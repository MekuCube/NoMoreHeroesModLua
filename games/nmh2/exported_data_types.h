// Exporter by @MekuCube

#pragma once

/// Forward Declaration

struct Vec;
struct stPcSaveData;
struct stBtEffect;
class mHRBattle;
class HrMissionResult;
class CHrHUDDemoButton;
class HrScreenStatusBalloon;
struct GXTexObj;
struct tagGHMR_TEX;
class HrScreenStatusSlot;
struct Rectf;
struct Vec2;
struct hPOINT;
class CNYDrawStringBase;
class NYDrawString;
class HrMap;
class NYPhase;
class CHrHUDBase;
class CHrHUDMoney;
class CHrHUDTension;
class HrScreenStatus;
class HrTask;
namespace EE
{
	template<typename T>
	class SmartPtr;
}
namespace EE
{
	class RefObject;
}
class GXTexture;
class GtSimplMes;
struct DVDCommandBlock;
struct DVDFileInfo;
class ghmGcFile;
struct DVDDiskID;
namespace EE
{
	class IFile;
}
struct BATTLESIMPLMESS_SET;
class HrEffectShutter;
class EfBase;
class EfSmoke;
class CTimeRatioInterpolate;
struct stFade;
class CSpringInterpolate;
class CDoubleSpringInterpolate;
class CAmbientShadow;
struct stCharaEffect;
class stCharaFileData;
class ghmSegment;
class ghmCapsule;
class ghmGcOctTreeNodeObj;
class ghmGcCollObj;
class ghmGcCollObjCapsule;
class WAnim;
class WAnimF;
struct stDamageInfo;
class ghmTriangle;
class ghmPlane;
class ghmGcCollObjHitResultObj;
struct stVec;
struct Quaternion;
struct stCharaStatus;
class ghmListObj;
struct CharControlMotID;
struct GXColor;
class vector4f;
class vector4x;
class tiVector;
namespace mot
{
	class IBoneEffectModel;
}
namespace mot
{
	class IBoneEffectModelPJ;
}
class TGmf;
class NYApproachToTargetVal;
class HrBattleIcon;
class mHRChara;
class HROBJDummy;
struct stTiger;
struct stHugWalk;
struct stPcEffect;
struct stPcSndData;
struct stDarkSideInfo;
struct stMiniDemo;
struct stPcStatus;
class mHRPc;
class ghmAABB;
class ghmGcOctTreeNode;
class ghmGcOctTree;
class ghmGcCollObjHitResult;
struct WGclMaterialSpec;
class ghmResGroup;
class ghmResStrTable;
class TGanPlay;
class TGan;
struct WGanSpec;
struct WGanMaterialSpec;
struct WGanFAnmSpec;
struct _WFAnmObjHeader;
struct _WFAnmObjKeyListHeader;
struct WGanMaterialLayerSpec;
struct WGanNodeSpec;
class TGanPlayNode;
class TFAnm;
class TGmfNode;
class CViewClipObjSphere;
class CViewClipObjBox;
class rPrimUnific;
class EfDestortion;
struct TGMFMESH;
struct rAlphaAnime;
struct rAnimeCounter;
struct rST;
struct rColor;
class rPrimBase;
class rTriangleList;
class CVertexAnimation;
class TFAnmObjF32_3;
class TFAnmObj;
namespace mot
{
	class IBoneEffectPJ;
}
class CCameraVibTiming;
struct HRCHARAVOICE;
namespace gameUtil
{
	class CPlane;
}
class CStickShadow;
class CharController;
class CObjectShadow;
struct stBikeEffect;
struct stBike;
class mHRBike;
class EventAreaCircle;
class ghmScriptVariables;
class ghmScript;
class ghmScriptFunc;
class HrScriptFunc;
class ghmScriptBase;
class CCameraCollision;
class FkPjLib;
class ghmScriptFuncArgBase;
struct ghmScriptObjectType;
class ghmScriptObject;
class ghmString;
struct ghmScrHeader;
struct ghmScrFuncHeader;
class ghmScriptProgFunc;
struct ghmScriptStackData;
class ghmScriptStack;
class ghmScriptContext;
class EveCorn;
class EventAreaCamera;
struct EVENTAREACAMERA_DATA;
class EffectDriftMark;
class EffectKeepSmoke;
class rQuad;
class EffectFixFire;
class EffectCloseContest;
class EfLineSpark;
class HrOverLap;
class CBgCtrl;
class rSkyMap;
class EffectSpeedBlur;
class rSkyMapMenu;
class HrStageDraw;
struct HRSAVEDATA_DEBUNEKO;
class PJState;
class ZkState_DownAttack;
class State_AwayAfterAttack;
class State_CloseBeforeAttack;
class State_StepInAttack;
class State_DownDamage;
class State_TojoBaseState;
class State_LeadPcWayPointMove;
class State_FixTurret;
class State_WayPointMoveAfterPop;
class State_Global;
class State_Dying;
class ZkState_Knife_Evacuation;
class ZkState_Knife_Defence;
class State_Close;
class State_NoProc;
class State_Caution;
class State_OutField;
class State_GoToFightLine;
class State_GetPcBehind;
class State_Debug;
class State_Guard;
class State_RunAway;
class State_Observ;
class State_PathFindToPc;
class State_UnderCtrl_Move;
class ZkState_FatBase_Defence;
class State_Tojo_RoomRunner;
class State_Tojo_AeroBike;
class State_Tojo_BreakCmnObj;
class State_Tojo_JumpOff;
class State_Tojo_Car;
class State_Tojo_RunAndTurnPc;
class State_Idle;
class State_Tojo_AgainstWall;
class State_Tojo_LookAround;
class State_Tojo_Stand;
class State_Tojo_Bench;
class State_Tojo_Sit;
class State_Tojo_SuddenAttack;
class State_ReleaseWaitIdle;
class State_Scare_Base;
class State_Scare_Kosinukasi;
class State_Scare_Run;
class State_WayPointMove;
class State_Pressure;
class State_ThroughDamage;
class State_Defence;
class State_Evacuate;
class State_ComboAttack;
class State_Damage;
struct CollInfo;
struct tagHRTASKCHECK;
struct ZkGuardParam;
struct ZkEvacuateParam;
class FkCounter;
struct ZkSetDamageInfo;
class State_Scare_Yotunbai;
class State_Scare_Stand;
class State_SideMove;
class State_RandomMove;
class State_PerformIll;
class PJZAKO;
class WGcl;
class commonObj;
struct WGclSpec;
struct WGclNodeSpec;
struct WGclNodeShapeMeshSpec;
struct WGclNodeShapeMeshBspNodeSpec;
struct WGclNodeShapeTriangleSpec;
class ghmGcColl;
class WGclNode;
class PJStateMachine;
class EffectDanmenFlash;
class EffectCutMark;
class EffectQuestion;
class PJZakoMotMng;
class PathPlanner;
class FkDynamicParam;
class FkObstacleSensor;
class FkBulletManager;
class EffectFkTobiDoguBase;
class rQuadEx;
class BoneStreamObj;
class EffectGunTrack;
namespace mot
{
	class CBoneEffectDamageData;
}
class PJTateshi;
class HrCamera;
class ghmSphere;
class ghmGcCollObjSphere;
struct RailCameraHead;
struct RailPath;
struct RailLink;
struct RailTriangle;
class CustomColliderObj;
struct KPADEXStatus;
struct KPADStatus;
class mHRPad;
class CSpringInterpolate3D;
class CDoubleSpringInterpolate3D;
class CGameDataLink;
namespace mot
{
	class CBoneEffectManager;
}
namespace mot
{
	class CBoneEffectPJ;
}
class CGameData;
class CPackFileDataElement;
class CFileData;
class CPackFileData;
class CGameDataManager;
namespace mot
{
	class IBoneEffect;
}
namespace mot
{
	class CIKManager;
}
namespace mot
{
	class CYuremonoManager;
}
class CLensFlare;
class HrKeyEvent;
class HrSkip;
class HrMiniDemo;
class HrMiniDemoObj;
class HrMiniDemoSound;
class mHRLockOnList;
class pcSNB;
class pcHEN;
class EffectEnemyDamage;
struct stThrowInfo;
class HrMessage;
class ghmGcFont;
struct GdlDialog;
struct GdlHeader;
class WGdl;
struct GdlLines;
struct GdlSentence;
class MessLines;
class ACameraModeBase;
class CCameraModeLockOn;
class HrTalk;
class HrSysMessage;
struct GFONT_MEMBER;
struct SYSMsIcon;
class mHRItem;
class PJZAKOBoneA;
class PJZAKOBoneB;
class State_StrongGlobal;
class ZkState_ChainSaw_Global;
class PJZAKOBoneC;
class State_FatTojo_EatPizza;
class PJZAKOBoneD;
template<typename T>
class KrBaseState;
class GLBDeathState;
class GLBWalkState;
class GLBComboState;
class GLBIdleState;
class GLBJampState;
template<typename T1, int T2>
class KrStateMachine;
class rSideScrollCamera;
class GLBDamageState;
class GLBGuardState;
class GLBAirKickState;
class pcGLB;
class EfRoboInterface;
class CmDeathState;
class SDPDeathState;
class SDPComboState;
class CmDamageState;
class SDPDamageState;
class SDPBeamState;
class CmIdleState;
class SDPIdleState;
class bsBasic;
class SDPMoveState;
class SDPGuardState;
class bsSDP;
class FkTriangleList;
class EffectModelBeam;
struct FkVtx;
class EfGeneralBeam;
class rGlobalData;
class JobMissionResult;
class PJJMBase;
class CMotionPlayer;
class CNYShopNPCTalkBase;
struct HRSAVEDATA_SHOP;
class PJZAKOBoneFive;
class HrScript;
class EveObj;
class HrMainMissionFax;
class CCameraVibManager;
class CCameraBank;
class CCameraModeSubjective;
class CCameraModePetitMovie;
class CCameraModeCircle;
class CCameraModeDefaultAngle;
class CCameraModeFree;
class CCameraModeNormal;
class CCameraModeReset;
class CCameraDistToLookAt;
class CCameraFollowRot;
class CCameraLookAtOffset;
class CCameraLookAtBase;
class CCameraDefaultAngle;
class CCameraLockOnModeData;
class CCameraNormalModeData;
class CCameraModeCommonData;
class CCameraDataManager;
class CCameraAreaManager;
namespace gameUtil
{
	class CPositionControl;
}
class CCameraTarget;
namespace ti
{
	class CCamera;
}
class CGameCamera;
class CCameraman;
class HrDemo;
struct HRDEMO_DATA;
class EffectSwordLaser;
class HrDemoObj;
class HrDemoMessage;
template<typename T>
class hList;
class hEffectManager;
class HrMiniDemoEffect;
struct STHrEffect;
template<typename T>
class hListObj;
class hEffPacket;
class hEffect;
class hEffectLayer;
struct hEffectKey;
struct HCOLOR;
struct hPerticleKey;
class hPerticle;
class hAnimTex;
struct hAnimChip;
class HrMiniDemoModel;
struct TGMFLIGHT;
class Archive;
struct tagDARC_HEAD;
struct tagDARC_FILETIME;
struct tagDARC_FILEHEAD;
struct tagDARC_DIRECTORY;
class STG0202;
struct GTEX_UVSET;
class EffectBoneElect;
class EffectMetalElect;
class PjSave;
class PJZakoCarBase;
class PJZakoCarVan;
class PJZakoCarSedan;
struct stRotDat;
class ZkState_HandGun_Shoot;
class ZkState_SubMachingeGun_Shoot;
class State_SubMachineGunDying;
class State_Tojo_Knife_SuddenAttack;
class ZkKnifeState_ThroughKnife;
class PJZakoKnife;
class ZkState_Kakuto_Hagaijime;
class ZkState_Kakuto_Global;
class State_ChainSawComboAttack;
class ZkState_ChainSaw_Close;
class bsSKE;
class bsLEZ;
class bsCEW;
class bsAST;
class bsRKT;
class PJOBJ0029;
class PJOBJ0033;
struct EFFECTSIMPLEOBJ3PARAM;
struct EFFECTMODELFIREPARAM;
class EffectModelFire;
class EffectSimpleObj3;
struct tagTLIST;
class PJOBJ0036;
class PJOBJ0037;
class PJOBJ0104;
class PJOBJ0155;
class PJOBJ0190;
class PJPTR;
class EfSnow;
struct NYPictData;
struct FkDbgInfo_EventArea;
class FkGlobalDBG;
class EffectBloodSplash;
class EffectSimpleObj2;
class EfBossDead;
class EfDeadString;
class EffectDemo2D;
class EffectFade;
class EfSubtitles;
class EffectSys;
class State_UnderCtrl_Attack;
struct NAGASU_MASU;
struct PIPE_MASU;
struct PJJMObjStatus;
class PJJMChar;
class PJJMPlumberItem;
class PJJMPlumberPc;
class SideMissionBase;
class EffectWaveBlow;
class EffectPop;
class EffectMuzzle;
class EffectSlashHit;
class FkBoss;
class EffectSlashTrack;
class EffectBeamDragon;
class EffectGYNMissile;
class EffectMoeMissile;
class NYMenuManager;
class INYTrainingCallBack;
class CNYTrainingManager;
class PJJobMissionManage;
class PJJMHarmfulInsect;
class PJJMPlumber;
class PJJMResult;
class hRECT;
template<typename T>
class hChildListObj;
class hGUIObj;
class hGUIWindow;
class hGUISlideBar;
class hGUIKeyFrame;
class hGUIUVEditor;
class hGUIMenuWindow;
class hGUIColorPicker;
class hGUICursor;
class hGUIManager;
class rCamera;
class hEffectEdit;
class hEffMenu;
class hGUIButton;
class hBj2Stage;
class hBj2Obj;
class hBj2Model;
class hBj2Player;
class hBj2ObjManager;
struct hBj2TimeTable;
class hBj2Fade;
struct tagHRSAVEDATA_STG;
class hStg2;
class Bj2Tile;
class ghmResAttr;

/// Full Declaration

// Unsupported operator
//int32_t `dynamic initializer for 'gHrCamera''()
// Unsupported operator
//int32_t `dynamic initializer for 'HrMap::s_quickMoveTarget2Name''()
// Unsupported operator
//int32_t `dynamic initializer for 'HrScreenStatus::uni''()
// Unsupported operator
//int32_t `dynamic initializer for 'mHRChara::mCharaAnchor''()
// Unsupported operator
//int32_t `dynamic initializer for 'HrMessage::m_TopNode''()
// Unsupported operator
//int32_t `dynamic initializer for 'HrTalk::uni''()
// Unsupported operator
//int32_t `dynamic initializer for 'HrSysMessage::uni''()
// Unsupported operator
//int32_t `dynamic initializer for 'mHRItem::mHRItemAnchor''()
// Unsupported operator
//int32_t `dynamic initializer for 'WGdl::mAnchor''()
// enum enPopReqType
enum enPopReqType : uint32_t
{
	// <ePopTypeDistance = 0x0>
	ePopTypeDistance = 0,

	// <ePopTypeAlways = 0x1>
	ePopTypeAlways = 1,

	// <ePopTypeOrder = 0x2>
	ePopTypeOrder = 2,

	// <ePopTypeOutOfCamera = 0x3>
	ePopTypeOutOfCamera = 3,

	// <ePopTypeMax = 0x4>
	ePopTypeMax = 4

};

// enum enCharaType
enum enCharaType : uint32_t
{
	// <eCharaTypeNone = 0x0>
	eCharaTypeNone = 0,

	// <eCharaTypePC = 0x1>
	eCharaTypePC = 1,

	// <CHARACTER_TYPE_ZAKO_BEGIN = 0x2>
	CHARACTER_TYPE_ZAKO_BEGIN = 2,

	// <eCharaTypeZKPipe = 0x3>
	eCharaTypeZKPipe = 3,

	// <eCharaTypeZKBat = 0x4>
	eCharaTypeZKBat = 4,

	// <eCharaTypeZKHandGun = 0x5>
	eCharaTypeZKHandGun = 5,

	// <eCharaTypeZKSubMachineGun = 0x6>
	eCharaTypeZKSubMachineGun = 6,

	// <eCharaTypeZKKnife = 0x7>
	eCharaTypeZKKnife = 7,

	// <eCharaTypeZKKakuto = 0x8>
	eCharaTypeZKKakuto = 8,

	// <eCharaTypeZKNihonto = 0x9>
	eCharaTypeZKNihonto = 9,

	// <eCharaTypeZKBeamKatana = 0xa>
	eCharaTypeZKBeamKatana = 10,

	// <eCharaTypeZKWarPick = 0xb>
	eCharaTypeZKWarPick = 11,

	// <eCharaTypeZKChainSaw = 0xc>
	eCharaTypeZKChainSaw = 12,

	// <eCharaTypeZKFiveNata = 0xd>
	eCharaTypeZKFiveNata = 13,

	// <eCharaTypeZKFiveHandGun = 0xe>
	eCharaTypeZKFiveHandGun = 14,

	// <eCharaTypeZKFiveMachineGun = 0xf>
	eCharaTypeZKFiveMachineGun = 15,

	// <CHARACTER_TYPE_ZAKO_END = 0x10>
	CHARACTER_TYPE_ZAKO_END = 16,

	// <CHARACTER_TYPE_BOSS_BEGIN = 0x11>
	CHARACTER_TYPE_BOSS_BEGIN = 17,

	// <eCharaTypeSKE = 0x12>
	eCharaTypeSKE = 18,

	// <eCharaTypeSPU = 0x13>
	eCharaTypeSPU = 19,

	// <eCharaTypeDSL = 0x14>
	eCharaTypeDSL = 20,

	// <eCharaTypeDSR = 0x15>
	eCharaTypeDSR = 21,

	// <eCharaTypeGSR = 0x16>
	eCharaTypeGSR = 22,

	// <eCharaTypePOP = 0x17>
	eCharaTypePOP = 23,

	// <eCharaTypeJPY = 0x18>
	eCharaTypeJPY = 24,

	// <eCharaTypeGYN = 0x19>
	eCharaTypeGYN = 25,

	// <eCharaTypeMGN = 0x1a>
	eCharaTypeMGN = 26,

	// <eCharaTypeMOE = 0x1b>
	eCharaTypeMOE = 27,

	// <eCharaTypeLEZ = 0x1c>
	eCharaTypeLEZ = 28,

	// <eCharaTypeCEW = 0x1d>
	eCharaTypeCEW = 29,

	// <eCharaTypeJBJA = 0x1e>
	eCharaTypeJBJA = 30,

	// <eCharaTypeJBJB = 0x1f>
	eCharaTypeJBJB = 31,

	// <eCharaTypeJBJC = 0x20>
	eCharaTypeJBJC = 32,

	// <eCharaTypeAST = 0x21>
	eCharaTypeAST = 33,

	// <eCharaTypeRKT = 0x22>
	eCharaTypeRKT = 34,

	// <eCharaTypeGLB = 0x23>
	eCharaTypeGLB = 35,

	// <eCharaTypeSDP = 0x24>
	eCharaTypeSDP = 36,

	// <eCharaTypeBIKJPY = 0x25>
	eCharaTypeBIKJPY = 37,

	// <CHARACTER_TYPE_BOSS_END = 0x26>
	CHARACTER_TYPE_BOSS_END = 38,

	// <eCharaTypePatroller = 0x27>
	eCharaTypePatroller = 39,

	// <eCharaTypeZKCar_Sedan = 0x28>
	eCharaTypeZKCar_Sedan = 40,

	// <eCharaTypeZKCar_Van = 0x29>
	eCharaTypeZKCar_Van = 41,

	// <eCharaTypePhotoCat = 0x2a>
	eCharaTypePhotoCat = 42,

	// <eCharaTypeFCA = 0x2b>
	eCharaTypeFCA = 43,

	// <eCharaTypeCommonNpc = 0x2c>
	eCharaTypeCommonNpc = 44,

	// <eCharaTypeScorpion = 0x2d>
	eCharaTypeScorpion = 45,

	// <eCharaTypeHelicopter = 0x2e>
	eCharaTypeHelicopter = 46,

	// <eCharaTypeCommonNpc_BUG = 0x2f>
	eCharaTypeCommonNpc_BUG = 47,

	// <eCharaTypeCommonNpc_PIPE = 0x30>
	eCharaTypeCommonNpc_PIPE = 48,

	// <eCharaTypeCommonNpc_COCONUT = 0x31>
	eCharaTypeCommonNpc_COCONUT = 49,

	// <eCharaTypeCommonNpc_DEBLI = 0x32>
	eCharaTypeCommonNpc_DEBLI = 50,

	// <eCharaTypeCommonNpc_PIZZA = 0x33>
	eCharaTypeCommonNpc_PIZZA = 51,

	// <eCharaTypeCommonNpc_TILE = 0x34>
	eCharaTypeCommonNpc_TILE = 52,

	// <eCharaTypeCommonNpc_STEAK = 0x35>
	eCharaTypeCommonNpc_STEAK = 53,

	// <eCharaTypeCommonNpc_SCORPION = 0x36>
	eCharaTypeCommonNpc_SCORPION = 54,

	// <eCharaTypeCommonNpc_CAR_BUG = 0x37>
	eCharaTypeCommonNpc_CAR_BUG = 55,

	// <eCharaTypeCommonNpc_CAR_PIPE = 0x38>
	eCharaTypeCommonNpc_CAR_PIPE = 56,

	// <eCharaTypeCommonNpc_CAR_COCONUT = 0x39>
	eCharaTypeCommonNpc_CAR_COCONUT = 57,

	// <eCharaTypeCommonNpc_CAR_DEBLI = 0x3a>
	eCharaTypeCommonNpc_CAR_DEBLI = 58,

	// <eCharaTypeCommonNpc_CAR_TILE = 0x3b>
	eCharaTypeCommonNpc_CAR_TILE = 59,

	// <eCharaTypeCommonNpc_CAR_STEAK = 0x3c>
	eCharaTypeCommonNpc_CAR_STEAK = 60,

	// <eCharaTypeCommonNpc_CAR_SCORPION = 0x3d>
	eCharaTypeCommonNpc_CAR_SCORPION = 61,

	// <eCharaTypeCmnObj = 0x3e8>
	eCharaTypeCmnObj = 1000,

	// <eCharaTypePlayerWeapon = 0x3e9>
	eCharaTypePlayerWeapon = 1001,

	// <eCustomColliderObject = 0x3ea>
	eCustomColliderObject = 1002

};

// enum eLightRefPriority
enum eLightRefPriority : uint32_t
{
	// <eLightRefPriority_MostHigh = 0x0>
	eLightRefPriority_MostHigh = 0,

	// <eLightRefPriority_PC_CUT = 0x1>
	eLightRefPriority_PC_CUT = 1,

	// <eLightRefPriority_GUARD = 0x2>
	eLightRefPriority_GUARD = 2,

	// <eLightRefPriority_MUZZLE_FLASH = 0x3>
	eLightRefPriority_MUZZLE_FLASH = 3,

	// <eLightRefPriority_Low = 0x4>
	eLightRefPriority_Low = 4

};

// [Structure] struct Vec
/// <summary>
/// 3D Vector (x, y, z). Y-up.
/// </summary>
struct Vec
{
public:
	/// Struct member variables

	// <float x, offset 0x0>
	float x = 0;

	// <float y, offset 0x4>
	float y = 0;

	// <float z, offset 0x8>
	float z = 0;

	/// 0 Functions

	/// Meta

	Vec() { x = 0; y = 0; z = 0; }
	Vec(float inX, float inY, float inZ) { x = inX; y = inY; z = inZ; }
	float Size() const { return sqrtf(x*x + y*y + z*z); }
	float SizeSquared() const { return x*x + y*y + z*z; }
	std::string ToString() const { std::stringstream stream; stream << "Vec(X: " << x << ", Y: " << y << ", Z: " << z << ") [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(Vec& InObject)
	{
		x = InObject.x;
		y = InObject.y;
		z = InObject.z;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Vec>("Vec")
			.addFunction("__tostring", &Vec::ToString)
			.addFunction("GetPtrAddr", &Vec::GetPtrAddr)
			.addProperty("x", &Vec::x)
			.addProperty("y", &Vec::y)
			.addProperty("z", &Vec::z)
			.addConstructor<void (*) (void)>()
			.addConstructor<void (*) (float, float, float)>()
			.addProperty("pitch", &Vec::x)
			.addProperty("yaw", &Vec::y)
			.addProperty("roll", &Vec::z)
			.addFunction("SizeSquared", &Vec::SizeSquared)
			.addFunction("Size", &Vec::Size)
		.endClass();
	}
#endif
};
static_assert(sizeof(Vec::x) == 4, "expected Vec::x to be size 4");
static_assert(sizeof(Vec::y) == 4, "expected Vec::y to be size 4");
static_assert(sizeof(Vec::z) == 4, "expected Vec::z to be size 4");
static_assert(sizeof(Vec) == 0xc, "expected Vec to be size 0xc");

// enum enBattleFrameProc
enum enBattleFrameProc : uint32_t
{
	// <eBtlFrameInit = 0x0>
	eBtlFrameInit = 0,

	// <eBtlFrameMain = 0x1>
	eBtlFrameMain = 1,

	// <eBtlFramePcTermWait = 0x2>
	eBtlFramePcTermWait = 2,

	// <eBtlFramePcInitWait = 0x3>
	eBtlFramePcInitWait = 3,

	// <eBtlFrameReleaseNpc = 0x4>
	eBtlFrameReleaseNpc = 4

};

// [Structure] struct stPcSaveData
struct stPcSaveData
{
public:
	/// Struct member variables

	// <float maxHp, offset 0x0>
	float maxHp = 0;

	// <float hp, offset 0x4>
	float hp = 0;

	// <int32_t WeaponID1, offset 0x8>
	int32_t WeaponID1 = 0;

	// <int16_t CurBattery1, offset 0xc>
	int16_t CurBattery1 = 0;

	// <int16_t MaxBattery1, offset 0xe>
	int16_t MaxBattery1 = 0;

	// <Unidentified data segment, offset 0x10>
private:
	char _UnidentifiedData_16[4];

public:
	// <uint8_t CmbExtend1, offset 0x14>
	uint8_t CmbExtend1 = 0;

	// <Unidentified data segment, offset 0x15>
private:
	char _UnidentifiedData_21[1479];

public:
	// <int32_t CurMoney, offset 0x5dc>
	int32_t CurMoney = 0;

	// <Unidentified data segment, offset 0x5e0>
private:
	char _UnidentifiedData_1504[49];

public:
	// <bool LostBikeFlag, offset 0x611>
	bool LostBikeFlag;

	// <Unidentified data segment, offset 0x612>
private:
	char _UnidentifiedData_1554[82];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stPcSaveData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stPcSaveData& InObject)
	{
		maxHp = InObject.maxHp;
		hp = InObject.hp;
		WeaponID1 = InObject.WeaponID1;
		CurBattery1 = InObject.CurBattery1;
		MaxBattery1 = InObject.MaxBattery1;
		CmbExtend1 = InObject.CmbExtend1;
		CurMoney = InObject.CurMoney;
		LostBikeFlag = InObject.LostBikeFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcSaveData>("stPcSaveData")
			.addFunction("__tostring", &stPcSaveData::ToString)
			.addFunction("GetPtrAddr", &stPcSaveData::GetPtrAddr)
			.addProperty("maxHp", &stPcSaveData::maxHp)
			.addProperty("hp", &stPcSaveData::hp)
			.addProperty("WeaponID1", &stPcSaveData::WeaponID1)
			.addProperty("CurBattery1", &stPcSaveData::CurBattery1)
			.addProperty("MaxBattery1", &stPcSaveData::MaxBattery1)
			.addProperty("CmbExtend1", &stPcSaveData::CmbExtend1)
			.addProperty("CurMoney", &stPcSaveData::CurMoney)
			.addProperty("LostBikeFlag", &stPcSaveData::LostBikeFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcSaveData::maxHp) == 4, "expected stPcSaveData::maxHp to be size 4");
static_assert(sizeof(stPcSaveData::hp) == 4, "expected stPcSaveData::hp to be size 4");
static_assert(sizeof(stPcSaveData::WeaponID1) == 4, "expected stPcSaveData::WeaponID1 to be size 4");
static_assert(sizeof(stPcSaveData::CurBattery1) == 2, "expected stPcSaveData::CurBattery1 to be size 2");
static_assert(sizeof(stPcSaveData::MaxBattery1) == 2, "expected stPcSaveData::MaxBattery1 to be size 2");
static_assert(sizeof(stPcSaveData::CmbExtend1) == 1, "expected stPcSaveData::CmbExtend1 to be size 1");
static_assert(sizeof(stPcSaveData::CurMoney) == 4, "expected stPcSaveData::CurMoney to be size 4");
static_assert(sizeof(stPcSaveData::LostBikeFlag) == 1, "expected stPcSaveData::LostBikeFlag to be size 1");
static_assert(sizeof(stPcSaveData) == 0x664, "expected stPcSaveData to be size 0x664");

// enum enPcKind
/// <summary>
/// Player character type (Travis, Shinobu, Henry)
/// </summary>
enum enPcKind : uint32_t
{
	// <ePcUndefined = 0xffffffffffffffff>
	ePcUndefined = UINT32_MAX,

	// <ePcTRV = 0x0>
	ePcTRV = 0,

	// <ePcSNB = 0x1>
	ePcSNB = 1,

	// <ePcHEN = 0x2>
	ePcHEN = 2,

	// <ePcKindMax = 0x3>
	ePcKindMax = 3

};

// [Structure] struct stBtEffect
struct stBtEffect
{
public:
	// enum stBtEffect::SlowType
	enum SlowType : uint32_t
	{
		// <FinishInput = 0x0>
		FinishInput = 0,

		// <BossFinish = 0x1>
		BossFinish = 1

	};

	/// Struct member variables

	// <class HrScreenStatus* pScreenStatus, offset 0x0>
	class HrScreenStatus* pScreenStatus = nullptr;

	// <class HrEffectShutter* pShutter, offset 0x4>
	class HrEffectShutter* pShutter = nullptr;

	// <class EfSmoke* pSmoke, offset 0x8>
	class EfSmoke* pSmoke = nullptr;

	// <int32_t slowMotTotalTick, offset 0xc>
	int32_t slowMotTotalTick = 0;

	// <int32_t slowMotTick, offset 0x10>
	int32_t slowMotTick = 0;

	// <enum stBtEffect::SlowType slowType, offset 0x14>
	enum stBtEffect::SlowType slowType;

	// <int32_t bulletSlowTick, offset 0x18>
	int32_t bulletSlowTick = 0;

	// <int32_t bossBreakSlowTick, offset 0x1c>
	int32_t bossBreakSlowTick = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stBtEffect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stBtEffect& InObject)
	{
		pScreenStatus = InObject.pScreenStatus;
		pShutter = InObject.pShutter;
		pSmoke = InObject.pSmoke;
		slowMotTotalTick = InObject.slowMotTotalTick;
		slowMotTick = InObject.slowMotTick;
		slowType = InObject.slowType;
		bulletSlowTick = InObject.bulletSlowTick;
		bossBreakSlowTick = InObject.bossBreakSlowTick;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stBtEffect>("stBtEffect")
			.addFunction("__tostring", &stBtEffect::ToString)
			.addFunction("GetPtrAddr", &stBtEffect::GetPtrAddr)
			.addProperty("pScreenStatus", &stBtEffect::pScreenStatus)
			.addProperty("pShutter", &stBtEffect::pShutter)
			.addProperty("pSmoke", &stBtEffect::pSmoke)
			.addProperty("slowMotTotalTick", &stBtEffect::slowMotTotalTick)
			.addProperty("slowMotTick", &stBtEffect::slowMotTick)
			.addProperty("slowType", &stBtEffect::slowType)
			.addProperty("bulletSlowTick", &stBtEffect::bulletSlowTick)
			.addProperty("bossBreakSlowTick", &stBtEffect::bossBreakSlowTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(stBtEffect::pScreenStatus) == 4, "expected stBtEffect::pScreenStatus to be size 4");
static_assert(sizeof(stBtEffect::pShutter) == 4, "expected stBtEffect::pShutter to be size 4");
static_assert(sizeof(stBtEffect::pSmoke) == 4, "expected stBtEffect::pSmoke to be size 4");
static_assert(sizeof(stBtEffect::slowMotTotalTick) == 4, "expected stBtEffect::slowMotTotalTick to be size 4");
static_assert(sizeof(stBtEffect::slowMotTick) == 4, "expected stBtEffect::slowMotTick to be size 4");
static_assert(sizeof(stBtEffect::slowType) == 4, "expected stBtEffect::slowType to be size 4");
static_assert(sizeof(stBtEffect::bulletSlowTick) == 4, "expected stBtEffect::bulletSlowTick to be size 4");
static_assert(sizeof(stBtEffect::bossBreakSlowTick) == 4, "expected stBtEffect::bossBreakSlowTick to be size 4");
static_assert(sizeof(stBtEffect) == 0x20, "expected stBtEffect to be size 0x20");

// [Structure] class mHRBattle
class mHRBattle
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[4];

public:
	// <int32_t PlayerInitializedState, offset 0x4>
	int32_t PlayerInitializedState = 0;

	// <Unidentified data segment, offset 0x8>
private:
	char _UnidentifiedData_8[4];

public:
	// <float CameraProjection, offset 0xc>
	float CameraProjection = 0;

	// <Unidentified data segment, offset 0x10>
private:
	char _UnidentifiedData_16[12];

public:
	// <uint8_t LockNavelPos, offset 0x1c>
	uint8_t LockNavelPos = 0;

	// <Unidentified data segment, offset 0x1d>
private:
	char _UnidentifiedData_29[304];

public:
	// <uint8_t CameraMotionEndStop, offset 0x14d>
	uint8_t CameraMotionEndStop = 0;

	// <Unidentified data segment, offset 0x14e>
private:
	char _UnidentifiedData_334[2];

public:
	// <struct stBtEffect btEffect, offset 0x150>
	struct stBtEffect btEffect;

	// <Unidentified data segment, offset 0x170>
private:
	char _UnidentifiedData_368[24];

public:
	// <enum enPcKind PcKind, offset 0x188>
	enum enPcKind PcKind;

	// <class mHRPc* PcPtr, offset 0x18c>
	class mHRPc* PcPtr = nullptr;

	// <Unidentified data segment, offset 0x190>
private:
	char _UnidentifiedData_400[1076];

public:
	// <int32_t WeaponType, offset 0x5c4>
	int32_t WeaponType = 0;

	// <Unidentified data segment, offset 0x5c8>
private:
	char _UnidentifiedData_1480[564];

public:
	// <void* UnknownWeaponPtr, offset 0x7fc>
	void* UnknownWeaponPtr = nullptr;

	// <Unidentified data segment, offset 0x800>
private:
	char _UnidentifiedData_2048[142760];

public:
	// <int32_t TotalKillNum, offset 0x235a8>
	int32_t TotalKillNum = 0;

	// <int32_t KillNum, offset 0x235ac>
	int32_t KillNum = 0;

	// <int32_t RevengeMissionZakoKillNum, offset 0x235b0>
	int32_t RevengeMissionZakoKillNum = 0;

	// <Unidentified data segment, offset 0x235b4>
private:
	char _UnidentifiedData_144820[16];

public:
	// <float NpcAttackRate, offset 0x235c4>
	float NpcAttackRate = 0;

	// <int32_t UnknownInt, offset 0x235c8>
	int32_t UnknownInt = 0;

	// <uint8_t NewGameDataRequest, offset 0x235cc>
	uint8_t NewGameDataRequest = 0;

	// <Unidentified data segment, offset 0x235cd>
private:
	char _UnidentifiedData_144845[7];

public:
	// <struct stPcSaveData SaveData, offset 0x235d4>
	struct stPcSaveData SaveData;

	// <Unidentified data segment, offset 0x23c38>
private:
	char _UnidentifiedData_146488[4];

public:
	/// 170 Functions

	// [Function] class mHRPc* __convention("thiscall") mHRBattle::mGetPcPtr(class mHRBattle* const this) [?mGetPcPtr@mHRBattle@@QAEPAVmHRPc@@XZ]
	typedef class mHRPc*(__thiscall* _mGetPcPtr_mHRBattle__QAEPAVmHRPc__XZ)(class mHRBattle* const thisPtr);
	class mHRPc* mGetPcPtr()
	{
		_mGetPcPtr_mHRBattle__QAEPAVmHRPc__XZ mFunc = (_mGetPcPtr_mHRBattle__QAEPAVmHRPc__XZ)(GameModule + 0x9c010);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetSlowMotionTick(class mHRBattle* const this) [?mGetSlowMotionTick@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetSlowMotionTick_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t mGetSlowMotionTick()
	{
		_mGetSlowMotionTick_mHRBattle__QAEHXZ mFunc = (_mGetSlowMotionTick_mHRBattle__QAEHXZ)(GameModule + 0x9cdf0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetBulletSlow(class mHRBattle* const this) [?mGetBulletSlow@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetBulletSlow_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t mGetBulletSlow()
	{
		_mGetBulletSlow_mHRBattle__QAEHXZ mFunc = (_mGetBulletSlow_mHRBattle__QAEHXZ)(GameModule + 0x9ce00);
		return mFunc(this);
	}
	// [Function] struct stBtEffect* __convention("thiscall") mHRBattle::mGetBtEffect(class mHRBattle* const this) [?mGetBtEffect@mHRBattle@@QAEPAUstBtEffect@@XZ]
	typedef struct stBtEffect*(__thiscall* _mGetBtEffect_mHRBattle__QAEPAUstBtEffect__XZ)(class mHRBattle* const thisPtr);
	struct stBtEffect* mGetBtEffect()
	{
		_mGetBtEffect_mHRBattle__QAEPAUstBtEffect__XZ mFunc = (_mGetBtEffect_mHRBattle__QAEPAUstBtEffect__XZ)(GameModule + 0x9ce10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetNpcAttackFlag(class mHRBattle* const this, uint8_t arg2) [?mSetNpcAttackFlag@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetNpcAttackFlag_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetNpcAttackFlag(uint8_t arg2)
	{
		_mSetNpcAttackFlag_mHRBattle__QAEX_N_Z mFunc = (_mSetNpcAttackFlag_mHRBattle__QAEX_N_Z)(GameModule + 0x9ce20);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRBattle::mSetNpcAttackRate(class mHRBattle* const this, float arg2) [?mSetNpcAttackRate@mHRBattle@@QAEMM@Z]
	typedef float(__thiscall* _mSetNpcAttackRate_mHRBattle__QAEMM_Z)(class mHRBattle* const thisPtr, float arg2);
	float mSetNpcAttackRate(float arg2)
	{
		_mSetNpcAttackRate_mHRBattle__QAEMM_Z mFunc = (_mSetNpcAttackRate_mHRBattle__QAEMM_Z)(GameModule + 0x9ce50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::SetNpcDatMax(class mHRBattle* const this, int32_t arg2) [?SetNpcDatMax@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _SetNpcDatMax_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void SetNpcDatMax(int32_t arg2)
	{
		_SetNpcDatMax_mHRBattle__QAEXH_Z mFunc = (_SetNpcDatMax_mHRBattle__QAEXH_Z)(GameModule + 0x9ce90);
		return mFunc(this, arg2);
	}
	// [Function] class EfSmoke* __convention("thiscall") mHRBattle::GetSmokeEf(class mHRBattle* const this) [?GetSmokeEf@mHRBattle@@QAEPAVEfSmoke@@XZ]
	typedef class EfSmoke*(__thiscall* _GetSmokeEf_mHRBattle__QAEPAVEfSmoke__XZ)(class mHRBattle* const thisPtr);
	class EfSmoke* GetSmokeEf()
	{
		_GetSmokeEf_mHRBattle__QAEPAVEfSmoke__XZ mFunc = (_GetSmokeEf_mHRBattle__QAEPAVEfSmoke__XZ)(GameModule + 0x9fbf0);
		return mFunc(this);
	}
	// [Function] enum enPcKind __convention("thiscall") mHRBattle::mGetPcKind(class mHRBattle* const this) [?mGetPcKind@mHRBattle@@QAE?AW4enPcKind@@XZ]
	typedef enum enPcKind(__thiscall* _mGetPcKind_mHRBattle__QAEAW4enPcKind__XZ)(class mHRBattle* const thisPtr);
	/* enum enPcKind */ uint32_t mGetPcKind()
	{
		_mGetPcKind_mHRBattle__QAEAW4enPcKind__XZ mFunc = (_mGetPcKind_mHRBattle__QAEAW4enPcKind__XZ)(GameModule + 0xa2060);
		return (uint32_t)mFunc(this);
	}
	// [Function] enum enBattleFrameProc __convention("thiscall") mHRBattle::mGetFrameProc(class mHRBattle* const this) [?mGetFrameProc@mHRBattle@@QAE?AW4enBattleFrameProc@@XZ]
	typedef enum enBattleFrameProc(__thiscall* _mGetFrameProc_mHRBattle__QAEAW4enBattleFrameProc__XZ)(class mHRBattle* const thisPtr);
	/* enum enBattleFrameProc */ uint32_t mGetFrameProc()
	{
		_mGetFrameProc_mHRBattle__QAEAW4enBattleFrameProc__XZ mFunc = (_mGetFrameProc_mHRBattle__QAEAW4enBattleFrameProc__XZ)(GameModule + 0xa2070);
		return (uint32_t)mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraAngle(class mHRBattle* const this, float arg2) [?mSetCameraAngle@mHRBattle@@QAEXM@Z]
	typedef void(__thiscall* _mSetCameraAngle_mHRBattle__QAEXM_Z)(class mHRBattle* const thisPtr, float arg2);
	void mSetCameraAngle(float arg2)
	{
		_mSetCameraAngle_mHRBattle__QAEXM_Z mFunc = (_mSetCameraAngle_mHRBattle__QAEXM_Z)(GameModule + 0xa2080);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCamMotFlag(class mHRBattle* const this, uint8_t arg2) [?mSetCamMotFlag@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCamMotFlag_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetCamMotFlag(uint8_t arg2)
	{
		_mSetCamMotFlag_mHRBattle__QAEX_N_Z mFunc = (_mSetCamMotFlag_mHRBattle__QAEX_N_Z)(GameModule + 0xa20b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCamMotFlagNoUse(class mHRBattle* const this, uint8_t arg2) [?mSetCamMotFlagNoUse@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCamMotFlagNoUse_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetCamMotFlagNoUse(uint8_t arg2)
	{
		_mSetCamMotFlagNoUse_mHRBattle__QAEX_N_Z mFunc = (_mSetCamMotFlagNoUse_mHRBattle__QAEX_N_Z)(GameModule + 0xa20c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraAutoReturnDisEnable(class mHRBattle* const this, uint8_t arg2) [?mSetCameraAutoReturnDisEnable@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCameraAutoReturnDisEnable_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetCameraAutoReturnDisEnable(uint8_t arg2)
	{
		_mSetCameraAutoReturnDisEnable_mHRBattle__QAEX_N_Z mFunc = (_mSetCameraAutoReturnDisEnable_mHRBattle__QAEX_N_Z)(GameModule + 0xa20e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mClearKillNum(class mHRBattle* const this) [?mClearKillNum@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mClearKillNum_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mClearKillNum()
	{
		_mClearKillNum_mHRBattle__QAEXXZ mFunc = (_mClearKillNum_mHRBattle__QAEXXZ)(GameModule + 0xa2100);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetKillNum(class mHRBattle* const this) [?mGetKillNum@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetKillNum_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t mGetKillNum()
	{
		_mGetKillNum_mHRBattle__QAEHXZ mFunc = (_mGetKillNum_mHRBattle__QAEHXZ)(GameModule + 0xa2110);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetKillNum(class mHRBattle* const this, int32_t arg2) [?mSetKillNum@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mSetKillNum_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mSetKillNum(int32_t arg2)
	{
		_mSetKillNum_mHRBattle__QAEXH_Z mFunc = (_mSetKillNum_mHRBattle__QAEXH_Z)(GameModule + 0xa2120);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::GetRevengeMissionZakoKillNum(class mHRBattle* const this) [?GetRevengeMissionZakoKillNum@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _GetRevengeMissionZakoKillNum_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t GetRevengeMissionZakoKillNum()
	{
		_GetRevengeMissionZakoKillNum_mHRBattle__QAEHXZ mFunc = (_GetRevengeMissionZakoKillNum_mHRBattle__QAEHXZ)(GameModule + 0xa2140);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::ClearRevengeMissionZakoKillNum(class mHRBattle* const this) [?ClearRevengeMissionZakoKillNum@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _ClearRevengeMissionZakoKillNum_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void ClearRevengeMissionZakoKillNum()
	{
		_ClearRevengeMissionZakoKillNum_mHRBattle__QAEXXZ mFunc = (_ClearRevengeMissionZakoKillNum_mHRBattle__QAEXXZ)(GameModule + 0xa2150);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetBattlePause(class mHRBattle* const this, uint8_t arg2) [?mSetBattlePause@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBattlePause_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetBattlePause(uint8_t arg2)
	{
		_mSetBattlePause_mHRBattle__QAEX_N_Z mFunc = (_mSetBattlePause_mHRBattle__QAEX_N_Z)(GameModule + 0xa2160);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetDispStatusDisEnable(class mHRBattle* const this, uint8_t arg2) [?mSetDispStatusDisEnable@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDispStatusDisEnable_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetDispStatusDisEnable(uint8_t arg2)
	{
		_mSetDispStatusDisEnable_mHRBattle__QAEX_N_Z mFunc = (_mSetDispStatusDisEnable_mHRBattle__QAEX_N_Z)(GameModule + 0xa2190);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetDispStatusDisEnable(class mHRBattle* const this) [?mGetDispStatusDisEnable@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDispStatusDisEnable_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetDispStatusDisEnable()
	{
		_mGetDispStatusDisEnable_mHRBattle__QAE_NXZ mFunc = (_mGetDispStatusDisEnable_mHRBattle__QAE_NXZ)(GameModule + 0xa21b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetChargeDamage(class mHRBattle* const this, uint8_t arg2) [?mSetChargeDamage@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetChargeDamage_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetChargeDamage(uint8_t arg2)
	{
		_mSetChargeDamage_mHRBattle__QAEX_N_Z mFunc = (_mSetChargeDamage_mHRBattle__QAEX_N_Z)(GameModule + 0xa21c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mClearTotalKillNum(class mHRBattle* const this) [?mClearTotalKillNum@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mClearTotalKillNum_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mClearTotalKillNum()
	{
		_mClearTotalKillNum_mHRBattle__QAEXXZ mFunc = (_mClearTotalKillNum_mHRBattle__QAEXXZ)(GameModule + 0xa3860);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetTutoRun(class mHRBattle* const this) [?mGetTutoRun@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetTutoRun_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetTutoRun()
	{
		_mGetTutoRun_mHRBattle__QAE_NXZ mFunc = (_mGetTutoRun_mHRBattle__QAE_NXZ)(GameModule + 0xa3870);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSubRepopNum(class mHRBattle* const this, int32_t arg2) [?mSubRepopNum@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mSubRepopNum_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mSubRepopNum(int32_t arg2)
	{
		_mSubRepopNum_mHRBattle__QAEXH_Z mFunc = (_mSubRepopNum_mHRBattle__QAEXH_Z)(GameModule + 0xa4750);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetRepopTimer(class mHRBattle* const this, int32_t arg2, int32_t arg3) [?mSetRepopTimer@mHRBattle@@QAEXHH@Z]
	typedef void(__thiscall* _mSetRepopTimer_mHRBattle__QAEXHH_Z)(class mHRBattle* const thisPtr, int32_t arg2, int32_t arg3);
	void mSetRepopTimer(int32_t arg2, int32_t arg3)
	{
		_mSetRepopTimer_mHRBattle__QAEXHH_Z mFunc = (_mSetRepopTimer_mHRBattle__QAEXHH_Z)(GameModule + 0xa4770);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetNewGameDataRequest(class mHRBattle* const this) [?mGetNewGameDataRequest@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetNewGameDataRequest_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetNewGameDataRequest()
	{
		_mGetNewGameDataRequest_mHRBattle__QAE_NXZ mFunc = (_mGetNewGameDataRequest_mHRBattle__QAE_NXZ)(GameModule + 0xa5290);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetDontChangeTeppeiCamera(class mHRBattle* const this) [?mGetDontChangeTeppeiCamera@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDontChangeTeppeiCamera_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetDontChangeTeppeiCamera()
	{
		_mGetDontChangeTeppeiCamera_mHRBattle__QAE_NXZ mFunc = (_mGetDontChangeTeppeiCamera_mHRBattle__QAE_NXZ)(GameModule + 0xa52a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRBattle::mGetCameraProjection(class mHRBattle* const this) [?mGetCameraProjection@mHRBattle@@QAEMXZ]
	typedef float(__thiscall* _mGetCameraProjection_mHRBattle__QAEMXZ)(class mHRBattle* const thisPtr);
	float mGetCameraProjection()
	{
		_mGetCameraProjection_mHRBattle__QAEMXZ mFunc = (_mGetCameraProjection_mHRBattle__QAEMXZ)(GameModule + 0xa52b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraMoveFlag(class mHRBattle* const this, uint8_t arg2) [?mSetCameraMoveFlag@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCameraMoveFlag_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetCameraMoveFlag(uint8_t arg2)
	{
		_mSetCameraMoveFlag_mHRBattle__QAEX_N_Z mFunc = (_mSetCameraMoveFlag_mHRBattle__QAEX_N_Z)(GameModule + 0xa52c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetMotionCameraPos(class mHRBattle* const this, struct Vec* arg2) [?mSetMotionCameraPos@mHRBattle@@QAEXPAUVec@@@Z]
	typedef void(__thiscall* _mSetMotionCameraPos_mHRBattle__QAEXPAUVec___Z)(class mHRBattle* const thisPtr, struct Vec* arg2);
	void mSetMotionCameraPos(struct Vec* arg2)
	{
		_mSetMotionCameraPos_mHRBattle__QAEXPAUVec___Z mFunc = (_mSetMotionCameraPos_mHRBattle__QAEXPAUVec___Z)(GameModule + 0xa52d0);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec* __convention("thiscall") mHRBattle::mGetMotionCameraPos(class mHRBattle* const this) [?mGetMotionCameraPos@mHRBattle@@QAEPAUVec@@XZ]
	typedef struct Vec*(__thiscall* _mGetMotionCameraPos_mHRBattle__QAEPAUVec__XZ)(class mHRBattle* const thisPtr);
	struct Vec* mGetMotionCameraPos()
	{
		_mGetMotionCameraPos_mHRBattle__QAEPAUVec__XZ mFunc = (_mGetMotionCameraPos_mHRBattle__QAEPAUVec__XZ)(GameModule + 0xa52e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetMotionCameraY(class mHRBattle* const this, float* arg2) [?mSetMotionCameraY@mHRBattle@@QAEXPAM@Z]
	typedef void(__thiscall* _mSetMotionCameraY_mHRBattle__QAEXPAM_Z)(class mHRBattle* const thisPtr, float* arg2);
	void mSetMotionCameraY(float* arg2)
	{
		_mSetMotionCameraY_mHRBattle__QAEXPAM_Z mFunc = (_mSetMotionCameraY_mHRBattle__QAEXPAM_Z)(GameModule + 0xa52f0);
		return mFunc(this, arg2);
	}
	// [Function] float* __convention("thiscall") mHRBattle::mGetMotionCameraY(class mHRBattle* const this) [?mGetMotionCameraY@mHRBattle@@QAEPAMXZ]
	typedef float*(__thiscall* _mGetMotionCameraY_mHRBattle__QAEPAMXZ)(class mHRBattle* const thisPtr);
	// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetMotionCameraY()
	{
		_mGetMotionCameraY_mHRBattle__QAEPAMXZ mFunc = (_mGetMotionCameraY_mHRBattle__QAEPAMXZ)(GameModule + 0xa5300);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetBattlePause(class mHRBattle* const this) [?mGetBattlePause@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBattlePause_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetBattlePause()
	{
		_mGetBattlePause_mHRBattle__QAE_NXZ mFunc = (_mGetBattlePause_mHRBattle__QAE_NXZ)(GameModule + 0xa5310);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetChargeDamage(class mHRBattle* const this) [?mGetChargeDamage@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetChargeDamage_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetChargeDamage()
	{
		_mGetChargeDamage_mHRBattle__QAE_NXZ mFunc = (_mGetChargeDamage_mHRBattle__QAE_NXZ)(GameModule + 0xa5320);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetChangeCameraRailFlag(class mHRBattle* const this) [?mGetChangeCameraRailFlag@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetChangeCameraRailFlag_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetChangeCameraRailFlag()
	{
		_mGetChangeCameraRailFlag_mHRBattle__QAE_NXZ mFunc = (_mGetChangeCameraRailFlag_mHRBattle__QAE_NXZ)(GameModule + 0xaa7a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRBattle::mGetCameraAngleX(class mHRBattle* const this) [?mGetCameraAngleX@mHRBattle@@QAEMXZ]
	typedef float(__thiscall* _mGetCameraAngleX_mHRBattle__QAEMXZ)(class mHRBattle* const thisPtr);
	float mGetCameraAngleX()
	{
		_mGetCameraAngleX_mHRBattle__QAEMXZ mFunc = (_mGetCameraAngleX_mHRBattle__QAEMXZ)(GameModule + 0xaa7c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLockNavelPos(class mHRBattle* const this, uint8_t arg2) [?mSetLockNavelPos@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetLockNavelPos_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetLockNavelPos(uint8_t arg2)
	{
		_mSetLockNavelPos_mHRBattle__QAEX_N_Z mFunc = (_mSetLockNavelPos_mHRBattle__QAEX_N_Z)(GameModule + 0xaa7d0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetTotalKillNum(class mHRBattle* const this) [?mGetTotalKillNum@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetTotalKillNum_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t mGetTotalKillNum()
	{
		_mGetTotalKillNum_mHRBattle__QAEHXZ mFunc = (_mGetTotalKillNum_mHRBattle__QAEHXZ)(GameModule + 0xaa7f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetTotalKillNum(class mHRBattle* const this, int32_t arg2) [?mSetTotalKillNum@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mSetTotalKillNum_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mSetTotalKillNum(int32_t arg2)
	{
		_mSetTotalKillNum_mHRBattle__QAEXH_Z mFunc = (_mSetTotalKillNum_mHRBattle__QAEXH_Z)(GameModule + 0xaa800);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetBossBreakSlow(class mHRBattle* const this) [?mGetBossBreakSlow@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetBossBreakSlow_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t mGetBossBreakSlow()
	{
		_mGetBossBreakSlow_mHRBattle__QAEHXZ mFunc = (_mGetBossBreakSlow_mHRBattle__QAEHXZ)(GameModule + 0xaffb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetNpcAttackFlag(class mHRBattle* const this) [?mGetNpcAttackFlag@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetNpcAttackFlag_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetNpcAttackFlag()
	{
		_mGetNpcAttackFlag_mHRBattle__QAE_NXZ mFunc = (_mGetNpcAttackFlag_mHRBattle__QAE_NXZ)(GameModule + 0xbade0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRBattle::mGetNpcAttackRate(class mHRBattle* const this) [?mGetNpcAttackRate@mHRBattle@@QAEMXZ]
	typedef float(__thiscall* _mGetNpcAttackRate_mHRBattle__QAEMXZ)(class mHRBattle* const thisPtr);
	float mGetNpcAttackRate()
	{
		_mGetNpcAttackRate_mHRBattle__QAEMXZ mFunc = (_mGetNpcAttackRate_mHRBattle__QAEMXZ)(GameModule + 0xbae00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::AddRevengeMissionZakoKillNum(class mHRBattle* const this) [?AddRevengeMissionZakoKillNum@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _AddRevengeMissionZakoKillNum_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void AddRevengeMissionZakoKillNum()
	{
		_AddRevengeMissionZakoKillNum_mHRBattle__QAEXXZ mFunc = (_AddRevengeMissionZakoKillNum_mHRBattle__QAEXXZ)(GameModule + 0xbae10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::SetCameraMotionEndStop(class mHRBattle* const this, uint8_t arg2) [?SetCameraMotionEndStop@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _SetCameraMotionEndStop_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void SetCameraMotionEndStop(uint8_t arg2)
	{
		_SetCameraMotionEndStop_mHRBattle__QAEX_N_Z mFunc = (_SetCameraMotionEndStop_mHRBattle__QAEX_N_Z)(GameModule + 0xc1f40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::IsBgmEffect(class mHRBattle* const this) [?IsBgmEffect@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsBgmEffect_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t IsBgmEffect()
	{
		_IsBgmEffect_mHRBattle__QAE_NXZ mFunc = (_IsBgmEffect_mHRBattle__QAE_NXZ)(GameModule + 0xc64c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetDontChangeTeppeiCamera(class mHRBattle* const this, uint8_t arg2) [?mSetDontChangeTeppeiCamera@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDontChangeTeppeiCamera_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetDontChangeTeppeiCamera(uint8_t arg2)
	{
		_mSetDontChangeTeppeiCamera_mHRBattle__QAEX_N_Z mFunc = (_mSetDontChangeTeppeiCamera_mHRBattle__QAEX_N_Z)(GameModule + 0xc8b00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::UpdateMassKillAchievement(class mHRBattle* const this) [?UpdateMassKillAchievement@mHRBattle@@AAEXXZ]
	typedef void(__thiscall* _UpdateMassKillAchievement_mHRBattle__AAEXXZ)(class mHRBattle* const thisPtr);
	void UpdateMassKillAchievement()
	{
		_UpdateMassKillAchievement_mHRBattle__AAEXXZ mFunc = (_UpdateMassKillAchievement_mHRBattle__AAEXXZ)(GameModule + 0x3f38c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::UpdateMainScreenUI(class mHRBattle* const this) [?UpdateMainScreenUI@mHRBattle@@AAEXXZ]
	typedef void(__thiscall* _UpdateMainScreenUI_mHRBattle__AAEXXZ)(class mHRBattle* const thisPtr);
	void UpdateMainScreenUI()
	{
		_UpdateMainScreenUI_mHRBattle__AAEXXZ mFunc = (_UpdateMainScreenUI_mHRBattle__AAEXXZ)(GameModule + 0x3f39e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::BgmEffectProc(class mHRBattle* const this) [?BgmEffectProc@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _BgmEffectProc_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void BgmEffectProc()
	{
		_BgmEffectProc_mHRBattle__QAEXXZ mFunc = (_BgmEffectProc_mHRBattle__QAEXXZ)(GameModule + 0x3f3cb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::SetBgmEffect(class mHRBattle* const this, float arg2, int32_t arg3) [?SetBgmEffect@mHRBattle@@QAEXMH@Z]
	typedef void(__thiscall* _SetBgmEffect_mHRBattle__QAEXMH_Z)(class mHRBattle* const thisPtr, float arg2, int32_t arg3);
	void SetBgmEffect(float arg2, int32_t arg3)
	{
		_SetBgmEffect_mHRBattle__QAEXMH_Z mFunc = (_SetBgmEffect_mHRBattle__QAEXMH_Z)(GameModule + 0x3f3d00);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRBattle::GetNpc(class mHRBattle* const this, int32_t arg2) [?GetNpc@mHRBattle@@QAEPAVmHRChara@@H@Z]
	typedef class mHRChara*(__thiscall* _GetNpc_mHRBattle__QAEPAVmHRChara__H_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	class mHRChara* GetNpc(int32_t arg2)
	{
		_GetNpc_mHRBattle__QAEPAVmHRChara__H_Z mFunc = (_GetNpc_mHRBattle__QAEPAVmHRChara__H_Z)(GameModule + 0x3f3d80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckPcLoaded4WepaponChange(class mHRBattle* const this) [?mCheckPcLoaded4WepaponChange@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckPcLoaded4WepaponChange_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mCheckPcLoaded4WepaponChange()
	{
		_mCheckPcLoaded4WepaponChange_mHRBattle__QAE_NXZ mFunc = (_mCheckPcLoaded4WepaponChange_mHRBattle__QAE_NXZ)(GameModule + 0x3f3dc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckBattleInit(class mHRBattle* const this) [?mCheckBattleInit@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckBattleInit_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mCheckBattleInit()
	{
		_mCheckBattleInit_mHRBattle__QAE_NXZ mFunc = (_mCheckBattleInit_mHRBattle__QAE_NXZ)(GameModule + 0x3f3e20);
		return mFunc(this);
	}
	// [Function] uint8_t mHRBattle::ChkToiletStage() [?ChkToiletStage@mHRBattle@@SA_NXZ]
	typedef uint8_t(__fastcall* _ChkToiletStage_mHRBattle__SA_NXZ)();
	static uint8_t ChkToiletStage()
	{
		_ChkToiletStage_mHRBattle__SA_NXZ mFunc = (_ChkToiletStage_mHRBattle__SA_NXZ)(GameModule + 0x3f3e30);
		return mFunc();
	}
	// [Function] uint8_t mHRBattle::ChkBikeStage() [?ChkBikeStage@mHRBattle@@SA_NXZ]
	typedef uint8_t(__fastcall* _ChkBikeStage_mHRBattle__SA_NXZ)();
	static uint8_t ChkBikeStage()
	{
		_ChkBikeStage_mHRBattle__SA_NXZ mFunc = (_ChkBikeStage_mHRBattle__SA_NXZ)(GameModule + 0x3f3e40);
		return mFunc();
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::GetPickUpGomiSubMissionResult(class mHRBattle* const this, int32_t arg2) [?GetPickUpGomiSubMissionResult@mHRBattle@@QAEHH@Z]
	typedef int32_t(__thiscall* _GetPickUpGomiSubMissionResult_mHRBattle__QAEHH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	int32_t GetPickUpGomiSubMissionResult(int32_t arg2)
	{
		_GetPickUpGomiSubMissionResult_mHRBattle__QAEHH_Z mFunc = (_GetPickUpGomiSubMissionResult_mHRBattle__QAEHH_Z)(GameModule + 0x3f3e60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mAddKillNum(class mHRBattle* const this) [?mAddKillNum@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mAddKillNum_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mAddKillNum()
	{
		_mAddKillNum_mHRBattle__QAEXXZ mFunc = (_mAddKillNum_mHRBattle__QAEXXZ)(GameModule + 0x3f3e90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mSetNpcAppear(class mHRBattle* const this, int32_t arg2) [?mSetNpcAppear@mHRBattle@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mSetNpcAppear_mHRBattle__QAE_NH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	uint8_t mSetNpcAppear(int32_t arg2)
	{
		_mSetNpcAppear_mHRBattle__QAE_NH_Z mFunc = (_mSetNpcAppear_mHRBattle__QAE_NH_Z)(GameModule + 0x3f3fc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::FixRotationOfItem(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4) [?FixRotationOfItem@mHRBattle@@QAEXHAAUVec@@ABU2@@Z]
	typedef void(__thiscall* _FixRotationOfItem_mHRBattle__QAEXHAAUVec__ABU2__Z)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4);
	void FixRotationOfItem(int32_t arg2, struct Vec& arg3, struct Vec& arg4)
	{
		_FixRotationOfItem_mHRBattle__QAEXHAAUVec__ABU2__Z mFunc = (_FixRotationOfItem_mHRBattle__QAEXHAAUVec__ABU2__Z)(GameModule + 0x3f4010);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRBattle::FixPositionOfItem(class mHRBattle* const this, int32_t arg2, struct Vec& arg3) [?FixPositionOfItem@mHRBattle@@QAEXHAAUVec@@@Z]
	typedef void(__thiscall* _FixPositionOfItem_mHRBattle__QAEXHAAUVec___Z)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3);
	void FixPositionOfItem(int32_t arg2, struct Vec& arg3)
	{
		_FixPositionOfItem_mHRBattle__QAEXHAAUVec___Z mFunc = (_FixPositionOfItem_mHRBattle__QAEXHAAUVec___Z)(GameModule + 0x3f40e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitCustomColliderObj(class mHRBattle* const this) [?mSetInitCustomColliderObj@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _mSetInitCustomColliderObj_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t mSetInitCustomColliderObj()
	{
		_mSetInitCustomColliderObj_mHRBattle__QAEHXZ mFunc = (_mSetInitCustomColliderObj_mHRBattle__QAEHXZ)(GameModule + 0x3f4390);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mSetInitCharaPos(class mHRBattle* const this, class mHRChara* arg2, struct Vec& arg3, struct Vec& arg4) [?mSetInitCharaPos@mHRBattle@@QAE_NPAVmHRChara@@ABUVec@@1@Z]
	typedef uint8_t(__thiscall* _mSetInitCharaPos_mHRBattle__QAE_NPAVmHRChara__ABUVec__1_Z)(class mHRBattle* const thisPtr, class mHRChara* arg2, struct Vec& arg3, struct Vec& arg4);
	uint8_t mSetInitCharaPos(class mHRChara* arg2, struct Vec& arg3, struct Vec& arg4)
	{
		_mSetInitCharaPos_mHRBattle__QAE_NPAVmHRChara__ABUVec__1_Z mFunc = (_mSetInitCharaPos_mHRBattle__QAE_NPAVmHRChara__ABUVec__1_Z)(GameModule + 0x3f4430);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckStatusDispOnlyBattery(class mHRBattle* const this) [?mCheckStatusDispOnlyBattery@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckStatusDispOnlyBattery_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mCheckStatusDispOnlyBattery()
	{
		_mCheckStatusDispOnlyBattery_mHRBattle__QAE_NXZ mFunc = (_mCheckStatusDispOnlyBattery_mHRBattle__QAE_NXZ)(GameModule + 0x3f4520);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckStatusDispWithoutBattery(class mHRBattle* const this) [?mCheckStatusDispWithoutBattery@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckStatusDispWithoutBattery_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mCheckStatusDispWithoutBattery()
	{
		_mCheckStatusDispWithoutBattery_mHRBattle__QAE_NXZ mFunc = (_mCheckStatusDispWithoutBattery_mHRBattle__QAE_NXZ)(GameModule + 0x3f4560);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckStatusDisp(class mHRBattle* const this) [?mCheckStatusDisp@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckStatusDisp_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mCheckStatusDisp()
	{
		_mCheckStatusDisp_mHRBattle__QAE_NXZ mFunc = (_mCheckStatusDisp_mHRBattle__QAE_NXZ)(GameModule + 0x3f4590);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mUndispMoney(class mHRBattle* const this) [?mUndispMoney@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mUndispMoney_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mUndispMoney()
	{
		_mUndispMoney_mHRBattle__QAEXXZ mFunc = (_mUndispMoney_mHRBattle__QAEXXZ)(GameModule + 0x3f45e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mDispMoney(class mHRBattle* const this) [?mDispMoney@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mDispMoney_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mDispMoney()
	{
		_mDispMoney_mHRBattle__QAEXXZ mFunc = (_mDispMoney_mHRBattle__QAEXXZ)(GameModule + 0x3f45f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetDispPcStatus(class mHRBattle* const this) [?mGetDispPcStatus@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDispPcStatus_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetDispPcStatus()
	{
		_mGetDispPcStatus_mHRBattle__QAE_NXZ mFunc = (_mGetDispPcStatus_mHRBattle__QAE_NXZ)(GameModule + 0x3f4640);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mReleaseAllNpcWithoutCmnObj(class mHRBattle* const this) [?mReleaseAllNpcWithoutCmnObj@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mReleaseAllNpcWithoutCmnObj_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mReleaseAllNpcWithoutCmnObj()
	{
		_mReleaseAllNpcWithoutCmnObj_mHRBattle__QAE_NXZ mFunc = (_mReleaseAllNpcWithoutCmnObj_mHRBattle__QAE_NXZ)(GameModule + 0x3f4650);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetBulletSlowTick(class mHRBattle* const this, int32_t arg2) [?mSetBulletSlowTick@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mSetBulletSlowTick_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mSetBulletSlowTick(int32_t arg2)
	{
		_mSetBulletSlowTick_mHRBattle__QAEXH_Z mFunc = (_mSetBulletSlowTick_mHRBattle__QAEXH_Z)(GameModule + 0x3f4750);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mResetBulletSlow(class mHRBattle* const this) [?mResetBulletSlow@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mResetBulletSlow_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mResetBulletSlow()
	{
		_mResetBulletSlow_mHRBattle__QAEXXZ mFunc = (_mResetBulletSlow_mHRBattle__QAEXXZ)(GameModule + 0x3f4770);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mResetSlowMotion(class mHRBattle* const this) [?mResetSlowMotion@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mResetSlowMotion_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mResetSlowMotion()
	{
		_mResetSlowMotion_mHRBattle__QAEXXZ mFunc = (_mResetSlowMotion_mHRBattle__QAEXXZ)(GameModule + 0x3f47a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mLightReflectEfProc(class mHRBattle* const this) [?mLightReflectEfProc@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mLightReflectEfProc_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mLightReflectEfProc()
	{
		_mLightReflectEfProc_mHRBattle__QAEXXZ mFunc = (_mLightReflectEfProc_mHRBattle__QAEXXZ)(GameModule + 0x3f47d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCheckSamePopNpcPosAsNpcDat(class mHRBattle* const this, struct Vec& arg2) [?mCheckSamePopNpcPosAsNpcDat@mHRBattle@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _mCheckSamePopNpcPosAsNpcDat_mHRBattle__QAEXABUVec___Z)(class mHRBattle* const thisPtr, struct Vec& arg2);
	void mCheckSamePopNpcPosAsNpcDat(struct Vec& arg2)
	{
		_mCheckSamePopNpcPosAsNpcDat_mHRBattle__QAEXABUVec___Z mFunc = (_mCheckSamePopNpcPosAsNpcDat_mHRBattle__QAEXABUVec___Z)(GameModule + 0x3f4910);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetEmptyNpcDatIndex(class mHRBattle* const this) [?mGetEmptyNpcDatIndex@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetEmptyNpcDatIndex_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t mGetEmptyNpcDatIndex()
	{
		_mGetEmptyNpcDatIndex_mHRBattle__QAEHXZ mFunc = (_mGetEmptyNpcDatIndex_mHRBattle__QAEHXZ)(GameModule + 0x3f4920);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mRestorePcData4Lap(class mHRBattle* const this) [?mRestorePcData4Lap@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mRestorePcData4Lap_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mRestorePcData4Lap()
	{
		_mRestorePcData4Lap_mHRBattle__QAEXXZ mFunc = (_mRestorePcData4Lap_mHRBattle__QAEXXZ)(GameModule + 0x3f4950);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mStorePcData4Lap(class mHRBattle* const this) [?mStorePcData4Lap@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mStorePcData4Lap_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mStorePcData4Lap()
	{
		_mStorePcData4Lap_mHRBattle__QAEXXZ mFunc = (_mStorePcData4Lap_mHRBattle__QAEXXZ)(GameModule + 0x3f4970);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCallPadProcess(class mHRBattle* const this) [?mCallPadProcess@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mCallPadProcess_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mCallPadProcess()
	{
		_mCallPadProcess_mHRBattle__QAEXXZ mFunc = (_mCallPadProcess_mHRBattle__QAEXXZ)(GameModule + 0x3f4d30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mClearNpcDat(class mHRBattle* const this, int32_t arg2) [?mClearNpcDat@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mClearNpcDat_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mClearNpcDat(int32_t arg2)
	{
		_mClearNpcDat_mHRBattle__QAEXH_Z mFunc = (_mClearNpcDat_mHRBattle__QAEXH_Z)(GameModule + 0x3f4d60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mEffectProc(class mHRBattle* const this) [?mEffectProc@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mEffectProc_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mEffectProc()
	{
		_mEffectProc_mHRBattle__QAEXXZ mFunc = (_mEffectProc_mHRBattle__QAEXXZ)(GameModule + 0x3f4ea0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetPopNpc(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4) [?mSetPopNpc@mHRBattle@@QAEXHABUVec@@0@Z]
	typedef void(__thiscall* _mSetPopNpc_mHRBattle__QAEXHABUVec__0_Z)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4);
	void mSetPopNpc(int32_t arg2, struct Vec& arg3, struct Vec& arg4)
	{
		_mSetPopNpc_mHRBattle__QAEXHABUVec__0_Z mFunc = (_mSetPopNpc_mHRBattle__QAEXHABUVec__0_Z)(GameModule + 0x3f5140);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mTestNpcType(class mHRBattle* const this, class mHRChara* arg2) [?mTestNpcType@mHRBattle@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mTestNpcType_mHRBattle__QAE_NPAVmHRChara___Z)(class mHRBattle* const thisPtr, class mHRChara* arg2);
	uint8_t mTestNpcType(class mHRChara* arg2)
	{
		_mTestNpcType_mHRBattle__QAE_NPAVmHRChara___Z mFunc = (_mTestNpcType_mHRBattle__QAE_NPAVmHRChara___Z)(GameModule + 0x3f51b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetNpcEnterPattern(class mHRBattle* const this, int32_t arg2, int32_t arg3, struct Vec& arg4) [?mSetNpcEnterPattern@mHRBattle@@QAEXHHABUVec@@@Z]
	typedef void(__thiscall* _mSetNpcEnterPattern_mHRBattle__QAEXHHABUVec___Z)(class mHRBattle* const thisPtr, int32_t arg2, int32_t arg3, struct Vec& arg4);
	void mSetNpcEnterPattern(int32_t arg2, int32_t arg3, struct Vec& arg4)
	{
		_mSetNpcEnterPattern_mHRBattle__QAEXHHABUVec___Z mFunc = (_mSetNpcEnterPattern_mHRBattle__QAEXHHABUVec___Z)(GameModule + 0x3f5210);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetShadowRate4CommonObject(class mHRBattle* const this, int32_t arg2, int32_t arg3) [?mSetShadowRate4CommonObject@mHRBattle@@QAEXHH@Z]
	typedef void(__thiscall* _mSetShadowRate4CommonObject_mHRBattle__QAEXHH_Z)(class mHRBattle* const thisPtr, int32_t arg2, int32_t arg3);
	void mSetShadowRate4CommonObject(int32_t arg2, int32_t arg3)
	{
		_mSetShadowRate4CommonObject_mHRBattle__QAEXHH_Z mFunc = (_mSetShadowRate4CommonObject_mHRBattle__QAEXHH_Z)(GameModule + 0x3f53a0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCreateNewNpc(class mHRBattle* const this, int32_t arg2, int32_t arg3) [?mCreateNewNpc@mHRBattle@@QAEXHH@Z]
	typedef void(__thiscall* _mCreateNewNpc_mHRBattle__QAEXHH_Z)(class mHRBattle* const thisPtr, int32_t arg2, int32_t arg3);
	void mCreateNewNpc(int32_t arg2, int32_t arg3)
	{
		_mCreateNewNpc_mHRBattle__QAEXHH_Z mFunc = (_mCreateNewNpc_mHRBattle__QAEXHH_Z)(GameModule + 0x3f5410);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckNpcInitHp(class mHRBattle* const this, float* arg2) [?mCheckNpcInitHp@mHRBattle@@QAE_NPAM@Z]
	typedef uint8_t(__thiscall* _mCheckNpcInitHp_mHRBattle__QAE_NPAM_Z)(class mHRBattle* const thisPtr, float* arg2);
	uint8_t mCheckNpcInitHp(float* arg2)
	{
		_mCheckNpcInitHp_mHRBattle__QAE_NPAM_Z mFunc = (_mCheckNpcInitHp_mHRBattle__QAE_NPAM_Z)(GameModule + 0x3f7a30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCheckDeadNpc(class mHRBattle* const this) [?mCheckDeadNpc@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mCheckDeadNpc_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mCheckDeadNpc()
	{
		_mCheckDeadNpc_mHRBattle__QAEXXZ mFunc = (_mCheckDeadNpc_mHRBattle__QAEXXZ)(GameModule + 0x3f7a50);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetEmptyNpcIndex(class mHRBattle* const this) [?mGetEmptyNpcIndex@mHRBattle@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetEmptyNpcIndex_mHRBattle__QAEHXZ)(class mHRBattle* const thisPtr);
	int32_t mGetEmptyNpcIndex()
	{
		_mGetEmptyNpcIndex_mHRBattle__QAEHXZ mFunc = (_mGetEmptyNpcIndex_mHRBattle__QAEHXZ)(GameModule + 0x3f7af0);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") mHRBattle::mGetResourceNpcNum(class mHRBattle* const this) [?mGetResourceNpcNum@mHRBattle@@QAEIXZ]
	typedef uint32_t(__thiscall* _mGetResourceNpcNum_mHRBattle__QAEIXZ)(class mHRBattle* const thisPtr);
	uint32_t mGetResourceNpcNum()
	{
		_mGetResourceNpcNum_mHRBattle__QAEIXZ mFunc = (_mGetResourceNpcNum_mHRBattle__QAEIXZ)(GameModule + 0x3f7b10);
		return mFunc(this);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceZakoNpcMotion(class mHRBattle* const this, char* arg2) [?mGetResourceZakoNpcMotion@mHRBattle@@QAEPAXPAD@Z]
	typedef void*(__thiscall* _mGetResourceZakoNpcMotion_mHRBattle__QAEPAXPAD_Z)(class mHRBattle* const thisPtr, char* arg2);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceZakoNpcMotion(std::string arg2)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_mGetResourceZakoNpcMotion_mHRBattle__QAEPAXPAD_Z mFunc = (_mGetResourceZakoNpcMotion_mHRBattle__QAEPAXPAD_Z)(GameModule + 0x3f7bb0);
		mFunc(this, &arg2_c_str[0]);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceZakoCmnMotion(class mHRBattle* const this, int32_t arg2) [?mGetResourceZakoCmnMotion@mHRBattle@@QAEPAXH@Z]
	typedef void*(__thiscall* _mGetResourceZakoCmnMotion_mHRBattle__QAEPAXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceZakoCmnMotion(int32_t arg2)
	{
		_mGetResourceZakoCmnMotion_mHRBattle__QAEPAXH_Z mFunc = (_mGetResourceZakoCmnMotion_mHRBattle__QAEPAXH_Z)(GameModule + 0x3f7cc0);
		mFunc(this, arg2);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceZakoWepMotion(class mHRBattle* const this, int32_t arg2) [?mGetResourceZakoWepMotion@mHRBattle@@QAEPAXH@Z]
	typedef void*(__thiscall* _mGetResourceZakoWepMotion_mHRBattle__QAEPAXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceZakoWepMotion(int32_t arg2)
	{
		_mGetResourceZakoWepMotion_mHRBattle__QAEPAXH_Z mFunc = (_mGetResourceZakoWepMotion_mHRBattle__QAEPAXH_Z)(GameModule + 0x3f7cf0);
		mFunc(this, arg2);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceNpc(class mHRBattle* const this, int32_t arg2, char const** arg3) [?mGetResourceNpc@mHRBattle@@QAEPAXHPAPBD@Z]
	typedef void*(__thiscall* _mGetResourceNpc_mHRBattle__QAEPAXHPAPBD_Z)(class mHRBattle* const thisPtr, int32_t arg2, char const** arg3);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceNpc(int32_t arg2, char const** arg3)
	{
		_mGetResourceNpc_mHRBattle__QAEPAXHPAPBD_Z mFunc = (_mGetResourceNpc_mHRBattle__QAEPAXHPAPBD_Z)(GameModule + 0x3f7d90);
		mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::GetNpcDatIndexByCharPtr(class mHRBattle* const this, class mHRChara* arg2) [?GetNpcDatIndexByCharPtr@mHRBattle@@QAEHPAVmHRChara@@@Z]
	typedef int32_t(__thiscall* _GetNpcDatIndexByCharPtr_mHRBattle__QAEHPAVmHRChara___Z)(class mHRBattle* const thisPtr, class mHRChara* arg2);
	int32_t GetNpcDatIndexByCharPtr(class mHRChara* arg2)
	{
		_GetNpcDatIndexByCharPtr_mHRBattle__QAEHPAVmHRChara___Z mFunc = (_GetNpcDatIndexByCharPtr_mHRBattle__QAEHPAVmHRChara___Z)(GameModule + 0x3f7e70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraRotD(class mHRBattle* const this) [?mCameraRotD@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mCameraRotD_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mCameraRotD()
	{
		_mCameraRotD_mHRBattle__QAEXXZ mFunc = (_mCameraRotD_mHRBattle__QAEXXZ)(GameModule + 0x3f7ed0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraRotU(class mHRBattle* const this) [?mCameraRotU@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mCameraRotU_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mCameraRotU()
	{
		_mCameraRotU_mHRBattle__QAEXXZ mFunc = (_mCameraRotU_mHRBattle__QAEXXZ)(GameModule + 0x3f7f50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraRotR(class mHRBattle* const this) [?mCameraRotR@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mCameraRotR_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mCameraRotR()
	{
		_mCameraRotR_mHRBattle__QAEXXZ mFunc = (_mCameraRotR_mHRBattle__QAEXXZ)(GameModule + 0x3f7fd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraRotL(class mHRBattle* const this) [?mCameraRotL@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mCameraRotL_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mCameraRotL()
	{
		_mCameraRotL_mHRBattle__QAEXXZ mFunc = (_mCameraRotL_mHRBattle__QAEXXZ)(GameModule + 0x3f8080);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraFrameProc(class mHRBattle* const this) [?mCameraFrameProc@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mCameraFrameProc_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mCameraFrameProc()
	{
		_mCameraFrameProc_mHRBattle__QAEXXZ mFunc = (_mCameraFrameProc_mHRBattle__QAEXXZ)(GameModule + 0x3f8130);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraOffset4Fps(class mHRBattle* const this, float arg2, float arg3, float arg4, int32_t arg5) [?mSetCameraOffset4Fps@mHRBattle@@QAEXMMMH@Z]
	typedef void(__thiscall* _mSetCameraOffset4Fps_mHRBattle__QAEXMMMH_Z)(class mHRBattle* const thisPtr, float arg2, float arg3, float arg4, int32_t arg5);
	void mSetCameraOffset4Fps(float arg2, float arg3, float arg4, int32_t arg5)
	{
		_mSetCameraOffset4Fps_mHRBattle__QAEXMMMH_Z mFunc = (_mSetCameraOffset4Fps_mHRBattle__QAEXMMMH_Z)(GameModule + 0x3f8e40);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRBattle::mResetCameraOffset4Fps(class mHRBattle* const this, int32_t arg2) [?mResetCameraOffset4Fps@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mResetCameraOffset4Fps_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mResetCameraOffset4Fps(int32_t arg2)
	{
		_mResetCameraOffset4Fps_mHRBattle__QAEXH_Z mFunc = (_mResetCameraOffset4Fps_mHRBattle__QAEXH_Z)(GameModule + 0x3f8f00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraOffset4En(class mHRBattle* const this, float arg2, float arg3, float arg4, int32_t arg5) [?mSetCameraOffset4En@mHRBattle@@QAEXMMMH@Z]
	typedef void(__thiscall* _mSetCameraOffset4En_mHRBattle__QAEXMMMH_Z)(class mHRBattle* const thisPtr, float arg2, float arg3, float arg4, int32_t arg5);
	void mSetCameraOffset4En(float arg2, float arg3, float arg4, int32_t arg5)
	{
		_mSetCameraOffset4En_mHRBattle__QAEXMMMH_Z mFunc = (_mSetCameraOffset4En_mHRBattle__QAEXMMMH_Z)(GameModule + 0x3f8fd0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraOffset4Pc(class mHRBattle* const this, float arg2, float arg3, float arg4, int32_t arg5) [?mSetCameraOffset4Pc@mHRBattle@@QAEXMMMH@Z]
	typedef void(__thiscall* _mSetCameraOffset4Pc_mHRBattle__QAEXMMMH_Z)(class mHRBattle* const thisPtr, float arg2, float arg3, float arg4, int32_t arg5);
	void mSetCameraOffset4Pc(float arg2, float arg3, float arg4, int32_t arg5)
	{
		_mSetCameraOffset4Pc_mHRBattle__QAEXMMMH_Z mFunc = (_mSetCameraOffset4Pc_mHRBattle__QAEXMMMH_Z)(GameModule + 0x3f9090);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLockOnCameraZoomIn(class mHRBattle* const this, int32_t arg2) [?mSetLockOnCameraZoomIn@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mSetLockOnCameraZoomIn_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mSetLockOnCameraZoomIn(int32_t arg2)
	{
		_mSetLockOnCameraZoomIn_mHRBattle__QAEXH_Z mFunc = (_mSetLockOnCameraZoomIn_mHRBattle__QAEXH_Z)(GameModule + 0x3f9130);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLockOnCameraZoomOut(class mHRBattle* const this, int32_t arg2) [?mSetLockOnCameraZoomOut@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mSetLockOnCameraZoomOut_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mSetLockOnCameraZoomOut(int32_t arg2)
	{
		_mSetLockOnCameraZoomOut_mHRBattle__QAEXH_Z mFunc = (_mSetLockOnCameraZoomOut_mHRBattle__QAEXH_Z)(GameModule + 0x3f91f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mResetLockOnCameraZoom(class mHRBattle* const this, int32_t arg2) [?mResetLockOnCameraZoom@mHRBattle@@QAEXH@Z]
	typedef void(__thiscall* _mResetLockOnCameraZoom_mHRBattle__QAEXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	void mResetLockOnCameraZoom(int32_t arg2)
	{
		_mResetLockOnCameraZoom_mHRBattle__QAEXH_Z mFunc = (_mResetLockOnCameraZoom_mHRBattle__QAEXH_Z)(GameModule + 0x3f92c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckUndispStatusStage(class mHRBattle* const this) [?mCheckUndispStatusStage@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckUndispStatusStage_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mCheckUndispStatusStage()
	{
		_mCheckUndispStatusStage_mHRBattle__QAE_NXZ mFunc = (_mCheckUndispStatusStage_mHRBattle__QAE_NXZ)(GameModule + 0x3f9390);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetMoveInitCamera4MiniDemo(class mHRBattle* const this) [?mSetMoveInitCamera4MiniDemo@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mSetMoveInitCamera4MiniDemo_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mSetMoveInitCamera4MiniDemo()
	{
		_mSetMoveInitCamera4MiniDemo_mHRBattle__QAEXXZ mFunc = (_mSetMoveInitCamera4MiniDemo_mHRBattle__QAEXXZ)(GameModule + 0x3f93a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLockOnCamera(class mHRBattle* const this) [?mSetLockOnCamera@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mSetLockOnCamera_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mSetLockOnCamera()
	{
		_mSetLockOnCamera_mHRBattle__QAEXXZ mFunc = (_mSetLockOnCamera_mHRBattle__QAEXXZ)(GameModule + 0x3f9470);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mPcTerm(class mHRBattle* const this) [?mPcTerm@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mPcTerm_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mPcTerm()
	{
		_mPcTerm_mHRBattle__QAE_NXZ mFunc = (_mPcTerm_mHRBattle__QAE_NXZ)(GameModule + 0x3f9480);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mPcInit(class mHRBattle* const this) [?mPcInit@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mPcInit_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mPcInit()
	{
		_mPcInit_mHRBattle__QAE_NXZ mFunc = (_mPcInit_mHRBattle__QAE_NXZ)(GameModule + 0x3f94e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mPopPcSaveData(class mHRBattle* const this) [?mPopPcSaveData@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mPopPcSaveData_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mPopPcSaveData()
	{
		_mPopPcSaveData_mHRBattle__QAEXXZ mFunc = (_mPopPcSaveData_mHRBattle__QAEXXZ)(GameModule + 0x3f9980);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mPushPcSaveData(class mHRBattle* const this) [?mPushPcSaveData@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mPushPcSaveData_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mPushPcSaveData()
	{
		_mPushPcSaveData_mHRBattle__QAEXXZ mFunc = (_mPushPcSaveData_mHRBattle__QAEXXZ)(GameModule + 0x3f99c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mInitStart(class mHRBattle* const this) [?mInitStart@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mInitStart_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mInitStart()
	{
		_mInitStart_mHRBattle__QAEXXZ mFunc = (_mInitStart_mHRBattle__QAEXXZ)(GameModule + 0x3f99f0);
		return mFunc(this);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceCmnObj(class mHRBattle* const this, int32_t arg2) [?mGetResourceCmnObj@mHRBattle@@QAEPAXH@Z]
	typedef void*(__thiscall* _mGetResourceCmnObj_mHRBattle__QAEPAXH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceCmnObj(int32_t arg2)
	{
		_mGetResourceCmnObj_mHRBattle__QAEPAXH_Z mFunc = (_mGetResourceCmnObj_mHRBattle__QAEPAXH_Z)(GameModule + 0x3f9cb0);
		mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLightReflecte(class mHRBattle* const this, struct Vec& arg2, float const arg3, uint32_t const arg4, int32_t const arg5, float const arg6, enum eLightRefPriority arg7) [?mSetLightReflecte@mHRBattle@@QAEXABUVec@@MIHMW4eLightRefPriority@@@Z]
	typedef void(__thiscall* _mSetLightReflecte_mHRBattle__QAEXABUVec__MIHMW4eLightRefPriority___Z)(class mHRBattle* const thisPtr, struct Vec& arg2, float const arg3, uint32_t const arg4, int32_t const arg5, float const arg6, enum eLightRefPriority arg7);
	void mSetLightReflecte(struct Vec& arg2, float const arg3, uint32_t const arg4, int32_t const arg5, float const arg6, /* enum eLightRefPriority */ uint32_t arg7)
	{
		_mSetLightReflecte_mHRBattle__QAEXABUVec__MIHMW4eLightRefPriority___Z mFunc = (_mSetLightReflecte_mHRBattle__QAEXABUVec__MIHMW4eLightRefPriority___Z)(GameModule + 0x3f9d50);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, (enum eLightRefPriority)arg7);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mInit(class mHRBattle* const this) [?mInit@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mInit_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mInit()
	{
		_mInit_mHRBattle__QAE_NXZ mFunc = (_mInit_mHRBattle__QAE_NXZ)(GameModule + 0x3fa000);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mFrameProc(class mHRBattle* const this) [?mFrameProc@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mFrameProc_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mFrameProc()
	{
		_mFrameProc_mHRBattle__QAE_NXZ mFunc = (_mFrameProc_mHRBattle__QAE_NXZ)(GameModule + 0x3fa0a0);
		return mFunc(this);
	}
private:
	// Hook: Pre
	inline static _mFrameProc_mHRBattle__QAE_NXZ _original_mFrameProc = nullptr;
	inline static std::unordered_set<std::string> _callbacks_mFrameProc_pre;
	inline static std::unordered_set<std::string> _callbacks_mFrameProc_post;
	static uint8_t __fastcall mFrameProc_OnHook(class mHRBattle* const thisPtr, void* EDX)
	{
#if WITH_LUA
		std::unordered_set<std::string>::iterator it = _callbacks_mFrameProc_pre.begin();
		while (it != _callbacks_mFrameProc_pre.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mFrameProc_pre.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		uint8_t Result = _original_mFrameProc(thisPtr);
#if WITH_LUA
		it = _callbacks_mFrameProc_post.begin();
		while (it != _callbacks_mFrameProc_post.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mFrameProc_post.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		return Result;
	}
public:
	// Hook: Register
#if WITH_LUA
	static void mFrameProc_RegisterHook(std::string HookName, bool bPostHook)
	{
		if (!HookName.empty() && !bPostHook) _callbacks_mFrameProc_pre.insert(HookName);
		if (!HookName.empty() && bPostHook) _callbacks_mFrameProc_post.insert(HookName);
		if (_original_mFrameProc == nullptr)
		{
			_original_mFrameProc = (_mFrameProc_mHRBattle__QAE_NXZ)mem::TrampHook((BYTE*)GameModule + 0x3fa0a0, (BYTE*)mFrameProc_OnHook, 0x6);
			assert(_original_mFrameProc);
		}
	}
#endif
	// [Function] void __convention("thiscall") mHRBattle::mSetVisibleAll(class mHRBattle* const this, uint8_t arg2) [?mSetVisibleAll@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetVisibleAll_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetVisibleAll(uint8_t arg2)
	{
		_mSetVisibleAll_mHRBattle__QAEX_N_Z mFunc = (_mSetVisibleAll_mHRBattle__QAEX_N_Z)(GameModule + 0x3fa310);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetOperateAll(class mHRBattle* const this, uint8_t arg2) [?mSetOperateAll@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetOperateAll_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetOperateAll(uint8_t arg2)
	{
		_mSetOperateAll_mHRBattle__QAEX_N_Z mFunc = (_mSetOperateAll_mHRBattle__QAEX_N_Z)(GameModule + 0x3fa370);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetNewGameDataRequest(class mHRBattle* const this, uint8_t arg2) [?mSetNewGameDataRequest@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetNewGameDataRequest_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetNewGameDataRequest(uint8_t arg2)
	{
		_mSetNewGameDataRequest_mHRBattle__QAEX_N_Z mFunc = (_mSetNewGameDataRequest_mHRBattle__QAEX_N_Z)(GameModule + 0x3fa3b0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mTerm(class mHRBattle* const this) [?mTerm@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTerm_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mTerm()
	{
		_mTerm_mHRBattle__QAE_NXZ mFunc = (_mTerm_mHRBattle__QAE_NXZ)(GameModule + 0x3fa3d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mPostRenderProc(class mHRBattle* const this) [?mPostRenderProc@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mPostRenderProc_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mPostRenderProc()
	{
		_mPostRenderProc_mHRBattle__QAE_NXZ mFunc = (_mPostRenderProc_mHRBattle__QAE_NXZ)(GameModule + 0x3fa480);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::GetBowlingSubMissionResult(class mHRBattle* const this, int32_t arg2) [?GetBowlingSubMissionResult@mHRBattle@@QAEHH@Z]
	typedef int32_t(__thiscall* _GetBowlingSubMissionResult_mHRBattle__QAEHH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	int32_t GetBowlingSubMissionResult(int32_t arg2)
	{
		_GetBowlingSubMissionResult_mHRBattle__QAEHH_Z mFunc = (_GetBowlingSubMissionResult_mHRBattle__QAEHH_Z)(GameModule + 0x3fa4f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckPcLoaded(class mHRBattle* const this) [?mCheckPcLoaded@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckPcLoaded_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mCheckPcLoaded()
	{
		_mCheckPcLoaded_mHRBattle__QAE_NXZ mFunc = (_mCheckPcLoaded_mHRBattle__QAE_NXZ)(GameModule + 0x3fa500);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetPcOperate(class mHRBattle* const this) [?mGetPcOperate@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetPcOperate_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mGetPcOperate()
	{
		_mGetPcOperate_mHRBattle__QAE_NXZ mFunc = (_mGetPcOperate_mHRBattle__QAE_NXZ)(GameModule + 0x3fa520);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetMoveInitCamera(class mHRBattle* const this, uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5) [?mSetMoveInitCamera@mHRBattle@@QAEX_N000@Z]
	typedef void(__thiscall* _mSetMoveInitCamera_mHRBattle__QAEX_N000_Z)(class mHRBattle* const thisPtr, uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5);
	void mSetMoveInitCamera(uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5)
	{
		_mSetMoveInitCamera_mHRBattle__QAEX_N000_Z mFunc = (_mSetMoveInitCamera_mHRBattle__QAEX_N000_Z)(GameModule + 0x3fa540);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRBattle::mInitStartMainMission(class mHRBattle* const this) [?mInitStartMainMission@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mInitStartMainMission_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mInitStartMainMission()
	{
		_mInitStartMainMission_mHRBattle__QAEXXZ mFunc = (_mInitStartMainMission_mHRBattle__QAEXXZ)(GameModule + 0x3fa6a0);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRBattle::mGetNpcPtr(class mHRBattle* const this, int32_t arg2) [?mGetNpcPtr@mHRBattle@@QAEPAVmHRChara@@H@Z]
	typedef class mHRChara*(__thiscall* _mGetNpcPtr_mHRBattle__QAEPAVmHRChara__H_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	class mHRChara* mGetNpcPtr(int32_t arg2)
	{
		_mGetNpcPtr_mHRBattle__QAEPAVmHRChara__H_Z mFunc = (_mGetNpcPtr_mHRBattle__QAEPAVmHRChara__H_Z)(GameModule + 0x3fa6d0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, uint8_t arg8) [?mSetInitNpcDat@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@_N@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDat_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType___N_Z)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, uint8_t arg8);
	int32_t mSetInitNpcDat(int32_t arg2, /* enum enCharaType */ uint32_t arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, /* enum enPopReqType */ uint32_t arg7, uint8_t arg8)
	{
		_mSetInitNpcDat_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType___N_Z mFunc = (_mSetInitNpcDat_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType___N_Z)(GameModule + 0x3fa710);
		return mFunc(this, arg2, (enum enCharaType)arg3, arg4, arg5, arg6, (enum enPopReqType)arg7, arg8);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitObjDat(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4, uint8_t arg5, char const* arg6, class TGmfNode* arg7, int32_t arg8, int32_t arg9) [?mSetInitObjDat@mHRBattle@@QAEHHABUVec@@0_NPBDPBVTGmfNode@@HH@Z]
	typedef int32_t(__thiscall* _mSetInitObjDat_mHRBattle__QAEHHABUVec__0_NPBDPBVTGmfNode__HH_Z)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4, uint8_t arg5, char const* arg6, class TGmfNode* arg7, int32_t arg8, int32_t arg9);
	int32_t mSetInitObjDat(int32_t arg2, struct Vec& arg3, struct Vec& arg4, uint8_t arg5, std::string arg6, class TGmfNode* arg7, int32_t arg8, int32_t arg9)
	{
		char const* arg6_c_str = arg6.c_str();
		_mSetInitObjDat_mHRBattle__QAEHHABUVec__0_NPBDPBVTGmfNode__HH_Z mFunc = (_mSetInitObjDat_mHRBattle__QAEHHABUVec__0_NPBDPBVTGmfNode__HH_Z)(GameModule + 0x3fa830);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6_c_str, arg7, arg8, arg9);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetPopType(class mHRBattle* const this, int32_t arg2, enum enPopReqType arg3) [?mSetPopType@mHRBattle@@QAEXHW4enPopReqType@@@Z]
	typedef void(__thiscall* _mSetPopType_mHRBattle__QAEXHW4enPopReqType___Z)(class mHRBattle* const thisPtr, int32_t arg2, enum enPopReqType arg3);
	void mSetPopType(int32_t arg2, /* enum enPopReqType */ uint32_t arg3)
	{
		_mSetPopType_mHRBattle__QAEXHW4enPopReqType___Z mFunc = (_mSetPopType_mHRBattle__QAEXHW4enPopReqType___Z)(GameModule + 0x3fac90);
		return mFunc(this, arg2, (enum enPopReqType)arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mSetPcKind(class mHRBattle* const this, enum enPcKind PcKind, bool ForceUpdate) [?mSetPcKind@mHRBattle@@QAE_NW4enPcKind@@_N@Z]
	typedef uint8_t(__thiscall* _mSetPcKind_mHRBattle__QAE_NW4enPcKind___N_Z)(class mHRBattle* const thisPtr, enum enPcKind PcKind, bool ForceUpdate);
	uint8_t mSetPcKind(/* enum enPcKind */ uint32_t PcKind, bool ForceUpdate)
	{
		_mSetPcKind_mHRBattle__QAE_NW4enPcKind___N_Z mFunc = (_mSetPcKind_mHRBattle__QAE_NW4enPcKind___N_Z)(GameModule + 0x3facc0);
		return mFunc(this, (enum enPcKind)PcKind, ForceUpdate);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat2(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, uint8_t arg11) [?mSetInitNpcDat2@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMM_N@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDat2_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMM_N_Z)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, uint8_t arg11);
	int32_t mSetInitNpcDat2(int32_t arg2, /* enum enCharaType */ uint32_t arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, /* enum enPopReqType */ uint32_t arg7, int32_t arg8, float arg9, float arg10, uint8_t arg11)
	{
		_mSetInitNpcDat2_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMM_N_Z mFunc = (_mSetInitNpcDat2_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMM_N_Z)(GameModule + 0x3fadc0);
		return mFunc(this, arg2, (enum enCharaType)arg3, arg4, arg5, arg6, (enum enPopReqType)arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat3(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, uint8_t arg12) [?mSetInitNpcDat3@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMH_N@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDat3_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMH_N_Z)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, uint8_t arg12);
	int32_t mSetInitNpcDat3(int32_t arg2, /* enum enCharaType */ uint32_t arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, /* enum enPopReqType */ uint32_t arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, uint8_t arg12)
	{
		_mSetInitNpcDat3_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMH_N_Z mFunc = (_mSetInitNpcDat3_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMH_N_Z)(GameModule + 0x3faef0);
		return mFunc(this, arg2, (enum enCharaType)arg3, arg4, arg5, arg6, (enum enPopReqType)arg7, arg8, arg9, arg10, arg11, arg12);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat4(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13) [?mSetInitNpcDat4@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMHPAD_N@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDat4_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_N_Z)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13);
	int32_t mSetInitNpcDat4(int32_t arg2, /* enum enCharaType */ uint32_t arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, /* enum enPopReqType */ uint32_t arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, std::string arg12, uint8_t arg13)
	{
		std::vector<char> arg12_c_str(arg12.c_str(), + arg12.c_str() + arg12.size() + 1);
		_mSetInitNpcDat4_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_N_Z mFunc = (_mSetInitNpcDat4_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_N_Z)(GameModule + 0x3fb020);
		return mFunc(this, arg2, (enum enCharaType)arg3, arg4, arg5, arg6, (enum enPopReqType)arg7, arg8, arg9, arg10, arg11, &arg12_c_str[0], arg13);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat5(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15) [?mSetInitNpcDat5@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMHPAD_NMH@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDat5_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMH_Z)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15);
	int32_t mSetInitNpcDat5(int32_t arg2, /* enum enCharaType */ uint32_t arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, /* enum enPopReqType */ uint32_t arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, std::string arg12, uint8_t arg13, float arg14, int32_t arg15)
	{
		std::vector<char> arg12_c_str(arg12.c_str(), + arg12.c_str() + arg12.size() + 1);
		_mSetInitNpcDat5_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMH_Z mFunc = (_mSetInitNpcDat5_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMH_Z)(GameModule + 0x3fb190);
		return mFunc(this, arg2, (enum enCharaType)arg3, arg4, arg5, arg6, (enum enPopReqType)arg7, arg8, arg9, arg10, arg11, &arg12_c_str[0], arg13, arg14, arg15);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat6(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16) [?mSetInitNpcDat6@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMHPAD_NMHH@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDat6_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMHH_Z)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16);
	int32_t mSetInitNpcDat6(int32_t arg2, /* enum enCharaType */ uint32_t arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, /* enum enPopReqType */ uint32_t arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, std::string arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16)
	{
		std::vector<char> arg12_c_str(arg12.c_str(), + arg12.c_str() + arg12.size() + 1);
		_mSetInitNpcDat6_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMHH_Z mFunc = (_mSetInitNpcDat6_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMHH_Z)(GameModule + 0x3fb310);
		return mFunc(this, arg2, (enum enCharaType)arg3, arg4, arg5, arg6, (enum enPopReqType)arg7, arg8, arg9, arg10, arg11, &arg12_c_str[0], arg13, arg14, arg15, arg16);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat7(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16) [?mSetInitNpcDat7@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMHPAD_NMHH@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDat7_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMHH_Z)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16);
	int32_t mSetInitNpcDat7(int32_t arg2, /* enum enCharaType */ uint32_t arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, /* enum enPopReqType */ uint32_t arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, std::string arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16)
	{
		std::vector<char> arg12_c_str(arg12.c_str(), + arg12.c_str() + arg12.size() + 1);
		_mSetInitNpcDat7_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMHH_Z mFunc = (_mSetInitNpcDat7_mHRBattle__QAEHHW4enCharaType__HABUVec__1W4enPopReqType__HMMHPAD_NMHH_Z)(GameModule + 0x3fb4a0);
		return mFunc(this, arg2, (enum enCharaType)arg3, arg4, arg5, arg6, (enum enPopReqType)arg7, arg8, arg9, arg10, arg11, &arg12_c_str[0], arg13, arg14, arg15, arg16);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDatObj095(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6) [?mSetInitNpcDatObj095@mHRBattle@@QAEHHABUVec@@0HH@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDatObj095_mHRBattle__QAEHHABUVec__0HH_Z)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6);
	int32_t mSetInitNpcDatObj095(int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6)
	{
		_mSetInitNpcDatObj095_mHRBattle__QAEHHABUVec__0HH_Z mFunc = (_mSetInitNpcDatObj095_mHRBattle__QAEHHABUVec__0HH_Z)(GameModule + 0x3fb630);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] void __convention("thiscall") mHRBattle::mDispPcStatus(class mHRBattle* const this) [?mDispPcStatus@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mDispPcStatus_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mDispPcStatus()
	{
		_mDispPcStatus_mHRBattle__QAEXXZ mFunc = (_mDispPcStatus_mHRBattle__QAEXXZ)(GameModule + 0x3fb740);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mDispMiniMap(class mHRBattle* const this) [?mDispMiniMap@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mDispMiniMap_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mDispMiniMap()
	{
		_mDispMiniMap_mHRBattle__QAEXXZ mFunc = (_mDispMiniMap_mHRBattle__QAEXXZ)(GameModule + 0x3fb750);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mUndispMiniMap(class mHRBattle* const this) [?mUndispMiniMap@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mUndispMiniMap_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mUndispMiniMap()
	{
		_mUndispMiniMap_mHRBattle__QAEXXZ mFunc = (_mUndispMiniMap_mHRBattle__QAEXXZ)(GameModule + 0x3fb7f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mDeleteNpc(class mHRBattle* const this, int32_t arg2) [?mDeleteNpc@mHRBattle@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mDeleteNpc_mHRBattle__QAE_NH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	uint8_t mDeleteNpc(int32_t arg2)
	{
		_mDeleteNpc_mHRBattle__QAE_NH_Z mFunc = (_mDeleteNpc_mHRBattle__QAE_NH_Z)(GameModule + 0x3fb810);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::RequestMotionNoNpc(class mHRBattle* const this, enum enCharaType arg2, int32_t arg3, uint8_t arg4) [?RequestMotionNoNpc@mHRBattle@@QAE_NW4enCharaType@@H_N@Z]
	typedef uint8_t(__thiscall* _RequestMotionNoNpc_mHRBattle__QAE_NW4enCharaType__H_N_Z)(class mHRBattle* const thisPtr, enum enCharaType arg2, int32_t arg3, uint8_t arg4);
	uint8_t RequestMotionNoNpc(/* enum enCharaType */ uint32_t arg2, int32_t arg3, uint8_t arg4)
	{
		_RequestMotionNoNpc_mHRBattle__QAE_NW4enCharaType__H_N_Z mFunc = (_RequestMotionNoNpc_mHRBattle__QAE_NW4enCharaType__H_N_Z)(GameModule + 0x3fb8b0);
		return mFunc(this, (enum enCharaType)arg2, arg3, arg4);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRBattle::mGetNpcPtrFromCharaType(class mHRBattle* const this, enum enCharaType arg2) [?mGetNpcPtrFromCharaType@mHRBattle@@QAEPAVmHRChara@@W4enCharaType@@@Z]
	typedef class mHRChara*(__thiscall* _mGetNpcPtrFromCharaType_mHRBattle__QAEPAVmHRChara__W4enCharaType___Z)(class mHRBattle* const thisPtr, enum enCharaType arg2);
	class mHRChara* mGetNpcPtrFromCharaType(/* enum enCharaType */ uint32_t arg2)
	{
		_mGetNpcPtrFromCharaType_mHRBattle__QAEPAVmHRChara__W4enCharaType___Z mFunc = (_mGetNpcPtrFromCharaType_mHRBattle__QAEPAVmHRChara__W4enCharaType___Z)(GameModule + 0x3fb970);
		return mFunc(this, (enum enCharaType)arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetZakoNpcMotionProcessDisEnable(class mHRBattle* const this, uint8_t arg2) [?mSetZakoNpcMotionProcessDisEnable@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetZakoNpcMotionProcessDisEnable_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetZakoNpcMotionProcessDisEnable(uint8_t arg2)
	{
		_mSetZakoNpcMotionProcessDisEnable_mHRBattle__QAEX_N_Z mFunc = (_mSetZakoNpcMotionProcessDisEnable_mHRBattle__QAEX_N_Z)(GameModule + 0x3fb9d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetAspectRate(class mHRBattle* const this, float arg2, int32_t arg3) [?mSetAspectRate@mHRBattle@@QAEXMH@Z]
	typedef void(__thiscall* _mSetAspectRate_mHRBattle__QAEXMH_Z)(class mHRBattle* const thisPtr, float arg2, int32_t arg3);
	void mSetAspectRate(float arg2, int32_t arg3)
	{
		_mSetAspectRate_mHRBattle__QAEXMH_Z mFunc = (_mSetAspectRate_mHRBattle__QAEXMH_Z)(GameModule + 0x3fba20);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckExistEnemy(class mHRBattle* const this) [?mCheckExistEnemy@mHRBattle@@QAE_NXZ]
	/// <summary>
	/// Returns true if any enemy is still alive.
	/// </summary>
	typedef uint8_t(__thiscall* _mCheckExistEnemy_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mCheckExistEnemy()
	{
		_mCheckExistEnemy_mHRBattle__QAE_NXZ mFunc = (_mCheckExistEnemy_mHRBattle__QAE_NXZ)(GameModule + 0x3fba60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mAllTestZakoDamage(class mHRBattle* const this, int32_t arg2) [?mAllTestZakoDamage@mHRBattle@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mAllTestZakoDamage_mHRBattle__QAE_NH_Z)(class mHRBattle* const thisPtr, int32_t arg2);
	uint8_t mAllTestZakoDamage(int32_t arg2)
	{
		_mAllTestZakoDamage_mHRBattle__QAE_NH_Z mFunc = (_mAllTestZakoDamage_mHRBattle__QAE_NH_Z)(GameModule + 0x3fbab0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mAllTestZakoTameDamage(class mHRBattle* const this) [?mAllTestZakoTameDamage@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mAllTestZakoTameDamage_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mAllTestZakoTameDamage()
	{
		_mAllTestZakoTameDamage_mHRBattle__QAE_NXZ mFunc = (_mAllTestZakoTameDamage_mHRBattle__QAE_NXZ)(GameModule + 0x3fbb00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mAllEnemyDie(class mHRBattle* const this) [?mAllEnemyDie@mHRBattle@@QAE_NXZ]
	/// <summary>
	/// Unloads all enemies in the level immediately, without any effect. Note that this does not kill them, and moving away then back will have them re-appear.
	/// </summary>
	typedef uint8_t(__thiscall* _mAllEnemyDie_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mAllEnemyDie()
	{
		_mAllEnemyDie_mHRBattle__QAE_NXZ mFunc = (_mAllEnemyDie_mHRBattle__QAE_NXZ)(GameModule + 0x3fbb20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mAllClearNpcData(class mHRBattle* const this) [?mAllClearNpcData@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mAllClearNpcData_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mAllClearNpcData()
	{
		_mAllClearNpcData_mHRBattle__QAEXXZ mFunc = (_mAllClearNpcData_mHRBattle__QAEXXZ)(GameModule + 0x3fbbb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraProjection(class mHRBattle* const this, float arg2) [?mSetCameraProjection@mHRBattle@@QAEXM@Z]
	typedef void(__thiscall* _mSetCameraProjection_mHRBattle__QAEXM_Z)(class mHRBattle* const thisPtr, float arg2);
	void mSetCameraProjection(float arg2)
	{
		_mSetCameraProjection_mHRBattle__QAEXM_Z mFunc = (_mSetCameraProjection_mHRBattle__QAEXM_Z)(GameModule + 0x3fbcb0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetObjNpcID(class mHRBattle* const this, int32_t arg2, char* arg3) [?mGetObjNpcID@mHRBattle@@QAEHHPAD@Z]
	typedef int32_t(__thiscall* _mGetObjNpcID_mHRBattle__QAEHHPAD_Z)(class mHRBattle* const thisPtr, int32_t arg2, char* arg3);
	int32_t mGetObjNpcID(int32_t arg2, std::string arg3)
	{
		std::vector<char> arg3_c_str(arg3.c_str(), + arg3.c_str() + arg3.size() + 1);
		_mGetObjNpcID_mHRBattle__QAEHHPAD_Z mFunc = (_mGetObjNpcID_mHRBattle__QAEHHPAD_Z)(GameModule + 0x3fbcf0);
		return mFunc(this, arg2, &arg3_c_str[0]);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRBattle::mGetObjPtr(class mHRBattle* const this, int32_t arg2, char* arg3) [?mGetObjPtr@mHRBattle@@QAEPAVmHRChara@@HPAD@Z]
	typedef class mHRChara*(__thiscall* _mGetObjPtr_mHRBattle__QAEPAVmHRChara__HPAD_Z)(class mHRBattle* const thisPtr, int32_t arg2, char* arg3);
	class mHRChara* mGetObjPtr(int32_t arg2, std::string arg3)
	{
		std::vector<char> arg3_c_str(arg3.c_str(), + arg3.c_str() + arg3.size() + 1);
		_mGetObjPtr_mHRBattle__QAEPAVmHRChara__HPAD_Z mFunc = (_mGetObjPtr_mHRBattle__QAEPAVmHRChara__HPAD_Z)(GameModule + 0x3fbd70);
		return mFunc(this, arg2, &arg3_c_str[0]);
	}
	// [Function] void __convention("thiscall") mHRBattle::mPopNpc(class mHRBattle* const this) [?mPopNpc@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mPopNpc_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mPopNpc()
	{
		_mPopNpc_mHRBattle__QAEXXZ mFunc = (_mPopNpc_mHRBattle__QAEXXZ)(GameModule + 0x3fbe00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetSlowMotionTick(class mHRBattle* const this, int32_t arg2, enum stBtEffect::SlowType arg3) [?mSetSlowMotionTick@mHRBattle@@QAEXHW4SlowType@stBtEffect@@@Z]
	typedef void(__thiscall* _mSetSlowMotionTick_mHRBattle__QAEXHW4SlowType_stBtEffect___Z)(class mHRBattle* const thisPtr, int32_t arg2, enum stBtEffect::SlowType arg3);
	void mSetSlowMotionTick(int32_t arg2, /* enum stBtEffect::SlowType */ uint32_t arg3)
	{
		_mSetSlowMotionTick_mHRBattle__QAEXHW4SlowType_stBtEffect___Z mFunc = (_mSetSlowMotionTick_mHRBattle__QAEXHW4SlowType_stBtEffect___Z)(GameModule + 0x3fca40);
		return mFunc(this, arg2, (enum stBtEffect::SlowType)arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mReleaseAllEnemy(class mHRBattle* const this) [?mReleaseAllEnemy@mHRBattle@@QAE_NXZ]
	/// <summary>
	/// Calls ::mClearNpcDat on all enemies, destroying them immediately, without triggering any effects or events (like gated doors).
	/// </summary>
	typedef uint8_t(__thiscall* _mReleaseAllEnemy_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mReleaseAllEnemy()
	{
		_mReleaseAllEnemy_mHRBattle__QAE_NXZ mFunc = (_mReleaseAllEnemy_mHRBattle__QAE_NXZ)(GameModule + 0x3fca70);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDatObj183(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6, uint8_t arg7, int32_t arg8) [?mSetInitNpcDatObj183@mHRBattle@@QAEHHABUVec@@0HH_NH@Z]
	typedef int32_t(__thiscall* _mSetInitNpcDatObj183_mHRBattle__QAEHHABUVec__0HH_NH_Z)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6, uint8_t arg7, int32_t arg8);
	int32_t mSetInitNpcDatObj183(int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6, uint8_t arg7, int32_t arg8)
	{
		_mSetInitNpcDatObj183_mHRBattle__QAEHHABUVec__0HH_NH_Z mFunc = (_mSetInitNpcDatObj183_mHRBattle__QAEHHABUVec__0HH_NH_Z)(GameModule + 0x3fcb80);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mReleaseAllNpc(class mHRBattle* const this) [?mReleaseAllNpc@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mReleaseAllNpc_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mReleaseAllNpc()
	{
		_mReleaseAllNpc_mHRBattle__QAE_NXZ mFunc = (_mReleaseAllNpc_mHRBattle__QAE_NXZ)(GameModule + 0x3fcca0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetDontAppearStatus(class mHRBattle* const this) [?mSetDontAppearStatus@mHRBattle@@QAEXXZ]
	typedef void(__thiscall* _mSetDontAppearStatus_mHRBattle__QAEXXZ)(class mHRBattle* const thisPtr);
	void mSetDontAppearStatus()
	{
		_mSetDontAppearStatus_mHRBattle__QAEXXZ mFunc = (_mSetDontAppearStatus_mHRBattle__QAEXXZ)(GameModule + 0x3fcd70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::CameraMotionModeReset(class mHRBattle* const this, uint8_t arg2) [?CameraMotionModeReset@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _CameraMotionModeReset_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void CameraMotionModeReset(uint8_t arg2)
	{
		_CameraMotionModeReset_mHRBattle__QAEX_N_Z mFunc = (_CameraMotionModeReset_mHRBattle__QAEX_N_Z)(GameModule + 0x3fcd80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetPcOperate(class mHRBattle* const this, uint8_t arg2) [?mSetPcOperate@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mSetPcOperate_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mSetPcOperate(uint8_t arg2)
	{
		_mSetPcOperate_mHRBattle__QAEX_N_Z mFunc = (_mSetPcOperate_mHRBattle__QAEX_N_Z)(GameModule + 0x3fce10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mUndispPcStatus(class mHRBattle* const this, uint8_t arg2) [?mUndispPcStatus@mHRBattle@@QAEX_N@Z]
	typedef void(__thiscall* _mUndispPcStatus_mHRBattle__QAEX_N_Z)(class mHRBattle* const thisPtr, uint8_t arg2);
	void mUndispPcStatus(uint8_t arg2)
	{
		_mUndispPcStatus_mHRBattle__QAEX_N_Z mFunc = (_mUndispPcStatus_mHRBattle__QAEX_N_Z)(GameModule + 0x3fce30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mRenderProc(class mHRBattle* const this) [?mRenderProc@mHRBattle@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mRenderProc_mHRBattle__QAE_NXZ)(class mHRBattle* const thisPtr);
	uint8_t mRenderProc()
	{
		_mRenderProc_mHRBattle__QAE_NXZ mFunc = (_mRenderProc_mHRBattle__QAE_NXZ)(GameModule + 0x3fce50);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRBattle::mGetNpcMotionSpd(class mHRBattle* const this, class mHRChara* arg2) [?mGetNpcMotionSpd@mHRBattle@@QAEMPAVmHRChara@@@Z]
	typedef float(__thiscall* _mGetNpcMotionSpd_mHRBattle__QAEMPAVmHRChara___Z)(class mHRBattle* const thisPtr, class mHRChara* arg2);
	float mGetNpcMotionSpd(class mHRChara* arg2)
	{
		_mGetNpcMotionSpd_mHRBattle__QAEMPAVmHRChara___Z mFunc = (_mGetNpcMotionSpd_mHRBattle__QAEMPAVmHRChara___Z)(GameModule + 0x3fce60);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class mHRBattle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(mHRBattle& InObject)
	{
		PlayerInitializedState = InObject.PlayerInitializedState;
		CameraProjection = InObject.CameraProjection;
		LockNavelPos = InObject.LockNavelPos;
		CameraMotionEndStop = InObject.CameraMotionEndStop;
		btEffect = InObject.btEffect;
		PcKind = InObject.PcKind;
		PcPtr = InObject.PcPtr;
		WeaponType = InObject.WeaponType;
		UnknownWeaponPtr = InObject.UnknownWeaponPtr;
		TotalKillNum = InObject.TotalKillNum;
		KillNum = InObject.KillNum;
		RevengeMissionZakoKillNum = InObject.RevengeMissionZakoKillNum;
		NpcAttackRate = InObject.NpcAttackRate;
		UnknownInt = InObject.UnknownInt;
		NewGameDataRequest = InObject.NewGameDataRequest;
		SaveData = InObject.SaveData;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRBattle>("mHRBattle")
			.addFunction("__tostring", &mHRBattle::ToString)
			.addFunction("GetPtrAddr", &mHRBattle::GetPtrAddr)
			.addProperty("PlayerInitializedState", &mHRBattle::PlayerInitializedState)
			.addProperty("CameraProjection", &mHRBattle::CameraProjection)
			.addProperty("LockNavelPos", &mHRBattle::LockNavelPos)
			.addProperty("CameraMotionEndStop", &mHRBattle::CameraMotionEndStop)
			.addProperty("btEffect", &mHRBattle::btEffect)
			.addProperty("PcKind", &mHRBattle::PcKind)
			.addProperty("PcPtr", &mHRBattle::PcPtr)
			.addProperty("WeaponType", &mHRBattle::WeaponType)
			// void type not supported in LuaBridge
			//.addProperty("UnknownWeaponPtr", &mHRBattle::UnknownWeaponPtr)
			.addProperty("TotalKillNum", &mHRBattle::TotalKillNum)
			.addProperty("KillNum", &mHRBattle::KillNum)
			.addProperty("RevengeMissionZakoKillNum", &mHRBattle::RevengeMissionZakoKillNum)
			.addProperty("NpcAttackRate", &mHRBattle::NpcAttackRate)
			.addProperty("UnknownInt", &mHRBattle::UnknownInt)
			.addProperty("NewGameDataRequest", &mHRBattle::NewGameDataRequest)
			.addProperty("SaveData", &mHRBattle::SaveData)
			.addFunction("mGetPcPtr", &mHRBattle::mGetPcPtr)
			.addFunction("mGetSlowMotionTick", &mHRBattle::mGetSlowMotionTick)
			.addFunction("mGetBulletSlow", &mHRBattle::mGetBulletSlow)
			.addFunction("mGetBtEffect", &mHRBattle::mGetBtEffect)
			.addFunction("mSetNpcAttackFlag", &mHRBattle::mSetNpcAttackFlag)
			.addFunction("mSetNpcAttackRate", &mHRBattle::mSetNpcAttackRate)
			.addFunction("SetNpcDatMax", &mHRBattle::SetNpcDatMax)
			.addFunction("GetSmokeEf", &mHRBattle::GetSmokeEf)
			.addFunction("mGetPcKind", &mHRBattle::mGetPcKind)
			.addFunction("mGetFrameProc", &mHRBattle::mGetFrameProc)
			.addFunction("mSetCameraAngle", &mHRBattle::mSetCameraAngle)
			.addFunction("mSetCamMotFlag", &mHRBattle::mSetCamMotFlag)
			.addFunction("mSetCamMotFlagNoUse", &mHRBattle::mSetCamMotFlagNoUse)
			.addFunction("mSetCameraAutoReturnDisEnable", &mHRBattle::mSetCameraAutoReturnDisEnable)
			.addFunction("mClearKillNum", &mHRBattle::mClearKillNum)
			.addFunction("mGetKillNum", &mHRBattle::mGetKillNum)
			.addFunction("mSetKillNum", &mHRBattle::mSetKillNum)
			.addFunction("GetRevengeMissionZakoKillNum", &mHRBattle::GetRevengeMissionZakoKillNum)
			.addFunction("ClearRevengeMissionZakoKillNum", &mHRBattle::ClearRevengeMissionZakoKillNum)
			.addFunction("mSetBattlePause", &mHRBattle::mSetBattlePause)
			.addFunction("mSetDispStatusDisEnable", &mHRBattle::mSetDispStatusDisEnable)
			.addFunction("mGetDispStatusDisEnable", &mHRBattle::mGetDispStatusDisEnable)
			.addFunction("mSetChargeDamage", &mHRBattle::mSetChargeDamage)
			.addFunction("mClearTotalKillNum", &mHRBattle::mClearTotalKillNum)
			.addFunction("mGetTutoRun", &mHRBattle::mGetTutoRun)
			.addFunction("mSubRepopNum", &mHRBattle::mSubRepopNum)
			.addFunction("mSetRepopTimer", &mHRBattle::mSetRepopTimer)
			.addFunction("mGetNewGameDataRequest", &mHRBattle::mGetNewGameDataRequest)
			.addFunction("mGetDontChangeTeppeiCamera", &mHRBattle::mGetDontChangeTeppeiCamera)
			.addFunction("mGetCameraProjection", &mHRBattle::mGetCameraProjection)
			.addFunction("mSetCameraMoveFlag", &mHRBattle::mSetCameraMoveFlag)
			.addFunction("mSetMotionCameraPos", &mHRBattle::mSetMotionCameraPos)
			.addFunction("mGetMotionCameraPos", &mHRBattle::mGetMotionCameraPos)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetMotionCameraY", &mHRBattle::mSetMotionCameraY)
			.addFunction("mGetMotionCameraY", &mHRBattle::mGetMotionCameraY)
			.addFunction("mGetBattlePause", &mHRBattle::mGetBattlePause)
			.addFunction("mGetChargeDamage", &mHRBattle::mGetChargeDamage)
			.addFunction("mGetChangeCameraRailFlag", &mHRBattle::mGetChangeCameraRailFlag)
			.addFunction("mGetCameraAngleX", &mHRBattle::mGetCameraAngleX)
			.addFunction("mSetLockNavelPos", &mHRBattle::mSetLockNavelPos)
			.addFunction("mGetTotalKillNum", &mHRBattle::mGetTotalKillNum)
			.addFunction("mSetTotalKillNum", &mHRBattle::mSetTotalKillNum)
			.addFunction("mGetBossBreakSlow", &mHRBattle::mGetBossBreakSlow)
			.addFunction("mGetNpcAttackFlag", &mHRBattle::mGetNpcAttackFlag)
			.addFunction("mGetNpcAttackRate", &mHRBattle::mGetNpcAttackRate)
			.addFunction("AddRevengeMissionZakoKillNum", &mHRBattle::AddRevengeMissionZakoKillNum)
			.addFunction("SetCameraMotionEndStop", &mHRBattle::SetCameraMotionEndStop)
			.addFunction("IsBgmEffect", &mHRBattle::IsBgmEffect)
			.addFunction("mSetDontChangeTeppeiCamera", &mHRBattle::mSetDontChangeTeppeiCamera)
			.addFunction("UpdateMassKillAchievement", &mHRBattle::UpdateMassKillAchievement)
			.addFunction("UpdateMainScreenUI", &mHRBattle::UpdateMainScreenUI)
			.addFunction("BgmEffectProc", &mHRBattle::BgmEffectProc)
			.addFunction("SetBgmEffect", &mHRBattle::SetBgmEffect)
			.addFunction("GetNpc", &mHRBattle::GetNpc)
			.addFunction("mCheckPcLoaded4WepaponChange", &mHRBattle::mCheckPcLoaded4WepaponChange)
			.addFunction("mCheckBattleInit", &mHRBattle::mCheckBattleInit)
			.addStaticFunction("ChkToiletStage", &mHRBattle::ChkToiletStage)
			.addStaticFunction("ChkBikeStage", &mHRBattle::ChkBikeStage)
			.addFunction("GetPickUpGomiSubMissionResult", &mHRBattle::GetPickUpGomiSubMissionResult)
			.addFunction("mAddKillNum", &mHRBattle::mAddKillNum)
			.addFunction("mSetNpcAppear", &mHRBattle::mSetNpcAppear)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("FixRotationOfItem", &mHRBattle::FixRotationOfItem)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("FixPositionOfItem", &mHRBattle::FixPositionOfItem)
			.addFunction("mSetInitCustomColliderObj", &mHRBattle::mSetInitCustomColliderObj)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitCharaPos", &mHRBattle::mSetInitCharaPos)
			.addFunction("mCheckStatusDispOnlyBattery", &mHRBattle::mCheckStatusDispOnlyBattery)
			.addFunction("mCheckStatusDispWithoutBattery", &mHRBattle::mCheckStatusDispWithoutBattery)
			.addFunction("mCheckStatusDisp", &mHRBattle::mCheckStatusDisp)
			.addFunction("mUndispMoney", &mHRBattle::mUndispMoney)
			.addFunction("mDispMoney", &mHRBattle::mDispMoney)
			.addFunction("mGetDispPcStatus", &mHRBattle::mGetDispPcStatus)
			.addFunction("mReleaseAllNpcWithoutCmnObj", &mHRBattle::mReleaseAllNpcWithoutCmnObj)
			.addFunction("mSetBulletSlowTick", &mHRBattle::mSetBulletSlowTick)
			.addFunction("mResetBulletSlow", &mHRBattle::mResetBulletSlow)
			.addFunction("mResetSlowMotion", &mHRBattle::mResetSlowMotion)
			.addFunction("mLightReflectEfProc", &mHRBattle::mLightReflectEfProc)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mCheckSamePopNpcPosAsNpcDat", &mHRBattle::mCheckSamePopNpcPosAsNpcDat)
			.addFunction("mGetEmptyNpcDatIndex", &mHRBattle::mGetEmptyNpcDatIndex)
			.addFunction("mRestorePcData4Lap", &mHRBattle::mRestorePcData4Lap)
			.addFunction("mStorePcData4Lap", &mHRBattle::mStorePcData4Lap)
			.addFunction("mCallPadProcess", &mHRBattle::mCallPadProcess)
			.addFunction("mClearNpcDat", &mHRBattle::mClearNpcDat)
			.addFunction("mEffectProc", &mHRBattle::mEffectProc)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetPopNpc", &mHRBattle::mSetPopNpc)
			.addFunction("mTestNpcType", &mHRBattle::mTestNpcType)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetNpcEnterPattern", &mHRBattle::mSetNpcEnterPattern)
			.addFunction("mSetShadowRate4CommonObject", &mHRBattle::mSetShadowRate4CommonObject)
			.addFunction("mCreateNewNpc", &mHRBattle::mCreateNewNpc)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mCheckNpcInitHp", &mHRBattle::mCheckNpcInitHp)
			.addFunction("mCheckDeadNpc", &mHRBattle::mCheckDeadNpc)
			.addFunction("mGetEmptyNpcIndex", &mHRBattle::mGetEmptyNpcIndex)
			.addFunction("mGetResourceNpcNum", &mHRBattle::mGetResourceNpcNum)
			.addFunction("mGetResourceZakoNpcMotion", &mHRBattle::mGetResourceZakoNpcMotion)
			.addFunction("mGetResourceZakoCmnMotion", &mHRBattle::mGetResourceZakoCmnMotion)
			.addFunction("mGetResourceZakoWepMotion", &mHRBattle::mGetResourceZakoWepMotion)
			// Can't export pointer to native type 'char const**' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetResourceNpc", &mHRBattle::mGetResourceNpc)
			.addFunction("GetNpcDatIndexByCharPtr", &mHRBattle::GetNpcDatIndexByCharPtr)
			.addFunction("mCameraRotD", &mHRBattle::mCameraRotD)
			.addFunction("mCameraRotU", &mHRBattle::mCameraRotU)
			.addFunction("mCameraRotR", &mHRBattle::mCameraRotR)
			.addFunction("mCameraRotL", &mHRBattle::mCameraRotL)
			.addFunction("mCameraFrameProc", &mHRBattle::mCameraFrameProc)
			.addFunction("mSetCameraOffset4Fps", &mHRBattle::mSetCameraOffset4Fps)
			.addFunction("mResetCameraOffset4Fps", &mHRBattle::mResetCameraOffset4Fps)
			.addFunction("mSetCameraOffset4En", &mHRBattle::mSetCameraOffset4En)
			.addFunction("mSetCameraOffset4Pc", &mHRBattle::mSetCameraOffset4Pc)
			.addFunction("mSetLockOnCameraZoomIn", &mHRBattle::mSetLockOnCameraZoomIn)
			.addFunction("mSetLockOnCameraZoomOut", &mHRBattle::mSetLockOnCameraZoomOut)
			.addFunction("mResetLockOnCameraZoom", &mHRBattle::mResetLockOnCameraZoom)
			.addFunction("mCheckUndispStatusStage", &mHRBattle::mCheckUndispStatusStage)
			.addFunction("mSetMoveInitCamera4MiniDemo", &mHRBattle::mSetMoveInitCamera4MiniDemo)
			.addFunction("mSetLockOnCamera", &mHRBattle::mSetLockOnCamera)
			.addFunction("mPcTerm", &mHRBattle::mPcTerm)
			.addFunction("mPcInit", &mHRBattle::mPcInit)
			.addFunction("mPopPcSaveData", &mHRBattle::mPopPcSaveData)
			.addFunction("mPushPcSaveData", &mHRBattle::mPushPcSaveData)
			.addFunction("mInitStart", &mHRBattle::mInitStart)
			.addFunction("mGetResourceCmnObj", &mHRBattle::mGetResourceCmnObj)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetLightReflecte", &mHRBattle::mSetLightReflecte)
			.addFunction("mInit", &mHRBattle::mInit)
			.addFunction("mFrameProc", &mHRBattle::mFrameProc)
			.addFunction("mSetVisibleAll", &mHRBattle::mSetVisibleAll)
			.addFunction("mSetOperateAll", &mHRBattle::mSetOperateAll)
			.addFunction("mSetNewGameDataRequest", &mHRBattle::mSetNewGameDataRequest)
			.addFunction("mTerm", &mHRBattle::mTerm)
			.addFunction("mPostRenderProc", &mHRBattle::mPostRenderProc)
			.addFunction("GetBowlingSubMissionResult", &mHRBattle::GetBowlingSubMissionResult)
			.addFunction("mCheckPcLoaded", &mHRBattle::mCheckPcLoaded)
			.addFunction("mGetPcOperate", &mHRBattle::mGetPcOperate)
			.addFunction("mSetMoveInitCamera", &mHRBattle::mSetMoveInitCamera)
			.addFunction("mInitStartMainMission", &mHRBattle::mInitStartMainMission)
			.addFunction("mGetNpcPtr", &mHRBattle::mGetNpcPtr)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitNpcDat", &mHRBattle::mSetInitNpcDat)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitObjDat", &mHRBattle::mSetInitObjDat)
			.addFunction("mSetPopType", &mHRBattle::mSetPopType)
			.addFunction("mSetPcKind", &mHRBattle::mSetPcKind)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitNpcDat2", &mHRBattle::mSetInitNpcDat2)
			// Can't export functions with more than 11 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat3", &mHRBattle::mSetInitNpcDat3)
			// Can't export functions with more than 11 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat4", &mHRBattle::mSetInitNpcDat4)
			// Can't export functions with more than 11 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat5", &mHRBattle::mSetInitNpcDat5)
			// Can't export functions with more than 11 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat6", &mHRBattle::mSetInitNpcDat6)
			// Can't export functions with more than 11 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat7", &mHRBattle::mSetInitNpcDat7)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitNpcDatObj095", &mHRBattle::mSetInitNpcDatObj095)
			.addFunction("mDispPcStatus", &mHRBattle::mDispPcStatus)
			.addFunction("mDispMiniMap", &mHRBattle::mDispMiniMap)
			.addFunction("mUndispMiniMap", &mHRBattle::mUndispMiniMap)
			.addFunction("mDeleteNpc", &mHRBattle::mDeleteNpc)
			.addFunction("RequestMotionNoNpc", &mHRBattle::RequestMotionNoNpc)
			.addFunction("mGetNpcPtrFromCharaType", &mHRBattle::mGetNpcPtrFromCharaType)
			.addFunction("mSetZakoNpcMotionProcessDisEnable", &mHRBattle::mSetZakoNpcMotionProcessDisEnable)
			.addFunction("mSetAspectRate", &mHRBattle::mSetAspectRate)
			.addFunction("mCheckExistEnemy", &mHRBattle::mCheckExistEnemy)
			.addFunction("mAllTestZakoDamage", &mHRBattle::mAllTestZakoDamage)
			.addFunction("mAllTestZakoTameDamage", &mHRBattle::mAllTestZakoTameDamage)
			.addFunction("mAllEnemyDie", &mHRBattle::mAllEnemyDie)
			.addFunction("mAllClearNpcData", &mHRBattle::mAllClearNpcData)
			.addFunction("mSetCameraProjection", &mHRBattle::mSetCameraProjection)
			.addFunction("mGetObjNpcID", &mHRBattle::mGetObjNpcID)
			.addFunction("mGetObjPtr", &mHRBattle::mGetObjPtr)
			.addFunction("mPopNpc", &mHRBattle::mPopNpc)
			.addFunction("mSetSlowMotionTick", &mHRBattle::mSetSlowMotionTick)
			.addFunction("mReleaseAllEnemy", &mHRBattle::mReleaseAllEnemy)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitNpcDatObj183", &mHRBattle::mSetInitNpcDatObj183)
			.addFunction("mReleaseAllNpc", &mHRBattle::mReleaseAllNpc)
			.addFunction("mSetDontAppearStatus", &mHRBattle::mSetDontAppearStatus)
			.addFunction("CameraMotionModeReset", &mHRBattle::CameraMotionModeReset)
			.addFunction("mSetPcOperate", &mHRBattle::mSetPcOperate)
			.addFunction("mUndispPcStatus", &mHRBattle::mUndispPcStatus)
			.addFunction("mRenderProc", &mHRBattle::mRenderProc)
			.addFunction("mGetNpcMotionSpd", &mHRBattle::mGetNpcMotionSpd)
			.addStaticFunction("mFrameProc_RegisterHook", &mHRBattle::mFrameProc_RegisterHook)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRBattle::PlayerInitializedState) == 4, "expected mHRBattle::PlayerInitializedState to be size 4");
static_assert(sizeof(mHRBattle::CameraProjection) == 4, "expected mHRBattle::CameraProjection to be size 4");
static_assert(sizeof(mHRBattle::LockNavelPos) == 1, "expected mHRBattle::LockNavelPos to be size 1");
static_assert(sizeof(mHRBattle::CameraMotionEndStop) == 1, "expected mHRBattle::CameraMotionEndStop to be size 1");
static_assert(sizeof(mHRBattle::btEffect) == 32, "expected mHRBattle::btEffect to be size 32");
static_assert(sizeof(mHRBattle::PcKind) == 4, "expected mHRBattle::PcKind to be size 4");
static_assert(sizeof(mHRBattle::PcPtr) == 4, "expected mHRBattle::PcPtr to be size 4");
static_assert(sizeof(mHRBattle::WeaponType) == 4, "expected mHRBattle::WeaponType to be size 4");
static_assert(sizeof(mHRBattle::UnknownWeaponPtr) == 4, "expected mHRBattle::UnknownWeaponPtr to be size 4");
static_assert(sizeof(mHRBattle::TotalKillNum) == 4, "expected mHRBattle::TotalKillNum to be size 4");
static_assert(sizeof(mHRBattle::KillNum) == 4, "expected mHRBattle::KillNum to be size 4");
static_assert(sizeof(mHRBattle::RevengeMissionZakoKillNum) == 4, "expected mHRBattle::RevengeMissionZakoKillNum to be size 4");
static_assert(sizeof(mHRBattle::NpcAttackRate) == 4, "expected mHRBattle::NpcAttackRate to be size 4");
static_assert(sizeof(mHRBattle::UnknownInt) == 4, "expected mHRBattle::UnknownInt to be size 4");
static_assert(sizeof(mHRBattle::NewGameDataRequest) == 1, "expected mHRBattle::NewGameDataRequest to be size 1");
static_assert(sizeof(mHRBattle::SaveData) == 1636, "expected mHRBattle::SaveData to be size 1636");
static_assert(sizeof(mHRBattle) == 0x23c3c, "expected mHRBattle to be size 0x23c3c");

// [Structure] class HrMissionResult
class HrMissionResult
{
public:
	// enum HrMissionResult::D_RESULT_TYPE
	enum D_RESULT_TYPE : uint32_t
	{
		// <D_RESULT_TYPE_FAILD = 0x0>
		D_RESULT_TYPE_FAILD = 0,

		// <XXX_D_RESULT_TYPE_SUCCESS = 0x1>
		XXX_D_RESULT_TYPE_SUCCESS = 1,

		// <D_RESULT_TYPE_REVENGE_SUCCESS = 0x2>
		D_RESULT_TYPE_REVENGE_SUCCESS = 2,

		// <D_RESULT_TYPE_RANKING_UP = 0x3>
		D_RESULT_TYPE_RANKING_UP = 3,

		// <D_RESULT_TYPE_MISSION_START = 0x4>
		D_RESULT_TYPE_MISSION_START = 4,

		// <D_RESULT_TYPE_MISSION_TIMEUP = 0x5>
		D_RESULT_TYPE_MISSION_TIMEUP = 5,

		// <D_RESULT_TYPE_SCORPION_TIMEUP = 0x6>
		D_RESULT_TYPE_SCORPION_TIMEUP = 6,

		// <D_RESULT_TYPE_REVENGE_FAILD = 0x7>
		D_RESULT_TYPE_REVENGE_FAILD = 7,

		// <D_RESULT_TYPE_REVENGE_TIMEUP = 0x8>
		D_RESULT_TYPE_REVENGE_TIMEUP = 8

	};

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[100];

public:
	// <int32_t ResultType, offset 0x64>
	int32_t ResultType = 0;

	// <Unidentified data segment, offset 0x68>
private:
	char _UnidentifiedData_104[4504];

public:
	/// 22 Functions

	// [Function] void __convention("thiscall") HrMissionResult::dSetCameraPos(class HrMissionResult* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4) [?dSetCameraPos@HrMissionResult@@QAEXHAAUVec@@0@Z]
	typedef void(__thiscall* _dSetCameraPos_HrMissionResult__QAEXHAAUVec__0_Z)(class HrMissionResult* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4);
	void dSetCameraPos(int32_t arg2, struct Vec& arg3, struct Vec& arg4)
	{
		_dSetCameraPos_HrMissionResult__QAEXHAAUVec__0_Z mFunc = (_dSetCameraPos_HrMissionResult__QAEXHAAUVec__0_Z)(GameModule + 0xafb10);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") HrMissionResult::dSetSceneTime(class HrMissionResult* const this, int32_t arg2, uint8_t arg3) [?dSetSceneTime@HrMissionResult@@QAEXHE@Z]
	typedef void(__thiscall* _dSetSceneTime_HrMissionResult__QAEXHE_Z)(class HrMissionResult* const thisPtr, int32_t arg2, uint8_t arg3);
	void dSetSceneTime(int32_t arg2, uint8_t arg3)
	{
		_dSetSceneTime_HrMissionResult__QAEXHE_Z mFunc = (_dSetSceneTime_HrMissionResult__QAEXHE_Z)(GameModule + 0xafb60);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") HrMissionResult::dGetStat(class HrMissionResult* const this) [?dGetStat@HrMissionResult@@QAEHXZ]
	typedef int32_t(__thiscall* _dGetStat_HrMissionResult__QAEHXZ)(class HrMissionResult* const thisPtr);
	int32_t dGetStat()
	{
		_dGetStat_HrMissionResult__QAEHXZ mFunc = (_dGetStat_HrMissionResult__QAEHXZ)(GameModule + 0xafb80);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") HrMissionResult::dGetMode(class HrMissionResult* const this) [?dGetMode@HrMissionResult@@QAEHXZ]
	typedef int32_t(__thiscall* _dGetMode_HrMissionResult__QAEHXZ)(class HrMissionResult* const thisPtr);
	int32_t dGetMode()
	{
		_dGetMode_HrMissionResult__QAEHXZ mFunc = (_dGetMode_HrMissionResult__QAEHXZ)(GameModule + 0xafb90);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") HrMissionResult::dGetResultType(class HrMissionResult* const this) [?dGetResultType@HrMissionResult@@QAEHXZ]
	typedef int32_t(__thiscall* _dGetResultType_HrMissionResult__QAEHXZ)(class HrMissionResult* const thisPtr);
	int32_t dGetResultType()
	{
		_dGetResultType_HrMissionResult__QAEHXZ mFunc = (_dGetResultType_HrMissionResult__QAEHXZ)(GameModule + 0xafba0);
		return mFunc(this);
	}
	// [Function] class HrTask* HrMissionResult::TestCreate() [?TestCreate@HrMissionResult@@SAPAVHrTask@@XZ]
	typedef class HrTask*(__fastcall* _TestCreate_HrMissionResult__SAPAVHrTask__XZ)();
	static class HrTask* TestCreate()
	{
		_TestCreate_HrMissionResult__SAPAVHrTask__XZ mFunc = (_TestCreate_HrMissionResult__SAPAVHrTask__XZ)(GameModule + 0x5ad300);
		return mFunc();
	}
	// [Function] void __convention("thiscall") HrMissionResult::MissionStartRender(class HrMissionResult* const this) [?MissionStartRender@HrMissionResult@@AAEXXZ]
	typedef void(__thiscall* _MissionStartRender_HrMissionResult__AAEXXZ)(class HrMissionResult* const thisPtr);
	void MissionStartRender()
	{
		_MissionStartRender_HrMissionResult__AAEXXZ mFunc = (_MissionStartRender_HrMissionResult__AAEXXZ)(GameModule + 0x5ad310);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMissionResult::FaildRender(class HrMissionResult* const this) [?FaildRender@HrMissionResult@@AAEXXZ]
	typedef void(__thiscall* _FaildRender_HrMissionResult__AAEXXZ)(class HrMissionResult* const thisPtr);
	void FaildRender()
	{
		_FaildRender_HrMissionResult__AAEXXZ mFunc = (_FaildRender_HrMissionResult__AAEXXZ)(GameModule + 0x5ad540);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMissionResult::RevengeFaildRender(class HrMissionResult* const this) [?RevengeFaildRender@HrMissionResult@@AAEXXZ]
	typedef void(__thiscall* _RevengeFaildRender_HrMissionResult__AAEXXZ)(class HrMissionResult* const thisPtr);
	void RevengeFaildRender()
	{
		_RevengeFaildRender_HrMissionResult__AAEXXZ mFunc = (_RevengeFaildRender_HrMissionResult__AAEXXZ)(GameModule + 0x5ade30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMissionResult::RevengeFaildFrame(class HrMissionResult* const this) [?RevengeFaildFrame@HrMissionResult@@AAE_NXZ]
	typedef uint8_t(__thiscall* _RevengeFaildFrame_HrMissionResult__AAE_NXZ)(class HrMissionResult* const thisPtr);
	uint8_t RevengeFaildFrame()
	{
		_RevengeFaildFrame_HrMissionResult__AAE_NXZ mFunc = (_RevengeFaildFrame_HrMissionResult__AAE_NXZ)(GameModule + 0x5adeb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMissionResult::RevengeClearRender(class HrMissionResult* const this) [?RevengeClearRender@HrMissionResult@@AAEXXZ]
	typedef void(__thiscall* _RevengeClearRender_HrMissionResult__AAEXXZ)(class HrMissionResult* const thisPtr);
	void RevengeClearRender()
	{
		_RevengeClearRender_HrMissionResult__AAEXXZ mFunc = (_RevengeClearRender_HrMissionResult__AAEXXZ)(GameModule + 0x5adf90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMissionResult::RevengeClearFrame(class HrMissionResult* const this) [?RevengeClearFrame@HrMissionResult@@AAE_NXZ]
	typedef uint8_t(__thiscall* _RevengeClearFrame_HrMissionResult__AAE_NXZ)(class HrMissionResult* const thisPtr);
	uint8_t RevengeClearFrame()
	{
		_RevengeClearFrame_HrMissionResult__AAE_NXZ mFunc = (_RevengeClearFrame_HrMissionResult__AAE_NXZ)(GameModule + 0x5ae100);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMissionResult::RenderProcess(class HrMissionResult* const this) [?RenderProcess@HrMissionResult@@MAEXXZ]
	typedef void(__thiscall* _RenderProcess_HrMissionResult__MAEXXZ)(class HrMissionResult* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_HrMissionResult__MAEXXZ mFunc = (_RenderProcess_HrMissionResult__MAEXXZ)(GameModule + 0x5ae170);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMissionResult::MissionStartFrame(class HrMissionResult* const this) [?MissionStartFrame@HrMissionResult@@AAE_NXZ]
	typedef uint8_t(__thiscall* _MissionStartFrame_HrMissionResult__AAE_NXZ)(class HrMissionResult* const thisPtr);
	uint8_t MissionStartFrame()
	{
		_MissionStartFrame_HrMissionResult__AAE_NXZ mFunc = (_MissionStartFrame_HrMissionResult__AAE_NXZ)(GameModule + 0x5ae3a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMissionResult::FaildFrame(class HrMissionResult* const this) [?FaildFrame@HrMissionResult@@AAE_NXZ]
	typedef uint8_t(__thiscall* _FaildFrame_HrMissionResult__AAE_NXZ)(class HrMissionResult* const thisPtr);
	uint8_t FaildFrame()
	{
		_FaildFrame_HrMissionResult__AAE_NXZ mFunc = (_FaildFrame_HrMissionResult__AAE_NXZ)(GameModule + 0x5ae8b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMissionResult::FrameProcess(class HrMissionResult* const this) [?FrameProcess@HrMissionResult@@MAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrMissionResult__MAEXXZ)(class HrMissionResult* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrMissionResult__MAEXXZ mFunc = (_FrameProcess_HrMissionResult__MAEXXZ)(GameModule + 0x5aed60);
		return mFunc(this);
	}
	// [Function] int16_t __convention("thiscall") HrMissionResult::GetRandPos(class HrMissionResult* const this, int32_t arg2, int16_t* arg3, int16_t* arg4) [?GetRandPos@HrMissionResult@@AAEFHPAF0@Z]
	typedef int16_t(__thiscall* _GetRandPos_HrMissionResult__AAEFHPAF0_Z)(class HrMissionResult* const thisPtr, int32_t arg2, int16_t* arg3, int16_t* arg4);
	int16_t GetRandPos(int32_t arg2, int16_t* arg3, int16_t* arg4)
	{
		_GetRandPos_HrMissionResult__AAEFHPAF0_Z mFunc = (_GetRandPos_HrMissionResult__AAEFHPAF0_Z)(GameModule + 0x5af610);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") HrMissionResult::Terminate(class HrMissionResult* const this) [?Terminate@HrMissionResult@@MAEXXZ]
	typedef void(__thiscall* _Terminate_HrMissionResult__MAEXXZ)(class HrMissionResult* const thisPtr);
	void Terminate()
	{
		_Terminate_HrMissionResult__MAEXXZ mFunc = (_Terminate_HrMissionResult__MAEXXZ)(GameModule + 0x5af830);
		return mFunc(this);
	}
	// [Function] class HrMissionResult* HrMissionResult::Create() [?Create@HrMissionResult@@SAPAV1@XZ]
	typedef class HrMissionResult*(__fastcall* _Create_HrMissionResult__SAPAV1_XZ)();
	static class HrMissionResult* Create()
	{
		_Create_HrMissionResult__SAPAV1_XZ mFunc = (_Create_HrMissionResult__SAPAV1_XZ)(GameModule + 0x5afa80);
		return mFunc();
	}
	// [Function] uint8_t __convention("thiscall") HrMissionResult::Initialize(class HrMissionResult* const this) [?Initialize@HrMissionResult@@QAE_NXZ]
	typedef uint8_t(__thiscall* _Initialize_HrMissionResult__QAE_NXZ)(class HrMissionResult* const thisPtr);
	uint8_t Initialize()
	{
		_Initialize_HrMissionResult__QAE_NXZ mFunc = (_Initialize_HrMissionResult__QAE_NXZ)(GameModule + 0x5afb90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMissionResult::dAppear(class HrMissionResult* const this, uint32_t arg2, int16_t arg3, int16_t arg4, int32_t arg5, char arg6, enum HrMissionResult::D_RESULT_TYPE arg7, int16_t arg8, int16_t arg9) [?dAppear@HrMissionResult@@QAE_NIFFHCW4D_RESULT_TYPE@1@FF@Z]
	typedef uint8_t(__thiscall* _dAppear_HrMissionResult__QAE_NIFFHCW4D_RESULT_TYPE_1_FF_Z)(class HrMissionResult* const thisPtr, uint32_t arg2, int16_t arg3, int16_t arg4, int32_t arg5, char arg6, enum HrMissionResult::D_RESULT_TYPE arg7, int16_t arg8, int16_t arg9);
	uint8_t dAppear(uint32_t arg2, int16_t arg3, int16_t arg4, int32_t arg5, char arg6, /* enum HrMissionResult::D_RESULT_TYPE */ uint32_t arg7, int16_t arg8, int16_t arg9)
	{
		_dAppear_HrMissionResult__QAE_NIFFHCW4D_RESULT_TYPE_1_FF_Z mFunc = (_dAppear_HrMissionResult__QAE_NIFFHCW4D_RESULT_TYPE_1_FF_Z)(GameModule + 0x5afca0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, (enum HrMissionResult::D_RESULT_TYPE)arg7, arg8, arg9);
	}
	// [Function] uint8_t __convention("thiscall") HrMissionResult::dLeaving(class HrMissionResult* const this) [?dLeaving@HrMissionResult@@QAE_NXZ]
	typedef uint8_t(__thiscall* _dLeaving_HrMissionResult__QAE_NXZ)(class HrMissionResult* const thisPtr);
	uint8_t dLeaving()
	{
		_dLeaving_HrMissionResult__QAE_NXZ mFunc = (_dLeaving_HrMissionResult__QAE_NXZ)(GameModule + 0x5b0110);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMissionResult [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMissionResult& InObject)
	{
		ResultType = InObject.ResultType;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrMissionResult>("HrMissionResult")
			.addFunction("__tostring", &HrMissionResult::ToString)
			.addFunction("GetPtrAddr", &HrMissionResult::GetPtrAddr)
			.addProperty("ResultType", &HrMissionResult::ResultType)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("dSetCameraPos", &HrMissionResult::dSetCameraPos)
			.addFunction("dSetSceneTime", &HrMissionResult::dSetSceneTime)
			.addFunction("dGetStat", &HrMissionResult::dGetStat)
			.addFunction("dGetMode", &HrMissionResult::dGetMode)
			.addFunction("dGetResultType", &HrMissionResult::dGetResultType)
			.addStaticFunction("TestCreate", &HrMissionResult::TestCreate)
			.addFunction("MissionStartRender", &HrMissionResult::MissionStartRender)
			.addFunction("FaildRender", &HrMissionResult::FaildRender)
			.addFunction("RevengeFaildRender", &HrMissionResult::RevengeFaildRender)
			.addFunction("RevengeFaildFrame", &HrMissionResult::RevengeFaildFrame)
			.addFunction("RevengeClearRender", &HrMissionResult::RevengeClearRender)
			.addFunction("RevengeClearFrame", &HrMissionResult::RevengeClearFrame)
			.addFunction("RenderProcess", &HrMissionResult::RenderProcess)
			.addFunction("MissionStartFrame", &HrMissionResult::MissionStartFrame)
			.addFunction("FaildFrame", &HrMissionResult::FaildFrame)
			.addFunction("FrameProcess", &HrMissionResult::FrameProcess)
			// Can't export pointer to native type 'int16_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("GetRandPos", &HrMissionResult::GetRandPos)
			.addFunction("Terminate", &HrMissionResult::Terminate)
			.addStaticFunction("Create", &HrMissionResult::Create)
			.addFunction("Initialize", &HrMissionResult::Initialize)
			.addFunction("dAppear", &HrMissionResult::dAppear)
			.addFunction("dLeaving", &HrMissionResult::dLeaving)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMissionResult::ResultType) == 4, "expected HrMissionResult::ResultType to be size 4");
static_assert(sizeof(HrMissionResult) == 0x1200, "expected HrMissionResult to be size 0x1200");

// enum BATTLE_SIMPLMESSEAGE_NUM
enum BATTLE_SIMPLMESSEAGE_NUM : uint32_t
{
	// <BSM_HP_RECOVER = 0x0>
	BSM_HP_RECOVER = 0,

	// <BSM_VT_RECOVER = 0x1>
	BSM_VT_RECOVER = 1,

	// <BSM_HP_FULL = 0x2>
	BSM_HP_FULL = 2,

	// <BSM_VT_FULL = 0x3>
	BSM_VT_FULL = 3,

	// <BSM_TENSION_UP = 0x4>
	BSM_TENSION_UP = 4,

	// <BSM_DEAD_POISON = 0x5>
	BSM_DEAD_POISON = 5,

	// <BSM_POISON_CLEAR = 0x6>
	BSM_POISON_CLEAR = 6,

	// <BSM_GET_MOMEY = 0x7>
	BSM_GET_MOMEY = 7,

	// <BSM_ALL_ENEMY = 0x8>
	BSM_ALL_ENEMY = 8,

	// <BSM_EVENT_ROCK = 0x9>
	BSM_EVENT_ROCK = 9,

	// <BSM_RELEASE_ROCK = 0xa>
	BSM_RELEASE_ROCK = 10,

	// <BSM_BREAK_DOOR = 0xb>
	BSM_BREAK_DOOR = 11,

	// <BSM_CHANGE_WEAPON = 0xc>
	BSM_CHANGE_WEAPON = 12,

	// <BSM_MAP_POINT = 0xd>
	BSM_MAP_POINT = 13,

	// <BSM_ENEMY_KATANA = 0xe>
	BSM_ENEMY_KATANA = 14,

	// <BSM_MOTEL_01 = 0xf>
	BSM_MOTEL_01 = 15,

	// <BSM_MOTEL_02 = 0x10>
	BSM_MOTEL_02 = 16,

	// <BSM_MOTEL_03 = 0x11>
	BSM_MOTEL_03 = 17,

	// <BSM_MOTEL_04 = 0x12>
	BSM_MOTEL_04 = 18,

	// <BSM_MOTEL_05 = 0x13>
	BSM_MOTEL_05 = 19,

	// <BSM_MOTEL_06 = 0x14>
	BSM_MOTEL_06 = 20,

	// <BSM_MOTEL_07 = 0x15>
	BSM_MOTEL_07 = 21,

	// <BSM_MOTEL_08 = 0x16>
	BSM_MOTEL_08 = 22,

	// <BSM_MOTEL_09 = 0x17>
	BSM_MOTEL_09 = 23,

	// <BSM_MOTEL_10 = 0x18>
	BSM_MOTEL_10 = 24,

	// <BSM_MOTEL_11 = 0x19>
	BSM_MOTEL_11 = 25,

	// <BSM_MOTEL_12 = 0x1a>
	BSM_MOTEL_12 = 26,

	// <BSM_MOTEL_13 = 0x1b>
	BSM_MOTEL_13 = 27,

	// <BSM_MOTEL_14 = 0x1c>
	BSM_MOTEL_14 = 28,

	// <BSM_MOTEL_15 = 0x1d>
	BSM_MOTEL_15 = 29,

	// <BSM_UAA_NO51 = 0x1e>
	BSM_UAA_NO51 = 30,

	// <BSM_UAA_NO50 = 0x1f>
	BSM_UAA_NO50 = 31,

	// <BSM_UAA_NO25 = 0x20>
	BSM_UAA_NO25 = 32,

	// <BSM_UAA_NOCH = 0x21>
	BSM_UAA_NOCH = 33,

	// <BSM_UAA_NO24 = 0x22>
	BSM_UAA_NO24 = 34,

	// <BSM_UAA_NO23 = 0x23>
	BSM_UAA_NO23 = 35,

	// <BSM_UAA_NO11 = 0x24>
	BSM_UAA_NO11 = 36,

	// <BSM_UAA_NO10 = 0x25>
	BSM_UAA_NO10 = 37,

	// <BSM_UAA_NO9 = 0x26>
	BSM_UAA_NO9 = 38,

	// <BSM_UAA_NO8 = 0x27>
	BSM_UAA_NO8 = 39,

	// <BSM_UAA_NODA = 0x28>
	BSM_UAA_NODA = 40,

	// <BSM_UAA_NO4 = 0x29>
	BSM_UAA_NO4 = 41,

	// <BSM_UAA_NO3 = 0x2a>
	BSM_UAA_NO3 = 42,

	// <BSM_UAA_NO2 = 0x2b>
	BSM_UAA_NO2 = 43,

	// <BSM_UAA_NO1 = 0x2c>
	BSM_UAA_NO1 = 44,

	// <BATTLESM_MAX = 0x2d>
	BATTLESM_MAX = 45

};

// [Structure] class CHrHUDDemoButton
class CHrHUDDemoButton
{
public:
	// enum CHrHUDDemoButton::PICT_ID_DEMO_BUTTON
	enum PICT_ID_DEMO_BUTTON : uint32_t
	{
		// <PICT_ID_BUTTON_A = 0x0>
		PICT_ID_BUTTON_A = 0,

		// <PICT_ID_BUTTON_B = 0x1>
		PICT_ID_BUTTON_B = 1,

		// <PICT_ID_BUTTON_C = 0x2>
		PICT_ID_BUTTON_C = 2,

		// <PICT_ID_BUTTON_Z = 0x3>
		PICT_ID_BUTTON_Z = 3,

		// <PICT_ID_BUTTON_CLASSIC_A = 0x4>
		PICT_ID_BUTTON_CLASSIC_A = 4,

		// <PICT_ID_BUTTON_CLASSIC_B = 0x5>
		PICT_ID_BUTTON_CLASSIC_B = 5,

		// <PICT_ID_BUTTON_CLASSIC_X = 0x6>
		PICT_ID_BUTTON_CLASSIC_X = 6,

		// <PICT_ID_BUTTON_CLASSIC_Y = 0x7>
		PICT_ID_BUTTON_CLASSIC_Y = 7,

		// <PICT_ID_BUTTON_ABCZ = 0x8>
		PICT_ID_BUTTON_ABCZ = 8,

		// <PICT_ID_BUTTON_CLASSIC_ABXY = 0x9>
		PICT_ID_BUTTON_CLASSIC_ABXY = 9,

		// <PICT_ID_MAX = 0xa>
		PICT_ID_MAX = 10

	};

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[432];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CHrHUDDemoButton [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CHrHUDDemoButton& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CHrHUDDemoButton>("CHrHUDDemoButton")
			.addFunction("__tostring", &CHrHUDDemoButton::ToString)
			.addFunction("GetPtrAddr", &CHrHUDDemoButton::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CHrHUDDemoButton) == 0x1b0, "expected CHrHUDDemoButton to be size 0x1b0");

// [Structure] class HrScreenStatusBalloon
class HrScreenStatusBalloon
{
public:
	// enum HrScreenStatusBalloon::OBJ_ID
	enum OBJ_ID : uint32_t
	{
		// <OBJ_ID_WEAPON_A = 0x0>
		OBJ_ID_WEAPON_A = 0,

		// <OBJ_ID_WEAPON_B = 0x1>
		OBJ_ID_WEAPON_B = 1,

		// <OBJ_ID_WEAPON_C = 0x2>
		OBJ_ID_WEAPON_C = 2,

		// <OBJ_ID_WEAPON_D = 0x3>
		OBJ_ID_WEAPON_D = 3,

		// <OBJ_ID_A = 0x4>
		OBJ_ID_A = 4,

		// <OBJ_ID_CAN_NOT_DROP_OFF = 0x5>
		OBJ_ID_CAN_NOT_DROP_OFF = 5,

		// <OBJ_ID_RIMOCON_SHAKE = 0x6>
		OBJ_ID_RIMOCON_SHAKE = 6,

		// <OBJ_ID_CAN_DOWN_ATTACK = 0x7>
		OBJ_ID_CAN_DOWN_ATTACK = 7,

		// <OBJ_ID_EXIT = 0x8>
		OBJ_ID_EXIT = 8,

		// <OBJ_ID_CLOSET = 0x9>
		OBJ_ID_CLOSET = 9,

		// <OBJ_ID_JEANE = 0xa>
		OBJ_ID_JEANE = 10,

		// <OBJ_ID_SHELF = 0xb>
		OBJ_ID_SHELF = 11,

		// <OBJ_ID_TELEVISION = 0xc>
		OBJ_ID_TELEVISION = 12,

		// <OBJ_ID_TOILET = 0xd>
		OBJ_ID_TOILET = 13,

		// <OBJ_ID_BUTTON_A_SCREEN = 0xe>
		OBJ_ID_BUTTON_A_SCREEN = 14,

		// <OBJ_ID_MAX = 0xf>
		OBJ_ID_MAX = 15

	};

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[1696];

public:
	/// 8 Functions

	// [Function] uint8_t __convention("thiscall") HrScreenStatusBalloon::IsActive(class HrScreenStatusBalloon* const this) [?IsActive@HrScreenStatusBalloon@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsActive_HrScreenStatusBalloon__QAE_NXZ)(class HrScreenStatusBalloon* const thisPtr);
	uint8_t IsActive()
	{
		_IsActive_HrScreenStatusBalloon__QAE_NXZ mFunc = (_IsActive_HrScreenStatusBalloon__QAE_NXZ)(GameModule + 0xafbf0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatusBalloon::IsAppear(class HrScreenStatusBalloon* const this, enum HrScreenStatusBalloon::OBJ_ID arg2) [?IsAppear@HrScreenStatusBalloon@@QAE_NW4OBJ_ID@1@@Z]
	typedef uint8_t(__thiscall* _IsAppear_HrScreenStatusBalloon__QAE_NW4OBJ_ID_1__Z)(class HrScreenStatusBalloon* const thisPtr, enum HrScreenStatusBalloon::OBJ_ID arg2);
	uint8_t IsAppear(/* enum HrScreenStatusBalloon::OBJ_ID */ uint32_t arg2)
	{
		_IsAppear_HrScreenStatusBalloon__QAE_NW4OBJ_ID_1__Z mFunc = (_IsAppear_HrScreenStatusBalloon__QAE_NW4OBJ_ID_1__Z)(GameModule + 0xafc00);
		return mFunc(this, (enum HrScreenStatusBalloon::OBJ_ID)arg2);
	}
	// [Function] struct NYPictData* __convention("thiscall") HrScreenStatusBalloon::GetPictData(class HrScreenStatusBalloon* const this, int32_t arg2) [?GetPictData@HrScreenStatusBalloon@@AAEPAUNYPictData@@H@Z]
	typedef struct NYPictData*(__thiscall* _GetPictData_HrScreenStatusBalloon__AAEPAUNYPictData__H_Z)(class HrScreenStatusBalloon* const thisPtr, int32_t arg2);
	struct NYPictData* GetPictData(int32_t arg2)
	{
		_GetPictData_HrScreenStatusBalloon__AAEPAUNYPictData__H_Z mFunc = (_GetPictData_HrScreenStatusBalloon__AAEPAUNYPictData__H_Z)(GameModule + 0x5a0b20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatusBalloon::LeaveAll(class HrScreenStatusBalloon* const this, uint8_t arg2) [?LeaveAll@HrScreenStatusBalloon@@QAEX_N@Z]
	typedef void(__thiscall* _LeaveAll_HrScreenStatusBalloon__QAEX_N_Z)(class HrScreenStatusBalloon* const thisPtr, uint8_t arg2);
	void LeaveAll(uint8_t arg2)
	{
		_LeaveAll_HrScreenStatusBalloon__QAEX_N_Z mFunc = (_LeaveAll_HrScreenStatusBalloon__QAEX_N_Z)(GameModule + 0x5a0c60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatusBalloon::FrameProcess(class HrScreenStatusBalloon* const this) [?FrameProcess@HrScreenStatusBalloon@@QAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrScreenStatusBalloon__QAEXXZ)(class HrScreenStatusBalloon* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrScreenStatusBalloon__QAEXXZ mFunc = (_FrameProcess_HrScreenStatusBalloon__QAEXXZ)(GameModule + 0x5a0d50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatusBalloon::RenderProcess(class HrScreenStatusBalloon* const this) [?RenderProcess@HrScreenStatusBalloon@@QAEXXZ]
	typedef void(__thiscall* _RenderProcess_HrScreenStatusBalloon__QAEXXZ)(class HrScreenStatusBalloon* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_HrScreenStatusBalloon__QAEXXZ mFunc = (_RenderProcess_HrScreenStatusBalloon__QAEXXZ)(GameModule + 0x5a0f70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatusBalloon::Appear(class HrScreenStatusBalloon* const this, enum HrScreenStatusBalloon::OBJ_ID arg2, uint8_t arg3) [?Appear@HrScreenStatusBalloon@@QAEXW4OBJ_ID@1@_N@Z]
	typedef void(__thiscall* _Appear_HrScreenStatusBalloon__QAEXW4OBJ_ID_1__N_Z)(class HrScreenStatusBalloon* const thisPtr, enum HrScreenStatusBalloon::OBJ_ID arg2, uint8_t arg3);
	void Appear(/* enum HrScreenStatusBalloon::OBJ_ID */ uint32_t arg2, uint8_t arg3)
	{
		_Appear_HrScreenStatusBalloon__QAEXW4OBJ_ID_1__N_Z mFunc = (_Appear_HrScreenStatusBalloon__QAEXW4OBJ_ID_1__N_Z)(GameModule + 0x5a1260);
		return mFunc(this, (enum HrScreenStatusBalloon::OBJ_ID)arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrScreenStatusBalloon::Leave(class HrScreenStatusBalloon* const this, enum HrScreenStatusBalloon::OBJ_ID arg2, uint8_t arg3) [?Leave@HrScreenStatusBalloon@@QAEXW4OBJ_ID@1@_N@Z]
	typedef void(__thiscall* _Leave_HrScreenStatusBalloon__QAEXW4OBJ_ID_1__N_Z)(class HrScreenStatusBalloon* const thisPtr, enum HrScreenStatusBalloon::OBJ_ID arg2, uint8_t arg3);
	void Leave(/* enum HrScreenStatusBalloon::OBJ_ID */ uint32_t arg2, uint8_t arg3)
	{
		_Leave_HrScreenStatusBalloon__QAEXW4OBJ_ID_1__N_Z mFunc = (_Leave_HrScreenStatusBalloon__QAEXW4OBJ_ID_1__N_Z)(GameModule + 0x5a17b0);
		return mFunc(this, (enum HrScreenStatusBalloon::OBJ_ID)arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrScreenStatusBalloon [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrScreenStatusBalloon& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrScreenStatusBalloon>("HrScreenStatusBalloon")
			.addFunction("__tostring", &HrScreenStatusBalloon::ToString)
			.addFunction("GetPtrAddr", &HrScreenStatusBalloon::GetPtrAddr)
			.addFunction("IsActive", &HrScreenStatusBalloon::IsActive)
			.addFunction("IsAppear", &HrScreenStatusBalloon::IsAppear)
			.addFunction("GetPictData", &HrScreenStatusBalloon::GetPictData)
			.addFunction("LeaveAll", &HrScreenStatusBalloon::LeaveAll)
			.addFunction("FrameProcess", &HrScreenStatusBalloon::FrameProcess)
			.addFunction("RenderProcess", &HrScreenStatusBalloon::RenderProcess)
			.addFunction("Appear", &HrScreenStatusBalloon::Appear)
			.addFunction("Leave", &HrScreenStatusBalloon::Leave)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrScreenStatusBalloon) == 0x6a0, "expected HrScreenStatusBalloon to be size 0x6a0");

// enum GHMR_TEXDOT_ASPECT
enum GHMR_TEXDOT_ASPECT : uint32_t
{
	// <GHMR_TEXDOT_ASPECT_1x1 = 0x0>
	GHMR_TEXDOT_ASPECT_1x1 = 0,

	// <GHMR_TEXDOT_ASPECT_CANCEL = 0x1>
	GHMR_TEXDOT_ASPECT_CANCEL = 1

};

// enum _GXTexFmt
enum _GXTexFmt : uint32_t
{
	// <GX_TF_I4 = 0x0>
	GX_TF_I4 = 0,

	// <GX_TF_I8 = 0x1>
	GX_TF_I8 = 1,

	// <GX_TF_IA4 = 0x2>
	GX_TF_IA4 = 2,

	// <GX_TF_IA8 = 0x3>
	GX_TF_IA8 = 3,

	// <GX_TF_RGB565 = 0x4>
	GX_TF_RGB565 = 4,

	// <GX_TF_RGB5A3 = 0x5>
	GX_TF_RGB5A3 = 5,

	// <GX_TF_RGBA8 = 0x6>
	GX_TF_RGBA8 = 6,

	// <GX_TF_CMPR = 0xe>
	GX_TF_CMPR = 14,

	// <GX_CTF_R4 = 0x20>
	GX_CTF_R4 = 32,

	// <GX_CTF_RA4 = 0x22>
	GX_CTF_RA4 = 34,

	// <GX_CTF_RA8 = 0x23>
	GX_CTF_RA8 = 35,

	// <GX_CTF_YUVA8 = 0x26>
	GX_CTF_YUVA8 = 38,

	// <GX_CTF_A8 = 0x27>
	GX_CTF_A8 = 39,

	// <GX_CTF_R8 = 0x28>
	GX_CTF_R8 = 40,

	// <GX_CTF_G8 = 0x29>
	GX_CTF_G8 = 41,

	// <GX_CTF_B8 = 0x2a>
	GX_CTF_B8 = 42,

	// <GX_CTF_RG8 = 0x2b>
	GX_CTF_RG8 = 43,

	// <GX_CTF_GB8 = 0x2c>
	GX_CTF_GB8 = 44,

	// <GX_TF_Z8 = 0x11>
	GX_TF_Z8 = 17,

	// <GX_TF_Z16 = 0x13>
	GX_TF_Z16 = 19,

	// <GX_TF_Z24X8 = 0x16>
	GX_TF_Z24X8 = 22,

	// <GX_CTF_Z4 = 0x30>
	GX_CTF_Z4 = 48,

	// <GX_CTF_Z8M = 0x39>
	GX_CTF_Z8M = 57,

	// <GX_CTF_Z8L = 0x3a>
	GX_CTF_Z8L = 58,

	// <GX_CTF_Z16L = 0x3c>
	GX_CTF_Z16L = 60,

	// <GX_TF_A8 = 0x27>
	GX_TF_A8 = 39

};

// enum GHMR_TEXFILTER
enum GHMR_TEXFILTER : uint32_t
{
	// <GHMR_TEXFILTER_NEAR = 0x0>
	GHMR_TEXFILTER_NEAR = 0,

	// <GHMR_TEXFILTER_LINEAR = 0x1>
	GHMR_TEXFILTER_LINEAR = 1

};

// enum GHMR_TEXADDRESS
enum GHMR_TEXADDRESS : uint32_t
{
	// <GHMR_TEXADDRESS_CLAMP = 0x0>
	GHMR_TEXADDRESS_CLAMP = 0,

	// <GHMR_TEXADDRESS_REPEAT = 0x1>
	GHMR_TEXADDRESS_REPEAT = 1,

	// <GHMR_TEXADDRESS_MIRROR = 0x2>
	GHMR_TEXADDRESS_MIRROR = 2,

	// <GHMR_TEXADDRESS_REPEAT_FORCED = 0x3>
	GHMR_TEXADDRESS_REPEAT_FORCED = 3,

	// <GHMR_TEXADDRESS_MIRROR_FORCED = 0x4>
	GHMR_TEXADDRESS_MIRROR_FORCED = 4

};

// [Structure] struct GXTexObj
struct GXTexObj
{
public:
	/// Struct member variables

	// <class GXTexture* pTex, offset 0x0>
	class GXTexture* pTex = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct GXTexObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GXTexObj& InObject)
	{
		pTex = InObject.pTex;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXTexObj>("GXTexObj")
			.addFunction("__tostring", &GXTexObj::ToString)
			.addFunction("GetPtrAddr", &GXTexObj::GetPtrAddr)
			.addProperty("pTex", &GXTexObj::pTex)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXTexObj::pTex) == 4, "expected GXTexObj::pTex to be size 4");
static_assert(sizeof(GXTexObj) == 0x4, "expected GXTexObj to be size 0x4");

// [Structure] struct tagGHMR_TEX
struct tagGHMR_TEX
{
public:
	/// Struct member variables

	// <uint8_t TMEFlag, offset 0x0>
	uint8_t TMEFlag = 0;

	// <uint8_t AlphaFlag, offset 0x1>
	uint8_t AlphaFlag = 0;

	// <uint8_t ImageBufferFreeFlag, offset 0x2>
	uint8_t ImageBufferFreeFlag = 0;

	// <Unidentified data segment, offset 0x3>
private:
	char _UnidentifiedData_3[1];

public:
	// <void* FileImage, offset 0x4>
	void* FileImage = nullptr;

	// <void* ImageBuffer, offset 0x8>
	void* ImageBuffer = nullptr;

	// <uint16_t Width, offset 0xc>
	uint16_t Width = 0;

	// <uint16_t Height, offset 0xe>
	uint16_t Height = 0;

	// <struct GXTexObj TexObj, offset 0x10>
	struct GXTexObj TexObj;

	// <enum GHMR_TEXADDRESS AddressMode, offset 0x14>
	enum GHMR_TEXADDRESS AddressMode;

	// <enum GHMR_TEXFILTER FilterMode, offset 0x18>
	enum GHMR_TEXFILTER FilterMode;

	// <enum _GXTexFmt GetScreenImageFormat, offset 0x1c>
	enum _GXTexFmt GetScreenImageFormat;

	// <int32_t ImageSize, offset 0x20>
	int32_t ImageSize = 0;

	// <enum GHMR_TEXDOT_ASPECT Aspect, offset 0x24>
	enum GHMR_TEXDOT_ASPECT Aspect;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct tagGHMR_TEX [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tagGHMR_TEX& InObject)
	{
		TMEFlag = InObject.TMEFlag;
		AlphaFlag = InObject.AlphaFlag;
		ImageBufferFreeFlag = InObject.ImageBufferFreeFlag;
		FileImage = InObject.FileImage;
		ImageBuffer = InObject.ImageBuffer;
		Width = InObject.Width;
		Height = InObject.Height;
		TexObj = InObject.TexObj;
		AddressMode = InObject.AddressMode;
		FilterMode = InObject.FilterMode;
		GetScreenImageFormat = InObject.GetScreenImageFormat;
		ImageSize = InObject.ImageSize;
		Aspect = InObject.Aspect;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagGHMR_TEX>("tagGHMR_TEX")
			.addFunction("__tostring", &tagGHMR_TEX::ToString)
			.addFunction("GetPtrAddr", &tagGHMR_TEX::GetPtrAddr)
			.addProperty("TMEFlag", &tagGHMR_TEX::TMEFlag)
			.addProperty("AlphaFlag", &tagGHMR_TEX::AlphaFlag)
			.addProperty("ImageBufferFreeFlag", &tagGHMR_TEX::ImageBufferFreeFlag)
			// void type not supported in LuaBridge
			//.addProperty("FileImage", &tagGHMR_TEX::FileImage)
			// void type not supported in LuaBridge
			//.addProperty("ImageBuffer", &tagGHMR_TEX::ImageBuffer)
			.addProperty("Width", &tagGHMR_TEX::Width)
			.addProperty("Height", &tagGHMR_TEX::Height)
			.addProperty("TexObj", &tagGHMR_TEX::TexObj)
			.addProperty("AddressMode", &tagGHMR_TEX::AddressMode)
			.addProperty("FilterMode", &tagGHMR_TEX::FilterMode)
			.addProperty("GetScreenImageFormat", &tagGHMR_TEX::GetScreenImageFormat)
			.addProperty("ImageSize", &tagGHMR_TEX::ImageSize)
			.addProperty("Aspect", &tagGHMR_TEX::Aspect)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagGHMR_TEX::TMEFlag) == 1, "expected tagGHMR_TEX::TMEFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::AlphaFlag) == 1, "expected tagGHMR_TEX::AlphaFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::ImageBufferFreeFlag) == 1, "expected tagGHMR_TEX::ImageBufferFreeFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::FileImage) == 4, "expected tagGHMR_TEX::FileImage to be size 4");
static_assert(sizeof(tagGHMR_TEX::ImageBuffer) == 4, "expected tagGHMR_TEX::ImageBuffer to be size 4");
static_assert(sizeof(tagGHMR_TEX::Width) == 2, "expected tagGHMR_TEX::Width to be size 2");
static_assert(sizeof(tagGHMR_TEX::Height) == 2, "expected tagGHMR_TEX::Height to be size 2");
static_assert(sizeof(tagGHMR_TEX::TexObj) == 4, "expected tagGHMR_TEX::TexObj to be size 4");
static_assert(sizeof(tagGHMR_TEX::AddressMode) == 4, "expected tagGHMR_TEX::AddressMode to be size 4");
static_assert(sizeof(tagGHMR_TEX::FilterMode) == 4, "expected tagGHMR_TEX::FilterMode to be size 4");
static_assert(sizeof(tagGHMR_TEX::GetScreenImageFormat) == 4, "expected tagGHMR_TEX::GetScreenImageFormat to be size 4");
static_assert(sizeof(tagGHMR_TEX::ImageSize) == 4, "expected tagGHMR_TEX::ImageSize to be size 4");
static_assert(sizeof(tagGHMR_TEX::Aspect) == 4, "expected tagGHMR_TEX::Aspect to be size 4");
static_assert(sizeof(tagGHMR_TEX) == 0x28, "expected tagGHMR_TEX to be size 0x28");

// [Structure] class HrScreenStatusSlot
class HrScreenStatusSlot
{
public:
	/// Struct member variables

	// <struct tagGHMR_TEX* m_pTex, offset 0x0>
	struct tagGHMR_TEX* m_pTex = nullptr;

	// <char m_SlotDeme[0x3], offset 0x4>
	char m_SlotDeme[3];

	// <Unidentified data segment, offset 0x7>
private:
	char _UnidentifiedData_7[1];

public:
	// <int16_t m_SlotDemeCounter[0x3], offset 0x8>
	int16_t m_SlotDemeCounter[3];

	// <int16_t m_SlotCounter, offset 0xe>
	int16_t m_SlotCounter = 0;

	// <int32_t m_zoromeCounter, offset 0x10>
	int32_t m_zoromeCounter = 0;

	// <uint8_t m_PlayZoroSound, offset 0x14>
	uint8_t m_PlayZoroSound = 0;

	// <uint8_t m_LeachHazure, offset 0x15>
	uint8_t m_LeachHazure = 0;

	// <uint8_t m_PlayLeachSound, offset 0x16>
	uint8_t m_PlayLeachSound = 0;

	// <uint8_t m_bZoromeSorotta, offset 0x17>
	uint8_t m_bZoromeSorotta = 0;

	// <uint8_t m_SlotZoromeStartToEndFlag, offset 0x18>
	uint8_t m_SlotZoromeStartToEndFlag = 0;

	// <uint8_t m_SlotSPAttackStartFlag, offset 0x19>
	uint8_t m_SlotSPAttackStartFlag = 0;

	// <int16_t m_SlotZoromeZOROME, offset 0x1a>
	int16_t m_SlotZoromeZOROME = 0;

	// <int32_t m_SlotZoroLeaveWaitCnt, offset 0x1c>
	int32_t m_SlotZoroLeaveWaitCnt = 0;

	// <int32_t m_SprLchSoundID, offset 0x20>
	int32_t m_SprLchSoundID = 0;

	// <uint32_t flaglmode, offset 0x24>
	uint32_t flaglmode = 0;

	/// 17 Functions

	// [Function] uint8_t __convention("thiscall") HrScreenStatusSlot::dGetSlotZoromeBeginToEnd(class HrScreenStatusSlot* const this) [?dGetSlotZoromeBeginToEnd@HrScreenStatusSlot@@QAE_NXZ]
	typedef uint8_t(__thiscall* _dGetSlotZoromeBeginToEnd_HrScreenStatusSlot__QAE_NXZ)(class HrScreenStatusSlot* const thisPtr);
	uint8_t dGetSlotZoromeBeginToEnd()
	{
		_dGetSlotZoromeBeginToEnd_HrScreenStatusSlot__QAE_NXZ mFunc = (_dGetSlotZoromeBeginToEnd_HrScreenStatusSlot__QAE_NXZ)(GameModule + 0xa2210);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatusSlot::dGetSlotSPAttackOK(class HrScreenStatusSlot* const this) [?dGetSlotSPAttackOK@HrScreenStatusSlot@@QAE_NXZ]
	typedef uint8_t(__thiscall* _dGetSlotSPAttackOK_HrScreenStatusSlot__QAE_NXZ)(class HrScreenStatusSlot* const thisPtr);
	uint8_t dGetSlotSPAttackOK()
	{
		_dGetSlotSPAttackOK_HrScreenStatusSlot__QAE_NXZ mFunc = (_dGetSlotSPAttackOK_HrScreenStatusSlot__QAE_NXZ)(GameModule + 0xaab30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatusSlot::dCheckSlotActive(class HrScreenStatusSlot* const this) [?dCheckSlotActive@HrScreenStatusSlot@@QAE_NXZ]
	typedef uint8_t(__thiscall* _dCheckSlotActive_HrScreenStatusSlot__QAE_NXZ)(class HrScreenStatusSlot* const thisPtr);
	uint8_t dCheckSlotActive()
	{
		_dCheckSlotActive_HrScreenStatusSlot__QAE_NXZ mFunc = (_dCheckSlotActive_HrScreenStatusSlot__QAE_NXZ)(GameModule + 0xaab40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatusSlot::IsActive(class HrScreenStatusSlot* const this) [?IsActive@HrScreenStatusSlot@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsActive_HrScreenStatusSlot__QAE_NXZ)(class HrScreenStatusSlot* const thisPtr);
	uint8_t IsActive()
	{
		_IsActive_HrScreenStatusSlot__QAE_NXZ mFunc = (_IsActive_HrScreenStatusSlot__QAE_NXZ)(GameModule + 0xafc20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatusSlot::IsLeavePhase(class HrScreenStatusSlot* const this) [?IsLeavePhase@HrScreenStatusSlot@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsLeavePhase_HrScreenStatusSlot__QAE_NXZ)(class HrScreenStatusSlot* const thisPtr);
	uint8_t IsLeavePhase()
	{
		_IsLeavePhase_HrScreenStatusSlot__QAE_NXZ mFunc = (_IsLeavePhase_HrScreenStatusSlot__QAE_NXZ)(GameModule + 0xba8b0);
		return mFunc(this);
	}
	// [Function] int16_t __convention("thiscall") HrScreenStatusSlot::GetZOROMEID(class HrScreenStatusSlot* const this) [?GetZOROMEID@HrScreenStatusSlot@@IAEFXZ]
	typedef int16_t(__thiscall* _GetZOROMEID_HrScreenStatusSlot__IAEFXZ)(class HrScreenStatusSlot* const thisPtr);
	int16_t GetZOROMEID()
	{
		_GetZOROMEID_HrScreenStatusSlot__IAEFXZ mFunc = (_GetZOROMEID_HrScreenStatusSlot__IAEFXZ)(GameModule + 0x5667f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatusSlot::ZoromeRenderProcess(class HrScreenStatusSlot* const this) [?ZoromeRenderProcess@HrScreenStatusSlot@@IAEXXZ]
	typedef void(__thiscall* _ZoromeRenderProcess_HrScreenStatusSlot__IAEXXZ)(class HrScreenStatusSlot* const thisPtr);
	void ZoromeRenderProcess()
	{
		_ZoromeRenderProcess_HrScreenStatusSlot__IAEXXZ mFunc = (_ZoromeRenderProcess_HrScreenStatusSlot__IAEXXZ)(GameModule + 0x566800);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatusSlot::SlotRenderProcess(class HrScreenStatusSlot* const this) [?SlotRenderProcess@HrScreenStatusSlot@@IAE_NXZ]
	typedef uint8_t(__thiscall* _SlotRenderProcess_HrScreenStatusSlot__IAE_NXZ)(class HrScreenStatusSlot* const thisPtr);
	uint8_t SlotRenderProcess()
	{
		_SlotRenderProcess_HrScreenStatusSlot__IAE_NXZ mFunc = (_SlotRenderProcess_HrScreenStatusSlot__IAE_NXZ)(GameModule + 0x566bb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatusSlot::ZoromeFrameProcess(class HrScreenStatusSlot* const this) [?ZoromeFrameProcess@HrScreenStatusSlot@@IAEXXZ]
	typedef void(__thiscall* _ZoromeFrameProcess_HrScreenStatusSlot__IAEXXZ)(class HrScreenStatusSlot* const thisPtr);
	void ZoromeFrameProcess()
	{
		_ZoromeFrameProcess_HrScreenStatusSlot__IAEXXZ mFunc = (_ZoromeFrameProcess_HrScreenStatusSlot__IAEXXZ)(GameModule + 0x566ec0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatusSlot::SlotFrameProcess(class HrScreenStatusSlot* const this) [?SlotFrameProcess@HrScreenStatusSlot@@IAEXXZ]
	typedef void(__thiscall* _SlotFrameProcess_HrScreenStatusSlot__IAEXXZ)(class HrScreenStatusSlot* const thisPtr);
	void SlotFrameProcess()
	{
		_SlotFrameProcess_HrScreenStatusSlot__IAEXXZ mFunc = (_SlotFrameProcess_HrScreenStatusSlot__IAEXXZ)(GameModule + 0x566f00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatusSlot::Initialize(class HrScreenStatusSlot* const this, struct tagGHMR_TEX* arg2) [?Initialize@HrScreenStatusSlot@@QAEXPAUtagGHMR_TEX@@@Z]
	typedef void(__thiscall* _Initialize_HrScreenStatusSlot__QAEXPAUtagGHMR_TEX___Z)(class HrScreenStatusSlot* const thisPtr, struct tagGHMR_TEX* arg2);
	void Initialize(struct tagGHMR_TEX* arg2)
	{
		_Initialize_HrScreenStatusSlot__QAEXPAUtagGHMR_TEX___Z mFunc = (_Initialize_HrScreenStatusSlot__QAEXPAUtagGHMR_TEX___Z)(GameModule + 0x567040);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatusSlot::FrameProcess(class HrScreenStatusSlot* const this) [?FrameProcess@HrScreenStatusSlot@@QAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrScreenStatusSlot__QAEXXZ)(class HrScreenStatusSlot* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrScreenStatusSlot__QAEXXZ mFunc = (_FrameProcess_HrScreenStatusSlot__QAEXXZ)(GameModule + 0x5670b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatusSlot::RenderProcess(class HrScreenStatusSlot* const this) [?RenderProcess@HrScreenStatusSlot@@QAE_NXZ]
	typedef uint8_t(__thiscall* _RenderProcess_HrScreenStatusSlot__QAE_NXZ)(class HrScreenStatusSlot* const thisPtr);
	uint8_t RenderProcess()
	{
		_RenderProcess_HrScreenStatusSlot__QAE_NXZ mFunc = (_RenderProcess_HrScreenStatusSlot__QAE_NXZ)(GameModule + 0x567240);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatusSlot::dAppearSlot(class HrScreenStatusSlot* const this, int16_t arg2, int16_t arg3) [?dAppearSlot@HrScreenStatusSlot@@QAE_NFF@Z]
	typedef uint8_t(__thiscall* _dAppearSlot_HrScreenStatusSlot__QAE_NFF_Z)(class HrScreenStatusSlot* const thisPtr, int16_t arg2, int16_t arg3);
	uint8_t dAppearSlot(int16_t arg2, int16_t arg3)
	{
		_dAppearSlot_HrScreenStatusSlot__QAE_NFF_Z mFunc = (_dAppearSlot_HrScreenStatusSlot__QAE_NFF_Z)(GameModule + 0x567270);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint16_t __convention("thiscall") HrScreenStatusSlot::dGetLMode(class HrScreenStatusSlot* const this, int32_t arg2) [?dGetLMode@HrScreenStatusSlot@@QAEGH@Z]
	typedef uint16_t(__thiscall* _dGetLMode_HrScreenStatusSlot__QAEGH_Z)(class HrScreenStatusSlot* const thisPtr, int32_t arg2);
	uint16_t dGetLMode(int32_t arg2)
	{
		_dGetLMode_HrScreenStatusSlot__QAEGH_Z mFunc = (_dGetLMode_HrScreenStatusSlot__QAEGH_Z)(GameModule + 0x567580);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatusSlot::dClearLMode(class HrScreenStatusSlot* const this, int32_t arg2, uint8_t arg3) [?dClearLMode@HrScreenStatusSlot@@QAEXH_N@Z]
	typedef void(__thiscall* _dClearLMode_HrScreenStatusSlot__QAEXH_N_Z)(class HrScreenStatusSlot* const thisPtr, int32_t arg2, uint8_t arg3);
	void dClearLMode(int32_t arg2, uint8_t arg3)
	{
		_dClearLMode_HrScreenStatusSlot__QAEXH_N_Z mFunc = (_dClearLMode_HrScreenStatusSlot__QAEXH_N_Z)(GameModule + 0x5675f0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrScreenStatusSlot::dSetSlotSPAttackOK(class HrScreenStatusSlot* const this, uint8_t arg2) [?dSetSlotSPAttackOK@HrScreenStatusSlot@@QAEX_N@Z]
	typedef void(__thiscall* _dSetSlotSPAttackOK_HrScreenStatusSlot__QAEX_N_Z)(class HrScreenStatusSlot* const thisPtr, uint8_t arg2);
	void dSetSlotSPAttackOK(uint8_t arg2)
	{
		_dSetSlotSPAttackOK_HrScreenStatusSlot__QAEX_N_Z mFunc = (_dSetSlotSPAttackOK_HrScreenStatusSlot__QAEX_N_Z)(GameModule + 0x567650);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrScreenStatusSlot [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrScreenStatusSlot& InObject)
	{
		m_pTex = InObject.m_pTex;
		m_SlotCounter = InObject.m_SlotCounter;
		m_zoromeCounter = InObject.m_zoromeCounter;
		m_PlayZoroSound = InObject.m_PlayZoroSound;
		m_LeachHazure = InObject.m_LeachHazure;
		m_PlayLeachSound = InObject.m_PlayLeachSound;
		m_bZoromeSorotta = InObject.m_bZoromeSorotta;
		m_SlotZoromeStartToEndFlag = InObject.m_SlotZoromeStartToEndFlag;
		m_SlotSPAttackStartFlag = InObject.m_SlotSPAttackStartFlag;
		m_SlotZoromeZOROME = InObject.m_SlotZoromeZOROME;
		m_SlotZoroLeaveWaitCnt = InObject.m_SlotZoroLeaveWaitCnt;
		m_SprLchSoundID = InObject.m_SprLchSoundID;
		flaglmode = InObject.flaglmode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrScreenStatusSlot>("HrScreenStatusSlot")
			.addFunction("__tostring", &HrScreenStatusSlot::ToString)
			.addFunction("GetPtrAddr", &HrScreenStatusSlot::GetPtrAddr)
			.addProperty("m_pTex", &HrScreenStatusSlot::m_pTex)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_SlotDeme", &HrScreenStatusSlot::m_SlotDeme)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_SlotDemeCounter", &HrScreenStatusSlot::m_SlotDemeCounter)
			.addProperty("m_SlotCounter", &HrScreenStatusSlot::m_SlotCounter)
			.addProperty("m_zoromeCounter", &HrScreenStatusSlot::m_zoromeCounter)
			.addProperty("m_PlayZoroSound", &HrScreenStatusSlot::m_PlayZoroSound)
			.addProperty("m_LeachHazure", &HrScreenStatusSlot::m_LeachHazure)
			.addProperty("m_PlayLeachSound", &HrScreenStatusSlot::m_PlayLeachSound)
			.addProperty("m_bZoromeSorotta", &HrScreenStatusSlot::m_bZoromeSorotta)
			.addProperty("m_SlotZoromeStartToEndFlag", &HrScreenStatusSlot::m_SlotZoromeStartToEndFlag)
			.addProperty("m_SlotSPAttackStartFlag", &HrScreenStatusSlot::m_SlotSPAttackStartFlag)
			.addProperty("m_SlotZoromeZOROME", &HrScreenStatusSlot::m_SlotZoromeZOROME)
			.addProperty("m_SlotZoroLeaveWaitCnt", &HrScreenStatusSlot::m_SlotZoroLeaveWaitCnt)
			.addProperty("m_SprLchSoundID", &HrScreenStatusSlot::m_SprLchSoundID)
			.addProperty("flaglmode", &HrScreenStatusSlot::flaglmode)
			.addFunction("dGetSlotZoromeBeginToEnd", &HrScreenStatusSlot::dGetSlotZoromeBeginToEnd)
			.addFunction("dGetSlotSPAttackOK", &HrScreenStatusSlot::dGetSlotSPAttackOK)
			.addFunction("dCheckSlotActive", &HrScreenStatusSlot::dCheckSlotActive)
			.addFunction("IsActive", &HrScreenStatusSlot::IsActive)
			.addFunction("IsLeavePhase", &HrScreenStatusSlot::IsLeavePhase)
			.addFunction("GetZOROMEID", &HrScreenStatusSlot::GetZOROMEID)
			.addFunction("ZoromeRenderProcess", &HrScreenStatusSlot::ZoromeRenderProcess)
			.addFunction("SlotRenderProcess", &HrScreenStatusSlot::SlotRenderProcess)
			.addFunction("ZoromeFrameProcess", &HrScreenStatusSlot::ZoromeFrameProcess)
			.addFunction("SlotFrameProcess", &HrScreenStatusSlot::SlotFrameProcess)
			.addFunction("Initialize", &HrScreenStatusSlot::Initialize)
			.addFunction("FrameProcess", &HrScreenStatusSlot::FrameProcess)
			.addFunction("RenderProcess", &HrScreenStatusSlot::RenderProcess)
			.addFunction("dAppearSlot", &HrScreenStatusSlot::dAppearSlot)
			.addFunction("dGetLMode", &HrScreenStatusSlot::dGetLMode)
			.addFunction("dClearLMode", &HrScreenStatusSlot::dClearLMode)
			.addFunction("dSetSlotSPAttackOK", &HrScreenStatusSlot::dSetSlotSPAttackOK)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrScreenStatusSlot::m_pTex) == 4, "expected HrScreenStatusSlot::m_pTex to be size 4");
static_assert(sizeof(HrScreenStatusSlot::m_SlotDeme) == 3, "expected HrScreenStatusSlot::m_SlotDeme to be size 3");
static_assert(sizeof(HrScreenStatusSlot::m_SlotDemeCounter) == 6, "expected HrScreenStatusSlot::m_SlotDemeCounter to be size 6");
static_assert(sizeof(HrScreenStatusSlot::m_SlotCounter) == 2, "expected HrScreenStatusSlot::m_SlotCounter to be size 2");
static_assert(sizeof(HrScreenStatusSlot::m_zoromeCounter) == 4, "expected HrScreenStatusSlot::m_zoromeCounter to be size 4");
static_assert(sizeof(HrScreenStatusSlot::m_PlayZoroSound) == 1, "expected HrScreenStatusSlot::m_PlayZoroSound to be size 1");
static_assert(sizeof(HrScreenStatusSlot::m_LeachHazure) == 1, "expected HrScreenStatusSlot::m_LeachHazure to be size 1");
static_assert(sizeof(HrScreenStatusSlot::m_PlayLeachSound) == 1, "expected HrScreenStatusSlot::m_PlayLeachSound to be size 1");
static_assert(sizeof(HrScreenStatusSlot::m_bZoromeSorotta) == 1, "expected HrScreenStatusSlot::m_bZoromeSorotta to be size 1");
static_assert(sizeof(HrScreenStatusSlot::m_SlotZoromeStartToEndFlag) == 1, "expected HrScreenStatusSlot::m_SlotZoromeStartToEndFlag to be size 1");
static_assert(sizeof(HrScreenStatusSlot::m_SlotSPAttackStartFlag) == 1, "expected HrScreenStatusSlot::m_SlotSPAttackStartFlag to be size 1");
static_assert(sizeof(HrScreenStatusSlot::m_SlotZoromeZOROME) == 2, "expected HrScreenStatusSlot::m_SlotZoromeZOROME to be size 2");
static_assert(sizeof(HrScreenStatusSlot::m_SlotZoroLeaveWaitCnt) == 4, "expected HrScreenStatusSlot::m_SlotZoroLeaveWaitCnt to be size 4");
static_assert(sizeof(HrScreenStatusSlot::m_SprLchSoundID) == 4, "expected HrScreenStatusSlot::m_SprLchSoundID to be size 4");
static_assert(sizeof(HrScreenStatusSlot::flaglmode) == 4, "expected HrScreenStatusSlot::flaglmode to be size 4");
static_assert(sizeof(HrScreenStatusSlot) == 0x28, "expected HrScreenStatusSlot to be size 0x28");

// [Structure] struct Rectf
struct Rectf
{
public:
	/// Struct member variables

	// <float left, offset 0x0>
	float left = 0;

	// <float top, offset 0x4>
	float top = 0;

	// <float right, offset 0x8>
	float right = 0;

	// <float bottom, offset 0xc>
	float bottom = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct Rectf [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(Rectf& InObject)
	{
		left = InObject.left;
		top = InObject.top;
		right = InObject.right;
		bottom = InObject.bottom;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Rectf>("Rectf")
			.addFunction("__tostring", &Rectf::ToString)
			.addFunction("GetPtrAddr", &Rectf::GetPtrAddr)
			.addProperty("left", &Rectf::left)
			.addProperty("top", &Rectf::top)
			.addProperty("right", &Rectf::right)
			.addProperty("bottom", &Rectf::bottom)
		.endClass();
	}
#endif
};
static_assert(sizeof(Rectf::left) == 4, "expected Rectf::left to be size 4");
static_assert(sizeof(Rectf::top) == 4, "expected Rectf::top to be size 4");
static_assert(sizeof(Rectf::right) == 4, "expected Rectf::right to be size 4");
static_assert(sizeof(Rectf::bottom) == 4, "expected Rectf::bottom to be size 4");
static_assert(sizeof(Rectf) == 0x10, "expected Rectf to be size 0x10");

// enum GFONTTYPE_NUM
enum GFONTTYPE_NUM : uint32_t
{
	// <GFONT_R = 0x0>
	GFONT_R = 0,

	// <GFONT_S = 0x1>
	GFONT_S = 1,

	// <GFONT_S_EXPLANATION = 0x2>
	GFONT_S_EXPLANATION = 2,

	// <GFONT_NUM_MAX = 0x3>
	GFONT_NUM_MAX = 3

};

// [Structure] struct Vec2
struct Vec2
{
public:
	/// Struct member variables

	// <float x, offset 0x0>
	float x = 0;

	// <float y, offset 0x4>
	float y = 0;

	/// 0 Functions

	/// Meta

	Vec2() { x = 0; y = 0; }
	Vec2(float inX, float inY) { x = inX; y = inY; }
	float Size() const { return sqrtf(x*x + y*y); }
	float SizeSquared() const { return x*x + y*y; }
	std::string ToString() const { std::stringstream stream; stream << "struct Vec2 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(Vec2& InObject)
	{
		x = InObject.x;
		y = InObject.y;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Vec2>("Vec2")
			.addFunction("__tostring", &Vec2::ToString)
			.addFunction("GetPtrAddr", &Vec2::GetPtrAddr)
			.addProperty("x", &Vec2::x)
			.addProperty("y", &Vec2::y)
			.addConstructor<void (*) (void)>()
			.addConstructor<void (*) (float, float)>()
			.addFunction("SizeSquared", &Vec2::SizeSquared)
			.addFunction("Size", &Vec2::Size)
		.endClass();
	}
#endif
};
static_assert(sizeof(Vec2::x) == 4, "expected Vec2::x to be size 4");
static_assert(sizeof(Vec2::y) == 4, "expected Vec2::y to be size 4");
static_assert(sizeof(Vec2) == 0x8, "expected Vec2 to be size 0x8");

// [Structure] struct hPOINT
struct hPOINT
{
public:
	/// Struct member variables

	// <float x, offset 0x0>
	float x = 0;

	// <float y, offset 0x4>
	float y = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct hPOINT [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hPOINT& InObject)
	{
		x = InObject.x;
		y = InObject.y;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hPOINT>("hPOINT")
			.addFunction("__tostring", &hPOINT::ToString)
			.addFunction("GetPtrAddr", &hPOINT::GetPtrAddr)
			.addProperty("x", &hPOINT::x)
			.addProperty("y", &hPOINT::y)
		.endClass();
	}
#endif
};
static_assert(sizeof(hPOINT::x) == 4, "expected hPOINT::x to be size 4");
static_assert(sizeof(hPOINT::y) == 4, "expected hPOINT::y to be size 4");
static_assert(sizeof(hPOINT) == 0x8, "expected hPOINT to be size 0x8");

// [Structure] class CNYDrawStringBase
class CNYDrawStringBase
{
public:
	// enum CNYDrawStringBase::ALIGNMENT_TYPE_BASE
	enum ALIGNMENT_TYPE_BASE : uint32_t
	{
		// <ALIGNMENT_TYPE_LEFT = 0x0>
		ALIGNMENT_TYPE_LEFT = 0,

		// <ALIGNMENT_TYPE_MIDDLE = 0x1>
		ALIGNMENT_TYPE_MIDDLE = 1,

		// <ALIGNMENT_TYPE_RIGHT = 0x2>
		ALIGNMENT_TYPE_RIGHT = 2

	};

	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <int32_t m_mesHandle, offset 0x4>
	int32_t m_mesHandle = 0;

	// <char* m_pstr, offset 0x8>
	char* m_pstr = nullptr;

	// <struct Vec2 m_pos, offset 0xc>
	struct Vec2 m_pos;

	// <struct Vec2 m_realPos, offset 0x14>
	struct Vec2 m_realPos;

	// <uint32_t m_color, offset 0x1c>
	uint32_t m_color = 0;

	// <enum GFONTTYPE_NUM m_fontType, offset 0x20>
	enum GFONTTYPE_NUM m_fontType;

	// <float m_fontSize, offset 0x24>
	float m_fontSize = 0;

	// <enum CNYDrawStringBase::ALIGNMENT_TYPE_BASE m_alignment, offset 0x28>
	enum CNYDrawStringBase::ALIGNMENT_TYPE_BASE m_alignment;

	// <uint8_t m_noGSYSMES, offset 0x2c>
	uint8_t m_noGSYSMES = 0;

	// <uint8_t m_beUpdate, offset 0x2d>
	uint8_t m_beUpdate = 0;

	// <Unidentified data segment, offset 0x2e>
private:
	char _UnidentifiedData_46[2];

public:
	// <struct Rectf m_WindowRect, offset 0x30>
	struct Rectf m_WindowRect;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CNYDrawStringBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CNYDrawStringBase& InObject)
	{
		m_mesHandle = InObject.m_mesHandle;
		m_pstr = InObject.m_pstr;
		m_pos = InObject.m_pos;
		m_realPos = InObject.m_realPos;
		m_color = InObject.m_color;
		m_fontType = InObject.m_fontType;
		m_fontSize = InObject.m_fontSize;
		m_alignment = InObject.m_alignment;
		m_noGSYSMES = InObject.m_noGSYSMES;
		m_beUpdate = InObject.m_beUpdate;
		m_WindowRect = InObject.m_WindowRect;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CNYDrawStringBase>("CNYDrawStringBase")
			.addFunction("__tostring", &CNYDrawStringBase::ToString)
			.addFunction("GetPtrAddr", &CNYDrawStringBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &CNYDrawStringBase::field_0)
			.addProperty("m_mesHandle", &CNYDrawStringBase::m_mesHandle)
			// char* type not supported in LuaBridge
			//.addProperty("m_pstr", &CNYDrawStringBase::m_pstr)
			.addProperty("m_pos", &CNYDrawStringBase::m_pos)
			.addProperty("m_realPos", &CNYDrawStringBase::m_realPos)
			.addProperty("m_color", &CNYDrawStringBase::m_color)
			.addProperty("m_fontType", &CNYDrawStringBase::m_fontType)
			.addProperty("m_fontSize", &CNYDrawStringBase::m_fontSize)
			.addProperty("m_alignment", &CNYDrawStringBase::m_alignment)
			.addProperty("m_noGSYSMES", &CNYDrawStringBase::m_noGSYSMES)
			.addProperty("m_beUpdate", &CNYDrawStringBase::m_beUpdate)
			.addProperty("m_WindowRect", &CNYDrawStringBase::m_WindowRect)
		.endClass();
	}
#endif
};
static_assert(sizeof(CNYDrawStringBase::field_0) == 4, "expected CNYDrawStringBase::field_0 to be size 4");
static_assert(sizeof(CNYDrawStringBase::m_mesHandle) == 4, "expected CNYDrawStringBase::m_mesHandle to be size 4");
static_assert(sizeof(CNYDrawStringBase::m_pstr) == 4, "expected CNYDrawStringBase::m_pstr to be size 4");
static_assert(sizeof(CNYDrawStringBase::m_pos) == 8, "expected CNYDrawStringBase::m_pos to be size 8");
static_assert(sizeof(CNYDrawStringBase::m_realPos) == 8, "expected CNYDrawStringBase::m_realPos to be size 8");
static_assert(sizeof(CNYDrawStringBase::m_color) == 4, "expected CNYDrawStringBase::m_color to be size 4");
static_assert(sizeof(CNYDrawStringBase::m_fontType) == 4, "expected CNYDrawStringBase::m_fontType to be size 4");
static_assert(sizeof(CNYDrawStringBase::m_fontSize) == 4, "expected CNYDrawStringBase::m_fontSize to be size 4");
static_assert(sizeof(CNYDrawStringBase::m_alignment) == 4, "expected CNYDrawStringBase::m_alignment to be size 4");
static_assert(sizeof(CNYDrawStringBase::m_noGSYSMES) == 1, "expected CNYDrawStringBase::m_noGSYSMES to be size 1");
static_assert(sizeof(CNYDrawStringBase::m_beUpdate) == 1, "expected CNYDrawStringBase::m_beUpdate to be size 1");
static_assert(sizeof(CNYDrawStringBase::m_WindowRect) == 16, "expected CNYDrawStringBase::m_WindowRect to be size 16");
static_assert(sizeof(CNYDrawStringBase) == 0x40, "expected CNYDrawStringBase to be size 0x40");

// [Structure] class NYDrawString
class NYDrawString : public CNYDrawStringBase
{
public:
	// enum NYDrawString::ALIGNMENT_TYPE
	enum ALIGNMENT_TYPE : uint32_t
	{
		// <ALIGNMENT_TYPE_LEFT = 0x0>
		ALIGNMENT_TYPE_LEFT = 0,

		// <ALIGNMENT_TYPE_MIDDLE = 0x1>
		ALIGNMENT_TYPE_MIDDLE = 1,

		// <ALIGNMENT_TYPE_RIGHT = 0x2>
		ALIGNMENT_TYPE_RIGHT = 2

	};

	/// Struct member variables

	// <class CNYDrawStringBase field_0, offset 0x0>
	// class CNYDrawStringBase Super;

	// <char m_str[0x40], offset 0x40>
	char m_str[64];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class NYDrawString [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(NYDrawString& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<NYDrawString, CNYDrawStringBase>("NYDrawString")
			.addFunction("__tostring", &NYDrawString::ToString)
			.addFunction("GetPtrAddr", &NYDrawString::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_str", &NYDrawString::m_str)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYDrawString::m_str) == 64, "expected NYDrawString::m_str to be size 64");
static_assert(sizeof(NYDrawString) == 0x80, "expected NYDrawString to be size 0x80");

// enum PJ_QUICK_MOVE_TARGET
enum PJ_QUICK_MOVE_TARGET : uint32_t
{
	// <PJ_QUICK_MOVE_TARGET_NONE = 0xffffffffffffffff>
	PJ_QUICK_MOVE_TARGET_NONE = UINT32_MAX,

	// <PJ_QUICK_MOVE_TARGET_MOTEL = 0x0>
	PJ_QUICK_MOVE_TARGET_MOTEL = 0,

	// <PJ_QUICK_MOVE_TARGET_NAOMIS_LAB = 0x1>
	PJ_QUICK_MOVE_TARGET_NAOMIS_LAB = 1,

	// <PJ_QUICK_MOVE_TARGET_AIRPORT51 = 0x2>
	PJ_QUICK_MOVE_TARGET_AIRPORT51 = 2,

	// <PJ_QUICK_MOVE_TARGET_TRAINING_GYM = 0x3>
	PJ_QUICK_MOVE_TARGET_TRAINING_GYM = 3,

	// <PJ_QUICK_MOVE_TARGET_THUNDER_RYU = 0x4>
	PJ_QUICK_MOVE_TARGET_THUNDER_RYU = 4,

	// <PJ_QUICK_MOVE_TARGET_BUG_BUSTER = 0x5>
	PJ_QUICK_MOVE_TARGET_BUG_BUSTER = 5,

	// <PJ_QUICK_MOVE_TARGET_PIPE_FITTER = 0x6>
	PJ_QUICK_MOVE_TARGET_PIPE_FITTER = 6,

	// <PJ_QUICK_MOVE_TARGET_COCONUT_COLLECTOR = 0x7>
	PJ_QUICK_MOVE_TARGET_COCONUT_COLLECTOR = 7,

	// <PJ_QUICK_MOVE_TARGET_SPACE_GARBAGE = 0x8>
	PJ_QUICK_MOVE_TARGET_SPACE_GARBAGE = 8,

	// <PJ_QUICK_MOVE_TARGET_PIZZA_DELIVER = 0x9>
	PJ_QUICK_MOVE_TARGET_PIZZA_DELIVER = 9,

	// <PJ_QUICK_MOVE_TARGET_TILE_PUZZLE = 0xa>
	PJ_QUICK_MOVE_TARGET_TILE_PUZZLE = 10,

	// <PJ_QUICK_MOVE_TARGET_STEAK_HOUSE = 0xb>
	PJ_QUICK_MOVE_TARGET_STEAK_HOUSE = 11,

	// <PJ_QUICK_MOVE_TARGET_BACK_ALLEY_1 = 0xc>
	PJ_QUICK_MOVE_TARGET_BACK_ALLEY_1 = 12,

	// <PJ_QUICK_MOVE_TARGET_BACK_ALLEY_2 = 0xd>
	PJ_QUICK_MOVE_TARGET_BACK_ALLEY_2 = 13,

	// <PJ_QUICK_MOVE_TARGET_CONSTRUCTION_FIELD_1 = 0xe>
	PJ_QUICK_MOVE_TARGET_CONSTRUCTION_FIELD_1 = 14,

	// <PJ_QUICK_MOVE_TARGET_CONSTRUCTION_FIELD_2 = 0xf>
	PJ_QUICK_MOVE_TARGET_CONSTRUCTION_FIELD_2 = 15,

	// <PJ_QUICK_MOVE_TARGET_UNDER_ELEVATED_1 = 0x10>
	PJ_QUICK_MOVE_TARGET_UNDER_ELEVATED_1 = 16,

	// <PJ_QUICK_MOVE_TARGET_UNDER_ELEVATED_2 = 0x11>
	PJ_QUICK_MOVE_TARGET_UNDER_ELEVATED_2 = 17,

	// <PJ_QUICK_MOVE_TARGET_RESTAURANT_1 = 0x12>
	PJ_QUICK_MOVE_TARGET_RESTAURANT_1 = 18,

	// <PJ_QUICK_MOVE_TARGET_RESTAURANT_2 = 0x13>
	PJ_QUICK_MOVE_TARGET_RESTAURANT_2 = 19,

	// <PJ_QUICK_MOVE_TARGET_BAR_1 = 0x14>
	PJ_QUICK_MOVE_TARGET_BAR_1 = 20,

	// <PJ_QUICK_MOVE_TARGET_BAR_2 = 0x15>
	PJ_QUICK_MOVE_TARGET_BAR_2 = 21,

	// <PJ_QUICK_MOVE_TARGET_MAX = 0x16>
	PJ_QUICK_MOVE_TARGET_MAX = 22

};

// [Structure] class HrMap
class HrMap
{
public:
	// enum HrMap::ICON_TYPE
	enum ICON_TYPE : uint32_t
	{
		// <ICON_TYPE_PC = 0x0>
		ICON_TYPE_PC = 0,

		// <ICON_TYPE_ENEMY = 0x1>
		ICON_TYPE_ENEMY = 1,

		// <ICON_TYPE_BOSS = 0x2>
		ICON_TYPE_BOSS = 2,

		// <ICON_TYPE_SAVE_POINT = 0x3>
		ICON_TYPE_SAVE_POINT = 3,

		// <ICON_TYPE_ACCESS_POINT_ON = 0x4>
		ICON_TYPE_ACCESS_POINT_ON = 4,

		// <ICON_TYPE_ACCESS_POINT_OFF = 0x5>
		ICON_TYPE_ACCESS_POINT_OFF = 5,

		// <ICON_TYPE_BOSS_POINT = 0x6>
		ICON_TYPE_BOSS_POINT = 6,

		// <ICON_TYPE_TREASURE_BOX = 0x7>
		ICON_TYPE_TREASURE_BOX = 7,

		// <ICON_TYPE_SNEAK_ENEMY = 0x8>
		ICON_TYPE_SNEAK_ENEMY = 8,

		// <ICON_TYPE_SHOOTER_ENEMY = 0x9>
		ICON_TYPE_SHOOTER_ENEMY = 9,

		// <ICON_TYPE_BIKE = 0xa>
		ICON_TYPE_BIKE = 10,

		// <ICON_TYPE_MOTEL = 0xb>
		ICON_TYPE_MOTEL = 11,

		// <ICON_TYPE_AIRPORT51 = 0xc>
		ICON_TYPE_AIRPORT51 = 12,

		// <ICON_TYPE_NAOMIS_LAB = 0xd>
		ICON_TYPE_NAOMIS_LAB = 13,

		// <ICON_TYPE_TRAINING_GYM = 0xe>
		ICON_TYPE_TRAINING_GYM = 14,

		// <ICON_TYPE_THUNDER_RYU = 0xf>
		ICON_TYPE_THUNDER_RYU = 15,

		// <ICON_TYPE_JOB_MISSION = 0x10>
		ICON_TYPE_JOB_MISSION = 16,

		// <ICON_TYPE_KILL_MISSION = 0x11>
		ICON_TYPE_KILL_MISSION = 17,

		// <ICON_TYPE_MAX = 0x12>
		ICON_TYPE_MAX = 18

	};

	// [Structure] struct HrMap::DrawData
	struct DrawData
	{
	public:
		/// Struct member variables

		// <enum HrMap::ICON_TYPE m_iconType, offset 0x0>
		enum ICON_TYPE m_iconType;

		// <struct Vec m_pos3D, offset 0x4>
		struct Vec m_pos3D;

		// <struct Vec2 m_pos, offset 0x10>
		struct Vec2 m_pos;

		// <struct Vec2 m_wh, offset 0x18>
		struct Vec2 m_wh;

		// <float m_rotAngle, offset 0x20>
		float m_rotAngle = 0;

		// <float m_scale, offset 0x24>
		float m_scale = 0;

		// <struct tagGHMR_TEX* m_pTex, offset 0x28>
		struct tagGHMR_TEX* m_pTex = nullptr;

		// <uint32_t m_color, offset 0x2c>
		uint32_t m_color = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct HrMap::DrawData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(HrMap::DrawData& InObject)
		{
			m_iconType = InObject.m_iconType;
			m_pos3D = InObject.m_pos3D;
			m_pos = InObject.m_pos;
			m_wh = InObject.m_wh;
			m_rotAngle = InObject.m_rotAngle;
			m_scale = InObject.m_scale;
			m_pTex = InObject.m_pTex;
			m_color = InObject.m_color;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<DrawData>("HrMap_DrawData")
				.addFunction("__tostring", &HrMap::DrawData::ToString)
				.addFunction("GetPtrAddr", &HrMap::DrawData::GetPtrAddr)
				.addProperty("m_iconType", &HrMap::DrawData::m_iconType)
				.addProperty("m_pos3D", &HrMap::DrawData::m_pos3D)
				.addProperty("m_pos", &HrMap::DrawData::m_pos)
				.addProperty("m_wh", &HrMap::DrawData::m_wh)
				.addProperty("m_rotAngle", &HrMap::DrawData::m_rotAngle)
				.addProperty("m_scale", &HrMap::DrawData::m_scale)
				.addProperty("m_pTex", &HrMap::DrawData::m_pTex)
				.addProperty("m_color", &HrMap::DrawData::m_color)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrMap::DrawData::m_iconType) == 4, "expected HrMap::DrawData::m_iconType to be size 4");
	static_assert(sizeof(HrMap::DrawData::m_pos3D) == 12, "expected HrMap::DrawData::m_pos3D to be size 12");
	static_assert(sizeof(HrMap::DrawData::m_pos) == 8, "expected HrMap::DrawData::m_pos to be size 8");
	static_assert(sizeof(HrMap::DrawData::m_wh) == 8, "expected HrMap::DrawData::m_wh to be size 8");
	static_assert(sizeof(HrMap::DrawData::m_rotAngle) == 4, "expected HrMap::DrawData::m_rotAngle to be size 4");
	static_assert(sizeof(HrMap::DrawData::m_scale) == 4, "expected HrMap::DrawData::m_scale to be size 4");
	static_assert(sizeof(HrMap::DrawData::m_pTex) == 4, "expected HrMap::DrawData::m_pTex to be size 4");
	static_assert(sizeof(HrMap::DrawData::m_color) == 4, "expected HrMap::DrawData::m_color to be size 4");
	static_assert(sizeof(HrMap::DrawData) == 0x30, "expected HrMap::DrawData to be size 0x30");

	// enum HrMap::SCALE_TYPE
	enum SCALE_TYPE : uint32_t
	{
		// <SCALE_TYPE_SMALL = 0x0>
		SCALE_TYPE_SMALL = 0,

		// <SCALE_TYPE_MEDIUM = 0x1>
		SCALE_TYPE_MEDIUM = 1,

		// <SCALE_TYPE_LARGE = 0x2>
		SCALE_TYPE_LARGE = 2,

		// <SCALE_TYPE_ALL = 0x3>
		SCALE_TYPE_ALL = 3

	};

	// enum HrMap::TYPE
	enum TYPE : uint32_t
	{
		// <TYPE_PREV = 0x0>
		TYPE_PREV = 0,

		// <TYPE_VIEW = 0x1>
		TYPE_VIEW = 1,

		// <TYPE_MINI = 0x2>
		TYPE_MINI = 2,

		// <TYPE_MINI_ROT = 0x3>
		TYPE_MINI_ROT = 3,

		// <TYPE_MINI_TILTED = 0x4>
		TYPE_MINI_TILTED = 4,

		// <TYPE_MINI_ROT_TILTED = 0x5>
		TYPE_MINI_ROT_TILTED = 5,

		// <TYPE_MAX = 0x6>
		TYPE_MAX = 6

	};

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[7076];

public:
	// <uint8_t FlashIconSEFlag, offset 0x1ba4>
	uint8_t FlashIconSEFlag = 0;

	// <Unidentified data segment, offset 0x1ba5>
private:
	char _UnidentifiedData_7077[3];

public:
	// <uint8_t FlashATMicon, offset 0x1ba8>
	uint8_t FlashATMicon = 0;

	// <Unidentified data segment, offset 0x1ba9>
private:
	char _UnidentifiedData_7081[763];

public:
	/// 31 Functions

	// [Function] int32_t __convention("thiscall") HrMap::SetIconPos(class HrMap* const this, struct Vec& arg2) [?SetIconPos@HrMap@@QAEHABUVec@@@Z]
	typedef int32_t(__thiscall* _SetIconPos_HrMap__QAEHABUVec___Z)(class HrMap* const thisPtr, struct Vec& arg2);
	int32_t SetIconPos(struct Vec& arg2)
	{
		_SetIconPos_HrMap__QAEHABUVec___Z mFunc = (_SetIconPos_HrMap__QAEHABUVec___Z)(GameModule + 0xa21e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrMap::ClearIcon(class HrMap* const this, int32_t arg2) [?ClearIcon@HrMap@@QAEXH@Z]
	typedef void(__thiscall* _ClearIcon_HrMap__QAEXH_Z)(class HrMap* const thisPtr, int32_t arg2);
	void ClearIcon(int32_t arg2)
	{
		_ClearIcon_HrMap__QAEXH_Z mFunc = (_ClearIcon_HrMap__QAEXH_Z)(GameModule + 0xa21f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrMap::SetFlashATMicon(class HrMap* const this, uint8_t arg2) [?SetFlashATMicon@HrMap@@QAEX_N@Z]
	typedef void(__thiscall* _SetFlashATMicon_HrMap__QAEX_N_Z)(class HrMap* const thisPtr, uint8_t arg2);
	void SetFlashATMicon(uint8_t arg2)
	{
		_SetFlashATMicon_HrMap__QAEX_N_Z mFunc = (_SetFlashATMicon_HrMap__QAEX_N_Z)(GameModule + 0xa2200);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrMap::IsMiniMap(class HrMap* const this) [?IsMiniMap@HrMap@@QBE_NXZ]
	typedef uint8_t(__thiscall* _IsMiniMap_HrMap__QBE_NXZ)(class HrMap* const thisPtr);
	uint8_t IsMiniMap()
	{
		_IsMiniMap_HrMap__QBE_NXZ mFunc = (_IsMiniMap_HrMap__QBE_NXZ)(GameModule + 0xacdf0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrMap::GetWidth3D(class HrMap* const this) [?GetWidth3D@HrMap@@QBEMXZ]
	typedef float(__thiscall* _GetWidth3D_HrMap__QBEMXZ)(class HrMap* const thisPtr);
	float GetWidth3D()
	{
		_GetWidth3D_HrMap__QBEMXZ mFunc = (_GetWidth3D_HrMap__QBEMXZ)(GameModule + 0xace00);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrMap::GetHeight3D(class HrMap* const this) [?GetHeight3D@HrMap@@QBEMXZ]
	typedef float(__thiscall* _GetHeight3D_HrMap__QBEMXZ)(class HrMap* const thisPtr);
	float GetHeight3D()
	{
		_GetHeight3D_HrMap__QBEMXZ mFunc = (_GetHeight3D_HrMap__QBEMXZ)(GameModule + 0xace30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMap::SetScissorRect(class HrMap* const this, float arg2, float arg3, float arg4, float arg5) [?SetScissorRect@HrMap@@QAEXMMMM@Z]
	typedef void(__thiscall* _SetScissorRect_HrMap__QAEXMMMM_Z)(class HrMap* const thisPtr, float arg2, float arg3, float arg4, float arg5);
	void SetScissorRect(float arg2, float arg3, float arg4, float arg5)
	{
		_SetScissorRect_HrMap__QAEXMMMM_Z mFunc = (_SetScissorRect_HrMap__QAEXMMMM_Z)(GameModule + 0xace60);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] struct Vec __convention("thiscall") HrMap::GetMapOffset(class HrMap* const this) [?GetMapOffset@HrMap@@IAE?BUVec@@XZ]
	typedef struct Vec(__thiscall* _GetMapOffset_HrMap__IAEBUVec__XZ)(class HrMap* const thisPtr);
	struct Vec GetMapOffset()
	{
		_GetMapOffset_HrMap__IAEBUVec__XZ mFunc = (_GetMapOffset_HrMap__IAEBUVec__XZ)(GameModule + 0xace90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMap::IsDied(class HrMap* const this, class mHRChara* Character) [?IsDied@HrMap@@IAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _IsDied_HrMap__IAE_NPAVmHRChara___Z)(class HrMap* const thisPtr, class mHRChara* Character);
	uint8_t IsDied(class mHRChara* Character)
	{
		_IsDied_HrMap__IAE_NPAVmHRChara___Z mFunc = (_IsDied_HrMap__IAE_NPAVmHRChara___Z)(GameModule + 0xaceb0);
		return mFunc(this, Character);
	}
	// [Function] uint8_t __convention("thiscall") HrMap::GetIsDisp(class HrMap* const this) [?GetIsDisp@HrMap@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetIsDisp_HrMap__QAE_NXZ)(class HrMap* const thisPtr);
	uint8_t GetIsDisp()
	{
		_GetIsDisp_HrMap__QAE_NXZ mFunc = (_GetIsDisp_HrMap__QAE_NXZ)(GameModule + 0xafa70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMap::SetFlashIconSE(class HrMap* const this, uint8_t arg2) [?SetFlashIconSE@HrMap@@QAEX_N@Z]
	typedef void(__thiscall* _SetFlashIconSE_HrMap__QAEX_N_Z)(class HrMap* const thisPtr, uint8_t arg2);
	void SetFlashIconSE(uint8_t arg2)
	{
		_SetFlashIconSE_HrMap__QAEX_N_Z mFunc = (_SetFlashIconSE_HrMap__QAEX_N_Z)(GameModule + 0xba4a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrMap::IsInitialized(class HrMap* const this) [?IsInitialized@HrMap@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsInitialized_HrMap__QAE_NXZ)(class HrMap* const thisPtr);
	uint8_t IsInitialized()
	{
		_IsInitialized_HrMap__QAE_NXZ mFunc = (_IsInitialized_HrMap__QAE_NXZ)(GameModule + 0xd3e30);
		return mFunc(this);
	}
	// [Function] struct tagGHMR_TEX __convention("thiscall") HrMap::GetMapFrameTex(class HrMap* const this) [?GetMapFrameTex@HrMap@@QAE?AUtagGHMR_TEX@@XZ]
	typedef struct tagGHMR_TEX(__thiscall* _GetMapFrameTex_HrMap__QAEAUtagGHMR_TEX__XZ)(class HrMap* const thisPtr);
	struct tagGHMR_TEX GetMapFrameTex()
	{
		_GetMapFrameTex_HrMap__QAEAUtagGHMR_TEX__XZ mFunc = (_GetMapFrameTex_HrMap__QAEAUtagGHMR_TEX__XZ)(GameModule + 0xd3e40);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMap::InitTextMessage(class HrMap* const this) [?InitTextMessage@HrMap@@IAEXXZ]
	typedef void(__thiscall* _InitTextMessage_HrMap__IAEXXZ)(class HrMap* const thisPtr);
	void InitTextMessage()
	{
		_InitTextMessage_HrMap__IAEXXZ mFunc = (_InitTextMessage_HrMap__IAEXXZ)(GameModule + 0x450b80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMap::IsOneFloor(class HrMap* const this) [?IsOneFloor@HrMap@@IAE_NXZ]
	typedef uint8_t(__thiscall* _IsOneFloor_HrMap__IAE_NXZ)(class HrMap* const thisPtr);
	uint8_t IsOneFloor()
	{
		_IsOneFloor_HrMap__IAE_NXZ mFunc = (_IsOneFloor_HrMap__IAE_NXZ)(GameModule + 0x450cc0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") HrMap::GetIconFloor(class HrMap* const this, float arg2) [?GetIconFloor@HrMap@@IAEHM@Z]
	typedef int32_t(__thiscall* _GetIconFloor_HrMap__IAEHM_Z)(class HrMap* const thisPtr, float arg2);
	int32_t GetIconFloor(float arg2)
	{
		_GetIconFloor_HrMap__IAEHM_Z mFunc = (_GetIconFloor_HrMap__IAEHM_Z)(GameModule + 0x450cf0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrMap::IsNowFloor(class HrMap* const this, float arg2) [?IsNowFloor@HrMap@@IAE_NM@Z]
	typedef uint8_t(__thiscall* _IsNowFloor_HrMap__IAE_NM_Z)(class HrMap* const thisPtr, float arg2);
	uint8_t IsNowFloor(float arg2)
	{
		_IsNowFloor_HrMap__IAE_NM_Z mFunc = (_IsNowFloor_HrMap__IAE_NM_Z)(GameModule + 0x450d80);
		return mFunc(this, arg2);
	}
	// [Function] enum PJ_QUICK_MOVE_TARGET __convention("thiscall") HrMap::IconDrawDataToQMT(class HrMap* const this, struct HrMap::DrawData& arg2) [?IconDrawDataToQMT@HrMap@@IAE?AW4PJ_QUICK_MOVE_TARGET@@ABUDrawData@1@@Z]
	typedef enum PJ_QUICK_MOVE_TARGET(__thiscall* _IconDrawDataToQMT_HrMap__IAEAW4PJ_QUICK_MOVE_TARGET__ABUDrawData_1__Z)(class HrMap* const thisPtr, struct HrMap::DrawData& arg2);
	/* enum PJ_QUICK_MOVE_TARGET */ uint32_t IconDrawDataToQMT(struct HrMap::DrawData& arg2)
	{
		_IconDrawDataToQMT_HrMap__IAEAW4PJ_QUICK_MOVE_TARGET__ABUDrawData_1__Z mFunc = (_IconDrawDataToQMT_HrMap__IAEAW4PJ_QUICK_MOVE_TARGET__ABUDrawData_1__Z)(GameModule + 0x450e20);
		return (uint32_t)mFunc(this, arg2);
	}
	// [Function] class NYDrawString* __convention("thiscall") HrMap::AddDrawString(class HrMap* const this, char const* arg2, struct Vec2& arg3, uint32_t arg4, enum GFONTTYPE_NUM arg5, enum NYDrawString::ALIGNMENT_TYPE arg6) [?AddDrawString@HrMap@@IAEPAVNYDrawString@@PBDABUVec2@@IW4GFONTTYPE_NUM@@W4ALIGNMENT_TYPE@2@@Z]
	typedef class NYDrawString*(__thiscall* _AddDrawString_HrMap__IAEPAVNYDrawString__PBDABUVec2__IW4GFONTTYPE_NUM__W4ALIGNMENT_TYPE_2__Z)(class HrMap* const thisPtr, char const* arg2, struct Vec2& arg3, uint32_t arg4, enum GFONTTYPE_NUM arg5, enum NYDrawString::ALIGNMENT_TYPE arg6);
	class NYDrawString* AddDrawString(std::string arg2, struct Vec2& arg3, uint32_t arg4, /* enum GFONTTYPE_NUM */ uint32_t arg5, /* enum NYDrawString::ALIGNMENT_TYPE */ uint32_t arg6)
	{
		char const* arg2_c_str = arg2.c_str();
		_AddDrawString_HrMap__IAEPAVNYDrawString__PBDABUVec2__IW4GFONTTYPE_NUM__W4ALIGNMENT_TYPE_2__Z mFunc = (_AddDrawString_HrMap__IAEPAVNYDrawString__PBDABUVec2__IW4GFONTTYPE_NUM__W4ALIGNMENT_TYPE_2__Z)(GameModule + 0x450ef0);
		return mFunc(this, arg2_c_str, arg3, arg4, (enum GFONTTYPE_NUM)arg5, (enum NYDrawString::ALIGNMENT_TYPE)arg6);
	}
	// [Function] struct tagGHMR_TEX& __convention("thiscall") HrMap::IconType2TexR(class HrMap* const this, enum HrMap::ICON_TYPE arg2) [?IconType2TexR@HrMap@@IAEAAUtagGHMR_TEX@@W4ICON_TYPE@1@@Z]
	typedef struct tagGHMR_TEX&(__thiscall* _IconType2TexR_HrMap__IAEAAUtagGHMR_TEX__W4ICON_TYPE_1__Z)(class HrMap* const thisPtr, enum HrMap::ICON_TYPE arg2);
	// Can't export & pointer 'struct tagGHMR_TEX&' [TypeClass.PointerTypeClass] in LuaBridge
	void IconType2TexR(/* enum HrMap::ICON_TYPE */ uint32_t arg2)
	{
		_IconType2TexR_HrMap__IAEAAUtagGHMR_TEX__W4ICON_TYPE_1__Z mFunc = (_IconType2TexR_HrMap__IAEAAUtagGHMR_TEX__W4ICON_TYPE_1__Z)(GameModule + 0x450fa0);
		mFunc(this, (enum HrMap::ICON_TYPE)arg2);
	}
	// [Function] void __convention("thiscall") HrMap::IconRegistClear(class HrMap* const this) [?IconRegistClear@HrMap@@IAEXXZ]
	typedef void(__thiscall* _IconRegistClear_HrMap__IAEXXZ)(class HrMap* const thisPtr);
	void IconRegistClear()
	{
		_IconRegistClear_HrMap__IAEXXZ mFunc = (_IconRegistClear_HrMap__IAEXXZ)(GameModule + 0x450fd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMap::IconRegist(class HrMap* const this, enum HrMap::ICON_TYPE arg2, struct Vec& arg3, float arg4, uint8_t arg5) [?IconRegist@HrMap@@IAEXW4ICON_TYPE@1@ABUVec@@M_N@Z]
	typedef void(__thiscall* _IconRegist_HrMap__IAEXW4ICON_TYPE_1_ABUVec__M_N_Z)(class HrMap* const thisPtr, enum HrMap::ICON_TYPE arg2, struct Vec& arg3, float arg4, uint8_t arg5);
	void IconRegist(/* enum HrMap::ICON_TYPE */ uint32_t arg2, struct Vec& arg3, float arg4, uint8_t arg5)
	{
		_IconRegist_HrMap__IAEXW4ICON_TYPE_1_ABUVec__M_N_Z mFunc = (_IconRegist_HrMap__IAEXW4ICON_TYPE_1_ABUVec__M_N_Z)(GameModule + 0x450ff0);
		return mFunc(this, (enum HrMap::ICON_TYPE)arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") HrMap::IconRegistEventArea(class HrMap* const this) [?IconRegistEventArea@HrMap@@IAEXXZ]
	typedef void(__thiscall* _IconRegistEventArea_HrMap__IAEXXZ)(class HrMap* const thisPtr);
	void IconRegistEventArea()
	{
		_IconRegistEventArea_HrMap__IAEXXZ mFunc = (_IconRegistEventArea_HrMap__IAEXXZ)(GameModule + 0x451400);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMap::SetScaleType(class HrMap* const this, enum HrMap::SCALE_TYPE arg2) [?SetScaleType@HrMap@@QAEXW4SCALE_TYPE@1@@Z]
	typedef void(__thiscall* _SetScaleType_HrMap__QAEXW4SCALE_TYPE_1__Z)(class HrMap* const thisPtr, enum HrMap::SCALE_TYPE arg2);
	void SetScaleType(/* enum HrMap::SCALE_TYPE */ uint32_t arg2)
	{
		_SetScaleType_HrMap__QAEXW4SCALE_TYPE_1__Z mFunc = (_SetScaleType_HrMap__QAEXW4SCALE_TYPE_1__Z)(GameModule + 0x451570);
		return mFunc(this, (enum HrMap::SCALE_TYPE)arg2);
	}
	// [Function] void __convention("thiscall") HrMap::Leave(class HrMap* const this, uint8_t arg2) [?Leave@HrMap@@QAEX_N@Z]
	typedef void(__thiscall* _Leave_HrMap__QAEX_N_Z)(class HrMap* const thisPtr, uint8_t arg2);
	void Leave(uint8_t arg2)
	{
		_Leave_HrMap__QAEX_N_Z mFunc = (_Leave_HrMap__QAEX_N_Z)(GameModule + 0x451700);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrMap::Appear(class HrMap* const this, enum HrMap::TYPE arg2, enum HrMap::SCALE_TYPE arg3, uint8_t arg4) [?Appear@HrMap@@QAE_NW4TYPE@1@W4SCALE_TYPE@1@_N@Z]
	typedef uint8_t(__thiscall* _Appear_HrMap__QAE_NW4TYPE_1_W4SCALE_TYPE_1__N_Z)(class HrMap* const thisPtr, enum HrMap::TYPE arg2, enum HrMap::SCALE_TYPE arg3, uint8_t arg4);
	uint8_t Appear(/* enum HrMap::TYPE */ uint32_t arg2, /* enum HrMap::SCALE_TYPE */ uint32_t arg3, uint8_t arg4)
	{
		_Appear_HrMap__QAE_NW4TYPE_1_W4SCALE_TYPE_1__N_Z mFunc = (_Appear_HrMap__QAE_NW4TYPE_1_W4SCALE_TYPE_1__N_Z)(GameModule + 0x4517e0);
		return mFunc(this, (enum HrMap::TYPE)arg2, (enum HrMap::SCALE_TYPE)arg3, arg4);
	}
	// [Function] void __convention("thiscall") HrMap::SetType(class HrMap* const this, enum HrMap::TYPE arg2) [?SetType@HrMap@@QAEXW4TYPE@1@@Z]
	typedef void(__thiscall* _SetType_HrMap__QAEXW4TYPE_1__Z)(class HrMap* const thisPtr, enum HrMap::TYPE arg2);
	void SetType(/* enum HrMap::TYPE */ uint32_t arg2)
	{
		_SetType_HrMap__QAEXW4TYPE_1__Z mFunc = (_SetType_HrMap__QAEXW4TYPE_1__Z)(GameModule + 0x4518d0);
		return mFunc(this, (enum HrMap::TYPE)arg2);
	}
	// [Function] void __convention("thiscall") HrMap::RenderProcess(class HrMap* const this) [?RenderProcess@HrMap@@QAEXXZ]
	typedef void(__thiscall* _RenderProcess_HrMap__QAEXXZ)(class HrMap* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_HrMap__QAEXXZ mFunc = (_RenderProcess_HrMap__QAEXXZ)(GameModule + 0x4519f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMap::FrameProcess(class HrMap* const this) [?FrameProcess@HrMap@@QAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrMap__QAEXXZ)(class HrMap* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrMap__QAEXXZ mFunc = (_FrameProcess_HrMap__QAEXXZ)(GameModule + 0x452350);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMap::Terminate(class HrMap* const this) [?Terminate@HrMap@@QAEXXZ]
	typedef void(__thiscall* _Terminate_HrMap__QAEXXZ)(class HrMap* const thisPtr);
	void Terminate()
	{
		_Terminate_HrMap__QAEXXZ mFunc = (_Terminate_HrMap__QAEXXZ)(GameModule + 0x453ae0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMap::InitializeStage(class HrMap* const this, class ghmResGroup* arg2, struct Vec& arg3) [?InitializeStage@HrMap@@QAE_NPAVghmResGroup@@ABUVec@@@Z]
	typedef uint8_t(__thiscall* _InitializeStage_HrMap__QAE_NPAVghmResGroup__ABUVec___Z)(class HrMap* const thisPtr, class ghmResGroup* arg2, struct Vec& arg3);
	uint8_t InitializeStage(class ghmResGroup* arg2, struct Vec& arg3)
	{
		_InitializeStage_HrMap__QAE_NPAVghmResGroup__ABUVec___Z mFunc = (_InitializeStage_HrMap__QAE_NPAVghmResGroup__ABUVec___Z)(GameModule + 0x453cd0);
		return mFunc(this, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMap [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMap& InObject)
	{
		FlashIconSEFlag = InObject.FlashIconSEFlag;
		FlashATMicon = InObject.FlashATMicon;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrMap>("HrMap")
			.addFunction("__tostring", &HrMap::ToString)
			.addFunction("GetPtrAddr", &HrMap::GetPtrAddr)
			.addProperty("FlashIconSEFlag", &HrMap::FlashIconSEFlag)
			.addProperty("FlashATMicon", &HrMap::FlashATMicon)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetIconPos", &HrMap::SetIconPos)
			.addFunction("ClearIcon", &HrMap::ClearIcon)
			.addFunction("SetFlashATMicon", &HrMap::SetFlashATMicon)
			.addFunction("IsMiniMap", &HrMap::IsMiniMap)
			.addFunction("GetWidth3D", &HrMap::GetWidth3D)
			.addFunction("GetHeight3D", &HrMap::GetHeight3D)
			.addFunction("SetScissorRect", &HrMap::SetScissorRect)
			.addFunction("GetMapOffset", &HrMap::GetMapOffset)
			.addFunction("IsDied", &HrMap::IsDied)
			.addFunction("GetIsDisp", &HrMap::GetIsDisp)
			.addFunction("SetFlashIconSE", &HrMap::SetFlashIconSE)
			.addFunction("IsInitialized", &HrMap::IsInitialized)
			.addFunction("GetMapFrameTex", &HrMap::GetMapFrameTex)
			.addFunction("InitTextMessage", &HrMap::InitTextMessage)
			.addFunction("IsOneFloor", &HrMap::IsOneFloor)
			.addFunction("GetIconFloor", &HrMap::GetIconFloor)
			.addFunction("IsNowFloor", &HrMap::IsNowFloor)
			// Can't export & pointer 'struct HrMap::DrawData&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("IconDrawDataToQMT", &HrMap::IconDrawDataToQMT)
			// Can't export & pointer 'struct Vec2&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("AddDrawString", &HrMap::AddDrawString)
			.addFunction("IconType2TexR", &HrMap::IconType2TexR)
			.addFunction("IconRegistClear", &HrMap::IconRegistClear)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("IconRegist", &HrMap::IconRegist)
			.addFunction("IconRegistEventArea", &HrMap::IconRegistEventArea)
			.addFunction("SetScaleType", &HrMap::SetScaleType)
			.addFunction("Leave", &HrMap::Leave)
			.addFunction("Appear", &HrMap::Appear)
			.addFunction("SetType", &HrMap::SetType)
			.addFunction("RenderProcess", &HrMap::RenderProcess)
			.addFunction("FrameProcess", &HrMap::FrameProcess)
			.addFunction("Terminate", &HrMap::Terminate)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("InitializeStage", &HrMap::InitializeStage)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMap::FlashIconSEFlag) == 1, "expected HrMap::FlashIconSEFlag to be size 1");
static_assert(sizeof(HrMap::FlashATMicon) == 1, "expected HrMap::FlashATMicon to be size 1");
static_assert(sizeof(HrMap) == 0x1ea4, "expected HrMap to be size 0x1ea4");

// [Structure] class NYPhase
class NYPhase
{
public:
	/// Struct member variables

	// <int32_t m_phase, offset 0x0>
	int32_t m_phase = 0;

	// <float m_frame, offset 0x4>
	float m_frame = 0;

	// <float m_frameMax, offset 0x8>
	float m_frameMax = 0;

	// <uint8_t m_useNext, offset 0xc>
	uint8_t m_useNext = 0;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData_13[3];

public:
	// <int32_t m_nextPhase, offset 0x10>
	int32_t m_nextPhase = 0;

	// <float m_nextFrame, offset 0x14>
	float m_nextFrame = 0;

	// <float m_nextFrameMax, offset 0x18>
	float m_nextFrameMax = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class NYPhase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(NYPhase& InObject)
	{
		m_phase = InObject.m_phase;
		m_frame = InObject.m_frame;
		m_frameMax = InObject.m_frameMax;
		m_useNext = InObject.m_useNext;
		m_nextPhase = InObject.m_nextPhase;
		m_nextFrame = InObject.m_nextFrame;
		m_nextFrameMax = InObject.m_nextFrameMax;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NYPhase>("NYPhase")
			.addFunction("__tostring", &NYPhase::ToString)
			.addFunction("GetPtrAddr", &NYPhase::GetPtrAddr)
			.addProperty("m_phase", &NYPhase::m_phase)
			.addProperty("m_frame", &NYPhase::m_frame)
			.addProperty("m_frameMax", &NYPhase::m_frameMax)
			.addProperty("m_useNext", &NYPhase::m_useNext)
			.addProperty("m_nextPhase", &NYPhase::m_nextPhase)
			.addProperty("m_nextFrame", &NYPhase::m_nextFrame)
			.addProperty("m_nextFrameMax", &NYPhase::m_nextFrameMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYPhase::m_phase) == 4, "expected NYPhase::m_phase to be size 4");
static_assert(sizeof(NYPhase::m_frame) == 4, "expected NYPhase::m_frame to be size 4");
static_assert(sizeof(NYPhase::m_frameMax) == 4, "expected NYPhase::m_frameMax to be size 4");
static_assert(sizeof(NYPhase::m_useNext) == 1, "expected NYPhase::m_useNext to be size 1");
static_assert(sizeof(NYPhase::m_nextPhase) == 4, "expected NYPhase::m_nextPhase to be size 4");
static_assert(sizeof(NYPhase::m_nextFrame) == 4, "expected NYPhase::m_nextFrame to be size 4");
static_assert(sizeof(NYPhase::m_nextFrameMax) == 4, "expected NYPhase::m_nextFrameMax to be size 4");
static_assert(sizeof(NYPhase) == 0x1c, "expected NYPhase to be size 0x1c");

// [Structure] class CHrHUDBase
class CHrHUDBase
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x8], offset 0x0>
	void* (* field_0)[0x8];

	// <void (* m_pPhaseProc[0x6][0x2])(CHrHUDBase* const this), offset 0x4>
	void (* m_pPhaseProc[0x6][0x2])(CHrHUDBase* const ThisPtr);

	// <uint8_t m_bHide, offset 0x34>
	uint8_t m_bHide = 0;

	// <Unidentified data segment, offset 0x35>
private:
	char _UnidentifiedData_53[3];

public:
	// <struct Vec2 m_OffsetPos, offset 0x38>
	struct Vec2 m_OffsetPos;

	// <class NYPhase m_Phase, offset 0x40>
	class NYPhase m_Phase;

	// <float m_PhaseTime[0x3], offset 0x5c>
	float m_PhaseTime[3];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CHrHUDBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CHrHUDBase& InObject)
	{
		m_bHide = InObject.m_bHide;
		m_OffsetPos = InObject.m_OffsetPos;
		m_Phase = InObject.m_Phase;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CHrHUDBase>("CHrHUDBase")
			.addFunction("__tostring", &CHrHUDBase::ToString)
			.addFunction("GetPtrAddr", &CHrHUDBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &CHrHUDBase::field_0)
			// void type not supported in LuaBridge
			//.addProperty("m_pPhaseProc", &CHrHUDBase::m_pPhaseProc)
			.addProperty("m_bHide", &CHrHUDBase::m_bHide)
			.addProperty("m_OffsetPos", &CHrHUDBase::m_OffsetPos)
			.addProperty("m_Phase", &CHrHUDBase::m_Phase)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_PhaseTime", &CHrHUDBase::m_PhaseTime)
		.endClass();
	}
#endif
};
static_assert(sizeof(CHrHUDBase::field_0) == 4, "expected CHrHUDBase::field_0 to be size 4");
static_assert(sizeof(CHrHUDBase::m_pPhaseProc) == 48, "expected CHrHUDBase::m_pPhaseProc to be size 48");
static_assert(sizeof(CHrHUDBase::m_bHide) == 1, "expected CHrHUDBase::m_bHide to be size 1");
static_assert(sizeof(CHrHUDBase::m_OffsetPos) == 8, "expected CHrHUDBase::m_OffsetPos to be size 8");
static_assert(sizeof(CHrHUDBase::m_Phase) == 28, "expected CHrHUDBase::m_Phase to be size 28");
static_assert(sizeof(CHrHUDBase::m_PhaseTime) == 12, "expected CHrHUDBase::m_PhaseTime to be size 12");
static_assert(sizeof(CHrHUDBase) == 0x68, "expected CHrHUDBase to be size 0x68");

// [Structure] class CHrHUDMoney
class CHrHUDMoney : public CHrHUDBase
{
public:
	/// Struct member variables

	// <class CHrHUDBase Super, offset 0x0>
	// class CHrHUDBase Super;

	// <Unidentified data segment, offset 0x68>
private:
	char _UnidentifiedData_104[4];

public:
	// <float AppearOffsetY, offset 0x6c>
	float AppearOffsetY = 0;

	// <Unidentified data segment, offset 0x70>
private:
	char _UnidentifiedData_112[556];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CHrHUDMoney [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CHrHUDMoney& InObject)
	{
		AppearOffsetY = InObject.AppearOffsetY;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CHrHUDMoney, CHrHUDBase>("CHrHUDMoney")
			.addFunction("__tostring", &CHrHUDMoney::ToString)
			.addFunction("GetPtrAddr", &CHrHUDMoney::GetPtrAddr)
			.addProperty("AppearOffsetY", &CHrHUDMoney::AppearOffsetY)
		.endClass();
	}
#endif
};
static_assert(sizeof(CHrHUDMoney::AppearOffsetY) == 4, "expected CHrHUDMoney::AppearOffsetY to be size 4");
static_assert(sizeof(CHrHUDMoney) == 0x29c, "expected CHrHUDMoney to be size 0x29c");

// [Structure] class CHrHUDTension
class CHrHUDTension : public CHrHUDBase
{
public:
	/// Struct member variables

	// <class CHrHUDBase Super, offset 0x0>
	// class CHrHUDBase Super;

	// <Unidentified data segment, offset 0x68>
private:
	char _UnidentifiedData_104[328];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CHrHUDTension [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CHrHUDTension& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CHrHUDTension, CHrHUDBase>("CHrHUDTension")
			.addFunction("__tostring", &CHrHUDTension::ToString)
			.addFunction("GetPtrAddr", &CHrHUDTension::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CHrHUDTension) == 0x1b0, "expected CHrHUDTension to be size 0x1b0");

// [Structure] class HrScreenStatus
class HrScreenStatus
{
public:
	// enum HrScreenStatus::STAT_DRAW_TYPE
	enum STAT_DRAW_TYPE : uint32_t
	{
		// <SCREEN_STAT_BATTLE = 0x0>
		SCREEN_STAT_BATTLE = 0,

		// <SCREEN_STAT_NATURAL = 0x1>
		SCREEN_STAT_NATURAL = 1,

		// <SCREEN_STAT_TOURING = 0x2>
		SCREEN_STAT_TOURING = 2

	};

	// enum HrScreenStatus::D_STATVAL_TYPE
	enum D_STATVAL_TYPE : uint32_t
	{
		// <D_STATVAL_HP = 0x0>
		D_STATVAL_HP = 0,

		// <D_STATVAL_TENSION = 0x1>
		D_STATVAL_TENSION = 1,

		// <D_STATVAL_BATTERY = 0x2>
		D_STATVAL_BATTERY = 2,

		// <D_STATVAL_MAP = 0x3>
		D_STATVAL_MAP = 3,

		// <D_STATVAL_MONEY = 0x4>
		D_STATVAL_MONEY = 4,

		// <D_STATVAL_SPEEDMETER = 0x5>
		D_STATVAL_SPEEDMETER = 5,

		// <D_STATVAL_KEYGUIDE = 0x6>
		D_STATVAL_KEYGUIDE = 6,

		// <D_STATVAL_CHECKPOINT = 0x7>
		D_STATVAL_CHECKPOINT = 7,

		// <D_STATVAL_BOSSHP = 0x8>
		D_STATVAL_BOSSHP = 8,

		// <D_STATVAL_LOG = 0x9>
		D_STATVAL_LOG = 9,

		// <D_STATVAL_COMBO = 0xa>
		D_STATVAL_COMBO = 10,

		// <D_STATVAL_SLOT = 0xb>
		D_STATVAL_SLOT = 11,

		// <D_STATVAL_TYPENUM = 0xc>
		D_STATVAL_TYPENUM = 12

	};

	// enum HrScreenStatus::E_LOG_DOID
	enum E_LOG_DOID : uint32_t
	{
		// <E_LOG_DOID_PICKUP = 0x0>
		E_LOG_DOID_PICKUP = 0,

		// <E_LOG_DOID_KABUTTA = 0x1>
		E_LOG_DOID_KABUTTA = 1,

		// <E_LOG_DOID_NAKATTA = 0x2>
		E_LOG_DOID_NAKATTA = 2,

		// <E_LOG_DOID_HORENAKATTA = 0x3>
		E_LOG_DOID_HORENAKATTA = 3,

		// <E_LOG_DOID_DIG_MONEY = 0x4>
		E_LOG_DOID_DIG_MONEY = 4,

		// <E_LOG_DOID_GET_MONEY = 0x5>
		E_LOG_DOID_GET_MONEY = 5,

		// <E_LOG_DOID_DIG_TSHIRT = 0x6>
		E_LOG_DOID_DIG_TSHIRT = 6,

		// <E_LOG_DOID_GET_TSHIRT = 0x7>
		E_LOG_DOID_GET_TSHIRT = 7,

		// <E_LOG_DOID_DIG = 0x8>
		E_LOG_DOID_DIG = 8,

		// <E_LOG_DOID_GET = 0x9>
		E_LOG_DOID_GET = 9,

		// <E_LOG_DOID_MAXHP_UP = 0xa>
		E_LOG_DOID_MAXHP_UP = 10,

		// <E_LOG_DOID_USAARE_GET = 0xb>
		E_LOG_DOID_USAARE_GET = 11,

		// <E_LOG_DOID_NIHONTO_GET = 0xc>
		E_LOG_DOID_NIHONTO_GET = 12,

		// <E_LOG_DOID_KAIFUKU = 0xd>
		E_LOG_DOID_KAIFUKU = 13,

		// <E_LOG_DOID_NUM = 0xe>
		E_LOG_DOID_NUM = 14

	};

	// enum HrScreenStatus::D_CHECKPOINT_TYPE
	enum D_CHECKPOINT_TYPE : uint32_t
	{
		// <D_CECKPO_CHECKPOINT = 0x0>
		D_CECKPO_CHECKPOINT = 0,

		// <D_CECKPO_STANDBY = 0x1>
		D_CECKPO_STANDBY = 1,

		// <D_CECKPO_ZENMETU = 0x2>
		D_CECKPO_ZENMETU = 2,

		// <D_CECKPO_CANTRIDE = 0x3>
		D_CECKPO_CANTRIDE = 3,

		// <D_CECKPO_PHONE = 0x4>
		D_CECKPO_PHONE = 4,

		// <D_CECKPO_NEWMASK = 0x5>
		D_CECKPO_NEWMASK = 5,

		// <D_CECKPO_SENRIHIN = 0x6>
		D_CECKPO_SENRIHIN = 6,

		// <D_CECKPO_TYPENUM = 0x7>
		D_CECKPO_TYPENUM = 7

	};

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[184];

public:
	// <uint32_t State, offset 0xb8>
	uint32_t State = 0;

	// <Unidentified data segment, offset 0xbc>
private:
	char _UnidentifiedData_188[28];

public:
	// <class HrMap* Map, offset 0xd8>
	class HrMap* Map = nullptr;

	// <Unidentified data segment, offset 0xdc>
private:
	char _UnidentifiedData_220[7840];

public:
	// <int32_t MapScaleType, offset 0x1f7c>
	int32_t MapScaleType = 0;

	// <Unidentified data segment, offset 0x1f80>
private:
	char _UnidentifiedData_8064[12];

public:
	// <class HrScreenStatusBalloon* ScreenStatusBalloon, offset 0x1f8c>
	class HrScreenStatusBalloon* ScreenStatusBalloon = nullptr;

	// <Unidentified data segment, offset 0x1f90>
private:
	char _UnidentifiedData_8080[1692];

public:
	// <uint32_t UnknownLanguageGroupResources, offset 0x262c>
	uint32_t UnknownLanguageGroupResources = 0;

	// <char UnknownBalloonInitializeStageFlag, offset 0x2630>
	char UnknownBalloonInitializeStageFlag;

	// <Unidentified data segment, offset 0x2631>
private:
	char _UnidentifiedData_9777[935];

public:
	// <class HrTask* UnknownMissionTaskPointer, offset 0x29d8>
	class HrTask* UnknownMissionTaskPointer = nullptr;

	// <Unidentified data segment, offset 0x29dc>
private:
	char _UnidentifiedData_10716[908];

public:
	// <class HrScreenStatusSlot* ScreenStatusSlot, offset 0x2d68>
	class HrScreenStatusSlot* ScreenStatusSlot = nullptr;

	// <Unidentified data segment, offset 0x2d6c>
private:
	char _UnidentifiedData_11628[36];

public:
	// <class GtSimplMes* SimpleMessage, offset 0x2d90>
	class GtSimplMes* SimpleMessage = nullptr;

	// <Unidentified data segment, offset 0x2d94>
private:
	char _UnidentifiedData_11668[16];

public:
	// <struct BATTLESIMPLMESS_SET* BattleSimpleMessagePtr, offset 0x2da4>
	struct BATTLESIMPLMESS_SET* BattleSimpleMessagePtr = nullptr;

	// <Unidentified data segment, offset 0x2da8>
private:
	char _UnidentifiedData_11688[8];

public:
	// <int16_t DrawFlag, offset 0x2db0>
	int16_t DrawFlag = 0;

	// <Unidentified data segment, offset 0x2db2>
private:
	char _UnidentifiedData_11698[21];

public:
	// <uint8_t BusFight, offset 0x2dc7>
	uint8_t BusFight = 0;

	// <Unidentified data segment, offset 0x2dc8>
private:
	char _UnidentifiedData_11720[7];

public:
	// <uint8_t MiniMapVisible, offset 0x2dcf>
	uint8_t MiniMapVisible = 0;

	// <Unidentified data segment, offset 0x2dd0>
private:
	char _UnidentifiedData_11728[4];

public:
	// <int32_t RevengeMissionAllEnmNum, offset 0x2dd4>
	int32_t RevengeMissionAllEnmNum = 0;

	// <Unidentified data segment, offset 0x2dd8>
private:
	char _UnidentifiedData_11736[60];

public:
	// <char HealthFlag, offset 0x2e14>
	char HealthFlag;

	// <Unidentified data segment, offset 0x2e15>
private:
	char _UnidentifiedData_11797[131];

public:
	// <char BatteryFlag, offset 0x2e98>
	char BatteryFlag;

	// <Unidentified data segment, offset 0x2e99>
private:
	char _UnidentifiedData_11929[751];

public:
	// <class CHrHUDTension TensionHud, offset 0x3188>
	class CHrHUDTension TensionHud;

	// <class CHrHUDMoney MoneyHud, offset 0x3338>
	class CHrHUDMoney MoneyHud;

	// <Unidentified data segment, offset 0x35d4>
private:
	char _UnidentifiedData_13780[52];

public:
	// <char SpeedMeterFlag, offset 0x3608>
	char SpeedMeterFlag;

	// <Unidentified data segment, offset 0x3609>
private:
	char _UnidentifiedData_13833[599];

public:
	// <uint32_t SettingBGMVolume, offset 0x3860>
	uint32_t SettingBGMVolume = 0;

	// <uint32_t SettingSEVolume, offset 0x3864>
	uint32_t SettingSEVolume = 0;

	// <uint8_t SettingMiniMap, offset 0x3868>
	uint8_t SettingMiniMap = 0;

	// <Unidentified data segment, offset 0x3869>
private:
	char _UnidentifiedData_14441[3];

public:
	// <float SettingPower, offset 0x386c>
	float SettingPower = 0;

	/// 66 Functions

	// [Function] class HrMap& __convention("thiscall") HrScreenStatus::GetMap(class HrScreenStatus* const this) [?GetMap@HrScreenStatus@@QAEAAVHrMap@@XZ]
	typedef class HrMap&(__thiscall* _GetMap_HrScreenStatus__QAEAAVHrMap__XZ)(class HrScreenStatus* const thisPtr);
	// Can't export & pointer 'class HrMap&' [TypeClass.PointerTypeClass] in LuaBridge
	void GetMap()
	{
		_GetMap_HrScreenStatus__QAEAAVHrMap__XZ mFunc = (_GetMap_HrScreenStatus__QAEAAVHrMap__XZ)(GameModule + 0x9cec0);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetStatusBatterySE_Flag(class HrScreenStatus* const this, uint8_t arg2) [?SetStatusBatterySE_Flag@HrScreenStatus@@QAEX_N@Z]
	typedef void(__thiscall* _SetStatusBatterySE_Flag_HrScreenStatus__QAEX_N_Z)(class HrScreenStatus* const thisPtr, uint8_t arg2);
	void SetStatusBatterySE_Flag(uint8_t arg2)
	{
		_SetStatusBatterySE_Flag_HrScreenStatus__QAEX_N_Z mFunc = (_SetStatusBatterySE_Flag_HrScreenStatus__QAEX_N_Z)(GameModule + 0xa2220);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetStatusMAXBatterySEStopFlag(class HrScreenStatus* const this) [?SetStatusMAXBatterySEStopFlag@HrScreenStatus@@QAEXXZ]
	typedef void(__thiscall* _SetStatusMAXBatterySEStopFlag_HrScreenStatus__QAEXXZ)(class HrScreenStatus* const thisPtr);
	void SetStatusMAXBatterySEStopFlag()
	{
		_SetStatusMAXBatterySEStopFlag_HrScreenStatus__QAEXXZ mFunc = (_SetStatusMAXBatterySEStopFlag_HrScreenStatus__QAEXXZ)(GameModule + 0xa2230);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetRevengeMissionAllEnmNum(class HrScreenStatus* const this, int32_t arg2) [?SetRevengeMissionAllEnmNum@HrScreenStatus@@QAEXH@Z]
	typedef void(__thiscall* _SetRevengeMissionAllEnmNum_HrScreenStatus__QAEXH_Z)(class HrScreenStatus* const thisPtr, int32_t arg2);
	void SetRevengeMissionAllEnmNum(int32_t arg2)
	{
		_SetRevengeMissionAllEnmNum_HrScreenStatus__QAEXH_Z mFunc = (_SetRevengeMissionAllEnmNum_HrScreenStatus__QAEXH_Z)(GameModule + 0xa2240);
		return mFunc(this, arg2);
	}
	// [Function] class HrScreenStatusSlot& __convention("thiscall") HrScreenStatus::GetSlot(class HrScreenStatus* const this) [?GetSlot@HrScreenStatus@@QAEAAVHrScreenStatusSlot@@XZ]
	typedef class HrScreenStatusSlot&(__thiscall* _GetSlot_HrScreenStatus__QAEAAVHrScreenStatusSlot__XZ)(class HrScreenStatus* const thisPtr);
	// Can't export & pointer 'class HrScreenStatusSlot&' [TypeClass.PointerTypeClass] in LuaBridge
	void GetSlot()
	{
		_GetSlot_HrScreenStatus__QAEAAVHrScreenStatusSlot__XZ mFunc = (_GetSlot_HrScreenStatus__QAEAAVHrScreenStatusSlot__XZ)(GameModule + 0xa2250);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetStatusProcess(class HrScreenStatus* const this, uint8_t arg2) [?SetStatusProcess@HrScreenStatus@@QAEX_N@Z]
	typedef void(__thiscall* _SetStatusProcess_HrScreenStatus__QAEX_N_Z)(class HrScreenStatus* const thisPtr, uint8_t arg2);
	void SetStatusProcess(uint8_t arg2)
	{
		_SetStatusProcess_HrScreenStatus__QAEX_N_Z mFunc = (_SetStatusProcess_HrScreenStatus__QAEX_N_Z)(GameModule + 0xa3880);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") HrScreenStatus::GetRevengeMissionAllEnmNum(class HrScreenStatus* const this) [?GetRevengeMissionAllEnmNum@HrScreenStatus@@QAEHXZ]
	typedef int32_t(__thiscall* _GetRevengeMissionAllEnmNum_HrScreenStatus__QAEHXZ)(class HrScreenStatus* const thisPtr);
	int32_t GetRevengeMissionAllEnmNum()
	{
		_GetRevengeMissionAllEnmNum_HrScreenStatus__QAEHXZ mFunc = (_GetRevengeMissionAllEnmNum_HrScreenStatus__QAEHXZ)(GameModule + 0xa3890);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetSettingBGMVolume(class HrScreenStatus* const this, uint32_t arg2) [?SetSettingBGMVolume@HrScreenStatus@@QAEXI@Z]
	typedef void(__thiscall* _SetSettingBGMVolume_HrScreenStatus__QAEXI_Z)(class HrScreenStatus* const thisPtr, uint32_t arg2);
	void SetSettingBGMVolume(uint32_t arg2)
	{
		_SetSettingBGMVolume_HrScreenStatus__QAEXI_Z mFunc = (_SetSettingBGMVolume_HrScreenStatus__QAEXI_Z)(GameModule + 0xa38a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetSettingSEVolume(class HrScreenStatus* const this, uint32_t arg2) [?SetSettingSEVolume@HrScreenStatus@@QAEXI@Z]
	typedef void(__thiscall* _SetSettingSEVolume_HrScreenStatus__QAEXI_Z)(class HrScreenStatus* const thisPtr, uint32_t arg2);
	void SetSettingSEVolume(uint32_t arg2)
	{
		_SetSettingSEVolume_HrScreenStatus__QAEXI_Z mFunc = (_SetSettingSEVolume_HrScreenStatus__QAEXI_Z)(GameModule + 0xa38b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetSettingMiniMap(class HrScreenStatus* const this, uint8_t arg2) [?SetSettingMiniMap@HrScreenStatus@@QAEX_N@Z]
	typedef void(__thiscall* _SetSettingMiniMap_HrScreenStatus__QAEX_N_Z)(class HrScreenStatus* const thisPtr, uint8_t arg2);
	void SetSettingMiniMap(uint8_t arg2)
	{
		_SetSettingMiniMap_HrScreenStatus__QAEX_N_Z mFunc = (_SetSettingMiniMap_HrScreenStatus__QAEX_N_Z)(GameModule + 0xa38c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetSettingPower(class HrScreenStatus* const this, float arg2) [?SetSettingPower@HrScreenStatus@@QAEXM@Z]
	typedef void(__thiscall* _SetSettingPower_HrScreenStatus__QAEXM_Z)(class HrScreenStatus* const thisPtr, float arg2);
	void SetSettingPower(float arg2)
	{
		_SetSettingPower_HrScreenStatus__QAEXM_Z mFunc = (_SetSettingPower_HrScreenStatus__QAEXM_Z)(GameModule + 0xa38d0);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") HrScreenStatus::GetStatusBatteryParam(class HrScreenStatus* const this) [?GetStatusBatteryParam@HrScreenStatus@@QAEMXZ]
	typedef float(__thiscall* _GetStatusBatteryParam_HrScreenStatus__QAEMXZ)(class HrScreenStatus* const thisPtr);
	float GetStatusBatteryParam()
	{
		_GetStatusBatteryParam_HrScreenStatus__QAEMXZ mFunc = (_GetStatusBatteryParam_HrScreenStatus__QAEMXZ)(GameModule + 0xaab50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::SetStatusDataLoadFlag(class HrScreenStatus* const this, uint8_t arg2) [?SetStatusDataLoadFlag@HrScreenStatus@@QAEX_N@Z]
	typedef void(__thiscall* _SetStatusDataLoadFlag_HrScreenStatus__QAEX_N_Z)(class HrScreenStatus* const thisPtr, uint8_t arg2);
	void SetStatusDataLoadFlag(uint8_t arg2)
	{
		_SetStatusDataLoadFlag_HrScreenStatus__QAEX_N_Z mFunc = (_SetStatusDataLoadFlag_HrScreenStatus__QAEX_N_Z)(GameModule + 0xaab60);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::GetStatusBatterySE_Flag(class HrScreenStatus* const this) [?GetStatusBatterySE_Flag@HrScreenStatus@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetStatusBatterySE_Flag_HrScreenStatus__QAE_NXZ)(class HrScreenStatus* const thisPtr);
	uint8_t GetStatusBatterySE_Flag()
	{
		_GetStatusBatterySE_Flag_HrScreenStatus__QAE_NXZ mFunc = (_GetStatusBatterySE_Flag_HrScreenStatus__QAE_NXZ)(GameModule + 0xaab70);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") HrScreenStatus::GetSettingBGMVolume(class HrScreenStatus* const this) [?GetSettingBGMVolume@HrScreenStatus@@QAEIXZ]
	typedef uint32_t(__thiscall* _GetSettingBGMVolume_HrScreenStatus__QAEIXZ)(class HrScreenStatus* const thisPtr);
	uint32_t GetSettingBGMVolume()
	{
		_GetSettingBGMVolume_HrScreenStatus__QAEIXZ mFunc = (_GetSettingBGMVolume_HrScreenStatus__QAEIXZ)(GameModule + 0xba4b0);
		return mFunc(this);
	}
	// [Function] struct tagGHMR_TEX* __convention("thiscall") HrScreenStatus::GetScrollBarTexture(class HrScreenStatus* const this) [?GetScrollBarTexture@HrScreenStatus@@QBEPAUtagGHMR_TEX@@XZ]
	typedef struct tagGHMR_TEX*(__thiscall* _GetScrollBarTexture_HrScreenStatus__QBEPAUtagGHMR_TEX__XZ)(class HrScreenStatus* const thisPtr);
	struct tagGHMR_TEX* GetScrollBarTexture()
	{
		_GetScrollBarTexture_HrScreenStatus__QBEPAUtagGHMR_TEX__XZ mFunc = (_GetScrollBarTexture_HrScreenStatus__QBEPAUtagGHMR_TEX__XZ)(GameModule + 0xd4000);
		return mFunc(this);
	}
	// [Function] struct tagGHMR_TEX __convention("thiscall") HrScreenStatus::GetMapFrameTex(class HrScreenStatus* const this) [?GetMapFrameTex@HrScreenStatus@@QAE?AUtagGHMR_TEX@@XZ]
	typedef struct tagGHMR_TEX(__thiscall* _GetMapFrameTex_HrScreenStatus__QAEAUtagGHMR_TEX__XZ)(class HrScreenStatus* const thisPtr);
	struct tagGHMR_TEX GetMapFrameTex()
	{
		_GetMapFrameTex_HrScreenStatus__QAEAUtagGHMR_TEX__XZ mFunc = (_GetMapFrameTex_HrScreenStatus__QAEAUtagGHMR_TEX__XZ)(GameModule + 0xd4010);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrScreenStatus::GetSettingPower(class HrScreenStatus* const this) [?GetSettingPower@HrScreenStatus@@QAEMXZ]
	typedef float(__thiscall* _GetSettingPower_HrScreenStatus__QAEMXZ)(class HrScreenStatus* const thisPtr);
	float GetSettingPower()
	{
		_GetSettingPower_HrScreenStatus__QAEMXZ mFunc = (_GetSettingPower_HrScreenStatus__QAEMXZ)(GameModule + 0xd4040);
		return mFunc(this);
	}
	// [Function] class HrTask* HrScreenStatus::TestCreate() [?TestCreate@HrScreenStatus@@SAPAVHrTask@@XZ]
	typedef class HrTask*(__fastcall* _TestCreate_HrScreenStatus__SAPAVHrTask__XZ)();
	static class HrTask* TestCreate()
	{
		_TestCreate_HrScreenStatus__SAPAVHrTask__XZ mFunc = (_TestCreate_HrScreenStatus__SAPAVHrTask__XZ)(GameModule + 0x469d60);
		return mFunc();
	}
	// [Function] uint8_t HrScreenStatus::CheckUnionTerminate() [?CheckUnionTerminate@HrScreenStatus@@KA_NXZ]
	typedef uint8_t(__fastcall* _CheckUnionTerminate_HrScreenStatus__KA_NXZ)();
	static uint8_t CheckUnionTerminate()
	{
		_CheckUnionTerminate_HrScreenStatus__KA_NXZ mFunc = (_CheckUnionTerminate_HrScreenStatus__KA_NXZ)(GameModule + 0x469d70);
		return mFunc();
	}
	// [Function] uint8_t HrScreenStatus::UnionTerminate() [?UnionTerminate@HrScreenStatus@@KA_NXZ]
	typedef uint8_t(__fastcall* _UnionTerminate_HrScreenStatus__KA_NXZ)();
	static uint8_t UnionTerminate()
	{
		_UnionTerminate_HrScreenStatus__KA_NXZ mFunc = (_UnionTerminate_HrScreenStatus__KA_NXZ)(GameModule + 0x469e40);
		return mFunc();
	}
	// [Function] uint8_t HrScreenStatus::CheckUnionInitialize() [?CheckUnionInitialize@HrScreenStatus@@KA_NXZ]
	typedef uint8_t(__fastcall* _CheckUnionInitialize_HrScreenStatus__KA_NXZ)();
	static uint8_t CheckUnionInitialize()
	{
		_CheckUnionInitialize_HrScreenStatus__KA_NXZ mFunc = (_CheckUnionInitialize_HrScreenStatus__KA_NXZ)(GameModule + 0x469e70);
		return mFunc();
	}
	// [Function] uint8_t HrScreenStatus::UnionInitialize() [?UnionInitialize@HrScreenStatus@@KA_NXZ]
	typedef uint8_t(__fastcall* _UnionInitialize_HrScreenStatus__KA_NXZ)();
	static uint8_t UnionInitialize()
	{
		_UnionInitialize_HrScreenStatus__KA_NXZ mFunc = (_UnionInitialize_HrScreenStatus__KA_NXZ)(GameModule + 0x46a1e0);
		return mFunc();
	}
	// [Function] float __convention("thiscall") HrScreenStatus::dValUp(class HrScreenStatus* const this, float arg2, float arg3) [?dValUp@HrScreenStatus@@AAEMMM@Z]
	typedef float(__thiscall* _dValUp_HrScreenStatus__AAEMMM_Z)(class HrScreenStatus* const thisPtr, float arg2, float arg3);
	float dValUp(float arg2, float arg3)
	{
		_dValUp_HrScreenStatus__AAEMMM_Z mFunc = (_dValUp_HrScreenStatus__AAEMMM_Z)(GameModule + 0x46a210);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dSetMissionResultSceneTime(class HrScreenStatus* const this, int32_t arg2, uint8_t arg3) [?dSetMissionResultSceneTime@HrScreenStatus@@QAE_NHE@Z]
	typedef uint8_t(__thiscall* _dSetMissionResultSceneTime_HrScreenStatus__QAE_NHE_Z)(class HrScreenStatus* const thisPtr, int32_t arg2, uint8_t arg3);
	uint8_t dSetMissionResultSceneTime(int32_t arg2, uint8_t arg3)
	{
		_dSetMissionResultSceneTime_HrScreenStatus__QAE_NHE_Z mFunc = (_dSetMissionResultSceneTime_HrScreenStatus__QAE_NHE_Z)(GameModule + 0x46a280);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::BalloonCheckDraw(class HrScreenStatus* const this) [?BalloonCheckDraw@HrScreenStatus@@QAE_NXZ]
	typedef uint8_t(__thiscall* _BalloonCheckDraw_HrScreenStatus__QAE_NXZ)(class HrScreenStatus* const thisPtr);
	uint8_t BalloonCheckDraw()
	{
		_BalloonCheckDraw_HrScreenStatus__QAE_NXZ mFunc = (_BalloonCheckDraw_HrScreenStatus__QAE_NXZ)(GameModule + 0x46a2d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::dLog_ScissoringBoxAnimationProc(class HrScreenStatus* const this, float* arg2, int16_t* arg3, int16_t* arg4, int32_t arg5) [?dLog_ScissoringBoxAnimationProc@HrScreenStatus@@AAEXPAMPAF1H@Z]
	typedef void(__thiscall* _dLog_ScissoringBoxAnimationProc_HrScreenStatus__AAEXPAMPAF1H_Z)(class HrScreenStatus* const thisPtr, float* arg2, int16_t* arg3, int16_t* arg4, int32_t arg5);
	void dLog_ScissoringBoxAnimationProc(float* arg2, int16_t* arg3, int16_t* arg4, int32_t arg5)
	{
		_dLog_ScissoringBoxAnimationProc_HrScreenStatus__AAEXPAMPAF1H_Z mFunc = (_dLog_ScissoringBoxAnimationProc_HrScreenStatus__AAEXPAMPAF1H_Z)(GameModule + 0x46a2e0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::RenderProcess(class HrScreenStatus* const this) [?RenderProcess@HrScreenStatus@@MAEXXZ]
	typedef void(__thiscall* _RenderProcess_HrScreenStatus__MAEXXZ)(class HrScreenStatus* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_HrScreenStatus__MAEXXZ mFunc = (_RenderProcess_HrScreenStatus__MAEXXZ)(GameModule + 0x46a3e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::DispCheckPointMessage(class HrScreenStatus* const this) [?DispCheckPointMessage@HrScreenStatus@@AAEXXZ]
	typedef void(__thiscall* _DispCheckPointMessage_HrScreenStatus__AAEXXZ)(class HrScreenStatus* const thisPtr);
	void DispCheckPointMessage()
	{
		_DispCheckPointMessage_HrScreenStatus__AAEXXZ mFunc = (_DispCheckPointMessage_HrScreenStatus__AAEXXZ)(GameModule + 0x46a530);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::IsDrawKillCount(class HrScreenStatus* const this) [?IsDrawKillCount@HrScreenStatus@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsDrawKillCount_HrScreenStatus__AAE_NXZ)(class HrScreenStatus* const thisPtr);
	uint8_t IsDrawKillCount()
	{
		_IsDrawKillCount_HrScreenStatus__AAE_NXZ mFunc = (_IsDrawKillCount_HrScreenStatus__AAE_NXZ)(GameModule + 0x46a600);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::DrawSubMissionInfo(class HrScreenStatus* const this) [?DrawSubMissionInfo@HrScreenStatus@@AAEXXZ]
	typedef void(__thiscall* _DrawSubMissionInfo_HrScreenStatus__AAEXXZ)(class HrScreenStatus* const thisPtr);
	void DrawSubMissionInfo()
	{
		_DrawSubMissionInfo_HrScreenStatus__AAEXXZ mFunc = (_DrawSubMissionInfo_HrScreenStatus__AAEXXZ)(GameModule + 0x46a640);
		return mFunc(this);
	}
	// [Function] void HrScreenStatus::RenderProcessFront(void* arg1) [?RenderProcessFront@HrScreenStatus@@KAXPAX@Z]
	typedef void(__fastcall* _RenderProcessFront_HrScreenStatus__KAXPAX_Z)(void* arg1);
	static void RenderProcessFront(void* arg1)
	{
		_RenderProcessFront_HrScreenStatus__KAXPAX_Z mFunc = (_RenderProcessFront_HrScreenStatus__KAXPAX_Z)(GameModule + 0x46a940);
		return mFunc(arg1);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::FrameProcess(class HrScreenStatus* const this) [?FrameProcess@HrScreenStatus@@MAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrScreenStatus__MAEXXZ)(class HrScreenStatus* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrScreenStatus__MAEXXZ mFunc = (_FrameProcess_HrScreenStatus__MAEXXZ)(GameModule + 0x46aab0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::dLeavingExceptBattery(class HrScreenStatus* const this, uint8_t arg2) [?dLeavingExceptBattery@HrScreenStatus@@QAEX_N@Z]
	typedef void(__thiscall* _dLeavingExceptBattery_HrScreenStatus__QAEX_N_Z)(class HrScreenStatus* const thisPtr, uint8_t arg2);
	void dLeavingExceptBattery(uint8_t arg2)
	{
		_dLeavingExceptBattery_HrScreenStatus__QAEX_N_Z mFunc = (_dLeavingExceptBattery_HrScreenStatus__QAEX_N_Z)(GameModule + 0x46ba60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::Terminate(class HrScreenStatus* const this) [?Terminate@HrScreenStatus@@MAEXXZ]
	typedef void(__thiscall* _Terminate_HrScreenStatus__MAEXXZ)(class HrScreenStatus* const thisPtr);
	void Terminate()
	{
		_Terminate_HrScreenStatus__MAEXXZ mFunc = (_Terminate_HrScreenStatus__MAEXXZ)(GameModule + 0x46bcd0);
		return mFunc(this);
	}
	// [Function] class ghmResGroup* HrScreenStatus::GetLanguageGroup(class ghmResGroup* arg1) [?GetLanguageGroup@HrScreenStatus@@SAPAVghmResGroup@@PAV2@@Z]
	typedef class ghmResGroup*(__fastcall* _GetLanguageGroup_HrScreenStatus__SAPAVghmResGroup__PAV2__Z)(class ghmResGroup* arg1);
	static class ghmResGroup* GetLanguageGroup(class ghmResGroup* arg1)
	{
		_GetLanguageGroup_HrScreenStatus__SAPAVghmResGroup__PAV2__Z mFunc = (_GetLanguageGroup_HrScreenStatus__SAPAVghmResGroup__PAV2__Z)(GameModule + 0x46c3f0);
		return mFunc(arg1);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::BalloonIsAppear(class HrScreenStatus* const this, enum HrScreenStatusBalloon::OBJ_ID arg2) [?BalloonIsAppear@HrScreenStatus@@QAE_NW4OBJ_ID@HrScreenStatusBalloon@@@Z]
	typedef uint8_t(__thiscall* _BalloonIsAppear_HrScreenStatus__QAE_NW4OBJ_ID_HrScreenStatusBalloon___Z)(class HrScreenStatus* const thisPtr, enum HrScreenStatusBalloon::OBJ_ID arg2);
	uint8_t BalloonIsAppear(/* enum HrScreenStatusBalloon::OBJ_ID */ uint32_t arg2)
	{
		_BalloonIsAppear_HrScreenStatus__QAE_NW4OBJ_ID_HrScreenStatusBalloon___Z mFunc = (_BalloonIsAppear_HrScreenStatus__QAE_NW4OBJ_ID_HrScreenStatusBalloon___Z)(GameModule + 0x46c470);
		return mFunc(this, (enum HrScreenStatusBalloon::OBJ_ID)arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dAppearInGameMenu(class HrScreenStatus* const this) [?dAppearInGameMenu@HrScreenStatus@@QAE_NXZ]
	/// <summary>
	/// Called when the pause menu is spawned.
	/// </summary>
	typedef uint8_t(__thiscall* _dAppearInGameMenu_HrScreenStatus__QAE_NXZ)(class HrScreenStatus* const thisPtr);
	uint8_t dAppearInGameMenu()
	{
		_dAppearInGameMenu_HrScreenStatus__QAE_NXZ mFunc = (_dAppearInGameMenu_HrScreenStatus__QAE_NXZ)(GameModule + 0x46c490);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::DemoButtonAppear(class HrScreenStatus* const this, enum CHrHUDDemoButton::PICT_ID_DEMO_BUTTON arg2) [?DemoButtonAppear@HrScreenStatus@@QAEXW4PICT_ID_DEMO_BUTTON@CHrHUDDemoButton@@@Z]
	typedef void(__thiscall* _DemoButtonAppear_HrScreenStatus__QAEXW4PICT_ID_DEMO_BUTTON_CHrHUDDemoButton___Z)(class HrScreenStatus* const thisPtr, enum CHrHUDDemoButton::PICT_ID_DEMO_BUTTON arg2);
	void DemoButtonAppear(/* enum CHrHUDDemoButton::PICT_ID_DEMO_BUTTON */ uint32_t arg2)
	{
		_DemoButtonAppear_HrScreenStatus__QAEXW4PICT_ID_DEMO_BUTTON_CHrHUDDemoButton___Z mFunc = (_DemoButtonAppear_HrScreenStatus__QAEXW4PICT_ID_DEMO_BUTTON_CHrHUDDemoButton___Z)(GameModule + 0x46c520);
		return mFunc(this, (enum CHrHUDDemoButton::PICT_ID_DEMO_BUTTON)arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::DemoButtonLeave(class HrScreenStatus* const this) [?DemoButtonLeave@HrScreenStatus@@QAEXXZ]
	typedef void(__thiscall* _DemoButtonLeave_HrScreenStatus__QAEXXZ)(class HrScreenStatus* const thisPtr);
	void DemoButtonLeave()
	{
		_DemoButtonLeave_HrScreenStatus__QAEXXZ mFunc = (_DemoButtonLeave_HrScreenStatus__QAEXXZ)(GameModule + 0x46c5c0);
		return mFunc(this);
	}
	// [Function] class HrScreenStatus* HrScreenStatus::Create() [?Create@HrScreenStatus@@SAPAV1@XZ]
	typedef class HrScreenStatus*(__fastcall* _Create_HrScreenStatus__SAPAV1_XZ)();
	static class HrScreenStatus* Create()
	{
		_Create_HrScreenStatus__SAPAV1_XZ mFunc = (_Create_HrScreenStatus__SAPAV1_XZ)(GameModule + 0x46c5d0);
		return mFunc();
	}
	// [Function] void __convention("thiscall") HrScreenStatus::dSetType(class HrScreenStatus* const this, enum HrScreenStatus::STAT_DRAW_TYPE arg2) [?dSetType@HrScreenStatus@@QAEXW4STAT_DRAW_TYPE@1@@Z]
	typedef void(__thiscall* _dSetType_HrScreenStatus__QAEXW4STAT_DRAW_TYPE_1__Z)(class HrScreenStatus* const thisPtr, enum HrScreenStatus::STAT_DRAW_TYPE arg2);
	void dSetType(/* enum HrScreenStatus::STAT_DRAW_TYPE */ uint32_t arg2)
	{
		_dSetType_HrScreenStatus__QAEXW4STAT_DRAW_TYPE_1__Z mFunc = (_dSetType_HrScreenStatus__QAEXW4STAT_DRAW_TYPE_1__Z)(GameModule + 0x46c840);
		return mFunc(this, (enum HrScreenStatus::STAT_DRAW_TYPE)arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dCheckDrawAll(class HrScreenStatus* const this) [?dCheckDrawAll@HrScreenStatus@@QAE_NXZ]
	typedef uint8_t(__thiscall* _dCheckDrawAll_HrScreenStatus__QAE_NXZ)(class HrScreenStatus* const thisPtr);
	uint8_t dCheckDrawAll()
	{
		_dCheckDrawAll_HrScreenStatus__QAE_NXZ mFunc = (_dCheckDrawAll_HrScreenStatus__QAE_NXZ)(GameModule + 0x46c850);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dCheckDraw(class HrScreenStatus* const this, enum HrScreenStatus::D_STATVAL_TYPE arg2) [?dCheckDraw@HrScreenStatus@@QAE_NW4D_STATVAL_TYPE@1@@Z]
	typedef uint8_t(__thiscall* _dCheckDraw_HrScreenStatus__QAE_NW4D_STATVAL_TYPE_1__Z)(class HrScreenStatus* const thisPtr, enum HrScreenStatus::D_STATVAL_TYPE arg2);
	uint8_t dCheckDraw(/* enum HrScreenStatus::D_STATVAL_TYPE */ uint32_t arg2)
	{
		_dCheckDraw_HrScreenStatus__QAE_NW4D_STATVAL_TYPE_1__Z mFunc = (_dCheckDraw_HrScreenStatus__QAE_NW4D_STATVAL_TYPE_1__Z)(GameModule + 0x46c8b0);
		return mFunc(this, (enum HrScreenStatus::D_STATVAL_TYPE)arg2);
	}
	// [Function] int32_t __convention("thiscall") HrScreenStatus::dGetMissionResultType(class HrScreenStatus* const this) [?dGetMissionResultType@HrScreenStatus@@QAEHXZ]
	typedef int32_t(__thiscall* _dGetMissionResultType_HrScreenStatus__QAEHXZ)(class HrScreenStatus* const thisPtr);
	int32_t dGetMissionResultType()
	{
		_dGetMissionResultType_HrScreenStatus__QAEHXZ mFunc = (_dGetMissionResultType_HrScreenStatus__QAEHXZ)(GameModule + 0x46c9a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::dLeavingSelect(class HrScreenStatus* const this, enum HrScreenStatus::D_STATVAL_TYPE arg2, char arg3) [?dLeavingSelect@HrScreenStatus@@QAEXW4D_STATVAL_TYPE@1@C@Z]
	typedef void(__thiscall* _dLeavingSelect_HrScreenStatus__QAEXW4D_STATVAL_TYPE_1_C_Z)(class HrScreenStatus* const thisPtr, enum HrScreenStatus::D_STATVAL_TYPE arg2, char arg3);
	void dLeavingSelect(/* enum HrScreenStatus::D_STATVAL_TYPE */ uint32_t arg2, char arg3)
	{
		_dLeavingSelect_HrScreenStatus__QAEXW4D_STATVAL_TYPE_1_C_Z mFunc = (_dLeavingSelect_HrScreenStatus__QAEXW4D_STATVAL_TYPE_1_C_Z)(GameModule + 0x46c9d0);
		return mFunc(this, (enum HrScreenStatus::D_STATVAL_TYPE)arg2, arg3);
	}
	// [Function] float __convention("thiscall") HrScreenStatus::dGetHpScale(class HrScreenStatus* const this) [?dGetHpScale@HrScreenStatus@@QAEMXZ]
	typedef float(__thiscall* _dGetHpScale_HrScreenStatus__QAEMXZ)(class HrScreenStatus* const thisPtr);
	float dGetHpScale()
	{
		_dGetHpScale_HrScreenStatus__QAEMXZ mFunc = (_dGetHpScale_HrScreenStatus__QAEMXZ)(GameModule + 0x46cc70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::BattleSimplMessage(class HrScreenStatus* const this, enum BATTLE_SIMPLMESSEAGE_NUM MessNum, bool SkipIfExists) [?BattleSimplMessage@HrScreenStatus@@QAEXH_N@Z]
	/// <summary>
	/// Displays a small center pop-up. Seen in normal play when picking up items, or standing on interaction circles.
	/// </summary>
	typedef void(__thiscall* _BattleSimplMessage_HrScreenStatus__QAEXH_N_Z)(class HrScreenStatus* const thisPtr, enum BATTLE_SIMPLMESSEAGE_NUM MessNum, bool SkipIfExists);
	void BattleSimplMessage(/* enum BATTLE_SIMPLMESSEAGE_NUM */ uint32_t MessNum, bool SkipIfExists)
	{
		_BattleSimplMessage_HrScreenStatus__QAEXH_N_Z mFunc = (_BattleSimplMessage_HrScreenStatus__QAEXH_N_Z)(GameModule + 0x46cc80);
		return mFunc(this, (enum BATTLE_SIMPLMESSEAGE_NUM)MessNum, SkipIfExists);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::BalloonLeaveAll(class HrScreenStatus* const this, uint8_t arg2) [?BalloonLeaveAll@HrScreenStatus@@QAEX_N@Z]
	typedef void(__thiscall* _BalloonLeaveAll_HrScreenStatus__QAEX_N_Z)(class HrScreenStatus* const thisPtr, uint8_t arg2);
	void BalloonLeaveAll(uint8_t arg2)
	{
		_BalloonLeaveAll_HrScreenStatus__QAEX_N_Z mFunc = (_BalloonLeaveAll_HrScreenStatus__QAEX_N_Z)(GameModule + 0x46cd70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::BalloonAppear(class HrScreenStatus* const this, enum HrScreenStatusBalloon::OBJ_ID arg2, uint8_t arg3) [?BalloonAppear@HrScreenStatus@@QAEXW4OBJ_ID@HrScreenStatusBalloon@@_N@Z]
	/// <summary>
	/// Makes a bubble appear above Travis. Bubble is seen in normal play when swapping weapons.
	/// </summary>
	typedef void(__thiscall* _BalloonAppear_HrScreenStatus__QAEXW4OBJ_ID_HrScreenStatusBalloon___N_Z)(class HrScreenStatus* const thisPtr, enum HrScreenStatusBalloon::OBJ_ID arg2, uint8_t arg3);
	void BalloonAppear(/* enum HrScreenStatusBalloon::OBJ_ID */ uint32_t arg2, uint8_t arg3)
	{
		_BalloonAppear_HrScreenStatus__QAEXW4OBJ_ID_HrScreenStatusBalloon___N_Z mFunc = (_BalloonAppear_HrScreenStatus__QAEXW4OBJ_ID_HrScreenStatusBalloon___N_Z)(GameModule + 0x46cd80);
		return mFunc(this, (enum HrScreenStatusBalloon::OBJ_ID)arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::BalloonLeave(class HrScreenStatus* const this, enum HrScreenStatusBalloon::OBJ_ID arg2, uint8_t arg3) [?BalloonLeave@HrScreenStatus@@QAEXW4OBJ_ID@HrScreenStatusBalloon@@_N@Z]
	typedef void(__thiscall* _BalloonLeave_HrScreenStatus__QAEXW4OBJ_ID_HrScreenStatusBalloon___N_Z)(class HrScreenStatus* const thisPtr, enum HrScreenStatusBalloon::OBJ_ID arg2, uint8_t arg3);
	void BalloonLeave(/* enum HrScreenStatusBalloon::OBJ_ID */ uint32_t arg2, uint8_t arg3)
	{
		_BalloonLeave_HrScreenStatus__QAEXW4OBJ_ID_HrScreenStatusBalloon___N_Z mFunc = (_BalloonLeave_HrScreenStatus__QAEXW4OBJ_ID_HrScreenStatusBalloon___N_Z)(GameModule + 0x46cd90);
		return mFunc(this, (enum HrScreenStatusBalloon::OBJ_ID)arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dAppearMissionResult(class HrScreenStatus* const this, uint32_t arg2, int16_t arg3, int16_t arg4, int32_t arg5, char arg6, enum HrMissionResult::D_RESULT_TYPE arg7, int16_t arg8, int16_t arg9) [?dAppearMissionResult@HrScreenStatus@@QAE_NIFFHCW4D_RESULT_TYPE@HrMissionResult@@FF@Z]
	typedef uint8_t(__thiscall* _dAppearMissionResult_HrScreenStatus__QAE_NIFFHCW4D_RESULT_TYPE_HrMissionResult__FF_Z)(class HrScreenStatus* const thisPtr, uint32_t arg2, int16_t arg3, int16_t arg4, int32_t arg5, char arg6, enum HrMissionResult::D_RESULT_TYPE arg7, int16_t arg8, int16_t arg9);
	uint8_t dAppearMissionResult(uint32_t arg2, int16_t arg3, int16_t arg4, int32_t arg5, char arg6, /* enum HrMissionResult::D_RESULT_TYPE */ uint32_t arg7, int16_t arg8, int16_t arg9)
	{
		_dAppearMissionResult_HrScreenStatus__QAE_NIFFHCW4D_RESULT_TYPE_HrMissionResult__FF_Z mFunc = (_dAppearMissionResult_HrScreenStatus__QAE_NIFFHCW4D_RESULT_TYPE_HrMissionResult__FF_Z)(GameModule + 0x46cf00);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, (enum HrMissionResult::D_RESULT_TYPE)arg7, arg8, arg9);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dLeavingMissionResult(class HrScreenStatus* const this) [?dLeavingMissionResult@HrScreenStatus@@QAE_NXZ]
	typedef uint8_t(__thiscall* _dLeavingMissionResult_HrScreenStatus__QAE_NXZ)(class HrScreenStatus* const thisPtr);
	uint8_t dLeavingMissionResult()
	{
		_dLeavingMissionResult_HrScreenStatus__QAE_NXZ mFunc = (_dLeavingMissionResult_HrScreenStatus__QAE_NXZ)(GameModule + 0x46d080);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dSetMissionResultCameraPos(class HrScreenStatus* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4) [?dSetMissionResultCameraPos@HrScreenStatus@@QAE_NHAAUVec@@0@Z]
	typedef uint8_t(__thiscall* _dSetMissionResultCameraPos_HrScreenStatus__QAE_NHAAUVec__0_Z)(class HrScreenStatus* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4);
	uint8_t dSetMissionResultCameraPos(int32_t arg2, struct Vec& arg3, struct Vec& arg4)
	{
		_dSetMissionResultCameraPos_HrScreenStatus__QAE_NHAAUVec__0_Z mFunc = (_dSetMissionResultCameraPos_HrScreenStatus__QAE_NHAAUVec__0_Z)(GameModule + 0x46d0c0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dReStartMissionResult(class HrScreenStatus* const this) [?dReStartMissionResult@HrScreenStatus@@QAE_NXZ]
	typedef uint8_t(__thiscall* _dReStartMissionResult_HrScreenStatus__QAE_NXZ)(class HrScreenStatus* const thisPtr);
	uint8_t dReStartMissionResult()
	{
		_dReStartMissionResult_HrScreenStatus__QAE_NXZ mFunc = (_dReStartMissionResult_HrScreenStatus__QAE_NXZ)(GameModule + 0x46d130);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::BattleSimplMessClear(class HrScreenStatus* const this) [?BattleSimplMessClear@HrScreenStatus@@QAEXXZ]
	typedef void(__thiscall* _BattleSimplMessClear_HrScreenStatus__QAEXXZ)(class HrScreenStatus* const thisPtr);
	void BattleSimplMessClear()
	{
		_BattleSimplMessClear_HrScreenStatus__QAEXXZ mFunc = (_BattleSimplMessClear_HrScreenStatus__QAEXXZ)(GameModule + 0x46d150);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::mSetBusFight(class HrScreenStatus* const this, uint8_t arg2) [?mSetBusFight@HrScreenStatus@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBusFight_HrScreenStatus__QAEX_N_Z)(class HrScreenStatus* const thisPtr, uint8_t arg2);
	void mSetBusFight(uint8_t arg2)
	{
		_mSetBusFight_HrScreenStatus__QAEX_N_Z mFunc = (_mSetBusFight_HrScreenStatus__QAEX_N_Z)(GameModule + 0x46d190);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::dAppear(class HrScreenStatus* const this) [?dAppear@HrScreenStatus@@QAEXXZ]
	typedef void(__thiscall* _dAppear_HrScreenStatus__QAEXXZ)(class HrScreenStatus* const thisPtr);
	void dAppear()
	{
		_dAppear_HrScreenStatus__QAEXXZ mFunc = (_dAppear_HrScreenStatus__QAEXXZ)(GameModule + 0x46d1a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::dLeaving(class HrScreenStatus* const this, uint8_t arg2, enum HrScreenStatus::D_STATVAL_TYPE arg3) [?dLeaving@HrScreenStatus@@QAEX_NW4D_STATVAL_TYPE@1@@Z]
	typedef void(__thiscall* _dLeaving_HrScreenStatus__QAEX_NW4D_STATVAL_TYPE_1__Z)(class HrScreenStatus* const thisPtr, uint8_t arg2, enum HrScreenStatus::D_STATVAL_TYPE arg3);
	void dLeaving(uint8_t arg2, /* enum HrScreenStatus::D_STATVAL_TYPE */ uint32_t arg3)
	{
		_dLeaving_HrScreenStatus__QAEX_NW4D_STATVAL_TYPE_1__Z mFunc = (_dLeaving_HrScreenStatus__QAEX_NW4D_STATVAL_TYPE_1__Z)(GameModule + 0x46d3b0);
		return mFunc(this, arg2, (enum HrScreenStatus::D_STATVAL_TYPE)arg3);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::dAppearLog(class HrScreenStatus* const this, int32_t arg2, enum HrScreenStatus::E_LOG_DOID arg3) [?dAppearLog@HrScreenStatus@@QAE_NHW4E_LOG_DOID@1@@Z]
	typedef uint8_t(__thiscall* _dAppearLog_HrScreenStatus__QAE_NHW4E_LOG_DOID_1__Z)(class HrScreenStatus* const thisPtr, int32_t arg2, enum HrScreenStatus::E_LOG_DOID arg3);
	uint8_t dAppearLog(int32_t arg2, /* enum HrScreenStatus::E_LOG_DOID */ uint32_t arg3)
	{
		_dAppearLog_HrScreenStatus__QAE_NHW4E_LOG_DOID_1__Z mFunc = (_dAppearLog_HrScreenStatus__QAE_NHW4E_LOG_DOID_1__Z)(GameModule + 0x46d610);
		return mFunc(this, arg2, (enum HrScreenStatus::E_LOG_DOID)arg3);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::BalloonTerminateStage(class HrScreenStatus* const this) [?BalloonTerminateStage@HrScreenStatus@@QAEXXZ]
	typedef void(__thiscall* _BalloonTerminateStage_HrScreenStatus__QAEXXZ)(class HrScreenStatus* const thisPtr);
	void BalloonTerminateStage()
	{
		_BalloonTerminateStage_HrScreenStatus__QAEXXZ mFunc = (_BalloonTerminateStage_HrScreenStatus__QAEXXZ)(GameModule + 0x46d770);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::dAppearSelect(class HrScreenStatus* const this, enum HrScreenStatus::D_STATVAL_TYPE arg2, uint8_t arg3, enum HrScreenStatus::D_CHECKPOINT_TYPE arg4) [?dAppearSelect@HrScreenStatus@@QAEXW4D_STATVAL_TYPE@1@_NW4D_CHECKPOINT_TYPE@1@@Z]
	typedef void(__thiscall* _dAppearSelect_HrScreenStatus__QAEXW4D_STATVAL_TYPE_1__NW4D_CHECKPOINT_TYPE_1__Z)(class HrScreenStatus* const thisPtr, enum HrScreenStatus::D_STATVAL_TYPE arg2, uint8_t arg3, enum HrScreenStatus::D_CHECKPOINT_TYPE arg4);
	void dAppearSelect(/* enum HrScreenStatus::D_STATVAL_TYPE */ uint32_t arg2, uint8_t arg3, /* enum HrScreenStatus::D_CHECKPOINT_TYPE */ uint32_t arg4)
	{
		_dAppearSelect_HrScreenStatus__QAEXW4D_STATVAL_TYPE_1__NW4D_CHECKPOINT_TYPE_1__Z mFunc = (_dAppearSelect_HrScreenStatus__QAEXW4D_STATVAL_TYPE_1__NW4D_CHECKPOINT_TYPE_1__Z)(GameModule + 0x46d8e0);
		return mFunc(this, (enum HrScreenStatus::D_STATVAL_TYPE)arg2, arg3, (enum HrScreenStatus::D_CHECKPOINT_TYPE)arg4);
	}
	// [Function] void __convention("thiscall") HrScreenStatus::BalloonInitializeStage(class HrScreenStatus* const this, class ghmResGroup* arg2) [?BalloonInitializeStage@HrScreenStatus@@QAEXPAVghmResGroup@@@Z]
	typedef void(__thiscall* _BalloonInitializeStage_HrScreenStatus__QAEXPAVghmResGroup___Z)(class HrScreenStatus* const thisPtr, class ghmResGroup* arg2);
	void BalloonInitializeStage(class ghmResGroup* arg2)
	{
		_BalloonInitializeStage_HrScreenStatus__QAEXPAVghmResGroup___Z mFunc = (_BalloonInitializeStage_HrScreenStatus__QAEXPAVghmResGroup___Z)(GameModule + 0x46dbc0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrScreenStatus::IsInGameMenuDisp(class HrScreenStatus* const this) [?IsInGameMenuDisp@HrScreenStatus@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsInGameMenuDisp_HrScreenStatus__QAE_NXZ)(class HrScreenStatus* const thisPtr);
	uint8_t IsInGameMenuDisp()
	{
		_IsInGameMenuDisp_HrScreenStatus__QAE_NXZ mFunc = (_IsInGameMenuDisp_HrScreenStatus__QAE_NXZ)(GameModule + 0x46dc80);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") HrScreenStatus::dGetMissionResultStat(class HrScreenStatus* const this) [?dGetMissionResultStat@HrScreenStatus@@QAEHXZ]
	typedef int32_t(__thiscall* _dGetMissionResultStat_HrScreenStatus__QAEHXZ)(class HrScreenStatus* const thisPtr);
	int32_t dGetMissionResultStat()
	{
		_dGetMissionResultStat_HrScreenStatus__QAEHXZ mFunc = (_dGetMissionResultStat_HrScreenStatus__QAEHXZ)(GameModule + 0x46dc90);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") HrScreenStatus::dGetMissionResultMode(class HrScreenStatus* const this) [?dGetMissionResultMode@HrScreenStatus@@QAEHXZ]
	typedef int32_t(__thiscall* _dGetMissionResultMode_HrScreenStatus__QAEHXZ)(class HrScreenStatus* const thisPtr);
	int32_t dGetMissionResultMode()
	{
		_dGetMissionResultMode_HrScreenStatus__QAEHXZ mFunc = (_dGetMissionResultMode_HrScreenStatus__QAEHXZ)(GameModule + 0x46dcc0);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrScreenStatus [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrScreenStatus& InObject)
	{
		State = InObject.State;
		Map = InObject.Map;
		MapScaleType = InObject.MapScaleType;
		ScreenStatusBalloon = InObject.ScreenStatusBalloon;
		UnknownLanguageGroupResources = InObject.UnknownLanguageGroupResources;
		UnknownBalloonInitializeStageFlag = InObject.UnknownBalloonInitializeStageFlag;
		UnknownMissionTaskPointer = InObject.UnknownMissionTaskPointer;
		ScreenStatusSlot = InObject.ScreenStatusSlot;
		SimpleMessage = InObject.SimpleMessage;
		BattleSimpleMessagePtr = InObject.BattleSimpleMessagePtr;
		DrawFlag = InObject.DrawFlag;
		BusFight = InObject.BusFight;
		MiniMapVisible = InObject.MiniMapVisible;
		RevengeMissionAllEnmNum = InObject.RevengeMissionAllEnmNum;
		HealthFlag = InObject.HealthFlag;
		BatteryFlag = InObject.BatteryFlag;
		TensionHud = InObject.TensionHud;
		MoneyHud = InObject.MoneyHud;
		SpeedMeterFlag = InObject.SpeedMeterFlag;
		SettingBGMVolume = InObject.SettingBGMVolume;
		SettingSEVolume = InObject.SettingSEVolume;
		SettingMiniMap = InObject.SettingMiniMap;
		SettingPower = InObject.SettingPower;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrScreenStatus>("HrScreenStatus")
			.addFunction("__tostring", &HrScreenStatus::ToString)
			.addFunction("GetPtrAddr", &HrScreenStatus::GetPtrAddr)
			.addProperty("State", &HrScreenStatus::State)
			.addProperty("Map", &HrScreenStatus::Map)
			.addProperty("MapScaleType", &HrScreenStatus::MapScaleType)
			.addProperty("ScreenStatusBalloon", &HrScreenStatus::ScreenStatusBalloon)
			.addProperty("UnknownLanguageGroupResources", &HrScreenStatus::UnknownLanguageGroupResources)
			.addProperty("UnknownBalloonInitializeStageFlag", &HrScreenStatus::UnknownBalloonInitializeStageFlag)
			.addProperty("UnknownMissionTaskPointer", &HrScreenStatus::UnknownMissionTaskPointer)
			.addProperty("ScreenStatusSlot", &HrScreenStatus::ScreenStatusSlot)
			.addProperty("SimpleMessage", &HrScreenStatus::SimpleMessage)
			.addProperty("BattleSimpleMessagePtr", &HrScreenStatus::BattleSimpleMessagePtr)
			.addProperty("DrawFlag", &HrScreenStatus::DrawFlag)
			.addProperty("BusFight", &HrScreenStatus::BusFight)
			.addProperty("MiniMapVisible", &HrScreenStatus::MiniMapVisible)
			.addProperty("RevengeMissionAllEnmNum", &HrScreenStatus::RevengeMissionAllEnmNum)
			.addProperty("HealthFlag", &HrScreenStatus::HealthFlag)
			.addProperty("BatteryFlag", &HrScreenStatus::BatteryFlag)
			.addProperty("TensionHud", &HrScreenStatus::TensionHud)
			.addProperty("MoneyHud", &HrScreenStatus::MoneyHud)
			.addProperty("SpeedMeterFlag", &HrScreenStatus::SpeedMeterFlag)
			.addProperty("SettingBGMVolume", &HrScreenStatus::SettingBGMVolume)
			.addProperty("SettingSEVolume", &HrScreenStatus::SettingSEVolume)
			.addProperty("SettingMiniMap", &HrScreenStatus::SettingMiniMap)
			.addProperty("SettingPower", &HrScreenStatus::SettingPower)
			.addFunction("GetMap", &HrScreenStatus::GetMap)
			.addFunction("SetStatusBatterySE_Flag", &HrScreenStatus::SetStatusBatterySE_Flag)
			.addFunction("SetStatusMAXBatterySEStopFlag", &HrScreenStatus::SetStatusMAXBatterySEStopFlag)
			.addFunction("SetRevengeMissionAllEnmNum", &HrScreenStatus::SetRevengeMissionAllEnmNum)
			.addFunction("GetSlot", &HrScreenStatus::GetSlot)
			.addFunction("SetStatusProcess", &HrScreenStatus::SetStatusProcess)
			.addFunction("GetRevengeMissionAllEnmNum", &HrScreenStatus::GetRevengeMissionAllEnmNum)
			.addFunction("SetSettingBGMVolume", &HrScreenStatus::SetSettingBGMVolume)
			.addFunction("SetSettingSEVolume", &HrScreenStatus::SetSettingSEVolume)
			.addFunction("SetSettingMiniMap", &HrScreenStatus::SetSettingMiniMap)
			.addFunction("SetSettingPower", &HrScreenStatus::SetSettingPower)
			.addFunction("GetStatusBatteryParam", &HrScreenStatus::GetStatusBatteryParam)
			.addFunction("SetStatusDataLoadFlag", &HrScreenStatus::SetStatusDataLoadFlag)
			.addFunction("GetStatusBatterySE_Flag", &HrScreenStatus::GetStatusBatterySE_Flag)
			.addFunction("GetSettingBGMVolume", &HrScreenStatus::GetSettingBGMVolume)
			.addFunction("GetScrollBarTexture", &HrScreenStatus::GetScrollBarTexture)
			.addFunction("GetMapFrameTex", &HrScreenStatus::GetMapFrameTex)
			.addFunction("GetSettingPower", &HrScreenStatus::GetSettingPower)
			.addStaticFunction("TestCreate", &HrScreenStatus::TestCreate)
			.addStaticFunction("CheckUnionTerminate", &HrScreenStatus::CheckUnionTerminate)
			.addStaticFunction("UnionTerminate", &HrScreenStatus::UnionTerminate)
			.addStaticFunction("CheckUnionInitialize", &HrScreenStatus::CheckUnionInitialize)
			.addStaticFunction("UnionInitialize", &HrScreenStatus::UnionInitialize)
			.addFunction("dValUp", &HrScreenStatus::dValUp)
			.addFunction("dSetMissionResultSceneTime", &HrScreenStatus::dSetMissionResultSceneTime)
			.addFunction("BalloonCheckDraw", &HrScreenStatus::BalloonCheckDraw)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("dLog_ScissoringBoxAnimationProc", &HrScreenStatus::dLog_ScissoringBoxAnimationProc)
			.addFunction("RenderProcess", &HrScreenStatus::RenderProcess)
			.addFunction("DispCheckPointMessage", &HrScreenStatus::DispCheckPointMessage)
			.addFunction("IsDrawKillCount", &HrScreenStatus::IsDrawKillCount)
			.addFunction("DrawSubMissionInfo", &HrScreenStatus::DrawSubMissionInfo)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("RenderProcessFront", &HrScreenStatus::RenderProcessFront)
			.addFunction("FrameProcess", &HrScreenStatus::FrameProcess)
			.addFunction("dLeavingExceptBattery", &HrScreenStatus::dLeavingExceptBattery)
			.addFunction("Terminate", &HrScreenStatus::Terminate)
			.addStaticFunction("GetLanguageGroup", &HrScreenStatus::GetLanguageGroup)
			.addFunction("BalloonIsAppear", &HrScreenStatus::BalloonIsAppear)
			.addFunction("dAppearInGameMenu", &HrScreenStatus::dAppearInGameMenu)
			.addFunction("DemoButtonAppear", &HrScreenStatus::DemoButtonAppear)
			.addFunction("DemoButtonLeave", &HrScreenStatus::DemoButtonLeave)
			.addStaticFunction("Create", &HrScreenStatus::Create)
			.addFunction("dSetType", &HrScreenStatus::dSetType)
			.addFunction("dCheckDrawAll", &HrScreenStatus::dCheckDrawAll)
			.addFunction("dCheckDraw", &HrScreenStatus::dCheckDraw)
			.addFunction("dGetMissionResultType", &HrScreenStatus::dGetMissionResultType)
			.addFunction("dLeavingSelect", &HrScreenStatus::dLeavingSelect)
			.addFunction("dGetHpScale", &HrScreenStatus::dGetHpScale)
			.addFunction("BattleSimplMessage", &HrScreenStatus::BattleSimplMessage)
			.addFunction("BalloonLeaveAll", &HrScreenStatus::BalloonLeaveAll)
			.addFunction("BalloonAppear", &HrScreenStatus::BalloonAppear)
			.addFunction("BalloonLeave", &HrScreenStatus::BalloonLeave)
			.addFunction("dAppearMissionResult", &HrScreenStatus::dAppearMissionResult)
			.addFunction("dLeavingMissionResult", &HrScreenStatus::dLeavingMissionResult)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("dSetMissionResultCameraPos", &HrScreenStatus::dSetMissionResultCameraPos)
			.addFunction("dReStartMissionResult", &HrScreenStatus::dReStartMissionResult)
			.addFunction("BattleSimplMessClear", &HrScreenStatus::BattleSimplMessClear)
			.addFunction("mSetBusFight", &HrScreenStatus::mSetBusFight)
			.addFunction("dAppear", &HrScreenStatus::dAppear)
			.addFunction("dLeaving", &HrScreenStatus::dLeaving)
			.addFunction("dAppearLog", &HrScreenStatus::dAppearLog)
			.addFunction("BalloonTerminateStage", &HrScreenStatus::BalloonTerminateStage)
			.addFunction("dAppearSelect", &HrScreenStatus::dAppearSelect)
			.addFunction("BalloonInitializeStage", &HrScreenStatus::BalloonInitializeStage)
			.addFunction("IsInGameMenuDisp", &HrScreenStatus::IsInGameMenuDisp)
			.addFunction("dGetMissionResultStat", &HrScreenStatus::dGetMissionResultStat)
			.addFunction("dGetMissionResultMode", &HrScreenStatus::dGetMissionResultMode)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrScreenStatus::State) == 4, "expected HrScreenStatus::State to be size 4");
static_assert(sizeof(HrScreenStatus::Map) == 4, "expected HrScreenStatus::Map to be size 4");
static_assert(sizeof(HrScreenStatus::MapScaleType) == 4, "expected HrScreenStatus::MapScaleType to be size 4");
static_assert(sizeof(HrScreenStatus::ScreenStatusBalloon) == 4, "expected HrScreenStatus::ScreenStatusBalloon to be size 4");
static_assert(sizeof(HrScreenStatus::UnknownLanguageGroupResources) == 4, "expected HrScreenStatus::UnknownLanguageGroupResources to be size 4");
static_assert(sizeof(HrScreenStatus::UnknownBalloonInitializeStageFlag) == 1, "expected HrScreenStatus::UnknownBalloonInitializeStageFlag to be size 1");
static_assert(sizeof(HrScreenStatus::UnknownMissionTaskPointer) == 4, "expected HrScreenStatus::UnknownMissionTaskPointer to be size 4");
static_assert(sizeof(HrScreenStatus::ScreenStatusSlot) == 4, "expected HrScreenStatus::ScreenStatusSlot to be size 4");
static_assert(sizeof(HrScreenStatus::SimpleMessage) == 4, "expected HrScreenStatus::SimpleMessage to be size 4");
static_assert(sizeof(HrScreenStatus::BattleSimpleMessagePtr) == 4, "expected HrScreenStatus::BattleSimpleMessagePtr to be size 4");
static_assert(sizeof(HrScreenStatus::DrawFlag) == 2, "expected HrScreenStatus::DrawFlag to be size 2");
static_assert(sizeof(HrScreenStatus::BusFight) == 1, "expected HrScreenStatus::BusFight to be size 1");
static_assert(sizeof(HrScreenStatus::MiniMapVisible) == 1, "expected HrScreenStatus::MiniMapVisible to be size 1");
static_assert(sizeof(HrScreenStatus::RevengeMissionAllEnmNum) == 4, "expected HrScreenStatus::RevengeMissionAllEnmNum to be size 4");
static_assert(sizeof(HrScreenStatus::HealthFlag) == 1, "expected HrScreenStatus::HealthFlag to be size 1");
static_assert(sizeof(HrScreenStatus::BatteryFlag) == 1, "expected HrScreenStatus::BatteryFlag to be size 1");
static_assert(sizeof(HrScreenStatus::TensionHud) == 432, "expected HrScreenStatus::TensionHud to be size 432");
static_assert(sizeof(HrScreenStatus::MoneyHud) == 668, "expected HrScreenStatus::MoneyHud to be size 668");
static_assert(sizeof(HrScreenStatus::SpeedMeterFlag) == 1, "expected HrScreenStatus::SpeedMeterFlag to be size 1");
static_assert(sizeof(HrScreenStatus::SettingBGMVolume) == 4, "expected HrScreenStatus::SettingBGMVolume to be size 4");
static_assert(sizeof(HrScreenStatus::SettingSEVolume) == 4, "expected HrScreenStatus::SettingSEVolume to be size 4");
static_assert(sizeof(HrScreenStatus::SettingMiniMap) == 1, "expected HrScreenStatus::SettingMiniMap to be size 1");
static_assert(sizeof(HrScreenStatus::SettingPower) == 4, "expected HrScreenStatus::SettingPower to be size 4");
static_assert(sizeof(HrScreenStatus) == 0x3870, "expected HrScreenStatus to be size 0x3870");

// [Structure] class HrTask
class HrTask
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[8];

public:
	// <uint32_t MagicNumber, offset 0x8>
	uint32_t MagicNumber = 0;

	// <Unidentified data segment, offset 0xc>
private:
	char _UnidentifiedData_12[68];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrTask [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrTask& InObject)
	{
		MagicNumber = InObject.MagicNumber;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrTask>("HrTask")
			.addFunction("__tostring", &HrTask::ToString)
			.addFunction("GetPtrAddr", &HrTask::GetPtrAddr)
			.addProperty("MagicNumber", &HrTask::MagicNumber)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrTask::MagicNumber) == 4, "expected HrTask::MagicNumber to be size 4");
static_assert(sizeof(HrTask) == 0x50, "expected HrTask to be size 0x50");

// [Structure] class EE::SmartPtr<ID3D11DepthStencilView>
namespace EE
{
	template<typename T>
	class SmartPtr
	{
	public:
		/// Struct member variables

		// <struct ID3D11DepthStencilView* m_pObject, offset 0x0>
		T* m_pObject = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class EE::SmartPtr [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EE::SmartPtr<ID3D11DepthStencilView>& InObject)
		{
			m_pObject = InObject.m_pObject;
		}
		// Exporting templated types to Lua currently not supported.
		// static void BindLua(luabridge::Namespace& NS)
	};
}
static_assert(sizeof(EE::SmartPtr<ID3D11DepthStencilView>::m_pObject) == 4, "expected EE::SmartPtr<ID3D11DepthStencilView>::m_pObject to be size 4");
static_assert(sizeof(EE::SmartPtr<ID3D11DepthStencilView>) == 0x4, "expected EE::SmartPtr<ID3D11DepthStencilView> to be size 0x4");

// [Structure] union GXSamplerStuff
union GXSamplerStuff
{
public:
	/// Struct member variables

	// <uint32_t wrapS, offset 0x0>
	uint32_t wrapS = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "union GXSamplerStuff [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GXSamplerStuff& InObject)
	{
		wrapS = InObject.wrapS;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXSamplerStuff>("GXSamplerStuff")
			.addFunction("__tostring", &GXSamplerStuff::ToString)
			.addFunction("GetPtrAddr", &GXSamplerStuff::GetPtrAddr)
			.addProperty("wrapS", &GXSamplerStuff::wrapS)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXSamplerStuff::wrapS) == 4, "expected GXSamplerStuff::wrapS to be size 4");
static_assert(sizeof(GXSamplerStuff) == 0x4, "expected GXSamplerStuff to be size 0x4");

// [Structure] class EE::RefObject
namespace EE
{
	class RefObject
	{
	public:
		/// Struct member variables

		// <void* (* field_0)[0x1], offset 0x0>
		void* (* field_0)[0x1];

		// <int32_t volatile refCount, offset 0x4>
		int32_t volatile refCount;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class EE::RefObject [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EE::RefObject& InObject)
		{
			refCount = InObject.refCount;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<RefObject>("EE_RefObject")
				.addFunction("__tostring", &EE::RefObject::ToString)
				.addFunction("GetPtrAddr", &EE::RefObject::GetPtrAddr)
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &EE::RefObject::field_0)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("refCount", &EE::RefObject::refCount)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(EE::RefObject::field_0) == 4, "expected EE::RefObject::field_0 to be size 4");
static_assert(sizeof(EE::RefObject::refCount) == 4, "expected EE::RefObject::refCount to be size 4");
static_assert(sizeof(EE::RefObject) == 0x8, "expected EE::RefObject to be size 0x8");

// [Structure] class GXTexture
class GXTexture : public EE::RefObject
{
public:
	// [Structure] struct GXTexture::GXSpecs
	struct GXSpecs
	{
	public:
		/// Struct member variables

		// <uint16_t width, offset 0x0>
		uint16_t width = 0;

		// <uint16_t height, offset 0x2>
		uint16_t height = 0;

		// <uint16_t rtWidth, offset 0x4>
		uint16_t rtWidth = 0;

		// <uint16_t rtHeight, offset 0x6>
		uint16_t rtHeight = 0;

		// <enum _GXTexFmt format, offset 0x8>
		enum _GXTexFmt format;

		// <uint8_t mipmap, offset 0xc>
		uint8_t mipmap = 0;

		// <uint8_t bias_clamp, offset 0xd>
		uint8_t bias_clamp = 0;

		// <uint8_t do_edge_lod, offset 0xe>
		uint8_t do_edge_lod = 0;

		// <Unidentified data segment, offset 0xf>
	private:
		char _UnidentifiedData_15[1];

	public:
		// <uint32_t hash, offset 0x10>
		uint32_t hash = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct GXTexture::GXSpecs [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(GXTexture::GXSpecs& InObject)
		{
			width = InObject.width;
			height = InObject.height;
			rtWidth = InObject.rtWidth;
			rtHeight = InObject.rtHeight;
			format = InObject.format;
			mipmap = InObject.mipmap;
			bias_clamp = InObject.bias_clamp;
			do_edge_lod = InObject.do_edge_lod;
			hash = InObject.hash;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<GXSpecs>("GXTexture_GXSpecs")
				.addFunction("__tostring", &GXTexture::GXSpecs::ToString)
				.addFunction("GetPtrAddr", &GXTexture::GXSpecs::GetPtrAddr)
				.addProperty("width", &GXTexture::GXSpecs::width)
				.addProperty("height", &GXTexture::GXSpecs::height)
				.addProperty("rtWidth", &GXTexture::GXSpecs::rtWidth)
				.addProperty("rtHeight", &GXTexture::GXSpecs::rtHeight)
				.addProperty("format", &GXTexture::GXSpecs::format)
				.addProperty("mipmap", &GXTexture::GXSpecs::mipmap)
				.addProperty("bias_clamp", &GXTexture::GXSpecs::bias_clamp)
				.addProperty("do_edge_lod", &GXTexture::GXSpecs::do_edge_lod)
				.addProperty("hash", &GXTexture::GXSpecs::hash)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(GXTexture::GXSpecs::width) == 2, "expected GXTexture::GXSpecs::width to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::height) == 2, "expected GXTexture::GXSpecs::height to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::rtWidth) == 2, "expected GXTexture::GXSpecs::rtWidth to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::rtHeight) == 2, "expected GXTexture::GXSpecs::rtHeight to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::format) == 4, "expected GXTexture::GXSpecs::format to be size 4");
	static_assert(sizeof(GXTexture::GXSpecs::mipmap) == 1, "expected GXTexture::GXSpecs::mipmap to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::bias_clamp) == 1, "expected GXTexture::GXSpecs::bias_clamp to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::do_edge_lod) == 1, "expected GXTexture::GXSpecs::do_edge_lod to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::hash) == 4, "expected GXTexture::GXSpecs::hash to be size 4");
	static_assert(sizeof(GXTexture::GXSpecs) == 0x14, "expected GXTexture::GXSpecs to be size 0x14");

	/// Struct member variables

	// <class EE::RefObject field_0, offset 0x0>
	// class EE::RefObject Super;

	// <uint32_t marker, offset 0x8>
	uint32_t marker = 0;

	// <union GXSamplerStuff sampler, offset 0xc>
	union GXSamplerStuff sampler;

	// <class EE::SmartPtr<ID3D11ShaderResourceView> textureView, offset 0x10>
	class EE::SmartPtr<ID3D11ShaderResourceView> textureView;

	// <uint32_t textureViewId, offset 0x14>
	uint32_t textureViewId = 0;

	// <struct GXTexture::GXSpecs gxSpecs, offset 0x18>
	struct GXTexture::GXSpecs gxSpecs;

	// <class EE::SmartPtr<ID3D11Texture2D> texture, offset 0x2c>
	class EE::SmartPtr<ID3D11Texture2D> texture;

	// <class EE::SmartPtr<ID3D11RenderTargetView> renderTargetView, offset 0x30>
	class EE::SmartPtr<ID3D11RenderTargetView> renderTargetView;

	// <class EE::SmartPtr<ID3D11DepthStencilView> depthStencilView, offset 0x34>
	class EE::SmartPtr<ID3D11DepthStencilView> depthStencilView;

	// <class EE::SmartPtr<ID3D11Texture2D> stagingTex, offset 0x38>
	class EE::SmartPtr<ID3D11Texture2D> stagingTex;

	// <struct D3D11_MAPPED_SUBRESOURCE stagingTexMap, offset 0x3c>
	struct D3D11_MAPPED_SUBRESOURCE stagingTexMap;

	// <struct EE::OptListNode<GXTexture *> renderTargetListNode, offset 0x48>
	struct EE::OptListNode<GXTexture *> renderTargetListNode;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GXTexture [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GXTexture& InObject)
	{
		marker = InObject.marker;
		sampler = InObject.sampler;
		textureView = InObject.textureView;
		textureViewId = InObject.textureViewId;
		gxSpecs = InObject.gxSpecs;
		texture = InObject.texture;
		renderTargetView = InObject.renderTargetView;
		depthStencilView = InObject.depthStencilView;
		stagingTex = InObject.stagingTex;
		stagingTexMap = InObject.stagingTexMap;
		renderTargetListNode = InObject.renderTargetListNode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<GXTexture, EE::RefObject>("GXTexture")
			.addFunction("__tostring", &GXTexture::ToString)
			.addFunction("GetPtrAddr", &GXTexture::GetPtrAddr)
			.addProperty("marker", &GXTexture::marker)
			.addProperty("sampler", &GXTexture::sampler)
			.addProperty("textureView", &GXTexture::textureView)
			.addProperty("textureViewId", &GXTexture::textureViewId)
			.addProperty("gxSpecs", &GXTexture::gxSpecs)
			.addProperty("texture", &GXTexture::texture)
			.addProperty("renderTargetView", &GXTexture::renderTargetView)
			.addProperty("depthStencilView", &GXTexture::depthStencilView)
			.addProperty("stagingTex", &GXTexture::stagingTex)
			.addProperty("stagingTexMap", &GXTexture::stagingTexMap)
			.addProperty("renderTargetListNode", &GXTexture::renderTargetListNode)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXTexture::marker) == 4, "expected GXTexture::marker to be size 4");
static_assert(sizeof(GXTexture::sampler) == 4, "expected GXTexture::sampler to be size 4");
static_assert(sizeof(GXTexture::textureView) == 4, "expected GXTexture::textureView to be size 4");
static_assert(sizeof(GXTexture::textureViewId) == 4, "expected GXTexture::textureViewId to be size 4");
static_assert(sizeof(GXTexture::gxSpecs) == 20, "expected GXTexture::gxSpecs to be size 20");
static_assert(sizeof(GXTexture::texture) == 4, "expected GXTexture::texture to be size 4");
static_assert(sizeof(GXTexture::renderTargetView) == 4, "expected GXTexture::renderTargetView to be size 4");
static_assert(sizeof(GXTexture::depthStencilView) == 4, "expected GXTexture::depthStencilView to be size 4");
static_assert(sizeof(GXTexture::stagingTex) == 4, "expected GXTexture::stagingTex to be size 4");
static_assert(sizeof(GXTexture::stagingTexMap) == 12, "expected GXTexture::stagingTexMap to be size 12");
static_assert(sizeof(GXTexture::renderTargetListNode) == 12, "expected GXTexture::renderTargetListNode to be size 12");
static_assert(sizeof(GXTexture) == 0x54, "expected GXTexture to be size 0x54");

// [Structure] class GtSimplMes
class GtSimplMes
{
public:
	/// Struct member variables

	// <class ghmGcFile* mpMSFile, offset 0x0>
	class ghmGcFile* mpMSFile = nullptr;

	// <void* mpMesRes, offset 0x4>
	void* mpMesRes = nullptr;

	// <uint32_t mHandol, offset 0x8>
	uint32_t mHandol = 0;

	// <int32_t mInitScane, offset 0xc>
	int32_t mInitScane = 0;

	// <uint8_t mInitFlg, offset 0x10>
	uint8_t mInitFlg = 0;

	// <Unidentified data segment, offset 0x11>
private:
	char _UnidentifiedData_17[3];

public:
	// <struct BATTLESIMPLMESS_SET* mpMessTop, offset 0x14>
	struct BATTLESIMPLMESS_SET* mpMessTop = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GtSimplMes [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GtSimplMes& InObject)
	{
		mpMSFile = InObject.mpMSFile;
		mpMesRes = InObject.mpMesRes;
		mHandol = InObject.mHandol;
		mInitScane = InObject.mInitScane;
		mInitFlg = InObject.mInitFlg;
		mpMessTop = InObject.mpMessTop;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GtSimplMes>("GtSimplMes")
			.addFunction("__tostring", &GtSimplMes::ToString)
			.addFunction("GetPtrAddr", &GtSimplMes::GetPtrAddr)
			.addProperty("mpMSFile", &GtSimplMes::mpMSFile)
			// void type not supported in LuaBridge
			//.addProperty("mpMesRes", &GtSimplMes::mpMesRes)
			.addProperty("mHandol", &GtSimplMes::mHandol)
			.addProperty("mInitScane", &GtSimplMes::mInitScane)
			.addProperty("mInitFlg", &GtSimplMes::mInitFlg)
			.addProperty("mpMessTop", &GtSimplMes::mpMessTop)
		.endClass();
	}
#endif
};
static_assert(sizeof(GtSimplMes::mpMSFile) == 4, "expected GtSimplMes::mpMSFile to be size 4");
static_assert(sizeof(GtSimplMes::mpMesRes) == 4, "expected GtSimplMes::mpMesRes to be size 4");
static_assert(sizeof(GtSimplMes::mHandol) == 4, "expected GtSimplMes::mHandol to be size 4");
static_assert(sizeof(GtSimplMes::mInitScane) == 4, "expected GtSimplMes::mInitScane to be size 4");
static_assert(sizeof(GtSimplMes::mInitFlg) == 1, "expected GtSimplMes::mInitFlg to be size 1");
static_assert(sizeof(GtSimplMes::mpMessTop) == 4, "expected GtSimplMes::mpMessTop to be size 4");
static_assert(sizeof(GtSimplMes) == 0x18, "expected GtSimplMes to be size 0x18");

// [Structure] struct DVDCommandBlock
struct DVDCommandBlock
{
public:
	/// Struct member variables

	// <DVDCommandBlock* next, offset 0x0>
	DVDCommandBlock* next = nullptr;

	// <DVDCommandBlock* prev, offset 0x4>
	DVDCommandBlock* prev = nullptr;

	// <uint32_t command, offset 0x8>
	uint32_t command = 0;

	// <int32_t volatile state, offset 0xc>
	int32_t volatile state;

	// <uint32_t offset, offset 0x10>
	uint32_t offset = 0;

	// <uint32_t length, offset 0x14>
	uint32_t length = 0;

	// <void* addr, offset 0x18>
	void* addr = nullptr;

	// <uint32_t currTransferSize, offset 0x1c>
	uint32_t currTransferSize = 0;

	// <uint32_t transferredSize, offset 0x20>
	uint32_t transferredSize = 0;

	// <struct DVDDiskID* id, offset 0x24>
	struct DVDDiskID* id = nullptr;

	// <void (* callback)(int32_t, DVDCommandBlock*), offset 0x28>
	void (* callback)(int32_t, DVDCommandBlock*);

	// <void* userData, offset 0x2c>
	void* userData = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct DVDCommandBlock [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(DVDCommandBlock& InObject)
	{
		next = InObject.next;
		prev = InObject.prev;
		command = InObject.command;
		state = InObject.state;
		offset = InObject.offset;
		length = InObject.length;
		addr = InObject.addr;
		currTransferSize = InObject.currTransferSize;
		transferredSize = InObject.transferredSize;
		id = InObject.id;
		userData = InObject.userData;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDCommandBlock>("DVDCommandBlock")
			.addFunction("__tostring", &DVDCommandBlock::ToString)
			.addFunction("GetPtrAddr", &DVDCommandBlock::GetPtrAddr)
			.addProperty("next", &DVDCommandBlock::next)
			.addProperty("prev", &DVDCommandBlock::prev)
			.addProperty("command", &DVDCommandBlock::command)
			// volatile not supported in LuaBridge and needs a getter
			//.addProperty("state", &DVDCommandBlock::state)
			.addProperty("offset", &DVDCommandBlock::offset)
			.addProperty("length", &DVDCommandBlock::length)
			// void type not supported in LuaBridge
			//.addProperty("addr", &DVDCommandBlock::addr)
			.addProperty("currTransferSize", &DVDCommandBlock::currTransferSize)
			.addProperty("transferredSize", &DVDCommandBlock::transferredSize)
			.addProperty("id", &DVDCommandBlock::id)
			// delegates are not supported in LuaBridge
			//.addProperty("callback", &DVDCommandBlock::callback)
			// void type not supported in LuaBridge
			//.addProperty("userData", &DVDCommandBlock::userData)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDCommandBlock::next) == 4, "expected DVDCommandBlock::next to be size 4");
static_assert(sizeof(DVDCommandBlock::prev) == 4, "expected DVDCommandBlock::prev to be size 4");
static_assert(sizeof(DVDCommandBlock::command) == 4, "expected DVDCommandBlock::command to be size 4");
static_assert(sizeof(DVDCommandBlock::state) == 4, "expected DVDCommandBlock::state to be size 4");
static_assert(sizeof(DVDCommandBlock::offset) == 4, "expected DVDCommandBlock::offset to be size 4");
static_assert(sizeof(DVDCommandBlock::length) == 4, "expected DVDCommandBlock::length to be size 4");
static_assert(sizeof(DVDCommandBlock::addr) == 4, "expected DVDCommandBlock::addr to be size 4");
static_assert(sizeof(DVDCommandBlock::currTransferSize) == 4, "expected DVDCommandBlock::currTransferSize to be size 4");
static_assert(sizeof(DVDCommandBlock::transferredSize) == 4, "expected DVDCommandBlock::transferredSize to be size 4");
static_assert(sizeof(DVDCommandBlock::id) == 4, "expected DVDCommandBlock::id to be size 4");
static_assert(sizeof(DVDCommandBlock::callback) == 4, "expected DVDCommandBlock::callback to be size 4");
static_assert(sizeof(DVDCommandBlock::userData) == 4, "expected DVDCommandBlock::userData to be size 4");
static_assert(sizeof(DVDCommandBlock) == 0x30, "expected DVDCommandBlock to be size 0x30");

// [Structure] struct DVDFileInfo
struct DVDFileInfo
{
public:
	/// Struct member variables

	// <struct DVDCommandBlock cb, offset 0x0>
	struct DVDCommandBlock cb;

	// <uint32_t startAddr, offset 0x30>
	uint32_t startAddr = 0;

	// <uint32_t length, offset 0x34>
	uint32_t length = 0;

	// <void (* callback)(int32_t, DVDFileInfo*), offset 0x38>
	void (* callback)(int32_t, DVDFileInfo*);

	// <class EE::SmartPtr<EE::IFile> file, offset 0x3c>
	class EE::SmartPtr<EE::IFile> file;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct DVDFileInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(DVDFileInfo& InObject)
	{
		cb = InObject.cb;
		startAddr = InObject.startAddr;
		length = InObject.length;
		file = InObject.file;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDFileInfo>("DVDFileInfo")
			.addFunction("__tostring", &DVDFileInfo::ToString)
			.addFunction("GetPtrAddr", &DVDFileInfo::GetPtrAddr)
			.addProperty("cb", &DVDFileInfo::cb)
			.addProperty("startAddr", &DVDFileInfo::startAddr)
			.addProperty("length", &DVDFileInfo::length)
			// delegates are not supported in LuaBridge
			//.addProperty("callback", &DVDFileInfo::callback)
			.addProperty("file", &DVDFileInfo::file)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDFileInfo::cb) == 48, "expected DVDFileInfo::cb to be size 48");
static_assert(sizeof(DVDFileInfo::startAddr) == 4, "expected DVDFileInfo::startAddr to be size 4");
static_assert(sizeof(DVDFileInfo::length) == 4, "expected DVDFileInfo::length to be size 4");
static_assert(sizeof(DVDFileInfo::callback) == 4, "expected DVDFileInfo::callback to be size 4");
static_assert(sizeof(DVDFileInfo::file) == 4, "expected DVDFileInfo::file to be size 4");
static_assert(sizeof(DVDFileInfo) == 0x40, "expected DVDFileInfo to be size 0x40");

// [Structure] class ghmGcFile
class ghmGcFile
{
public:
	// enum ghmGcFile::ghmGcFileState
	enum ghmGcFileState : uint32_t
	{
		// <READFINISH = 0x1>
		READFINISH = 1,

		// <CANCELED = 0x1>
		CANCELED = 1,

		// <CLOSED = 0x0>
		CLOSED = 0,

		// <OPENED = 0x1>
		OPENED = 1,

		// <READ = 0x2>
		READ = 2,

		// <READRETRY = 0x3>
		READRETRY = 3

	};

	// [Structure] struct ghmGcFile::ghmGcFileInfo
	struct ghmGcFileInfo
	{
	public:
		/// Struct member variables

		// <struct DVDFileInfo mFileInfo, offset 0x0>
		struct DVDFileInfo mFileInfo;

		// <int32_t mOffset, offset 0x40>
		int32_t mOffset = 0;

		// <int32_t mLength, offset 0x44>
		int32_t mLength = 0;

		// <int32_t mRequestNo, offset 0x48>
		int32_t mRequestNo = 0;

		// <int32_t volatile mReadStatus, offset 0x4c>
		int32_t volatile mReadStatus;

		// <int32_t volatile mReadResult, offset 0x50>
		int32_t volatile mReadResult;

		// <enum ghmGcFile::ghmGcFileState mState, offset 0x54>
		enum ghmGcFileState mState;

		// <uint8_t mDivRead, offset 0x58>
		uint8_t mDivRead = 0;

		// <Unidentified data segment, offset 0x59>
	private:
		char _UnidentifiedData_89[3];

	public:
		// <int32_t mTotalReadLength, offset 0x5c>
		int32_t mTotalReadLength = 0;

		// <int32_t mOneReadLength, offset 0x60>
		int32_t mOneReadLength = 0;

		// <int32_t mReadOffset, offset 0x64>
		int32_t mReadOffset = 0;

		// <void* mpBuffer, offset 0x68>
		void* mpBuffer = nullptr;

		// <int32_t mReadCount, offset 0x6c>
		int32_t mReadCount = 0;

		// <int32_t mDivNum, offset 0x70>
		int32_t mDivNum = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct ghmGcFile::ghmGcFileInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(ghmGcFile::ghmGcFileInfo& InObject)
		{
			mFileInfo = InObject.mFileInfo;
			mOffset = InObject.mOffset;
			mLength = InObject.mLength;
			mRequestNo = InObject.mRequestNo;
			mReadStatus = InObject.mReadStatus;
			mReadResult = InObject.mReadResult;
			mState = InObject.mState;
			mDivRead = InObject.mDivRead;
			mTotalReadLength = InObject.mTotalReadLength;
			mOneReadLength = InObject.mOneReadLength;
			mReadOffset = InObject.mReadOffset;
			mpBuffer = InObject.mpBuffer;
			mReadCount = InObject.mReadCount;
			mDivNum = InObject.mDivNum;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<ghmGcFileInfo>("ghmGcFile_ghmGcFileInfo")
				.addFunction("__tostring", &ghmGcFile::ghmGcFileInfo::ToString)
				.addFunction("GetPtrAddr", &ghmGcFile::ghmGcFileInfo::GetPtrAddr)
				.addProperty("mFileInfo", &ghmGcFile::ghmGcFileInfo::mFileInfo)
				.addProperty("mOffset", &ghmGcFile::ghmGcFileInfo::mOffset)
				.addProperty("mLength", &ghmGcFile::ghmGcFileInfo::mLength)
				.addProperty("mRequestNo", &ghmGcFile::ghmGcFileInfo::mRequestNo)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("mReadStatus", &ghmGcFile::ghmGcFileInfo::mReadStatus)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("mReadResult", &ghmGcFile::ghmGcFileInfo::mReadResult)
				.addProperty("mState", &ghmGcFile::ghmGcFileInfo::mState)
				.addProperty("mDivRead", &ghmGcFile::ghmGcFileInfo::mDivRead)
				.addProperty("mTotalReadLength", &ghmGcFile::ghmGcFileInfo::mTotalReadLength)
				.addProperty("mOneReadLength", &ghmGcFile::ghmGcFileInfo::mOneReadLength)
				.addProperty("mReadOffset", &ghmGcFile::ghmGcFileInfo::mReadOffset)
				// void type not supported in LuaBridge
				//.addProperty("mpBuffer", &ghmGcFile::ghmGcFileInfo::mpBuffer)
				.addProperty("mReadCount", &ghmGcFile::ghmGcFileInfo::mReadCount)
				.addProperty("mDivNum", &ghmGcFile::ghmGcFileInfo::mDivNum)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mFileInfo) == 64, "expected ghmGcFile::ghmGcFileInfo::mFileInfo to be size 64");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mOffset) == 4, "expected ghmGcFile::ghmGcFileInfo::mOffset to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mLength) == 4, "expected ghmGcFile::ghmGcFileInfo::mLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mRequestNo) == 4, "expected ghmGcFile::ghmGcFileInfo::mRequestNo to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadStatus) == 4, "expected ghmGcFile::ghmGcFileInfo::mReadStatus to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadResult) == 4, "expected ghmGcFile::ghmGcFileInfo::mReadResult to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mState) == 4, "expected ghmGcFile::ghmGcFileInfo::mState to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mDivRead) == 1, "expected ghmGcFile::ghmGcFileInfo::mDivRead to be size 1");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mTotalReadLength) == 4, "expected ghmGcFile::ghmGcFileInfo::mTotalReadLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mOneReadLength) == 4, "expected ghmGcFile::ghmGcFileInfo::mOneReadLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadOffset) == 4, "expected ghmGcFile::ghmGcFileInfo::mReadOffset to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mpBuffer) == 4, "expected ghmGcFile::ghmGcFileInfo::mpBuffer to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadCount) == 4, "expected ghmGcFile::ghmGcFileInfo::mReadCount to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mDivNum) == 4, "expected ghmGcFile::ghmGcFileInfo::mDivNum to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo) == 0x74, "expected ghmGcFile::ghmGcFileInfo to be size 0x74");

	/// Struct member variables

	// <struct ghmGcFile::ghmGcFileInfo mInfo, offset 0x0>
	struct ghmGcFile::ghmGcFileInfo mInfo;

	// <ghmGcFile* mpPrev, offset 0x74>
	ghmGcFile* mpPrev = nullptr;

	// <ghmGcFile* mpNext, offset 0x78>
	ghmGcFile* mpNext = nullptr;

	// <char mFileName[0x40], offset 0x7c>
	char mFileName[64];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcFile [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcFile& InObject)
	{
		mInfo = InObject.mInfo;
		mpPrev = InObject.mpPrev;
		mpNext = InObject.mpNext;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcFile>("ghmGcFile")
			.addFunction("__tostring", &ghmGcFile::ToString)
			.addFunction("GetPtrAddr", &ghmGcFile::GetPtrAddr)
			.addProperty("mInfo", &ghmGcFile::mInfo)
			.addProperty("mpPrev", &ghmGcFile::mpPrev)
			.addProperty("mpNext", &ghmGcFile::mpNext)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mFileName", &ghmGcFile::mFileName)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcFile::mInfo) == 116, "expected ghmGcFile::mInfo to be size 116");
static_assert(sizeof(ghmGcFile::mpPrev) == 4, "expected ghmGcFile::mpPrev to be size 4");
static_assert(sizeof(ghmGcFile::mpNext) == 4, "expected ghmGcFile::mpNext to be size 4");
static_assert(sizeof(ghmGcFile::mFileName) == 64, "expected ghmGcFile::mFileName to be size 64");
static_assert(sizeof(ghmGcFile) == 0xbc, "expected ghmGcFile to be size 0xbc");

// [Structure] struct DVDDiskID
struct DVDDiskID
{
public:
	/// Struct member variables

	// <char gameName[0x4], offset 0x0>
	char gameName[4];

	// <char company[0x2], offset 0x4>
	char company[2];

	// <uint8_t diskNumber, offset 0x6>
	uint8_t diskNumber = 0;

	// <uint8_t gameVersion, offset 0x7>
	uint8_t gameVersion = 0;

	// <uint8_t streaming, offset 0x8>
	uint8_t streaming = 0;

	// <uint8_t streamingBufSize, offset 0x9>
	uint8_t streamingBufSize = 0;

	// <uint8_t padding[0xe], offset 0xa>
	uint8_t padding[14];

	// <uint32_t rvlMagic, offset 0x18>
	uint32_t rvlMagic = 0;

	// <uint32_t gcMagic, offset 0x1c>
	uint32_t gcMagic = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct DVDDiskID [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(DVDDiskID& InObject)
	{
		diskNumber = InObject.diskNumber;
		gameVersion = InObject.gameVersion;
		streaming = InObject.streaming;
		streamingBufSize = InObject.streamingBufSize;
		rvlMagic = InObject.rvlMagic;
		gcMagic = InObject.gcMagic;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDDiskID>("DVDDiskID")
			.addFunction("__tostring", &DVDDiskID::ToString)
			.addFunction("GetPtrAddr", &DVDDiskID::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("gameName", &DVDDiskID::gameName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("company", &DVDDiskID::company)
			.addProperty("diskNumber", &DVDDiskID::diskNumber)
			.addProperty("gameVersion", &DVDDiskID::gameVersion)
			.addProperty("streaming", &DVDDiskID::streaming)
			.addProperty("streamingBufSize", &DVDDiskID::streamingBufSize)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("padding", &DVDDiskID::padding)
			.addProperty("rvlMagic", &DVDDiskID::rvlMagic)
			.addProperty("gcMagic", &DVDDiskID::gcMagic)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDDiskID::gameName) == 4, "expected DVDDiskID::gameName to be size 4");
static_assert(sizeof(DVDDiskID::company) == 2, "expected DVDDiskID::company to be size 2");
static_assert(sizeof(DVDDiskID::diskNumber) == 1, "expected DVDDiskID::diskNumber to be size 1");
static_assert(sizeof(DVDDiskID::gameVersion) == 1, "expected DVDDiskID::gameVersion to be size 1");
static_assert(sizeof(DVDDiskID::streaming) == 1, "expected DVDDiskID::streaming to be size 1");
static_assert(sizeof(DVDDiskID::streamingBufSize) == 1, "expected DVDDiskID::streamingBufSize to be size 1");
static_assert(sizeof(DVDDiskID::padding) == 14, "expected DVDDiskID::padding to be size 14");
static_assert(sizeof(DVDDiskID::rvlMagic) == 4, "expected DVDDiskID::rvlMagic to be size 4");
static_assert(sizeof(DVDDiskID::gcMagic) == 4, "expected DVDDiskID::gcMagic to be size 4");
static_assert(sizeof(DVDDiskID) == 0x20, "expected DVDDiskID to be size 0x20");

// [Structure] class EE::IFile
namespace EE
{
	class IFile : public EE::RefObject
	{
	public:
		/// Struct member variables

		// <class EE::RefObject field_0, offset 0x0>
		// class RefObject Super;

		// <class EE::String name, offset 0x8>
		class String name;

		// <uint8_t endianSwap, offset 0x14>
		uint8_t endianSwap = 0;

		// <Unidentified data segment, offset 0x15>
	private:
		char _UnidentifiedData_21[3];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class EE::IFile [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EE::IFile& InObject)
		{
			name = InObject.name;
			endianSwap = InObject.endianSwap;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.deriveClass<IFile, EE::RefObject>("EE_IFile")
				.addFunction("__tostring", &EE::IFile::ToString)
				.addFunction("GetPtrAddr", &EE::IFile::GetPtrAddr)
				.addProperty("name", &EE::IFile::name)
				.addProperty("endianSwap", &EE::IFile::endianSwap)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(EE::IFile::name) == 12, "expected EE::IFile::name to be size 12");
static_assert(sizeof(EE::IFile::endianSwap) == 1, "expected EE::IFile::endianSwap to be size 1");
static_assert(sizeof(EE::IFile) == 0x18, "expected EE::IFile to be size 0x18");

// [Structure] struct BATTLESIMPLMESS_SET
/// <summary>
/// Stores info on simple battle messages.
/// </summary>
struct BATTLESIMPLMESS_SET
{
public:
	/// Struct member variables

	// <int16_t mMessNum, offset 0x0>
	int16_t mMessNum = 0;

	// <Unidentified data segment, offset 0x2>
private:
	char _UnidentifiedData_2[2];

public:
	// <float mMesPosY, offset 0x4>
	float mMesPosY = 0;

	// <int32_t mAnimCount, offset 0x8>
	int32_t mAnimCount = 0;

	// <int32_t mAlpha, offset 0xc>
	int32_t mAlpha = 0;

	// <uint8_t mLiveflg, offset 0x10>
	uint8_t mLiveflg = 0;

	// <Unidentified data segment, offset 0x11>
private:
	char _UnidentifiedData_17[1];

public:
	// <int16_t mMax_Cnt, offset 0x12>
	int16_t mMax_Cnt = 0;

	// <BATTLESIMPLMESS_SET* pNext, offset 0x14>
	BATTLESIMPLMESS_SET* pNext = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct BATTLESIMPLMESS_SET [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(BATTLESIMPLMESS_SET& InObject)
	{
		mMessNum = InObject.mMessNum;
		mMesPosY = InObject.mMesPosY;
		mAnimCount = InObject.mAnimCount;
		mAlpha = InObject.mAlpha;
		mLiveflg = InObject.mLiveflg;
		mMax_Cnt = InObject.mMax_Cnt;
		pNext = InObject.pNext;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<BATTLESIMPLMESS_SET>("BATTLESIMPLMESS_SET")
			.addFunction("__tostring", &BATTLESIMPLMESS_SET::ToString)
			.addFunction("GetPtrAddr", &BATTLESIMPLMESS_SET::GetPtrAddr)
			.addProperty("mMessNum", &BATTLESIMPLMESS_SET::mMessNum)
			.addProperty("mMesPosY", &BATTLESIMPLMESS_SET::mMesPosY)
			.addProperty("mAnimCount", &BATTLESIMPLMESS_SET::mAnimCount)
			.addProperty("mAlpha", &BATTLESIMPLMESS_SET::mAlpha)
			.addProperty("mLiveflg", &BATTLESIMPLMESS_SET::mLiveflg)
			.addProperty("mMax_Cnt", &BATTLESIMPLMESS_SET::mMax_Cnt)
			.addProperty("pNext", &BATTLESIMPLMESS_SET::pNext)
		.endClass();
	}
#endif
};
static_assert(sizeof(BATTLESIMPLMESS_SET::mMessNum) == 2, "expected BATTLESIMPLMESS_SET::mMessNum to be size 2");
static_assert(sizeof(BATTLESIMPLMESS_SET::mMesPosY) == 4, "expected BATTLESIMPLMESS_SET::mMesPosY to be size 4");
static_assert(sizeof(BATTLESIMPLMESS_SET::mAnimCount) == 4, "expected BATTLESIMPLMESS_SET::mAnimCount to be size 4");
static_assert(sizeof(BATTLESIMPLMESS_SET::mAlpha) == 4, "expected BATTLESIMPLMESS_SET::mAlpha to be size 4");
static_assert(sizeof(BATTLESIMPLMESS_SET::mLiveflg) == 1, "expected BATTLESIMPLMESS_SET::mLiveflg to be size 1");
static_assert(sizeof(BATTLESIMPLMESS_SET::mMax_Cnt) == 2, "expected BATTLESIMPLMESS_SET::mMax_Cnt to be size 2");
static_assert(sizeof(BATTLESIMPLMESS_SET::pNext) == 4, "expected BATTLESIMPLMESS_SET::pNext to be size 4");
static_assert(sizeof(BATTLESIMPLMESS_SET) == 0x18, "expected BATTLESIMPLMESS_SET to be size 0x18");

// [Structure] class HrEffectShutter
class HrEffectShutter : public HrTask
{
public:
	// enum HrEffectShutter::D_EFFECTSHUTTER_STAT
	enum D_EFFECTSHUTTER_STAT : uint32_t
	{
		// <NONE = 0x0>
		NONE = 0,

		// <CLOSE_DO = 0x1>
		CLOSE_DO = 1,

		// <CLOSE_ED = 0x2>
		CLOSE_ED = 2,

		// <OPEN_DO = 0x3>
		OPEN_DO = 3,

		// <OPEN_ED = 0x4>
		OPEN_ED = 4

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <enum HrEffectShutter::D_EFFECTSHUTTER_STAT m_Stat, offset 0x50>
	enum HrEffectShutter::D_EFFECTSHUTTER_STAT m_Stat;

	// <int16_t m_Counter, offset 0x54>
	int16_t m_Counter = 0;

	// <int16_t m_OpenTime, offset 0x56>
	int16_t m_OpenTime = 0;

	// <int16_t m_CloseTime, offset 0x58>
	int16_t m_CloseTime = 0;

	// <Unidentified data segment, offset 0x5a>
private:
	char _UnidentifiedData_90[2];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrEffectShutter [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrEffectShutter& InObject)
	{
		m_Stat = InObject.m_Stat;
		m_Counter = InObject.m_Counter;
		m_OpenTime = InObject.m_OpenTime;
		m_CloseTime = InObject.m_CloseTime;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrEffectShutter, HrTask>("HrEffectShutter")
			.addFunction("__tostring", &HrEffectShutter::ToString)
			.addFunction("GetPtrAddr", &HrEffectShutter::GetPtrAddr)
			.addProperty("m_Stat", &HrEffectShutter::m_Stat)
			.addProperty("m_Counter", &HrEffectShutter::m_Counter)
			.addProperty("m_OpenTime", &HrEffectShutter::m_OpenTime)
			.addProperty("m_CloseTime", &HrEffectShutter::m_CloseTime)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrEffectShutter::m_Stat) == 4, "expected HrEffectShutter::m_Stat to be size 4");
static_assert(sizeof(HrEffectShutter::m_Counter) == 2, "expected HrEffectShutter::m_Counter to be size 2");
static_assert(sizeof(HrEffectShutter::m_OpenTime) == 2, "expected HrEffectShutter::m_OpenTime to be size 2");
static_assert(sizeof(HrEffectShutter::m_CloseTime) == 2, "expected HrEffectShutter::m_CloseTime to be size 2");
static_assert(sizeof(HrEffectShutter) == 0x5c, "expected HrEffectShutter to be size 0x5c");

// enum GHMR_BLEND
enum GHMR_BLEND : uint32_t
{
	// <GHMR_BLEND_ADD = 0x0>
	GHMR_BLEND_ADD = 0,

	// <GHMR_BLEND_SUB = 0x1>
	GHMR_BLEND_SUB = 1,

	// <GHMR_BLEND_MUL = 0x2>
	GHMR_BLEND_MUL = 2,

	// <GHMR_BLEND_ALPHA = 0x3>
	GHMR_BLEND_ALPHA = 3,

	// <GHMR_BLEND_NONE = 0x4>
	GHMR_BLEND_NONE = 4,

	// <GHMR_BLEND_NUM = 0x5>
	GHMR_BLEND_NUM = 5

};

// [Structure] class EfBase
class EfBase
{
public:
	/// Struct member variables

	// <uint8_t mBitFlag, offset 0x0>
	uint8_t mBitFlag = 0;

	// <Unidentified data segment, offset 0x1>
private:
	char _UnidentifiedData_1[3];

public:
	// <uint32_t mTick, offset 0x4>
	uint32_t mTick = 0;

	// <uint32_t mBefFrameTick, offset 0x8>
	uint32_t mBefFrameTick = 0;

	// <float mRate, offset 0xc>
	float mRate = 0;

	// <uint32_t mSelectParam, offset 0x10>
	uint32_t mSelectParam = 0;

	// <uint32_t mKeyWait, offset 0x14>
	uint32_t mKeyWait = 0;

	/// 1 Functions

	// [Function] class ghmResGroup* __convention("thiscall") EfBase::GetCurrentResGroup(class EfBase* const this) [?GetCurrentResGroup@EfBase@@IAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _GetCurrentResGroup_EfBase__IAEPAVghmResGroup__XZ)(class EfBase* const thisPtr);
	class ghmResGroup* GetCurrentResGroup()
	{
		_GetCurrentResGroup_EfBase__IAEPAVghmResGroup__XZ mFunc = (_GetCurrentResGroup_EfBase__IAEPAVghmResGroup__XZ)(GameModule + 0x562550);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfBase& InObject)
	{
		mBitFlag = InObject.mBitFlag;
		mTick = InObject.mTick;
		mBefFrameTick = InObject.mBefFrameTick;
		mRate = InObject.mRate;
		mSelectParam = InObject.mSelectParam;
		mKeyWait = InObject.mKeyWait;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfBase>("EfBase")
			.addFunction("__tostring", &EfBase::ToString)
			.addFunction("GetPtrAddr", &EfBase::GetPtrAddr)
			.addProperty("mBitFlag", &EfBase::mBitFlag)
			.addProperty("mTick", &EfBase::mTick)
			.addProperty("mBefFrameTick", &EfBase::mBefFrameTick)
			.addProperty("mRate", &EfBase::mRate)
			.addProperty("mSelectParam", &EfBase::mSelectParam)
			.addProperty("mKeyWait", &EfBase::mKeyWait)
			.addFunction("GetCurrentResGroup", &EfBase::GetCurrentResGroup)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfBase::mBitFlag) == 1, "expected EfBase::mBitFlag to be size 1");
static_assert(sizeof(EfBase::mTick) == 4, "expected EfBase::mTick to be size 4");
static_assert(sizeof(EfBase::mBefFrameTick) == 4, "expected EfBase::mBefFrameTick to be size 4");
static_assert(sizeof(EfBase::mRate) == 4, "expected EfBase::mRate to be size 4");
static_assert(sizeof(EfBase::mSelectParam) == 4, "expected EfBase::mSelectParam to be size 4");
static_assert(sizeof(EfBase::mKeyWait) == 4, "expected EfBase::mKeyWait to be size 4");
static_assert(sizeof(EfBase) == 0x18, "expected EfBase to be size 0x18");

// [Structure] class EfSmoke
class EfSmoke : public HrTask
{
public:
	// [Structure] struct EfSmoke::SmokePrim
	struct SmokePrim
	{
	public:
		/// Struct member variables

		// <struct Vec Pos, offset 0x0>
		struct Vec Pos;

		// <struct Vec Mov, offset 0xc>
		struct Vec Mov;

		// <uint32_t Color, offset 0x18>
		uint32_t Color = 0;

		// <float Scale, offset 0x1c>
		float Scale = 0;

		// <float ScaleAdd, offset 0x20>
		float ScaleAdd = 0;

		// <float Speed, offset 0x24>
		float Speed = 0;

		// <float SpeedAdd, offset 0x28>
		float SpeedAdd = 0;

		// <float Alpha, offset 0x2c>
		float Alpha = 0;

		// <float Rot, offset 0x30>
		float Rot = 0;

		// <float RotSpeed, offset 0x34>
		float RotSpeed = 0;

		// <uint32_t Cnt, offset 0x38>
		uint32_t Cnt = 0;

		// <uint32_t FadeStartTick, offset 0x3c>
		uint32_t FadeStartTick = 0;

		// <float FadeValue, offset 0x40>
		float FadeValue = 0;

		// <EfSmoke::SmokePrim* pNext, offset 0x44>
		SmokePrim* pNext = nullptr;

		// <EfSmoke::SmokePrim* pPrev, offset 0x48>
		SmokePrim* pPrev = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EfSmoke::SmokePrim [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EfSmoke::SmokePrim& InObject)
		{
			Pos = InObject.Pos;
			Mov = InObject.Mov;
			Color = InObject.Color;
			Scale = InObject.Scale;
			ScaleAdd = InObject.ScaleAdd;
			Speed = InObject.Speed;
			SpeedAdd = InObject.SpeedAdd;
			Alpha = InObject.Alpha;
			Rot = InObject.Rot;
			RotSpeed = InObject.RotSpeed;
			Cnt = InObject.Cnt;
			FadeStartTick = InObject.FadeStartTick;
			FadeValue = InObject.FadeValue;
			pNext = InObject.pNext;
			pPrev = InObject.pPrev;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<SmokePrim>("EfSmoke_SmokePrim")
				.addFunction("__tostring", &EfSmoke::SmokePrim::ToString)
				.addFunction("GetPtrAddr", &EfSmoke::SmokePrim::GetPtrAddr)
				.addProperty("Pos", &EfSmoke::SmokePrim::Pos)
				.addProperty("Mov", &EfSmoke::SmokePrim::Mov)
				.addProperty("Color", &EfSmoke::SmokePrim::Color)
				.addProperty("Scale", &EfSmoke::SmokePrim::Scale)
				.addProperty("ScaleAdd", &EfSmoke::SmokePrim::ScaleAdd)
				.addProperty("Speed", &EfSmoke::SmokePrim::Speed)
				.addProperty("SpeedAdd", &EfSmoke::SmokePrim::SpeedAdd)
				.addProperty("Alpha", &EfSmoke::SmokePrim::Alpha)
				.addProperty("Rot", &EfSmoke::SmokePrim::Rot)
				.addProperty("RotSpeed", &EfSmoke::SmokePrim::RotSpeed)
				.addProperty("Cnt", &EfSmoke::SmokePrim::Cnt)
				.addProperty("FadeStartTick", &EfSmoke::SmokePrim::FadeStartTick)
				.addProperty("FadeValue", &EfSmoke::SmokePrim::FadeValue)
				.addProperty("pNext", &EfSmoke::SmokePrim::pNext)
				.addProperty("pPrev", &EfSmoke::SmokePrim::pPrev)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EfSmoke::SmokePrim::Pos) == 12, "expected EfSmoke::SmokePrim::Pos to be size 12");
	static_assert(sizeof(EfSmoke::SmokePrim::Mov) == 12, "expected EfSmoke::SmokePrim::Mov to be size 12");
	static_assert(sizeof(EfSmoke::SmokePrim::Color) == 4, "expected EfSmoke::SmokePrim::Color to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Scale) == 4, "expected EfSmoke::SmokePrim::Scale to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::ScaleAdd) == 4, "expected EfSmoke::SmokePrim::ScaleAdd to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Speed) == 4, "expected EfSmoke::SmokePrim::Speed to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::SpeedAdd) == 4, "expected EfSmoke::SmokePrim::SpeedAdd to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Alpha) == 4, "expected EfSmoke::SmokePrim::Alpha to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Rot) == 4, "expected EfSmoke::SmokePrim::Rot to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::RotSpeed) == 4, "expected EfSmoke::SmokePrim::RotSpeed to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Cnt) == 4, "expected EfSmoke::SmokePrim::Cnt to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::FadeStartTick) == 4, "expected EfSmoke::SmokePrim::FadeStartTick to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::FadeValue) == 4, "expected EfSmoke::SmokePrim::FadeValue to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::pNext) == 4, "expected EfSmoke::SmokePrim::pNext to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::pPrev) == 4, "expected EfSmoke::SmokePrim::pPrev to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim) == 0x4c, "expected EfSmoke::SmokePrim to be size 0x4c");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <struct EfSmoke::SmokePrim* mpPrimAry, offset 0x68>
	struct EfSmoke::SmokePrim* mpPrimAry = nullptr;

	// <struct EfSmoke::SmokePrim* mpValidList, offset 0x6c>
	struct EfSmoke::SmokePrim* mpValidList = nullptr;

	// <struct EfSmoke::SmokePrim* mpActiveList, offset 0x70>
	struct EfSmoke::SmokePrim* mpActiveList = nullptr;

	// <struct tagGHMR_TEX* mpChangeTex, offset 0x74>
	struct tagGHMR_TEX* mpChangeTex = nullptr;

	// <int32_t mActiveNum, offset 0x78>
	int32_t mActiveNum = 0;

	// <enum GHMR_BLEND mBlendMode, offset 0x7c>
	enum GHMR_BLEND mBlendMode;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfSmoke [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfSmoke& InObject)
	{
		field_50 = InObject.field_50;
		mpPrimAry = InObject.mpPrimAry;
		mpValidList = InObject.mpValidList;
		mpActiveList = InObject.mpActiveList;
		mpChangeTex = InObject.mpChangeTex;
		mActiveNum = InObject.mActiveNum;
		mBlendMode = InObject.mBlendMode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfSmoke, HrTask>("EfSmoke")
			.addFunction("__tostring", &EfSmoke::ToString)
			.addFunction("GetPtrAddr", &EfSmoke::GetPtrAddr)
			.addProperty("field_50", &EfSmoke::field_50)
			.addProperty("mpPrimAry", &EfSmoke::mpPrimAry)
			.addProperty("mpValidList", &EfSmoke::mpValidList)
			.addProperty("mpActiveList", &EfSmoke::mpActiveList)
			.addProperty("mpChangeTex", &EfSmoke::mpChangeTex)
			.addProperty("mActiveNum", &EfSmoke::mActiveNum)
			.addProperty("mBlendMode", &EfSmoke::mBlendMode)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfSmoke::field_50) == 24, "expected EfSmoke::field_50 to be size 24");
static_assert(sizeof(EfSmoke::mpPrimAry) == 4, "expected EfSmoke::mpPrimAry to be size 4");
static_assert(sizeof(EfSmoke::mpValidList) == 4, "expected EfSmoke::mpValidList to be size 4");
static_assert(sizeof(EfSmoke::mpActiveList) == 4, "expected EfSmoke::mpActiveList to be size 4");
static_assert(sizeof(EfSmoke::mpChangeTex) == 4, "expected EfSmoke::mpChangeTex to be size 4");
static_assert(sizeof(EfSmoke::mActiveNum) == 4, "expected EfSmoke::mActiveNum to be size 4");
static_assert(sizeof(EfSmoke::mBlendMode) == 4, "expected EfSmoke::mBlendMode to be size 4");
static_assert(sizeof(EfSmoke) == 0x80, "expected EfSmoke to be size 0x80");

// enum enPcAttackEffect
enum enPcAttackEffect : uint32_t
{
	// <eEfGuard = 0x0>
	eEfGuard = 0,

	// <eEfHitSword = 0x1>
	eEfHitSword = 1,

	// <eEfHitFight = 0x2>
	eEfHitFight = 2,

	// <eEfHitPiyori = 0x3>
	eEfHitPiyori = 3,

	// <eEfHitGuardBreak = 0x4>
	eEfHitGuardBreak = 4,

	// <eEfMax = 0x5>
	eEfMax = 5

};

// enum enThrowDir
enum enThrowDir : uint32_t
{
	// <enThrowDirF = 0x0>
	enThrowDirF = 0,

	// <enThrowDirB = 0x1>
	enThrowDirB = 1,

	// <enThrowDirLR = 0x2>
	enThrowDirLR = 2,

	// <enThrowDirH = 0x3>
	enThrowDirH = 3,

	// <enThrowDirMax = 0x4>
	enThrowDirMax = 4

};

// enum enScreenChangeStatus
enum enScreenChangeStatus : uint32_t
{
	// <ScreenChangeStatusStandby = 0x0>
	ScreenChangeStatusStandby = 0,

	// <ScreenChangeStatusFadeIn = 0x1>
	ScreenChangeStatusFadeIn = 1,

	// <ScreenChangeStatusFadeStandby = 0x2>
	ScreenChangeStatusFadeStandby = 2,

	// <ScreenChangeStatusFadeOut = 0x3>
	ScreenChangeStatusFadeOut = 3,

	// <ScreenChangeStatusMax = 0x4>
	ScreenChangeStatusMax = 4

};

// enum eEfDmgLevel
enum eEfDmgLevel : uint32_t
{
	// <eEfDmgLevel_UNKNOWN = 0xffffffffffffffff>
	eEfDmgLevel_UNKNOWN = UINT32_MAX,

	// <eEfDmgLevel_Small = 0x0>
	eEfDmgLevel_Small = 0,

	// <eEfDmgLevel_Big = 0x1>
	eEfDmgLevel_Big = 1,

	// <eEfDmgLevel_Slash = 0x2>
	eEfDmgLevel_Slash = 2,

	// <eEfDmgLevel_NUM = 0x3>
	eEfDmgLevel_NUM = 3

};

// enum enDownStatus
enum enDownStatus : uint32_t
{
	// <eDownFront = 0x0>
	eDownFront = 0,

	// <eDownBack = 0x1>
	eDownBack = 1,

	// <eDownMax = 0x2>
	eDownMax = 2

};

// enum enPcPose
enum enPcPose : uint32_t
{
	// <ePcPoseUpper = 0x0>
	ePcPoseUpper = 0,

	// <ePcPoseBottom = 0x1>
	ePcPoseBottom = 1,

	// <ePcPoseMax = 0x2>
	ePcPoseMax = 2

};

// enum enShakeDir
enum enShakeDir : uint32_t
{
	// <eShakeUp2Down = 0x0>
	eShakeUp2Down = 0,

	// <eShakeDown2Up = 0x1>
	eShakeDown2Up = 1,

	// <eShakeLeft2Right = 0x2>
	eShakeLeft2Right = 2,

	// <eShakeRight2Left = 0x3>
	eShakeRight2Left = 3,

	// <eShakeThrust = 0x4>
	eShakeThrust = 4,

	// <eShakePull = 0x5>
	eShakePull = 5,

	// <eShakeCross = 0x6>
	eShakeCross = 6,

	// <eShakeNone = 0x7>
	eShakeNone = 7

};

// enum enEqKind
enum enEqKind : uint32_t
{
	// <eEqWeaponR = 0x0>
	eEqWeaponR = 0,

	// <eEqSunglass = 0x1>
	eEqSunglass = 1,

	// <eEqJacket = 0x2>
	eEqJacket = 2,

	// <eEqShoes = 0x3>
	eEqShoes = 3,

	// <eEqPants = 0x4>
	eEqPants = 4,

	// <eEqBelt = 0x5>
	eEqBelt = 5,

	// <eEqTshirt = 0x6>
	eEqTshirt = 6,

	// <eEqWBand = 0x7>
	eEqWBand = 7,

	// <eEqWeaponL = 0x8>
	eEqWeaponL = 8,

	// <eEqKindMax = 0x9>
	eEqKindMax = 9

};

// [Structure] class CTimeRatioInterpolate
class CTimeRatioInterpolate
{
public:
	/// Struct member variables

	// <float m_fOneRatioTime, offset 0x0>
	float m_fOneRatioTime = 0;

	// <float m_fRatio, offset 0x4>
	float m_fRatio = 0;

	// <float m_fTimer, offset 0x8>
	float m_fTimer = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CTimeRatioInterpolate [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CTimeRatioInterpolate& InObject)
	{
		m_fOneRatioTime = InObject.m_fOneRatioTime;
		m_fRatio = InObject.m_fRatio;
		m_fTimer = InObject.m_fTimer;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CTimeRatioInterpolate>("CTimeRatioInterpolate")
			.addFunction("__tostring", &CTimeRatioInterpolate::ToString)
			.addFunction("GetPtrAddr", &CTimeRatioInterpolate::GetPtrAddr)
			.addProperty("m_fOneRatioTime", &CTimeRatioInterpolate::m_fOneRatioTime)
			.addProperty("m_fRatio", &CTimeRatioInterpolate::m_fRatio)
			.addProperty("m_fTimer", &CTimeRatioInterpolate::m_fTimer)
		.endClass();
	}
#endif
};
static_assert(sizeof(CTimeRatioInterpolate::m_fOneRatioTime) == 4, "expected CTimeRatioInterpolate::m_fOneRatioTime to be size 4");
static_assert(sizeof(CTimeRatioInterpolate::m_fRatio) == 4, "expected CTimeRatioInterpolate::m_fRatio to be size 4");
static_assert(sizeof(CTimeRatioInterpolate::m_fTimer) == 4, "expected CTimeRatioInterpolate::m_fTimer to be size 4");
static_assert(sizeof(CTimeRatioInterpolate) == 0xc, "expected CTimeRatioInterpolate to be size 0xc");

// enum enWepChangeProc
enum enWepChangeProc : uint32_t
{
	// <eWepChangeInit = 0x0>
	eWepChangeInit = 0,

	// <eWepChangeWait = 0x1>
	eWepChangeWait = 1,

	// <eWepChangeMax = 0x2>
	eWepChangeMax = 2

};

// [Structure] union uniSMflag
union uniSMflag
{
public:
	/// Struct member variables

	// <uint16_t smBaceActivSubMission, offset 0x0>
	uint16_t smBaceActivSubMission = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "union uniSMflag [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(uniSMflag& InObject)
	{
		smBaceActivSubMission = InObject.smBaceActivSubMission;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<uniSMflag>("uniSMflag")
			.addFunction("__tostring", &uniSMflag::ToString)
			.addFunction("GetPtrAddr", &uniSMflag::GetPtrAddr)
			.addProperty("smBaceActivSubMission", &uniSMflag::smBaceActivSubMission)
		.endClass();
	}
#endif
};
static_assert(sizeof(uniSMflag::smBaceActivSubMission) == 2, "expected uniSMflag::smBaceActivSubMission to be size 2");
static_assert(sizeof(uniSMflag) == 0x2, "expected uniSMflag to be size 0x2");

// enum enScreenChangeKind
enum enScreenChangeKind : uint32_t
{
	// <eScreenChangeStencil = 0x0>
	eScreenChangeStencil = 0,

	// <eScreenChangeFade = 0x1>
	eScreenChangeFade = 1,

	// <eScreenChangeMax = 0x2>
	eScreenChangeMax = 2

};

// [Structure] struct stFade
struct stFade
{
public:
	/// Struct member variables

	// <enum enScreenChangeKind kind, offset 0x0>
	enum enScreenChangeKind kind;

	// <uint8_t requestStart, offset 0x4>
	uint8_t requestStart = 0;

	// <uint8_t requestEnd, offset 0x5>
	uint8_t requestEnd = 0;

	// <Unidentified data segment, offset 0x6>
private:
	char _UnidentifiedData_6[2];

public:
	// <class HrOverLap* pOverLap, offset 0x8>
	class HrOverLap* pOverLap = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stFade [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stFade& InObject)
	{
		kind = InObject.kind;
		requestStart = InObject.requestStart;
		requestEnd = InObject.requestEnd;
		pOverLap = InObject.pOverLap;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stFade>("stFade")
			.addFunction("__tostring", &stFade::ToString)
			.addFunction("GetPtrAddr", &stFade::GetPtrAddr)
			.addProperty("kind", &stFade::kind)
			.addProperty("requestStart", &stFade::requestStart)
			.addProperty("requestEnd", &stFade::requestEnd)
			.addProperty("pOverLap", &stFade::pOverLap)
		.endClass();
	}
#endif
};
static_assert(sizeof(stFade::kind) == 4, "expected stFade::kind to be size 4");
static_assert(sizeof(stFade::requestStart) == 1, "expected stFade::requestStart to be size 1");
static_assert(sizeof(stFade::requestEnd) == 1, "expected stFade::requestEnd to be size 1");
static_assert(sizeof(stFade::pOverLap) == 4, "expected stFade::pOverLap to be size 4");
static_assert(sizeof(stFade) == 0xc, "expected stFade to be size 0xc");

// enum enCharaInitProc
enum enCharaInitProc : uint32_t
{
	// <eCharaInitProcPrepareForReadRsl = 0x0>
	eCharaInitProcPrepareForReadRsl = 0,

	// <eCharaInitProcReadRsl = 0x1>
	eCharaInitProcReadRsl = 1,

	// <eCharaInitProcReadRslWait = 0x2>
	eCharaInitProcReadRslWait = 2,

	// <eCharaInitProcPrepareForRsl = 0x3>
	eCharaInitProcPrepareForRsl = 3,

	// <eCharaInitProcFinish = 0x4>
	eCharaInitProcFinish = 4,

	// <eCharaInitProcMax = 0x5>
	eCharaInitProcMax = 5

};

// [Structure] class CSpringInterpolate
class CSpringInterpolate
{
public:
	/// Struct member variables

	// <float m_fSpringCoe, offset 0x0>
	float m_fSpringCoe = 0;

	// <float m_fMaxVel, offset 0x4>
	float m_fMaxVel = 0;

	// <float m_fMinVel, offset 0x8>
	float m_fMinVel = 0;

	// <uint8_t m_bIsRadiInterp, offset 0xc>
	uint8_t m_bIsRadiInterp = 0;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData_13[3];

public:
	// <float m_fEpsilon, offset 0x10>
	float m_fEpsilon = 0;

	// <float m_fValue, offset 0x14>
	float m_fValue = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CSpringInterpolate [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CSpringInterpolate& InObject)
	{
		m_fSpringCoe = InObject.m_fSpringCoe;
		m_fMaxVel = InObject.m_fMaxVel;
		m_fMinVel = InObject.m_fMinVel;
		m_bIsRadiInterp = InObject.m_bIsRadiInterp;
		m_fEpsilon = InObject.m_fEpsilon;
		m_fValue = InObject.m_fValue;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CSpringInterpolate>("CSpringInterpolate")
			.addFunction("__tostring", &CSpringInterpolate::ToString)
			.addFunction("GetPtrAddr", &CSpringInterpolate::GetPtrAddr)
			.addProperty("m_fSpringCoe", &CSpringInterpolate::m_fSpringCoe)
			.addProperty("m_fMaxVel", &CSpringInterpolate::m_fMaxVel)
			.addProperty("m_fMinVel", &CSpringInterpolate::m_fMinVel)
			.addProperty("m_bIsRadiInterp", &CSpringInterpolate::m_bIsRadiInterp)
			.addProperty("m_fEpsilon", &CSpringInterpolate::m_fEpsilon)
			.addProperty("m_fValue", &CSpringInterpolate::m_fValue)
		.endClass();
	}
#endif
};
static_assert(sizeof(CSpringInterpolate::m_fSpringCoe) == 4, "expected CSpringInterpolate::m_fSpringCoe to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fMaxVel) == 4, "expected CSpringInterpolate::m_fMaxVel to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fMinVel) == 4, "expected CSpringInterpolate::m_fMinVel to be size 4");
static_assert(sizeof(CSpringInterpolate::m_bIsRadiInterp) == 1, "expected CSpringInterpolate::m_bIsRadiInterp to be size 1");
static_assert(sizeof(CSpringInterpolate::m_fEpsilon) == 4, "expected CSpringInterpolate::m_fEpsilon to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fValue) == 4, "expected CSpringInterpolate::m_fValue to be size 4");
static_assert(sizeof(CSpringInterpolate) == 0x18, "expected CSpringInterpolate to be size 0x18");

// [Structure] class CDoubleSpringInterpolate
class CDoubleSpringInterpolate
{
public:
	/// Struct member variables

	// <class CSpringInterpolate m_inHopeInterp, offset 0x0>
	class CSpringInterpolate m_inHopeInterp;

	// <class CSpringInterpolate m_inCurInterp, offset 0x18>
	class CSpringInterpolate m_inCurInterp;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CDoubleSpringInterpolate [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CDoubleSpringInterpolate& InObject)
	{
		m_inHopeInterp = InObject.m_inHopeInterp;
		m_inCurInterp = InObject.m_inCurInterp;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CDoubleSpringInterpolate>("CDoubleSpringInterpolate")
			.addFunction("__tostring", &CDoubleSpringInterpolate::ToString)
			.addFunction("GetPtrAddr", &CDoubleSpringInterpolate::GetPtrAddr)
			.addProperty("m_inHopeInterp", &CDoubleSpringInterpolate::m_inHopeInterp)
			.addProperty("m_inCurInterp", &CDoubleSpringInterpolate::m_inCurInterp)
		.endClass();
	}
#endif
};
static_assert(sizeof(CDoubleSpringInterpolate::m_inHopeInterp) == 24, "expected CDoubleSpringInterpolate::m_inHopeInterp to be size 24");
static_assert(sizeof(CDoubleSpringInterpolate::m_inCurInterp) == 24, "expected CDoubleSpringInterpolate::m_inCurInterp to be size 24");
static_assert(sizeof(CDoubleSpringInterpolate) == 0x30, "expected CDoubleSpringInterpolate to be size 0x30");

// [Structure] class CAmbientShadow
class CAmbientShadow
{
public:
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inRatio, offset 0x0>
	class CDoubleSpringInterpolate m_inRatio;

	// <float m_fSetRatio, offset 0x30>
	float m_fSetRatio = 0;

	// <class TGmf* m_pPreGmf, offset 0x34>
	class TGmf* m_pPreGmf = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CAmbientShadow [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CAmbientShadow& InObject)
	{
		m_inRatio = InObject.m_inRatio;
		m_fSetRatio = InObject.m_fSetRatio;
		m_pPreGmf = InObject.m_pPreGmf;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CAmbientShadow>("CAmbientShadow")
			.addFunction("__tostring", &CAmbientShadow::ToString)
			.addFunction("GetPtrAddr", &CAmbientShadow::GetPtrAddr)
			.addProperty("m_inRatio", &CAmbientShadow::m_inRatio)
			.addProperty("m_fSetRatio", &CAmbientShadow::m_fSetRatio)
			.addProperty("m_pPreGmf", &CAmbientShadow::m_pPreGmf)
		.endClass();
	}
#endif
};
static_assert(sizeof(CAmbientShadow::m_inRatio) == 48, "expected CAmbientShadow::m_inRatio to be size 48");
static_assert(sizeof(CAmbientShadow::m_fSetRatio) == 4, "expected CAmbientShadow::m_fSetRatio to be size 4");
static_assert(sizeof(CAmbientShadow::m_pPreGmf) == 4, "expected CAmbientShadow::m_pPreGmf to be size 4");
static_assert(sizeof(CAmbientShadow) == 0x38, "expected CAmbientShadow to be size 0x38");

// [Structure] struct stCharaEffect
struct stCharaEffect
{
public:
	/// Struct member variables

	// <void* BeamKatanaPrimary, offset 0x0>
	void* BeamKatanaPrimary = nullptr;

	// <void* BeamKatanaSecondary, offset 0x4>
	void* BeamKatanaSecondary = nullptr;

	// <Unidentified data segment, offset 0x8>
private:
	char _UnidentifiedData_8[104];

public:
	// <class HrBattleIcon* BattleIcon, offset 0x70>
	class HrBattleIcon* BattleIcon = nullptr;

	// <Unidentified data segment, offset 0x74>
private:
	char _UnidentifiedData_116[176];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stCharaEffect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stCharaEffect& InObject)
	{
		BeamKatanaPrimary = InObject.BeamKatanaPrimary;
		BeamKatanaSecondary = InObject.BeamKatanaSecondary;
		BattleIcon = InObject.BattleIcon;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaEffect>("stCharaEffect")
			.addFunction("__tostring", &stCharaEffect::ToString)
			.addFunction("GetPtrAddr", &stCharaEffect::GetPtrAddr)
			// void type not supported in LuaBridge
			//.addProperty("BeamKatanaPrimary", &stCharaEffect::BeamKatanaPrimary)
			// void type not supported in LuaBridge
			//.addProperty("BeamKatanaSecondary", &stCharaEffect::BeamKatanaSecondary)
			.addProperty("BattleIcon", &stCharaEffect::BattleIcon)
		.endClass();
	}
#endif
};
static_assert(sizeof(stCharaEffect::BeamKatanaPrimary) == 4, "expected stCharaEffect::BeamKatanaPrimary to be size 4");
static_assert(sizeof(stCharaEffect::BeamKatanaSecondary) == 4, "expected stCharaEffect::BeamKatanaSecondary to be size 4");
static_assert(sizeof(stCharaEffect::BattleIcon) == 4, "expected stCharaEffect::BattleIcon to be size 4");
static_assert(sizeof(stCharaEffect) == 0x124, "expected stCharaEffect to be size 0x124");

// [Structure] class stCharaFileData
class stCharaFileData
{
public:
	/// Struct member variables

	// <class ghmGcFile* file, offset 0x0>
	class ghmGcFile* file = nullptr;

	// <void* pData, offset 0x4>
	void* pData = nullptr;

	// <class ghmResGroup* pRsl, offset 0x8>
	class ghmResGroup* pRsl = nullptr;

	// <class TGmf* pGmf, offset 0xc>
	class TGmf* pGmf = nullptr;

	// <class TGmf* pGmfDead, offset 0x10>
	class TGmf* pGmfDead = nullptr;

	// <class TGmf* pGmfWepR, offset 0x14>
	class TGmf* pGmfWepR = nullptr;

	// <class TGmf* pGmfWepL, offset 0x18>
	class TGmf* pGmfWepL = nullptr;

	// <int16_t motionNumMax, offset 0x1c>
	int16_t motionNumMax = 0;

	// <uint8_t readyDelete, offset 0x1e>
	uint8_t readyDelete = 0;

	// <Unidentified data segment, offset 0x1f>
private:
	char _UnidentifiedData_31[1];

public:
	// <int32_t sndFileHandle, offset 0x20>
	int32_t sndFileHandle = 0;

	// <struct HRCHARAVOICE* pVoice, offset 0x24>
	struct HRCHARAVOICE* pVoice = nullptr;

	// <char FileName[0x9], offset 0x28>
	char FileName[9];

	// <Unidentified data segment, offset 0x31>
private:
	char _UnidentifiedData_49[3];

public:
	// <class TGan** pGan, offset 0x34>
	class TGan** pGan = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class stCharaFileData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stCharaFileData& InObject)
	{
		file = InObject.file;
		pData = InObject.pData;
		pRsl = InObject.pRsl;
		pGmf = InObject.pGmf;
		pGmfDead = InObject.pGmfDead;
		pGmfWepR = InObject.pGmfWepR;
		pGmfWepL = InObject.pGmfWepL;
		motionNumMax = InObject.motionNumMax;
		readyDelete = InObject.readyDelete;
		sndFileHandle = InObject.sndFileHandle;
		pVoice = InObject.pVoice;
		pGan = InObject.pGan;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaFileData>("stCharaFileData")
			.addFunction("__tostring", &stCharaFileData::ToString)
			.addFunction("GetPtrAddr", &stCharaFileData::GetPtrAddr)
			.addProperty("file", &stCharaFileData::file)
			// void type not supported in LuaBridge
			//.addProperty("pData", &stCharaFileData::pData)
			.addProperty("pRsl", &stCharaFileData::pRsl)
			.addProperty("pGmf", &stCharaFileData::pGmf)
			.addProperty("pGmfDead", &stCharaFileData::pGmfDead)
			.addProperty("pGmfWepR", &stCharaFileData::pGmfWepR)
			.addProperty("pGmfWepL", &stCharaFileData::pGmfWepL)
			.addProperty("motionNumMax", &stCharaFileData::motionNumMax)
			.addProperty("readyDelete", &stCharaFileData::readyDelete)
			.addProperty("sndFileHandle", &stCharaFileData::sndFileHandle)
			.addProperty("pVoice", &stCharaFileData::pVoice)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("FileName", &stCharaFileData::FileName)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("pGan", &stCharaFileData::pGan)
		.endClass();
	}
#endif
};
static_assert(sizeof(stCharaFileData::file) == 4, "expected stCharaFileData::file to be size 4");
static_assert(sizeof(stCharaFileData::pData) == 4, "expected stCharaFileData::pData to be size 4");
static_assert(sizeof(stCharaFileData::pRsl) == 4, "expected stCharaFileData::pRsl to be size 4");
static_assert(sizeof(stCharaFileData::pGmf) == 4, "expected stCharaFileData::pGmf to be size 4");
static_assert(sizeof(stCharaFileData::pGmfDead) == 4, "expected stCharaFileData::pGmfDead to be size 4");
static_assert(sizeof(stCharaFileData::pGmfWepR) == 4, "expected stCharaFileData::pGmfWepR to be size 4");
static_assert(sizeof(stCharaFileData::pGmfWepL) == 4, "expected stCharaFileData::pGmfWepL to be size 4");
static_assert(sizeof(stCharaFileData::motionNumMax) == 2, "expected stCharaFileData::motionNumMax to be size 2");
static_assert(sizeof(stCharaFileData::readyDelete) == 1, "expected stCharaFileData::readyDelete to be size 1");
static_assert(sizeof(stCharaFileData::sndFileHandle) == 4, "expected stCharaFileData::sndFileHandle to be size 4");
static_assert(sizeof(stCharaFileData::pVoice) == 4, "expected stCharaFileData::pVoice to be size 4");
static_assert(sizeof(stCharaFileData::FileName) == 9, "expected stCharaFileData::FileName to be size 9");
static_assert(sizeof(stCharaFileData::pGan) == 4, "expected stCharaFileData::pGan to be size 4");
static_assert(sizeof(stCharaFileData) == 0x38, "expected stCharaFileData to be size 0x38");

// [Structure] class ghmSegment
class ghmSegment
{
public:
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mDir, offset 0xc>
	struct Vec mDir;

	// <float mExtent, offset 0x18>
	float mExtent = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmSegment [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmSegment& InObject)
	{
		mCenter = InObject.mCenter;
		mDir = InObject.mDir;
		mExtent = InObject.mExtent;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmSegment>("ghmSegment")
			.addFunction("__tostring", &ghmSegment::ToString)
			.addFunction("GetPtrAddr", &ghmSegment::GetPtrAddr)
			.addProperty("mCenter", &ghmSegment::mCenter)
			.addProperty("mDir", &ghmSegment::mDir)
			.addProperty("mExtent", &ghmSegment::mExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmSegment::mCenter) == 12, "expected ghmSegment::mCenter to be size 12");
static_assert(sizeof(ghmSegment::mDir) == 12, "expected ghmSegment::mDir to be size 12");
static_assert(sizeof(ghmSegment::mExtent) == 4, "expected ghmSegment::mExtent to be size 4");
static_assert(sizeof(ghmSegment) == 0x1c, "expected ghmSegment to be size 0x1c");

// [Structure] class ghmCapsule
class ghmCapsule
{
public:
	/// Struct member variables

	// <class ghmSegment mAxis, offset 0x0>
	class ghmSegment mAxis;

	// <float mRadius, offset 0x1c>
	float mRadius = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmCapsule [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmCapsule& InObject)
	{
		mAxis = InObject.mAxis;
		mRadius = InObject.mRadius;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmCapsule>("ghmCapsule")
			.addFunction("__tostring", &ghmCapsule::ToString)
			.addFunction("GetPtrAddr", &ghmCapsule::GetPtrAddr)
			.addProperty("mAxis", &ghmCapsule::mAxis)
			.addProperty("mRadius", &ghmCapsule::mRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmCapsule::mAxis) == 28, "expected ghmCapsule::mAxis to be size 28");
static_assert(sizeof(ghmCapsule::mRadius) == 4, "expected ghmCapsule::mRadius to be size 4");
static_assert(sizeof(ghmCapsule) == 0x20, "expected ghmCapsule to be size 0x20");

// [Structure] class ghmGcOctTreeNodeObj
class ghmGcOctTreeNodeObj
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x2], offset 0x0>
	void* (* field_0)[0x2];

	// <class ghmGcOctTreeNode* mpContainer, offset 0x4>
	class ghmGcOctTreeNode* mpContainer = nullptr;

	// <ghmGcOctTreeNodeObj* mpNext, offset 0x8>
	ghmGcOctTreeNodeObj* mpNext = nullptr;

	// <ghmGcOctTreeNodeObj* mpPrev, offset 0xc>
	ghmGcOctTreeNodeObj* mpPrev = nullptr;

	// <uint32_t mUserData, offset 0x10>
	uint32_t mUserData = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcOctTreeNodeObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcOctTreeNodeObj& InObject)
	{
		mpContainer = InObject.mpContainer;
		mpNext = InObject.mpNext;
		mpPrev = InObject.mpPrev;
		mUserData = InObject.mUserData;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTreeNodeObj>("ghmGcOctTreeNodeObj")
			.addFunction("__tostring", &ghmGcOctTreeNodeObj::ToString)
			.addFunction("GetPtrAddr", &ghmGcOctTreeNodeObj::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTreeNodeObj::field_0)
			.addProperty("mpContainer", &ghmGcOctTreeNodeObj::mpContainer)
			.addProperty("mpNext", &ghmGcOctTreeNodeObj::mpNext)
			.addProperty("mpPrev", &ghmGcOctTreeNodeObj::mpPrev)
			.addProperty("mUserData", &ghmGcOctTreeNodeObj::mUserData)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTreeNodeObj::field_0) == 4, "expected ghmGcOctTreeNodeObj::field_0 to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpContainer) == 4, "expected ghmGcOctTreeNodeObj::mpContainer to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpNext) == 4, "expected ghmGcOctTreeNodeObj::mpNext to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpPrev) == 4, "expected ghmGcOctTreeNodeObj::mpPrev to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mUserData) == 4, "expected ghmGcOctTreeNodeObj::mUserData to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj) == 0x14, "expected ghmGcOctTreeNodeObj to be size 0x14");

// [Structure] class ghmGcCollObj
class ghmGcCollObj : public ghmGcOctTreeNodeObj
{
public:
	// enum ghmGcCollObj::Type
	enum Type : uint32_t
	{
		// <TYPE_TRIANGLE = 0x0>
		TYPE_TRIANGLE = 0,

		// <TYPE_SPHERE = 0x1>
		TYPE_SPHERE = 1,

		// <TYPE_AABB = 0x2>
		TYPE_AABB = 2,

		// <TYPE_OBB = 0x3>
		TYPE_OBB = 3,

		// <TYPE_CAPSULE = 0x4>
		TYPE_CAPSULE = 4,

		// <TYPE_USER = 0x5>
		TYPE_USER = 5,

		// <TYPE_INVALID = 0xffffffffffffffff>
		TYPE_INVALID = UINT32_MAX

	};

	/// Struct member variables

	// <class ghmGcOctTreeNodeObj field_0, offset 0x0>
	// class ghmGcOctTreeNodeObj Super;

	// <enum ghmGcCollObj::Type mObjType, offset 0x14>
	enum ghmGcCollObj::Type mObjType;

	// <uint32_t mGroup, offset 0x18>
	uint32_t mGroup = 0;

	// <uint32_t mIgnoreGroup, offset 0x1c>
	uint32_t mIgnoreGroup = 0;

	// <int32_t (* mpHitTestCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*), offset 0x20>
	int32_t (* mpHitTestCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*);

	// <int32_t (* mpHitCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*), offset 0x24>
	int32_t (* mpHitCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*);

	// <struct Vec mVelocity, offset 0x28>
	struct Vec mVelocity;

	// <uint32_t mFlag, offset 0x34>
	uint32_t mFlag = 0;

	// <uint32_t mParam[0x2], offset 0x38>
	uint32_t mParam[2];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcCollObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcCollObj& InObject)
	{
		mObjType = InObject.mObjType;
		mGroup = InObject.mGroup;
		mIgnoreGroup = InObject.mIgnoreGroup;
		mVelocity = InObject.mVelocity;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmGcCollObj, ghmGcOctTreeNodeObj>("ghmGcCollObj")
			.addFunction("__tostring", &ghmGcCollObj::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObj::GetPtrAddr)
			.addProperty("mObjType", &ghmGcCollObj::mObjType)
			.addProperty("mGroup", &ghmGcCollObj::mGroup)
			.addProperty("mIgnoreGroup", &ghmGcCollObj::mIgnoreGroup)
			// delegates are not supported in LuaBridge
			//.addProperty("mpHitTestCallback", &ghmGcCollObj::mpHitTestCallback)
			// delegates are not supported in LuaBridge
			//.addProperty("mpHitCallback", &ghmGcCollObj::mpHitCallback)
			.addProperty("mVelocity", &ghmGcCollObj::mVelocity)
			.addProperty("mFlag", &ghmGcCollObj::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mParam", &ghmGcCollObj::mParam)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObj::mObjType) == 4, "expected ghmGcCollObj::mObjType to be size 4");
static_assert(sizeof(ghmGcCollObj::mGroup) == 4, "expected ghmGcCollObj::mGroup to be size 4");
static_assert(sizeof(ghmGcCollObj::mIgnoreGroup) == 4, "expected ghmGcCollObj::mIgnoreGroup to be size 4");
static_assert(sizeof(ghmGcCollObj::mpHitTestCallback) == 4, "expected ghmGcCollObj::mpHitTestCallback to be size 4");
static_assert(sizeof(ghmGcCollObj::mpHitCallback) == 4, "expected ghmGcCollObj::mpHitCallback to be size 4");
static_assert(sizeof(ghmGcCollObj::mVelocity) == 12, "expected ghmGcCollObj::mVelocity to be size 12");
static_assert(sizeof(ghmGcCollObj::mFlag) == 4, "expected ghmGcCollObj::mFlag to be size 4");
static_assert(sizeof(ghmGcCollObj::mParam) == 8, "expected ghmGcCollObj::mParam to be size 8");
static_assert(sizeof(ghmGcCollObj) == 0x40, "expected ghmGcCollObj to be size 0x40");

// [Structure] class ghmGcCollObjCapsule
class ghmGcCollObjCapsule : public ghmGcCollObj
{
public:
	/// Struct member variables

	// <class ghmGcCollObj field_0, offset 0x0>
	// class ghmGcCollObj Super;

	// <class ghmCapsule mShape, offset 0x40>
	class ghmCapsule mShape;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcCollObjCapsule [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcCollObjCapsule& InObject)
	{
		mShape = InObject.mShape;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmGcCollObjCapsule, ghmGcCollObj>("ghmGcCollObjCapsule")
			.addFunction("__tostring", &ghmGcCollObjCapsule::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObjCapsule::GetPtrAddr)
			.addProperty("mShape", &ghmGcCollObjCapsule::mShape)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjCapsule::mShape) == 32, "expected ghmGcCollObjCapsule::mShape to be size 32");
static_assert(sizeof(ghmGcCollObjCapsule) == 0x60, "expected ghmGcCollObjCapsule to be size 0x60");

// [Structure] class WAnim
class WAnim
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class WAnim [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WAnim& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WAnim>("WAnim")
			.addFunction("__tostring", &WAnim::ToString)
			.addFunction("GetPtrAddr", &WAnim::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &WAnim::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(WAnim::field_0) == 4, "expected WAnim::field_0 to be size 4");
static_assert(sizeof(WAnim) == 0x4, "expected WAnim to be size 0x4");

// [Structure] class WAnimF
class WAnimF : public WAnim
{
public:
	/// Struct member variables

	// <class WAnim field_0, offset 0x0>
	// class WAnim Super;

	// <float mCurValue, offset 0x4>
	float mCurValue = 0;

	// <float mDstValue, offset 0x8>
	float mDstValue = 0;

	// <float mSrcValue, offset 0xc>
	float mSrcValue = 0;

	// <uint32_t mCount, offset 0x10>
	uint32_t mCount = 0;

	// <uint32_t mTime, offset 0x14>
	uint32_t mTime = 0;

	// <int32_t mIpType, offset 0x18>
	int32_t mIpType = 0;

	// <float mMotionRate, offset 0x1c>
	float mMotionRate = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class WAnimF [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WAnimF& InObject)
	{
		mCurValue = InObject.mCurValue;
		mDstValue = InObject.mDstValue;
		mSrcValue = InObject.mSrcValue;
		mCount = InObject.mCount;
		mTime = InObject.mTime;
		mIpType = InObject.mIpType;
		mMotionRate = InObject.mMotionRate;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<WAnimF, WAnim>("WAnimF")
			.addFunction("__tostring", &WAnimF::ToString)
			.addFunction("GetPtrAddr", &WAnimF::GetPtrAddr)
			.addProperty("mCurValue", &WAnimF::mCurValue)
			.addProperty("mDstValue", &WAnimF::mDstValue)
			.addProperty("mSrcValue", &WAnimF::mSrcValue)
			.addProperty("mCount", &WAnimF::mCount)
			.addProperty("mTime", &WAnimF::mTime)
			.addProperty("mIpType", &WAnimF::mIpType)
			.addProperty("mMotionRate", &WAnimF::mMotionRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(WAnimF::mCurValue) == 4, "expected WAnimF::mCurValue to be size 4");
static_assert(sizeof(WAnimF::mDstValue) == 4, "expected WAnimF::mDstValue to be size 4");
static_assert(sizeof(WAnimF::mSrcValue) == 4, "expected WAnimF::mSrcValue to be size 4");
static_assert(sizeof(WAnimF::mCount) == 4, "expected WAnimF::mCount to be size 4");
static_assert(sizeof(WAnimF::mTime) == 4, "expected WAnimF::mTime to be size 4");
static_assert(sizeof(WAnimF::mIpType) == 4, "expected WAnimF::mIpType to be size 4");
static_assert(sizeof(WAnimF::mMotionRate) == 4, "expected WAnimF::mMotionRate to be size 4");
static_assert(sizeof(WAnimF) == 0x20, "expected WAnimF to be size 0x20");

// [Structure] struct stDamageInfo
struct stDamageInfo
{
public:
	/// Struct member variables

	// <float dmg, offset 0x0>
	float dmg = 0;

	// <int32_t dmgMot, offset 0x4>
	int32_t dmgMot = 0;

	// <int32_t grdMot, offset 0x8>
	int32_t grdMot = 0;

	// <int32_t atkMot, offset 0xc>
	int32_t atkMot = 0;

	// <int32_t atkKind, offset 0x10>
	int32_t atkKind = 0;

	// <float dmgDirec, offset 0x14>
	float dmgDirec = 0;

	// <float nockBackSpd, offset 0x18>
	float nockBackSpd = 0;

	// <float nockBackDst, offset 0x1c>
	float nockBackDst = 0;

	// <struct Vec nockBackDir, offset 0x20>
	struct Vec nockBackDir;

	// <float nockBackMasatu, offset 0x2c>
	float nockBackMasatu = 0;

	// <float upperPow, offset 0x30>
	float upperPow = 0;

	// <float upperPowLast, offset 0x34>
	float upperPowLast = 0;

	// <float upperPosY, offset 0x38>
	float upperPosY = 0;

	// <float grav, offset 0x3c>
	float grav = 0;

	// <uint8_t upper, offset 0x40>
	uint8_t upper = 0;

	// <Unidentified data segment, offset 0x41>
private:
	char _UnidentifiedData_65[3];

public:
	// <int32_t tick, offset 0x44>
	int32_t tick = 0;

	// <class WAnimF fade, offset 0x48>
	class WAnimF fade;

	// <uint8_t m_PiyoRequest, offset 0x68>
	uint8_t m_PiyoRequest = 0;

	// <uint8_t m_BikeDeadRequest, offset 0x69>
	uint8_t m_BikeDeadRequest = 0;

	// <Unidentified data segment, offset 0x6a>
private:
	char _UnidentifiedData_106[2];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stDamageInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stDamageInfo& InObject)
	{
		dmg = InObject.dmg;
		dmgMot = InObject.dmgMot;
		grdMot = InObject.grdMot;
		atkMot = InObject.atkMot;
		atkKind = InObject.atkKind;
		dmgDirec = InObject.dmgDirec;
		nockBackSpd = InObject.nockBackSpd;
		nockBackDst = InObject.nockBackDst;
		nockBackDir = InObject.nockBackDir;
		nockBackMasatu = InObject.nockBackMasatu;
		upperPow = InObject.upperPow;
		upperPowLast = InObject.upperPowLast;
		upperPosY = InObject.upperPosY;
		grav = InObject.grav;
		upper = InObject.upper;
		tick = InObject.tick;
		fade = InObject.fade;
		m_PiyoRequest = InObject.m_PiyoRequest;
		m_BikeDeadRequest = InObject.m_BikeDeadRequest;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stDamageInfo>("stDamageInfo")
			.addFunction("__tostring", &stDamageInfo::ToString)
			.addFunction("GetPtrAddr", &stDamageInfo::GetPtrAddr)
			.addProperty("dmg", &stDamageInfo::dmg)
			.addProperty("dmgMot", &stDamageInfo::dmgMot)
			.addProperty("grdMot", &stDamageInfo::grdMot)
			.addProperty("atkMot", &stDamageInfo::atkMot)
			.addProperty("atkKind", &stDamageInfo::atkKind)
			.addProperty("dmgDirec", &stDamageInfo::dmgDirec)
			.addProperty("nockBackSpd", &stDamageInfo::nockBackSpd)
			.addProperty("nockBackDst", &stDamageInfo::nockBackDst)
			.addProperty("nockBackDir", &stDamageInfo::nockBackDir)
			.addProperty("nockBackMasatu", &stDamageInfo::nockBackMasatu)
			.addProperty("upperPow", &stDamageInfo::upperPow)
			.addProperty("upperPowLast", &stDamageInfo::upperPowLast)
			.addProperty("upperPosY", &stDamageInfo::upperPosY)
			.addProperty("grav", &stDamageInfo::grav)
			.addProperty("upper", &stDamageInfo::upper)
			.addProperty("tick", &stDamageInfo::tick)
			.addProperty("fade", &stDamageInfo::fade)
			.addProperty("m_PiyoRequest", &stDamageInfo::m_PiyoRequest)
			.addProperty("m_BikeDeadRequest", &stDamageInfo::m_BikeDeadRequest)
		.endClass();
	}
#endif
};
static_assert(sizeof(stDamageInfo::dmg) == 4, "expected stDamageInfo::dmg to be size 4");
static_assert(sizeof(stDamageInfo::dmgMot) == 4, "expected stDamageInfo::dmgMot to be size 4");
static_assert(sizeof(stDamageInfo::grdMot) == 4, "expected stDamageInfo::grdMot to be size 4");
static_assert(sizeof(stDamageInfo::atkMot) == 4, "expected stDamageInfo::atkMot to be size 4");
static_assert(sizeof(stDamageInfo::atkKind) == 4, "expected stDamageInfo::atkKind to be size 4");
static_assert(sizeof(stDamageInfo::dmgDirec) == 4, "expected stDamageInfo::dmgDirec to be size 4");
static_assert(sizeof(stDamageInfo::nockBackSpd) == 4, "expected stDamageInfo::nockBackSpd to be size 4");
static_assert(sizeof(stDamageInfo::nockBackDst) == 4, "expected stDamageInfo::nockBackDst to be size 4");
static_assert(sizeof(stDamageInfo::nockBackDir) == 12, "expected stDamageInfo::nockBackDir to be size 12");
static_assert(sizeof(stDamageInfo::nockBackMasatu) == 4, "expected stDamageInfo::nockBackMasatu to be size 4");
static_assert(sizeof(stDamageInfo::upperPow) == 4, "expected stDamageInfo::upperPow to be size 4");
static_assert(sizeof(stDamageInfo::upperPowLast) == 4, "expected stDamageInfo::upperPowLast to be size 4");
static_assert(sizeof(stDamageInfo::upperPosY) == 4, "expected stDamageInfo::upperPosY to be size 4");
static_assert(sizeof(stDamageInfo::grav) == 4, "expected stDamageInfo::grav to be size 4");
static_assert(sizeof(stDamageInfo::upper) == 1, "expected stDamageInfo::upper to be size 1");
static_assert(sizeof(stDamageInfo::tick) == 4, "expected stDamageInfo::tick to be size 4");
static_assert(sizeof(stDamageInfo::fade) == 32, "expected stDamageInfo::fade to be size 32");
static_assert(sizeof(stDamageInfo::m_PiyoRequest) == 1, "expected stDamageInfo::m_PiyoRequest to be size 1");
static_assert(sizeof(stDamageInfo::m_BikeDeadRequest) == 1, "expected stDamageInfo::m_BikeDeadRequest to be size 1");
static_assert(sizeof(stDamageInfo) == 0x6c, "expected stDamageInfo to be size 0x6c");

// [Structure] class ghmTriangle
class ghmTriangle
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[36];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmTriangle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmTriangle& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmTriangle>("ghmTriangle")
			.addFunction("__tostring", &ghmTriangle::ToString)
			.addFunction("GetPtrAddr", &ghmTriangle::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmTriangle) == 0x24, "expected ghmTriangle to be size 0x24");

// [Structure] class ghmPlane
class ghmPlane
{
public:
	/// Struct member variables

	// <struct Vec mNormal, offset 0x0>
	struct Vec mNormal;

	// <float mDist, offset 0xc>
	float mDist = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmPlane [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmPlane& InObject)
	{
		mNormal = InObject.mNormal;
		mDist = InObject.mDist;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmPlane>("ghmPlane")
			.addFunction("__tostring", &ghmPlane::ToString)
			.addFunction("GetPtrAddr", &ghmPlane::GetPtrAddr)
			.addProperty("mNormal", &ghmPlane::mNormal)
			.addProperty("mDist", &ghmPlane::mDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmPlane::mNormal) == 12, "expected ghmPlane::mNormal to be size 12");
static_assert(sizeof(ghmPlane::mDist) == 4, "expected ghmPlane::mDist to be size 4");
static_assert(sizeof(ghmPlane) == 0x10, "expected ghmPlane to be size 0x10");

// [Structure] class ghmGcCollObjHitResultObj
class ghmGcCollObjHitResultObj
{
public:
	/// Struct member variables

	// <class ghmPlane mPlane, offset 0x0>
	class ghmPlane mPlane;

	// <class ghmTriangle mTriangle, offset 0x10>
	class ghmTriangle mTriangle;

	// <struct Vec mPoint, offset 0x34>
	struct Vec mPoint;

	// <float mRate, offset 0x40>
	float mRate = 0;

	// <uint32_t mAttr, offset 0x44>
	uint32_t mAttr = 0;

	// <class ghmGcCollObj* mpObj, offset 0x48>
	class ghmGcCollObj* mpObj = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcCollObjHitResultObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcCollObjHitResultObj& InObject)
	{
		mPlane = InObject.mPlane;
		mTriangle = InObject.mTriangle;
		mPoint = InObject.mPoint;
		mRate = InObject.mRate;
		mAttr = InObject.mAttr;
		mpObj = InObject.mpObj;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcCollObjHitResultObj>("ghmGcCollObjHitResultObj")
			.addFunction("__tostring", &ghmGcCollObjHitResultObj::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObjHitResultObj::GetPtrAddr)
			.addProperty("mPlane", &ghmGcCollObjHitResultObj::mPlane)
			.addProperty("mTriangle", &ghmGcCollObjHitResultObj::mTriangle)
			.addProperty("mPoint", &ghmGcCollObjHitResultObj::mPoint)
			.addProperty("mRate", &ghmGcCollObjHitResultObj::mRate)
			.addProperty("mAttr", &ghmGcCollObjHitResultObj::mAttr)
			.addProperty("mpObj", &ghmGcCollObjHitResultObj::mpObj)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjHitResultObj::mPlane) == 16, "expected ghmGcCollObjHitResultObj::mPlane to be size 16");
static_assert(sizeof(ghmGcCollObjHitResultObj::mTriangle) == 36, "expected ghmGcCollObjHitResultObj::mTriangle to be size 36");
static_assert(sizeof(ghmGcCollObjHitResultObj::mPoint) == 12, "expected ghmGcCollObjHitResultObj::mPoint to be size 12");
static_assert(sizeof(ghmGcCollObjHitResultObj::mRate) == 4, "expected ghmGcCollObjHitResultObj::mRate to be size 4");
static_assert(sizeof(ghmGcCollObjHitResultObj::mAttr) == 4, "expected ghmGcCollObjHitResultObj::mAttr to be size 4");
static_assert(sizeof(ghmGcCollObjHitResultObj::mpObj) == 4, "expected ghmGcCollObjHitResultObj::mpObj to be size 4");
static_assert(sizeof(ghmGcCollObjHitResultObj) == 0x4c, "expected ghmGcCollObjHitResultObj to be size 0x4c");

// enum enCharaCondition
enum enCharaCondition : uint32_t
{
	// <eGood = 0x0>
	eGood = 0,

	// <eDamaging = 0x1>
	eDamaging = 1,

	// <eDying = 0x2>
	eDying = 2,

	// <eDead = 0x3>
	eDead = 3,

	// <eBossDead = 0x4>
	eBossDead = 4,

	// <eConditionInit = 0x5>
	eConditionInit = 5,

	// <eConditionMax = 0x6>
	eConditionMax = 6

};

// [Structure] struct stVec
struct stVec
{
public:
	/// Struct member variables

	// <class WAnimF x, offset 0x0>
	class WAnimF x;

	// <class WAnimF y, offset 0x20>
	class WAnimF y;

	// <class WAnimF z, offset 0x40>
	class WAnimF z;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stVec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stVec& InObject)
	{
		x = InObject.x;
		y = InObject.y;
		z = InObject.z;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stVec>("stVec")
			.addFunction("__tostring", &stVec::ToString)
			.addFunction("GetPtrAddr", &stVec::GetPtrAddr)
			.addProperty("x", &stVec::x)
			.addProperty("y", &stVec::y)
			.addProperty("z", &stVec::z)
		.endClass();
	}
#endif
};
static_assert(sizeof(stVec::x) == 32, "expected stVec::x to be size 32");
static_assert(sizeof(stVec::y) == 32, "expected stVec::y to be size 32");
static_assert(sizeof(stVec::z) == 32, "expected stVec::z to be size 32");
static_assert(sizeof(stVec) == 0x60, "expected stVec to be size 0x60");

// [Structure] struct Quaternion
struct Quaternion
{
public:
	/// Struct member variables

	// <float x, offset 0x0>
	float x = 0;

	// <float y, offset 0x4>
	float y = 0;

	// <float z, offset 0x8>
	float z = 0;

	// <float w, offset 0xc>
	float w = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct Quaternion [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(Quaternion& InObject)
	{
		x = InObject.x;
		y = InObject.y;
		z = InObject.z;
		w = InObject.w;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Quaternion>("Quaternion")
			.addFunction("__tostring", &Quaternion::ToString)
			.addFunction("GetPtrAddr", &Quaternion::GetPtrAddr)
			.addProperty("x", &Quaternion::x)
			.addProperty("y", &Quaternion::y)
			.addProperty("z", &Quaternion::z)
			.addProperty("w", &Quaternion::w)
		.endClass();
	}
#endif
};
static_assert(sizeof(Quaternion::x) == 4, "expected Quaternion::x to be size 4");
static_assert(sizeof(Quaternion::y) == 4, "expected Quaternion::y to be size 4");
static_assert(sizeof(Quaternion::z) == 4, "expected Quaternion::z to be size 4");
static_assert(sizeof(Quaternion::w) == 4, "expected Quaternion::w to be size 4");
static_assert(sizeof(Quaternion) == 0x10, "expected Quaternion to be size 0x10");

// [Structure] struct stCharaStatus
/// <summary>
/// Contains position, rotation, hp, flags, etc
/// </summary>
struct stCharaStatus
{
public:
	/// Struct member variables

	// <int32_t resNo, offset 0x0>
	int32_t resNo = 0;

	// <int32_t datNo, offset 0x4>
	int32_t datNo = 0;

	// <enum enCharaType charaType, offset 0x8>
	enum enCharaType charaType;

	// <int16_t zakoWepType, offset 0xc>
	int16_t zakoWepType = 0;

	// <Unidentified data segment, offset 0xe>
private:
	char _UnidentifiedData_14[2];

public:
	// <float maxHp, offset 0x10>
	float maxHp = 0;

	// <float hp, offset 0x14>
	float hp = 0;

	// <int16_t money, offset 0x18>
	int16_t money = 0;

	// <int16_t dropMoney, offset 0x1a>
	int16_t dropMoney = 0;

	// <float tension, offset 0x1c>
	float tension = 0;

	// <float hajikiCount, offset 0x20>
	float hajikiCount = 0;

	// <uint8_t alwaysCheckHitColl, offset 0x24>
	uint8_t alwaysCheckHitColl = 0;

	// <Unidentified data segment, offset 0x25>
private:
	char _UnidentifiedData_37[3];

public:
	// <struct Vec pos, offset 0x28>
	struct Vec pos;

	// <struct Vec beforePos, offset 0x34>
	struct Vec beforePos;

	// <struct Vec oldPos, offset 0x40>
	struct Vec oldPos;

	// <struct Vec navelPos, offset 0x4c>
	struct Vec navelPos;

	// <struct Vec brainPos, offset 0x58>
	struct Vec brainPos;

	// <struct Vec rot, offset 0x64>
	struct Vec rot;

	// <struct Vec scale, offset 0x70>
	struct Vec scale;

	// <struct Quaternion qRot, offset 0x7c>
	struct Quaternion qRot;

	// <float movSpd, offset 0x8c>
	float movSpd = 0;

	// <float hitSize, offset 0x90>
	float hitSize = 0;

	// <float height, offset 0x94>
	float height = 0;

	// <struct stVec aPos, offset 0x98>
	struct stVec aPos;

	// <struct stVec aRot, offset 0xf8>
	struct stVec aRot;

	// <int32_t enterPattern, offset 0x158>
	int32_t enterPattern = 0;

	// <float reactionDist, offset 0x15c>
	float reactionDist = 0;

	// <int32_t itemNo, offset 0x160>
	int32_t itemNo = 0;

	// <int32_t mAiDefBasic, offset 0x164>
	int32_t mAiDefBasic = 0;

	// <int32_t mAiDefCurrent, offset 0x168>
	int32_t mAiDefCurrent = 0;

	// <int32_t mAiDefTick, offset 0x16c>
	int32_t mAiDefTick = 0;

	// <int32_t mAiDefBaseTick, offset 0x170>
	int32_t mAiDefBaseTick = 0;

	// <float mAiDamageCount, offset 0x174>
	float mAiDamageCount = 0;

	// <char* pScriptProc, offset 0x178>
	char* pScriptProc = nullptr;

	// <int32_t tsubazeriNum, offset 0x17c>
	int32_t tsubazeriNum = 0;

	// <int32_t DamageAcceptFrame, offset 0x180>
	int32_t DamageAcceptFrame = 0;

	// <int32_t motionNo, offset 0x184>
	int32_t motionNo = 0;

	// <char motionBrendNum, offset 0x188>
	char motionBrendNum;

	// <Unidentified data segment, offset 0x189>
private:
	char _UnidentifiedData_393[3];

public:
	// <float motSpd, offset 0x18c>
	float motSpd = 0;

	// <float subMotSpd, offset 0x190>
	float subMotSpd = 0;

	// <enum enCharaCondition condition, offset 0x194>
	enum enCharaCondition condition;

	// <class ghmGcCollObj* footHitResultObj, offset 0x198>
	class ghmGcCollObj* footHitResultObj = nullptr;

	// <class ghmGcCollObjHitResult* footHitResult, offset 0x19c>
	class ghmGcCollObjHitResult* footHitResult = nullptr;

	// <class ghmGcCollObjHitResultObj footHitResultObj2, offset 0x1a0>
	class ghmGcCollObjHitResultObj footHitResultObj2;

	// <class ghmGcCollObjHitResultObj HitWallObj, offset 0x1ec>
	class ghmGcCollObjHitResultObj HitWallObj;

	// <struct WGclMaterialSpec* hitWallMaterial, offset 0x238>
	struct WGclMaterialSpec* hitWallMaterial = nullptr;

	// <struct Vec HitWallNormal, offset 0x23c>
	struct Vec HitWallNormal;

	// <struct stDamageInfo dmgInfo, offset 0x248>
	struct stDamageInfo dmgInfo;

	// <struct Vec mYukaNormal, offset 0x2b4>
	struct Vec mYukaNormal;

	// <int32_t mFootNumber, offset 0x2c0>
	int32_t mFootNumber = 0;

	// <int32_t movTick, offset 0x2c4>
	int32_t movTick = 0;

	// <int16_t hitNum, offset 0x2c8>
	int16_t hitNum = 0;

	// <Unidentified data segment, offset 0x2ca>
private:
	char _UnidentifiedData_714[2];

public:
	// <class ghmGcCollObjCapsule hitColl, offset 0x2cc>
	class ghmGcCollObjCapsule hitColl;

	// <int32_t mAiAtkLv, offset 0x32c>
	int32_t mAiAtkLv = 0;

	// <int32_t mAiAtkClass, offset 0x330>
	int32_t mAiAtkClass = 0;

	// <int16_t AtkAi[0xa], offset 0x334>
	int16_t AtkAi[10];

	// <int32_t renderSkipCounter, offset 0x348>
	int32_t renderSkipCounter = 0;

	// <float renderSkipMotSpd, offset 0x34c>
	float renderSkipMotSpd = 0;

	// <int32_t frameStop, offset 0x350>
	int32_t frameStop = 0;

	// <float lockOnDistance, offset 0x354>
	float lockOnDistance = 0;

	// <float lockOnDistanceHi, offset 0x358>
	float lockOnDistanceHi = 0;

	// <float lockOnDistanceLow, offset 0x35c>
	float lockOnDistanceLow = 0;

	// <float DrawYAdjust, offset 0x360>
	float DrawYAdjust = 0;

	// <uint8_t bBloom, offset 0x364>
	uint8_t bBloom = 0;

	// <uint8_t JumpBlockHit, offset 0x365>
	uint8_t JumpBlockHit = 0;

	// <Unidentified data segment, offset 0x366>
private:
	char _UnidentifiedData_870[2];

public:
	// <float AtkDisAdjust, offset 0x368>
	float AtkDisAdjust = 0;

	// <float TubaFrmOffset, offset 0x36c>
	float TubaFrmOffset = 0;

	// <int32_t motionNoNpc, offset 0x370>
	int32_t motionNoNpc = 0;

	// <class WAnimF semiTransRate, offset 0x374>
	class WAnimF semiTransRate;

	// <uint32_t flag[0x2], offset 0x394>
	uint32_t flag[2];

	/// 0 Functions

	/// Meta

	std::string GetCharaTypeStr() const
	{
	switch (charaType)
	{
	case enCharaType::eCharaTypePC: return "PC";
	case enCharaType::eCharaTypeCommonNpc: return "CommonNpc";
	case enCharaType::eCharaTypeCmnObj: return "CmnObj";
	case enCharaType::eCharaTypeHelicopter: return "Helicopter";
	case enCharaType::eCharaTypePatroller: return "Patroller";
	case enCharaType::eCharaTypePlayerWeapon: return "PlayerWeapon";
	case enCharaType::eCustomColliderObject: return "CustomColliderObject";
	case enCharaType::eCharaTypeFCA: return "FCA";
	case enCharaType::eCharaTypeCommonNpc_PIZZA: return "Common NPC (Pizza)";
	case enCharaType::eCharaTypeZKPipe: return "Zako (Pipe)";
	case enCharaType::eCharaTypeZKBat: return "Zako (Bat)";
	case enCharaType::eCharaTypeNone: return "None";
	}
	if (charaType >= enCharaType::CHARACTER_TYPE_BOSS_BEGIN && charaType <= enCharaType::CHARACTER_TYPE_BOSS_END)
	return "Unknown Boss";
	if (charaType >= enCharaType::CHARACTER_TYPE_ZAKO_BEGIN && charaType <= enCharaType::CHARACTER_TYPE_ZAKO_END)
	{ std::stringstream stream; stream << "Unknown Zako " << (int)charaType; return stream.str(); }
	std::stringstream stream; stream << "Unknown " << (int)charaType; return stream.str();
	}
	bool IsZako() const { return charaType >= enCharaType::CHARACTER_TYPE_ZAKO_BEGIN && charaType <= enCharaType::CHARACTER_TYPE_ZAKO_END; }
	std::string ToString() const { std::stringstream stream; stream << "struct stCharaStatus (charaType: " << GetCharaTypeStr() << ", pos: " << pos.ToString() << ") [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stCharaStatus& InObject)
	{
		resNo = InObject.resNo;
		datNo = InObject.datNo;
		charaType = InObject.charaType;
		zakoWepType = InObject.zakoWepType;
		maxHp = InObject.maxHp;
		hp = InObject.hp;
		money = InObject.money;
		dropMoney = InObject.dropMoney;
		tension = InObject.tension;
		hajikiCount = InObject.hajikiCount;
		alwaysCheckHitColl = InObject.alwaysCheckHitColl;
		pos = InObject.pos;
		beforePos = InObject.beforePos;
		oldPos = InObject.oldPos;
		navelPos = InObject.navelPos;
		brainPos = InObject.brainPos;
		rot = InObject.rot;
		scale = InObject.scale;
		qRot = InObject.qRot;
		movSpd = InObject.movSpd;
		hitSize = InObject.hitSize;
		height = InObject.height;
		aPos = InObject.aPos;
		aRot = InObject.aRot;
		enterPattern = InObject.enterPattern;
		reactionDist = InObject.reactionDist;
		itemNo = InObject.itemNo;
		mAiDefBasic = InObject.mAiDefBasic;
		mAiDefCurrent = InObject.mAiDefCurrent;
		mAiDefTick = InObject.mAiDefTick;
		mAiDefBaseTick = InObject.mAiDefBaseTick;
		mAiDamageCount = InObject.mAiDamageCount;
		pScriptProc = InObject.pScriptProc;
		tsubazeriNum = InObject.tsubazeriNum;
		DamageAcceptFrame = InObject.DamageAcceptFrame;
		motionNo = InObject.motionNo;
		motionBrendNum = InObject.motionBrendNum;
		motSpd = InObject.motSpd;
		subMotSpd = InObject.subMotSpd;
		condition = InObject.condition;
		footHitResultObj = InObject.footHitResultObj;
		footHitResult = InObject.footHitResult;
		footHitResultObj2 = InObject.footHitResultObj2;
		HitWallObj = InObject.HitWallObj;
		hitWallMaterial = InObject.hitWallMaterial;
		HitWallNormal = InObject.HitWallNormal;
		dmgInfo = InObject.dmgInfo;
		mYukaNormal = InObject.mYukaNormal;
		mFootNumber = InObject.mFootNumber;
		movTick = InObject.movTick;
		hitNum = InObject.hitNum;
		hitColl = InObject.hitColl;
		mAiAtkLv = InObject.mAiAtkLv;
		mAiAtkClass = InObject.mAiAtkClass;
		renderSkipCounter = InObject.renderSkipCounter;
		renderSkipMotSpd = InObject.renderSkipMotSpd;
		frameStop = InObject.frameStop;
		lockOnDistance = InObject.lockOnDistance;
		lockOnDistanceHi = InObject.lockOnDistanceHi;
		lockOnDistanceLow = InObject.lockOnDistanceLow;
		DrawYAdjust = InObject.DrawYAdjust;
		bBloom = InObject.bBloom;
		JumpBlockHit = InObject.JumpBlockHit;
		AtkDisAdjust = InObject.AtkDisAdjust;
		TubaFrmOffset = InObject.TubaFrmOffset;
		motionNoNpc = InObject.motionNoNpc;
		semiTransRate = InObject.semiTransRate;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaStatus>("stCharaStatus")
			.addFunction("__tostring", &stCharaStatus::ToString)
			.addFunction("GetPtrAddr", &stCharaStatus::GetPtrAddr)
			.addProperty("resNo", &stCharaStatus::resNo)
			.addProperty("datNo", &stCharaStatus::datNo)
			.addProperty("charaType", &stCharaStatus::charaType)
			.addProperty("zakoWepType", &stCharaStatus::zakoWepType)
			.addProperty("maxHp", &stCharaStatus::maxHp)
			.addProperty("hp", &stCharaStatus::hp)
			.addProperty("money", &stCharaStatus::money)
			.addProperty("dropMoney", &stCharaStatus::dropMoney)
			.addProperty("tension", &stCharaStatus::tension)
			.addProperty("hajikiCount", &stCharaStatus::hajikiCount)
			.addProperty("alwaysCheckHitColl", &stCharaStatus::alwaysCheckHitColl)
			.addProperty("pos", &stCharaStatus::pos)
			.addProperty("beforePos", &stCharaStatus::beforePos)
			.addProperty("oldPos", &stCharaStatus::oldPos)
			.addProperty("navelPos", &stCharaStatus::navelPos)
			.addProperty("brainPos", &stCharaStatus::brainPos)
			.addProperty("rot", &stCharaStatus::rot)
			.addProperty("scale", &stCharaStatus::scale)
			.addProperty("qRot", &stCharaStatus::qRot)
			.addProperty("movSpd", &stCharaStatus::movSpd)
			.addProperty("hitSize", &stCharaStatus::hitSize)
			.addProperty("height", &stCharaStatus::height)
			.addProperty("aPos", &stCharaStatus::aPos)
			.addProperty("aRot", &stCharaStatus::aRot)
			.addProperty("enterPattern", &stCharaStatus::enterPattern)
			.addProperty("reactionDist", &stCharaStatus::reactionDist)
			.addProperty("itemNo", &stCharaStatus::itemNo)
			.addProperty("mAiDefBasic", &stCharaStatus::mAiDefBasic)
			.addProperty("mAiDefCurrent", &stCharaStatus::mAiDefCurrent)
			.addProperty("mAiDefTick", &stCharaStatus::mAiDefTick)
			.addProperty("mAiDefBaseTick", &stCharaStatus::mAiDefBaseTick)
			.addProperty("mAiDamageCount", &stCharaStatus::mAiDamageCount)
			// char* type not supported in LuaBridge
			//.addProperty("pScriptProc", &stCharaStatus::pScriptProc)
			.addProperty("tsubazeriNum", &stCharaStatus::tsubazeriNum)
			.addProperty("DamageAcceptFrame", &stCharaStatus::DamageAcceptFrame)
			.addProperty("motionNo", &stCharaStatus::motionNo)
			.addProperty("motionBrendNum", &stCharaStatus::motionBrendNum)
			.addProperty("motSpd", &stCharaStatus::motSpd)
			.addProperty("subMotSpd", &stCharaStatus::subMotSpd)
			.addProperty("condition", &stCharaStatus::condition)
			.addProperty("footHitResultObj", &stCharaStatus::footHitResultObj)
			.addProperty("footHitResult", &stCharaStatus::footHitResult)
			.addProperty("footHitResultObj2", &stCharaStatus::footHitResultObj2)
			.addProperty("HitWallObj", &stCharaStatus::HitWallObj)
			.addProperty("hitWallMaterial", &stCharaStatus::hitWallMaterial)
			.addProperty("HitWallNormal", &stCharaStatus::HitWallNormal)
			.addProperty("dmgInfo", &stCharaStatus::dmgInfo)
			.addProperty("mYukaNormal", &stCharaStatus::mYukaNormal)
			.addProperty("mFootNumber", &stCharaStatus::mFootNumber)
			.addProperty("movTick", &stCharaStatus::movTick)
			.addProperty("hitNum", &stCharaStatus::hitNum)
			.addProperty("hitColl", &stCharaStatus::hitColl)
			.addProperty("mAiAtkLv", &stCharaStatus::mAiAtkLv)
			.addProperty("mAiAtkClass", &stCharaStatus::mAiAtkClass)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("AtkAi", &stCharaStatus::AtkAi)
			.addProperty("renderSkipCounter", &stCharaStatus::renderSkipCounter)
			.addProperty("renderSkipMotSpd", &stCharaStatus::renderSkipMotSpd)
			.addProperty("frameStop", &stCharaStatus::frameStop)
			.addProperty("lockOnDistance", &stCharaStatus::lockOnDistance)
			.addProperty("lockOnDistanceHi", &stCharaStatus::lockOnDistanceHi)
			.addProperty("lockOnDistanceLow", &stCharaStatus::lockOnDistanceLow)
			.addProperty("DrawYAdjust", &stCharaStatus::DrawYAdjust)
			.addProperty("bBloom", &stCharaStatus::bBloom)
			.addProperty("JumpBlockHit", &stCharaStatus::JumpBlockHit)
			.addProperty("AtkDisAdjust", &stCharaStatus::AtkDisAdjust)
			.addProperty("TubaFrmOffset", &stCharaStatus::TubaFrmOffset)
			.addProperty("motionNoNpc", &stCharaStatus::motionNoNpc)
			.addProperty("semiTransRate", &stCharaStatus::semiTransRate)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("flag", &stCharaStatus::flag)
			.addFunction("GetCharaTypeStr", &stCharaStatus::GetCharaTypeStr)
			.addFunction("IsZako", &stCharaStatus::IsZako)
		.endClass();
	}
#endif
};
static_assert(sizeof(stCharaStatus::resNo) == 4, "expected stCharaStatus::resNo to be size 4");
static_assert(sizeof(stCharaStatus::datNo) == 4, "expected stCharaStatus::datNo to be size 4");
static_assert(sizeof(stCharaStatus::charaType) == 4, "expected stCharaStatus::charaType to be size 4");
static_assert(sizeof(stCharaStatus::zakoWepType) == 2, "expected stCharaStatus::zakoWepType to be size 2");
static_assert(sizeof(stCharaStatus::maxHp) == 4, "expected stCharaStatus::maxHp to be size 4");
static_assert(sizeof(stCharaStatus::hp) == 4, "expected stCharaStatus::hp to be size 4");
static_assert(sizeof(stCharaStatus::money) == 2, "expected stCharaStatus::money to be size 2");
static_assert(sizeof(stCharaStatus::dropMoney) == 2, "expected stCharaStatus::dropMoney to be size 2");
static_assert(sizeof(stCharaStatus::tension) == 4, "expected stCharaStatus::tension to be size 4");
static_assert(sizeof(stCharaStatus::hajikiCount) == 4, "expected stCharaStatus::hajikiCount to be size 4");
static_assert(sizeof(stCharaStatus::alwaysCheckHitColl) == 1, "expected stCharaStatus::alwaysCheckHitColl to be size 1");
static_assert(sizeof(stCharaStatus::pos) == 12, "expected stCharaStatus::pos to be size 12");
static_assert(sizeof(stCharaStatus::beforePos) == 12, "expected stCharaStatus::beforePos to be size 12");
static_assert(sizeof(stCharaStatus::oldPos) == 12, "expected stCharaStatus::oldPos to be size 12");
static_assert(sizeof(stCharaStatus::navelPos) == 12, "expected stCharaStatus::navelPos to be size 12");
static_assert(sizeof(stCharaStatus::brainPos) == 12, "expected stCharaStatus::brainPos to be size 12");
static_assert(sizeof(stCharaStatus::rot) == 12, "expected stCharaStatus::rot to be size 12");
static_assert(sizeof(stCharaStatus::scale) == 12, "expected stCharaStatus::scale to be size 12");
static_assert(sizeof(stCharaStatus::qRot) == 16, "expected stCharaStatus::qRot to be size 16");
static_assert(sizeof(stCharaStatus::movSpd) == 4, "expected stCharaStatus::movSpd to be size 4");
static_assert(sizeof(stCharaStatus::hitSize) == 4, "expected stCharaStatus::hitSize to be size 4");
static_assert(sizeof(stCharaStatus::height) == 4, "expected stCharaStatus::height to be size 4");
static_assert(sizeof(stCharaStatus::aPos) == 96, "expected stCharaStatus::aPos to be size 96");
static_assert(sizeof(stCharaStatus::aRot) == 96, "expected stCharaStatus::aRot to be size 96");
static_assert(sizeof(stCharaStatus::enterPattern) == 4, "expected stCharaStatus::enterPattern to be size 4");
static_assert(sizeof(stCharaStatus::reactionDist) == 4, "expected stCharaStatus::reactionDist to be size 4");
static_assert(sizeof(stCharaStatus::itemNo) == 4, "expected stCharaStatus::itemNo to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefBasic) == 4, "expected stCharaStatus::mAiDefBasic to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefCurrent) == 4, "expected stCharaStatus::mAiDefCurrent to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefTick) == 4, "expected stCharaStatus::mAiDefTick to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefBaseTick) == 4, "expected stCharaStatus::mAiDefBaseTick to be size 4");
static_assert(sizeof(stCharaStatus::mAiDamageCount) == 4, "expected stCharaStatus::mAiDamageCount to be size 4");
static_assert(sizeof(stCharaStatus::pScriptProc) == 4, "expected stCharaStatus::pScriptProc to be size 4");
static_assert(sizeof(stCharaStatus::tsubazeriNum) == 4, "expected stCharaStatus::tsubazeriNum to be size 4");
static_assert(sizeof(stCharaStatus::DamageAcceptFrame) == 4, "expected stCharaStatus::DamageAcceptFrame to be size 4");
static_assert(sizeof(stCharaStatus::motionNo) == 4, "expected stCharaStatus::motionNo to be size 4");
static_assert(sizeof(stCharaStatus::motionBrendNum) == 1, "expected stCharaStatus::motionBrendNum to be size 1");
static_assert(sizeof(stCharaStatus::motSpd) == 4, "expected stCharaStatus::motSpd to be size 4");
static_assert(sizeof(stCharaStatus::subMotSpd) == 4, "expected stCharaStatus::subMotSpd to be size 4");
static_assert(sizeof(stCharaStatus::condition) == 4, "expected stCharaStatus::condition to be size 4");
static_assert(sizeof(stCharaStatus::footHitResultObj) == 4, "expected stCharaStatus::footHitResultObj to be size 4");
static_assert(sizeof(stCharaStatus::footHitResult) == 4, "expected stCharaStatus::footHitResult to be size 4");
static_assert(sizeof(stCharaStatus::footHitResultObj2) == 76, "expected stCharaStatus::footHitResultObj2 to be size 76");
static_assert(sizeof(stCharaStatus::HitWallObj) == 76, "expected stCharaStatus::HitWallObj to be size 76");
static_assert(sizeof(stCharaStatus::hitWallMaterial) == 4, "expected stCharaStatus::hitWallMaterial to be size 4");
static_assert(sizeof(stCharaStatus::HitWallNormal) == 12, "expected stCharaStatus::HitWallNormal to be size 12");
static_assert(sizeof(stCharaStatus::dmgInfo) == 108, "expected stCharaStatus::dmgInfo to be size 108");
static_assert(sizeof(stCharaStatus::mYukaNormal) == 12, "expected stCharaStatus::mYukaNormal to be size 12");
static_assert(sizeof(stCharaStatus::mFootNumber) == 4, "expected stCharaStatus::mFootNumber to be size 4");
static_assert(sizeof(stCharaStatus::movTick) == 4, "expected stCharaStatus::movTick to be size 4");
static_assert(sizeof(stCharaStatus::hitNum) == 2, "expected stCharaStatus::hitNum to be size 2");
static_assert(sizeof(stCharaStatus::hitColl) == 96, "expected stCharaStatus::hitColl to be size 96");
static_assert(sizeof(stCharaStatus::mAiAtkLv) == 4, "expected stCharaStatus::mAiAtkLv to be size 4");
static_assert(sizeof(stCharaStatus::mAiAtkClass) == 4, "expected stCharaStatus::mAiAtkClass to be size 4");
static_assert(sizeof(stCharaStatus::AtkAi) == 20, "expected stCharaStatus::AtkAi to be size 20");
static_assert(sizeof(stCharaStatus::renderSkipCounter) == 4, "expected stCharaStatus::renderSkipCounter to be size 4");
static_assert(sizeof(stCharaStatus::renderSkipMotSpd) == 4, "expected stCharaStatus::renderSkipMotSpd to be size 4");
static_assert(sizeof(stCharaStatus::frameStop) == 4, "expected stCharaStatus::frameStop to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistance) == 4, "expected stCharaStatus::lockOnDistance to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistanceHi) == 4, "expected stCharaStatus::lockOnDistanceHi to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistanceLow) == 4, "expected stCharaStatus::lockOnDistanceLow to be size 4");
static_assert(sizeof(stCharaStatus::DrawYAdjust) == 4, "expected stCharaStatus::DrawYAdjust to be size 4");
static_assert(sizeof(stCharaStatus::bBloom) == 1, "expected stCharaStatus::bBloom to be size 1");
static_assert(sizeof(stCharaStatus::JumpBlockHit) == 1, "expected stCharaStatus::JumpBlockHit to be size 1");
static_assert(sizeof(stCharaStatus::AtkDisAdjust) == 4, "expected stCharaStatus::AtkDisAdjust to be size 4");
static_assert(sizeof(stCharaStatus::TubaFrmOffset) == 4, "expected stCharaStatus::TubaFrmOffset to be size 4");
static_assert(sizeof(stCharaStatus::motionNoNpc) == 4, "expected stCharaStatus::motionNoNpc to be size 4");
static_assert(sizeof(stCharaStatus::semiTransRate) == 32, "expected stCharaStatus::semiTransRate to be size 32");
static_assert(sizeof(stCharaStatus::flag) == 8, "expected stCharaStatus::flag to be size 8");
static_assert(sizeof(stCharaStatus) == 0x39c, "expected stCharaStatus to be size 0x39c");

// [Structure] class ghmListObj
/// <summary>
/// Linked list object (mpPrev and mpNext).
/// </summary>
class ghmListObj
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x6], offset 0x0>
	void* (* field_0)[0x6];

	// <ghmListObj* mpPrev, offset 0x4>
	ghmListObj* mpPrev = nullptr;

	// <ghmListObj* mpNext, offset 0x8>
	ghmListObj* mpNext = nullptr;

	// <int32_t mPriority, offset 0xc>
	int32_t mPriority = 0;

	/// 0 Functions

	/// Meta

	mHRChara* AsHRChara() const { return (mHRChara*)this; }
	std::string ToString() const { std::stringstream stream; stream << "class ghmListObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmListObj& InObject)
	{
		mpPrev = InObject.mpPrev;
		mpNext = InObject.mpNext;
		mPriority = InObject.mPriority;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmListObj>("ghmListObj")
			.addFunction("__tostring", &ghmListObj::ToString)
			.addFunction("GetPtrAddr", &ghmListObj::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmListObj::field_0)
			.addProperty("mpPrev", &ghmListObj::mpPrev)
			.addProperty("mpNext", &ghmListObj::mpNext)
			.addProperty("mPriority", &ghmListObj::mPriority)
			.addFunction("AsHRChara", &ghmListObj::AsHRChara)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmListObj::field_0) == 4, "expected ghmListObj::field_0 to be size 4");
static_assert(sizeof(ghmListObj::mpPrev) == 4, "expected ghmListObj::mpPrev to be size 4");
static_assert(sizeof(ghmListObj::mpNext) == 4, "expected ghmListObj::mpNext to be size 4");
static_assert(sizeof(ghmListObj::mPriority) == 4, "expected ghmListObj::mPriority to be size 4");
static_assert(sizeof(ghmListObj) == 0x10, "expected ghmListObj to be size 0x10");

// enum eUDLR
enum eUDLR : uint32_t
{
	// <eUp = 0x0>
	eUp = 0,

	// <eDown = 0x1>
	eDown = 1,

	// <eLeft = 0x2>
	eLeft = 2,

	// <eRight = 0x3>
	eRight = 3,

	// <eUDLRMax = 0x4>
	eUDLRMax = 4

};

// enum enWepLeftRight
enum enWepLeftRight : uint32_t
{
	// <eWepLeft = 0x0>
	eWepLeft = 0,

	// <eWepRight = 0x1>
	eWepRight = 1,

	// <eWepLeftRightMax = 0x2>
	eWepLeftRightMax = 2

};

// enum eDmgCallBackDmgType
enum eDmgCallBackDmgType : uint32_t
{
	// <eDmgCallBackDmgType_Cut = 0x0>
	eDmgCallBackDmgType_Cut = 0,

	// <eDmgCallBackDmgType_Through = 0x1>
	eDmgCallBackDmgType_Through = 1

};

// [Structure] struct CharControlMotID
struct CharControlMotID
{
public:
	/// Struct member variables

	// <int32_t WalkNeutral, offset 0x0>
	int32_t WalkNeutral = 0;

	// <int32_t WalkFront, offset 0x4>
	int32_t WalkFront = 0;

	// <int32_t WalkBack, offset 0x8>
	int32_t WalkBack = 0;

	// <int32_t WalkSideLeft, offset 0xc>
	int32_t WalkSideLeft = 0;

	// <int32_t WalkSideRight, offset 0x10>
	int32_t WalkSideRight = 0;

	// <int32_t Run, offset 0x14>
	int32_t Run = 0;

	// <int32_t EvacuateBack, offset 0x18>
	int32_t EvacuateBack = 0;

	// <int32_t EvacuateLeft, offset 0x1c>
	int32_t EvacuateLeft = 0;

	// <int32_t EvacuateRight, offset 0x20>
	int32_t EvacuateRight = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct CharControlMotID [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CharControlMotID& InObject)
	{
		WalkNeutral = InObject.WalkNeutral;
		WalkFront = InObject.WalkFront;
		WalkBack = InObject.WalkBack;
		WalkSideLeft = InObject.WalkSideLeft;
		WalkSideRight = InObject.WalkSideRight;
		Run = InObject.Run;
		EvacuateBack = InObject.EvacuateBack;
		EvacuateLeft = InObject.EvacuateLeft;
		EvacuateRight = InObject.EvacuateRight;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CharControlMotID>("CharControlMotID")
			.addFunction("__tostring", &CharControlMotID::ToString)
			.addFunction("GetPtrAddr", &CharControlMotID::GetPtrAddr)
			.addProperty("WalkNeutral", &CharControlMotID::WalkNeutral)
			.addProperty("WalkFront", &CharControlMotID::WalkFront)
			.addProperty("WalkBack", &CharControlMotID::WalkBack)
			.addProperty("WalkSideLeft", &CharControlMotID::WalkSideLeft)
			.addProperty("WalkSideRight", &CharControlMotID::WalkSideRight)
			.addProperty("Run", &CharControlMotID::Run)
			.addProperty("EvacuateBack", &CharControlMotID::EvacuateBack)
			.addProperty("EvacuateLeft", &CharControlMotID::EvacuateLeft)
			.addProperty("EvacuateRight", &CharControlMotID::EvacuateRight)
		.endClass();
	}
#endif
};
static_assert(sizeof(CharControlMotID::WalkNeutral) == 4, "expected CharControlMotID::WalkNeutral to be size 4");
static_assert(sizeof(CharControlMotID::WalkFront) == 4, "expected CharControlMotID::WalkFront to be size 4");
static_assert(sizeof(CharControlMotID::WalkBack) == 4, "expected CharControlMotID::WalkBack to be size 4");
static_assert(sizeof(CharControlMotID::WalkSideLeft) == 4, "expected CharControlMotID::WalkSideLeft to be size 4");
static_assert(sizeof(CharControlMotID::WalkSideRight) == 4, "expected CharControlMotID::WalkSideRight to be size 4");
static_assert(sizeof(CharControlMotID::Run) == 4, "expected CharControlMotID::Run to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateBack) == 4, "expected CharControlMotID::EvacuateBack to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateLeft) == 4, "expected CharControlMotID::EvacuateLeft to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateRight) == 4, "expected CharControlMotID::EvacuateRight to be size 4");
static_assert(sizeof(CharControlMotID) == 0x24, "expected CharControlMotID to be size 0x24");

// [Structure] struct GXColor
struct GXColor
{
public:
	/// Struct member variables

	// <uint32_t PackedValue, offset 0x0>
	uint32_t PackedValue = 0;

	/// 0 Functions

	/// Meta

	GXColor() { PackedValue = 0; }
	GXColor(int R, int G, int B) { PackedValue = (255<<24) + (int(R)<<16) + (int(G)<<8) + int(B); }
	std::string ToString() const { std::stringstream stream; stream << "struct GXColor [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GXColor& InObject)
	{
		PackedValue = InObject.PackedValue;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXColor>("GXColor")
			.addFunction("__tostring", &GXColor::ToString)
			.addFunction("GetPtrAddr", &GXColor::GetPtrAddr)
			.addProperty("PackedValue", &GXColor::PackedValue)
			.addConstructor<void (*) (void)>()
			.addConstructor<void (*) (int, int, int)>()
		.endClass();
	}
#endif
};
static_assert(sizeof(GXColor::PackedValue) == 4, "expected GXColor::PackedValue to be size 4");
static_assert(sizeof(GXColor) == 0x4, "expected GXColor to be size 0x4");

// [Structure] union __m128
union __m128
{
public:
	/// Struct member variables

	// <float m128_f32[0x4], offset 0x0>
	float m128_f32[4];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "union __m128 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(__m128& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<__m128>("__m128")
			.addFunction("__tostring", &__m128::ToString)
			.addFunction("GetPtrAddr", &__m128::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m128_f32", &__m128::m128_f32)
		.endClass();
	}
#endif
};
static_assert(sizeof(__m128::m128_f32) == 16, "expected __m128::m128_f32 to be size 16");
static_assert(sizeof(__m128) == 0x10, "expected __m128 to be size 0x10");

// [Structure] class vector4f
class vector4f
{
public:
	/// Struct member variables

	// <uint32_t u[0x4], offset 0x0>
	uint32_t u[4];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class vector4f [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(vector4f& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<vector4f>("vector4f")
			.addFunction("__tostring", &vector4f::ToString)
			.addFunction("GetPtrAddr", &vector4f::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("u", &vector4f::u)
		.endClass();
	}
#endif
};
static_assert(sizeof(vector4f::u) == 16, "expected vector4f::u to be size 16");
static_assert(sizeof(vector4f) == 0x10, "expected vector4f to be size 0x10");

// [Structure] class vector4x
class vector4x
{
public:
	/// Struct member variables

	// <double sd[0x2], offset 0x0>
	double sd[2];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class vector4x [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(vector4x& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<vector4x>("vector4x")
			.addFunction("__tostring", &vector4x::ToString)
			.addFunction("GetPtrAddr", &vector4x::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("sd", &vector4x::sd)
		.endClass();
	}
#endif
};
static_assert(sizeof(vector4x::sd) == 16, "expected vector4x::sd to be size 16");
static_assert(sizeof(vector4x) == 0x10, "expected vector4x to be size 0x10");

// [Structure] class tiVector
class tiVector
{
public:
	/// Struct member variables

	// <float x, offset 0x0>
	float x = 0;

	// <float y, offset 0x4>
	float y = 0;

	// <float z, offset 0x8>
	float z = 0;

	// <float w, offset 0xc>
	float w = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class tiVector [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tiVector& InObject)
	{
		x = InObject.x;
		y = InObject.y;
		z = InObject.z;
		w = InObject.w;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tiVector>("tiVector")
			.addFunction("__tostring", &tiVector::ToString)
			.addFunction("GetPtrAddr", &tiVector::GetPtrAddr)
			.addProperty("x", &tiVector::x)
			.addProperty("y", &tiVector::y)
			.addProperty("z", &tiVector::z)
			.addProperty("w", &tiVector::w)
		.endClass();
	}
#endif
};
static_assert(sizeof(tiVector::x) == 4, "expected tiVector::x to be size 4");
static_assert(sizeof(tiVector::y) == 4, "expected tiVector::y to be size 4");
static_assert(sizeof(tiVector::z) == 4, "expected tiVector::z to be size 4");
static_assert(sizeof(tiVector::w) == 4, "expected tiVector::w to be size 4");
static_assert(sizeof(tiVector) == 0x10, "expected tiVector to be size 0x10");

// [Structure] class mot::IBoneEffectModel
namespace mot
{
	class IBoneEffectModel
	{
	public:
		/// Struct member variables

		// <void* (* field_0)[0x1f], offset 0x0>
		void* (* field_0)[0x1f];

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::IBoneEffectModel [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::IBoneEffectModel& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<IBoneEffectModel>("mot_IBoneEffectModel")
				.addFunction("__tostring", &mot::IBoneEffectModel::ToString)
				.addFunction("GetPtrAddr", &mot::IBoneEffectModel::GetPtrAddr)
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &mot::IBoneEffectModel::field_0)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectModel::field_0) == 4, "expected mot::IBoneEffectModel::field_0 to be size 4");
static_assert(sizeof(mot::IBoneEffectModel) == 0x4, "expected mot::IBoneEffectModel to be size 0x4");

// [Structure] class mot::IBoneEffectModelPJ
namespace mot
{
	class IBoneEffectModelPJ : public mot::IBoneEffectModel
	{
	public:
		/// Struct member variables

		// <class mot::IBoneEffectModel field_0, offset 0x0>
		// class IBoneEffectModel Super;

		// <Unidentified data segment, offset 0x4>
	private:
		char _UnidentifiedData_4[12];

	public:
		// <class tiVector m_inYureBonePosiOfst, offset 0x10>
		class tiVector m_inYureBonePosiOfst;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::IBoneEffectModelPJ [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::IBoneEffectModelPJ& InObject)
		{
			m_inYureBonePosiOfst = InObject.m_inYureBonePosiOfst;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.deriveClass<IBoneEffectModelPJ, mot::IBoneEffectModel>("mot_IBoneEffectModelPJ")
				.addFunction("__tostring", &mot::IBoneEffectModelPJ::ToString)
				.addFunction("GetPtrAddr", &mot::IBoneEffectModelPJ::GetPtrAddr)
				.addProperty("m_inYureBonePosiOfst", &mot::IBoneEffectModelPJ::m_inYureBonePosiOfst)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectModelPJ::m_inYureBonePosiOfst) == 16, "expected mot::IBoneEffectModelPJ::m_inYureBonePosiOfst to be size 16");
static_assert(sizeof(mot::IBoneEffectModelPJ) == 0x20, "expected mot::IBoneEffectModelPJ to be size 0x20");

// [Structure] class TGmf
class TGmf : public mot::IBoneEffectModelPJ
{
public:
	// [Structure] struct TGmf::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData_0[2284];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TGmf::tagMAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TGmf::tagMAIN& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<tagMAIN>("TGmf_tagMAIN")
				.addFunction("__tostring", &TGmf::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TGmf::tagMAIN::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGmf::tagMAIN) == 0x8ec, "expected TGmf::tagMAIN to be size 0x8ec");

	/// Struct member variables

	// <class mot::IBoneEffectModelPJ field_0, offset 0x0>
	// class mot::IBoneEffectModelPJ Super;

	// <struct TGmf::tagMAIN dat, offset 0x20>
	struct TGmf::tagMAIN dat;

	// <uint8_t mUseLight, offset 0x90c>
	uint8_t mUseLight = 0;

	// <Unidentified data segment, offset 0x90d>
private:
	char _UnidentifiedData_2317[3];

public:
	// <class TGanPlay* mpFrameInfoPlay, offset 0x910>
	class TGanPlay* mpFrameInfoPlay = nullptr;

	// <class TGanPlayNode* mpFrameInfoNode, offset 0x914>
	class TGanPlayNode* mpFrameInfoNode = nullptr;

	// <class TGanPlay* mpEffectInfoPlay, offset 0x918>
	class TGanPlay* mpEffectInfoPlay = nullptr;

	// <class TGanPlayNode* mpSmokeParam1Node, offset 0x91c>
	class TGanPlayNode* mpSmokeParam1Node = nullptr;

	// <class TGanPlayNode* mpSmokeParam2Node, offset 0x920>
	class TGanPlayNode* mpSmokeParam2Node = nullptr;

	// <int32_t mHitFrameNum, offset 0x924>
	int32_t mHitFrameNum = 0;

	// <int32_t mDmgMotNum, offset 0x928>
	int32_t mDmgMotNum = 0;

	// <int32_t mGrdMotNum, offset 0x92c>
	int32_t mGrdMotNum = 0;

	// <int32_t mNextGrdMotNum, offset 0x930>
	int32_t mNextGrdMotNum = 0;

	// <int32_t mAtkDirec, offset 0x934>
	int32_t mAtkDirec = 0;

	// <int32_t mEffectNum, offset 0x938>
	int32_t mEffectNum = 0;

	// <float mIKBlendRate, offset 0x93c>
	float mIKBlendRate = 0;

	// <float mSlowRate, offset 0x940>
	float mSlowRate = 0;

	// <uint8_t mbDrawMirror, offset 0x944>
	uint8_t mbDrawMirror = 0;

	// <uint8_t mbObj, offset 0x945>
	uint8_t mbObj = 0;

	// <Unidentified data segment, offset 0x946>
private:
	char _UnidentifiedData_2374[2];

public:
	// <float m_fFadeAlpha, offset 0x948>
	float m_fFadeAlpha = 0;

	// <class TGmfNode* m_pLocatorNode, offset 0x94c>
	class TGmfNode* m_pLocatorNode = nullptr;

	// <int32_t m_nTotalModel, offset 0x950>
	int32_t m_nTotalModel = 0;

	// <int32_t m_nCurModelIndex, offset 0x954>
	int32_t m_nCurModelIndex = 0;

	// <class TGmfNode* m_pCurModelTopNode, offset 0x958>
	class TGmfNode* m_pCurModelTopNode = nullptr;

	// <class TGmfNode* m_pBoneEffectTopNode, offset 0x95c>
	class TGmfNode* m_pBoneEffectTopNode = nullptr;

	// <uint32_t m_bActedSetupRefMesh, offset 0x960>
	uint32_t m_bActedSetupRefMesh = 0;

	// <uint32_t m_bActedRefreshRefMesh, offset 0x964>
	uint32_t m_bActedRefreshRefMesh = 0;

	// <class mot::IBoneEffectPJ* m_pBoneEffect, offset 0x968>
	class mot::IBoneEffectPJ* m_pBoneEffect = nullptr;

	// <uint8_t m_bActedBoneEffectInit, offset 0x96c>
	uint8_t m_bActedBoneEffectInit = 0;

	// <uint8_t m_bActBoneEffectOnUpdate, offset 0x96d>
	uint8_t m_bActBoneEffectOnUpdate = 0;

	// <Unidentified data segment, offset 0x96e>
private:
	char _UnidentifiedData_2414[2];

public:
	// <char const* m_sIDName, offset 0x970>
	char const* m_sIDName = nullptr;

	// <int32_t m_nIDNum, offset 0x974>
	int32_t m_nIDNum = 0;

	// <char const* m_sMotName, offset 0x978>
	char const* m_sMotName = nullptr;

	// <int32_t m_nTotalCamVibTiming, offset 0x97c>
	int32_t m_nTotalCamVibTiming = 0;

	// <class CCameraVibTiming* m_ainCamVibTiming, offset 0x980>
	class CCameraVibTiming* m_ainCamVibTiming = nullptr;

	// <uint8_t m_bIsBootCamVib, offset 0x984>
	uint8_t m_bIsBootCamVib = 0;

	// <Unidentified data segment, offset 0x985>
private:
	char _UnidentifiedData_2437[11];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class TGmf [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TGmf& InObject)
	{
		dat = InObject.dat;
		mUseLight = InObject.mUseLight;
		mpFrameInfoPlay = InObject.mpFrameInfoPlay;
		mpFrameInfoNode = InObject.mpFrameInfoNode;
		mpEffectInfoPlay = InObject.mpEffectInfoPlay;
		mpSmokeParam1Node = InObject.mpSmokeParam1Node;
		mpSmokeParam2Node = InObject.mpSmokeParam2Node;
		mHitFrameNum = InObject.mHitFrameNum;
		mDmgMotNum = InObject.mDmgMotNum;
		mGrdMotNum = InObject.mGrdMotNum;
		mNextGrdMotNum = InObject.mNextGrdMotNum;
		mAtkDirec = InObject.mAtkDirec;
		mEffectNum = InObject.mEffectNum;
		mIKBlendRate = InObject.mIKBlendRate;
		mSlowRate = InObject.mSlowRate;
		mbDrawMirror = InObject.mbDrawMirror;
		mbObj = InObject.mbObj;
		m_fFadeAlpha = InObject.m_fFadeAlpha;
		m_pLocatorNode = InObject.m_pLocatorNode;
		m_nTotalModel = InObject.m_nTotalModel;
		m_nCurModelIndex = InObject.m_nCurModelIndex;
		m_pCurModelTopNode = InObject.m_pCurModelTopNode;
		m_pBoneEffectTopNode = InObject.m_pBoneEffectTopNode;
		m_bActedSetupRefMesh = InObject.m_bActedSetupRefMesh;
		m_bActedRefreshRefMesh = InObject.m_bActedRefreshRefMesh;
		m_pBoneEffect = InObject.m_pBoneEffect;
		m_bActedBoneEffectInit = InObject.m_bActedBoneEffectInit;
		m_bActBoneEffectOnUpdate = InObject.m_bActBoneEffectOnUpdate;
		m_sIDName = InObject.m_sIDName;
		m_nIDNum = InObject.m_nIDNum;
		m_sMotName = InObject.m_sMotName;
		m_nTotalCamVibTiming = InObject.m_nTotalCamVibTiming;
		m_ainCamVibTiming = InObject.m_ainCamVibTiming;
		m_bIsBootCamVib = InObject.m_bIsBootCamVib;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<TGmf, mot::IBoneEffectModelPJ>("TGmf")
			.addFunction("__tostring", &TGmf::ToString)
			.addFunction("GetPtrAddr", &TGmf::GetPtrAddr)
			.addProperty("dat", &TGmf::dat)
			.addProperty("mUseLight", &TGmf::mUseLight)
			.addProperty("mpFrameInfoPlay", &TGmf::mpFrameInfoPlay)
			.addProperty("mpFrameInfoNode", &TGmf::mpFrameInfoNode)
			.addProperty("mpEffectInfoPlay", &TGmf::mpEffectInfoPlay)
			.addProperty("mpSmokeParam1Node", &TGmf::mpSmokeParam1Node)
			.addProperty("mpSmokeParam2Node", &TGmf::mpSmokeParam2Node)
			.addProperty("mHitFrameNum", &TGmf::mHitFrameNum)
			.addProperty("mDmgMotNum", &TGmf::mDmgMotNum)
			.addProperty("mGrdMotNum", &TGmf::mGrdMotNum)
			.addProperty("mNextGrdMotNum", &TGmf::mNextGrdMotNum)
			.addProperty("mAtkDirec", &TGmf::mAtkDirec)
			.addProperty("mEffectNum", &TGmf::mEffectNum)
			.addProperty("mIKBlendRate", &TGmf::mIKBlendRate)
			.addProperty("mSlowRate", &TGmf::mSlowRate)
			.addProperty("mbDrawMirror", &TGmf::mbDrawMirror)
			.addProperty("mbObj", &TGmf::mbObj)
			.addProperty("m_fFadeAlpha", &TGmf::m_fFadeAlpha)
			.addProperty("m_pLocatorNode", &TGmf::m_pLocatorNode)
			.addProperty("m_nTotalModel", &TGmf::m_nTotalModel)
			.addProperty("m_nCurModelIndex", &TGmf::m_nCurModelIndex)
			.addProperty("m_pCurModelTopNode", &TGmf::m_pCurModelTopNode)
			.addProperty("m_pBoneEffectTopNode", &TGmf::m_pBoneEffectTopNode)
			.addProperty("m_bActedSetupRefMesh", &TGmf::m_bActedSetupRefMesh)
			.addProperty("m_bActedRefreshRefMesh", &TGmf::m_bActedRefreshRefMesh)
			.addProperty("m_pBoneEffect", &TGmf::m_pBoneEffect)
			.addProperty("m_bActedBoneEffectInit", &TGmf::m_bActedBoneEffectInit)
			.addProperty("m_bActBoneEffectOnUpdate", &TGmf::m_bActBoneEffectOnUpdate)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sIDName", &TGmf::m_sIDName)
			.addProperty("m_nIDNum", &TGmf::m_nIDNum)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sMotName", &TGmf::m_sMotName)
			.addProperty("m_nTotalCamVibTiming", &TGmf::m_nTotalCamVibTiming)
			.addProperty("m_ainCamVibTiming", &TGmf::m_ainCamVibTiming)
			.addProperty("m_bIsBootCamVib", &TGmf::m_bIsBootCamVib)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGmf::dat) == 2284, "expected TGmf::dat to be size 2284");
static_assert(sizeof(TGmf::mUseLight) == 1, "expected TGmf::mUseLight to be size 1");
static_assert(sizeof(TGmf::mpFrameInfoPlay) == 4, "expected TGmf::mpFrameInfoPlay to be size 4");
static_assert(sizeof(TGmf::mpFrameInfoNode) == 4, "expected TGmf::mpFrameInfoNode to be size 4");
static_assert(sizeof(TGmf::mpEffectInfoPlay) == 4, "expected TGmf::mpEffectInfoPlay to be size 4");
static_assert(sizeof(TGmf::mpSmokeParam1Node) == 4, "expected TGmf::mpSmokeParam1Node to be size 4");
static_assert(sizeof(TGmf::mpSmokeParam2Node) == 4, "expected TGmf::mpSmokeParam2Node to be size 4");
static_assert(sizeof(TGmf::mHitFrameNum) == 4, "expected TGmf::mHitFrameNum to be size 4");
static_assert(sizeof(TGmf::mDmgMotNum) == 4, "expected TGmf::mDmgMotNum to be size 4");
static_assert(sizeof(TGmf::mGrdMotNum) == 4, "expected TGmf::mGrdMotNum to be size 4");
static_assert(sizeof(TGmf::mNextGrdMotNum) == 4, "expected TGmf::mNextGrdMotNum to be size 4");
static_assert(sizeof(TGmf::mAtkDirec) == 4, "expected TGmf::mAtkDirec to be size 4");
static_assert(sizeof(TGmf::mEffectNum) == 4, "expected TGmf::mEffectNum to be size 4");
static_assert(sizeof(TGmf::mIKBlendRate) == 4, "expected TGmf::mIKBlendRate to be size 4");
static_assert(sizeof(TGmf::mSlowRate) == 4, "expected TGmf::mSlowRate to be size 4");
static_assert(sizeof(TGmf::mbDrawMirror) == 1, "expected TGmf::mbDrawMirror to be size 1");
static_assert(sizeof(TGmf::mbObj) == 1, "expected TGmf::mbObj to be size 1");
static_assert(sizeof(TGmf::m_fFadeAlpha) == 4, "expected TGmf::m_fFadeAlpha to be size 4");
static_assert(sizeof(TGmf::m_pLocatorNode) == 4, "expected TGmf::m_pLocatorNode to be size 4");
static_assert(sizeof(TGmf::m_nTotalModel) == 4, "expected TGmf::m_nTotalModel to be size 4");
static_assert(sizeof(TGmf::m_nCurModelIndex) == 4, "expected TGmf::m_nCurModelIndex to be size 4");
static_assert(sizeof(TGmf::m_pCurModelTopNode) == 4, "expected TGmf::m_pCurModelTopNode to be size 4");
static_assert(sizeof(TGmf::m_pBoneEffectTopNode) == 4, "expected TGmf::m_pBoneEffectTopNode to be size 4");
static_assert(sizeof(TGmf::m_bActedSetupRefMesh) == 4, "expected TGmf::m_bActedSetupRefMesh to be size 4");
static_assert(sizeof(TGmf::m_bActedRefreshRefMesh) == 4, "expected TGmf::m_bActedRefreshRefMesh to be size 4");
static_assert(sizeof(TGmf::m_pBoneEffect) == 4, "expected TGmf::m_pBoneEffect to be size 4");
static_assert(sizeof(TGmf::m_bActedBoneEffectInit) == 1, "expected TGmf::m_bActedBoneEffectInit to be size 1");
static_assert(sizeof(TGmf::m_bActBoneEffectOnUpdate) == 1, "expected TGmf::m_bActBoneEffectOnUpdate to be size 1");
static_assert(sizeof(TGmf::m_sIDName) == 4, "expected TGmf::m_sIDName to be size 4");
static_assert(sizeof(TGmf::m_nIDNum) == 4, "expected TGmf::m_nIDNum to be size 4");
static_assert(sizeof(TGmf::m_sMotName) == 4, "expected TGmf::m_sMotName to be size 4");
static_assert(sizeof(TGmf::m_nTotalCamVibTiming) == 4, "expected TGmf::m_nTotalCamVibTiming to be size 4");
static_assert(sizeof(TGmf::m_ainCamVibTiming) == 4, "expected TGmf::m_ainCamVibTiming to be size 4");
static_assert(sizeof(TGmf::m_bIsBootCamVib) == 1, "expected TGmf::m_bIsBootCamVib to be size 1");
static_assert(sizeof(TGmf) == 0x990, "expected TGmf to be size 0x990");

// [Structure] class NYApproachToTargetVal
class NYApproachToTargetVal
{
public:
	// enum NYApproachToTargetVal::CHANGE_TYPE
	enum CHANGE_TYPE : uint32_t
	{
		// <CHANGE_TYPE_INCREASED = 0x0>
		CHANGE_TYPE_INCREASED = 0,

		// <CHANGE_TYPE_DECREASED = 0x1>
		CHANGE_TYPE_DECREASED = 1,

		// <CHANGE_TYPE_APPROACHED = 0x2>
		CHANGE_TYPE_APPROACHED = 2,

		// <CHANGE_TYPE_NO_CHANGED = 0x3>
		CHANGE_TYPE_NO_CHANGED = 3

	};

	/// Struct member variables

	// <float m_val, offset 0x0>
	float m_val = 0;

	// <float m_targetVal, offset 0x4>
	float m_targetVal = 0;

	// <enum NYApproachToTargetVal::CHANGE_TYPE m_lastChangeType, offset 0x8>
	enum NYApproachToTargetVal::CHANGE_TYPE m_lastChangeType;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class NYApproachToTargetVal [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(NYApproachToTargetVal& InObject)
	{
		m_val = InObject.m_val;
		m_targetVal = InObject.m_targetVal;
		m_lastChangeType = InObject.m_lastChangeType;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NYApproachToTargetVal>("NYApproachToTargetVal")
			.addFunction("__tostring", &NYApproachToTargetVal::ToString)
			.addFunction("GetPtrAddr", &NYApproachToTargetVal::GetPtrAddr)
			.addProperty("m_val", &NYApproachToTargetVal::m_val)
			.addProperty("m_targetVal", &NYApproachToTargetVal::m_targetVal)
			.addProperty("m_lastChangeType", &NYApproachToTargetVal::m_lastChangeType)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYApproachToTargetVal::m_val) == 4, "expected NYApproachToTargetVal::m_val to be size 4");
static_assert(sizeof(NYApproachToTargetVal::m_targetVal) == 4, "expected NYApproachToTargetVal::m_targetVal to be size 4");
static_assert(sizeof(NYApproachToTargetVal::m_lastChangeType) == 4, "expected NYApproachToTargetVal::m_lastChangeType to be size 4");
static_assert(sizeof(NYApproachToTargetVal) == 0xc, "expected NYApproachToTargetVal to be size 0xc");

// enum
enum : uint32_t
{
	// <E_CON_ACT_NONE = 0xffffffffffffffff>
	E_CON_ACT_NONE = UINT32_MAX,

	// <E_CON_ACT_FURIAGE = 0x0>
	E_CON_ACT_FURIAGE = 0,

	// <E_CON_ACT_UP = 0x1>
	E_CON_ACT_UP = 1,

	// <E_CON_ACT_DOWN = 0x2>
	E_CON_ACT_DOWN = 2,

	// <E_CON_ACT_PUSH = 0x3>
	E_CON_ACT_PUSH = 3,

	// <E_CON_ACT_PULL = 0x4>
	E_CON_ACT_PULL = 4,

	// <E_CON_ACT_RBLOW = 0x5>
	E_CON_ACT_RBLOW = 5,

	// <E_CON_ACT_LBLOW = 0x6>
	E_CON_ACT_LBLOW = 6,

	// <E_CON_ACT_ROTATE = 0x7>
	E_CON_ACT_ROTATE = 7,

	// <E_COM_ACT_CROSS = 0x8>
	E_COM_ACT_CROSS = 8

};

// [Structure] class HrBattleIcon
class HrBattleIcon : public HrTask
{
public:
	// enum HrBattleIcon::D_BICON_STAT
	enum D_BICON_STAT : uint32_t
	{
		// <D_BICON_NONE = 0x0>
		D_BICON_NONE = 0,

		// <D_BICON_MINI = 0x1>
		D_BICON_MINI = 1,

		// <D_BICON_MINI_TO_SKULL = 0x2>
		D_BICON_MINI_TO_SKULL = 2,

		// <D_BICON_SKULL_TO_MINI = 0x3>
		D_BICON_SKULL_TO_MINI = 3,

		// <D_BICON_SKULL = 0x4>
		D_BICON_SKULL = 4,

		// <D_BICON_TODOME_DO = 0x5>
		D_BICON_TODOME_DO = 5,

		// <D_BICON_TODOME_ED = 0x6>
		D_BICON_TODOME_ED = 6,

		// <D_BICON_CONTROLLER_ACT = 0x7>
		D_BICON_CONTROLLER_ACT = 7,

		// <D_BICON_TUBAZERI = 0x8>
		D_BICON_TUBAZERI = 8

	};

	// enum HrBattleIcon::D_TODOME_DIRECT
	enum D_TODOME_DIRECT : uint32_t
	{
		// <D_TODOME_RIGHT = 0x0>
		D_TODOME_RIGHT = 0,

		// <D_TODOME_DOWN = 0x1>
		D_TODOME_DOWN = 1,

		// <D_TODOME_LEFT = 0x2>
		D_TODOME_LEFT = 2,

		// <D_TODOME_UP = 0x3>
		D_TODOME_UP = 3,

		// <D_TODOME_360 = 0x4>
		D_TODOME_360 = 4,

		// <D_TODOME_2RIGHTDOWN = 0x5>
		D_TODOME_2RIGHTDOWN = 5,

		// <D_TODOME_2LEFTDOWN = 0x6>
		D_TODOME_2LEFTDOWN = 6

	};

	// [Structure] class HrBattleIcon::CHrHpGauge
	class CHrHpGauge
	{
	public:
		/// Struct member variables

		// <class NYPhase m_Phase, offset 0x0>
		class NYPhase m_Phase;

		// <void (* m_pPhaseProc[0x7][0x2])(HrBattleIcon::CHrHpGauge* const this), offset 0x1c>
		void (* m_pPhaseProc[0x7][0x2])(HrBattleIcon::CHrHpGauge* const ThisPtr);

		// <class mHRChara* m_pTargetChara, offset 0x54>
		class mHRChara* m_pTargetChara = nullptr;

		// <int16_t const mc_Height, offset 0x58>
		int16_t mc_Height = 0;

		// <int16_t const mc_FrameEdge_Width, offset 0x5a>
		int16_t mc_FrameEdge_Width = 0;

		// <int16_t const mc_DrawOffsetY, offset 0x5c>
		int16_t mc_DrawOffsetY = 0;

		// <Unidentified data segment, offset 0x5e>
	private:
		char _UnidentifiedData_94[2];

	public:
		// <float m_DrawWidth, offset 0x60>
		float m_DrawWidth = 0;

		// <float m_DrawHeight, offset 0x64>
		float m_DrawHeight = 0;

		// <float m_DrawAlpha, offset 0x68>
		float m_DrawAlpha = 0;

		// <float m_HpRate, offset 0x6c>
		float m_HpRate = 0;

		// <int16_t m_SlashFadeCounter, offset 0x70>
		int16_t m_SlashFadeCounter = 0;

		// <Unidentified data segment, offset 0x72>
	private:
		char _UnidentifiedData_114[2];

	public:
		/// 1 Functions

		// [Function] void __convention("thiscall") HrBattleIcon::CHrHpGauge::Initialize(class HrBattleIcon::CHrHpGauge* const this, class mHRChara* arg2) [?Initialize@CHrHpGauge@HrBattleIcon@@QAEXPAVmHRChara@@@Z]
		typedef void(__thiscall* _Initialize_CHrHpGauge_HrBattleIcon__QAEXPAVmHRChara___Z)(class HrBattleIcon::CHrHpGauge* const thisPtr, class mHRChara* arg2);
		void Initialize(class mHRChara* arg2)
		{
			_Initialize_CHrHpGauge_HrBattleIcon__QAEXPAVmHRChara___Z mFunc = (_Initialize_CHrHpGauge_HrBattleIcon__QAEXPAVmHRChara___Z)(GameModule + 0x4ca550);
			return mFunc(this, arg2);
		}
		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class HrBattleIcon::CHrHpGauge [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(HrBattleIcon::CHrHpGauge& InObject)
		{
			m_Phase = InObject.m_Phase;
			m_pTargetChara = InObject.m_pTargetChara;
			mc_Height = InObject.mc_Height;
			mc_FrameEdge_Width = InObject.mc_FrameEdge_Width;
			mc_DrawOffsetY = InObject.mc_DrawOffsetY;
			m_DrawWidth = InObject.m_DrawWidth;
			m_DrawHeight = InObject.m_DrawHeight;
			m_DrawAlpha = InObject.m_DrawAlpha;
			m_HpRate = InObject.m_HpRate;
			m_SlashFadeCounter = InObject.m_SlashFadeCounter;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CHrHpGauge>("HrBattleIcon_CHrHpGauge")
				.addFunction("__tostring", &HrBattleIcon::CHrHpGauge::ToString)
				.addFunction("GetPtrAddr", &HrBattleIcon::CHrHpGauge::GetPtrAddr)
				.addProperty("m_Phase", &HrBattleIcon::CHrHpGauge::m_Phase)
				// void type not supported in LuaBridge
				//.addProperty("m_pPhaseProc", &HrBattleIcon::CHrHpGauge::m_pPhaseProc)
				.addProperty("m_pTargetChara", &HrBattleIcon::CHrHpGauge::m_pTargetChara)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_Height", &HrBattleIcon::CHrHpGauge::mc_Height)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_FrameEdge_Width", &HrBattleIcon::CHrHpGauge::mc_FrameEdge_Width)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_DrawOffsetY", &HrBattleIcon::CHrHpGauge::mc_DrawOffsetY)
				.addProperty("m_DrawWidth", &HrBattleIcon::CHrHpGauge::m_DrawWidth)
				.addProperty("m_DrawHeight", &HrBattleIcon::CHrHpGauge::m_DrawHeight)
				.addProperty("m_DrawAlpha", &HrBattleIcon::CHrHpGauge::m_DrawAlpha)
				.addProperty("m_HpRate", &HrBattleIcon::CHrHpGauge::m_HpRate)
				.addProperty("m_SlashFadeCounter", &HrBattleIcon::CHrHpGauge::m_SlashFadeCounter)
				.addFunction("Initialize", &HrBattleIcon::CHrHpGauge::Initialize)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_Phase) == 28, "expected HrBattleIcon::CHrHpGauge::m_Phase to be size 28");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_pPhaseProc) == 56, "expected HrBattleIcon::CHrHpGauge::m_pPhaseProc to be size 56");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_pTargetChara) == 4, "expected HrBattleIcon::CHrHpGauge::m_pTargetChara to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_Height) == 2, "expected HrBattleIcon::CHrHpGauge::mc_Height to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_FrameEdge_Width) == 2, "expected HrBattleIcon::CHrHpGauge::mc_FrameEdge_Width to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_DrawOffsetY) == 2, "expected HrBattleIcon::CHrHpGauge::mc_DrawOffsetY to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawWidth) == 4, "expected HrBattleIcon::CHrHpGauge::m_DrawWidth to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawHeight) == 4, "expected HrBattleIcon::CHrHpGauge::m_DrawHeight to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawAlpha) == 4, "expected HrBattleIcon::CHrHpGauge::m_DrawAlpha to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_HpRate) == 4, "expected HrBattleIcon::CHrHpGauge::m_HpRate to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_SlashFadeCounter) == 2, "expected HrBattleIcon::CHrHpGauge::m_SlashFadeCounter to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge) == 0x74, "expected HrBattleIcon::CHrHpGauge to be size 0x74");

	// enum HrBattleIcon::E_CON_ACT_ID
	enum E_CON_ACT_ID : uint32_t
	{
		// <E_CON_ACT_NONE = 0xffffffffffffffff>
		E_CON_ACT_NONE = UINT32_MAX,

		// <E_CON_ACT_FURIAGE = 0x0>
		E_CON_ACT_FURIAGE = 0,

		// <E_CON_ACT_UP = 0x1>
		E_CON_ACT_UP = 1,

		// <E_CON_ACT_DOWN = 0x2>
		E_CON_ACT_DOWN = 2,

		// <E_CON_ACT_PUSH = 0x3>
		E_CON_ACT_PUSH = 3,

		// <E_CON_ACT_PULL = 0x4>
		E_CON_ACT_PULL = 4,

		// <E_CON_ACT_RBLOW = 0x5>
		E_CON_ACT_RBLOW = 5,

		// <E_CON_ACT_LBLOW = 0x6>
		E_CON_ACT_LBLOW = 6,

		// <E_CON_ACT_ROTATE = 0x7>
		E_CON_ACT_ROTATE = 7,

		// <E_COM_ACT_CROSS = 0x8>
		E_COM_ACT_CROSS = 8

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class NYApproachToTargetVal m_HPVal, offset 0x50>
	class NYApproachToTargetVal m_HPVal;

	// <float m_damagedCounter, offset 0x5c>
	float m_damagedCounter = 0;

	// <enum HrBattleIcon::D_BICON_STAT m_IconStat, offset 0x60>
	enum HrBattleIcon::D_BICON_STAT m_IconStat;

	// <enum HrBattleIcon::D_BICON_STAT m_YoyakuIcon, offset 0x64>
	enum HrBattleIcon::D_BICON_STAT m_YoyakuIcon;

	// <float m_LockOnDist, offset 0x68>
	float m_LockOnDist = 0;

	// <float m_LockOnCircleSize, offset 0x6c>
	float m_LockOnCircleSize = 0;

	// <float m_BIcon_Block_Size, offset 0x70>
	float m_BIcon_Block_Size = 0;

	// <uint8_t m_blockcolor[0x3], offset 0x74>
	uint8_t m_blockcolor[3];

	// <uint8_t m_ColorType, offset 0x77>
	uint8_t m_ColorType = 0;

	// <enum m_ConActID[0x2], offset 0x78>
	uint32_t m_ConActID[2];

	// <int16_t m_ConActCount[0x2], offset 0x80>
	int16_t m_ConActCount[2];

	// <int16_t m_Counter, offset 0x84>
	int16_t m_Counter = 0;

	// <int16_t m_DelCounter, offset 0x86>
	int16_t m_DelCounter = 0;

	// <uint32_t m_Rotate_AnimCnt, offset 0x88>
	uint32_t m_Rotate_AnimCnt = 0;

	// <struct Vec m_TmpJstVec, offset 0x8c>
	struct Vec m_TmpJstVec;

	// <int16_t m_PyokoCnt, offset 0x98>
	int16_t m_PyokoCnt = 0;

	// <int16_t m_PyokoFlag, offset 0x9a>
	int16_t m_PyokoFlag = 0;

	// <float m_PyokoRatio, offset 0x9c>
	float m_PyokoRatio = 0;

	// <uint8_t m_PyokoAlpha, offset 0xa0>
	uint8_t m_PyokoAlpha = 0;

	// <uint8_t m_DrawHitCmbFlag, offset 0xa1>
	uint8_t m_DrawHitCmbFlag = 0;

	// <Unidentified data segment, offset 0xa2>
private:
	char _UnidentifiedData_162[2];

public:
	// <float m_TsubaRatio[0x24], offset 0xa4>
	float m_TsubaRatio[36];

	// <struct Vec* m_pPosition[0x2], offset 0x134>
	struct Vec* m_pPosition[2];

	// <class mHRChara* m_pTargetChara, offset 0x13c>
	class mHRChara* m_pTargetChara = nullptr;

	// <int16_t m_HpBerCounter, offset 0x140>
	int16_t m_HpBerCounter = 0;

	// <int16_t m_LineCounter, offset 0x142>
	int16_t m_LineCounter = 0;

	// <char m_MeterCounter, offset 0x144>
	char m_MeterCounter;

	// <Unidentified data segment, offset 0x145>
private:
	char _UnidentifiedData_325[3];

public:
	// <float m_Tension[0x2], offset 0x148>
	float m_Tension[2];

	// <float m_TMeterRevPos[0x2], offset 0x150>
	float m_TMeterRevPos[2];

	// <int16_t m_GetMoney[0x2], offset 0x158>
	int16_t m_GetMoney[2];

	// <int16_t m_HitNum[0x2], offset 0x15c>
	int16_t m_HitNum[2];

	// <float m_HP[0x3], offset 0x160>
	float m_HP[3];

	// <int16_t m_SlashFadeCounter, offset 0x16c>
	int16_t m_SlashFadeCounter = 0;

	// <int16_t m_BottanCounter[0x4], offset 0x16e>
	int16_t m_BottanCounter[4];

	// <int16_t m_TergetIconCount, offset 0x176>
	int16_t m_TergetIconCount = 0;

	// <enum HrBattleIcon::D_TODOME_DIRECT m_Direct, offset 0x178>
	enum HrBattleIcon::D_TODOME_DIRECT m_Direct;

	// <int32_t m_Angle, offset 0x17c>
	int32_t m_Angle = 0;

	// <int32_t m_Soundid, offset 0x180>
	int32_t m_Soundid = 0;

	// <uint16_t flag, offset 0x184>
	uint16_t flag = 0;

	// <uint8_t m_bDemo, offset 0x186>
	uint8_t m_bDemo = 0;

	// <Unidentified data segment, offset 0x187>
private:
	char _UnidentifiedData_391[1];

public:
	// <class HrBattleIcon::CHrHpGauge m_HpGauge, offset 0x188>
	class HrBattleIcon::CHrHpGauge m_HpGauge;

	// <int32_t m_SlashSEStatus, offset 0x1fc>
	int32_t m_SlashSEStatus = 0;

	/// 2 Functions

	// [Function] void __convention("thiscall") HrBattleIcon::OnCharacterTerminate(class HrBattleIcon* const this, class mHRChara* arg2) [?OnCharacterTerminate@HrBattleIcon@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _OnCharacterTerminate_HrBattleIcon__QAEXPAVmHRChara___Z)(class HrBattleIcon* const thisPtr, class mHRChara* arg2);
	void OnCharacterTerminate(class mHRChara* arg2)
	{
		_OnCharacterTerminate_HrBattleIcon__QAEXPAVmHRChara___Z mFunc = (_OnCharacterTerminate_HrBattleIcon__QAEXPAVmHRChara___Z)(GameModule + 0x4cdbf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrBattleIcon::Initialize(class HrBattleIcon* const this, class mHRChara* arg2, uint8_t arg3) [?Initialize@HrBattleIcon@@QAEXPAVmHRChara@@_N@Z]
	typedef void(__thiscall* _Initialize_HrBattleIcon__QAEXPAVmHRChara___N_Z)(class HrBattleIcon* const thisPtr, class mHRChara* arg2, uint8_t arg3);
	void Initialize(class mHRChara* arg2, uint8_t arg3)
	{
		_Initialize_HrBattleIcon__QAEXPAVmHRChara___N_Z mFunc = (_Initialize_HrBattleIcon__QAEXPAVmHRChara___N_Z)(GameModule + 0x4ce4b0);
		return mFunc(this, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrBattleIcon [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrBattleIcon& InObject)
	{
		m_HPVal = InObject.m_HPVal;
		m_damagedCounter = InObject.m_damagedCounter;
		m_IconStat = InObject.m_IconStat;
		m_YoyakuIcon = InObject.m_YoyakuIcon;
		m_LockOnDist = InObject.m_LockOnDist;
		m_LockOnCircleSize = InObject.m_LockOnCircleSize;
		m_BIcon_Block_Size = InObject.m_BIcon_Block_Size;
		m_ColorType = InObject.m_ColorType;
		m_Counter = InObject.m_Counter;
		m_DelCounter = InObject.m_DelCounter;
		m_Rotate_AnimCnt = InObject.m_Rotate_AnimCnt;
		m_TmpJstVec = InObject.m_TmpJstVec;
		m_PyokoCnt = InObject.m_PyokoCnt;
		m_PyokoFlag = InObject.m_PyokoFlag;
		m_PyokoRatio = InObject.m_PyokoRatio;
		m_PyokoAlpha = InObject.m_PyokoAlpha;
		m_DrawHitCmbFlag = InObject.m_DrawHitCmbFlag;
		m_pTargetChara = InObject.m_pTargetChara;
		m_HpBerCounter = InObject.m_HpBerCounter;
		m_LineCounter = InObject.m_LineCounter;
		m_MeterCounter = InObject.m_MeterCounter;
		m_SlashFadeCounter = InObject.m_SlashFadeCounter;
		m_TergetIconCount = InObject.m_TergetIconCount;
		m_Direct = InObject.m_Direct;
		m_Angle = InObject.m_Angle;
		m_Soundid = InObject.m_Soundid;
		flag = InObject.flag;
		m_bDemo = InObject.m_bDemo;
		m_HpGauge = InObject.m_HpGauge;
		m_SlashSEStatus = InObject.m_SlashSEStatus;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrBattleIcon, HrTask>("HrBattleIcon")
			.addFunction("__tostring", &HrBattleIcon::ToString)
			.addFunction("GetPtrAddr", &HrBattleIcon::GetPtrAddr)
			.addProperty("m_HPVal", &HrBattleIcon::m_HPVal)
			.addProperty("m_damagedCounter", &HrBattleIcon::m_damagedCounter)
			.addProperty("m_IconStat", &HrBattleIcon::m_IconStat)
			.addProperty("m_YoyakuIcon", &HrBattleIcon::m_YoyakuIcon)
			.addProperty("m_LockOnDist", &HrBattleIcon::m_LockOnDist)
			.addProperty("m_LockOnCircleSize", &HrBattleIcon::m_LockOnCircleSize)
			.addProperty("m_BIcon_Block_Size", &HrBattleIcon::m_BIcon_Block_Size)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_blockcolor", &HrBattleIcon::m_blockcolor)
			.addProperty("m_ColorType", &HrBattleIcon::m_ColorType)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_ConActID", &HrBattleIcon::m_ConActID)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_ConActCount", &HrBattleIcon::m_ConActCount)
			.addProperty("m_Counter", &HrBattleIcon::m_Counter)
			.addProperty("m_DelCounter", &HrBattleIcon::m_DelCounter)
			.addProperty("m_Rotate_AnimCnt", &HrBattleIcon::m_Rotate_AnimCnt)
			.addProperty("m_TmpJstVec", &HrBattleIcon::m_TmpJstVec)
			.addProperty("m_PyokoCnt", &HrBattleIcon::m_PyokoCnt)
			.addProperty("m_PyokoFlag", &HrBattleIcon::m_PyokoFlag)
			.addProperty("m_PyokoRatio", &HrBattleIcon::m_PyokoRatio)
			.addProperty("m_PyokoAlpha", &HrBattleIcon::m_PyokoAlpha)
			.addProperty("m_DrawHitCmbFlag", &HrBattleIcon::m_DrawHitCmbFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_TsubaRatio", &HrBattleIcon::m_TsubaRatio)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pPosition", &HrBattleIcon::m_pPosition)
			.addProperty("m_pTargetChara", &HrBattleIcon::m_pTargetChara)
			.addProperty("m_HpBerCounter", &HrBattleIcon::m_HpBerCounter)
			.addProperty("m_LineCounter", &HrBattleIcon::m_LineCounter)
			.addProperty("m_MeterCounter", &HrBattleIcon::m_MeterCounter)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_Tension", &HrBattleIcon::m_Tension)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_TMeterRevPos", &HrBattleIcon::m_TMeterRevPos)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_GetMoney", &HrBattleIcon::m_GetMoney)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_HitNum", &HrBattleIcon::m_HitNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_HP", &HrBattleIcon::m_HP)
			.addProperty("m_SlashFadeCounter", &HrBattleIcon::m_SlashFadeCounter)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_BottanCounter", &HrBattleIcon::m_BottanCounter)
			.addProperty("m_TergetIconCount", &HrBattleIcon::m_TergetIconCount)
			.addProperty("m_Direct", &HrBattleIcon::m_Direct)
			.addProperty("m_Angle", &HrBattleIcon::m_Angle)
			.addProperty("m_Soundid", &HrBattleIcon::m_Soundid)
			.addProperty("flag", &HrBattleIcon::flag)
			.addProperty("m_bDemo", &HrBattleIcon::m_bDemo)
			.addProperty("m_HpGauge", &HrBattleIcon::m_HpGauge)
			.addProperty("m_SlashSEStatus", &HrBattleIcon::m_SlashSEStatus)
			.addFunction("OnCharacterTerminate", &HrBattleIcon::OnCharacterTerminate)
			.addFunction("Initialize", &HrBattleIcon::Initialize)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrBattleIcon::m_HPVal) == 12, "expected HrBattleIcon::m_HPVal to be size 12");
static_assert(sizeof(HrBattleIcon::m_damagedCounter) == 4, "expected HrBattleIcon::m_damagedCounter to be size 4");
static_assert(sizeof(HrBattleIcon::m_IconStat) == 4, "expected HrBattleIcon::m_IconStat to be size 4");
static_assert(sizeof(HrBattleIcon::m_YoyakuIcon) == 4, "expected HrBattleIcon::m_YoyakuIcon to be size 4");
static_assert(sizeof(HrBattleIcon::m_LockOnDist) == 4, "expected HrBattleIcon::m_LockOnDist to be size 4");
static_assert(sizeof(HrBattleIcon::m_LockOnCircleSize) == 4, "expected HrBattleIcon::m_LockOnCircleSize to be size 4");
static_assert(sizeof(HrBattleIcon::m_BIcon_Block_Size) == 4, "expected HrBattleIcon::m_BIcon_Block_Size to be size 4");
static_assert(sizeof(HrBattleIcon::m_blockcolor) == 3, "expected HrBattleIcon::m_blockcolor to be size 3");
static_assert(sizeof(HrBattleIcon::m_ColorType) == 1, "expected HrBattleIcon::m_ColorType to be size 1");
static_assert(sizeof(HrBattleIcon::m_ConActID) == 8, "expected HrBattleIcon::m_ConActID to be size 8");
static_assert(sizeof(HrBattleIcon::m_ConActCount) == 4, "expected HrBattleIcon::m_ConActCount to be size 4");
static_assert(sizeof(HrBattleIcon::m_Counter) == 2, "expected HrBattleIcon::m_Counter to be size 2");
static_assert(sizeof(HrBattleIcon::m_DelCounter) == 2, "expected HrBattleIcon::m_DelCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_Rotate_AnimCnt) == 4, "expected HrBattleIcon::m_Rotate_AnimCnt to be size 4");
static_assert(sizeof(HrBattleIcon::m_TmpJstVec) == 12, "expected HrBattleIcon::m_TmpJstVec to be size 12");
static_assert(sizeof(HrBattleIcon::m_PyokoCnt) == 2, "expected HrBattleIcon::m_PyokoCnt to be size 2");
static_assert(sizeof(HrBattleIcon::m_PyokoFlag) == 2, "expected HrBattleIcon::m_PyokoFlag to be size 2");
static_assert(sizeof(HrBattleIcon::m_PyokoRatio) == 4, "expected HrBattleIcon::m_PyokoRatio to be size 4");
static_assert(sizeof(HrBattleIcon::m_PyokoAlpha) == 1, "expected HrBattleIcon::m_PyokoAlpha to be size 1");
static_assert(sizeof(HrBattleIcon::m_DrawHitCmbFlag) == 1, "expected HrBattleIcon::m_DrawHitCmbFlag to be size 1");
static_assert(sizeof(HrBattleIcon::m_TsubaRatio) == 144, "expected HrBattleIcon::m_TsubaRatio to be size 144");
static_assert(sizeof(HrBattleIcon::m_pPosition) == 8, "expected HrBattleIcon::m_pPosition to be size 8");
static_assert(sizeof(HrBattleIcon::m_pTargetChara) == 4, "expected HrBattleIcon::m_pTargetChara to be size 4");
static_assert(sizeof(HrBattleIcon::m_HpBerCounter) == 2, "expected HrBattleIcon::m_HpBerCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_LineCounter) == 2, "expected HrBattleIcon::m_LineCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_MeterCounter) == 1, "expected HrBattleIcon::m_MeterCounter to be size 1");
static_assert(sizeof(HrBattleIcon::m_Tension) == 8, "expected HrBattleIcon::m_Tension to be size 8");
static_assert(sizeof(HrBattleIcon::m_TMeterRevPos) == 8, "expected HrBattleIcon::m_TMeterRevPos to be size 8");
static_assert(sizeof(HrBattleIcon::m_GetMoney) == 4, "expected HrBattleIcon::m_GetMoney to be size 4");
static_assert(sizeof(HrBattleIcon::m_HitNum) == 4, "expected HrBattleIcon::m_HitNum to be size 4");
static_assert(sizeof(HrBattleIcon::m_HP) == 12, "expected HrBattleIcon::m_HP to be size 12");
static_assert(sizeof(HrBattleIcon::m_SlashFadeCounter) == 2, "expected HrBattleIcon::m_SlashFadeCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_BottanCounter) == 8, "expected HrBattleIcon::m_BottanCounter to be size 8");
static_assert(sizeof(HrBattleIcon::m_TergetIconCount) == 2, "expected HrBattleIcon::m_TergetIconCount to be size 2");
static_assert(sizeof(HrBattleIcon::m_Direct) == 4, "expected HrBattleIcon::m_Direct to be size 4");
static_assert(sizeof(HrBattleIcon::m_Angle) == 4, "expected HrBattleIcon::m_Angle to be size 4");
static_assert(sizeof(HrBattleIcon::m_Soundid) == 4, "expected HrBattleIcon::m_Soundid to be size 4");
static_assert(sizeof(HrBattleIcon::flag) == 2, "expected HrBattleIcon::flag to be size 2");
static_assert(sizeof(HrBattleIcon::m_bDemo) == 1, "expected HrBattleIcon::m_bDemo to be size 1");
static_assert(sizeof(HrBattleIcon::m_HpGauge) == 116, "expected HrBattleIcon::m_HpGauge to be size 116");
static_assert(sizeof(HrBattleIcon::m_SlashSEStatus) == 4, "expected HrBattleIcon::m_SlashSEStatus to be size 4");
static_assert(sizeof(HrBattleIcon) == 0x200, "expected HrBattleIcon to be size 0x200");

// [Structure] class mHRChara
/// <summary>
/// Base character (Travis, enemies, etc)
/// </summary>
class mHRChara : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct stCharaStatus mStatus, offset 0x10>
	struct stCharaStatus mStatus;

	// <class stCharaFileData mResource, offset 0x3ac>
	class stCharaFileData mResource;

	// <struct stCharaEffect mEffect, offset 0x3e4>
	struct stCharaEffect mEffect;

	// <class CAmbientShadow m_inAmbientShadow, offset 0x508>
	class CAmbientShadow m_inAmbientShadow;

	// <class CStlVector<CStickShadow> m_ainFootShadow, offset 0x540>
	class std::vector<CStickShadow> m_ainFootShadow;

	// <enum enCharaInitProc mInitProc, offset 0x54c>
	enum enCharaInitProc mInitProc;

	// <class CharController* m_pCharController, offset 0x550>
	class CharController* m_pCharController = nullptr;

	// <class ghmTriangle mWepColl, offset 0x554>
	class ghmTriangle mWepColl;

	// <int32_t motionInvincibilityFrames, offset 0x578>
	int32_t motionInvincibilityFrames = 0;

	// <int32_t invincibileMotion, offset 0x57c>
	int32_t invincibileMotion = 0;

	/// 367 Functions

	// [Function] enum enCharaType __convention("thiscall") mHRChara::mGetCharaType(class mHRChara* const this) [?mGetCharaType@mHRChara@@QBE?AW4enCharaType@@XZ]
	typedef enum enCharaType(__thiscall* _mGetCharaType_mHRChara__QBEAW4enCharaType__XZ)(class mHRChara* const thisPtr);
	/* enum enCharaType */ uint32_t mGetCharaType()
	{
		_mGetCharaType_mHRChara__QBEAW4enCharaType__XZ mFunc = (_mGetCharaType_mHRChara__QBEAW4enCharaType__XZ)(GameModule + 0x9f060);
		return (uint32_t)mFunc(this);
	}
	// [Function] uint8_t mHRChara::isCharacterTypeZako(enum enCharaType InType) [?isCharacterTypeZako@mHRChara@@SA_NW4enCharaType@@@Z]
	typedef uint8_t(__fastcall* _isCharacterTypeZako_mHRChara__SA_NW4enCharaType___Z)(enum enCharaType InType);
	static uint8_t isCharacterTypeZako(/* enum enCharaType */ uint32_t InType)
	{
		_isCharacterTypeZako_mHRChara__SA_NW4enCharaType___Z mFunc = (_isCharacterTypeZako_mHRChara__SA_NW4enCharaType___Z)(GameModule + 0xa2c60);
		return mFunc((enum enCharaType)InType);
	}
	// [Function] bool __convention("thiscall") mHRChara::mTestZako(class mHRChara* const this) [?mTestZako@mHRChara@@QBE_NXZ]
	typedef bool(__thiscall* _mTestZako_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	bool mTestZako()
	{
		_mTestZako_mHRChara__QBE_NXZ mFunc = (_mTestZako_mHRChara__QBE_NXZ)(GameModule + 0xa2c70);
		return mFunc(this);
	}
	// [Function] bool mHRChara::isCharacterTypeBoss(enum enCharaType arg1) [?isCharacterTypeBoss@mHRChara@@SA_NW4enCharaType@@@Z]
	typedef bool(__fastcall* _isCharacterTypeBoss_mHRChara__SA_NW4enCharaType___Z)(enum enCharaType arg1);
	static bool isCharacterTypeBoss(/* enum enCharaType */ uint32_t arg1)
	{
		_isCharacterTypeBoss_mHRChara__SA_NW4enCharaType___Z mFunc = (_isCharacterTypeBoss_mHRChara__SA_NW4enCharaType___Z)(GameModule + 0xa2c80);
		return mFunc((enum enCharaType)arg1);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestBoss(class mHRChara* const this) [?mTestBoss@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mTestBoss_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTestBoss()
	{
		_mTestBoss_mHRChara__QBE_NXZ mFunc = (_mTestBoss_mHRChara__QBE_NXZ)(GameModule + 0xa2c90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestEnemy(class mHRChara* const this) [?mTestEnemy@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mTestEnemy_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTestEnemy()
	{
		_mTestEnemy_mHRChara__QBE_NXZ mFunc = (_mTestEnemy_mHRChara__QBE_NXZ)(GameModule + 0xa2ca0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetItemNo(class mHRChara* const this, int32_t arg2) [?mSetItemNo@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _mSetItemNo_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	void mSetItemNo(int32_t arg2)
	{
		_mSetItemNo_mHRChara__QAEXH_Z mFunc = (_mSetItemNo_mHRChara__QAEXH_Z)(GameModule + 0xa2cc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetLockOnNoCheckColl(class mHRChara* const this, uint8_t arg2) [?mSetLockOnNoCheckColl@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetLockOnNoCheckColl_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetLockOnNoCheckColl(uint8_t arg2)
	{
		_mSetLockOnNoCheckColl_mHRChara__QAEX_N_Z mFunc = (_mSetLockOnNoCheckColl_mHRChara__QAEX_N_Z)(GameModule + 0xa2cd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetLockOnDistanceLow(class mHRChara* const this, float arg2) [?mSetLockOnDistanceLow@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetLockOnDistanceLow_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetLockOnDistanceLow(float arg2)
	{
		_mSetLockOnDistanceLow_mHRChara__QAEXM_Z mFunc = (_mSetLockOnDistanceLow_mHRChara__QAEXM_Z)(GameModule + 0xa2ce0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetLockOnDistanceHi(class mHRChara* const this, float arg2) [?mSetLockOnDistanceHi@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetLockOnDistanceHi_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetLockOnDistanceHi(float arg2)
	{
		_mSetLockOnDistanceHi_mHRChara__QAEXM_Z mFunc = (_mSetLockOnDistanceHi_mHRChara__QAEXM_Z)(GameModule + 0xa2cf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetLockOnDistance(class mHRChara* const this, float arg2) [?mSetLockOnDistance@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetLockOnDistance_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetLockOnDistance(float arg2)
	{
		_mSetLockOnDistance_mHRChara__QAEXM_Z mFunc = (_mSetLockOnDistance_mHRChara__QAEXM_Z)(GameModule + 0xa2d00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCanLockOn(class mHRChara* const this, uint8_t arg2) [?mSetCanLockOn@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCanLockOn_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetCanLockOn(uint8_t arg2)
	{
		_mSetCanLockOn_mHRChara__QAEX_N_Z mFunc = (_mSetCanLockOn_mHRChara__QAEX_N_Z)(GameModule + 0xa2d10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDisableDameged(class mHRChara* const this, uint8_t arg2) [?mSetDisableDameged@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDisableDameged_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetDisableDameged(uint8_t arg2)
	{
		_mSetDisableDameged_mHRChara__QAEX_N_Z mFunc = (_mSetDisableDameged_mHRChara__QAEX_N_Z)(GameModule + 0xa2d30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetDisableDameged(class mHRChara* const this) [?mGetDisableDameged@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDisableDameged_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetDisableDameged()
	{
		_mGetDisableDameged_mHRChara__QAE_NXZ mFunc = (_mGetDisableDameged_mHRChara__QAE_NXZ)(GameModule + 0xa2d50);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetMaxHp(class mHRChara* const this) [?mGetMaxHp@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetMaxHp_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetMaxHp()
	{
		_mGetMaxHp_mHRChara__QAEMXZ mFunc = (_mGetMaxHp_mHRChara__QAEMXZ)(GameModule + 0xa2d60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mUndispTgtIcn(class mHRChara* const this) [?mUndispTgtIcn@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mUndispTgtIcn_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mUndispTgtIcn()
	{
		_mUndispTgtIcn_mHRChara__QAE_NXZ mFunc = (_mUndispTgtIcn_mHRChara__QAE_NXZ)(GameModule + 0xa2d70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mDispTgtIcn(class mHRChara* const this) [?mDispTgtIcn@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mDispTgtIcn_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mDispTgtIcn()
	{
		_mDispTgtIcn_mHRChara__QAE_NXZ mFunc = (_mDispTgtIcn_mHRChara__QAE_NXZ)(GameModule + 0xa2df0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetHp(class mHRChara* const this) [?mGetHp@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetHp_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetHp()
	{
		_mGetHp_mHRChara__QAEMXZ mFunc = (_mGetHp_mHRChara__QAEMXZ)(GameModule + 0xa2e30);
		return mFunc(this);
	}
	// [Function] enum enCharaCondition __convention("thiscall") mHRChara::mGetCondition(class mHRChara* const this) [?mGetCondition@mHRChara@@QBE?AW4enCharaCondition@@XZ]
	typedef enum enCharaCondition(__thiscall* _mGetCondition_mHRChara__QBEAW4enCharaCondition__XZ)(class mHRChara* const thisPtr);
	/* enum enCharaCondition */ uint32_t mGetCondition()
	{
		_mGetCondition_mHRChara__QBEAW4enCharaCondition__XZ mFunc = (_mGetCondition_mHRChara__QBEAW4enCharaCondition__XZ)(GameModule + 0xa2fd0);
		return (uint32_t)mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRChara::mGetNext(class mHRChara* const this) [?mGetNext@mHRChara@@QAEPAV1@XZ]
	typedef class mHRChara*(__thiscall* _mGetNext_mHRChara__QAEPAV1_XZ)(class mHRChara* const thisPtr);
	class mHRChara* mGetNext()
	{
		_mGetNext_mHRChara__QAEPAV1_XZ mFunc = (_mGetNext_mHRChara__QAEPAV1_XZ)(GameModule + 0xa2fe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetHp(class mHRChara* const this, float arg2) [?mSetHp@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetHp_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetHp(float arg2)
	{
		_mSetHp_mHRChara__QAEXM_Z mFunc = (_mSetHp_mHRChara__QAEXM_Z)(GameModule + 0xa2ff0);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* mHRChara::mGetTop() [?mGetTop@mHRChara@@SAPAV1@XZ]
	typedef class mHRChara*(__fastcall* _mGetTop_mHRChara__SAPAV1_XZ)();
	static class mHRChara* mGetTop()
	{
		_mGetTop_mHRChara__SAPAV1_XZ mFunc = (_mGetTop_mHRChara__SAPAV1_XZ)(GameModule + 0xa3020);
		return mFunc();
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetRot(class mHRChara* const this) [?mGetRot@mHRChara@@QAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetRot_mHRChara__QAEAAUVec__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetRot()
	{
		_mGetRot_mHRChara__QAEAAUVec__XZ mFunc = (_mGetRot_mHRChara__QAEAAUVec__XZ)(GameModule + 0xa3030);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCharaPause(class mHRChara* const this, uint8_t arg2) [?mSetCharaPause@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCharaPause_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetCharaPause(uint8_t arg2)
	{
		_mSetCharaPause_mHRChara__QAEX_N_Z mFunc = (_mSetCharaPause_mHRChara__QAEX_N_Z)(GameModule + 0xa3150);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetRotY(class mHRChara* const this) [?mGetRotY@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetRotY_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetRotY()
	{
		_mGetRotY_mHRChara__QAEMXZ mFunc = (_mGetRotY_mHRChara__QAEMXZ)(GameModule + 0xa3180);
		return mFunc(this);
	}
	// [Function] struct WGclMaterialSpec* __convention("thiscall") mHRChara::GetGroundTouchMaterial(class mHRChara* const this) [?GetGroundTouchMaterial@mHRChara@@QBEPAUWGclMaterialSpec@@XZ]
	typedef struct WGclMaterialSpec*(__thiscall* _GetGroundTouchMaterial_mHRChara__QBEPAUWGclMaterialSpec__XZ)(class mHRChara* const thisPtr);
	struct WGclMaterialSpec* GetGroundTouchMaterial()
	{
		_GetGroundTouchMaterial_mHRChara__QBEPAUWGclMaterialSpec__XZ mFunc = (_GetGroundTouchMaterial_mHRChara__QBEPAUWGclMaterialSpec__XZ)(GameModule + 0xa3190);
		return mFunc(this);
	}
	// [Function] struct stCharaStatus* __convention("thiscall") mHRChara::mGetStatusPtr(class mHRChara* const this) [?mGetStatusPtr@mHRChara@@QAEPAUstCharaStatus@@XZ]
	typedef struct stCharaStatus*(__thiscall* _mGetStatusPtr_mHRChara__QAEPAUstCharaStatus__XZ)(class mHRChara* const thisPtr);
	struct stCharaStatus* mGetStatusPtr()
	{
		_mGetStatusPtr_mHRChara__QAEPAUstCharaStatus__XZ mFunc = (_mGetStatusPtr_mHRChara__QAEPAUstCharaStatus__XZ)(GameModule + 0xa3260);
		return mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetPos(class mHRChara* const this) [?mGetPos@mHRChara@@QAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetPos_mHRChara__QAEAAUVec__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetPos()
	{
		_mGetPos_mHRChara__QAEAAUVec__XZ mFunc = (_mGetPos_mHRChara__QAEAAUVec__XZ)(GameModule + 0xa3280);
		mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetMotionNo(class mHRChara* const this) [?mGetMotionNo@mHRChara@@QBEHXZ]
	typedef int32_t(__thiscall* _mGetMotionNo_mHRChara__QBEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetMotionNo()
	{
		_mGetMotionNo_mHRChara__QBEHXZ mFunc = (_mGetMotionNo_mHRChara__QBEHXZ)(GameModule + 0xa3290);
		return mFunc(this);
	}
	// [Function] char* __convention("thiscall") mHRChara::mGetFileName(class mHRChara* const this) [?mGetFileName@mHRChara@@QAEPADXZ]
	typedef char*(__thiscall* _mGetFileName_mHRChara__QAEPADXZ)(class mHRChara* const thisPtr);
	std::string mGetFileName()
	{
		_mGetFileName_mHRChara__QAEPADXZ mFunc = (_mGetFileName_mHRChara__QAEPADXZ)(GameModule + 0xa3ac0);
		char* OutResult = mFunc(this);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsTubaAngleCorrect(class mHRChara* const this) [?IsTubaAngleCorrect@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsTubaAngleCorrect_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsTubaAngleCorrect()
	{
		_IsTubaAngleCorrect_mHRChara__UAE_NXZ mFunc = (_IsTubaAngleCorrect_mHRChara__UAE_NXZ)(GameModule + 0xa48f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::getMiraretaiPosition(class mHRChara* const this, struct Vec* arg2) [?getMiraretaiPosition@mHRChara@@UBE_NPAUVec@@@Z]
	typedef uint8_t(__thiscall* _getMiraretaiPosition_mHRChara__UBE_NPAUVec___Z)(class mHRChara* const thisPtr, struct Vec* arg2);
	uint8_t getMiraretaiPosition(struct Vec* arg2)
	{
		_getMiraretaiPosition_mHRChara__UBE_NPAUVec___Z mFunc = (_getMiraretaiPosition_mHRChara__UBE_NPAUVec___Z)(GameModule + 0xa4900);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isHopeInterestMe(class mHRChara* const this) [?isHopeInterestMe@mHRChara@@UBE_NXZ]
	typedef uint8_t(__thiscall* _isHopeInterestMe_mHRChara__UBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t isHopeInterestMe()
	{
		_isHopeInterestMe_mHRChara__UBE_NXZ mFunc = (_isHopeInterestMe_mHRChara__UBE_NXZ)(GameModule + 0xa4910);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsWatchPc(class mHRChara* const this) [?IsWatchPc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsWatchPc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsWatchPc()
	{
		_IsWatchPc_mHRChara__UAE_NXZ mFunc = (_IsWatchPc_mHRChara__UAE_NXZ)(GameModule + 0xa4920);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsUseRotMov(class mHRChara* const this) [?IsUseRotMov@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsUseRotMov_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsUseRotMov()
	{
		_IsUseRotMov_mHRChara__UAE_NXZ mFunc = (_IsUseRotMov_mHRChara__UAE_NXZ)(GameModule + 0xa4930);
		return mFunc(this);
	}
	// [Function] char const* __convention("thiscall") mHRChara::getCurMotionName(class mHRChara* const this) [?getCurMotionName@mHRChara@@UBEPBDXZ]
	typedef char const*(__thiscall* _getCurMotionName_mHRChara__UBEPBDXZ)(class mHRChara* const thisPtr);
	std::string getCurMotionName()
	{
		_getCurMotionName_mHRChara__UBEPBDXZ mFunc = (_getCurMotionName_mHRChara__UBEPBDXZ)(GameModule + 0xa4940);
		char const* OutResult = mFunc(this);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestRunMotion(class mHRChara* const this) [?mTestRunMotion@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mTestRunMotion_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTestRunMotion()
	{
		_mTestRunMotion_mHRChara__UAE_NXZ mFunc = (_mTestRunMotion_mHRChara__UAE_NXZ)(GameModule + 0xa4970);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mZakoDieOut(class mHRChara* const this) [?mZakoDieOut@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mZakoDieOut_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mZakoDieOut()
	{
		_mZakoDieOut_mHRChara__UAE_NXZ mFunc = (_mZakoDieOut_mHRChara__UAE_NXZ)(GameModule + 0xa4980);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCreateLoseSight(class mHRChara* const this) [?mCreateLoseSight@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCreateLoseSight_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCreateLoseSight()
	{
		_mCreateLoseSight_mHRChara__UAE_NXZ mFunc = (_mCreateLoseSight_mHRChara__UAE_NXZ)(GameModule + 0xa4990);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckDamageMotion(class mHRChara* const this) [?mCheckDamageMotion@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckDamageMotion_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckDamageMotion()
	{
		_mCheckDamageMotion_mHRChara__UAE_NXZ mFunc = (_mCheckDamageMotion_mHRChara__UAE_NXZ)(GameModule + 0xa49a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckEnterMotion(class mHRChara* const this) [?mCheckEnterMotion@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckEnterMotion_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckEnterMotion()
	{
		_mCheckEnterMotion_mHRChara__UAE_NXZ mFunc = (_mCheckEnterMotion_mHRChara__UAE_NXZ)(GameModule + 0xa49b0);
		return mFunc(this);
	}
	// [Function] class TGan* __convention("thiscall") mHRChara::mpGetGan(class mHRChara* const this, int32_t arg2) [?mpGetGan@mHRChara@@UBEPBVTGan@@H@Z]
	typedef class TGan*(__thiscall* _mpGetGan_mHRChara__UBEPBVTGan__H_Z)(class mHRChara* const thisPtr, int32_t arg2);
	class TGan* mpGetGan(int32_t arg2)
	{
		_mpGetGan_mHRChara__UBEPBVTGan__H_Z mFunc = (_mpGetGan_mHRChara__UBEPBVTGan__H_Z)(GameModule + 0xa49c0);
		return mFunc(this, arg2);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetCurResourceGmfPtr(class mHRChara* const this) [?mGetCurResourceGmfPtr@mHRChara@@UAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetCurResourceGmfPtr_mHRChara__UAEPAVTGmf__XZ)(class mHRChara* const thisPtr);
	class TGmf* mGetCurResourceGmfPtr()
	{
		_mGetCurResourceGmfPtr_mHRChara__UAEPAVTGmf__XZ mFunc = (_mGetCurResourceGmfPtr_mHRChara__UAEPAVTGmf__XZ)(GameModule + 0xa49d0);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetCurResourceGmfPtr(class mHRChara* const this) [?mGetCurResourceGmfPtr@mHRChara@@UBEPBVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetCurResourceGmfPtr_mHRChara__UBEPBVTGmf__XZ_2)(class mHRChara* const thisPtr);
	class TGmf* mGetCurResourceGmfPtr_2()
	{
		_mGetCurResourceGmfPtr_mHRChara__UBEPBVTGmf__XZ_2 mFunc = (_mGetCurResourceGmfPtr_mHRChara__UBEPBVTGmf__XZ_2)(GameModule + 0xa49f0);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfWepLPtr(class mHRChara* const this) [?mGetResourceGmfWepLPtr@mHRChara@@UAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetResourceGmfWepLPtr_mHRChara__UAEPAVTGmf__XZ)(class mHRChara* const thisPtr);
	class TGmf* mGetResourceGmfWepLPtr()
	{
		_mGetResourceGmfWepLPtr_mHRChara__UAEPAVTGmf__XZ mFunc = (_mGetResourceGmfWepLPtr_mHRChara__UAEPAVTGmf__XZ)(GameModule + 0xa4a00);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfWepRPtr(class mHRChara* const this) [?mGetResourceGmfWepRPtr@mHRChara@@UAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetResourceGmfWepRPtr_mHRChara__UAEPAVTGmf__XZ)(class mHRChara* const thisPtr);
	class TGmf* mGetResourceGmfWepRPtr()
	{
		_mGetResourceGmfWepRPtr_mHRChara__UAEPAVTGmf__XZ mFunc = (_mGetResourceGmfWepRPtr_mHRChara__UAEPAVTGmf__XZ)(GameModule + 0xa4a10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetResourceGmfPtr(class mHRChara* const this, class TGmf* arg2, char* arg3) [?mSetResourceGmfPtr@mHRChara@@UAEXPAVTGmf@@PAD@Z]
	typedef void(__thiscall* _mSetResourceGmfPtr_mHRChara__UAEXPAVTGmf__PAD_Z)(class mHRChara* const thisPtr, class TGmf* arg2, char* arg3);
	void mSetResourceGmfPtr(class TGmf* arg2, std::string arg3)
	{
		std::vector<char> arg3_c_str(arg3.c_str(), + arg3.c_str() + arg3.size() + 1);
		_mSetResourceGmfPtr_mHRChara__UAEXPAVTGmf__PAD_Z mFunc = (_mSetResourceGmfPtr_mHRChara__UAEXPAVTGmf__PAD_Z)(GameModule + 0xa4a20);
		return mFunc(this, arg2, &arg3_c_str[0]);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfDeadPtr(class mHRChara* const this) [?mGetResourceGmfDeadPtr@mHRChara@@UBEPBVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetResourceGmfDeadPtr_mHRChara__UBEPBVTGmf__XZ)(class mHRChara* const thisPtr);
	class TGmf* mGetResourceGmfDeadPtr()
	{
		_mGetResourceGmfDeadPtr_mHRChara__UBEPBVTGmf__XZ mFunc = (_mGetResourceGmfDeadPtr_mHRChara__UBEPBVTGmf__XZ)(GameModule + 0xa4a60);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfDeadPtr(class mHRChara* const this) [?mGetResourceGmfDeadPtr@mHRChara@@UAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetResourceGmfDeadPtr_mHRChara__UAEPAVTGmf__XZ_2)(class mHRChara* const thisPtr);
	class TGmf* mGetResourceGmfDeadPtr_2()
	{
		_mGetResourceGmfDeadPtr_mHRChara__UAEPAVTGmf__XZ_2 mFunc = (_mGetResourceGmfDeadPtr_mHRChara__UAEPAVTGmf__XZ_2)(GameModule + 0xa4a70);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfPtr(class mHRChara* const this) [?mGetResourceGmfPtr@mHRChara@@UBEPBVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetResourceGmfPtr_mHRChara__UBEPBVTGmf__XZ)(class mHRChara* const thisPtr);
	class TGmf* mGetResourceGmfPtr()
	{
		_mGetResourceGmfPtr_mHRChara__UBEPBVTGmf__XZ mFunc = (_mGetResourceGmfPtr_mHRChara__UBEPBVTGmf__XZ)(GameModule + 0xa4a80);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfPtr(class mHRChara* const this) [?mGetResourceGmfPtr@mHRChara@@UAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetResourceGmfPtr_mHRChara__UAEPAVTGmf__XZ_2)(class mHRChara* const thisPtr);
	class TGmf* mGetResourceGmfPtr_2()
	{
		_mGetResourceGmfPtr_mHRChara__UAEPAVTGmf__XZ_2 mFunc = (_mGetResourceGmfPtr_mHRChara__UAEPAVTGmf__XZ_2)(GameModule + 0xa4a90);
		return mFunc(this);
	}
	// [Function] class ghmGcCollObjCapsule* __convention("thiscall") mHRChara::mGetCollPtr(class mHRChara* const this) [?mGetCollPtr@mHRChara@@UAEPAVghmGcCollObjCapsule@@XZ]
	typedef class ghmGcCollObjCapsule*(__thiscall* _mGetCollPtr_mHRChara__UAEPAVghmGcCollObjCapsule__XZ)(class mHRChara* const thisPtr);
	class ghmGcCollObjCapsule* mGetCollPtr()
	{
		_mGetCollPtr_mHRChara__UAEPAVghmGcCollObjCapsule__XZ mFunc = (_mGetCollPtr_mHRChara__UAEPAVghmGcCollObjCapsule__XZ)(GameModule + 0xa4aa0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSethitOidashiDisEnable(class mHRChara* const this, uint8_t arg2) [?mSethitOidashiDisEnable@mHRChara@@UAEX_N@Z]
	typedef void(__thiscall* _mSethitOidashiDisEnable_mHRChara__UAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSethitOidashiDisEnable(uint8_t arg2)
	{
		_mSethitOidashiDisEnable_mHRChara__UAEX_N_Z mFunc = (_mSethitOidashiDisEnable_mHRChara__UAEX_N_Z)(GameModule + 0xa4ab0);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetBrainPos(class mHRChara* const this) [?mGetBrainPos@mHRChara@@UAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetBrainPos_mHRChara__UAEAAUVec__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetBrainPos()
	{
		_mGetBrainPos_mHRChara__UAEAAUVec__XZ mFunc = (_mGetBrainPos_mHRChara__UAEAAUVec__XZ)(GameModule + 0xa4ae0);
		mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetHitPos(class mHRChara* const this) [?mGetHitPos@mHRChara@@UAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetHitPos_mHRChara__UAEAAUVec__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetHitPos()
	{
		_mGetHitPos_mHRChara__UAEAAUVec__XZ mFunc = (_mGetHitPos_mHRChara__UAEAAUVec__XZ)(GameModule + 0xa4af0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetMirrorModel(class mHRChara* const this) [?mGetMirrorModel@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mGetMirrorModel_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetMirrorModel()
	{
		_mGetMirrorModel_mHRChara__UAE_NXZ mFunc = (_mGetMirrorModel_mHRChara__UAE_NXZ)(GameModule + 0xa4b00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetVisibleDist(class mHRChara* const this) [?mGetVisibleDist@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mGetVisibleDist_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetVisibleDist()
	{
		_mGetVisibleDist_mHRChara__UAE_NXZ mFunc = (_mGetVisibleDist_mHRChara__UAE_NXZ)(GameModule + 0xa4b10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCondition(class mHRChara* const this, enum enCharaCondition arg2) [?mSetCondition@mHRChara@@UAEXW4enCharaCondition@@@Z]
	typedef void(__thiscall* _mSetCondition_mHRChara__UAEXW4enCharaCondition___Z)(class mHRChara* const thisPtr, enum enCharaCondition arg2);
	void mSetCondition(/* enum enCharaCondition */ uint32_t arg2)
	{
		_mSetCondition_mHRChara__UAEXW4enCharaCondition___Z mFunc = (_mSetCondition_mHRChara__UAEXW4enCharaCondition___Z)(GameModule + 0xa4b20);
		return mFunc(this, (enum enCharaCondition)arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetSubMotionSpd(class mHRChara* const this, float arg2) [?mSetSubMotionSpd@mHRChara@@UAEXM@Z]
	typedef void(__thiscall* _mSetSubMotionSpd_mHRChara__UAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetSubMotionSpd(float arg2)
	{
		_mSetSubMotionSpd_mHRChara__UAEXM_Z mFunc = (_mSetSubMotionSpd_mHRChara__UAEXM_Z)(GameModule + 0xa4b30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheck4tsunbai(class mHRChara* const this) [?mCheck4tsunbai@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheck4tsunbai_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheck4tsunbai()
	{
		_mCheck4tsunbai_mHRChara__UAE_NXZ mFunc = (_mCheck4tsunbai_mHRChara__UAE_NXZ)(GameModule + 0xa4b50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckSquat(class mHRChara* const this) [?mCheckSquat@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckSquat_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckSquat()
	{
		_mCheckSquat_mHRChara__UAE_NXZ mFunc = (_mCheckSquat_mHRChara__UAE_NXZ)(GameModule + 0xa4b60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mGetThrowMotNo(class mHRChara* const this, int32_t* arg2, int32_t* arg3) [?mGetThrowMotNo@mHRChara@@UAEXPAH0@Z]
	typedef void(__thiscall* _mGetThrowMotNo_mHRChara__UAEXPAH0_Z)(class mHRChara* const thisPtr, int32_t* arg2, int32_t* arg3);
	void mGetThrowMotNo(int32_t* arg2, int32_t* arg3)
	{
		_mGetThrowMotNo_mHRChara__UAEXPAH0_Z mFunc = (_mGetThrowMotNo_mHRChara__UAEXPAH0_Z)(GameModule + 0xa4b70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetTsubazeriMotionID(class mHRChara* const this) [?mGetTsubazeriMotionID@mHRChara@@UAEHXZ]
	typedef int32_t(__thiscall* _mGetTsubazeriMotionID_mHRChara__UAEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetTsubazeriMotionID()
	{
		_mGetTsubazeriMotionID_mHRChara__UAEHXZ mFunc = (_mGetTsubazeriMotionID_mHRChara__UAEHXZ)(GameModule + 0xa4b90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mTsubazeriDifficultyClear(class mHRChara* const this) [?mTsubazeriDifficultyClear@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mTsubazeriDifficultyClear_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mTsubazeriDifficultyClear()
	{
		_mTsubazeriDifficultyClear_mHRChara__UAEXXZ mFunc = (_mTsubazeriDifficultyClear_mHRChara__UAEXXZ)(GameModule + 0xa4ba0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mTsubazeriDifficultyUp(class mHRChara* const this) [?mTsubazeriDifficultyUp@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mTsubazeriDifficultyUp_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mTsubazeriDifficultyUp()
	{
		_mTsubazeriDifficultyUp_mHRChara__UAEXXZ mFunc = (_mTsubazeriDifficultyUp_mHRChara__UAEXXZ)(GameModule + 0xa4bb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsTubaPosAdjust(class mHRChara* const this) [?IsTubaPosAdjust@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsTubaPosAdjust_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsTubaPosAdjust()
	{
		_IsTubaPosAdjust_mHRChara__UAE_NXZ mFunc = (_IsTubaPosAdjust_mHRChara__UAE_NXZ)(GameModule + 0xa4bc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckGuard(class mHRChara* const this) [?mCheckGuard@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckGuard_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckGuard()
	{
		_mCheckGuard_mHRChara__UAE_NXZ mFunc = (_mCheckGuard_mHRChara__UAE_NXZ)(GameModule + 0xa4bd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckAttack(class mHRChara* const this) [?mCheckAttack@mHRChara@@UBE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAttack_mHRChara__UBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckAttack()
	{
		_mCheckAttack_mHRChara__UBE_NXZ mFunc = (_mCheckAttack_mHRChara__UBE_NXZ)(GameModule + 0xa4be0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSubTension(class mHRChara* const this, float arg2) [?mSubTension@mHRChara@@UAEXM@Z]
	typedef void(__thiscall* _mSubTension_mHRChara__UAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSubTension(float arg2)
	{
		_mSubTension_mHRChara__UAEXM_Z mFunc = (_mSubTension_mHRChara__UAEXM_Z)(GameModule + 0xa4bf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mAddTension(class mHRChara* const this, float arg2) [?mAddTension@mHRChara@@UAEXM@Z]
	typedef void(__thiscall* _mAddTension_mHRChara__UAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mAddTension(float arg2)
	{
		_mAddTension_mHRChara__UAEXM_Z mFunc = (_mAddTension_mHRChara__UAEXM_Z)(GameModule + 0xa4c30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetTension(class mHRChara* const this, float arg2) [?mSetTension@mHRChara@@UAEXM@Z]
	typedef void(__thiscall* _mSetTension_mHRChara__UAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetTension(float arg2)
	{
		_mSetTension_mHRChara__UAEXM_Z mFunc = (_mSetTension_mHRChara__UAEXM_Z)(GameModule + 0xa4c70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mResetTension(class mHRChara* const this) [?mResetTension@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mResetTension_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mResetTension()
	{
		_mResetTension_mHRChara__UAEXXZ mFunc = (_mResetTension_mHRChara__UAEXXZ)(GameModule + 0xa4cb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMovSpd(class mHRChara* const this, float arg2) [?mSetMovSpd@mHRChara@@UAEXM@Z]
	typedef void(__thiscall* _mSetMovSpd_mHRChara__UAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetMovSpd(float arg2)
	{
		_mSetMovSpd_mHRChara__UAEXM_Z mFunc = (_mSetMovSpd_mHRChara__UAEXM_Z)(GameModule + 0xa4cc0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::UnderControllAttack_A(class mHRChara* const this) [?UnderControllAttack_A@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _UnderControllAttack_A_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t UnderControllAttack_A()
	{
		_UnderControllAttack_A_mHRChara__UAE_NXZ mFunc = (_UnderControllAttack_A_mHRChara__UAE_NXZ)(GameModule + 0xa4ce0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::UnderControllComboAttack(class mHRChara* const this) [?UnderControllComboAttack@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _UnderControllComboAttack_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t UnderControllComboAttack()
	{
		_UnderControllComboAttack_mHRChara__UAE_NXZ mFunc = (_UnderControllComboAttack_mHRChara__UAE_NXZ)(GameModule + 0xa4cf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::ExitUnderControl(class mHRChara* const this) [?ExitUnderControl@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _ExitUnderControl_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void ExitUnderControl()
	{
		_ExitUnderControl_mHRChara__UAEXXZ mFunc = (_ExitUnderControl_mHRChara__UAEXXZ)(GameModule + 0xa4d00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::EnterUnderControl(class mHRChara* const this) [?EnterUnderControl@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _EnterUnderControl_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void EnterUnderControl()
	{
		_EnterUnderControl_mHRChara__UAEXXZ mFunc = (_EnterUnderControl_mHRChara__UAEXXZ)(GameModule + 0xa4d10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPostRenderProc(class mHRChara* const this) [?mPostRenderProc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostRenderProc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mPostRenderProc()
	{
		_mPostRenderProc_mHRChara__UAE_NXZ mFunc = (_mPostRenderProc_mHRChara__UAE_NXZ)(GameModule + 0xa4d20);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::getViewClipBoxPositionOffsetY(class mHRChara* const this) [?getViewClipBoxPositionOffsetY@mHRChara@@MBEMXZ]
	typedef float(__thiscall* _getViewClipBoxPositionOffsetY_mHRChara__MBEMXZ)(class mHRChara* const thisPtr);
	float getViewClipBoxPositionOffsetY()
	{
		_getViewClipBoxPositionOffsetY_mHRChara__MBEMXZ mFunc = (_getViewClipBoxPositionOffsetY_mHRChara__MBEMXZ)(GameModule + 0xa4d30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::getViewClipBoxHalfLengthXYZ(class mHRChara* const this, struct Vec* arg2) [?getViewClipBoxHalfLengthXYZ@mHRChara@@MBEXPAUVec@@@Z]
	typedef void(__thiscall* _getViewClipBoxHalfLengthXYZ_mHRChara__MBEXPAUVec___Z)(class mHRChara* const thisPtr, struct Vec* arg2);
	void getViewClipBoxHalfLengthXYZ(struct Vec* arg2)
	{
		_getViewClipBoxHalfLengthXYZ_mHRChara__MBEXPAUVec___Z mFunc = (_getViewClipBoxHalfLengthXYZ_mHRChara__MBEXPAUVec___Z)(GameModule + 0xa4d40);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetResNo(class mHRChara* const this) [?mGetResNo@mHRChara@@QBEHXZ]
	typedef int32_t(__thiscall* _mGetResNo_mHRChara__QBEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetResNo()
	{
		_mGetResNo_mHRChara__QBEHXZ mFunc = (_mGetResNo_mHRChara__QBEHXZ)(GameModule + 0xa4d60);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetDropMoney(class mHRChara* const this) [?mGetDropMoney@mHRChara@@QBEHXZ]
	typedef int32_t(__thiscall* _mGetDropMoney_mHRChara__QBEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetDropMoney()
	{
		_mGetDropMoney_mHRChara__QBEHXZ mFunc = (_mGetDropMoney_mHRChara__QBEHXZ)(GameModule + 0xa4d70);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetItemNo(class mHRChara* const this) [?mGetItemNo@mHRChara@@QBEHXZ]
	typedef int32_t(__thiscall* _mGetItemNo_mHRChara__QBEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetItemNo()
	{
		_mGetItemNo_mHRChara__QBEHXZ mFunc = (_mGetItemNo_mHRChara__QBEHXZ)(GameModule + 0xa4d80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::setLocatorNode(class mHRChara* const this, class TGmfNode* arg2) [?setLocatorNode@mHRChara@@UAEXPBVTGmfNode@@@Z]
	typedef void(__thiscall* _setLocatorNode_mHRChara__UAEXPBVTGmfNode___Z)(class mHRChara* const thisPtr, class TGmfNode* arg2);
	void setLocatorNode(class TGmfNode* arg2)
	{
		_setLocatorNode_mHRChara__UAEXPBVTGmfNode___Z mFunc = (_setLocatorNode_mHRChara__UAEXPBVTGmfNode___Z)(GameModule + 0xa4da0);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetHpRate(class mHRChara* const this) [?mGetHpRate@mHRChara@@QBEMXZ]
	typedef float(__thiscall* _mGetHpRate_mHRChara__QBEMXZ)(class mHRChara* const thisPtr);
	float mGetHpRate()
	{
		_mGetHpRate_mHRChara__QBEMXZ mFunc = (_mGetHpRate_mHRChara__QBEMXZ)(GameModule + 0xa4f00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSubHp(class mHRChara* const this, float arg2) [?mSubHp@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSubHp_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSubHp(float arg2)
	{
		_mSubHp_mHRChara__QAEXM_Z mFunc = (_mSubHp_mHRChara__QAEXM_Z)(GameModule + 0xa4f10);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetHitSize(class mHRChara* const this) [?mGetHitSize@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetHitSize_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetHitSize()
	{
		_mGetHitSize_mHRChara__QAEMXZ mFunc = (_mGetHitSize_mHRChara__QAEMXZ)(GameModule + 0xa4f60);
		return mFunc(this);
	}
	// [Function] enum enCharaInitProc __convention("thiscall") mHRChara::mGetInitProc(class mHRChara* const this) [?mGetInitProc@mHRChara@@QAE?AW4enCharaInitProc@@XZ]
	typedef enum enCharaInitProc(__thiscall* _mGetInitProc_mHRChara__QAEAW4enCharaInitProc__XZ)(class mHRChara* const thisPtr);
	/* enum enCharaInitProc */ uint32_t mGetInitProc()
	{
		_mGetInitProc_mHRChara__QAEAW4enCharaInitProc__XZ mFunc = (_mGetInitProc_mHRChara__QAEAW4enCharaInitProc__XZ)(GameModule + 0xa4f70);
		return (uint32_t)mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isCrashBreak(class mHRChara* const this) [?isCrashBreak@mHRChara@@UBE_NXZ]
	typedef uint8_t(__thiscall* _isCrashBreak_mHRChara__UBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t isCrashBreak()
	{
		_isCrashBreak_mHRChara__UBE_NXZ mFunc = (_isCrashBreak_mHRChara__UBE_NXZ)(GameModule + 0xa4fd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCharaHit(class mHRChara* const this, uint8_t arg2) [?mSetCharaHit@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCharaHit_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetCharaHit(uint8_t arg2)
	{
		_mSetCharaHit_mHRChara__QAEX_N_Z mFunc = (_mSetCharaHit_mHRChara__QAEX_N_Z)(GameModule + 0xa5120);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetDmgAtkMot(class mHRChara* const this) [?mGetDmgAtkMot@mHRChara@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetDmgAtkMot_mHRChara__QAEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetDmgAtkMot()
	{
		_mGetDmgAtkMot_mHRChara__QAEHXZ mFunc = (_mGetDmgAtkMot_mHRChara__QAEHXZ)(GameModule + 0xa5a80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMotionProcessDisEnable(class mHRChara* const this, uint8_t arg2) [?mSetMotionProcessDisEnable@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetMotionProcessDisEnable_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetMotionProcessDisEnable(uint8_t arg2)
	{
		_mSetMotionProcessDisEnable_mHRChara__QAEX_N_Z mFunc = (_mSetMotionProcessDisEnable_mHRChara__QAEX_N_Z)(GameModule + 0xa5a90);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetMotionSpd(class mHRChara* const this) [?mGetMotionSpd@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetMotionSpd_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetMotionSpd()
	{
		_mGetMotionSpd_mHRChara__QAEMXZ mFunc = (_mGetMotionSpd_mHRChara__QAEMXZ)(GameModule + 0xa5ae0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetStageHitDisEnable(class mHRChara* const this, uint8_t arg2) [?mSetStageHitDisEnable@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetStageHitDisEnable_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetStageHitDisEnable(uint8_t arg2)
	{
		_mSetStageHitDisEnable_mHRChara__QAEX_N_Z mFunc = (_mSetStageHitDisEnable_mHRChara__QAEX_N_Z)(GameModule + 0xa5af0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsFootShadowDraw(class mHRChara* const this) [?IsFootShadowDraw@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _IsFootShadowDraw_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsFootShadowDraw()
	{
		_IsFootShadowDraw_mHRChara__QBE_NXZ mFunc = (_IsFootShadowDraw_mHRChara__QBE_NXZ)(GameModule + 0xa5b30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetFootShadowDraw(class mHRChara* const this, uint8_t arg2) [?SetFootShadowDraw@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _SetFootShadowDraw_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void SetFootShadowDraw(uint8_t arg2)
	{
		_SetFootShadowDraw_mHRChara__QAEX_N_Z mFunc = (_SetFootShadowDraw_mHRChara__QAEX_N_Z)(GameModule + 0xa5b40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMotionNoNpc(class mHRChara* const this, int32_t arg2) [?mSetMotionNoNpc@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _mSetMotionNoNpc_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	void mSetMotionNoNpc(int32_t arg2)
	{
		_mSetMotionNoNpc_mHRChara__QAEXH_Z mFunc = (_mSetMotionNoNpc_mHRChara__QAEXH_Z)(GameModule + 0xa5b50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCallScriptProc(class mHRChara* const this, char* arg2) [?mSetCallScriptProc@mHRChara@@QAEXPAD@Z]
	typedef void(__thiscall* _mSetCallScriptProc_mHRChara__QAEXPAD_Z)(class mHRChara* const thisPtr, char* arg2);
	void mSetCallScriptProc(std::string arg2)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_mSetCallScriptProc_mHRChara__QAEXPAD_Z mFunc = (_mSetCallScriptProc_mHRChara__QAEXPAD_Z)(GameModule + 0xa5b60);
		return mFunc(this, &arg2_c_str[0]);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDropMoney(class mHRChara* const this, int32_t arg2) [?mSetDropMoney@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _mSetDropMoney_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	void mSetDropMoney(int32_t arg2)
	{
		_mSetDropMoney_mHRChara__QAEXH_Z mFunc = (_mSetDropMoney_mHRChara__QAEXH_Z)(GameModule + 0xa5b70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetReactionDist(class mHRChara* const this, float arg2) [?mSetReactionDist@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetReactionDist_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetReactionDist(float arg2)
	{
		_mSetReactionDist_mHRChara__QAEXM_Z mFunc = (_mSetReactionDist_mHRChara__QAEXM_Z)(GameModule + 0xa5b80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetEnterPattern(class mHRChara* const this, int32_t arg2) [?mSetEnterPattern@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _mSetEnterPattern_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	void mSetEnterPattern(int32_t arg2)
	{
		_mSetEnterPattern_mHRChara__QAEXH_Z mFunc = (_mSetEnterPattern_mHRChara__QAEXH_Z)(GameModule + 0xa5b90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDatNo(class mHRChara* const this, int32_t arg2) [?mSetDatNo@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _mSetDatNo_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	void mSetDatNo(int32_t arg2)
	{
		_mSetDatNo_mHRChara__QAEXH_Z mFunc = (_mSetDatNo_mHRChara__QAEXH_Z)(GameModule + 0xa5ba0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetResNo(class mHRChara* const this, int32_t arg2) [?mSetResNo@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _mSetResNo_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	void mSetResNo(int32_t arg2)
	{
		_mSetResNo_mHRChara__QAEXH_Z mFunc = (_mSetResNo_mHRChara__QAEXH_Z)(GameModule + 0xa5bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCharaType(class mHRChara* const this, enum enCharaType arg2) [?mSetCharaType@mHRChara@@QAEXW4enCharaType@@@Z]
	typedef void(__thiscall* _mSetCharaType_mHRChara__QAEXW4enCharaType___Z)(class mHRChara* const thisPtr, enum enCharaType arg2);
	void mSetCharaType(/* enum enCharaType */ uint32_t arg2)
	{
		_mSetCharaType_mHRChara__QAEXW4enCharaType___Z mFunc = (_mSetCharaType_mHRChara__QAEXW4enCharaType___Z)(GameModule + 0xa5bc0);
		return mFunc(this, (enum enCharaType)arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetDatNo(class mHRChara* const this) [?mGetDatNo@mHRChara@@QBEHXZ]
	typedef int32_t(__thiscall* _mGetDatNo_mHRChara__QBEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetDatNo()
	{
		_mGetDatNo_mHRChara__QBEHXZ mFunc = (_mGetDatNo_mHRChara__QBEHXZ)(GameModule + 0xa5bd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetResourceDeleteFlag(class mHRChara* const this) [?mGetResourceDeleteFlag@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetResourceDeleteFlag_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetResourceDeleteFlag()
	{
		_mGetResourceDeleteFlag_mHRChara__QAE_NXZ mFunc = (_mGetResourceDeleteFlag_mHRChara__QAE_NXZ)(GameModule + 0xa5be0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetDmgUpperPosY(class mHRChara* const this) [?mGetDmgUpperPosY@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetDmgUpperPosY_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetDmgUpperPosY()
	{
		_mGetDmgUpperPosY_mHRChara__QAEMXZ mFunc = (_mGetDmgUpperPosY_mHRChara__QAEMXZ)(GameModule + 0xa5c00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetDmgUpper(class mHRChara* const this) [?mGetDmgUpper@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDmgUpper_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetDmgUpper()
	{
		_mGetDmgUpper_mHRChara__QAE_NXZ mFunc = (_mGetDmgUpper_mHRChara__QAE_NXZ)(GameModule + 0xa5c10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetResourceDeleteFlag(class mHRChara* const this, uint8_t arg2) [?mSetResourceDeleteFlag@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetResourceDeleteFlag_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetResourceDeleteFlag(uint8_t arg2)
	{
		_mSetResourceDeleteFlag_mHRChara__QAEX_N_Z mFunc = (_mSetResourceDeleteFlag_mHRChara__QAEX_N_Z)(GameModule + 0xa5c50);
		return mFunc(this, arg2);
	}
	// [Function] class ghmPlane& __convention("thiscall") mHRChara::getLatestGroundTouchPlane(class mHRChara* const this) [?getLatestGroundTouchPlane@mHRChara@@QBEABVghmPlane@@XZ]
	typedef class ghmPlane&(__thiscall* _getLatestGroundTouchPlane_mHRChara__QBEABVghmPlane__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'class ghmPlane&' [TypeClass.PointerTypeClass] in LuaBridge
	void getLatestGroundTouchPlane()
	{
		_getLatestGroundTouchPlane_mHRChara__QBEABVghmPlane__XZ mFunc = (_getLatestGroundTouchPlane_mHRChara__QBEABVghmPlane__XZ)(GameModule + 0xa89d0);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mUndispBtlIcn(class mHRChara* const this) [?mUndispBtlIcn@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mUndispBtlIcn_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mUndispBtlIcn()
	{
		_mUndispBtlIcn_mHRChara__QAEXXZ mFunc = (_mUndispBtlIcn_mHRChara__QAEXXZ)(GameModule + 0xa94a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnFinishDemo(class mHRChara* const this, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4) [?mChgBtlIcnFinishDemo@mHRChara@@QAEXW4E_CON_ACT_ID@HrBattleIcon@@0_N@Z]
	typedef void(__thiscall* _mChgBtlIcnFinishDemo_mHRChara__QAEXW4E_CON_ACT_ID_HrBattleIcon__0_N_Z)(class mHRChara* const thisPtr, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4);
	void mChgBtlIcnFinishDemo(/* enum HrBattleIcon::E_CON_ACT_ID */ uint32_t arg2, /* enum HrBattleIcon::E_CON_ACT_ID */ uint32_t arg3, uint8_t arg4)
	{
		_mChgBtlIcnFinishDemo_mHRChara__QAEXW4E_CON_ACT_ID_HrBattleIcon__0_N_Z mFunc = (_mChgBtlIcnFinishDemo_mHRChara__QAEXW4E_CON_ACT_ID_HrBattleIcon__0_N_Z)(GameModule + 0xa94d0);
		return mFunc(this, (enum HrBattleIcon::E_CON_ACT_ID)arg2, (enum HrBattleIcon::E_CON_ACT_ID)arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnTb(class mHRChara* const this) [?mChgBtlIcnTb@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mChgBtlIcnTb_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mChgBtlIcnTb()
	{
		_mChgBtlIcnTb_mHRChara__QAEXXZ mFunc = (_mChgBtlIcnTb_mHRChara__QAEXXZ)(GameModule + 0xa9510);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnFinishDemo(class mHRChara* const this, enum HrBattleIcon::D_TODOME_DIRECT arg2) [?mChgBtlIcnFinishDemo@mHRChara@@QAEXW4D_TODOME_DIRECT@HrBattleIcon@@@Z]
	typedef void(__thiscall* _mChgBtlIcnFinishDemo_mHRChara__QAEXW4D_TODOME_DIRECT_HrBattleIcon___Z_2)(class mHRChara* const thisPtr, enum HrBattleIcon::D_TODOME_DIRECT arg2);
	void mChgBtlIcnFinishDemo_2(/* enum HrBattleIcon::D_TODOME_DIRECT */ uint32_t arg2)
	{
		_mChgBtlIcnFinishDemo_mHRChara__QAEXW4D_TODOME_DIRECT_HrBattleIcon___Z_2 mFunc = (_mChgBtlIcnFinishDemo_mHRChara__QAEXW4D_TODOME_DIRECT_HrBattleIcon___Z_2)(GameModule + 0xa9520);
		return mFunc(this, (enum HrBattleIcon::D_TODOME_DIRECT)arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::SetDrawYAdjust(class mHRChara* const this, float arg2) [?SetDrawYAdjust@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _SetDrawYAdjust_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void SetDrawYAdjust(float arg2)
	{
		_SetDrawYAdjust_mHRChara__QAEXM_Z mFunc = (_SetDrawYAdjust_mHRChara__QAEXM_Z)(GameModule + 0xa9af0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDemoCtrl(class mHRChara* const this, uint8_t arg2) [?mSetDemoCtrl@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDemoCtrl_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetDemoCtrl(uint8_t arg2)
	{
		_mSetDemoCtrl_mHRChara__QAEX_N_Z mFunc = (_mSetDemoCtrl_mHRChara__QAEX_N_Z)(GameModule + 0xa9b10);
		return mFunc(this, arg2);
	}
	// [Function] uint64_t __convention("thiscall") mHRChara::mGetDemoCtrl(class mHRChara* const this) [?mGetDemoCtrl@mHRChara@@QAE_KXZ]
	typedef uint64_t(__thiscall* _mGetDemoCtrl_mHRChara__QAE_KXZ)(class mHRChara* const thisPtr);
	uint64_t mGetDemoCtrl()
	{
		_mGetDemoCtrl_mHRChara__QAE_KXZ mFunc = (_mGetDemoCtrl_mHRChara__QAE_KXZ)(GameModule + 0xa9b90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isAcceptDistanceDelete(class mHRChara* const this) [?isAcceptDistanceDelete@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _isAcceptDistanceDelete_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t isAcceptDistanceDelete()
	{
		_isAcceptDistanceDelete_mHRChara__UAE_NXZ mFunc = (_isAcceptDistanceDelete_mHRChara__UAE_NXZ)(GameModule + 0xab940);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetStageHitDisEnableReq(class mHRChara* const this, uint8_t arg2) [?mSetStageHitDisEnableReq@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetStageHitDisEnableReq_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetStageHitDisEnableReq(uint8_t arg2)
	{
		_mSetStageHitDisEnableReq_mHRChara__QAEX_N_Z mFunc = (_mSetStageHitDisEnableReq_mHRChara__QAEX_N_Z)(GameModule + 0xab950);
		return mFunc(this, arg2);
	}
	// [Function] struct stCharaEffect* __convention("thiscall") mHRChara::mGetEffectStPtr(class mHRChara* const this) [?mGetEffectStPtr@mHRChara@@QAEPAUstCharaEffect@@XZ]
	typedef struct stCharaEffect*(__thiscall* _mGetEffectStPtr_mHRChara__QAEPAUstCharaEffect__XZ)(class mHRChara* const thisPtr);
	struct stCharaEffect* mGetEffectStPtr()
	{
		_mGetEffectStPtr_mHRChara__QAEPAUstCharaEffect__XZ mFunc = (_mGetEffectStPtr_mHRChara__QAEPAUstCharaEffect__XZ)(GameModule + 0xab960);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::setBlackBodyEffect(class mHRChara* const this, class EffectEnemyDamage* arg2) [?setBlackBodyEffect@mHRChara@@QAEXPAVEffectEnemyDamage@@@Z]
	typedef void(__thiscall* _setBlackBodyEffect_mHRChara__QAEXPAVEffectEnemyDamage___Z)(class mHRChara* const thisPtr, class EffectEnemyDamage* arg2);
	void setBlackBodyEffect(class EffectEnemyDamage* arg2)
	{
		_setBlackBodyEffect_mHRChara__QAEXPAVEffectEnemyDamage___Z mFunc = (_setBlackBodyEffect_mHRChara__QAEXPAVEffectEnemyDamage___Z)(GameModule + 0xab970);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetNavelPos(class mHRChara* const this) [?mGetNavelPos@mHRChara@@UAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetNavelPos_mHRChara__UAEAAUVec__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetNavelPos()
	{
		_mGetNavelPos_mHRChara__UAEAAUVec__XZ mFunc = (_mGetNavelPos_mHRChara__UAEAAUVec__XZ)(GameModule + 0xab980);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDamageAcceptFrame(class mHRChara* const this, int32_t arg2) [?mSetDamageAcceptFrame@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _mSetDamageAcceptFrame_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	void mSetDamageAcceptFrame(int32_t arg2)
	{
		_mSetDamageAcceptFrame_mHRChara__QAEXH_Z mFunc = (_mSetDamageAcceptFrame_mHRChara__QAEXH_Z)(GameModule + 0xab990);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetAlwaysCheckHitColl(class mHRChara* const this, uint8_t arg2) [?mSetAlwaysCheckHitColl@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetAlwaysCheckHitColl_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetAlwaysCheckHitColl(uint8_t arg2)
	{
		_mSetAlwaysCheckHitColl_mHRChara__QAEX_N_Z mFunc = (_mSetAlwaysCheckHitColl_mHRChara__QAEX_N_Z)(GameModule + 0xab9a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetLockOnNoCheckColl(class mHRChara* const this) [?mGetLockOnNoCheckColl@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetLockOnNoCheckColl_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetLockOnNoCheckColl()
	{
		_mGetLockOnNoCheckColl_mHRChara__QAE_NXZ mFunc = (_mGetLockOnNoCheckColl_mHRChara__QAE_NXZ)(GameModule + 0xaba30);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetLockOnDistanceLow(class mHRChara* const this) [?mGetLockOnDistanceLow@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetLockOnDistanceLow_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetLockOnDistanceLow()
	{
		_mGetLockOnDistanceLow_mHRChara__QAEMXZ mFunc = (_mGetLockOnDistanceLow_mHRChara__QAEMXZ)(GameModule + 0xaba40);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetLockOnDistanceHi(class mHRChara* const this) [?mGetLockOnDistanceHi@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetLockOnDistanceHi_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetLockOnDistanceHi()
	{
		_mGetLockOnDistanceHi_mHRChara__QAEMXZ mFunc = (_mGetLockOnDistanceHi_mHRChara__QAEMXZ)(GameModule + 0xaba50);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetLockOnDistance(class mHRChara* const this) [?mGetLockOnDistance@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetLockOnDistance_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetLockOnDistance()
	{
		_mGetLockOnDistance_mHRChara__QAEMXZ mFunc = (_mGetLockOnDistance_mHRChara__QAEMXZ)(GameModule + 0xaba60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetAliveBtlIcn(class mHRChara* const this) [?mGetAliveBtlIcn@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetAliveBtlIcn_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetAliveBtlIcn()
	{
		_mGetAliveBtlIcn_mHRChara__QAE_NXZ mFunc = (_mGetAliveBtlIcn_mHRChara__QAE_NXZ)(GameModule + 0xaba70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnFinish(class mHRChara* const this, enum HrBattleIcon::D_TODOME_DIRECT arg2) [?mChgBtlIcnFinish@mHRChara@@QAEXW4D_TODOME_DIRECT@HrBattleIcon@@@Z]
	typedef void(__thiscall* _mChgBtlIcnFinish_mHRChara__QAEXW4D_TODOME_DIRECT_HrBattleIcon___Z)(class mHRChara* const thisPtr, enum HrBattleIcon::D_TODOME_DIRECT arg2);
	void mChgBtlIcnFinish(/* enum HrBattleIcon::D_TODOME_DIRECT */ uint32_t arg2)
	{
		_mChgBtlIcnFinish_mHRChara__QAEXW4D_TODOME_DIRECT_HrBattleIcon___Z mFunc = (_mChgBtlIcnFinish_mHRChara__QAEXW4D_TODOME_DIRECT_HrBattleIcon___Z)(GameModule + 0xaba80);
		return mFunc(this, (enum HrBattleIcon::D_TODOME_DIRECT)arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnFinish(class mHRChara* const this, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4) [?mChgBtlIcnFinish@mHRChara@@QAEXW4E_CON_ACT_ID@HrBattleIcon@@0_N@Z]
	typedef void(__thiscall* _mChgBtlIcnFinish_mHRChara__QAEXW4E_CON_ACT_ID_HrBattleIcon__0_N_Z_2)(class mHRChara* const thisPtr, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4);
	void mChgBtlIcnFinish_2(/* enum HrBattleIcon::E_CON_ACT_ID */ uint32_t arg2, /* enum HrBattleIcon::E_CON_ACT_ID */ uint32_t arg3, uint8_t arg4)
	{
		_mChgBtlIcnFinish_mHRChara__QAEXW4E_CON_ACT_ID_HrBattleIcon__0_N_Z_2 mFunc = (_mChgBtlIcnFinish_mHRChara__QAEXW4E_CON_ACT_ID_HrBattleIcon__0_N_Z_2)(GameModule + 0xabaa0);
		return mFunc(this, (enum HrBattleIcon::E_CON_ACT_ID)arg2, (enum HrBattleIcon::E_CON_ACT_ID)arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetSlowBlow(class mHRChara* const this, uint8_t arg2) [?mSetSlowBlow@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetSlowBlow_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetSlowBlow(uint8_t arg2)
	{
		_mSetSlowBlow_mHRChara__QAEX_N_Z mFunc = (_mSetSlowBlow_mHRChara__QAEX_N_Z)(GameModule + 0xabac0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetInputFinishReq(class mHRChara* const this, uint8_t arg2) [?mSetInputFinishReq@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetInputFinishReq_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetInputFinishReq(uint8_t arg2)
	{
		_mSetInputFinishReq_mHRChara__QAEX_N_Z mFunc = (_mSetInputFinishReq_mHRChara__QAEX_N_Z)(GameModule + 0xabad0);
		return mFunc(this, arg2);
	}
	// [Function] class TGan* __convention("thiscall") mHRChara::mGetResourceGanPtr(class mHRChara* const this, int32_t arg2) [?mGetResourceGanPtr@mHRChara@@QAEPAVTGan@@H@Z]
	typedef class TGan*(__thiscall* _mGetResourceGanPtr_mHRChara__QAEPAVTGan__H_Z)(class mHRChara* const thisPtr, int32_t arg2);
	class TGan* mGetResourceGanPtr(int32_t arg2)
	{
		_mGetResourceGanPtr_mHRChara__QAEPAVTGan__H_Z mFunc = (_mGetResourceGanPtr_mHRChara__QAEPAVTGan__H_Z)(GameModule + 0xabaf0);
		return mFunc(this, arg2);
	}
	// [Function] int16_t __convention("thiscall") mHRChara::mGetMoney(class mHRChara* const this) [?mGetMoney@mHRChara@@QAEFXZ]
	typedef int16_t(__thiscall* _mGetMoney_mHRChara__QAEFXZ)(class mHRChara* const thisPtr);
	int16_t mGetMoney()
	{
		_mGetMoney_mHRChara__QAEFXZ mFunc = (_mGetMoney_mHRChara__QAEFXZ)(GameModule + 0xabb00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMoney(class mHRChara* const this, int16_t arg2) [?mSetMoney@mHRChara@@QAEXF@Z]
	typedef void(__thiscall* _mSetMoney_mHRChara__QAEXF_Z)(class mHRChara* const thisPtr, int16_t arg2);
	void mSetMoney(int16_t arg2)
	{
		_mSetMoney_mHRChara__QAEXF_Z mFunc = (_mSetMoney_mHRChara__QAEXF_Z)(GameModule + 0xabb10);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetInputFinishReq(class mHRChara* const this) [?mGetInputFinishReq@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetInputFinishReq_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetInputFinishReq()
	{
		_mGetInputFinishReq_mHRChara__QAE_NXZ mFunc = (_mGetInputFinishReq_mHRChara__QAE_NXZ)(GameModule + 0xabb20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mAddMoney(class mHRChara* const this, int16_t arg2) [?mAddMoney@mHRChara@@QAEXF@Z]
	typedef void(__thiscall* _mAddMoney_mHRChara__QAEXF_Z)(class mHRChara* const thisPtr, int16_t arg2);
	void mAddMoney(int16_t arg2)
	{
		_mAddMoney_mHRChara__QAEXF_Z mFunc = (_mAddMoney_mHRChara__QAEXF_Z)(GameModule + 0xabb30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetInvincibleMotion(class mHRChara* const this, int32_t arg2, int32_t arg3) [?mSetInvincibleMotion@mHRChara@@QAEXHH@Z]
	typedef void(__thiscall* _mSetInvincibleMotion_mHRChara__QAEXHH_Z)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3);
	void mSetInvincibleMotion(int32_t arg2, int32_t arg3)
	{
		_mSetInvincibleMotion_mHRChara__QAEXHH_Z mFunc = (_mSetInvincibleMotion_mHRChara__QAEXHH_Z)(GameModule + 0xabb40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mResetInvincibleMotion(class mHRChara* const this) [?mResetInvincibleMotion@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mResetInvincibleMotion_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mResetInvincibleMotion()
	{
		_mResetInvincibleMotion_mHRChara__QAEXXZ mFunc = (_mResetInvincibleMotion_mHRChara__QAEXXZ)(GameModule + 0xabb60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCanGetHitByMotion(class mHRChara* const this, int32_t arg2) [?mCanGetHitByMotion@mHRChara@@QBE_NH@Z]
	typedef uint8_t(__thiscall* _mCanGetHitByMotion_mHRChara__QBE_NH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	uint8_t mCanGetHitByMotion(int32_t arg2)
	{
		_mCanGetHitByMotion_mHRChara__QBE_NH_Z mFunc = (_mCanGetHitByMotion_mHRChara__QBE_NH_Z)(GameModule + 0xabb80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mDispAtkHitIcn(class mHRChara* const this) [?mDispAtkHitIcn@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mDispAtkHitIcn_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mDispAtkHitIcn()
	{
		_mDispAtkHitIcn_mHRChara__QAE_NXZ mFunc = (_mDispAtkHitIcn_mHRChara__QAE_NXZ)(GameModule + 0xabbb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetDontStandUp(class mHRChara* const this) [?mGetDontStandUp@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDontStandUp_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetDontStandUp()
	{
		_mGetDontStandUp_mHRChara__QAE_NXZ mFunc = (_mGetDontStandUp_mHRChara__QAE_NXZ)(GameModule + 0xabbd0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::GetTubaFrmOffset(class mHRChara* const this) [?GetTubaFrmOffset@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _GetTubaFrmOffset_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float GetTubaFrmOffset()
	{
		_GetTubaFrmOffset_mHRChara__QAEMXZ mFunc = (_GetTubaFrmOffset_mHRChara__QAEMXZ)(GameModule + 0xabbe0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::GetAtkDisAdjust(class mHRChara* const this) [?GetAtkDisAdjust@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _GetAtkDisAdjust_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float GetAtkDisAdjust()
	{
		_GetAtkDisAdjust_mHRChara__QAEMXZ mFunc = (_GetAtkDisAdjust_mHRChara__QAEMXZ)(GameModule + 0xabbf0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetLoseTsubazeriFlag(class mHRChara* const this) [?mGetLoseTsubazeriFlag@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetLoseTsubazeriFlag_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetLoseTsubazeriFlag()
	{
		_mGetLoseTsubazeriFlag_mHRChara__QAE_NXZ mFunc = (_mGetLoseTsubazeriFlag_mHRChara__QAE_NXZ)(GameModule + 0xabc00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetSuccessThrow(class mHRChara* const this, uint8_t arg2) [?mSetSuccessThrow@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetSuccessThrow_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetSuccessThrow(uint8_t arg2)
	{
		_mSetSuccessThrow_mHRChara__QAEX_N_Z mFunc = (_mSetSuccessThrow_mHRChara__QAEX_N_Z)(GameModule + 0xabc10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetRotYA(class mHRChara* const this, float arg2) [?mSetRotYA@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetRotYA_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetRotYA(float arg2)
	{
		_mSetRotYA_mHRChara__QAEXM_Z mFunc = (_mSetRotYA_mHRChara__QAEXM_Z)(GameModule + 0xabc40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDontStandUp(class mHRChara* const this, uint8_t arg2) [?mSetDontStandUp@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDontStandUp_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetDontStandUp(uint8_t arg2)
	{
		_mSetDontStandUp_mHRChara__QAEX_N_Z mFunc = (_mSetDontStandUp_mHRChara__QAEX_N_Z)(GameModule + 0xabc50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDmgGrav(class mHRChara* const this, float arg2) [?mSetDmgGrav@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetDmgGrav_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetDmgGrav(float arg2)
	{
		_mSetDmgGrav_mHRChara__QAEXM_Z mFunc = (_mSetDmgGrav_mHRChara__QAEXM_Z)(GameModule + 0xabc80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnSml(class mHRChara* const this, uint8_t arg2) [?mChgBtlIcnSml@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mChgBtlIcnSml_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mChgBtlIcnSml(uint8_t arg2)
	{
		_mChgBtlIcnSml_mHRChara__QAEX_N_Z mFunc = (_mChgBtlIcnSml_mHRChara__QAEX_N_Z)(GameModule + 0xabc90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnBig(class mHRChara* const this) [?mChgBtlIcnBig@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mChgBtlIcnBig_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mChgBtlIcnBig()
	{
		_mChgBtlIcnBig_mHRChara__QAEXXZ mFunc = (_mChgBtlIcnBig_mHRChara__QAEXXZ)(GameModule + 0xabe10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetCharaHit(class mHRChara* const this) [?mGetCharaHit@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetCharaHit_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetCharaHit()
	{
		_mGetCharaHit_mHRChara__QAE_NXZ mFunc = (_mGetCharaHit_mHRChara__QAE_NXZ)(GameModule + 0xabf20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetCanLockOn(class mHRChara* const this) [?mGetCanLockOn@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetCanLockOn_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetCanLockOn()
	{
		_mGetCanLockOn_mHRChara__QAE_NXZ mFunc = (_mGetCanLockOn_mHRChara__QAE_NXZ)(GameModule + 0xabf30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGethitOidashiDisEnable(class mHRChara* const this) [?mGethitOidashiDisEnable@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGethitOidashiDisEnable_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGethitOidashiDisEnable()
	{
		_mGethitOidashiDisEnable_mHRChara__QAE_NXZ mFunc = (_mGethitOidashiDisEnable_mHRChara__QAE_NXZ)(GameModule + 0xabf40);
		return mFunc(this);
	}
	// [Function] enum HrBattleIcon::D_BICON_STAT __convention("thiscall") mHRChara::mGetBtlIcnStatus(class mHRChara* const this) [?mGetBtlIcnStatus@mHRChara@@QAE?AW4D_BICON_STAT@HrBattleIcon@@XZ]
	typedef enum HrBattleIcon::D_BICON_STAT(__thiscall* _mGetBtlIcnStatus_mHRChara__QAEAW4D_BICON_STAT_HrBattleIcon__XZ)(class mHRChara* const thisPtr);
	/* enum HrBattleIcon::D_BICON_STAT */ uint32_t mGetBtlIcnStatus()
	{
		_mGetBtlIcnStatus_mHRChara__QAEAW4D_BICON_STAT_HrBattleIcon__XZ mFunc = (_mGetBtlIcnStatus_mHRChara__QAEAW4D_BICON_STAT_HrBattleIcon__XZ)(GameModule + 0xabf60);
		return (uint32_t)mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetWepVisible(class mHRChara* const this) [?mGetWepVisible@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetWepVisible_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetWepVisible()
	{
		_mGetWepVisible_mHRChara__QAE_NXZ mFunc = (_mGetWepVisible_mHRChara__QAE_NXZ)(GameModule + 0xabf90);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetMotionBrendNum(class mHRChara* const this) [?mGetMotionBrendNum@mHRChara@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetMotionBrendNum_mHRChara__QAEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetMotionBrendNum()
	{
		_mGetMotionBrendNum_mHRChara__QAEHXZ mFunc = (_mGetMotionBrendNum_mHRChara__QAEHXZ)(GameModule + 0xac020);
		return mFunc(this);
	}
	// [Function] int16_t __convention("thiscall") mHRChara::mGetAiValue(class mHRChara* const this, int32_t arg2) [?mGetAiValue@mHRChara@@QAEFH@Z]
	typedef int16_t(__thiscall* _mGetAiValue_mHRChara__QAEFH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	int16_t mGetAiValue(int32_t arg2)
	{
		_mGetAiValue_mHRChara__QAEFH_Z mFunc = (_mGetAiValue_mHRChara__QAEFH_Z)(GameModule + 0xac030);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mResetPosA(class mHRChara* const this) [?mResetPosA@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mResetPosA_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mResetPosA()
	{
		_mResetPosA_mHRChara__QAEXXZ mFunc = (_mResetPosA_mHRChara__QAEXXZ)(GameModule + 0xac040);
		return mFunc(this);
	}
	// [Function] class ghmPlane& __convention("thiscall") mHRChara::getEasyShadowProjectionPlane(class mHRChara* const this) [?getEasyShadowProjectionPlane@mHRChara@@QBEABVghmPlane@@XZ]
	typedef class ghmPlane&(__thiscall* _getEasyShadowProjectionPlane_mHRChara__QBEABVghmPlane__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'class ghmPlane&' [TypeClass.PointerTypeClass] in LuaBridge
	void getEasyShadowProjectionPlane()
	{
		_getEasyShadowProjectionPlane_mHRChara__QBEABVghmPlane__XZ mFunc = (_getEasyShadowProjectionPlane_mHRChara__QBEABVghmPlane__XZ)(GameModule + 0xac0d0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isInterestTarget(class mHRChara* const this) [?isInterestTarget@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _isInterestTarget_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t isInterestTarget()
	{
		_isInterestTarget_mHRChara__QBE_NXZ mFunc = (_isInterestTarget_mHRChara__QBE_NXZ)(GameModule + 0xac100);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMotionSpd(class mHRChara* const this, float arg2) [?mSetMotionSpd@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetMotionSpd_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetMotionSpd(float arg2)
	{
		_mSetMotionSpd_mHRChara__QAEXM_Z mFunc = (_mSetMotionSpd_mHRChara__QAEXM_Z)(GameModule + 0xac140);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetWepEffectVisible(class mHRChara* const this) [?mGetWepEffectVisible@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetWepEffectVisible_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetWepEffectVisible()
	{
		_mGetWepEffectVisible_mHRChara__QAE_NXZ mFunc = (_mGetWepEffectVisible_mHRChara__QAE_NXZ)(GameModule + 0xac150);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetVisible(class mHRChara* const this) [?mGetVisible@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetVisible_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetVisible()
	{
		_mGetVisible_mHRChara__QAE_NXZ mFunc = (_mGetVisible_mHRChara__QAE_NXZ)(GameModule + 0xac1a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetTension(class mHRChara* const this) [?mGetTension@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetTension_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetTension()
	{
		_mGetTension_mHRChara__QAEMXZ mFunc = (_mGetTension_mHRChara__QAEMXZ)(GameModule + 0xac270);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetMiniMapRender(class mHRChara* const this) [?mGetMiniMapRender@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mGetMiniMapRender_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetMiniMapRender()
	{
		_mGetMiniMapRender_mHRChara__QBE_NXZ mFunc = (_mGetMiniMapRender_mHRChara__QBE_NXZ)(GameModule + 0xacfb0);
		return mFunc(this);
	}
	// [Function] class ghmResGroup* __convention("thiscall") mHRChara::mGetResourceRslPtr(class mHRChara* const this) [?mGetResourceRslPtr@mHRChara@@QAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _mGetResourceRslPtr_mHRChara__QAEPAVghmResGroup__XZ)(class mHRChara* const thisPtr);
	class ghmResGroup* mGetResourceRslPtr()
	{
		_mGetResourceRslPtr_mHRChara__QAEPAVghmResGroup__XZ mFunc = (_mGetResourceRslPtr_mHRChara__QAEPAVghmResGroup__XZ)(GameModule + 0xad5f0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::getFootNumber(class mHRChara* const this) [?getFootNumber@mHRChara@@QBEHXZ]
	typedef int32_t(__thiscall* _getFootNumber_mHRChara__QBEHXZ)(class mHRChara* const thisPtr);
	int32_t getFootNumber()
	{
		_getFootNumber_mHRChara__QBEHXZ mFunc = (_getFootNumber_mHRChara__QBEHXZ)(GameModule + 0xada50);
		return mFunc(this);
	}
	// [Function] char* __convention("thiscall") mHRChara::mGetCallScriptProc(class mHRChara* const this) [?mGetCallScriptProc@mHRChara@@QAEPADXZ]
	typedef char*(__thiscall* _mGetCallScriptProc_mHRChara__QAEPADXZ)(class mHRChara* const thisPtr);
	std::string mGetCallScriptProc()
	{
		_mGetCallScriptProc_mHRChara__QAEPADXZ mFunc = (_mGetCallScriptProc_mHRChara__QAEPADXZ)(GameModule + 0xb03a0);
		char* OutResult = mFunc(this);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetMotionProcessDisEnable(class mHRChara* const this) [?mGetMotionProcessDisEnable@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mGetMotionProcessDisEnable_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetMotionProcessDisEnable()
	{
		_mGetMotionProcessDisEnable_mHRChara__QBE_NXZ mFunc = (_mGetMotionProcessDisEnable_mHRChara__QBE_NXZ)(GameModule + 0xb03b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsBloom(class mHRChara* const this) [?IsBloom@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsBloom_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsBloom()
	{
		_IsBloom_mHRChara__QAE_NXZ mFunc = (_IsBloom_mHRChara__QAE_NXZ)(GameModule + 0xb03c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetTermAll(class mHRChara* const this, uint8_t arg2) [?SetTermAll@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _SetTermAll_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void SetTermAll(uint8_t arg2)
	{
		_SetTermAll_mHRChara__QAEX_N_Z mFunc = (_SetTermAll_mHRChara__QAEX_N_Z)(GameModule + 0xb03d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::SetKnockBackSpd(class mHRChara* const this, float arg2) [?SetKnockBackSpd@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _SetKnockBackSpd_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void SetKnockBackSpd(float arg2)
	{
		_SetKnockBackSpd_mHRChara__QAEXM_Z mFunc = (_SetKnockBackSpd_mHRChara__QAEXM_Z)(GameModule + 0xb0430);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::GetKnockBackSpd(class mHRChara* const this) [?GetKnockBackSpd@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _GetKnockBackSpd_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float GetKnockBackSpd()
	{
		_GetKnockBackSpd_mHRChara__QAEMXZ mFunc = (_GetKnockBackSpd_mHRChara__QAEMXZ)(GameModule + 0xb0440);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetStageHitDisEnable(class mHRChara* const this) [?mGetStageHitDisEnable@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetStageHitDisEnable_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetStageHitDisEnable()
	{
		_mGetStageHitDisEnable_mHRChara__QAE_NXZ mFunc = (_mGetStageHitDisEnable_mHRChara__QAE_NXZ)(GameModule + 0xb0450);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetStartSplitFlameFlag(class mHRChara* const this) [?mGetStartSplitFlameFlag@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mGetStartSplitFlameFlag_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetStartSplitFlameFlag()
	{
		_mGetStartSplitFlameFlag_mHRChara__QBE_NXZ mFunc = (_mGetStartSplitFlameFlag_mHRChara__QBE_NXZ)(GameModule + 0xb04b0);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::getBoneEffectGmf(class mHRChara* const this) [?getBoneEffectGmf@mHRChara@@AAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _getBoneEffectGmf_mHRChara__AAEPAVTGmf__XZ)(class mHRChara* const thisPtr);
	class TGmf* getBoneEffectGmf()
	{
		_getBoneEffectGmf_mHRChara__AAEPAVTGmf__XZ mFunc = (_getBoneEffectGmf_mHRChara__AAEPAVTGmf__XZ)(GameModule + 0xb04c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetStartSplitFlameFlag(class mHRChara* const this, uint8_t arg2) [?mSetStartSplitFlameFlag@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetStartSplitFlameFlag_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetStartSplitFlameFlag(uint8_t arg2)
	{
		_mSetStartSplitFlameFlag_mHRChara__QAEX_N_Z mFunc = (_mSetStartSplitFlameFlag_mHRChara__QAEX_N_Z)(GameModule + 0xb04e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetCharaPause(class mHRChara* const this) [?mGetCharaPause@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mGetCharaPause_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetCharaPause()
	{
		_mGetCharaPause_mHRChara__QBE_NXZ mFunc = (_mGetCharaPause_mHRChara__QBE_NXZ)(GameModule + 0xb05a0);
		return mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetBeforePos(class mHRChara* const this) [?mGetBeforePos@mHRChara@@QAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetBeforePos_mHRChara__QAEAAUVec__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetBeforePos()
	{
		_mGetBeforePos_mHRChara__QAEAAUVec__XZ mFunc = (_mGetBeforePos_mHRChara__QAEAAUVec__XZ)(GameModule + 0xb9640);
		mFunc(this);
	}
	// [Function] int16_t __convention("thiscall") mHRChara::mGetZakoWepType(class mHRChara* const this) [?mGetZakoWepType@mHRChara@@QBEFXZ]
	typedef int16_t(__thiscall* _mGetZakoWepType_mHRChara__QBEFXZ)(class mHRChara* const thisPtr);
	int16_t mGetZakoWepType()
	{
		_mGetZakoWepType_mHRChara__QBEFXZ mFunc = (_mGetZakoWepType_mHRChara__QBEFXZ)(GameModule + 0xb9900);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetFootHitResultObj2(class mHRChara* const this, class ghmGcCollObjHitResultObj& arg2) [?mSetFootHitResultObj2@mHRChara@@QAEXABVghmGcCollObjHitResultObj@@@Z]
	typedef void(__thiscall* _mSetFootHitResultObj2_mHRChara__QAEXABVghmGcCollObjHitResultObj___Z)(class mHRChara* const thisPtr, class ghmGcCollObjHitResultObj& arg2);
	void mSetFootHitResultObj2(class ghmGcCollObjHitResultObj& arg2)
	{
		_mSetFootHitResultObj2_mHRChara__QAEXABVghmGcCollObjHitResultObj___Z mFunc = (_mSetFootHitResultObj2_mHRChara__QAEXABVghmGcCollObjHitResultObj___Z)(GameModule + 0xba010);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDmgUpperPow(class mHRChara* const this, float arg2) [?mSetDmgUpperPow@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetDmgUpperPow_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetDmgUpperPow(float arg2)
	{
		_mSetDmgUpperPow_mHRChara__QAEXM_Z mFunc = (_mSetDmgUpperPow_mHRChara__QAEXM_Z)(GameModule + 0xba060);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mAddHp(class mHRChara* const this, float arg2) [?mAddHp@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mAddHp_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mAddHp(float arg2)
	{
		_mAddHp_mHRChara__QAEXM_Z mFunc = (_mAddHp_mHRChara__QAEXM_Z)(GameModule + 0xba980);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetSubMotionSpd(class mHRChara* const this) [?mGetSubMotionSpd@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetSubMotionSpd_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetSubMotionSpd()
	{
		_mGetSubMotionSpd_mHRChara__QAEMXZ mFunc = (_mGetSubMotionSpd_mHRChara__QAEMXZ)(GameModule + 0xbd0b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetZakoWepType(class mHRChara* const this, int16_t arg2) [?mSetZakoWepType@mHRChara@@QAEXF@Z]
	typedef void(__thiscall* _mSetZakoWepType_mHRChara__QAEXF_Z)(class mHRChara* const thisPtr, int16_t arg2);
	void mSetZakoWepType(int16_t arg2)
	{
		_mSetZakoWepType_mHRChara__QAEXF_Z mFunc = (_mSetZakoWepType_mHRChara__QAEXF_Z)(GameModule + 0xbd120);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetHitSize(class mHRChara* const this, float arg2) [?mSetHitSize@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetHitSize_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetHitSize(float arg2)
	{
		_mSetHitSize_mHRChara__QAEXM_Z mFunc = (_mSetHitSize_mHRChara__QAEXM_Z)(GameModule + 0xbd4a0);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetReactionDist(class mHRChara* const this) [?mGetReactionDist@mHRChara@@QBEMXZ]
	typedef float(__thiscall* _mGetReactionDist_mHRChara__QBEMXZ)(class mHRChara* const thisPtr);
	float mGetReactionDist()
	{
		_mGetReactionDist_mHRChara__QBEMXZ mFunc = (_mGetReactionDist_mHRChara__QBEMXZ)(GameModule + 0xc0260);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMiniMapRender(class mHRChara* const this, uint8_t arg2) [?mSetMiniMapRender@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetMiniMapRender_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetMiniMapRender(uint8_t arg2)
	{
		_mSetMiniMapRender_mHRChara__QAEX_N_Z mFunc = (_mSetMiniMapRender_mHRChara__QAEX_N_Z)(GameModule + 0xc0270);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec __convention("thiscall") mHRChara::GetKnockBackDir(class mHRChara* const this) [?GetKnockBackDir@mHRChara@@QAE?AUVec@@XZ]
	typedef struct Vec(__thiscall* _GetKnockBackDir_mHRChara__QAEAUVec__XZ)(class mHRChara* const thisPtr);
	struct Vec GetKnockBackDir()
	{
		_GetKnockBackDir_mHRChara__QAEAUVec__XZ mFunc = (_GetKnockBackDir_mHRChara__QAEAUVec__XZ)(GameModule + 0xc7970);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetMotionNoNpc(class mHRChara* const this) [?mGetMotionNoNpc@mHRChara@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetMotionNoNpc_mHRChara__QAEHXZ)(class mHRChara* const thisPtr);
	int32_t mGetMotionNoNpc()
	{
		_mGetMotionNoNpc_mHRChara__QAEHXZ mFunc = (_mGetMotionNoNpc_mHRChara__QAEHXZ)(GameModule + 0xc97e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetNormalClip(class mHRChara* const this, uint8_t arg2) [?SetNormalClip@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _SetNormalClip_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void SetNormalClip(uint8_t arg2)
	{
		_SetNormalClip_mHRChara__QAEX_N_Z mFunc = (_SetNormalClip_mHRChara__QAEX_N_Z)(GameModule + 0xce050);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetOldPos(class mHRChara* const this) [?mGetOldPos@mHRChara@@QAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetOldPos_mHRChara__QAEAAUVec__XZ)(class mHRChara* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetOldPos()
	{
		_mGetOldPos_mHRChara__QAEAAUVec__XZ mFunc = (_mGetOldPos_mHRChara__QAEAAUVec__XZ)(GameModule + 0xd4ae0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetSuccessThrow(class mHRChara* const this) [?mGetSuccessThrow@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetSuccessThrow_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetSuccessThrow()
	{
		_mGetSuccessThrow_mHRChara__QAE_NXZ mFunc = (_mGetSuccessThrow_mHRChara__QAE_NXZ)(GameModule + 0xd8b90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDmgUpperPosY(class mHRChara* const this, float const arg2) [?mSetDmgUpperPosY@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetDmgUpperPosY_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float const arg2);
	void mSetDmgUpperPosY(float const arg2)
	{
		_mSetDmgUpperPosY_mHRChara__QAEXM_Z mFunc = (_mSetDmgUpperPosY_mHRChara__QAEXM_Z)(GameModule + 0xe34c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::SetDeleteReq(class mHRChara* const this) [?SetDeleteReq@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _SetDeleteReq_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void SetDeleteReq()
	{
		_SetDeleteReq_mHRChara__QAEXXZ mFunc = (_SetDeleteReq_mHRChara__QAEXXZ)(GameModule + 0x46dcf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::getShootPosiAndYaw(class mHRChara* const this, struct Vec* arg2, float* arg3, class TGmf& arg4, char const* arg5) [?getShootPosiAndYaw@mHRChara@@QBEXPAUVec@@PAMABVTGmf@@PBD@Z]
	typedef void(__thiscall* _getShootPosiAndYaw_mHRChara__QBEXPAUVec__PAMABVTGmf__PBD_Z)(class mHRChara* const thisPtr, struct Vec* arg2, float* arg3, class TGmf& arg4, char const* arg5);
	void getShootPosiAndYaw(struct Vec* arg2, float* arg3, class TGmf& arg4, std::string arg5)
	{
		char const* arg5_c_str = arg5.c_str();
		_getShootPosiAndYaw_mHRChara__QBEXPAUVec__PAMABVTGmf__PBD_Z mFunc = (_getShootPosiAndYaw_mHRChara__QBEXPAUVec__PAMABVTGmf__PBD_Z)(GameModule + 0x46dd10);
		return mFunc(this, arg2, arg3, arg4, arg5_c_str);
	}
	// [Function] void __convention("thiscall") mHRChara::setHomingPositionFromAI(class mHRChara* const this, struct Vec& arg2) [?setHomingPositionFromAI@mHRChara@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _setHomingPositionFromAI_mHRChara__QAEXABUVec___Z)(class mHRChara* const thisPtr, struct Vec& arg2);
	void setHomingPositionFromAI(struct Vec& arg2)
	{
		_setHomingPositionFromAI_mHRChara__QAEXABUVec___Z mFunc = (_setHomingPositionFromAI_mHRChara__QAEXABUVec___Z)(GameModule + 0x46de70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::setHomingActFlagFromAI(class mHRChara* const this, uint8_t const arg2) [?setHomingActFlagFromAI@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _setHomingActFlagFromAI_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t const arg2);
	void setHomingActFlagFromAI(uint8_t const arg2)
	{
		_setHomingActFlagFromAI_mHRChara__QAEX_N_Z mFunc = (_setHomingActFlagFromAI_mHRChara__QAEX_N_Z)(GameModule + 0x46dea0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isHoming(class mHRChara* const this) [?isHoming@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _isHoming_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t isHoming()
	{
		_isHoming_mHRChara__QBE_NXZ mFunc = (_isHoming_mHRChara__QBE_NXZ)(GameModule + 0x46ded0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::setInterestUseBoneNumFromAI(class mHRChara* const this, int32_t const arg2) [?setInterestUseBoneNumFromAI@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _setInterestUseBoneNumFromAI_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t const arg2);
	void setInterestUseBoneNumFromAI(int32_t const arg2)
	{
		_setInterestUseBoneNumFromAI_mHRChara__QAEXH_Z mFunc = (_setInterestUseBoneNumFromAI_mHRChara__QAEXH_Z)(GameModule + 0x46def0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isInteresting(class mHRChara* const this) [?isInteresting@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _isInteresting_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t isInteresting()
	{
		_isInteresting_mHRChara__QBE_NXZ mFunc = (_isInteresting_mHRChara__QBE_NXZ)(GameModule + 0x46df20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::addDamageToYuremono(class mHRChara* const this, float const arg2, struct Vec& arg3) [?addDamageToYuremono@mHRChara@@QAEXMABUVec@@@Z]
	typedef void(__thiscall* _addDamageToYuremono_mHRChara__QAEXMABUVec___Z)(class mHRChara* const thisPtr, float const arg2, struct Vec& arg3);
	void addDamageToYuremono(float const arg2, struct Vec& arg3)
	{
		_addDamageToYuremono_mHRChara__QAEXMABUVec___Z mFunc = (_addDamageToYuremono_mHRChara__QAEXMABUVec___Z)(GameModule + 0x46df40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mot::IBoneEffectPJ* __convention("thiscall") mHRChara::getBoneEffect(class mHRChara* const this) [?getBoneEffect@mHRChara@@IAEPAVIBoneEffectPJ@mot@@XZ]
	typedef class mot::IBoneEffectPJ*(__thiscall* _getBoneEffect_mHRChara__IAEPAVIBoneEffectPJ_mot__XZ)(class mHRChara* const thisPtr);
	class mot::IBoneEffectPJ* getBoneEffect()
	{
		_getBoneEffect_mHRChara__IAEPAVIBoneEffectPJ_mot__XZ mFunc = (_getBoneEffect_mHRChara__IAEPAVIBoneEffectPJ_mot__XZ)(GameModule + 0x46df80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mSetHajikiCheck(class mHRChara* const this, float arg2) [?mSetHajikiCheck@mHRChara@@QAE_NM@Z]
	typedef uint8_t(__thiscall* _mSetHajikiCheck_mHRChara__QAE_NM_Z)(class mHRChara* const thisPtr, float arg2);
	uint8_t mSetHajikiCheck(float arg2)
	{
		_mSetHajikiCheck_mHRChara__QAE_NM_Z mFunc = (_mSetHajikiCheck_mHRChara__QAE_NM_Z)(GameModule + 0x46dfa0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckDamageAccept(class mHRChara* const this) [?mCheckDamageAccept@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckDamageAccept_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckDamageAccept()
	{
		_mCheckDamageAccept_mHRChara__QAE_NXZ mFunc = (_mCheckDamageAccept_mHRChara__QAE_NXZ)(GameModule + 0x46dfc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestZakoDown(class mHRChara* const this) [?mTestZakoDown@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestZakoDown_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTestZakoDown()
	{
		_mTestZakoDown_mHRChara__QAE_NXZ mFunc = (_mTestZakoDown_mHRChara__QAE_NXZ)(GameModule + 0x46dfd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestPiyoRequest(class mHRChara* const this) [?mTestPiyoRequest@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestPiyoRequest_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTestPiyoRequest()
	{
		_mTestPiyoRequest_mHRChara__QAE_NXZ mFunc = (_mTestPiyoRequest_mHRChara__QAE_NXZ)(GameModule + 0x46e000);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetPiyoriHeight(class mHRChara* const this) [?mGetPiyoriHeight@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _mGetPiyoriHeight_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float mGetPiyoriHeight()
	{
		_mGetPiyoriHeight_mHRChara__QAEMXZ mFunc = (_mGetPiyoriHeight_mHRChara__QAEMXZ)(GameModule + 0x46e010);
		return mFunc(this);
	}
	// [Function] class mHRChara* mHRChara::mGetCharaPtr(int32_t arg1) [?mGetCharaPtr@mHRChara@@SAPAV1@H@Z]
	typedef class mHRChara*(__fastcall* _mGetCharaPtr_mHRChara__SAPAV1_H_Z)(int32_t arg1);
	static class mHRChara* mGetCharaPtr(int32_t arg1)
	{
		_mGetCharaPtr_mHRChara__SAPAV1_H_Z mFunc = (_mGetCharaPtr_mHRChara__SAPAV1_H_Z)(GameModule + 0x46e100);
		return mFunc(arg1);
	}
	// [Function] void mHRChara::mRenderGmf(void* arg1) [?mRenderGmf@mHRChara@@SAXPAX@Z]
	typedef void(__fastcall* _mRenderGmf_mHRChara__SAXPAX_Z)(void* arg1);
	static void mRenderGmf(void* arg1)
	{
		_mRenderGmf_mHRChara__SAXPAX_Z mFunc = (_mRenderGmf_mHRChara__SAXPAX_Z)(GameModule + 0x46e120);
		return mFunc(arg1);
	}
	// [Function] int32_t mHRChara::debugDispCharaInfo() [?debugDispCharaInfo@mHRChara@@SAXXZ]
	typedef int32_t(__fastcall* _debugDispCharaInfo_mHRChara__SAXXZ)();
	static int32_t debugDispCharaInfo()
	{
		_debugDispCharaInfo_mHRChara__SAXXZ mFunc = (_debugDispCharaInfo_mHRChara__SAXXZ)(GameModule + 0x46e140);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mTermAllZakoMotion() [?mTermAllZakoMotion@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mTermAllZakoMotion_mHRChara__SA_NXZ)();
	static uint8_t mTermAllZakoMotion()
	{
		_mTermAllZakoMotion_mHRChara__SA_NXZ mFunc = (_mTermAllZakoMotion_mHRChara__SA_NXZ)(GameModule + 0x46e150);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mInitAllNpc() [?mInitAllNpc@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mInitAllNpc_mHRChara__SA_NXZ)();
	static uint8_t mInitAllNpc()
	{
		_mInitAllNpc_mHRChara__SA_NXZ mFunc = (_mInitAllNpc_mHRChara__SA_NXZ)(GameModule + 0x46e3a0);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::mCreateBloodSplash(class mHRChara* const this, class TGmfNode* inpNode, float posY, struct tagHRTASKCHECK* inpChkDat) [?mCreateBloodSplash@mHRChara@@QAEXPAVTGmfNode@@MPAUtagHRTASKCHECK@@@Z]
	typedef void(__thiscall* _mCreateBloodSplash_mHRChara__QAEXPAVTGmfNode__MPAUtagHRTASKCHECK___Z)(class mHRChara* const thisPtr, class TGmfNode* inpNode, float posY, struct tagHRTASKCHECK* inpChkDat);
	void mCreateBloodSplash(class TGmfNode* inpNode, float posY, struct tagHRTASKCHECK* inpChkDat)
	{
		_mCreateBloodSplash_mHRChara__QAEXPAVTGmfNode__MPAUtagHRTASKCHECK___Z mFunc = (_mCreateBloodSplash_mHRChara__QAEXPAVTGmfNode__MPAUtagHRTASKCHECK___Z)(GameModule + 0x46e3e0);
		return mFunc(this, inpNode, posY, inpChkDat);
	}
	// [Function] void __convention("thiscall") mHRChara::mBloodSplashProc(class mHRChara* const this) [?mBloodSplashProc@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mBloodSplashProc_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mBloodSplashProc()
	{
		_mBloodSplashProc_mHRChara__QAEXXZ mFunc = (_mBloodSplashProc_mHRChara__QAEXXZ)(GameModule + 0x46e440);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::AddBoneElectPtrToList(class mHRChara* const this, class EffectBoneElect* arg2) [?AddBoneElectPtrToList@mHRChara@@QAEXPAVEffectBoneElect@@@Z]
	typedef void(__thiscall* _AddBoneElectPtrToList_mHRChara__QAEXPAVEffectBoneElect___Z)(class mHRChara* const thisPtr, class EffectBoneElect* arg2);
	void AddBoneElectPtrToList(class EffectBoneElect* arg2)
	{
		_AddBoneElectPtrToList_mHRChara__QAEXPAVEffectBoneElect___Z mFunc = (_AddBoneElectPtrToList_mHRChara__QAEXPAVEffectBoneElect___Z)(GameModule + 0x46e4e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::ReleaseBoneElect(class mHRChara* const this) [?ReleaseBoneElect@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _ReleaseBoneElect_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t ReleaseBoneElect()
	{
		_ReleaseBoneElect_mHRChara__QAE_NXZ mFunc = (_ReleaseBoneElect_mHRChara__QAE_NXZ)(GameModule + 0x46e520);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsEmtpyBoneElectList(class mHRChara* const this) [?IsEmtpyBoneElectList@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsEmtpyBoneElectList_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsEmtpyBoneElectList()
	{
		_IsEmtpyBoneElectList_mHRChara__QAE_NXZ mFunc = (_IsEmtpyBoneElectList_mHRChara__QAE_NXZ)(GameModule + 0x46e600);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::DeleteBoneElectFromList(class mHRChara* const this, class EffectBoneElect* arg2) [?DeleteBoneElectFromList@mHRChara@@QAEXPAVEffectBoneElect@@@Z]
	typedef void(__thiscall* _DeleteBoneElectFromList_mHRChara__QAEXPAVEffectBoneElect___Z)(class mHRChara* const thisPtr, class EffectBoneElect* arg2);
	void DeleteBoneElectFromList(class EffectBoneElect* arg2)
	{
		_DeleteBoneElectFromList_mHRChara__QAEXPAVEffectBoneElect___Z mFunc = (_DeleteBoneElectFromList_mHRChara__QAEXPAVEffectBoneElect___Z)(GameModule + 0x46e620);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::AddCutmarkPtrToList(class mHRChara* const this, class EffectCutMark* arg2) [?AddCutmarkPtrToList@mHRChara@@QAEXPAVEffectCutMark@@@Z]
	typedef void(__thiscall* _AddCutmarkPtrToList_mHRChara__QAEXPAVEffectCutMark___Z)(class mHRChara* const thisPtr, class EffectCutMark* arg2);
	void AddCutmarkPtrToList(class EffectCutMark* arg2)
	{
		_AddCutmarkPtrToList_mHRChara__QAEXPAVEffectCutMark___Z mFunc = (_AddCutmarkPtrToList_mHRChara__QAEXPAVEffectCutMark___Z)(GameModule + 0x46e660);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsEmtpyCutmarkList(class mHRChara* const this) [?IsEmtpyCutmarkList@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsEmtpyCutmarkList_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsEmtpyCutmarkList()
	{
		_IsEmtpyCutmarkList_mHRChara__QAE_NXZ mFunc = (_IsEmtpyCutmarkList_mHRChara__QAE_NXZ)(GameModule + 0x46e6a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::DeleteCutmarkFromList(class mHRChara* const this, class EffectCutMark* arg2) [?DeleteCutmarkFromList@mHRChara@@QAEXPAVEffectCutMark@@@Z]
	typedef void(__thiscall* _DeleteCutmarkFromList_mHRChara__QAEXPAVEffectCutMark___Z)(class mHRChara* const thisPtr, class EffectCutMark* arg2);
	void DeleteCutmarkFromList(class EffectCutMark* arg2)
	{
		_DeleteCutmarkFromList_mHRChara__QAEXPAVEffectCutMark___Z mFunc = (_DeleteCutmarkFromList_mHRChara__QAEXPAVEffectCutMark___Z)(GameModule + 0x46e6c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::SetPowerFlash(class mHRChara* const this, int32_t arg2, struct GXColor arg3) [?SetPowerFlash@mHRChara@@QAE_NHUGXColor@@@Z]
	typedef uint8_t(__thiscall* _SetPowerFlash_mHRChara__QAE_NHUGXColor___Z)(class mHRChara* const thisPtr, int32_t arg2, struct GXColor arg3);
	uint8_t SetPowerFlash(int32_t arg2, struct GXColor arg3)
	{
		_SetPowerFlash_mHRChara__QAE_NHUGXColor___Z mFunc = (_SetPowerFlash_mHRChara__QAE_NHUGXColor___Z)(GameModule + 0x46e700);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::SetNoGuardEffect(class mHRChara* const this) [?SetNoGuardEffect@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _SetNoGuardEffect_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t SetNoGuardEffect()
	{
		_SetNoGuardEffect_mHRChara__QAE_NXZ mFunc = (_SetNoGuardEffect_mHRChara__QAE_NXZ)(GameModule + 0x46e820);
		return mFunc(this);
	}
	// [Function] uint8_t mHRChara::mCheckAtkAllNpc() [?mCheckAtkAllNpc@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mCheckAtkAllNpc_mHRChara__SA_NXZ)();
	static uint8_t mCheckAtkAllNpc()
	{
		_mCheckAtkAllNpc_mHRChara__SA_NXZ mFunc = (_mCheckAtkAllNpc_mHRChara__SA_NXZ)(GameModule + 0x46e840);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mCheckCanAtk() [?mCheckCanAtk@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mCheckCanAtk_mHRChara__SA_NXZ)();
	static uint8_t mCheckCanAtk()
	{
		_mCheckCanAtk_mHRChara__SA_NXZ mFunc = (_mCheckCanAtk_mHRChara__SA_NXZ)(GameModule + 0x46e870);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::mCallBeforeRenderProc(class mHRChara* const this) [?mCallBeforeRenderProc@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mCallBeforeRenderProc_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mCallBeforeRenderProc()
	{
		_mCallBeforeRenderProc_mHRChara__QAEXXZ mFunc = (_mCallBeforeRenderProc_mHRChara__QAEXXZ)(GameModule + 0x46e8a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanHit(class mHRChara* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mCheckCanHit@mHRChara@@UAE_NH_N0@Z]
	typedef uint8_t(__thiscall* _mCheckCanHit_mHRChara__UAE_NH_N0_Z)(class mHRChara* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
	uint8_t mCheckCanHit(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		_mCheckCanHit_mHRChara__UAE_NH_N0_Z mFunc = (_mCheckCanHit_mHRChara__UAE_NH_N0_Z)(GameModule + 0x46e8b0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRChara::CreateFootSmokeEffect(class mHRChara* const this) [?CreateFootSmokeEffect@mHRChara@@QAEXXZ]
	/// <summary>
	/// Creates a dust effect at character feet.
	/// </summary>
	typedef void(__thiscall* _CreateFootSmokeEffect_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void CreateFootSmokeEffect()
	{
		_CreateFootSmokeEffect_mHRChara__QAEXXZ mFunc = (_CreateFootSmokeEffect_mHRChara__QAEXXZ)(GameModule + 0x46e8c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::KnockBackProc(class mHRChara* const this) [?KnockBackProc@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _KnockBackProc_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void KnockBackProc()
	{
		_KnockBackProc_mHRChara__QAEXXZ mFunc = (_KnockBackProc_mHRChara__QAEXXZ)(GameModule + 0x46ea20);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::GetKnockBackRatio(class mHRChara* const this) [?GetKnockBackRatio@mHRChara@@QAEMXZ]
	typedef float(__thiscall* _GetKnockBackRatio_mHRChara__QAEMXZ)(class mHRChara* const thisPtr);
	float GetKnockBackRatio()
	{
		_GetKnockBackRatio_mHRChara__QAEMXZ mFunc = (_GetKnockBackRatio_mHRChara__QAEMXZ)(GameModule + 0x46eb30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mSetDamage(class mHRChara* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@mHRChara@@UAE_NMHHHMHMMPAV1@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_mHRChara__UAE_NMHHHMHMMPAV1__Z)(class mHRChara* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_mHRChara__UAE_NMHHHMHMMPAV1__Z mFunc = (_mSetDamage_mHRChara__UAE_NMHHHMHMMPAV1__Z)(GameModule + 0x46eba0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] void __convention("thiscall") mHRChara::mInitDamageMotInfo(class mHRChara* const this) [?mInitDamageMotInfo@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mInitDamageMotInfo_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mInitDamageMotInfo()
	{
		_mInitDamageMotInfo_mHRChara__QAEXXZ mFunc = (_mInitDamageMotInfo_mHRChara__QAEXXZ)(GameModule + 0x46ebb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mChangeDefAi(class mHRChara* const this, uint8_t arg2, uint8_t arg3) [?mChangeDefAi@mHRChara@@QAE_N_N0@Z]
	typedef uint8_t(__thiscall* _mChangeDefAi_mHRChara__QAE_N_N0_Z)(class mHRChara* const thisPtr, uint8_t arg2, uint8_t arg3);
	uint8_t mChangeDefAi(uint8_t arg2, uint8_t arg3)
	{
		_mChangeDefAi_mHRChara__QAE_N_N0_Z mFunc = (_mChangeDefAi_mHRChara__QAE_N_N0_Z)(GameModule + 0x46ebe0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDefAI(class mHRChara* const this, uint8_t arg2) [?mSetDefAI@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDefAI_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetDefAI(uint8_t arg2)
	{
		_mSetDefAI_mHRChara__QAEX_N_Z mFunc = (_mSetDefAI_mHRChara__QAEX_N_Z)(GameModule + 0x46ec60);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCallFrameProc(class mHRChara* const this) [?mCheckCallFrameProc@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCallFrameProc_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckCallFrameProc()
	{
		_mCheckCallFrameProc_mHRChara__QAE_NXZ mFunc = (_mCheckCallFrameProc_mHRChara__QAE_NXZ)(GameModule + 0x46ecb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsNowUnderControl(class mHRChara* const this) [?IsNowUnderControl@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsNowUnderControl_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsNowUnderControl()
	{
		_IsNowUnderControl_mHRChara__QAE_NXZ mFunc = (_IsNowUnderControl_mHRChara__QAE_NXZ)(GameModule + 0x46ed60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::RegistUnderControlAtkFuncPtr(class mHRChara* const this) [?RegistUnderControlAtkFuncPtr@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _RegistUnderControlAtkFuncPtr_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void RegistUnderControlAtkFuncPtr()
	{
		_RegistUnderControlAtkFuncPtr_mHRChara__QAEXXZ mFunc = (_RegistUnderControlAtkFuncPtr_mHRChara__QAEXXZ)(GameModule + 0x46ed70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::RegistUnderControlMotID(class mHRChara* const this, struct CharControlMotID& arg2) [?RegistUnderControlMotID@mHRChara@@QAEXABUCharControlMotID@@@Z]
	typedef void(__thiscall* _RegistUnderControlMotID_mHRChara__QAEXABUCharControlMotID___Z)(class mHRChara* const thisPtr, struct CharControlMotID& arg2);
	void RegistUnderControlMotID(struct CharControlMotID& arg2)
	{
		_RegistUnderControlMotID_mHRChara__QAEXABUCharControlMotID___Z mFunc = (_RegistUnderControlMotID_mHRChara__QAEXABUCharControlMotID___Z)(GameModule + 0x46ed80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::SetUnderControlFlag(class mHRChara* const this, uint8_t arg2) [?SetUnderControlFlag@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _SetUnderControlFlag_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void SetUnderControlFlag(uint8_t arg2)
	{
		_SetUnderControlFlag_mHRChara__QAEX_N_Z mFunc = (_SetUnderControlFlag_mHRChara__QAEX_N_Z)(GameModule + 0x46edb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::DrawDebugCollision(class mHRChara* const this) [?DrawDebugCollision@mHRChara@@IAEXXZ]
	typedef void(__thiscall* _DrawDebugCollision_mHRChara__IAEXXZ)(class mHRChara* const thisPtr);
	void DrawDebugCollision()
	{
		_DrawDebugCollision_mHRChara__IAEXXZ mFunc = (_DrawDebugCollision_mHRChara__IAEXXZ)(GameModule + 0x46edf0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mRenderProc(class mHRChara* const this) [?mRenderProc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mRenderProc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mRenderProc()
	{
		_mRenderProc_mHRChara__UAE_NXZ mFunc = (_mRenderProc_mHRChara__UAE_NXZ)(GameModule + 0x46ee00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::postSetupMatrix(class mHRChara* const this) [?postSetupMatrix@mHRChara@@AAEXXZ]
	typedef void(__thiscall* _postSetupMatrix_mHRChara__AAEXXZ)(class mHRChara* const thisPtr);
	void postSetupMatrix()
	{
		_postSetupMatrix_mHRChara__AAEXXZ mFunc = (_postSetupMatrix_mHRChara__AAEXXZ)(GameModule + 0x46ef90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::preSetupMatrix(class mHRChara* const this) [?preSetupMatrix@mHRChara@@AAEXXZ]
	typedef void(__thiscall* _preSetupMatrix_mHRChara__AAEXXZ)(class mHRChara* const thisPtr);
	void preSetupMatrix()
	{
		_preSetupMatrix_mHRChara__AAEXXZ mFunc = (_preSetupMatrix_mHRChara__AAEXXZ)(GameModule + 0x46f000);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mFootSmokeEffect(class mHRChara* const this) [?mFootSmokeEffect@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mFootSmokeEffect_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mFootSmokeEffect()
	{
		_mFootSmokeEffect_mHRChara__QAEXXZ mFunc = (_mFootSmokeEffect_mHRChara__QAEXXZ)(GameModule + 0x46f1f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mPosAnimationProc(class mHRChara* const this) [?mPosAnimationProc@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mPosAnimationProc_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mPosAnimationProc()
	{
		_mPosAnimationProc_mHRChara__QAEXXZ mFunc = (_mPosAnimationProc_mHRChara__QAEXXZ)(GameModule + 0x46f590);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPostFrameProc(class mHRChara* const this) [?mPostFrameProc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameProc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mPostFrameProc()
	{
		_mPostFrameProc_mHRChara__UAE_NXZ mFunc = (_mPostFrameProc_mHRChara__UAE_NXZ)(GameModule + 0x46f6b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mFrameProc(class mHRChara* const this) [?mFrameProc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mFrameProc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mFrameProc()
	{
		_mFrameProc_mHRChara__UAE_NXZ mFunc = (_mFrameProc_mHRChara__UAE_NXZ)(GameModule + 0x46f860);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mInit(class mHRChara* const this) [?mInit@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mInit_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mInit()
	{
		_mInit_mHRChara__UAE_NXZ mFunc = (_mInit_mHRChara__UAE_NXZ)(GameModule + 0x46f870);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetRotA(class mHRChara* const this, struct Vec& arg2, uint32_t const arg3) [?mSetRotA@mHRChara@@QAEXABUVec@@I@Z]
	typedef void(__thiscall* _mSetRotA_mHRChara__QAEXABUVec__I_Z)(class mHRChara* const thisPtr, struct Vec& arg2, uint32_t const arg3);
	void mSetRotA(struct Vec& arg2, uint32_t const arg3)
	{
		_mSetRotA_mHRChara__QAEXABUVec__I_Z mFunc = (_mSetRotA_mHRChara__QAEXABUVec__I_Z)(GameModule + 0x46fd30);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetWepEffectVisibleInstant(class mHRChara* const this, uint8_t arg2) [?mSetWepEffectVisibleInstant@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _mSetWepEffectVisibleInstant_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetWepEffectVisibleInstant(uint8_t arg2)
	{
		_mSetWepEffectVisibleInstant_mHRChara__QAEX_N_Z mFunc = (_mSetWepEffectVisibleInstant_mHRChara__QAEX_N_Z)(GameModule + 0x46fda0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSubFrameStop(class mHRChara* const this) [?mSubFrameStop@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mSubFrameStop_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mSubFrameStop()
	{
		_mSubFrameStop_mHRChara__QAEXXZ mFunc = (_mSubFrameStop_mHRChara__QAEXXZ)(GameModule + 0x46fe70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPlayMotionMov(class mHRChara* const this, int32_t arg2, float arg3, float arg4, float arg5, uint8_t arg6) [?mPlayMotionMov@mHRChara@@QAE_NHMMM_N@Z]
	typedef uint8_t(__thiscall* _mPlayMotionMov_mHRChara__QAE_NHMMM_N_Z)(class mHRChara* const thisPtr, int32_t arg2, float arg3, float arg4, float arg5, uint8_t arg6);
	uint8_t mPlayMotionMov(int32_t arg2, float arg3, float arg4, float arg5, uint8_t arg6)
	{
		_mPlayMotionMov_mHRChara__QAE_NHMMM_N_Z mFunc = (_mPlayMotionMov_mHRChara__QAE_NHMMM_N_Z)(GameModule + 0x46ff00);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestMotion(class mHRChara* const this, int32_t arg2) [?mTestMotion@mHRChara@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mTestMotion_mHRChara__QAE_NH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	uint8_t mTestMotion(int32_t arg2)
	{
		_mTestMotion_mHRChara__QAE_NH_Z mFunc = (_mTestMotion_mHRChara__QAE_NH_Z)(GameModule + 0x470000);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDifficultyMotionSpeed(class mHRChara* const this, float arg2) [?mSetDifficultyMotionSpeed@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetDifficultyMotionSpeed_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetDifficultyMotionSpeed(float arg2)
	{
		_mSetDifficultyMotionSpeed_mHRChara__QAEXM_Z mFunc = (_mSetDifficultyMotionSpeed_mHRChara__QAEXM_Z)(GameModule + 0x470030);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* mHRChara::getCharaByGM2FileName(char const* arg1) [?getCharaByGM2FileName@mHRChara@@SAPAV1@PBD@Z]
	typedef class mHRChara*(__fastcall* _getCharaByGM2FileName_mHRChara__SAPAV1_PBD_Z)(char const* arg1);
	static class mHRChara* getCharaByGM2FileName(std::string arg1)
	{
		char const* arg1_c_str = arg1.c_str();
		_getCharaByGM2FileName_mHRChara__SAPAV1_PBD_Z mFunc = (_getCharaByGM2FileName_mHRChara__SAPAV1_PBD_Z)(GameModule + 0x470040);
		return mFunc(arg1_c_str);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDeath(class mHRChara* const this) [?mSetDeath@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mSetDeath_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mSetDeath()
	{
		_mSetDeath_mHRChara__QAEXXZ mFunc = (_mSetDeath_mHRChara__QAEXXZ)(GameModule + 0x4700a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mDamageCallBackForScript(class mHRChara* const this, int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4, int32_t arg5) [?mDamageCallBackForScript@mHRChara@@QAEXH_NW4eDmgCallBackDmgType@@H@Z]
	typedef void(__thiscall* _mDamageCallBackForScript_mHRChara__QAEXH_NW4eDmgCallBackDmgType__H_Z)(class mHRChara* const thisPtr, int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4, int32_t arg5);
	void mDamageCallBackForScript(int32_t arg2, uint8_t arg3, /* enum eDmgCallBackDmgType */ uint32_t arg4, int32_t arg5)
	{
		_mDamageCallBackForScript_mHRChara__QAEXH_NW4eDmgCallBackDmgType__H_Z mFunc = (_mDamageCallBackForScript_mHRChara__QAEXH_NW4eDmgCallBackDmgType__H_Z)(GameModule + 0x4700c0);
		return mFunc(this, arg2, arg3, (enum eDmgCallBackDmgType)arg4, arg5);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetMotionPlay(class mHRChara* const this) [?mGetMotionPlay@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetMotionPlay_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mGetMotionPlay()
	{
		_mGetMotionPlay_mHRChara__QAE_NXZ mFunc = (_mGetMotionPlay_mHRChara__QAE_NXZ)(GameModule + 0x470140);
		return mFunc(this);
	}
	// [Function] class mHRChara* mHRChara::mGetAliveResourceCharaPtr(enum enCharaType arg1, uint32_t arg2) [?mGetAliveResourceCharaPtr@mHRChara@@SAPAV1@W4enCharaType@@I@Z]
	typedef class mHRChara*(__fastcall* _mGetAliveResourceCharaPtr_mHRChara__SAPAV1_W4enCharaType__I_Z)(enum enCharaType arg1, uint32_t arg2);
	static class mHRChara* mGetAliveResourceCharaPtr(/* enum enCharaType */ uint32_t arg1, uint32_t arg2)
	{
		_mGetAliveResourceCharaPtr_mHRChara__SAPAV1_W4enCharaType__I_Z mFunc = (_mGetAliveResourceCharaPtr_mHRChara__SAPAV1_W4enCharaType__I_Z)(GameModule + 0x470150);
		return mFunc((enum enCharaType)arg1, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::ReleaseCutmark(class mHRChara* const this) [?ReleaseCutmark@mHRChara@@QAE_NXZ]
	typedef uint8_t(__thiscall* _ReleaseCutmark_mHRChara__QAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t ReleaseCutmark()
	{
		_ReleaseCutmark_mHRChara__QAE_NXZ mFunc = (_ReleaseCutmark_mHRChara__QAE_NXZ)(GameModule + 0x470180);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestPiyori(class mHRChara* const this) [?mTestPiyori@mHRChara@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mTestPiyori_mHRChara__QBE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTestPiyori()
	{
		_mTestPiyori_mHRChara__QBE_NXZ mFunc = (_mTestPiyori_mHRChara__QBE_NXZ)(GameModule + 0x470260);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") mHRChara::mGetMotionTotalTick(class mHRChara* const this, int32_t arg2) [?mGetMotionTotalTick@mHRChara@@QAEIH@Z]
	typedef uint32_t(__thiscall* _mGetMotionTotalTick_mHRChara__QAEIH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	uint32_t mGetMotionTotalTick(int32_t arg2)
	{
		_mGetMotionTotalTick_mHRChara__QAEIH_Z mFunc = (_mGetMotionTotalTick_mHRChara__QAEIH_Z)(GameModule + 0x470270);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::setInterestPositionFromAI(class mHRChara* const this, struct Vec& arg2) [?setInterestPositionFromAI@mHRChara@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _setInterestPositionFromAI_mHRChara__QAEXABUVec___Z)(class mHRChara* const thisPtr, struct Vec& arg2);
	void setInterestPositionFromAI(struct Vec& arg2)
	{
		_setInterestPositionFromAI_mHRChara__QAEXABUVec___Z mFunc = (_setInterestPositionFromAI_mHRChara__QAEXABUVec___Z)(GameModule + 0x4702f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::setInterestActFlagFromAI(class mHRChara* const this, uint8_t const arg2) [?setInterestActFlagFromAI@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _setInterestActFlagFromAI_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t const arg2);
	void setInterestActFlagFromAI(uint8_t const arg2)
	{
		_setInterestActFlagFromAI_mHRChara__QAEX_N_Z mFunc = (_setInterestActFlagFromAI_mHRChara__QAEX_N_Z)(GameModule + 0x470320);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetWepTopPos(class mHRChara* const this, struct Vec* arg2, enum enWepLeftRight arg3) [?mGetWepTopPos@mHRChara@@QAE_NPAUVec@@W4enWepLeftRight@@@Z]
	typedef uint8_t(__thiscall* _mGetWepTopPos_mHRChara__QAE_NPAUVec__W4enWepLeftRight___Z)(class mHRChara* const thisPtr, struct Vec* arg2, enum enWepLeftRight arg3);
	uint8_t mGetWepTopPos(struct Vec* arg2, /* enum enWepLeftRight */ uint32_t arg3)
	{
		_mGetWepTopPos_mHRChara__QAE_NPAUVec__W4enWepLeftRight___Z mFunc = (_mGetWepTopPos_mHRChara__QAE_NPAUVec__W4enWepLeftRight___Z)(GameModule + 0x470350);
		return mFunc(this, arg2, (enum enWepLeftRight)arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mInitDamageStatus(class mHRChara* const this) [?mInitDamageStatus@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mInitDamageStatus_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mInitDamageStatus()
	{
		_mInitDamageStatus_mHRChara__QAEXXZ mFunc = (_mInitDamageStatus_mHRChara__QAEXXZ)(GameModule + 0x470390);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPostFrameCommonProc1(class mHRChara* const this) [?mPostFrameCommonProc1@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameCommonProc1_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mPostFrameCommonProc1()
	{
		_mPostFrameCommonProc1_mHRChara__UAE_NXZ mFunc = (_mPostFrameCommonProc1_mHRChara__UAE_NXZ)(GameModule + 0x470450);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPostFrameCommonProc2(class mHRChara* const this) [?mPostFrameCommonProc2@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameCommonProc2_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mPostFrameCommonProc2()
	{
		_mPostFrameCommonProc2_mHRChara__UAE_NXZ mFunc = (_mPostFrameCommonProc2_mHRChara__UAE_NXZ)(GameModule + 0x470e10);
		return mFunc(this);
	}
	// [Function] class mot::CBoneEffectDamageData* __convention("thiscall") mHRChara::getBoneEffectDamageData(class mHRChara* const this) [?getBoneEffectDamageData@mHRChara@@IAEPAVCBoneEffectDamageData@mot@@XZ]
	typedef class mot::CBoneEffectDamageData*(__thiscall* _getBoneEffectDamageData_mHRChara__IAEPAVCBoneEffectDamageData_mot__XZ)(class mHRChara* const thisPtr);
	class mot::CBoneEffectDamageData* getBoneEffectDamageData()
	{
		_getBoneEffectDamageData_mHRChara__IAEPAVCBoneEffectDamageData_mot__XZ mFunc = (_getBoneEffectDamageData_mHRChara__IAEPAVCBoneEffectDamageData_mot__XZ)(GameModule + 0x471850);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetKnockBack(class mHRChara* const this, float arg2, struct Vec& arg3, float arg4) [?SetKnockBack@mHRChara@@QAEXMABUVec@@M@Z]
	typedef void(__thiscall* _SetKnockBack_mHRChara__QAEXMABUVec__M_Z)(class mHRChara* const thisPtr, float arg2, struct Vec& arg3, float arg4);
	void SetKnockBack(float arg2, struct Vec& arg3, float arg4)
	{
		_SetKnockBack_mHRChara__QAEXMABUVec__M_Z mFunc = (_SetKnockBack_mHRChara__QAEXMABUVec__M_Z)(GameModule + 0x471870);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::CheckWallCrashAndDamageProc(class mHRChara* const this, int32_t const arg2, int32_t const arg3) [?CheckWallCrashAndDamageProc@mHRChara@@QAE_NHH@Z]
	typedef uint8_t(__thiscall* _CheckWallCrashAndDamageProc_mHRChara__QAE_NHH_Z)(class mHRChara* const thisPtr, int32_t const arg2, int32_t const arg3);
	uint8_t CheckWallCrashAndDamageProc(int32_t const arg2, int32_t const arg3)
	{
		_CheckWallCrashAndDamageProc_mHRChara__QAE_NHH_Z mFunc = (_CheckWallCrashAndDamageProc_mHRChara__QAE_NHH_Z)(GameModule + 0x471ae0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mSetHpBarVisible(class mHRChara* const this, uint8_t arg2) [?mSetHpBarVisible@mHRChara@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _mSetHpBarVisible_mHRChara__QAE_N_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	uint8_t mSetHpBarVisible(uint8_t arg2)
	{
		_mSetHpBarVisible_mHRChara__QAE_N_N_Z mFunc = (_mSetHpBarVisible_mHRChara__QAE_N_N_Z)(GameModule + 0x471db0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetPosA(class mHRChara* const this, struct Vec& arg2, uint32_t const arg3, int32_t const arg4) [?mSetPosA@mHRChara@@QAEXABUVec@@IH@Z]
	typedef void(__thiscall* _mSetPosA_mHRChara__QAEXABUVec__IH_Z)(class mHRChara* const thisPtr, struct Vec& arg2, uint32_t const arg3, int32_t const arg4);
	void mSetPosA(struct Vec& arg2, uint32_t const arg3, int32_t const arg4)
	{
		_mSetPosA_mHRChara__QAEXABUVec__IH_Z mFunc = (_mSetPosA_mHRChara__QAEXABUVec__IH_Z)(GameModule + 0x471e10);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mSetSimpleHpBarVisible(class mHRChara* const this, uint8_t arg2) [?mSetSimpleHpBarVisible@mHRChara@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _mSetSimpleHpBarVisible_mHRChara__QAE_N_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	uint8_t mSetSimpleHpBarVisible(uint8_t arg2)
	{
		_mSetSimpleHpBarVisible_mHRChara__QAE_N_N_Z mFunc = (_mSetSimpleHpBarVisible_mHRChara__QAE_N_N_Z)(GameModule + 0x471f20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mPlayCamMotFromCharMot(class mHRChara* const this, int32_t arg2, int32_t arg3, uint8_t arg4, uint8_t arg5, uint8_t arg6) [?mPlayCamMotFromCharMot@mHRChara@@QAEXHH_N00@Z]
	typedef void(__thiscall* _mPlayCamMotFromCharMot_mHRChara__QAEXHH_N00_Z)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3, uint8_t arg4, uint8_t arg5, uint8_t arg6);
	void mPlayCamMotFromCharMot(int32_t arg2, int32_t arg3, uint8_t arg4, uint8_t arg5, uint8_t arg6)
	{
		_mPlayCamMotFromCharMot_mHRChara__QAEXHH_N00_Z mFunc = (_mPlayCamMotFromCharMot_mHRChara__QAEXHH_N00_Z)(GameModule + 0x471f80);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPlayMotionMov(class mHRChara* const this, int32_t arg2, float arg3, float arg4, uint8_t arg5) [?mPlayMotionMov@mHRChara@@QAE_NHMM_N@Z]
	typedef uint8_t(__thiscall* _mPlayMotionMov_mHRChara__QAE_NHMM_N_Z_2)(class mHRChara* const thisPtr, int32_t arg2, float arg3, float arg4, uint8_t arg5);
	uint8_t mPlayMotionMov_2(int32_t arg2, float arg3, float arg4, uint8_t arg5)
	{
		_mPlayMotionMov_mHRChara__QAE_NHMM_N_Z_2 mFunc = (_mPlayMotionMov_mHRChara__QAE_NHMM_N_Z_2)(GameModule + 0x4721d0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRChara::checkDeleteBlackBodyEffect(class mHRChara* const this) [?checkDeleteBlackBodyEffect@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _checkDeleteBlackBodyEffect_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void checkDeleteBlackBodyEffect()
	{
		_checkDeleteBlackBodyEffect_mHRChara__QAEXXZ mFunc = (_checkDeleteBlackBodyEffect_mHRChara__QAEXXZ)(GameModule + 0x4722c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetHitCounter(class mHRChara* const this) [?mSetHitCounter@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mSetHitCounter_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mSetHitCounter()
	{
		_mSetHitCounter_mHRChara__QAEXXZ mFunc = (_mSetHitCounter_mHRChara__QAEXXZ)(GameModule + 0x4722e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mReleaseBloodSplash(class mHRChara* const this, uint8_t arg2) [?mReleaseBloodSplash@mHRChara@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _mReleaseBloodSplash_mHRChara__QAE_N_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	uint8_t mReleaseBloodSplash(uint8_t arg2)
	{
		_mReleaseBloodSplash_mHRChara__QAE_N_N_Z mFunc = (_mReleaseBloodSplash_mHRChara__QAE_N_N_Z)(GameModule + 0x472310);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPreFrameProc(class mHRChara* const this) [?mPreFrameProc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPreFrameProc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mPreFrameProc()
	{
		_mPreFrameProc_mHRChara__UAE_NXZ mFunc = (_mPreFrameProc_mHRChara__UAE_NXZ)(GameModule + 0x472370);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPreRenderProc(class mHRChara* const this) [?mPreRenderProc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPreRenderProc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mPreRenderProc()
	{
		_mPreRenderProc_mHRChara__UAE_NXZ mFunc = (_mPreRenderProc_mHRChara__UAE_NXZ)(GameModule + 0x472510);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mDetouchMotionBrend(class mHRChara* const this) [?mDetouchMotionBrend@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mDetouchMotionBrend_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mDetouchMotionBrend()
	{
		_mDetouchMotionBrend_mHRChara__QAEXXZ mFunc = (_mDetouchMotionBrend_mHRChara__QAEXXZ)(GameModule + 0x472540);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mReleaseDemoBtleIcn(class mHRChara* const this) [?mReleaseDemoBtleIcn@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mReleaseDemoBtleIcn_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mReleaseDemoBtleIcn()
	{
		_mReleaseDemoBtleIcn_mHRChara__QAEXXZ mFunc = (_mReleaseDemoBtleIcn_mHRChara__QAEXXZ)(GameModule + 0x4725b0);
		return mFunc(this);
	}
	// [Function] uint8_t mHRChara::isThisCharaExist(class mHRChara* arg1) [?isThisCharaExist@mHRChara@@SA_NPBV1@@Z]
	typedef uint8_t(__fastcall* _isThisCharaExist_mHRChara__SA_NPBV1__Z)(class mHRChara* arg1);
	static uint8_t isThisCharaExist(class mHRChara* arg1)
	{
		_isThisCharaExist_mHRChara__SA_NPBV1__Z mFunc = (_isThisCharaExist_mHRChara__SA_NPBV1__Z)(GameModule + 0x4725d0);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRChara::mTermAllNpc() [?mTermAllNpc@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mTermAllNpc_mHRChara__SA_NXZ)();
	static uint8_t mTermAllNpc()
	{
		_mTermAllNpc_mHRChara__SA_NXZ mFunc = (_mTermAllNpc_mHRChara__SA_NXZ)(GameModule + 0x472600);
		return mFunc();
	}
	// [Function] int32_t mHRChara::mGetPopZakoNum() [?mGetPopZakoNum@mHRChara@@SAHXZ]
	typedef int32_t(__fastcall* _mGetPopZakoNum_mHRChara__SAHXZ)();
	static int32_t mGetPopZakoNum()
	{
		_mGetPopZakoNum_mHRChara__SAHXZ mFunc = (_mGetPopZakoNum_mHRChara__SAHXZ)(GameModule + 0x472670);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::mDeleteDispChara(class mHRChara* const this) [?mDeleteDispChara@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mDeleteDispChara_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mDeleteDispChara()
	{
		_mDeleteDispChara_mHRChara__QAEXXZ mFunc = (_mDeleteDispChara_mHRChara__QAEXXZ)(GameModule + 0x4726a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetAiDef(class mHRChara* const this, int32_t arg2) [?mSetAiDef@mHRChara@@QAEXH@Z]
	typedef void(__thiscall* _mSetAiDef_mHRChara__QAEXH_Z)(class mHRChara* const thisPtr, int32_t arg2);
	void mSetAiDef(int32_t arg2)
	{
		_mSetAiDef_mHRChara__QAEXH_Z mFunc = (_mSetAiDef_mHRChara__QAEXH_Z)(GameModule + 0x4726d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::setFootShadowDrawFlag(class mHRChara* const this, uint8_t const arg2) [?setFootShadowDrawFlag@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _setFootShadowDrawFlag_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t const arg2);
	void setFootShadowDrawFlag(uint8_t const arg2)
	{
		_setFootShadowDrawFlag_mHRChara__QAEX_N_Z mFunc = (_setFootShadowDrawFlag_mHRChara__QAEX_N_Z)(GameModule + 0x4726f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t mHRChara::mFrameProcAll() [?mFrameProcAll@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mFrameProcAll_mHRChara__SA_NXZ)();
	static uint8_t mFrameProcAll()
	{
		_mFrameProcAll_mHRChara__SA_NXZ mFunc = (_mFrameProcAll_mHRChara__SA_NXZ)(GameModule + 0x472810);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mRenderProcAll(uint8_t arg1) [?mRenderProcAll@mHRChara@@SA_N_N@Z]
	typedef uint8_t(__fastcall* _mRenderProcAll_mHRChara__SA_N_N_Z)(uint8_t arg1);
	static uint8_t mRenderProcAll(uint8_t arg1)
	{
		_mRenderProcAll_mHRChara__SA_N_N_Z mFunc = (_mRenderProcAll_mHRChara__SA_N_N_Z)(GameModule + 0x472a40);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRChara::mPostRenderProcAll() [?mPostRenderProcAll@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mPostRenderProcAll_mHRChara__SA_NXZ)();
	static uint8_t mPostRenderProcAll()
	{
		_mPostRenderProcAll_mHRChara__SA_NXZ mFunc = (_mPostRenderProcAll_mHRChara__SA_NXZ)(GameModule + 0x472ba0);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mTermAllNpcWithoutCmnObj() [?mTermAllNpcWithoutCmnObj@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mTermAllNpcWithoutCmnObj_mHRChara__SA_NXZ)();
	static uint8_t mTermAllNpcWithoutCmnObj()
	{
		_mTermAllNpcWithoutCmnObj_mHRChara__SA_NXZ mFunc = (_mTermAllNpcWithoutCmnObj_mHRChara__SA_NXZ)(GameModule + 0x472c10);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mTermAllEnemyNpc() [?mTermAllEnemyNpc@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mTermAllEnemyNpc_mHRChara__SA_NXZ)();
	static uint8_t mTermAllEnemyNpc()
	{
		_mTermAllEnemyNpc_mHRChara__SA_NXZ mFunc = (_mTermAllEnemyNpc_mHRChara__SA_NXZ)(GameModule + 0x472c80);
		return mFunc();
	}
	// [Function] class mHRChara* mHRChara::mGetNpcTop() [?mGetNpcTop@mHRChara@@SAPAV1@XZ]
	typedef class mHRChara*(__fastcall* _mGetNpcTop_mHRChara__SAPAV1_XZ)();
	static class mHRChara* mGetNpcTop()
	{
		_mGetNpcTop_mHRChara__SAPAV1_XZ mFunc = (_mGetNpcTop_mHRChara__SAPAV1_XZ)(GameModule + 0x472cf0);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::SetFileName(class mHRChara* const this, char const* arg2) [?SetFileName@mHRChara@@QAEXPBD@Z]
	typedef void(__thiscall* _SetFileName_mHRChara__QAEXPBD_Z)(class mHRChara* const thisPtr, char const* arg2);
	void SetFileName(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_SetFileName_mHRChara__QAEXPBD_Z mFunc = (_SetFileName_mHRChara__QAEXPBD_Z)(GameModule + 0x473620);
		return mFunc(this, arg2_c_str);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMaxHp(class mHRChara* const this, float arg2) [?mSetMaxHp@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetMaxHp_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetMaxHp(float arg2)
	{
		_mSetMaxHp_mHRChara__QAEXM_Z mFunc = (_mSetMaxHp_mHRChara__QAEXM_Z)(GameModule + 0x473640);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTerm(class mHRChara* const this) [?mTerm@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mTerm_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTerm()
	{
		_mTerm_mHRChara__UAE_NXZ mFunc = (_mTerm_mHRChara__UAE_NXZ)(GameModule + 0x473660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetPos(class mHRChara* const this, struct Vec& arg2, uint8_t arg3, float arg4) [?mSetPos@mHRChara@@UAEXABUVec@@_NM@Z]
	typedef void(__thiscall* _mSetPos_mHRChara__UAEXABUVec___NM_Z)(class mHRChara* const thisPtr, struct Vec& arg2, uint8_t arg3, float arg4);
	void mSetPos(struct Vec& arg2, uint8_t arg3, float arg4)
	{
		_mSetPos_mHRChara__UAEXABUVec___NM_Z mFunc = (_mSetPos_mHRChara__UAEXABUVec___NM_Z)(GameModule + 0x473940);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetRot(class mHRChara* const this, struct Vec& arg2) [?mSetRot@mHRChara@@UAEXABUVec@@@Z]
	typedef void(__thiscall* _mSetRot_mHRChara__UAEXABUVec___Z)(class mHRChara* const thisPtr, struct Vec& arg2);
	void mSetRot(struct Vec& arg2)
	{
		_mSetRot_mHRChara__UAEXABUVec___Z mFunc = (_mSetRot_mHRChara__UAEXABUVec___Z)(GameModule + 0x473a30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetScale(class mHRChara* const this, struct Vec& arg2) [?mSetScale@mHRChara@@UAEXABUVec@@@Z]
	typedef void(__thiscall* _mSetScale_mHRChara__UAEXABUVec___Z)(class mHRChara* const thisPtr, struct Vec& arg2);
	void mSetScale(struct Vec& arg2)
	{
		_mSetScale_mHRChara__UAEXABUVec___Z mFunc = (_mSetScale_mHRChara__UAEXABUVec___Z)(GameModule + 0x473ac0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mHitCheck(class mHRChara* const this, class mHRChara* arg2) [?mHitCheck@mHRChara@@UAE_NPAV1@@Z]
	typedef uint8_t(__thiscall* _mHitCheck_mHRChara__UAE_NPAV1__Z)(class mHRChara* const thisPtr, class mHRChara* arg2);
	uint8_t mHitCheck(class mHRChara* arg2)
	{
		_mHitCheck_mHRChara__UAE_NPAV1__Z mFunc = (_mHitCheck_mHRChara__UAE_NPAV1__Z)(GameModule + 0x473b20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mMotionSpeedControl(class mHRChara* const this) [?mMotionSpeedControl@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mMotionSpeedControl_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mMotionSpeedControl()
	{
		_mMotionSpeedControl_mHRChara__QAEXXZ mFunc = (_mMotionSpeedControl_mHRChara__QAEXXZ)(GameModule + 0x473f60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mCallMotionProc(class mHRChara* const this) [?mCallMotionProc@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mCallMotionProc_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mCallMotionProc()
	{
		_mCallMotionProc_mHRChara__QAEXXZ mFunc = (_mCallMotionProc_mHRChara__QAEXXZ)(GameModule + 0x474290);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPlayMotion(class mHRChara* const this, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6) [?mPlayMotion@mHRChara@@UAE_NH_NH0M@Z]
	typedef uint8_t(__thiscall* _mPlayMotion_mHRChara__UAE_NH_NH0M_Z)(class mHRChara* const thisPtr, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6);
	uint8_t mPlayMotion(int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6)
	{
		_mPlayMotion_mHRChara__UAE_NH_NH0M_Z mFunc = (_mPlayMotion_mHRChara__UAE_NH_NH0M_Z)(GameModule + 0x474400);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] void __convention("thiscall") mHRChara::mCallMoneyDrop(class mHRChara* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mCallMoneyDrop@mHRChara@@QAEXH_N0@Z]
	typedef void(__thiscall* _mCallMoneyDrop_mHRChara__QAEXH_N0_Z)(class mHRChara* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
	void mCallMoneyDrop(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		_mCallMoneyDrop_mHRChara__QAEXH_N0_Z mFunc = (_mCallMoneyDrop_mHRChara__QAEXH_N0_Z)(GameModule + 0x474550);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mAttachWep(class mHRChara* const this, class TGmf* arg2, enum eUDLR arg3, char* arg4) [?mAttachWep@mHRChara@@UAE_NPAVTGmf@@W4eUDLR@@PAD@Z]
	typedef uint8_t(__thiscall* _mAttachWep_mHRChara__UAE_NPAVTGmf__W4eUDLR__PAD_Z)(class mHRChara* const thisPtr, class TGmf* arg2, enum eUDLR arg3, char* arg4);
	uint8_t mAttachWep(class TGmf* arg2, /* enum eUDLR */ uint32_t arg3, std::string arg4)
	{
		std::vector<char> arg4_c_str(arg4.c_str(), + arg4.c_str() + arg4.size() + 1);
		_mAttachWep_mHRChara__UAE_NPAVTGmf__W4eUDLR__PAD_Z mFunc = (_mAttachWep_mHRChara__UAE_NPAVTGmf__W4eUDLR__PAD_Z)(GameModule + 0x4745d0);
		return mFunc(this, arg2, (enum eUDLR)arg3, &arg4_c_str[0]);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mDetachWep(class mHRChara* const this, enum eUDLR arg2, char* arg3) [?mDetachWep@mHRChara@@UAE_NW4eUDLR@@PAD@Z]
	typedef uint8_t(__thiscall* _mDetachWep_mHRChara__UAE_NW4eUDLR__PAD_Z)(class mHRChara* const thisPtr, enum eUDLR arg2, char* arg3);
	uint8_t mDetachWep(/* enum eUDLR */ uint32_t arg2, std::string arg3)
	{
		std::vector<char> arg3_c_str(arg3.c_str(), + arg3.c_str() + arg3.size() + 1);
		_mDetachWep_mHRChara__UAE_NW4eUDLR__PAD_Z mFunc = (_mDetachWep_mHRChara__UAE_NW4eUDLR__PAD_Z)(GameModule + 0x474880);
		return mFunc(this, (enum eUDLR)arg2, &arg3_c_str[0]);
	}
	// [Function] void __convention("thiscall") mHRChara::mSemitransparentProcess(class mHRChara* const this) [?mSemitransparentProcess@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mSemitransparentProcess_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mSemitransparentProcess()
	{
		_mSemitransparentProcess_mHRChara__UAEXXZ mFunc = (_mSemitransparentProcess_mHRChara__UAEXXZ)(GameModule + 0x474980);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mUpdateAtkColl(class mHRChara* const this) [?mUpdateAtkColl@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mUpdateAtkColl_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mUpdateAtkColl()
	{
		_mUpdateAtkColl_mHRChara__UAEXXZ mFunc = (_mUpdateAtkColl_mHRChara__UAEXXZ)(GameModule + 0x474c50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mRenderShadowProc(class mHRChara* const this) [?mRenderShadowProc@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mRenderShadowProc_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mRenderShadowProc()
	{
		_mRenderShadowProc_mHRChara__UAEXXZ mFunc = (_mRenderShadowProc_mHRChara__UAEXXZ)(GameModule + 0x474e50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mRefreshFloorPosition(class mHRChara* const this, float arg2, uint8_t arg3) [?mRefreshFloorPosition@mHRChara@@UAE_NM_N@Z]
	typedef uint8_t(__thiscall* _mRefreshFloorPosition_mHRChara__UAE_NM_N_Z)(class mHRChara* const thisPtr, float arg2, uint8_t arg3);
	uint8_t mRefreshFloorPosition(float arg2, uint8_t arg3)
	{
		_mRefreshFloorPosition_mHRChara__UAE_NM_N_Z mFunc = (_mRefreshFloorPosition_mHRChara__UAE_NM_N_Z)(GameModule + 0x474f70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mDamageProc(class mHRChara* const this) [?mDamageProc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mDamageProc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mDamageProc()
	{
		_mDamageProc_mHRChara__UAE_NXZ mFunc = (_mDamageProc_mHRChara__UAE_NXZ)(GameModule + 0x475080);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mRestoreDamage(class mHRChara* const this, int32_t arg2, float arg3) [?mRestoreDamage@mHRChara@@UAEXHM@Z]
	typedef void(__thiscall* _mRestoreDamage_mHRChara__UAEXHM_Z)(class mHRChara* const thisPtr, int32_t arg2, float arg3);
	void mRestoreDamage(int32_t arg2, float arg3)
	{
		_mRestoreDamage_mHRChara__UAEXHM_Z mFunc = (_mRestoreDamage_mHRChara__UAEXHM_Z)(GameModule + 0x475090);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckAttack(class mHRChara* const this) [?mCheckAttack@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAttack_mHRChara__UAE_NXZ_2)(class mHRChara* const thisPtr);
	uint8_t mCheckAttack_2()
	{
		_mCheckAttack_mHRChara__UAE_NXZ_2 mFunc = (_mCheckAttack_mHRChara__UAE_NXZ_2)(GameModule + 0x4750e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanAttack(class mHRChara* const this) [?mCheckCanAttack@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanAttack_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckCanAttack()
	{
		_mCheckCanAttack_mHRChara__UAE_NXZ mFunc = (_mCheckCanAttack_mHRChara__UAE_NXZ)(GameModule + 0x4750f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mGetTsubazeriaiPos(class mHRChara* const this, struct Vec* arg2) [?mGetTsubazeriaiPos@mHRChara@@UAEXPAUVec@@@Z]
	typedef void(__thiscall* _mGetTsubazeriaiPos_mHRChara__UAEXPAUVec___Z)(class mHRChara* const thisPtr, struct Vec* arg2);
	void mGetTsubazeriaiPos(struct Vec* arg2)
	{
		_mGetTsubazeriaiPos_mHRChara__UAEXPAUVec___Z mFunc = (_mGetTsubazeriaiPos_mHRChara__UAEXPAUVec___Z)(GameModule + 0x475100);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetPcTsubaOuterMot(class mHRChara* const this) [?mSetPcTsubaOuterMot@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mSetPcTsubaOuterMot_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mSetPcTsubaOuterMot()
	{
		_mSetPcTsubaOuterMot_mHRChara__UAEXXZ mFunc = (_mSetPcTsubaOuterMot_mHRChara__UAEXXZ)(GameModule + 0x475120);
		return mFunc(this);
	}
	// [Function] struct Vec __convention("thiscall") mHRChara::GetTsubaEffectPos(class mHRChara* const this) [?GetTsubaEffectPos@mHRChara@@UAE?AUVec@@XZ]
	typedef struct Vec(__thiscall* _GetTsubaEffectPos_mHRChara__UAEAUVec__XZ)(class mHRChara* const thisPtr);
	struct Vec GetTsubaEffectPos()
	{
		_GetTsubaEffectPos_mHRChara__UAEAUVec__XZ mFunc = (_GetTsubaEffectPos_mHRChara__UAEAUVec__XZ)(GameModule + 0x475140);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanCatch(class mHRChara* const this) [?mCheckCanCatch@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanCatch_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckCanCatch()
	{
		_mCheckCanCatch_mHRChara__UAE_NXZ mFunc = (_mCheckCanCatch_mHRChara__UAE_NXZ)(GameModule + 0x475270);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanThrow(class mHRChara* const this) [?mCheckCanThrow@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanThrow_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckCanThrow()
	{
		_mCheckCanThrow_mHRChara__UAE_NXZ mFunc = (_mCheckCanThrow_mHRChara__UAE_NXZ)(GameModule + 0x475280);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mPlayThrownMotion(class mHRChara* const this, int32_t arg2, int32_t arg3) [?mPlayThrownMotion@mHRChara@@UAEXHH@Z]
	typedef void(__thiscall* _mPlayThrownMotion_mHRChara__UAEXHH_Z)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3);
	void mPlayThrownMotion(int32_t arg2, int32_t arg3)
	{
		_mPlayThrownMotion_mHRChara__UAEXHH_Z mFunc = (_mPlayThrownMotion_mHRChara__UAEXHH_Z)(GameModule + 0x475290);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPlayMotionBlend(class mHRChara* const this, class TGan** arg2, char arg3) [?mPlayMotionBlend@mHRChara@@UAE_NPAPAVTGan@@C@Z]
	typedef uint8_t(__thiscall* _mPlayMotionBlend_mHRChara__UAE_NPAPAVTGan__C_Z)(class mHRChara* const thisPtr, class TGan** arg2, char arg3);
	uint8_t mPlayMotionBlend(class TGan** arg2, char arg3)
	{
		_mPlayMotionBlend_mHRChara__UAE_NPAPAVTGan__C_Z mFunc = (_mPlayMotionBlend_mHRChara__UAE_NPAPAVTGan__C_Z)(GameModule + 0x4754e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPlayMotionBlend(class mHRChara* const this, int32_t arg2, char arg3, uint8_t arg4, uint8_t arg5) [?mPlayMotionBlend@mHRChara@@UAE_NHC_N0@Z]
	typedef uint8_t(__thiscall* _mPlayMotionBlend_mHRChara__UAE_NHC_N0_Z_2)(class mHRChara* const thisPtr, int32_t arg2, char arg3, uint8_t arg4, uint8_t arg5);
	uint8_t mPlayMotionBlend_2(int32_t arg2, char arg3, uint8_t arg4, uint8_t arg5)
	{
		_mPlayMotionBlend_mHRChara__UAE_NHC_N0_Z_2 mFunc = (_mPlayMotionBlend_mHRChara__UAE_NHC_N0_Z_2)(GameModule + 0x475630);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRChara::mBossDeadCommonProcess(class mHRChara* const this) [?mBossDeadCommonProcess@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mBossDeadCommonProcess_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mBossDeadCommonProcess()
	{
		_mBossDeadCommonProcess_mHRChara__UAEXXZ mFunc = (_mBossDeadCommonProcess_mHRChara__UAEXXZ)(GameModule + 0x4758f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanLockOn(class mHRChara* const this) [?mCheckCanLockOn@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanLockOn_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckCanLockOn()
	{
		_mCheckCanLockOn_mHRChara__UAE_NXZ mFunc = (_mCheckCanLockOn_mHRChara__UAE_NXZ)(GameModule + 0x475910);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::getLockOnCursorBasePosition(class mHRChara* const this, struct Vec* arg2) [?getLockOnCursorBasePosition@mHRChara@@UBE_NPAUVec@@@Z]
	typedef uint8_t(__thiscall* _getLockOnCursorBasePosition_mHRChara__UBE_NPAUVec___Z)(class mHRChara* const thisPtr, struct Vec* arg2);
	uint8_t getLockOnCursorBasePosition(struct Vec* arg2)
	{
		_getLockOnCursorBasePosition_mHRChara__UBE_NPAUVec___Z mFunc = (_getLockOnCursorBasePosition_mHRChara__UBE_NPAUVec___Z)(GameModule + 0x475920);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetVisible(class mHRChara* const this, uint8_t arg2) [?mSetVisible@mHRChara@@UAEX_N@Z]
	typedef void(__thiscall* _mSetVisible_mHRChara__UAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetVisible(uint8_t arg2)
	{
		_mSetVisible_mHRChara__UAEX_N_Z mFunc = (_mSetVisible_mHRChara__UAEX_N_Z)(GameModule + 0x475a30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetWepVisible(class mHRChara* const this, uint8_t arg2) [?mSetWepVisible@mHRChara@@UAEX_N@Z]
	typedef void(__thiscall* _mSetWepVisible_mHRChara__UAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetWepVisible(uint8_t arg2)
	{
		_mSetWepVisible_mHRChara__UAEX_N_Z mFunc = (_mSetWepVisible_mHRChara__UAEX_N_Z)(GameModule + 0x475a60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetWepEffectVisible(class mHRChara* const this, uint8_t arg2) [?mSetWepEffectVisible@mHRChara@@UAEX_N@Z]
	typedef void(__thiscall* _mSetWepEffectVisible_mHRChara__UAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetWepEffectVisible(uint8_t arg2)
	{
		_mSetWepEffectVisible_mHRChara__UAEX_N_Z mFunc = (_mSetWepEffectVisible_mHRChara__UAEX_N_Z)(GameModule + 0x475ae0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetVisibleDist(class mHRChara* const this, uint8_t arg2) [?mSetVisibleDist@mHRChara@@UAEX_N@Z]
	typedef void(__thiscall* _mSetVisibleDist_mHRChara__UAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetVisibleDist(uint8_t arg2)
	{
		_mSetVisibleDist_mHRChara__UAEX_N_Z mFunc = (_mSetVisibleDist_mHRChara__UAEX_N_Z)(GameModule + 0x475b90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mEffectInit(class mHRChara* const this) [?mEffectInit@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mEffectInit_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mEffectInit()
	{
		_mEffectInit_mHRChara__UAEXXZ mFunc = (_mEffectInit_mHRChara__UAEXXZ)(GameModule + 0x475bb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMirrorModel(class mHRChara* const this, uint8_t arg2) [?mSetMirrorModel@mHRChara@@UAEX_N@Z]
	typedef void(__thiscall* _mSetMirrorModel_mHRChara__UAEX_N_Z)(class mHRChara* const thisPtr, uint8_t arg2);
	void mSetMirrorModel(uint8_t arg2)
	{
		_mSetMirrorModel_mHRChara__UAEX_N_Z mFunc = (_mSetMirrorModel_mHRChara__UAEX_N_Z)(GameModule + 0x475bc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetAiAtk(class mHRChara* const this, int32_t arg2, int32_t arg3) [?mSetAiAtk@mHRChara@@UAEXHH@Z]
	typedef void(__thiscall* _mSetAiAtk_mHRChara__UAEXHH_Z)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3);
	void mSetAiAtk(int32_t arg2, int32_t arg3)
	{
		_mSetAiAtk_mHRChara__UAEXHH_Z mFunc = (_mSetAiAtk_mHRChara__UAEXHH_Z)(GameModule + 0x475c00);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetWarpPos(class mHRChara* const this, struct Vec& arg2, uint8_t arg3) [?mSetWarpPos@mHRChara@@UAEXABUVec@@_N@Z]
	typedef void(__thiscall* _mSetWarpPos_mHRChara__UAEXABUVec___N_Z)(class mHRChara* const thisPtr, struct Vec& arg2, uint8_t arg3);
	void mSetWarpPos(struct Vec& arg2, uint8_t arg3)
	{
		_mSetWarpPos_mHRChara__UAEXABUVec___N_Z mFunc = (_mSetWarpPos_mHRChara__UAEXABUVec___N_Z)(GameModule + 0x475c40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mHitCheckStage(class mHRChara* const this, class ghmGcCollObjCapsule* arg2, struct Vec* arg3, struct Vec* arg4, struct Vec* arg5, struct Vec* arg6, class ghmGcCollObj** arg7, class ghmGcCollObjHitResult** arg8, class ghmGcCollObjHitResultObj* arg9, struct WGclMaterialSpec** arg10, uint8_t* arg11, uint8_t arg12, float arg13) [?mHitCheckStage@mHRChara@@UAE_NPAVghmGcCollObjCapsule@@PAUVec@@111PAPAVghmGcCollObj@@PAPAVghmGcCollObjHitResult@@PAVghmGcCollObjHitResultObj@@PAPAUWGclMaterialSpec@@PA_N_NM@Z]
	typedef uint8_t(__thiscall* _mHitCheckStage_mHRChara__UAE_NPAVghmGcCollObjCapsule__PAUVec__111PAPAVghmGcCollObj__PAPAVghmGcCollObjHitResult__PAVghmGcCollObjHitResultObj__PAPAUWGclMaterialSpec__PA_N_NM_Z)(class mHRChara* const thisPtr, class ghmGcCollObjCapsule* arg2, struct Vec* arg3, struct Vec* arg4, struct Vec* arg5, struct Vec* arg6, class ghmGcCollObj** arg7, class ghmGcCollObjHitResult** arg8, class ghmGcCollObjHitResultObj* arg9, struct WGclMaterialSpec** arg10, uint8_t* arg11, uint8_t arg12, float arg13);
	uint8_t mHitCheckStage(class ghmGcCollObjCapsule* arg2, struct Vec* arg3, struct Vec* arg4, struct Vec* arg5, struct Vec* arg6, class ghmGcCollObj** arg7, class ghmGcCollObjHitResult** arg8, class ghmGcCollObjHitResultObj* arg9, struct WGclMaterialSpec** arg10, uint8_t* arg11, uint8_t arg12, float arg13)
	{
		_mHitCheckStage_mHRChara__UAE_NPAVghmGcCollObjCapsule__PAUVec__111PAPAVghmGcCollObj__PAPAVghmGcCollObjHitResult__PAVghmGcCollObjHitResultObj__PAPAUWGclMaterialSpec__PA_N_NM_Z mFunc = (_mHitCheckStage_mHRChara__UAE_NPAVghmGcCollObjCapsule__PAUVec__111PAPAVghmGcCollObj__PAPAVghmGcCollObjHitResult__PAVghmGcCollObjHitResultObj__PAPAUWGclMaterialSpec__PA_N_NM_Z)(GameModule + 0x475cc0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
	}
	// [Function] class TGan* __convention("thiscall") mHRChara::mpGetGan(class mHRChara* const this, int32_t arg2) [?mpGetGan@mHRChara@@UAEPAVTGan@@H@Z]
	typedef class TGan*(__thiscall* _mpGetGan_mHRChara__UAEPAVTGan__H_Z_2)(class mHRChara* const thisPtr, int32_t arg2);
	class TGan* mpGetGan_2(int32_t arg2)
	{
		_mpGetGan_mHRChara__UAEPAVTGan__H_Z_2 mFunc = (_mpGetGan_mHRChara__UAEPAVTGan__H_Z_2)(GameModule + 0x477960);
		return mFunc(this, arg2);
	}
	// [Function] class TGan** __convention("thiscall") mHRChara::mppGetGan(class mHRChara* const this, int32_t arg2) [?mppGetGan@mHRChara@@UAEPAPAVTGan@@H@Z]
	typedef class TGan**(__thiscall* _mppGetGan_mHRChara__UAEPAPAVTGan__H_Z)(class mHRChara* const thisPtr, int32_t arg2);
	// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
	void mppGetGan(int32_t arg2)
	{
		_mppGetGan_mHRChara__UAEPAPAVTGan__H_Z mFunc = (_mppGetGan_mHRChara__UAEPAPAVTGan__H_Z)(GameModule + 0x4779c0);
		mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mRequestBloodSplash(class mHRChara* const this, char* inNodeName, int32_t inRagTick) [?mRequestBloodSplash@mHRChara@@UAE_NPADH@Z]
	typedef uint8_t(__thiscall* _mRequestBloodSplash_mHRChara__UAE_NPADH_Z)(class mHRChara* const thisPtr, char* inNodeName, int32_t inRagTick);
	uint8_t mRequestBloodSplash(std::string inNodeName, int32_t inRagTick)
	{
		std::vector<char> inNodeName_c_str(inNodeName.c_str(), + inNodeName.c_str() + inNodeName.size() + 1);
		_mRequestBloodSplash_mHRChara__UAE_NPADH_Z mFunc = (_mRequestBloodSplash_mHRChara__UAE_NPADH_Z)(GameModule + 0x4779e0);
		return mFunc(this, &inNodeName_c_str[0], inRagTick);
	}
	// [Function] void __convention("thiscall") mHRChara::mCallKillPcProcess(class mHRChara* const this) [?mCallKillPcProcess@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mCallKillPcProcess_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void mCallKillPcProcess()
	{
		_mCallKillPcProcess_mHRChara__UAEXXZ mFunc = (_mCallKillPcProcess_mHRChara__UAEXXZ)(GameModule + 0x477a90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckComboing(class mHRChara* const this) [?mCheckComboing@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckComboing_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCheckComboing()
	{
		_mCheckComboing_mHRChara__UAE_NXZ mFunc = (_mCheckComboing_mHRChara__UAE_NXZ)(GameModule + 0x477aa0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetAttackTableValue(class mHRChara* const this, int32_t arg2, int32_t arg3) [?mGetAttackTableValue@mHRChara@@UAEMHH@Z]
	typedef float(__thiscall* _mGetAttackTableValue_mHRChara__UAEMHH_Z)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3);
	float mGetAttackTableValue(int32_t arg2, int32_t arg3)
	{
		_mGetAttackTableValue_mHRChara__UAEMHH_Z mFunc = (_mGetAttackTableValue_mHRChara__UAEMHH_Z)(GameModule + 0x477ab0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetAttackDirection(class mHRChara* const this) [?mGetAttackDirection@mHRChara@@UAEMXZ]
	typedef float(__thiscall* _mGetAttackDirection_mHRChara__UAEMXZ)(class mHRChara* const thisPtr);
	float mGetAttackDirection()
	{
		_mGetAttackDirection_mHRChara__UAEMXZ mFunc = (_mGetAttackDirection_mHRChara__UAEMXZ)(GameModule + 0x477ac0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestLowDmg(class mHRChara* const this) [?mTestLowDmg@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mTestLowDmg_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTestLowDmg()
	{
		_mTestLowDmg_mHRChara__UAE_NXZ mFunc = (_mTestLowDmg_mHRChara__UAE_NXZ)(GameModule + 0x477ad0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCreatePiyori(class mHRChara* const this) [?mCreatePiyori@mHRChara@@UAE_NXZ]
	/// <summary>
	/// Creates a stun star effect above the character's head.
	/// </summary>
	typedef uint8_t(__thiscall* _mCreatePiyori_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mCreatePiyori()
	{
		_mCreatePiyori_mHRChara__UAE_NXZ mFunc = (_mCreatePiyori_mHRChara__UAE_NXZ)(GameModule + 0x477ae0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTermPiyori(class mHRChara* const this) [?mTermPiyori@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mTermPiyori_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mTermPiyori()
	{
		_mTermPiyori_mHRChara__UAE_NXZ mFunc = (_mTermPiyori_mHRChara__UAE_NXZ)(GameModule + 0x477b50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPiyoriProc(class mHRChara* const this) [?mPiyoriProc@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPiyoriProc_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t mPiyoriProc()
	{
		_mPiyoriProc_mHRChara__UAE_NXZ mFunc = (_mPiyoriProc_mHRChara__UAE_NXZ)(GameModule + 0x477b80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDamageAcceptFrame(class mHRChara* const this) [?mSetDamageAcceptFrame@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _mSetDamageAcceptFrame_mHRChara__UAEXXZ_2)(class mHRChara* const thisPtr);
	void mSetDamageAcceptFrame_2()
	{
		_mSetDamageAcceptFrame_mHRChara__UAEXXZ_2 mFunc = (_mSetDamageAcceptFrame_mHRChara__UAEXXZ_2)(GameModule + 0x477bd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsMultiStep(class mHRChara* const this) [?IsMultiStep@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsMultiStep_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsMultiStep()
	{
		_IsMultiStep_mHRChara__UAE_NXZ mFunc = (_IsMultiStep_mHRChara__UAE_NXZ)(GameModule + 0x477be0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsDownAttack(class mHRChara* const this) [?IsDownAttack@mHRChara@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsDownAttack_mHRChara__UAE_NXZ)(class mHRChara* const thisPtr);
	uint8_t IsDownAttack()
	{
		_IsDownAttack_mHRChara__UAE_NXZ mFunc = (_IsDownAttack_mHRChara__UAE_NXZ)(GameModule + 0x477bf0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::getFootShadowWidthHalf(class mHRChara* const this) [?getFootShadowWidthHalf@mHRChara@@UBEMXZ]
	typedef float(__thiscall* _getFootShadowWidthHalf_mHRChara__UBEMXZ)(class mHRChara* const thisPtr);
	float getFootShadowWidthHalf()
	{
		_getFootShadowWidthHalf_mHRChara__UBEMXZ mFunc = (_getFootShadowWidthHalf_mHRChara__UBEMXZ)(GameModule + 0x477c00);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::getFootShadowDepthPlus(class mHRChara* const this) [?getFootShadowDepthPlus@mHRChara@@UBEMXZ]
	typedef float(__thiscall* _getFootShadowDepthPlus_mHRChara__UBEMXZ)(class mHRChara* const thisPtr);
	float getFootShadowDepthPlus()
	{
		_getFootShadowDepthPlus_mHRChara__UBEMXZ mFunc = (_getFootShadowDepthPlus_mHRChara__UBEMXZ)(GameModule + 0x477c10);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::getFootShadowDepthMinus(class mHRChara* const this) [?getFootShadowDepthMinus@mHRChara@@UBEMXZ]
	typedef float(__thiscall* _getFootShadowDepthMinus_mHRChara__UBEMXZ)(class mHRChara* const thisPtr);
	float getFootShadowDepthMinus()
	{
		_getFootShadowDepthMinus_mHRChara__UBEMXZ mFunc = (_getFootShadowDepthMinus_mHRChara__UBEMXZ)(GameModule + 0x477c20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::OnStageUnload(class mHRChara* const this) [?OnStageUnload@mHRChara@@UAEXXZ]
	typedef void(__thiscall* _OnStageUnload_mHRChara__UAEXXZ)(class mHRChara* const thisPtr);
	void OnStageUnload()
	{
		_OnStageUnload_mHRChara__UAEXXZ mFunc = (_OnStageUnload_mHRChara__UAEXXZ)(GameModule + 0x477c30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::setFootGroundTouchActFlagFromAI(class mHRChara* const this, uint8_t const arg2) [?setFootGroundTouchActFlagFromAI@mHRChara@@QAEX_N@Z]
	typedef void(__thiscall* _setFootGroundTouchActFlagFromAI_mHRChara__QAEX_N_Z)(class mHRChara* const thisPtr, uint8_t const arg2);
	void setFootGroundTouchActFlagFromAI(uint8_t const arg2)
	{
		_setFootGroundTouchActFlagFromAI_mHRChara__QAEX_N_Z mFunc = (_setFootGroundTouchActFlagFromAI_mHRChara__QAEX_N_Z)(GameModule + 0x477c60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mPlayCamMot(class mHRChara* const this, class TGan* arg2, int32_t arg3, uint8_t arg4, struct Vec* arg5, float* arg6, uint8_t arg7) [?mPlayCamMot@mHRChara@@QAEXPAVTGan@@H_NPAUVec@@PAM1@Z]
	typedef void(__thiscall* _mPlayCamMot_mHRChara__QAEXPAVTGan__H_NPAUVec__PAM1_Z)(class mHRChara* const thisPtr, class TGan* arg2, int32_t arg3, uint8_t arg4, struct Vec* arg5, float* arg6, uint8_t arg7);
	void mPlayCamMot(class TGan* arg2, int32_t arg3, uint8_t arg4, struct Vec* arg5, float* arg6, uint8_t arg7)
	{
		_mPlayCamMot_mHRChara__QAEXPAVTGan__H_NPAUVec__PAM1_Z mFunc = (_mPlayCamMot_mHRChara__QAEXPAVTGan__H_NPAUVec__PAM1_Z)(GameModule + 0x477c90);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	// [Function] void __convention("thiscall") mHRChara::mStopCamMotFromCharMot(class mHRChara* const this) [?mStopCamMotFromCharMot@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mStopCamMotFromCharMot_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mStopCamMotFromCharMot()
	{
		_mStopCamMotFromCharMot_mHRChara__QAEXXZ mFunc = (_mStopCamMotFromCharMot_mHRChara__QAEXXZ)(GameModule + 0x477e20);
		return mFunc(this);
	}
	// [Function] uint8_t mHRChara::mRenderShadowProcAll() [?mRenderShadowProcAll@mHRChara@@SA_NXZ]
	typedef uint8_t(__fastcall* _mRenderShadowProcAll_mHRChara__SA_NXZ)();
	static uint8_t mRenderShadowProcAll()
	{
		_mRenderShadowProcAll_mHRChara__SA_NXZ mFunc = (_mRenderShadowProcAll_mHRChara__SA_NXZ)(GameModule + 0x477e60);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::mSetRotY(class mHRChara* const this, float arg2) [?mSetRotY@mHRChara@@QAEXM@Z]
	typedef void(__thiscall* _mSetRotY_mHRChara__QAEXM_Z)(class mHRChara* const thisPtr, float arg2);
	void mSetRotY(float arg2)
	{
		_mSetRotY_mHRChara__QAEXM_Z mFunc = (_mSetRotY_mHRChara__QAEXM_Z)(GameModule + 0x478050);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckSegmentHitStage(class mHRChara* const this, int64_t arg2, int32_t, float arg4, uint8_t arg5, float* arg6, struct Vec* arg7) [?mCheckSegmentHitStage@mHRChara@@QAE_NUVec@@0M_NPAMPAU2@@Z]
	typedef uint8_t(__thiscall* _mCheckSegmentHitStage_mHRChara__QAE_NUVec__0M_NPAMPAU2__Z)(class mHRChara* const thisPtr, int64_t arg2, uint32_t arg3, float arg4, uint8_t arg5, float* arg6, struct Vec* arg7);
	uint8_t mCheckSegmentHitStage(int64_t arg2, uint32_t arg3, float arg4, uint8_t arg5, float* arg6, struct Vec* arg7)
	{
		_mCheckSegmentHitStage_mHRChara__QAE_NUVec__0M_NPAMPAU2__Z mFunc = (_mCheckSegmentHitStage_mHRChara__QAE_NUVec__0M_NPAMPAU2__Z)(GameModule + 0x4780c0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	// [Function] void __convention("thiscall") mHRChara::mEraseDispChara(class mHRChara* const this) [?mEraseDispChara@mHRChara@@QAEXXZ]
	typedef void(__thiscall* _mEraseDispChara_mHRChara__QAEXXZ)(class mHRChara* const thisPtr);
	void mEraseDispChara()
	{
		_mEraseDispChara_mHRChara__QAEXXZ mFunc = (_mEraseDispChara_mHRChara__QAEXXZ)(GameModule + 0x478340);
		return mFunc(this);
	}
	// [Function] class mHRChara* mHRChara::mGetCharaPtr(enum enCharaType arg1, uint32_t arg2) [?mGetCharaPtr@mHRChara@@SAPAV1@W4enCharaType@@I@Z]
	typedef class mHRChara*(__fastcall* _mGetCharaPtr_mHRChara__SAPAV1_W4enCharaType__I_Z_2)(enum enCharaType arg1, uint32_t arg2);
	static class mHRChara* mGetCharaPtr_2(/* enum enCharaType */ uint32_t arg1, uint32_t arg2)
	{
		_mGetCharaPtr_mHRChara__SAPAV1_W4enCharaType__I_Z_2 mFunc = (_mGetCharaPtr_mHRChara__SAPAV1_W4enCharaType__I_Z_2)(GameModule + 0x478370);
		return mFunc((enum enCharaType)arg1, arg2);
	}
	// [Function] class mHRChara* mHRChara::mAllSearchPiyoZako() [?mAllSearchPiyoZako@mHRChara@@SAPAV1@XZ]
	typedef class mHRChara*(__fastcall* _mAllSearchPiyoZako_mHRChara__SAPAV1_XZ)();
	static class mHRChara* mAllSearchPiyoZako()
	{
		_mAllSearchPiyoZako_mHRChara__SAPAV1_XZ mFunc = (_mAllSearchPiyoZako_mHRChara__SAPAV1_XZ)(GameModule + 0x4783a0);
		return mFunc();
	}
	// [Function] void mHRChara::OnStageUnloadAll() [?OnStageUnloadAll@mHRChara@@SAXXZ]
	typedef void(__fastcall* _OnStageUnloadAll_mHRChara__SAXXZ)();
	static void OnStageUnloadAll()
	{
		_OnStageUnloadAll_mHRChara__SAXXZ mFunc = (_OnStageUnloadAll_mHRChara__SAXXZ)(GameModule + 0x4783e0);
		return mFunc();
	}
	/// Meta

	PJZAKO* AsZako() { return mTestZako() ? (PJZAKO*)this : nullptr; }
	std::string ToString() const { std::stringstream stream; stream << "class mHRChara (" << mStatus.ToString() << ") [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(mHRChara& InObject)
	{
		mStatus = InObject.mStatus;
		mResource = InObject.mResource;
		mEffect = InObject.mEffect;
		m_inAmbientShadow = InObject.m_inAmbientShadow;
		m_ainFootShadow = InObject.m_ainFootShadow;
		mInitProc = InObject.mInitProc;
		m_pCharController = InObject.m_pCharController;
		mWepColl = InObject.mWepColl;
		motionInvincibilityFrames = InObject.motionInvincibilityFrames;
		invincibileMotion = InObject.invincibileMotion;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<mHRChara, ghmListObj>("mHRChara")
			.addFunction("__tostring", &mHRChara::ToString)
			.addFunction("GetPtrAddr", &mHRChara::GetPtrAddr)
			.addProperty("mStatus", &mHRChara::mStatus)
			.addProperty("mResource", &mHRChara::mResource)
			.addProperty("mEffect", &mHRChara::mEffect)
			.addProperty("m_inAmbientShadow", &mHRChara::m_inAmbientShadow)
			.addProperty("m_ainFootShadow", &mHRChara::m_ainFootShadow)
			.addProperty("mInitProc", &mHRChara::mInitProc)
			.addProperty("m_pCharController", &mHRChara::m_pCharController)
			.addProperty("mWepColl", &mHRChara::mWepColl)
			.addProperty("motionInvincibilityFrames", &mHRChara::motionInvincibilityFrames)
			.addProperty("invincibileMotion", &mHRChara::invincibileMotion)
			.addFunction("mGetCharaType", &mHRChara::mGetCharaType)
			.addStaticFunction("isCharacterTypeZako", &mHRChara::isCharacterTypeZako)
			.addFunction("mTestZako", &mHRChara::mTestZako)
			.addStaticFunction("isCharacterTypeBoss", &mHRChara::isCharacterTypeBoss)
			.addFunction("mTestBoss", &mHRChara::mTestBoss)
			.addFunction("mTestEnemy", &mHRChara::mTestEnemy)
			.addFunction("mSetItemNo", &mHRChara::mSetItemNo)
			.addFunction("mSetLockOnNoCheckColl", &mHRChara::mSetLockOnNoCheckColl)
			.addFunction("mSetLockOnDistanceLow", &mHRChara::mSetLockOnDistanceLow)
			.addFunction("mSetLockOnDistanceHi", &mHRChara::mSetLockOnDistanceHi)
			.addFunction("mSetLockOnDistance", &mHRChara::mSetLockOnDistance)
			.addFunction("mSetCanLockOn", &mHRChara::mSetCanLockOn)
			.addFunction("mSetDisableDameged", &mHRChara::mSetDisableDameged)
			.addFunction("mGetDisableDameged", &mHRChara::mGetDisableDameged)
			.addFunction("mGetMaxHp", &mHRChara::mGetMaxHp)
			.addFunction("mUndispTgtIcn", &mHRChara::mUndispTgtIcn)
			.addFunction("mDispTgtIcn", &mHRChara::mDispTgtIcn)
			.addFunction("mGetHp", &mHRChara::mGetHp)
			.addFunction("mGetCondition", &mHRChara::mGetCondition)
			.addFunction("mGetNext", &mHRChara::mGetNext)
			.addFunction("mSetHp", &mHRChara::mSetHp)
			.addStaticFunction("mGetTop", &mHRChara::mGetTop)
			.addFunction("mGetRot", &mHRChara::mGetRot)
			.addFunction("mSetCharaPause", &mHRChara::mSetCharaPause)
			.addFunction("mGetRotY", &mHRChara::mGetRotY)
			.addFunction("GetGroundTouchMaterial", &mHRChara::GetGroundTouchMaterial)
			.addFunction("mGetStatusPtr", &mHRChara::mGetStatusPtr)
			.addFunction("mGetPos", &mHRChara::mGetPos)
			.addFunction("mGetMotionNo", &mHRChara::mGetMotionNo)
			.addFunction("mGetFileName", &mHRChara::mGetFileName)
			.addFunction("IsTubaAngleCorrect", &mHRChara::IsTubaAngleCorrect)
			.addFunction("getMiraretaiPosition", &mHRChara::getMiraretaiPosition)
			.addFunction("isHopeInterestMe", &mHRChara::isHopeInterestMe)
			.addFunction("IsWatchPc", &mHRChara::IsWatchPc)
			.addFunction("IsUseRotMov", &mHRChara::IsUseRotMov)
			.addFunction("getCurMotionName", &mHRChara::getCurMotionName)
			.addFunction("mTestRunMotion", &mHRChara::mTestRunMotion)
			.addFunction("mZakoDieOut", &mHRChara::mZakoDieOut)
			.addFunction("mCreateLoseSight", &mHRChara::mCreateLoseSight)
			.addFunction("mCheckDamageMotion", &mHRChara::mCheckDamageMotion)
			.addFunction("mCheckEnterMotion", &mHRChara::mCheckEnterMotion)
			.addFunction("mpGetGan", &mHRChara::mpGetGan)
			.addFunction("mGetCurResourceGmfPtr", &mHRChara::mGetCurResourceGmfPtr)
			.addFunction("mGetCurResourceGmfPtr_2", &mHRChara::mGetCurResourceGmfPtr_2)
			.addFunction("mGetResourceGmfWepLPtr", &mHRChara::mGetResourceGmfWepLPtr)
			.addFunction("mGetResourceGmfWepRPtr", &mHRChara::mGetResourceGmfWepRPtr)
			.addFunction("mSetResourceGmfPtr", &mHRChara::mSetResourceGmfPtr)
			.addFunction("mGetResourceGmfDeadPtr", &mHRChara::mGetResourceGmfDeadPtr)
			.addFunction("mGetResourceGmfDeadPtr_2", &mHRChara::mGetResourceGmfDeadPtr_2)
			.addFunction("mGetResourceGmfPtr", &mHRChara::mGetResourceGmfPtr)
			.addFunction("mGetResourceGmfPtr_2", &mHRChara::mGetResourceGmfPtr_2)
			.addFunction("mGetCollPtr", &mHRChara::mGetCollPtr)
			.addFunction("mSethitOidashiDisEnable", &mHRChara::mSethitOidashiDisEnable)
			.addFunction("mGetBrainPos", &mHRChara::mGetBrainPos)
			.addFunction("mGetHitPos", &mHRChara::mGetHitPos)
			.addFunction("mGetMirrorModel", &mHRChara::mGetMirrorModel)
			.addFunction("mGetVisibleDist", &mHRChara::mGetVisibleDist)
			.addFunction("mSetCondition", &mHRChara::mSetCondition)
			.addFunction("mSetSubMotionSpd", &mHRChara::mSetSubMotionSpd)
			.addFunction("mCheck4tsunbai", &mHRChara::mCheck4tsunbai)
			.addFunction("mCheckSquat", &mHRChara::mCheckSquat)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetThrowMotNo", &mHRChara::mGetThrowMotNo)
			.addFunction("mGetTsubazeriMotionID", &mHRChara::mGetTsubazeriMotionID)
			.addFunction("mTsubazeriDifficultyClear", &mHRChara::mTsubazeriDifficultyClear)
			.addFunction("mTsubazeriDifficultyUp", &mHRChara::mTsubazeriDifficultyUp)
			.addFunction("IsTubaPosAdjust", &mHRChara::IsTubaPosAdjust)
			.addFunction("mCheckGuard", &mHRChara::mCheckGuard)
			.addFunction("mCheckAttack", &mHRChara::mCheckAttack)
			.addFunction("mSubTension", &mHRChara::mSubTension)
			.addFunction("mAddTension", &mHRChara::mAddTension)
			.addFunction("mSetTension", &mHRChara::mSetTension)
			.addFunction("mResetTension", &mHRChara::mResetTension)
			.addFunction("mSetMovSpd", &mHRChara::mSetMovSpd)
			.addFunction("UnderControllAttack_A", &mHRChara::UnderControllAttack_A)
			.addFunction("UnderControllComboAttack", &mHRChara::UnderControllComboAttack)
			.addFunction("ExitUnderControl", &mHRChara::ExitUnderControl)
			.addFunction("EnterUnderControl", &mHRChara::EnterUnderControl)
			.addFunction("mPostRenderProc", &mHRChara::mPostRenderProc)
			.addFunction("getViewClipBoxPositionOffsetY", &mHRChara::getViewClipBoxPositionOffsetY)
			.addFunction("getViewClipBoxHalfLengthXYZ", &mHRChara::getViewClipBoxHalfLengthXYZ)
			.addFunction("mGetResNo", &mHRChara::mGetResNo)
			.addFunction("mGetDropMoney", &mHRChara::mGetDropMoney)
			.addFunction("mGetItemNo", &mHRChara::mGetItemNo)
			.addFunction("setLocatorNode", &mHRChara::setLocatorNode)
			.addFunction("mGetHpRate", &mHRChara::mGetHpRate)
			.addFunction("mSubHp", &mHRChara::mSubHp)
			.addFunction("mGetHitSize", &mHRChara::mGetHitSize)
			.addFunction("mGetInitProc", &mHRChara::mGetInitProc)
			.addFunction("isCrashBreak", &mHRChara::isCrashBreak)
			.addFunction("mSetCharaHit", &mHRChara::mSetCharaHit)
			.addFunction("mGetDmgAtkMot", &mHRChara::mGetDmgAtkMot)
			.addFunction("mSetMotionProcessDisEnable", &mHRChara::mSetMotionProcessDisEnable)
			.addFunction("mGetMotionSpd", &mHRChara::mGetMotionSpd)
			.addFunction("mSetStageHitDisEnable", &mHRChara::mSetStageHitDisEnable)
			.addFunction("IsFootShadowDraw", &mHRChara::IsFootShadowDraw)
			.addFunction("SetFootShadowDraw", &mHRChara::SetFootShadowDraw)
			.addFunction("mSetMotionNoNpc", &mHRChara::mSetMotionNoNpc)
			.addFunction("mSetCallScriptProc", &mHRChara::mSetCallScriptProc)
			.addFunction("mSetDropMoney", &mHRChara::mSetDropMoney)
			.addFunction("mSetReactionDist", &mHRChara::mSetReactionDist)
			.addFunction("mSetEnterPattern", &mHRChara::mSetEnterPattern)
			.addFunction("mSetDatNo", &mHRChara::mSetDatNo)
			.addFunction("mSetResNo", &mHRChara::mSetResNo)
			.addFunction("mSetCharaType", &mHRChara::mSetCharaType)
			.addFunction("mGetDatNo", &mHRChara::mGetDatNo)
			.addFunction("mGetResourceDeleteFlag", &mHRChara::mGetResourceDeleteFlag)
			.addFunction("mGetDmgUpperPosY", &mHRChara::mGetDmgUpperPosY)
			.addFunction("mGetDmgUpper", &mHRChara::mGetDmgUpper)
			.addFunction("mSetResourceDeleteFlag", &mHRChara::mSetResourceDeleteFlag)
			.addFunction("getLatestGroundTouchPlane", &mHRChara::getLatestGroundTouchPlane)
			.addFunction("mUndispBtlIcn", &mHRChara::mUndispBtlIcn)
			.addFunction("mChgBtlIcnFinishDemo", &mHRChara::mChgBtlIcnFinishDemo)
			.addFunction("mChgBtlIcnTb", &mHRChara::mChgBtlIcnTb)
			.addFunction("mChgBtlIcnFinishDemo_2", &mHRChara::mChgBtlIcnFinishDemo_2)
			.addFunction("SetDrawYAdjust", &mHRChara::SetDrawYAdjust)
			.addFunction("mSetDemoCtrl", &mHRChara::mSetDemoCtrl)
			.addFunction("mGetDemoCtrl", &mHRChara::mGetDemoCtrl)
			.addFunction("isAcceptDistanceDelete", &mHRChara::isAcceptDistanceDelete)
			.addFunction("mSetStageHitDisEnableReq", &mHRChara::mSetStageHitDisEnableReq)
			.addFunction("mGetEffectStPtr", &mHRChara::mGetEffectStPtr)
			.addFunction("setBlackBodyEffect", &mHRChara::setBlackBodyEffect)
			.addFunction("mGetNavelPos", &mHRChara::mGetNavelPos)
			.addFunction("mSetDamageAcceptFrame", &mHRChara::mSetDamageAcceptFrame)
			.addFunction("mSetAlwaysCheckHitColl", &mHRChara::mSetAlwaysCheckHitColl)
			.addFunction("mGetLockOnNoCheckColl", &mHRChara::mGetLockOnNoCheckColl)
			.addFunction("mGetLockOnDistanceLow", &mHRChara::mGetLockOnDistanceLow)
			.addFunction("mGetLockOnDistanceHi", &mHRChara::mGetLockOnDistanceHi)
			.addFunction("mGetLockOnDistance", &mHRChara::mGetLockOnDistance)
			.addFunction("mGetAliveBtlIcn", &mHRChara::mGetAliveBtlIcn)
			.addFunction("mChgBtlIcnFinish", &mHRChara::mChgBtlIcnFinish)
			.addFunction("mChgBtlIcnFinish_2", &mHRChara::mChgBtlIcnFinish_2)
			.addFunction("mSetSlowBlow", &mHRChara::mSetSlowBlow)
			.addFunction("mSetInputFinishReq", &mHRChara::mSetInputFinishReq)
			.addFunction("mGetResourceGanPtr", &mHRChara::mGetResourceGanPtr)
			.addFunction("mGetMoney", &mHRChara::mGetMoney)
			.addFunction("mSetMoney", &mHRChara::mSetMoney)
			.addFunction("mGetInputFinishReq", &mHRChara::mGetInputFinishReq)
			.addFunction("mAddMoney", &mHRChara::mAddMoney)
			.addFunction("mSetInvincibleMotion", &mHRChara::mSetInvincibleMotion)
			.addFunction("mResetInvincibleMotion", &mHRChara::mResetInvincibleMotion)
			.addFunction("mCanGetHitByMotion", &mHRChara::mCanGetHitByMotion)
			.addFunction("mDispAtkHitIcn", &mHRChara::mDispAtkHitIcn)
			.addFunction("mGetDontStandUp", &mHRChara::mGetDontStandUp)
			.addFunction("GetTubaFrmOffset", &mHRChara::GetTubaFrmOffset)
			.addFunction("GetAtkDisAdjust", &mHRChara::GetAtkDisAdjust)
			.addFunction("mGetLoseTsubazeriFlag", &mHRChara::mGetLoseTsubazeriFlag)
			.addFunction("mSetSuccessThrow", &mHRChara::mSetSuccessThrow)
			.addFunction("mSetRotYA", &mHRChara::mSetRotYA)
			.addFunction("mSetDontStandUp", &mHRChara::mSetDontStandUp)
			.addFunction("mSetDmgGrav", &mHRChara::mSetDmgGrav)
			.addFunction("mChgBtlIcnSml", &mHRChara::mChgBtlIcnSml)
			.addFunction("mChgBtlIcnBig", &mHRChara::mChgBtlIcnBig)
			.addFunction("mGetCharaHit", &mHRChara::mGetCharaHit)
			.addFunction("mGetCanLockOn", &mHRChara::mGetCanLockOn)
			.addFunction("mGethitOidashiDisEnable", &mHRChara::mGethitOidashiDisEnable)
			.addFunction("mGetBtlIcnStatus", &mHRChara::mGetBtlIcnStatus)
			.addFunction("mGetWepVisible", &mHRChara::mGetWepVisible)
			.addFunction("mGetMotionBrendNum", &mHRChara::mGetMotionBrendNum)
			.addFunction("mGetAiValue", &mHRChara::mGetAiValue)
			.addFunction("mResetPosA", &mHRChara::mResetPosA)
			.addFunction("getEasyShadowProjectionPlane", &mHRChara::getEasyShadowProjectionPlane)
			.addFunction("isInterestTarget", &mHRChara::isInterestTarget)
			.addFunction("mSetMotionSpd", &mHRChara::mSetMotionSpd)
			.addFunction("mGetWepEffectVisible", &mHRChara::mGetWepEffectVisible)
			.addFunction("mGetVisible", &mHRChara::mGetVisible)
			.addFunction("mGetTension", &mHRChara::mGetTension)
			.addFunction("mGetMiniMapRender", &mHRChara::mGetMiniMapRender)
			.addFunction("mGetResourceRslPtr", &mHRChara::mGetResourceRslPtr)
			.addFunction("getFootNumber", &mHRChara::getFootNumber)
			.addFunction("mGetCallScriptProc", &mHRChara::mGetCallScriptProc)
			.addFunction("mGetMotionProcessDisEnable", &mHRChara::mGetMotionProcessDisEnable)
			.addFunction("IsBloom", &mHRChara::IsBloom)
			.addFunction("SetTermAll", &mHRChara::SetTermAll)
			.addFunction("SetKnockBackSpd", &mHRChara::SetKnockBackSpd)
			.addFunction("GetKnockBackSpd", &mHRChara::GetKnockBackSpd)
			.addFunction("mGetStageHitDisEnable", &mHRChara::mGetStageHitDisEnable)
			.addFunction("mGetStartSplitFlameFlag", &mHRChara::mGetStartSplitFlameFlag)
			.addFunction("getBoneEffectGmf", &mHRChara::getBoneEffectGmf)
			.addFunction("mSetStartSplitFlameFlag", &mHRChara::mSetStartSplitFlameFlag)
			.addFunction("mGetCharaPause", &mHRChara::mGetCharaPause)
			.addFunction("mGetBeforePos", &mHRChara::mGetBeforePos)
			.addFunction("mGetZakoWepType", &mHRChara::mGetZakoWepType)
			// Can't export & pointer 'class ghmGcCollObjHitResultObj&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetFootHitResultObj2", &mHRChara::mSetFootHitResultObj2)
			.addFunction("mSetDmgUpperPow", &mHRChara::mSetDmgUpperPow)
			.addFunction("mAddHp", &mHRChara::mAddHp)
			.addFunction("mGetSubMotionSpd", &mHRChara::mGetSubMotionSpd)
			.addFunction("mSetZakoWepType", &mHRChara::mSetZakoWepType)
			.addFunction("mSetHitSize", &mHRChara::mSetHitSize)
			.addFunction("mGetReactionDist", &mHRChara::mGetReactionDist)
			.addFunction("mSetMiniMapRender", &mHRChara::mSetMiniMapRender)
			.addFunction("GetKnockBackDir", &mHRChara::GetKnockBackDir)
			.addFunction("mGetMotionNoNpc", &mHRChara::mGetMotionNoNpc)
			.addFunction("SetNormalClip", &mHRChara::SetNormalClip)
			.addFunction("mGetOldPos", &mHRChara::mGetOldPos)
			.addFunction("mGetSuccessThrow", &mHRChara::mGetSuccessThrow)
			.addFunction("mSetDmgUpperPosY", &mHRChara::mSetDmgUpperPosY)
			.addFunction("SetDeleteReq", &mHRChara::SetDeleteReq)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("getShootPosiAndYaw", &mHRChara::getShootPosiAndYaw)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("setHomingPositionFromAI", &mHRChara::setHomingPositionFromAI)
			.addFunction("setHomingActFlagFromAI", &mHRChara::setHomingActFlagFromAI)
			.addFunction("isHoming", &mHRChara::isHoming)
			.addFunction("setInterestUseBoneNumFromAI", &mHRChara::setInterestUseBoneNumFromAI)
			.addFunction("isInteresting", &mHRChara::isInteresting)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("addDamageToYuremono", &mHRChara::addDamageToYuremono)
			.addFunction("getBoneEffect", &mHRChara::getBoneEffect)
			.addFunction("mSetHajikiCheck", &mHRChara::mSetHajikiCheck)
			.addFunction("mCheckDamageAccept", &mHRChara::mCheckDamageAccept)
			.addFunction("mTestZakoDown", &mHRChara::mTestZakoDown)
			.addFunction("mTestPiyoRequest", &mHRChara::mTestPiyoRequest)
			.addFunction("mGetPiyoriHeight", &mHRChara::mGetPiyoriHeight)
			.addStaticFunction("mGetCharaPtr", &mHRChara::mGetCharaPtr)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("mRenderGmf", &mHRChara::mRenderGmf)
			.addStaticFunction("debugDispCharaInfo", &mHRChara::debugDispCharaInfo)
			.addStaticFunction("mTermAllZakoMotion", &mHRChara::mTermAllZakoMotion)
			.addStaticFunction("mInitAllNpc", &mHRChara::mInitAllNpc)
			.addFunction("mCreateBloodSplash", &mHRChara::mCreateBloodSplash)
			.addFunction("mBloodSplashProc", &mHRChara::mBloodSplashProc)
			.addFunction("AddBoneElectPtrToList", &mHRChara::AddBoneElectPtrToList)
			.addFunction("ReleaseBoneElect", &mHRChara::ReleaseBoneElect)
			.addFunction("IsEmtpyBoneElectList", &mHRChara::IsEmtpyBoneElectList)
			.addFunction("DeleteBoneElectFromList", &mHRChara::DeleteBoneElectFromList)
			.addFunction("AddCutmarkPtrToList", &mHRChara::AddCutmarkPtrToList)
			.addFunction("IsEmtpyCutmarkList", &mHRChara::IsEmtpyCutmarkList)
			.addFunction("DeleteCutmarkFromList", &mHRChara::DeleteCutmarkFromList)
			.addFunction("SetPowerFlash", &mHRChara::SetPowerFlash)
			.addFunction("SetNoGuardEffect", &mHRChara::SetNoGuardEffect)
			.addStaticFunction("mCheckAtkAllNpc", &mHRChara::mCheckAtkAllNpc)
			.addStaticFunction("mCheckCanAtk", &mHRChara::mCheckCanAtk)
			.addFunction("mCallBeforeRenderProc", &mHRChara::mCallBeforeRenderProc)
			.addFunction("mCheckCanHit", &mHRChara::mCheckCanHit)
			.addFunction("CreateFootSmokeEffect", &mHRChara::CreateFootSmokeEffect)
			.addFunction("KnockBackProc", &mHRChara::KnockBackProc)
			.addFunction("GetKnockBackRatio", &mHRChara::GetKnockBackRatio)
			.addFunction("mSetDamage", &mHRChara::mSetDamage)
			.addFunction("mInitDamageMotInfo", &mHRChara::mInitDamageMotInfo)
			.addFunction("mChangeDefAi", &mHRChara::mChangeDefAi)
			.addFunction("mSetDefAI", &mHRChara::mSetDefAI)
			.addFunction("mCheckCallFrameProc", &mHRChara::mCheckCallFrameProc)
			.addFunction("IsNowUnderControl", &mHRChara::IsNowUnderControl)
			.addFunction("RegistUnderControlAtkFuncPtr", &mHRChara::RegistUnderControlAtkFuncPtr)
			// Can't export & pointer 'struct CharControlMotID&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("RegistUnderControlMotID", &mHRChara::RegistUnderControlMotID)
			.addFunction("SetUnderControlFlag", &mHRChara::SetUnderControlFlag)
			.addFunction("DrawDebugCollision", &mHRChara::DrawDebugCollision)
			.addFunction("mRenderProc", &mHRChara::mRenderProc)
			.addFunction("postSetupMatrix", &mHRChara::postSetupMatrix)
			.addFunction("preSetupMatrix", &mHRChara::preSetupMatrix)
			.addFunction("mFootSmokeEffect", &mHRChara::mFootSmokeEffect)
			.addFunction("mPosAnimationProc", &mHRChara::mPosAnimationProc)
			.addFunction("mPostFrameProc", &mHRChara::mPostFrameProc)
			.addFunction("mFrameProc", &mHRChara::mFrameProc)
			.addFunction("mInit", &mHRChara::mInit)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetRotA", &mHRChara::mSetRotA)
			.addFunction("mSetWepEffectVisibleInstant", &mHRChara::mSetWepEffectVisibleInstant)
			.addFunction("mSubFrameStop", &mHRChara::mSubFrameStop)
			.addFunction("mPlayMotionMov", &mHRChara::mPlayMotionMov)
			.addFunction("mTestMotion", &mHRChara::mTestMotion)
			.addFunction("mSetDifficultyMotionSpeed", &mHRChara::mSetDifficultyMotionSpeed)
			.addStaticFunction("getCharaByGM2FileName", &mHRChara::getCharaByGM2FileName)
			.addFunction("mSetDeath", &mHRChara::mSetDeath)
			.addFunction("mDamageCallBackForScript", &mHRChara::mDamageCallBackForScript)
			.addFunction("mGetMotionPlay", &mHRChara::mGetMotionPlay)
			.addStaticFunction("mGetAliveResourceCharaPtr", &mHRChara::mGetAliveResourceCharaPtr)
			.addFunction("ReleaseCutmark", &mHRChara::ReleaseCutmark)
			.addFunction("mTestPiyori", &mHRChara::mTestPiyori)
			.addFunction("mGetMotionTotalTick", &mHRChara::mGetMotionTotalTick)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("setInterestPositionFromAI", &mHRChara::setInterestPositionFromAI)
			.addFunction("setInterestActFlagFromAI", &mHRChara::setInterestActFlagFromAI)
			.addFunction("mGetWepTopPos", &mHRChara::mGetWepTopPos)
			.addFunction("mInitDamageStatus", &mHRChara::mInitDamageStatus)
			.addFunction("mPostFrameCommonProc1", &mHRChara::mPostFrameCommonProc1)
			.addFunction("mPostFrameCommonProc2", &mHRChara::mPostFrameCommonProc2)
			.addFunction("getBoneEffectDamageData", &mHRChara::getBoneEffectDamageData)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetKnockBack", &mHRChara::SetKnockBack)
			.addFunction("CheckWallCrashAndDamageProc", &mHRChara::CheckWallCrashAndDamageProc)
			.addFunction("mSetHpBarVisible", &mHRChara::mSetHpBarVisible)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetPosA", &mHRChara::mSetPosA)
			.addFunction("mSetSimpleHpBarVisible", &mHRChara::mSetSimpleHpBarVisible)
			.addFunction("mPlayCamMotFromCharMot", &mHRChara::mPlayCamMotFromCharMot)
			.addFunction("mPlayMotionMov_2", &mHRChara::mPlayMotionMov_2)
			.addFunction("checkDeleteBlackBodyEffect", &mHRChara::checkDeleteBlackBodyEffect)
			.addFunction("mSetHitCounter", &mHRChara::mSetHitCounter)
			.addFunction("mReleaseBloodSplash", &mHRChara::mReleaseBloodSplash)
			.addFunction("mPreFrameProc", &mHRChara::mPreFrameProc)
			.addFunction("mPreRenderProc", &mHRChara::mPreRenderProc)
			.addFunction("mDetouchMotionBrend", &mHRChara::mDetouchMotionBrend)
			.addFunction("mReleaseDemoBtleIcn", &mHRChara::mReleaseDemoBtleIcn)
			.addStaticFunction("isThisCharaExist", &mHRChara::isThisCharaExist)
			.addStaticFunction("mTermAllNpc", &mHRChara::mTermAllNpc)
			.addStaticFunction("mGetPopZakoNum", &mHRChara::mGetPopZakoNum)
			.addFunction("mDeleteDispChara", &mHRChara::mDeleteDispChara)
			.addFunction("mSetAiDef", &mHRChara::mSetAiDef)
			.addFunction("setFootShadowDrawFlag", &mHRChara::setFootShadowDrawFlag)
			.addStaticFunction("mFrameProcAll", &mHRChara::mFrameProcAll)
			.addStaticFunction("mRenderProcAll", &mHRChara::mRenderProcAll)
			.addStaticFunction("mPostRenderProcAll", &mHRChara::mPostRenderProcAll)
			.addStaticFunction("mTermAllNpcWithoutCmnObj", &mHRChara::mTermAllNpcWithoutCmnObj)
			.addStaticFunction("mTermAllEnemyNpc", &mHRChara::mTermAllEnemyNpc)
			.addStaticFunction("mGetNpcTop", &mHRChara::mGetNpcTop)
			.addFunction("SetFileName", &mHRChara::SetFileName)
			.addFunction("mSetMaxHp", &mHRChara::mSetMaxHp)
			.addFunction("mTerm", &mHRChara::mTerm)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetPos", &mHRChara::mSetPos)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetRot", &mHRChara::mSetRot)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetScale", &mHRChara::mSetScale)
			.addFunction("mHitCheck", &mHRChara::mHitCheck)
			.addFunction("mMotionSpeedControl", &mHRChara::mMotionSpeedControl)
			.addFunction("mCallMotionProc", &mHRChara::mCallMotionProc)
			.addFunction("mPlayMotion", &mHRChara::mPlayMotion)
			.addFunction("mCallMoneyDrop", &mHRChara::mCallMoneyDrop)
			.addFunction("mAttachWep", &mHRChara::mAttachWep)
			.addFunction("mDetachWep", &mHRChara::mDetachWep)
			.addFunction("mSemitransparentProcess", &mHRChara::mSemitransparentProcess)
			.addFunction("mUpdateAtkColl", &mHRChara::mUpdateAtkColl)
			.addFunction("mRenderShadowProc", &mHRChara::mRenderShadowProc)
			.addFunction("mRefreshFloorPosition", &mHRChara::mRefreshFloorPosition)
			.addFunction("mDamageProc", &mHRChara::mDamageProc)
			.addFunction("mRestoreDamage", &mHRChara::mRestoreDamage)
			.addFunction("mCheckAttack_2", &mHRChara::mCheckAttack_2)
			.addFunction("mCheckCanAttack", &mHRChara::mCheckCanAttack)
			.addFunction("mGetTsubazeriaiPos", &mHRChara::mGetTsubazeriaiPos)
			.addFunction("mSetPcTsubaOuterMot", &mHRChara::mSetPcTsubaOuterMot)
			.addFunction("GetTsubaEffectPos", &mHRChara::GetTsubaEffectPos)
			.addFunction("mCheckCanCatch", &mHRChara::mCheckCanCatch)
			.addFunction("mCheckCanThrow", &mHRChara::mCheckCanThrow)
			.addFunction("mPlayThrownMotion", &mHRChara::mPlayThrownMotion)
			// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mPlayMotionBlend", &mHRChara::mPlayMotionBlend)
			.addFunction("mPlayMotionBlend_2", &mHRChara::mPlayMotionBlend_2)
			.addFunction("mBossDeadCommonProcess", &mHRChara::mBossDeadCommonProcess)
			.addFunction("mCheckCanLockOn", &mHRChara::mCheckCanLockOn)
			.addFunction("getLockOnCursorBasePosition", &mHRChara::getLockOnCursorBasePosition)
			.addFunction("mSetVisible", &mHRChara::mSetVisible)
			.addFunction("mSetWepVisible", &mHRChara::mSetWepVisible)
			.addFunction("mSetWepEffectVisible", &mHRChara::mSetWepEffectVisible)
			.addFunction("mSetVisibleDist", &mHRChara::mSetVisibleDist)
			.addFunction("mEffectInit", &mHRChara::mEffectInit)
			.addFunction("mSetMirrorModel", &mHRChara::mSetMirrorModel)
			.addFunction("mSetAiAtk", &mHRChara::mSetAiAtk)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetWarpPos", &mHRChara::mSetWarpPos)
			// Can't export functions with more than 11 parameters to LuaBridge.
			//.addFunction("mHitCheckStage", &mHRChara::mHitCheckStage)
			.addFunction("mpGetGan_2", &mHRChara::mpGetGan_2)
			.addFunction("mppGetGan", &mHRChara::mppGetGan)
			.addFunction("mRequestBloodSplash", &mHRChara::mRequestBloodSplash)
			.addFunction("mCallKillPcProcess", &mHRChara::mCallKillPcProcess)
			.addFunction("mCheckComboing", &mHRChara::mCheckComboing)
			.addFunction("mGetAttackTableValue", &mHRChara::mGetAttackTableValue)
			.addFunction("mGetAttackDirection", &mHRChara::mGetAttackDirection)
			.addFunction("mTestLowDmg", &mHRChara::mTestLowDmg)
			.addFunction("mCreatePiyori", &mHRChara::mCreatePiyori)
			.addFunction("mTermPiyori", &mHRChara::mTermPiyori)
			.addFunction("mPiyoriProc", &mHRChara::mPiyoriProc)
			.addFunction("mSetDamageAcceptFrame_2", &mHRChara::mSetDamageAcceptFrame_2)
			.addFunction("IsMultiStep", &mHRChara::IsMultiStep)
			.addFunction("IsDownAttack", &mHRChara::IsDownAttack)
			.addFunction("getFootShadowWidthHalf", &mHRChara::getFootShadowWidthHalf)
			.addFunction("getFootShadowDepthPlus", &mHRChara::getFootShadowDepthPlus)
			.addFunction("getFootShadowDepthMinus", &mHRChara::getFootShadowDepthMinus)
			.addFunction("OnStageUnload", &mHRChara::OnStageUnload)
			.addFunction("setFootGroundTouchActFlagFromAI", &mHRChara::setFootGroundTouchActFlagFromAI)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mPlayCamMot", &mHRChara::mPlayCamMot)
			.addFunction("mStopCamMotFromCharMot", &mHRChara::mStopCamMotFromCharMot)
			.addStaticFunction("mRenderShadowProcAll", &mHRChara::mRenderShadowProcAll)
			.addFunction("mSetRotY", &mHRChara::mSetRotY)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mCheckSegmentHitStage", &mHRChara::mCheckSegmentHitStage)
			.addFunction("mEraseDispChara", &mHRChara::mEraseDispChara)
			.addStaticFunction("mGetCharaPtr_2", &mHRChara::mGetCharaPtr_2)
			.addStaticFunction("mAllSearchPiyoZako", &mHRChara::mAllSearchPiyoZako)
			.addStaticFunction("OnStageUnloadAll", &mHRChara::OnStageUnloadAll)
			.addFunction("AsZako", &mHRChara::AsZako)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRChara::mStatus) == 924, "expected mHRChara::mStatus to be size 924");
static_assert(sizeof(mHRChara::mResource) == 56, "expected mHRChara::mResource to be size 56");
static_assert(sizeof(mHRChara::mEffect) == 292, "expected mHRChara::mEffect to be size 292");
static_assert(sizeof(mHRChara::m_inAmbientShadow) == 56, "expected mHRChara::m_inAmbientShadow to be size 56");
static_assert(sizeof(mHRChara::m_ainFootShadow) == 12, "expected mHRChara::m_ainFootShadow to be size 12");
static_assert(sizeof(mHRChara::mInitProc) == 4, "expected mHRChara::mInitProc to be size 4");
static_assert(sizeof(mHRChara::m_pCharController) == 4, "expected mHRChara::m_pCharController to be size 4");
static_assert(sizeof(mHRChara::mWepColl) == 36, "expected mHRChara::mWepColl to be size 36");
static_assert(sizeof(mHRChara::motionInvincibilityFrames) == 4, "expected mHRChara::motionInvincibilityFrames to be size 4");
static_assert(sizeof(mHRChara::invincibileMotion) == 4, "expected mHRChara::invincibileMotion to be size 4");
static_assert(sizeof(mHRChara) == 0x580, "expected mHRChara to be size 0x580");

// [Structure] class HROBJDummy
class HROBJDummy : public mHRChara
{
public:
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HROBJDummy [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HROBJDummy& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HROBJDummy, mHRChara>("HROBJDummy")
			.addFunction("__tostring", &HROBJDummy::ToString)
			.addFunction("GetPtrAddr", &HROBJDummy::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(HROBJDummy) == 0x580, "expected HROBJDummy to be size 0x580");

// [Structure] struct stTiger
struct stTiger
{
public:
	/// Struct member variables

	// <uint8_t visible, offset 0x0>
	uint8_t visible = 0;

	// <Unidentified data segment, offset 0x1>
private:
	char _UnidentifiedData_1[3];

public:
	// <class TGmf* pGmf, offset 0x4>
	class TGmf* pGmf = nullptr;

	// <class TGan* pGan[0x8], offset 0x8>
	class TGan* pGan[8];

	// <int32_t motNo, offset 0x28>
	int32_t motNo = 0;

	// <char const* motName, offset 0x2c>
	char const* motName = nullptr;

	// <uint8_t dispPc, offset 0x30>
	uint8_t dispPc = 0;

	// <uint8_t dispTiger, offset 0x31>
	uint8_t dispTiger = 0;

	// <Unidentified data segment, offset 0x32>
private:
	char _UnidentifiedData_50[2];

public:
	// <struct Vec startPos, offset 0x34>
	struct Vec startPos;

	// <class CStlVector<CStickShadow> m_ainFootShadow, offset 0x40>
	class std::vector<CStickShadow> m_ainFootShadow;

	// <int32_t endFadeTick, offset 0x4c>
	int32_t endFadeTick = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stTiger [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stTiger& InObject)
	{
		visible = InObject.visible;
		pGmf = InObject.pGmf;
		motNo = InObject.motNo;
		motName = InObject.motName;
		dispPc = InObject.dispPc;
		dispTiger = InObject.dispTiger;
		startPos = InObject.startPos;
		m_ainFootShadow = InObject.m_ainFootShadow;
		endFadeTick = InObject.endFadeTick;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stTiger>("stTiger")
			.addFunction("__tostring", &stTiger::ToString)
			.addFunction("GetPtrAddr", &stTiger::GetPtrAddr)
			.addProperty("visible", &stTiger::visible)
			.addProperty("pGmf", &stTiger::pGmf)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pGan", &stTiger::pGan)
			.addProperty("motNo", &stTiger::motNo)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("motName", &stTiger::motName)
			.addProperty("dispPc", &stTiger::dispPc)
			.addProperty("dispTiger", &stTiger::dispTiger)
			.addProperty("startPos", &stTiger::startPos)
			.addProperty("m_ainFootShadow", &stTiger::m_ainFootShadow)
			.addProperty("endFadeTick", &stTiger::endFadeTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(stTiger::visible) == 1, "expected stTiger::visible to be size 1");
static_assert(sizeof(stTiger::pGmf) == 4, "expected stTiger::pGmf to be size 4");
static_assert(sizeof(stTiger::pGan) == 32, "expected stTiger::pGan to be size 32");
static_assert(sizeof(stTiger::motNo) == 4, "expected stTiger::motNo to be size 4");
static_assert(sizeof(stTiger::motName) == 4, "expected stTiger::motName to be size 4");
static_assert(sizeof(stTiger::dispPc) == 1, "expected stTiger::dispPc to be size 1");
static_assert(sizeof(stTiger::dispTiger) == 1, "expected stTiger::dispTiger to be size 1");
static_assert(sizeof(stTiger::startPos) == 12, "expected stTiger::startPos to be size 12");
static_assert(sizeof(stTiger::m_ainFootShadow) == 12, "expected stTiger::m_ainFootShadow to be size 12");
static_assert(sizeof(stTiger::endFadeTick) == 4, "expected stTiger::endFadeTick to be size 4");
static_assert(sizeof(stTiger) == 0x50, "expected stTiger to be size 0x50");

// [Structure] struct stHugWalk
struct stHugWalk
{
public:
	/// Struct member variables

	// <class TGmf* pGmf, offset 0x0>
	class TGmf* pGmf = nullptr;

	// <class TGan* pGan[0x6], offset 0x4>
	class TGan* pGan[6];

	// <int32_t motNo, offset 0x1c>
	int32_t motNo = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stHugWalk [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stHugWalk& InObject)
	{
		pGmf = InObject.pGmf;
		motNo = InObject.motNo;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stHugWalk>("stHugWalk")
			.addFunction("__tostring", &stHugWalk::ToString)
			.addFunction("GetPtrAddr", &stHugWalk::GetPtrAddr)
			.addProperty("pGmf", &stHugWalk::pGmf)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pGan", &stHugWalk::pGan)
			.addProperty("motNo", &stHugWalk::motNo)
		.endClass();
	}
#endif
};
static_assert(sizeof(stHugWalk::pGmf) == 4, "expected stHugWalk::pGmf to be size 4");
static_assert(sizeof(stHugWalk::pGan) == 24, "expected stHugWalk::pGan to be size 24");
static_assert(sizeof(stHugWalk::motNo) == 4, "expected stHugWalk::motNo to be size 4");
static_assert(sizeof(stHugWalk) == 0x20, "expected stHugWalk to be size 0x20");

// [Structure] struct stPcEffect
struct stPcEffect
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[12];

public:
	// <class EffectCloseContest* CloseContest, offset 0xc>
	class EffectCloseContest* CloseContest = nullptr;

	// <Unidentified data segment, offset 0x10>
private:
	char _UnidentifiedData_16[400];

public:
	// <void* WeaponStruct1, offset 0x1a0>
	void* WeaponStruct1 = nullptr;

	// <void* WeaponStruct2, offset 0x1a4>
	void* WeaponStruct2 = nullptr;

	// <void* WeaponStruct3, offset 0x1a8>
	void* WeaponStruct3 = nullptr;

	// <void* WeaponStruct4, offset 0x1ac>
	void* WeaponStruct4 = nullptr;

	// <void* WeaponStruct5, offset 0x1b0>
	void* WeaponStruct5 = nullptr;

	// <Unidentified data segment, offset 0x1b4>
private:
	char _UnidentifiedData_436[220];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stPcEffect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stPcEffect& InObject)
	{
		CloseContest = InObject.CloseContest;
		WeaponStruct1 = InObject.WeaponStruct1;
		WeaponStruct2 = InObject.WeaponStruct2;
		WeaponStruct3 = InObject.WeaponStruct3;
		WeaponStruct4 = InObject.WeaponStruct4;
		WeaponStruct5 = InObject.WeaponStruct5;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcEffect>("stPcEffect")
			.addFunction("__tostring", &stPcEffect::ToString)
			.addFunction("GetPtrAddr", &stPcEffect::GetPtrAddr)
			.addProperty("CloseContest", &stPcEffect::CloseContest)
			// void type not supported in LuaBridge
			//.addProperty("WeaponStruct1", &stPcEffect::WeaponStruct1)
			// void type not supported in LuaBridge
			//.addProperty("WeaponStruct2", &stPcEffect::WeaponStruct2)
			// void type not supported in LuaBridge
			//.addProperty("WeaponStruct3", &stPcEffect::WeaponStruct3)
			// void type not supported in LuaBridge
			//.addProperty("WeaponStruct4", &stPcEffect::WeaponStruct4)
			// void type not supported in LuaBridge
			//.addProperty("WeaponStruct5", &stPcEffect::WeaponStruct5)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcEffect::CloseContest) == 4, "expected stPcEffect::CloseContest to be size 4");
static_assert(sizeof(stPcEffect::WeaponStruct1) == 4, "expected stPcEffect::WeaponStruct1 to be size 4");
static_assert(sizeof(stPcEffect::WeaponStruct2) == 4, "expected stPcEffect::WeaponStruct2 to be size 4");
static_assert(sizeof(stPcEffect::WeaponStruct3) == 4, "expected stPcEffect::WeaponStruct3 to be size 4");
static_assert(sizeof(stPcEffect::WeaponStruct4) == 4, "expected stPcEffect::WeaponStruct4 to be size 4");
static_assert(sizeof(stPcEffect::WeaponStruct5) == 4, "expected stPcEffect::WeaponStruct5 to be size 4");
static_assert(sizeof(stPcEffect) == 0x290, "expected stPcEffect to be size 0x290");

// enum enPcInputMode
enum enPcInputMode : uint32_t
{
	// <ePcInputIdle = 0x0>
	ePcInputIdle = 0,

	// <ePcInputCamera = 0x1>
	ePcInputCamera = 1,

	// <ePcInputMove = 0x2>
	ePcInputMove = 2,

	// <ePcInputBattleMove = 0x3>
	ePcInputBattleMove = 3,

	// <ePcInputBattleIdle = 0x4>
	ePcInputBattleIdle = 4,

	// <ePcInputBike = 0x5>
	ePcInputBike = 5,

	// <ePcInputMenu = 0x6>
	ePcInputMenu = 6,

	// <ePcInputDamage = 0x7>
	ePcInputDamage = 7,

	// <ePcInputTiger = 0x8>
	ePcInputTiger = 8,

	// <ePcInputJump = 0x9>
	ePcInputJump = 9,

	// <ePcInputDash = 0xa>
	ePcInputDash = 10,

	// <ePcInputDigHole = 0xb>
	ePcInputDigHole = 11,

	// <ePcInputWepChange = 0xc>
	ePcInputWepChange = 12,

	// <ePcInputDeadFukki = 0xd>
	ePcInputDeadFukki = 13,

	// <ePcInputMax = 0xe>
	ePcInputMax = 14

};

// enum enSeReadProc
enum enSeReadProc : uint32_t
{
	// <eSeRead = 0x0>
	eSeRead = 0,

	// <eSeReadWait = 0x1>
	eSeReadWait = 1,

	// <eSeReadMax = 0x2>
	eSeReadMax = 2

};

// [Structure] struct stPcSndData
struct stPcSndData
{
public:
	/// Struct member variables

	// <int32_t seHdlLightsavorReady, offset 0x0>
	int32_t seHdlLightsavorReady = 0;

	// <float seVolLightsavorReady, offset 0x4>
	float seVolLightsavorReady = 0;

	// <uint8_t seDontPlaySeAgainLSReady, offset 0x8>
	uint8_t seDontPlaySeAgainLSReady = 0;

	// <Unidentified data segment, offset 0x9>
private:
	char _UnidentifiedData_9[3];

public:
	// <int32_t seHdlSlow, offset 0xc>
	int32_t seHdlSlow = 0;

	// <float oldBgmVol, offset 0x10>
	float oldBgmVol = 0;

	// <int32_t oldBgmHdl, offset 0x14>
	int32_t oldBgmHdl = 0;

	// <int32_t oldBgmNo, offset 0x18>
	int32_t oldBgmNo = 0;

	// <int32_t nowBgmHdl, offset 0x1c>
	int32_t nowBgmHdl = 0;

	// <enum enSeReadProc seReadProc, offset 0x20>
	enum enSeReadProc seReadProc;

	// <class WAnimF pitchBgm, offset 0x24>
	class WAnimF pitchBgm;

	// <uint32_t oldFinishBgmVol, offset 0x44>
	uint32_t oldFinishBgmVol = 0;

	// <uint32_t oldFinishSeVol, offset 0x48>
	uint32_t oldFinishSeVol = 0;

	// <int32_t seHdlCharge, offset 0x4c>
	int32_t seHdlCharge = 0;

	// <class WAnimF pitchCharge, offset 0x50>
	class WAnimF pitchCharge;

	// <int32_t seHdlChargeMax, offset 0x70>
	int32_t seHdlChargeMax = 0;

	// <class WAnimF pitchChargeMax, offset 0x74>
	class WAnimF pitchChargeMax;

	// <int32_t seHdlAlarm, offset 0x94>
	int32_t seHdlAlarm = 0;

	// <int32_t seHdlTel, offset 0x98>
	int32_t seHdlTel = 0;

	// <int32_t seHdlDsBreath, offset 0x9c>
	int32_t seHdlDsBreath = 0;

	// <int32_t seHdlTsubazeri, offset 0xa0>
	int32_t seHdlTsubazeri = 0;

	// <int32_t seHdlSNBElecDmg, offset 0xa4>
	int32_t seHdlSNBElecDmg = 0;

	// <int32_t seHdlPoison, offset 0xa8>
	int32_t seHdlPoison = 0;

	// <uint8_t playBackAttackSe, offset 0xac>
	uint8_t playBackAttackSe = 0;

	// <uint8_t playBackAttackPullSe, offset 0xad>
	uint8_t playBackAttackPullSe = 0;

	// <Unidentified data segment, offset 0xae>
private:
	char _UnidentifiedData_174[2];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stPcSndData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stPcSndData& InObject)
	{
		seHdlLightsavorReady = InObject.seHdlLightsavorReady;
		seVolLightsavorReady = InObject.seVolLightsavorReady;
		seDontPlaySeAgainLSReady = InObject.seDontPlaySeAgainLSReady;
		seHdlSlow = InObject.seHdlSlow;
		oldBgmVol = InObject.oldBgmVol;
		oldBgmHdl = InObject.oldBgmHdl;
		oldBgmNo = InObject.oldBgmNo;
		nowBgmHdl = InObject.nowBgmHdl;
		seReadProc = InObject.seReadProc;
		pitchBgm = InObject.pitchBgm;
		oldFinishBgmVol = InObject.oldFinishBgmVol;
		oldFinishSeVol = InObject.oldFinishSeVol;
		seHdlCharge = InObject.seHdlCharge;
		pitchCharge = InObject.pitchCharge;
		seHdlChargeMax = InObject.seHdlChargeMax;
		pitchChargeMax = InObject.pitchChargeMax;
		seHdlAlarm = InObject.seHdlAlarm;
		seHdlTel = InObject.seHdlTel;
		seHdlDsBreath = InObject.seHdlDsBreath;
		seHdlTsubazeri = InObject.seHdlTsubazeri;
		seHdlSNBElecDmg = InObject.seHdlSNBElecDmg;
		seHdlPoison = InObject.seHdlPoison;
		playBackAttackSe = InObject.playBackAttackSe;
		playBackAttackPullSe = InObject.playBackAttackPullSe;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcSndData>("stPcSndData")
			.addFunction("__tostring", &stPcSndData::ToString)
			.addFunction("GetPtrAddr", &stPcSndData::GetPtrAddr)
			.addProperty("seHdlLightsavorReady", &stPcSndData::seHdlLightsavorReady)
			.addProperty("seVolLightsavorReady", &stPcSndData::seVolLightsavorReady)
			.addProperty("seDontPlaySeAgainLSReady", &stPcSndData::seDontPlaySeAgainLSReady)
			.addProperty("seHdlSlow", &stPcSndData::seHdlSlow)
			.addProperty("oldBgmVol", &stPcSndData::oldBgmVol)
			.addProperty("oldBgmHdl", &stPcSndData::oldBgmHdl)
			.addProperty("oldBgmNo", &stPcSndData::oldBgmNo)
			.addProperty("nowBgmHdl", &stPcSndData::nowBgmHdl)
			.addProperty("seReadProc", &stPcSndData::seReadProc)
			.addProperty("pitchBgm", &stPcSndData::pitchBgm)
			.addProperty("oldFinishBgmVol", &stPcSndData::oldFinishBgmVol)
			.addProperty("oldFinishSeVol", &stPcSndData::oldFinishSeVol)
			.addProperty("seHdlCharge", &stPcSndData::seHdlCharge)
			.addProperty("pitchCharge", &stPcSndData::pitchCharge)
			.addProperty("seHdlChargeMax", &stPcSndData::seHdlChargeMax)
			.addProperty("pitchChargeMax", &stPcSndData::pitchChargeMax)
			.addProperty("seHdlAlarm", &stPcSndData::seHdlAlarm)
			.addProperty("seHdlTel", &stPcSndData::seHdlTel)
			.addProperty("seHdlDsBreath", &stPcSndData::seHdlDsBreath)
			.addProperty("seHdlTsubazeri", &stPcSndData::seHdlTsubazeri)
			.addProperty("seHdlSNBElecDmg", &stPcSndData::seHdlSNBElecDmg)
			.addProperty("seHdlPoison", &stPcSndData::seHdlPoison)
			.addProperty("playBackAttackSe", &stPcSndData::playBackAttackSe)
			.addProperty("playBackAttackPullSe", &stPcSndData::playBackAttackPullSe)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcSndData::seHdlLightsavorReady) == 4, "expected stPcSndData::seHdlLightsavorReady to be size 4");
static_assert(sizeof(stPcSndData::seVolLightsavorReady) == 4, "expected stPcSndData::seVolLightsavorReady to be size 4");
static_assert(sizeof(stPcSndData::seDontPlaySeAgainLSReady) == 1, "expected stPcSndData::seDontPlaySeAgainLSReady to be size 1");
static_assert(sizeof(stPcSndData::seHdlSlow) == 4, "expected stPcSndData::seHdlSlow to be size 4");
static_assert(sizeof(stPcSndData::oldBgmVol) == 4, "expected stPcSndData::oldBgmVol to be size 4");
static_assert(sizeof(stPcSndData::oldBgmHdl) == 4, "expected stPcSndData::oldBgmHdl to be size 4");
static_assert(sizeof(stPcSndData::oldBgmNo) == 4, "expected stPcSndData::oldBgmNo to be size 4");
static_assert(sizeof(stPcSndData::nowBgmHdl) == 4, "expected stPcSndData::nowBgmHdl to be size 4");
static_assert(sizeof(stPcSndData::seReadProc) == 4, "expected stPcSndData::seReadProc to be size 4");
static_assert(sizeof(stPcSndData::pitchBgm) == 32, "expected stPcSndData::pitchBgm to be size 32");
static_assert(sizeof(stPcSndData::oldFinishBgmVol) == 4, "expected stPcSndData::oldFinishBgmVol to be size 4");
static_assert(sizeof(stPcSndData::oldFinishSeVol) == 4, "expected stPcSndData::oldFinishSeVol to be size 4");
static_assert(sizeof(stPcSndData::seHdlCharge) == 4, "expected stPcSndData::seHdlCharge to be size 4");
static_assert(sizeof(stPcSndData::pitchCharge) == 32, "expected stPcSndData::pitchCharge to be size 32");
static_assert(sizeof(stPcSndData::seHdlChargeMax) == 4, "expected stPcSndData::seHdlChargeMax to be size 4");
static_assert(sizeof(stPcSndData::pitchChargeMax) == 32, "expected stPcSndData::pitchChargeMax to be size 32");
static_assert(sizeof(stPcSndData::seHdlAlarm) == 4, "expected stPcSndData::seHdlAlarm to be size 4");
static_assert(sizeof(stPcSndData::seHdlTel) == 4, "expected stPcSndData::seHdlTel to be size 4");
static_assert(sizeof(stPcSndData::seHdlDsBreath) == 4, "expected stPcSndData::seHdlDsBreath to be size 4");
static_assert(sizeof(stPcSndData::seHdlTsubazeri) == 4, "expected stPcSndData::seHdlTsubazeri to be size 4");
static_assert(sizeof(stPcSndData::seHdlSNBElecDmg) == 4, "expected stPcSndData::seHdlSNBElecDmg to be size 4");
static_assert(sizeof(stPcSndData::seHdlPoison) == 4, "expected stPcSndData::seHdlPoison to be size 4");
static_assert(sizeof(stPcSndData::playBackAttackSe) == 1, "expected stPcSndData::playBackAttackSe to be size 1");
static_assert(sizeof(stPcSndData::playBackAttackPullSe) == 1, "expected stPcSndData::playBackAttackPullSe to be size 1");
static_assert(sizeof(stPcSndData) == 0xb0, "expected stPcSndData to be size 0xb0");

// [Structure] struct stDarkSideInfo
struct stDarkSideInfo
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[4];

public:
	// <uint8_t TestBullet, offset 0x4>
	uint8_t TestBullet = 0;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	// <uint8_t TestFire, offset 0x8>
	uint8_t TestFire = 0;

	// <Unidentified data segment, offset 0x9>
private:
	char _UnidentifiedData_9[43];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stDarkSideInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stDarkSideInfo& InObject)
	{
		TestBullet = InObject.TestBullet;
		TestFire = InObject.TestFire;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stDarkSideInfo>("stDarkSideInfo")
			.addFunction("__tostring", &stDarkSideInfo::ToString)
			.addFunction("GetPtrAddr", &stDarkSideInfo::GetPtrAddr)
			.addProperty("TestBullet", &stDarkSideInfo::TestBullet)
			.addProperty("TestFire", &stDarkSideInfo::TestFire)
		.endClass();
	}
#endif
};
static_assert(sizeof(stDarkSideInfo::TestBullet) == 1, "expected stDarkSideInfo::TestBullet to be size 1");
static_assert(sizeof(stDarkSideInfo::TestFire) == 1, "expected stDarkSideInfo::TestFire to be size 1");
static_assert(sizeof(stDarkSideInfo) == 0x34, "expected stDarkSideInfo to be size 0x34");

// [Structure] struct stMiniDemo
struct stMiniDemo
{
public:
	/// Struct member variables

	// <uint8_t play, offset 0x0>
	uint8_t play = 0;

	// <uint8_t pauseStart, offset 0x1>
	uint8_t pauseStart = 0;

	// <uint8_t fadeInPermission, offset 0x2>
	uint8_t fadeInPermission = 0;

	// <Unidentified data segment, offset 0x3>
private:
	char _UnidentifiedData_3[1];

public:
	// <int32_t warpWaitFrame, offset 0x4>
	int32_t warpWaitFrame = 0;

	// <int32_t warpTargetIndex, offset 0x8>
	int32_t warpTargetIndex = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stMiniDemo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stMiniDemo& InObject)
	{
		play = InObject.play;
		pauseStart = InObject.pauseStart;
		fadeInPermission = InObject.fadeInPermission;
		warpWaitFrame = InObject.warpWaitFrame;
		warpTargetIndex = InObject.warpTargetIndex;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stMiniDemo>("stMiniDemo")
			.addFunction("__tostring", &stMiniDemo::ToString)
			.addFunction("GetPtrAddr", &stMiniDemo::GetPtrAddr)
			.addProperty("play", &stMiniDemo::play)
			.addProperty("pauseStart", &stMiniDemo::pauseStart)
			.addProperty("fadeInPermission", &stMiniDemo::fadeInPermission)
			.addProperty("warpWaitFrame", &stMiniDemo::warpWaitFrame)
			.addProperty("warpTargetIndex", &stMiniDemo::warpTargetIndex)
		.endClass();
	}
#endif
};
static_assert(sizeof(stMiniDemo::play) == 1, "expected stMiniDemo::play to be size 1");
static_assert(sizeof(stMiniDemo::pauseStart) == 1, "expected stMiniDemo::pauseStart to be size 1");
static_assert(sizeof(stMiniDemo::fadeInPermission) == 1, "expected stMiniDemo::fadeInPermission to be size 1");
static_assert(sizeof(stMiniDemo::warpWaitFrame) == 4, "expected stMiniDemo::warpWaitFrame to be size 4");
static_assert(sizeof(stMiniDemo::warpTargetIndex) == 4, "expected stMiniDemo::warpTargetIndex to be size 4");
static_assert(sizeof(stMiniDemo) == 0xc, "expected stMiniDemo to be size 0xc");

// enum enPcCmbKind
enum enPcCmbKind : uint32_t
{
	// <ePcAtkFghtCmbUp = 0x0>
	ePcAtkFghtCmbUp = 0,

	// <ePcAtkFghtCmbDw = 0x1>
	ePcAtkFghtCmbDw = 1,

	// <ePcAtkCmb01Up = 0x2>
	ePcAtkCmb01Up = 2,

	// <ePcAtkCmb01Btm = 0x3>
	ePcAtkCmb01Btm = 3,

	// <ePcAtkCmb02Up = 0x4>
	ePcAtkCmb02Up = 4,

	// <ePcAtkCmb02Btm = 0x5>
	ePcAtkCmb02Btm = 5,

	// <ePcAtkCmb03Up = 0x6>
	ePcAtkCmb03Up = 6,

	// <ePcAtkCmb03Btm = 0x7>
	ePcAtkCmb03Btm = 7,

	// <ePcAtkCmb04Up = 0x8>
	ePcAtkCmb04Up = 8,

	// <ePcAtkCmb04Btm = 0x9>
	ePcAtkCmb04Btm = 9,

	// <ePcAtkCmb01Dncng = 0xa>
	ePcAtkCmb01Dncng = 10,

	// <ePcAtkCmb02Dncng = 0xb>
	ePcAtkCmb02Dncng = 11,

	// <ePcAtkCmb03Dncng = 0xc>
	ePcAtkCmb03Dncng = 12,

	// <ePcAtkCmb04Dncng = 0xd>
	ePcAtkCmb04Dncng = 13,

	// <eSNBAtkCmb01Up = 0xe>
	eSNBAtkCmb01Up = 14,

	// <eSNBAtkCmb01Btm = 0xf>
	eSNBAtkCmb01Btm = 15,

	// <eHENAtkCmb01Up = 0x10>
	eHENAtkCmb01Up = 16,

	// <eHENAtkCmb01Btm = 0x11>
	eHENAtkCmb01Btm = 17,

	// <ePcAtkCmbKindMax = 0x12>
	ePcAtkCmbKindMax = 18

};

// [Structure] struct stPcStatus
struct stPcStatus
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[12];

public:
	// <int32_t UnknownAtkMot, offset 0xc>
	int32_t UnknownAtkMot = 0;

	// <Unidentified data segment, offset 0x10>
private:
	char _UnidentifiedData_16[24];

public:
	// <class TGmf* MotionTGmf, offset 0x28>
	class TGmf* MotionTGmf = nullptr;

	// <Unidentified data segment, offset 0x2c>
private:
	char _UnidentifiedData_44[20];

public:
	// <int32_t EqWepID, offset 0x40>
	int32_t EqWepID = 0;

	// <Unidentified data segment, offset 0x44>
private:
	char _UnidentifiedData_68[260];

public:
	// <struct tagGHMR_TEX* EquipTexPtr, offset 0x148>
	struct tagGHMR_TEX* EquipTexPtr = nullptr;

	// <Unidentified data segment, offset 0x14c>
private:
	char _UnidentifiedData_332[276];

public:
	// <uint32_t WeaponID, offset 0x260>
	uint32_t WeaponID = 0;

	// <Unidentified data segment, offset 0x264>
private:
	char _UnidentifiedData_612[20];

public:
	// <int32_t WeaponID1, offset 0x278>
	int32_t WeaponID1 = 0;

	// <int16_t CurBattery1, offset 0x27c>
	int16_t CurBattery1 = 0;

	// <int16_t MaxBattery1, offset 0x27e>
	int16_t MaxBattery1 = 0;

	// <Unidentified data segment, offset 0x280>
private:
	char _UnidentifiedData_640[4];

public:
	// <uint8_t CmbExtend1, offset 0x284>
	uint8_t CmbExtend1 = 0;

	// <Unidentified data segment, offset 0x285>
private:
	char _UnidentifiedData_645[3];

public:
	// <int32_t WeaponID2, offset 0x288>
	int32_t WeaponID2 = 0;

	// <int16_t CurBattery2, offset 0x28c>
	int16_t CurBattery2 = 0;

	// <int16_t MaxBattery2, offset 0x28e>
	int16_t MaxBattery2 = 0;

	// <Unidentified data segment, offset 0x290>
private:
	char _UnidentifiedData_656[4];

public:
	// <uint8_t CmbExtend2, offset 0x294>
	uint8_t CmbExtend2 = 0;

	// <Unidentified data segment, offset 0x295>
private:
	char _UnidentifiedData_661[3];

public:
	// <int32_t WeaponID3, offset 0x298>
	int32_t WeaponID3 = 0;

	// <int16_t CurBattery3, offset 0x29c>
	int16_t CurBattery3 = 0;

	// <int16_t MaxBattery3, offset 0x29e>
	int16_t MaxBattery3 = 0;

	// <Unidentified data segment, offset 0x2a0>
private:
	char _UnidentifiedData_672[4];

public:
	// <uint8_t CmbExtend3, offset 0x2a4>
	uint8_t CmbExtend3 = 0;

	// <Unidentified data segment, offset 0x2a5>
private:
	char _UnidentifiedData_677[3];

public:
	// <int32_t WeaponID4, offset 0x2a8>
	int32_t WeaponID4 = 0;

	// <int16_t CurBattery4, offset 0x2ac>
	int16_t CurBattery4 = 0;

	// <int16_t MaxBattery4, offset 0x2ae>
	int16_t MaxBattery4 = 0;

	// <Unidentified data segment, offset 0x2b0>
private:
	char _UnidentifiedData_688[4];

public:
	// <uint8_t CmbExtend4, offset 0x2b4>
	uint8_t CmbExtend4 = 0;

	// <Unidentified data segment, offset 0x2b5>
private:
	char _UnidentifiedData_693[3];

public:
	// <void* UnknownWeaponPtr, offset 0x2b8>
	void* UnknownWeaponPtr = nullptr;

	// <Unidentified data segment, offset 0x2bc>
private:
	char _UnidentifiedData_700[824];

public:
	// <int32_t CurMoney, offset 0x5f4>
	int32_t CurMoney = 0;

	// <int32_t MaxMoney, offset 0x5f8>
	int32_t MaxMoney = 0;

	// <Unidentified data segment, offset 0x5fc>
private:
	char _UnidentifiedData_1532[140];

public:
	// <enum enPcCmbKind CmbKind, offset 0x688>
	enum enPcCmbKind CmbKind;

	// <Unidentified data segment, offset 0x68c>
private:
	char _UnidentifiedData_1676[41];

public:
	// <char FinishNpcNum, offset 0x6b5>
	char FinishNpcNum;

	// <Unidentified data segment, offset 0x6b6>
private:
	char _UnidentifiedData_1718[95];

public:
	// <uint8_t AtkMode, offset 0x715>
	uint8_t AtkMode = 0;

	// <bool EqWepLaser, offset 0x716>
	bool EqWepLaser;

	// <Unidentified data segment, offset 0x717>
private:
	char _UnidentifiedData_1815[9];

public:
	// <uint8_t TsubaDisEnable, offset 0x720>
	uint8_t TsubaDisEnable = 0;

	// <Unidentified data segment, offset 0x721>
private:
	char _UnidentifiedData_1825[6];

public:
	// <bool ElectroShockWalk, offset 0x727>
	bool ElectroShockWalk;

	// <bool HugWalk, offset 0x728>
	bool HugWalk;

	// <Unidentified data segment, offset 0x729>
private:
	char _UnidentifiedData_1833[3];

public:
	// <bool AlwaysEmptyBattery, offset 0x72c>
	bool AlwaysEmptyBattery;

	// <bool CantChargeBattery, offset 0x72d>
	bool CantChargeBattery;

	// <Unidentified data segment, offset 0x72e>
private:
	char _UnidentifiedData_1838[3];

public:
	// <byte WeaponEquipFlag, offset 0x731>
	byte WeaponEquipFlag;

	// <Unidentified data segment, offset 0x732>
private:
	char _UnidentifiedData_1842[4];

public:
	// <bool CantCallBikeFlag, offset 0x736>
	bool CantCallBikeFlag;

	// <Unidentified data segment, offset 0x737>
private:
	char _UnidentifiedData_1847[3];

public:
	// <bool LostBikeFlag, offset 0x73a>
	bool LostBikeFlag;

	// <char BikeVisible, offset 0x73b>
	char BikeVisible;

	// <Unidentified data segment, offset 0x73c>
private:
	char _UnidentifiedData_1852[20];

public:
	// <int32_t SwingCount, offset 0x750>
	int32_t SwingCount = 0;

	// <Unidentified data segment, offset 0x754>
private:
	char _UnidentifiedData_1876[52];

public:
	// <uint8_t PuppetMode, offset 0x788>
	uint8_t PuppetMode = 0;

	// <uint8_t UseWeaponEffect, offset 0x789>
	uint8_t UseWeaponEffect = 0;

	// <Unidentified data segment, offset 0x78a>
private:
	char _UnidentifiedData_1930[122];

public:
	// <bool BanSlotCry, offset 0x804>
	bool BanSlotCry;

	// <bool BanSlotBel, offset 0x805>
	bool BanSlotBel;

	// <bool BanSlotBar, offset 0x806>
	bool BanSlotBar;

	// <bool BanSlot777, offset 0x807>
	bool BanSlot777;

	// <bool BanRollEscape, offset 0x808>
	bool BanRollEscape;

	// <bool BanJump, offset 0x809>
	bool BanJump;

	// <bool BanDeadFukki, offset 0x80a>
	bool BanDeadFukki;

	// <bool BanJustGuard, offset 0x80b>
	bool BanJustGuard;

	// <bool BanWinTsubazeri, offset 0x80c>
	bool BanWinTsubazeri;

	// <uint8_t WepStick, offset 0x80d>
	uint8_t WepStick = 0;

	// <Unidentified data segment, offset 0x80e>
private:
	char _UnidentifiedData_2062[62];

public:
	// <uint32_t DeadBossNum, offset 0x84c>
	uint32_t DeadBossNum = 0;

	// <Unidentified data segment, offset 0x850>
private:
	char _UnidentifiedData_2128[16];

public:
	// <bool DontSubBattery, offset 0x860>
	bool DontSubBattery;

	// <bool AutoSubBatteryDisEnable, offset 0x861>
	bool AutoSubBatteryDisEnable;

	// <Unidentified data segment, offset 0x862>
private:
	char _UnidentifiedData_2146[2];

public:
	// <bool DontRestoreMotion, offset 0x864>
	bool DontRestoreMotion;

	// <uint8_t BikeClash2battou, offset 0x865>
	uint8_t BikeClash2battou = 0;

	// <Unidentified data segment, offset 0x866>
private:
	char _UnidentifiedData_2150[10];

public:
	// <bool JustGuardDisEnable, offset 0x870>
	bool JustGuardDisEnable;

	// <Unidentified data segment, offset 0x871>
private:
	char _UnidentifiedData_2161[1];

public:
	// <uint8_t DashAtkExec, offset 0x872>
	uint8_t DashAtkExec = 0;

	// <bool JustEscapeDisEnable, offset 0x873>
	bool JustEscapeDisEnable;

	// <Unidentified data segment, offset 0x874>
private:
	char _UnidentifiedData_2164[36];

public:
	// <bool BanPiyori, offset 0x898>
	bool BanPiyori;

	// <Unidentified data segment, offset 0x899>
private:
	char _UnidentifiedData_2201[7];

public:
	// <uint8_t CancelSetPadOffset, offset 0x8a0>
	uint8_t CancelSetPadOffset = 0;

	// <Unidentified data segment, offset 0x8a1>
private:
	char _UnidentifiedData_2209[3];

public:
	// <float UnknownAttackRotationYaw, offset 0x8a4>
	float UnknownAttackRotationYaw = 0;

	// <Unidentified data segment, offset 0x8a8>
private:
	char _UnidentifiedData_2216[60];

public:
	// <uint8_t ChangeEquipFromScript, offset 0x8e4>
	uint8_t ChangeEquipFromScript = 0;

	// <bool NoBatteryThrow, offset 0x8e5>
	bool NoBatteryThrow;

	// <uint8_t ChangeWeaponEffectVisible, offset 0x8e6>
	uint8_t ChangeWeaponEffectVisible = 0;

	// <uint8_t LockOnNockDown, offset 0x8e7>
	uint8_t LockOnNockDown = 0;

	// <uint8_t AttackHajiki, offset 0x8e8>
	uint8_t AttackHajiki = 0;

	// <uint8_t DontPlayLoseTsubazeriMotion, offset 0x8e9>
	uint8_t DontPlayLoseTsubazeriMotion = 0;

	// <Unidentified data segment, offset 0x8ea>
private:
	char _UnidentifiedData_2282[6];

public:
	// <bool NoWearJacket, offset 0x8f0>
	bool NoWearJacket;

	// <Unidentified data segment, offset 0x8f1>
private:
	char _UnidentifiedData_2289[7];

public:
	// <bool DispChangeWeaponIcon, offset 0x8f8>
	bool DispChangeWeaponIcon;

	// <uint8_t StandUpAttack, offset 0x8f9>
	uint8_t StandUpAttack = 0;

	// <bool PushingBatteryChargeButton, offset 0x8fa>
	bool PushingBatteryChargeButton;

	// <uint8_t HitBigConsumeBattertAttack, offset 0x8fb>
	uint8_t HitBigConsumeBattertAttack = 0;

	// <Unidentified data segment, offset 0x8fc>
private:
	char _UnidentifiedData_2300[4];

public:
	// <uint8_t StartThrowSlow, offset 0x900>
	uint8_t StartThrowSlow = 0;

	// <uint8_t ForceLoseTsubazeri, offset 0x901>
	uint8_t ForceLoseTsubazeri = 0;

	// <Unidentified data segment, offset 0x902>
private:
	char _UnidentifiedData_2306[2];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stPcStatus [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stPcStatus& InObject)
	{
		UnknownAtkMot = InObject.UnknownAtkMot;
		MotionTGmf = InObject.MotionTGmf;
		EqWepID = InObject.EqWepID;
		EquipTexPtr = InObject.EquipTexPtr;
		WeaponID = InObject.WeaponID;
		WeaponID1 = InObject.WeaponID1;
		CurBattery1 = InObject.CurBattery1;
		MaxBattery1 = InObject.MaxBattery1;
		CmbExtend1 = InObject.CmbExtend1;
		WeaponID2 = InObject.WeaponID2;
		CurBattery2 = InObject.CurBattery2;
		MaxBattery2 = InObject.MaxBattery2;
		CmbExtend2 = InObject.CmbExtend2;
		WeaponID3 = InObject.WeaponID3;
		CurBattery3 = InObject.CurBattery3;
		MaxBattery3 = InObject.MaxBattery3;
		CmbExtend3 = InObject.CmbExtend3;
		WeaponID4 = InObject.WeaponID4;
		CurBattery4 = InObject.CurBattery4;
		MaxBattery4 = InObject.MaxBattery4;
		CmbExtend4 = InObject.CmbExtend4;
		UnknownWeaponPtr = InObject.UnknownWeaponPtr;
		CurMoney = InObject.CurMoney;
		MaxMoney = InObject.MaxMoney;
		CmbKind = InObject.CmbKind;
		FinishNpcNum = InObject.FinishNpcNum;
		AtkMode = InObject.AtkMode;
		EqWepLaser = InObject.EqWepLaser;
		TsubaDisEnable = InObject.TsubaDisEnable;
		ElectroShockWalk = InObject.ElectroShockWalk;
		HugWalk = InObject.HugWalk;
		AlwaysEmptyBattery = InObject.AlwaysEmptyBattery;
		CantChargeBattery = InObject.CantChargeBattery;
		WeaponEquipFlag = InObject.WeaponEquipFlag;
		CantCallBikeFlag = InObject.CantCallBikeFlag;
		LostBikeFlag = InObject.LostBikeFlag;
		BikeVisible = InObject.BikeVisible;
		SwingCount = InObject.SwingCount;
		PuppetMode = InObject.PuppetMode;
		UseWeaponEffect = InObject.UseWeaponEffect;
		BanSlotCry = InObject.BanSlotCry;
		BanSlotBel = InObject.BanSlotBel;
		BanSlotBar = InObject.BanSlotBar;
		BanSlot777 = InObject.BanSlot777;
		BanRollEscape = InObject.BanRollEscape;
		BanJump = InObject.BanJump;
		BanDeadFukki = InObject.BanDeadFukki;
		BanJustGuard = InObject.BanJustGuard;
		BanWinTsubazeri = InObject.BanWinTsubazeri;
		WepStick = InObject.WepStick;
		DeadBossNum = InObject.DeadBossNum;
		DontSubBattery = InObject.DontSubBattery;
		AutoSubBatteryDisEnable = InObject.AutoSubBatteryDisEnable;
		DontRestoreMotion = InObject.DontRestoreMotion;
		BikeClash2battou = InObject.BikeClash2battou;
		JustGuardDisEnable = InObject.JustGuardDisEnable;
		DashAtkExec = InObject.DashAtkExec;
		JustEscapeDisEnable = InObject.JustEscapeDisEnable;
		BanPiyori = InObject.BanPiyori;
		CancelSetPadOffset = InObject.CancelSetPadOffset;
		UnknownAttackRotationYaw = InObject.UnknownAttackRotationYaw;
		ChangeEquipFromScript = InObject.ChangeEquipFromScript;
		NoBatteryThrow = InObject.NoBatteryThrow;
		ChangeWeaponEffectVisible = InObject.ChangeWeaponEffectVisible;
		LockOnNockDown = InObject.LockOnNockDown;
		AttackHajiki = InObject.AttackHajiki;
		DontPlayLoseTsubazeriMotion = InObject.DontPlayLoseTsubazeriMotion;
		NoWearJacket = InObject.NoWearJacket;
		DispChangeWeaponIcon = InObject.DispChangeWeaponIcon;
		StandUpAttack = InObject.StandUpAttack;
		PushingBatteryChargeButton = InObject.PushingBatteryChargeButton;
		HitBigConsumeBattertAttack = InObject.HitBigConsumeBattertAttack;
		StartThrowSlow = InObject.StartThrowSlow;
		ForceLoseTsubazeri = InObject.ForceLoseTsubazeri;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcStatus>("stPcStatus")
			.addFunction("__tostring", &stPcStatus::ToString)
			.addFunction("GetPtrAddr", &stPcStatus::GetPtrAddr)
			.addProperty("UnknownAtkMot", &stPcStatus::UnknownAtkMot)
			.addProperty("MotionTGmf", &stPcStatus::MotionTGmf)
			.addProperty("EqWepID", &stPcStatus::EqWepID)
			.addProperty("EquipTexPtr", &stPcStatus::EquipTexPtr)
			.addProperty("WeaponID", &stPcStatus::WeaponID)
			.addProperty("WeaponID1", &stPcStatus::WeaponID1)
			.addProperty("CurBattery1", &stPcStatus::CurBattery1)
			.addProperty("MaxBattery1", &stPcStatus::MaxBattery1)
			.addProperty("CmbExtend1", &stPcStatus::CmbExtend1)
			.addProperty("WeaponID2", &stPcStatus::WeaponID2)
			.addProperty("CurBattery2", &stPcStatus::CurBattery2)
			.addProperty("MaxBattery2", &stPcStatus::MaxBattery2)
			.addProperty("CmbExtend2", &stPcStatus::CmbExtend2)
			.addProperty("WeaponID3", &stPcStatus::WeaponID3)
			.addProperty("CurBattery3", &stPcStatus::CurBattery3)
			.addProperty("MaxBattery3", &stPcStatus::MaxBattery3)
			.addProperty("CmbExtend3", &stPcStatus::CmbExtend3)
			.addProperty("WeaponID4", &stPcStatus::WeaponID4)
			.addProperty("CurBattery4", &stPcStatus::CurBattery4)
			.addProperty("MaxBattery4", &stPcStatus::MaxBattery4)
			.addProperty("CmbExtend4", &stPcStatus::CmbExtend4)
			// void type not supported in LuaBridge
			//.addProperty("UnknownWeaponPtr", &stPcStatus::UnknownWeaponPtr)
			.addProperty("CurMoney", &stPcStatus::CurMoney)
			.addProperty("MaxMoney", &stPcStatus::MaxMoney)
			.addProperty("CmbKind", &stPcStatus::CmbKind)
			.addProperty("FinishNpcNum", &stPcStatus::FinishNpcNum)
			.addProperty("AtkMode", &stPcStatus::AtkMode)
			.addProperty("EqWepLaser", &stPcStatus::EqWepLaser)
			.addProperty("TsubaDisEnable", &stPcStatus::TsubaDisEnable)
			.addProperty("ElectroShockWalk", &stPcStatus::ElectroShockWalk)
			.addProperty("HugWalk", &stPcStatus::HugWalk)
			.addProperty("AlwaysEmptyBattery", &stPcStatus::AlwaysEmptyBattery)
			.addProperty("CantChargeBattery", &stPcStatus::CantChargeBattery)
			.addProperty("WeaponEquipFlag", &stPcStatus::WeaponEquipFlag)
			.addProperty("CantCallBikeFlag", &stPcStatus::CantCallBikeFlag)
			.addProperty("LostBikeFlag", &stPcStatus::LostBikeFlag)
			.addProperty("BikeVisible", &stPcStatus::BikeVisible)
			.addProperty("SwingCount", &stPcStatus::SwingCount)
			.addProperty("PuppetMode", &stPcStatus::PuppetMode)
			.addProperty("UseWeaponEffect", &stPcStatus::UseWeaponEffect)
			.addProperty("BanSlotCry", &stPcStatus::BanSlotCry)
			.addProperty("BanSlotBel", &stPcStatus::BanSlotBel)
			.addProperty("BanSlotBar", &stPcStatus::BanSlotBar)
			.addProperty("BanSlot777", &stPcStatus::BanSlot777)
			.addProperty("BanRollEscape", &stPcStatus::BanRollEscape)
			.addProperty("BanJump", &stPcStatus::BanJump)
			.addProperty("BanDeadFukki", &stPcStatus::BanDeadFukki)
			.addProperty("BanJustGuard", &stPcStatus::BanJustGuard)
			.addProperty("BanWinTsubazeri", &stPcStatus::BanWinTsubazeri)
			.addProperty("WepStick", &stPcStatus::WepStick)
			.addProperty("DeadBossNum", &stPcStatus::DeadBossNum)
			.addProperty("DontSubBattery", &stPcStatus::DontSubBattery)
			.addProperty("AutoSubBatteryDisEnable", &stPcStatus::AutoSubBatteryDisEnable)
			.addProperty("DontRestoreMotion", &stPcStatus::DontRestoreMotion)
			.addProperty("BikeClash2battou", &stPcStatus::BikeClash2battou)
			.addProperty("JustGuardDisEnable", &stPcStatus::JustGuardDisEnable)
			.addProperty("DashAtkExec", &stPcStatus::DashAtkExec)
			.addProperty("JustEscapeDisEnable", &stPcStatus::JustEscapeDisEnable)
			.addProperty("BanPiyori", &stPcStatus::BanPiyori)
			.addProperty("CancelSetPadOffset", &stPcStatus::CancelSetPadOffset)
			.addProperty("UnknownAttackRotationYaw", &stPcStatus::UnknownAttackRotationYaw)
			.addProperty("ChangeEquipFromScript", &stPcStatus::ChangeEquipFromScript)
			.addProperty("NoBatteryThrow", &stPcStatus::NoBatteryThrow)
			.addProperty("ChangeWeaponEffectVisible", &stPcStatus::ChangeWeaponEffectVisible)
			.addProperty("LockOnNockDown", &stPcStatus::LockOnNockDown)
			.addProperty("AttackHajiki", &stPcStatus::AttackHajiki)
			.addProperty("DontPlayLoseTsubazeriMotion", &stPcStatus::DontPlayLoseTsubazeriMotion)
			.addProperty("NoWearJacket", &stPcStatus::NoWearJacket)
			.addProperty("DispChangeWeaponIcon", &stPcStatus::DispChangeWeaponIcon)
			.addProperty("StandUpAttack", &stPcStatus::StandUpAttack)
			.addProperty("PushingBatteryChargeButton", &stPcStatus::PushingBatteryChargeButton)
			.addProperty("HitBigConsumeBattertAttack", &stPcStatus::HitBigConsumeBattertAttack)
			.addProperty("StartThrowSlow", &stPcStatus::StartThrowSlow)
			.addProperty("ForceLoseTsubazeri", &stPcStatus::ForceLoseTsubazeri)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcStatus::UnknownAtkMot) == 4, "expected stPcStatus::UnknownAtkMot to be size 4");
static_assert(sizeof(stPcStatus::MotionTGmf) == 4, "expected stPcStatus::MotionTGmf to be size 4");
static_assert(sizeof(stPcStatus::EqWepID) == 4, "expected stPcStatus::EqWepID to be size 4");
static_assert(sizeof(stPcStatus::EquipTexPtr) == 4, "expected stPcStatus::EquipTexPtr to be size 4");
static_assert(sizeof(stPcStatus::WeaponID) == 4, "expected stPcStatus::WeaponID to be size 4");
static_assert(sizeof(stPcStatus::WeaponID1) == 4, "expected stPcStatus::WeaponID1 to be size 4");
static_assert(sizeof(stPcStatus::CurBattery1) == 2, "expected stPcStatus::CurBattery1 to be size 2");
static_assert(sizeof(stPcStatus::MaxBattery1) == 2, "expected stPcStatus::MaxBattery1 to be size 2");
static_assert(sizeof(stPcStatus::CmbExtend1) == 1, "expected stPcStatus::CmbExtend1 to be size 1");
static_assert(sizeof(stPcStatus::WeaponID2) == 4, "expected stPcStatus::WeaponID2 to be size 4");
static_assert(sizeof(stPcStatus::CurBattery2) == 2, "expected stPcStatus::CurBattery2 to be size 2");
static_assert(sizeof(stPcStatus::MaxBattery2) == 2, "expected stPcStatus::MaxBattery2 to be size 2");
static_assert(sizeof(stPcStatus::CmbExtend2) == 1, "expected stPcStatus::CmbExtend2 to be size 1");
static_assert(sizeof(stPcStatus::WeaponID3) == 4, "expected stPcStatus::WeaponID3 to be size 4");
static_assert(sizeof(stPcStatus::CurBattery3) == 2, "expected stPcStatus::CurBattery3 to be size 2");
static_assert(sizeof(stPcStatus::MaxBattery3) == 2, "expected stPcStatus::MaxBattery3 to be size 2");
static_assert(sizeof(stPcStatus::CmbExtend3) == 1, "expected stPcStatus::CmbExtend3 to be size 1");
static_assert(sizeof(stPcStatus::WeaponID4) == 4, "expected stPcStatus::WeaponID4 to be size 4");
static_assert(sizeof(stPcStatus::CurBattery4) == 2, "expected stPcStatus::CurBattery4 to be size 2");
static_assert(sizeof(stPcStatus::MaxBattery4) == 2, "expected stPcStatus::MaxBattery4 to be size 2");
static_assert(sizeof(stPcStatus::CmbExtend4) == 1, "expected stPcStatus::CmbExtend4 to be size 1");
static_assert(sizeof(stPcStatus::UnknownWeaponPtr) == 4, "expected stPcStatus::UnknownWeaponPtr to be size 4");
static_assert(sizeof(stPcStatus::CurMoney) == 4, "expected stPcStatus::CurMoney to be size 4");
static_assert(sizeof(stPcStatus::MaxMoney) == 4, "expected stPcStatus::MaxMoney to be size 4");
static_assert(sizeof(stPcStatus::CmbKind) == 4, "expected stPcStatus::CmbKind to be size 4");
static_assert(sizeof(stPcStatus::FinishNpcNum) == 1, "expected stPcStatus::FinishNpcNum to be size 1");
static_assert(sizeof(stPcStatus::AtkMode) == 1, "expected stPcStatus::AtkMode to be size 1");
static_assert(sizeof(stPcStatus::EqWepLaser) == 1, "expected stPcStatus::EqWepLaser to be size 1");
static_assert(sizeof(stPcStatus::TsubaDisEnable) == 1, "expected stPcStatus::TsubaDisEnable to be size 1");
static_assert(sizeof(stPcStatus::ElectroShockWalk) == 1, "expected stPcStatus::ElectroShockWalk to be size 1");
static_assert(sizeof(stPcStatus::HugWalk) == 1, "expected stPcStatus::HugWalk to be size 1");
static_assert(sizeof(stPcStatus::AlwaysEmptyBattery) == 1, "expected stPcStatus::AlwaysEmptyBattery to be size 1");
static_assert(sizeof(stPcStatus::CantChargeBattery) == 1, "expected stPcStatus::CantChargeBattery to be size 1");
static_assert(sizeof(stPcStatus::WeaponEquipFlag) == 1, "expected stPcStatus::WeaponEquipFlag to be size 1");
static_assert(sizeof(stPcStatus::CantCallBikeFlag) == 1, "expected stPcStatus::CantCallBikeFlag to be size 1");
static_assert(sizeof(stPcStatus::LostBikeFlag) == 1, "expected stPcStatus::LostBikeFlag to be size 1");
static_assert(sizeof(stPcStatus::BikeVisible) == 1, "expected stPcStatus::BikeVisible to be size 1");
static_assert(sizeof(stPcStatus::SwingCount) == 4, "expected stPcStatus::SwingCount to be size 4");
static_assert(sizeof(stPcStatus::PuppetMode) == 1, "expected stPcStatus::PuppetMode to be size 1");
static_assert(sizeof(stPcStatus::UseWeaponEffect) == 1, "expected stPcStatus::UseWeaponEffect to be size 1");
static_assert(sizeof(stPcStatus::BanSlotCry) == 1, "expected stPcStatus::BanSlotCry to be size 1");
static_assert(sizeof(stPcStatus::BanSlotBel) == 1, "expected stPcStatus::BanSlotBel to be size 1");
static_assert(sizeof(stPcStatus::BanSlotBar) == 1, "expected stPcStatus::BanSlotBar to be size 1");
static_assert(sizeof(stPcStatus::BanSlot777) == 1, "expected stPcStatus::BanSlot777 to be size 1");
static_assert(sizeof(stPcStatus::BanRollEscape) == 1, "expected stPcStatus::BanRollEscape to be size 1");
static_assert(sizeof(stPcStatus::BanJump) == 1, "expected stPcStatus::BanJump to be size 1");
static_assert(sizeof(stPcStatus::BanDeadFukki) == 1, "expected stPcStatus::BanDeadFukki to be size 1");
static_assert(sizeof(stPcStatus::BanJustGuard) == 1, "expected stPcStatus::BanJustGuard to be size 1");
static_assert(sizeof(stPcStatus::BanWinTsubazeri) == 1, "expected stPcStatus::BanWinTsubazeri to be size 1");
static_assert(sizeof(stPcStatus::WepStick) == 1, "expected stPcStatus::WepStick to be size 1");
static_assert(sizeof(stPcStatus::DeadBossNum) == 4, "expected stPcStatus::DeadBossNum to be size 4");
static_assert(sizeof(stPcStatus::DontSubBattery) == 1, "expected stPcStatus::DontSubBattery to be size 1");
static_assert(sizeof(stPcStatus::AutoSubBatteryDisEnable) == 1, "expected stPcStatus::AutoSubBatteryDisEnable to be size 1");
static_assert(sizeof(stPcStatus::DontRestoreMotion) == 1, "expected stPcStatus::DontRestoreMotion to be size 1");
static_assert(sizeof(stPcStatus::BikeClash2battou) == 1, "expected stPcStatus::BikeClash2battou to be size 1");
static_assert(sizeof(stPcStatus::JustGuardDisEnable) == 1, "expected stPcStatus::JustGuardDisEnable to be size 1");
static_assert(sizeof(stPcStatus::DashAtkExec) == 1, "expected stPcStatus::DashAtkExec to be size 1");
static_assert(sizeof(stPcStatus::JustEscapeDisEnable) == 1, "expected stPcStatus::JustEscapeDisEnable to be size 1");
static_assert(sizeof(stPcStatus::BanPiyori) == 1, "expected stPcStatus::BanPiyori to be size 1");
static_assert(sizeof(stPcStatus::CancelSetPadOffset) == 1, "expected stPcStatus::CancelSetPadOffset to be size 1");
static_assert(sizeof(stPcStatus::UnknownAttackRotationYaw) == 4, "expected stPcStatus::UnknownAttackRotationYaw to be size 4");
static_assert(sizeof(stPcStatus::ChangeEquipFromScript) == 1, "expected stPcStatus::ChangeEquipFromScript to be size 1");
static_assert(sizeof(stPcStatus::NoBatteryThrow) == 1, "expected stPcStatus::NoBatteryThrow to be size 1");
static_assert(sizeof(stPcStatus::ChangeWeaponEffectVisible) == 1, "expected stPcStatus::ChangeWeaponEffectVisible to be size 1");
static_assert(sizeof(stPcStatus::LockOnNockDown) == 1, "expected stPcStatus::LockOnNockDown to be size 1");
static_assert(sizeof(stPcStatus::AttackHajiki) == 1, "expected stPcStatus::AttackHajiki to be size 1");
static_assert(sizeof(stPcStatus::DontPlayLoseTsubazeriMotion) == 1, "expected stPcStatus::DontPlayLoseTsubazeriMotion to be size 1");
static_assert(sizeof(stPcStatus::NoWearJacket) == 1, "expected stPcStatus::NoWearJacket to be size 1");
static_assert(sizeof(stPcStatus::DispChangeWeaponIcon) == 1, "expected stPcStatus::DispChangeWeaponIcon to be size 1");
static_assert(sizeof(stPcStatus::StandUpAttack) == 1, "expected stPcStatus::StandUpAttack to be size 1");
static_assert(sizeof(stPcStatus::PushingBatteryChargeButton) == 1, "expected stPcStatus::PushingBatteryChargeButton to be size 1");
static_assert(sizeof(stPcStatus::HitBigConsumeBattertAttack) == 1, "expected stPcStatus::HitBigConsumeBattertAttack to be size 1");
static_assert(sizeof(stPcStatus::StartThrowSlow) == 1, "expected stPcStatus::StartThrowSlow to be size 1");
static_assert(sizeof(stPcStatus::ForceLoseTsubazeri) == 1, "expected stPcStatus::ForceLoseTsubazeri to be size 1");
static_assert(sizeof(stPcStatus) == 0x904, "expected stPcStatus to be size 0x904");

// [Structure] class mHRPc
/// <summary>
/// Player character (Travis)
/// </summary>
class mHRPc : public mHRChara
{
public:
	/// Struct member variables

	// <class mHRChara Super, offset 0x0>
	// class mHRChara Super;

	// <int32_t mEscapeActionInit, offset 0x580>
	int32_t mEscapeActionInit = 0;

	// <struct stPcStatus mPcStatus, offset 0x584>
	struct stPcStatus mPcStatus;

	// <struct stMiniDemo mMiniDemo, offset 0xe88>
	struct stMiniDemo mMiniDemo;

	// <struct stPcSaveData mPcSaveData, offset 0xe94>
	struct stPcSaveData mPcSaveData;

	// <struct stDarkSideInfo mDarkSideInfo, offset 0x14f8>
	struct stDarkSideInfo mDarkSideInfo;

	// <class mHRBike* mpBike, offset 0x152c>
	class mHRBike* mpBike = nullptr;

	// <struct stPcSndData mSnd, offset 0x1530>
	struct stPcSndData mSnd;

	// <enum enPcInputMode mInputMode, offset 0x15e0>
	enum enPcInputMode mInputMode;

	// <enum enPcInputMode mInputModeOld, offset 0x15e4>
	enum enPcInputMode mInputModeOld;

	// <enum enPcInputMode mInputModeBefore, offset 0x15e8>
	enum enPcInputMode mInputModeBefore;

	// <uint8_t mPauseAll, offset 0x15ec>
	uint8_t mPauseAll = 0;

	// <uint8_t mPauseNpc, offset 0x15ed>
	uint8_t mPauseNpc = 0;

	// <uint8_t mOperate, offset 0x15ee>
	uint8_t mOperate = 0;

	// <uint8_t mOnlyMove, offset 0x15ef>
	uint8_t mOnlyMove = 0;

	// <uint8_t mMotSpdAdj, offset 0x15f0>
	uint8_t mMotSpdAdj = 0;

	// <uint8_t mDead, offset 0x15f1>
	uint8_t mDead = 0;

	// <uint8_t mDeadPause, offset 0x15f2>
	uint8_t mDeadPause = 0;

	// <uint8_t mCameraOperate, offset 0x15f3>
	uint8_t mCameraOperate = 0;

	// <uint8_t mBattouDemoRequest, offset 0x15f4>
	uint8_t mBattouDemoRequest = 0;

	// <uint8_t mStageChangeInitEnd, offset 0x15f5>
	uint8_t mStageChangeInitEnd = 0;

	// <uint8_t mStageChangeTermEnd, offset 0x15f6>
	uint8_t mStageChangeTermEnd = 0;

	// <uint8_t mStageChangeMuteki, offset 0x15f7>
	uint8_t mStageChangeMuteki = 0;

	// <uint8_t mBanStatusScreen, offset 0x15f8>
	uint8_t mBanStatusScreen = 0;

	// <Unidentified data segment, offset 0x15f9>
private:
	char _UnidentifiedData_5625[3];

public:
	// <int32_t mAtkPauseTime, offset 0x15fc>
	int32_t mAtkPauseTime = 0;

	// <int32_t mStopRenderFrameNum, offset 0x1600>
	int32_t mStopRenderFrameNum = 0;

	// <int32_t mWait1Frame, offset 0x1604>
	int32_t mWait1Frame = 0;

	// <struct stPcEffect mPcEffect, offset 0x1608>
	struct stPcEffect mPcEffect;

	// <struct stHugWalk mPcHug, offset 0x1898>
	struct stHugWalk mPcHug;

	// <struct stTiger mTiger, offset 0x18b8>
	struct stTiger mTiger;

	// <struct Vec mLockOnPos, offset 0x1908>
	struct Vec mLockOnPos;

	// <class mHRChara* mpLockOnNpc, offset 0x1914>
	class mHRChara* mpLockOnNpc = nullptr;

	// <class mHRChara* mpTsubaNpc, offset 0x1918>
	class mHRChara* mpTsubaNpc = nullptr;

	// <class mHRChara* mpCatchNpc, offset 0x191c>
	class mHRChara* mpCatchNpc = nullptr;

	// <class mHRChara* mpCatchReserveNpc, offset 0x1920>
	class mHRChara* mpCatchReserveNpc = nullptr;

	// <class mHRChara* mpEscapeNpc, offset 0x1924>
	class mHRChara* mpEscapeNpc = nullptr;

	// <class mHRChara* mpInitFinishNpc, offset 0x1928>
	class mHRChara* mpInitFinishNpc = nullptr;

	// <class mHRChara* mpNextFinishNpc, offset 0x192c>
	class mHRChara* mpNextFinishNpc = nullptr;

	// <class mHRChara* mpFinishNpc[0x8], offset 0x1930>
	class mHRChara* mpFinishNpc[8];

	// <class mHRChara* mpFinishReserveNpc, offset 0x1950>
	class mHRChara* mpFinishReserveNpc = nullptr;

	// <class mHRChara* mpDSTargetNpc, offset 0x1954>
	class mHRChara* mpDSTargetNpc = nullptr;

	// <class mHRChara* mpDwnAtkNpc, offset 0x1958>
	class mHRChara* mpDwnAtkNpc = nullptr;

	// <class mHRChara* mpLastAtkNpc, offset 0x195c>
	class mHRChara* mpLastAtkNpc = nullptr;

	// <class mHRChara* mpAttackFromBackNpc, offset 0x1960>
	class mHRChara* mpAttackFromBackNpc = nullptr;

	// <class HROBJDummy mLockOnDummy, offset 0x1964>
	class HROBJDummy mLockOnDummy;

	// <uint8_t mSavehitOidashiDisEnable, offset 0x1ee4>
	uint8_t mSavehitOidashiDisEnable = 0;

	// <Unidentified data segment, offset 0x1ee5>
private:
	char _UnidentifiedData_7909[3];

public:
	// <int32_t mSlowMotionSytemMotNo, offset 0x1ee8>
	int32_t mSlowMotionSytemMotNo = 0;

	// <int32_t mSlowMotionSytemButton, offset 0x1eec>
	int32_t mSlowMotionSytemButton = 0;

	// <class ghmTriangle mWepCollL, offset 0x1ef0>
	class ghmTriangle mWepCollL;

	// <class ghmTriangle* m_pAttackHitTriangle, offset 0x1f14>
	class ghmTriangle* m_pAttackHitTriangle = nullptr;

	// <struct stFade mFade, offset 0x1f18>
	struct stFade mFade;

	// <union uniSMflag mSubMissionflag, offset 0x1f24>
	union uniSMflag mSubMissionflag;

	// <uint8_t mSubMissionPcPosStoreFlag, offset 0x1f26>
	uint8_t mSubMissionPcPosStoreFlag = 0;

	// <Unidentified data segment, offset 0x1f27>
private:
	char _UnidentifiedData_7975[1];

public:
	// <struct Vec mSubMissionStorePos, offset 0x1f28>
	struct Vec mSubMissionStorePos;

	// <struct Vec mSubMissionStoreRot, offset 0x1f34>
	struct Vec mSubMissionStoreRot;

	// <uint8_t mSubMissionBikePosStoreFlag, offset 0x1f40>
	uint8_t mSubMissionBikePosStoreFlag = 0;

	// <Unidentified data segment, offset 0x1f41>
private:
	char _UnidentifiedData_8001[3];

public:
	// <struct Vec mSubMissionStoreBikePos, offset 0x1f44>
	struct Vec mSubMissionStoreBikePos;

	// <struct Vec mSubMissionStoreBikeRot, offset 0x1f50>
	struct Vec mSubMissionStoreBikeRot;

	// <class EventAreaCamera* mpSubMissionJumpCameraHandle, offset 0x1f5c>
	class EventAreaCamera* mpSubMissionJumpCameraHandle = nullptr;

	// <int32_t mDisEnableBtlPoseCalc, offset 0x1f60>
	int32_t mDisEnableBtlPoseCalc = 0;

	// <uint8_t mTamePush, offset 0x1f64>
	uint8_t mTamePush = 0;

	// <uint8_t mTameMax, offset 0x1f65>
	uint8_t mTameMax = 0;

	// <uint8_t mTameSe, offset 0x1f66>
	uint8_t mTameSe = 0;

	// <Unidentified data segment, offset 0x1f67>
private:
	char _UnidentifiedData_8039[1];

public:
	// <int32_t mDigAction, offset 0x1f68>
	int32_t mDigAction = 0;

	// <enum enWepChangeProc mChangeWepProc, offset 0x1f6c>
	enum enWepChangeProc mChangeWepProc;

	// <int32_t mChangeWepKind, offset 0x1f70>
	int32_t mChangeWepKind = 0;

	// <int32_t mMenuDisEnableFrame, offset 0x1f74>
	int32_t mMenuDisEnableFrame = 0;

	// <char const* m_sMotName, offset 0x1f78>
	char const* m_sMotName = nullptr;

	// <char const* m_sPreMotName, offset 0x1f7c>
	char const* m_sPreMotName = nullptr;

	// <char m_sOutMotName[0x10], offset 0x1f80>
	char m_sOutMotName[16];

	// <uint8_t m_bIsBootStageHitEffect, offset 0x1f90>
	uint8_t m_bIsBootStageHitEffect = 0;

	// <Unidentified data segment, offset 0x1f91>
private:
	char _UnidentifiedData_8081[3];

public:
	// <struct Vec m_inPreWeaponTopPosi, offset 0x1f94>
	struct Vec m_inPreWeaponTopPosi;

	// <uint8_t m_bIsPreTigerVisible, offset 0x1fa0>
	uint8_t m_bIsPreTigerVisible = 0;

	// <uint8_t m_bIsPreFinishAttack, offset 0x1fa1>
	uint8_t m_bIsPreFinishAttack = 0;

	// <uint8_t m_bIsBeginFinishAttack, offset 0x1fa2>
	uint8_t m_bIsBeginFinishAttack = 0;

	// <uint8_t m_bIsPlayCamBankMotion, offset 0x1fa3>
	uint8_t m_bIsPlayCamBankMotion = 0;

	// <class CTimeRatioInterpolate m_inWeaponLengthRatio, offset 0x1fa4>
	class CTimeRatioInterpolate m_inWeaponLengthRatio;

	/// 731 Functions

	// [Function] uint8_t __convention("thiscall") mHRPc::mGetEventWalk(class mHRPc* const this) [?mGetEventWalk@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetEventWalk_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetEventWalk()
	{
		_mGetEventWalk_mHRPc__QAE_NXZ mFunc = (_mGetEventWalk_mHRPc__QAE_NXZ)(GameModule + 0x9ccd0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetDarkSideTick(class mHRPc* const this) [?mGetDarkSideTick@mHRPc@@QBEHXZ]
	typedef int32_t(__thiscall* _mGetDarkSideTick_mHRPc__QBEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetDarkSideTick()
	{
		_mGetDarkSideTick_mHRPc__QBEHXZ mFunc = (_mGetDarkSideTick_mHRPc__QBEHXZ)(GameModule + 0x9cce0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::isFireDarkSideModeActive(class mHRPc* const this) [?isFireDarkSideModeActive@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _isFireDarkSideModeActive_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t isFireDarkSideModeActive()
	{
		_isFireDarkSideModeActive_mHRPc__QAE_NXZ mFunc = (_isFireDarkSideModeActive_mHRPc__QAE_NXZ)(GameModule + 0x9fbe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTsubaDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetTsubaDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetTsubaDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetTsubaDisEnable(uint8_t arg2)
	{
		_mSetTsubaDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetTsubaDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1b00);
		return mFunc(this, arg2);
	}
	// [Function] enum enPcInputMode __convention("thiscall") mHRPc::mGetInputMode(class mHRPc* const this) [?mGetInputMode@mHRPc@@QAE?AW4enPcInputMode@@XZ]
	typedef enum enPcInputMode(__thiscall* _mGetInputMode_mHRPc__QAEAW4enPcInputMode__XZ)(class mHRPc* const thisPtr);
	/* enum enPcInputMode */ uint32_t mGetInputMode()
	{
		_mGetInputMode_mHRPc__QAEAW4enPcInputMode__XZ mFunc = (_mGetInputMode_mHRPc__QAEAW4enPcInputMode__XZ)(GameModule + 0xa1b10);
		return (uint32_t)mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPcMoney(class mHRPc* const this, int32_t NewAmount) [?mSetPcMoney@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetPcMoney_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t NewAmount);
	void mSetPcMoney(int32_t NewAmount)
	{
		_mSetPcMoney_mHRPc__QAEXH_Z mFunc = (_mSetPcMoney_mHRPc__QAEXH_Z)(GameModule + 0xa1b20);
		return mFunc(this, NewAmount);
	}
	// [Function] void __convention("thiscall") mHRPc::mSubPcMoney(class mHRPc* const this, int32_t arg2) [?mSubPcMoney@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSubPcMoney_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSubPcMoney(int32_t arg2)
	{
		_mSubPcMoney_mHRPc__QAEXH_Z mFunc = (_mSubPcMoney_mHRPc__QAEXH_Z)(GameModule + 0xa1b50);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetPcMoney(class mHRPc* const this) [?mGetPcMoney@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetPcMoney_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetPcMoney()
	{
		_mGetPcMoney_mHRPc__QAEHXZ mFunc = (_mGetPcMoney_mHRPc__QAEHXZ)(GameModule + 0xa1b90);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetEquipID(class mHRPc* const this, enum enEqKind arg2) [?mGetEquipID@mHRPc@@QAEHW4enEqKind@@@Z]
	typedef int32_t(__thiscall* _mGetEquipID_mHRPc__QAEHW4enEqKind___Z)(class mHRPc* const thisPtr, enum enEqKind arg2);
	int32_t mGetEquipID(/* enum enEqKind */ uint32_t arg2)
	{
		_mGetEquipID_mHRPc__QAEHW4enEqKind___Z mFunc = (_mGetEquipID_mHRPc__QAEHW4enEqKind___Z)(GameModule + 0xa1ba0);
		return mFunc(this, (enum enEqKind)arg2);
	}
	// [Function] class TGmf* __convention("thiscall") mHRPc::mGetEquipGmfPtr(class mHRPc* const this, enum enEqKind arg2) [?mGetEquipGmfPtr@mHRPc@@QAEPAVTGmf@@W4enEqKind@@@Z]
	typedef class TGmf*(__thiscall* _mGetEquipGmfPtr_mHRPc__QAEPAVTGmf__W4enEqKind___Z)(class mHRPc* const thisPtr, enum enEqKind arg2);
	class TGmf* mGetEquipGmfPtr(/* enum enEqKind */ uint32_t arg2)
	{
		_mGetEquipGmfPtr_mHRPc__QAEPAVTGmf__W4enEqKind___Z mFunc = (_mGetEquipGmfPtr_mHRPc__QAEPAVTGmf__W4enEqKind___Z)(GameModule + 0xa1bc0);
		return mFunc(this, (enum enEqKind)arg2);
	}
	// [Function] class mHRBike* __convention("thiscall") mHRPc::mGetBikePtr(class mHRPc* const this) [?mGetBikePtr@mHRPc@@QAEPAVmHRBike@@XZ]
	typedef class mHRBike*(__thiscall* _mGetBikePtr_mHRPc__QAEPAVmHRBike__XZ)(class mHRPc* const thisPtr);
	class mHRBike* mGetBikePtr()
	{
		_mGetBikePtr_mHRPc__QAEPAVmHRBike__XZ mFunc = (_mGetBikePtr_mHRPc__QAEPAVmHRBike__XZ)(GameModule + 0xa1be0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBgmNo4Load(class mHRPc* const this, int32_t arg2) [?mSetBgmNo4Load@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetBgmNo4Load_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSetBgmNo4Load(int32_t arg2)
	{
		_mSetBgmNo4Load_mHRPc__QAEXH_Z mFunc = (_mSetBgmNo4Load_mHRPc__QAEXH_Z)(GameModule + 0xa1bf0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDemoBattou(class mHRPc* const this) [?mCheckDemoBattou@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckDemoBattou_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckDemoBattou()
	{
		_mCheckDemoBattou_mHRPc__QAE_NXZ mFunc = (_mCheckDemoBattou_mHRPc__QAE_NXZ)(GameModule + 0xa1c00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDemoNoutou(class mHRPc* const this) [?mCheckDemoNoutou@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckDemoNoutou_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckDemoNoutou()
	{
		_mCheckDemoNoutou_mHRPc__QAE_NXZ mFunc = (_mCheckDemoNoutou_mHRPc__QAE_NXZ)(GameModule + 0xa1c10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetThrowModeOnly(class mHRPc* const this, uint8_t arg2) [?mSetThrowModeOnly@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetThrowModeOnly_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetThrowModeOnly(uint8_t arg2)
	{
		_mSetThrowModeOnly_mHRPc__QAEX_N_Z mFunc = (_mSetThrowModeOnly_mHRPc__QAEX_N_Z)(GameModule + 0xa1c20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSlashModeOnly(class mHRPc* const this, uint8_t arg2) [?mSetSlashModeOnly@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetSlashModeOnly_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetSlashModeOnly(uint8_t arg2)
	{
		_mSetSlashModeOnly_mHRPc__QAEX_N_Z mFunc = (_mSetSlashModeOnly_mHRPc__QAEX_N_Z)(GameModule + 0xa1c30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCatchModeDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetCatchModeDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCatchModeDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetCatchModeDisEnable(uint8_t arg2)
	{
		_mSetCatchModeDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetCatchModeDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1c40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetFightTameDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetFightTameDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetFightTameDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetFightTameDisEnable(uint8_t arg2)
	{
		_mSetFightTameDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetFightTameDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1c50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSlashTameDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetSlashTameDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetSlashTameDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetSlashTameDisEnable(uint8_t arg2)
	{
		_mSetSlashTameDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetSlashTameDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1c60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDownAttackDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetDownAttackDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDownAttackDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDownAttackDisEnable(uint8_t arg2)
	{
		_mSetDownAttackDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetDownAttackDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1c70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDigDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetDigDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDigDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDigDisEnable(uint8_t arg2)
	{
		_mSetDigDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetDigDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1c80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDigDisEnable4SM(class mHRPc* const this) [?mGetDigDisEnable4SM@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDigDisEnable4SM_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDigDisEnable4SM()
	{
		_mGetDigDisEnable4SM_mHRPc__QAE_NXZ mFunc = (_mGetDigDisEnable4SM_mHRPc__QAE_NXZ)(GameModule + 0xa1c90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearSubMissionflag(class mHRPc* const this) [?mClearSubMissionflag@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearSubMissionflag_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearSubMissionflag()
	{
		_mClearSubMissionflag_mHRPc__QAEXXZ mFunc = (_mClearSubMissionflag_mHRPc__QAEXXZ)(GameModule + 0xa1ca0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSubMissionActivflag(class mHRPc* const this, int32_t arg2) [?mSetSubMissionActivflag@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetSubMissionActivflag_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSetSubMissionActivflag(int32_t arg2)
	{
		_mSetSubMissionActivflag_mHRPc__QAEXH_Z mFunc = (_mSetSubMissionActivflag_mHRPc__QAEXH_Z)(GameModule + 0xa1cb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSkillCatch(class mHRPc* const this, int32_t arg2) [?mSetSkillCatch@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetSkillCatch_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSetSkillCatch(int32_t arg2)
	{
		_mSetSkillCatch_mHRPc__QAEXH_Z mFunc = (_mSetSkillCatch_mHRPc__QAEXH_Z)(GameModule + 0xa1cd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAtkMode(class mHRPc* const this, uint8_t arg2) [?mSetAtkMode@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetAtkMode_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetAtkMode(uint8_t arg2)
	{
		_mSetAtkMode_mHRPc__QAEX_N_Z mFunc = (_mSetAtkMode_mHRPc__QAEX_N_Z)(GameModule + 0xa1cf0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAtkMode(class mHRPc* const this) [?mGetAtkMode@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetAtkMode_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetAtkMode()
	{
		_mGetAtkMode_mHRPc__QAE_NXZ mFunc = (_mGetAtkMode_mHRPc__QAE_NXZ)(GameModule + 0xa1d00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetEqWepLaser(class mHRPc* const this) [?mGetEqWepLaser@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetEqWepLaser_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetEqWepLaser()
	{
		_mGetEqWepLaser_mHRPc__QAE_NXZ mFunc = (_mGetEqWepLaser_mHRPc__QAE_NXZ)(GameModule + 0xa1d10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAlwaysEmptyBattery(class mHRPc* const this, uint8_t arg2) [?mSetAlwaysEmptyBattery@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetAlwaysEmptyBattery_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetAlwaysEmptyBattery(uint8_t arg2)
	{
		_mSetAlwaysEmptyBattery_mHRPc__QAEX_N_Z mFunc = (_mSetAlwaysEmptyBattery_mHRPc__QAEX_N_Z)(GameModule + 0xa1d20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCantChargeBattery(class mHRPc* const this, uint8_t arg2) [?mSetCantChargeBattery@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCantChargeBattery_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetCantChargeBattery(uint8_t arg2)
	{
		_mSetCantChargeBattery_mHRPc__QAEX_N_Z mFunc = (_mSetCantChargeBattery_mHRPc__QAEX_N_Z)(GameModule + 0xa1d30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontSemitrans(class mHRPc* const this, uint8_t arg2) [?mSetDontSemitrans@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDontSemitrans_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDontSemitrans(uint8_t arg2)
	{
		_mSetDontSemitrans_mHRPc__QAEX_N_Z mFunc = (_mSetDontSemitrans_mHRPc__QAEX_N_Z)(GameModule + 0xa1d40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCantCallBikeFlag(class mHRPc* const this, uint8_t arg2) [?mSetCantCallBikeFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCantCallBikeFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetCantCallBikeFlag(uint8_t arg2)
	{
		_mSetCantCallBikeFlag_mHRPc__QAEX_N_Z mFunc = (_mSetCantCallBikeFlag_mHRPc__QAEX_N_Z)(GameModule + 0xa1d50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLostBikeFlag(class mHRPc* const this, uint8_t arg2) [?mSetLostBikeFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetLostBikeFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetLostBikeFlag(uint8_t arg2)
	{
		_mSetLostBikeFlag_mHRPc__QAEX_N_Z mFunc = (_mSetLostBikeFlag_mHRPc__QAEX_N_Z)(GameModule + 0xa1d60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetMaxCombo(class mHRPc* const this) [?mResetMaxCombo@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetMaxCombo_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetMaxCombo()
	{
		_mResetMaxCombo_mHRPc__QAEXXZ mFunc = (_mResetMaxCombo_mHRPc__QAEXXZ)(GameModule + 0xa1d70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDigToolFlag(class mHRPc* const this) [?mGetDigToolFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDigToolFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDigToolFlag()
	{
		_mGetDigToolFlag_mHRPc__QAE_NXZ mFunc = (_mGetDigToolFlag_mHRPc__QAE_NXZ)(GameModule + 0xa1d80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPuppetMode(class mHRPc* const this, uint8_t arg2) [?mSetPuppetMode@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetPuppetMode_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetPuppetMode(uint8_t arg2)
	{
		_mSetPuppetMode_mHRPc__QAEX_N_Z mFunc = (_mSetPuppetMode_mHRPc__QAEX_N_Z)(GameModule + 0xa1d90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetUseWeaponEffect(class mHRPc* const this, uint8_t arg2) [?mSetUseWeaponEffect@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetUseWeaponEffect_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetUseWeaponEffect(uint8_t arg2)
	{
		_mSetUseWeaponEffect_mHRPc__QAEX_N_Z mFunc = (_mSetUseWeaponEffect_mHRPc__QAEX_N_Z)(GameModule + 0xa1da0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTodomePrepareMode(class mHRPc* const this) [?mGetTodomePrepareMode@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetTodomePrepareMode_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetTodomePrepareMode()
	{
		_mGetTodomePrepareMode_mHRPc__QAE_NXZ mFunc = (_mGetTodomePrepareMode_mHRPc__QAE_NXZ)(GameModule + 0xa1db0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearTodomePrepareMode(class mHRPc* const this) [?mClearTodomePrepareMode@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearTodomePrepareMode_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearTodomePrepareMode()
	{
		_mClearTodomePrepareMode_mHRPc__QAEXXZ mFunc = (_mClearTodomePrepareMode_mHRPc__QAEXXZ)(GameModule + 0xa1dc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetThrowPrepareMode(class mHRPc* const this) [?mGetThrowPrepareMode@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetThrowPrepareMode_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetThrowPrepareMode()
	{
		_mGetThrowPrepareMode_mHRPc__QAE_NXZ mFunc = (_mGetThrowPrepareMode_mHRPc__QAE_NXZ)(GameModule + 0xa1dd0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetThrowInputResult(class mHRPc* const this) [?mGetThrowInputResult@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetThrowInputResult_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetThrowInputResult()
	{
		_mGetThrowInputResult_mHRPc__QAEHXZ mFunc = (_mGetThrowInputResult_mHRPc__QAEHXZ)(GameModule + 0xa1de0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetShadowDepth(class mHRPc* const this, uint8_t arg2) [?mSetShadowDepth@mHRPc@@QAEXE@Z]
	typedef void(__thiscall* _mSetShadowDepth_mHRPc__QAEXE_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetShadowDepth(uint8_t arg2)
	{
		_mSetShadowDepth_mHRPc__QAEXE_Z mFunc = (_mSetShadowDepth_mHRPc__QAEXE_Z)(GameModule + 0xa1df0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanSlotCry(class mHRPc* const this, uint8_t arg2) [?mSetBanSlotCry@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanSlotCry_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetBanSlotCry(uint8_t arg2)
	{
		_mSetBanSlotCry_mHRPc__QAEX_N_Z mFunc = (_mSetBanSlotCry_mHRPc__QAEX_N_Z)(GameModule + 0xa1e00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanSlotBel(class mHRPc* const this, uint8_t arg2) [?mSetBanSlotBel@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanSlotBel_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetBanSlotBel(uint8_t arg2)
	{
		_mSetBanSlotBel_mHRPc__QAEX_N_Z mFunc = (_mSetBanSlotBel_mHRPc__QAEX_N_Z)(GameModule + 0xa1e10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanSlotBar(class mHRPc* const this, uint8_t arg2) [?mSetBanSlotBar@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanSlotBar_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetBanSlotBar(uint8_t arg2)
	{
		_mSetBanSlotBar_mHRPc__QAEX_N_Z mFunc = (_mSetBanSlotBar_mHRPc__QAEX_N_Z)(GameModule + 0xa1e20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanSlot777(class mHRPc* const this, uint8_t arg2) [?mSetBanSlot777@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanSlot777_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetBanSlot777(uint8_t arg2)
	{
		_mSetBanSlot777_mHRPc__QAEX_N_Z mFunc = (_mSetBanSlot777_mHRPc__QAEX_N_Z)(GameModule + 0xa1e30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDeadSubmission(class mHRPc* const this, uint8_t arg2) [?mSetDeadSubmission@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDeadSubmission_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDeadSubmission(uint8_t arg2)
	{
		_mSetDeadSubmission_mHRPc__QAEX_N_Z mFunc = (_mSetDeadSubmission_mHRPc__QAEX_N_Z)(GameModule + 0xa1e40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontSubBattery(class mHRPc* const this, uint8_t arg2) [?mSetDontSubBattery@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDontSubBattery_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDontSubBattery(uint8_t arg2)
	{
		_mSetDontSubBattery_mHRPc__QAEX_N_Z mFunc = (_mSetDontSubBattery_mHRPc__QAEX_N_Z)(GameModule + 0xa1e50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAutoSubBatteryDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetAutoSubBatteryDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetAutoSubBatteryDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetAutoSubBatteryDisEnable(uint8_t arg2)
	{
		_mSetAutoSubBatteryDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetAutoSubBatteryDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1e60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetJustGuardDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetJustGuardDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetJustGuardDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetJustGuardDisEnable(uint8_t arg2)
	{
		_mSetJustGuardDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetJustGuardDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1e70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDashAtkDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetDashAtkDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDashAtkDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDashAtkDisEnable(uint8_t arg2)
	{
		_mSetDashAtkDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetDashAtkDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1e80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetJustEscapeDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetJustEscapeDisEnable@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetJustEscapeDisEnable_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetJustEscapeDisEnable(uint8_t arg2)
	{
		_mSetJustEscapeDisEnable_mHRPc__QAEX_N_Z mFunc = (_mSetJustEscapeDisEnable_mHRPc__QAEX_N_Z)(GameModule + 0xa1e90);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetTsubaNpc(class mHRPc* const this) [?mGetTsubaNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mGetTsubaNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mGetTsubaNpc()
	{
		_mGetTsubaNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mGetTsubaNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0xa1ea0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOperate(class mHRPc* const this, uint8_t arg2) [?mSetOperate@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetOperate_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetOperate(uint8_t arg2)
	{
		_mSetOperate_mHRPc__QAEX_N_Z mFunc = (_mSetOperate_mHRPc__QAEX_N_Z)(GameModule + 0xa1eb0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetOperate(class mHRPc* const this) [?mGetOperate@mHRPc@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mGetOperate_mHRPc__QBE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetOperate()
	{
		_mGetOperate_mHRPc__QBE_NXZ mFunc = (_mGetOperate_mHRPc__QBE_NXZ)(GameModule + 0xa1ec0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCameraOperate(class mHRPc* const this, uint8_t arg2) [?mSetCameraOperate@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCameraOperate_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetCameraOperate(uint8_t arg2)
	{
		_mSetCameraOperate_mHRPc__QAEX_N_Z mFunc = (_mSetCameraOperate_mHRPc__QAEX_N_Z)(GameModule + 0xa1ed0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckStageChangeTermEnd(class mHRPc* const this) [?mCheckStageChangeTermEnd@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckStageChangeTermEnd_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckStageChangeTermEnd()
	{
		_mCheckStageChangeTermEnd_mHRPc__QAE_NXZ mFunc = (_mCheckStageChangeTermEnd_mHRPc__QAE_NXZ)(GameModule + 0xa1ee0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDeadFlag(class mHRPc* const this) [?mGetDeadFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDeadFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDeadFlag()
	{
		_mGetDeadFlag_mHRPc__QAE_NXZ mFunc = (_mGetDeadFlag_mHRPc__QAE_NXZ)(GameModule + 0xa1ef0);
		return mFunc(this);
	}
	// [Function] struct HRSAVEDATA_DEBUNEKO* __convention("thiscall") mHRPc::mGetDebuNekoDataPtr(class mHRPc* const this) [?mGetDebuNekoDataPtr@mHRPc@@QAEPAUHRSAVEDATA_DEBUNEKO@@XZ]
	typedef struct HRSAVEDATA_DEBUNEKO*(__thiscall* _mGetDebuNekoDataPtr_mHRPc__QAEPAUHRSAVEDATA_DEBUNEKO__XZ)(class mHRPc* const thisPtr);
	struct HRSAVEDATA_DEBUNEKO* mGetDebuNekoDataPtr()
	{
		_mGetDebuNekoDataPtr_mHRPc__QAEPAUHRSAVEDATA_DEBUNEKO__XZ mFunc = (_mGetDebuNekoDataPtr_mHRPc__QAEPAUHRSAVEDATA_DEBUNEKO__XZ)(GameModule + 0xa1f00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPauseAllFlag(class mHRPc* const this, uint8_t arg2) [?mSetPauseAllFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetPauseAllFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetPauseAllFlag(uint8_t arg2)
	{
		_mSetPauseAllFlag_mHRPc__QAEX_N_Z mFunc = (_mSetPauseAllFlag_mHRPc__QAEX_N_Z)(GameModule + 0xa1f10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCancelSetPadOffset(class mHRPc* const this, uint8_t arg2) [?mSetCancelSetPadOffset@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCancelSetPadOffset_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetCancelSetPadOffset(uint8_t arg2)
	{
		_mSetCancelSetPadOffset_mHRPc__QAEX_N_Z mFunc = (_mSetCancelSetPadOffset_mHRPc__QAEX_N_Z)(GameModule + 0xa1f20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetChangeEquipFromScript(class mHRPc* const this, uint8_t arg2) [?mSetChangeEquipFromScript@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetChangeEquipFromScript_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetChangeEquipFromScript(uint8_t arg2)
	{
		_mSetChangeEquipFromScript_mHRPc__QAEX_N_Z mFunc = (_mSetChangeEquipFromScript_mHRPc__QAEX_N_Z)(GameModule + 0xa1f30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetForceLoseTsubazeri(class mHRPc* const this, uint8_t arg2) [?mSetForceLoseTsubazeri@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetForceLoseTsubazeri_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetForceLoseTsubazeri(uint8_t arg2)
	{
		_mSetForceLoseTsubazeri_mHRPc__QAEX_N_Z mFunc = (_mSetForceLoseTsubazeri_mHRPc__QAEX_N_Z)(GameModule + 0xa1f40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDeadFukki(class mHRPc* const this) [?mCheckDeadFukki@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckDeadFukki_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckDeadFukki()
	{
		_mCheckDeadFukki_mHRPc__QAE_NXZ mFunc = (_mCheckDeadFukki_mHRPc__QAE_NXZ)(GameModule + 0xa1f50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionFromDatPtrExt(class mHRPc* const this, class TGan* arg2, char const* arg3, uint8_t arg4, int32_t arg5, uint8_t arg6, float arg7) [?mPlayMotionFromDatPtrExt@mHRPc@@QAE_NPAVTGan@@PBD_NH2M@Z]
	typedef uint8_t(__thiscall* _mPlayMotionFromDatPtrExt_mHRPc__QAE_NPAVTGan__PBD_NH2M_Z)(class mHRPc* const thisPtr, class TGan* arg2, char const* arg3, uint8_t arg4, int32_t arg5, uint8_t arg6, float arg7);
	uint8_t mPlayMotionFromDatPtrExt(class TGan* arg2, std::string arg3, uint8_t arg4, int32_t arg5, uint8_t arg6, float arg7)
	{
		char const* arg3_c_str = arg3.c_str();
		_mPlayMotionFromDatPtrExt_mHRPc__QAE_NPAVTGan__PBD_NH2M_Z mFunc = (_mPlayMotionFromDatPtrExt_mHRPc__QAE_NPAVTGan__PBD_NH2M_Z)(GameModule + 0xa32a0);
		return mFunc(this, arg2, arg3_c_str, arg4, arg5, arg6, arg7);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPcPower(class mHRPc* const this, float arg2) [?mSetPcPower@mHRPc@@QAEXM@Z]
	typedef void(__thiscall* _mSetPcPower_mHRPc__QAEXM_Z)(class mHRPc* const thisPtr, float arg2);
	void mSetPcPower(float arg2)
	{
		_mSetPcPower_mHRPc__QAEXM_Z mFunc = (_mSetPcPower_mHRPc__QAEXM_Z)(GameModule + 0xa32f0);
		return mFunc(this, arg2);
	}
	// [Function] struct tagGHMR_TEX* __convention("thiscall") mHRPc::mGetEquipTexPtr(class mHRPc* const this, enum enEqKind arg2) [?mGetEquipTexPtr@mHRPc@@QAEPAUtagGHMR_TEX@@W4enEqKind@@@Z]
	typedef struct tagGHMR_TEX*(__thiscall* _mGetEquipTexPtr_mHRPc__QAEPAUtagGHMR_TEX__W4enEqKind___Z)(class mHRPc* const thisPtr, enum enEqKind arg2);
	struct tagGHMR_TEX* mGetEquipTexPtr(/* enum enEqKind */ uint32_t arg2)
	{
		_mGetEquipTexPtr_mHRPc__QAEPAUtagGHMR_TEX__W4enEqKind___Z mFunc = (_mGetEquipTexPtr_mHRPc__QAEPAUtagGHMR_TEX__W4enEqKind___Z)(GameModule + 0xa3300);
		return mFunc(this, (enum enEqKind)arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetRestartBGM(class mHRPc* const this) [?mSetRestartBGM@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetRestartBGM_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetRestartBGM()
	{
		_mSetRestartBGM_mHRPc__QAEXXZ mFunc = (_mSetRestartBGM_mHRPc__QAEXXZ)(GameModule + 0xa3310);
		return mFunc(this);
	}
	// [Function] union uniSMflag* __convention("thiscall") mHRPc::mGetSubMissionflag(class mHRPc* const this) [?mGetSubMissionflag@mHRPc@@QAEPATuniSMflag@@XZ]
	typedef union uniSMflag*(__thiscall* _mGetSubMissionflag_mHRPc__QAEPATuniSMflag__XZ)(class mHRPc* const thisPtr);
	union uniSMflag* mGetSubMissionflag()
	{
		_mGetSubMissionflag_mHRPc__QAEPATuniSMflag__XZ mFunc = (_mGetSubMissionflag_mHRPc__QAEPATuniSMflag__XZ)(GameModule + 0xa3320);
		return mFunc(this);
	}
	// [Function] void mHRPc::mSetDisplayMiniMapFlag(uint8_t arg1) [?mSetDisplayMiniMapFlag@mHRPc@@SAX_N@Z]
	typedef void(__fastcall* _mSetDisplayMiniMapFlag_mHRPc__SAX_N_Z)(uint8_t arg1);
	static void mSetDisplayMiniMapFlag(uint8_t arg1)
	{
		_mSetDisplayMiniMapFlag_mHRPc__SAX_N_Z mFunc = (_mSetDisplayMiniMapFlag_mHRPc__SAX_N_Z)(GameModule + 0xa3330);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRPc::mGetDisplayMiniMapFlag() [?mGetDisplayMiniMapFlag@mHRPc@@SA_NXZ]
	typedef uint8_t(__fastcall* _mGetDisplayMiniMapFlag_mHRPc__SA_NXZ)();
	static uint8_t mGetDisplayMiniMapFlag()
	{
		_mGetDisplayMiniMapFlag_mHRPc__SA_NXZ mFunc = (_mGetDisplayMiniMapFlag_mHRPc__SA_NXZ)(GameModule + 0xa3340);
		return mFunc();
	}
	// [Function] void mHRPc::mSetCameraXReverseControlFlag(uint8_t arg1) [?mSetCameraXReverseControlFlag@mHRPc@@SAX_N@Z]
	typedef void(__fastcall* _mSetCameraXReverseControlFlag_mHRPc__SAX_N_Z)(uint8_t arg1);
	static void mSetCameraXReverseControlFlag(uint8_t arg1)
	{
		_mSetCameraXReverseControlFlag_mHRPc__SAX_N_Z mFunc = (_mSetCameraXReverseControlFlag_mHRPc__SAX_N_Z)(GameModule + 0xa3350);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRPc::mGetCameraXReverseControlFlag() [?mGetCameraXReverseControlFlag@mHRPc@@SA_NXZ]
	typedef uint8_t(__fastcall* _mGetCameraXReverseControlFlag_mHRPc__SA_NXZ)();
	static uint8_t mGetCameraXReverseControlFlag()
	{
		_mGetCameraXReverseControlFlag_mHRPc__SA_NXZ mFunc = (_mGetCameraXReverseControlFlag_mHRPc__SA_NXZ)(GameModule + 0xa3360);
		return mFunc();
	}
	// [Function] void mHRPc::mSetCameraYReverseControlFlag(uint8_t arg1) [?mSetCameraYReverseControlFlag@mHRPc@@SAX_N@Z]
	typedef void(__fastcall* _mSetCameraYReverseControlFlag_mHRPc__SAX_N_Z)(uint8_t arg1);
	static void mSetCameraYReverseControlFlag(uint8_t arg1)
	{
		_mSetCameraYReverseControlFlag_mHRPc__SAX_N_Z mFunc = (_mSetCameraYReverseControlFlag_mHRPc__SAX_N_Z)(GameModule + 0xa3370);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRPc::mGetCameraYReverseControlFlag() [?mGetCameraYReverseControlFlag@mHRPc@@SA_NXZ]
	typedef uint8_t(__fastcall* _mGetCameraYReverseControlFlag_mHRPc__SA_NXZ)();
	static uint8_t mGetCameraYReverseControlFlag()
	{
		_mGetCameraYReverseControlFlag_mHRPc__SA_NXZ mFunc = (_mGetCameraYReverseControlFlag_mHRPc__SA_NXZ)(GameModule + 0xa3380);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRPc::mAddClearNum(class mHRPc* const this) [?mAddClearNum@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mAddClearNum_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mAddClearNum()
	{
		_mAddClearNum_mHRPc__QAEXXZ mFunc = (_mAddClearNum_mHRPc__QAEXXZ)(GameModule + 0xa3390);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDeadSubmission(class mHRPc* const this) [?mGetDeadSubmission@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDeadSubmission_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDeadSubmission()
	{
		_mGetDeadSubmission_mHRPc__QAE_NXZ mFunc = (_mGetDeadSubmission_mHRPc__QAE_NXZ)(GameModule + 0xa33a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckStatusMenuDisp(class mHRPc* const this) [?mCheckStatusMenuDisp@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckStatusMenuDisp_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckStatusMenuDisp()
	{
		_mCheckStatusMenuDisp_mHRPc__QAE_NXZ mFunc = (_mCheckStatusMenuDisp_mHRPc__QAE_NXZ)(GameModule + 0xa4740);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetMotionNo(class mHRPc* const this, int32_t arg2) [?mSetMotionNo@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetMotionNo_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSetMotionNo(int32_t arg2)
	{
		_mSetMotionNo_mHRPc__QAEXH_Z mFunc = (_mSetMotionNo_mHRPc__QAEXH_Z)(GameModule + 0xa51b0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAtkPauseTime(class mHRPc* const this) [?mGetAtkPauseTime@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetAtkPauseTime_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetAtkPauseTime()
	{
		_mGetAtkPauseTime_mHRPc__QAEHXZ mFunc = (_mGetAtkPauseTime_mHRPc__QAEHXZ)(GameModule + 0xa51c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDecAtkPauseTime(class mHRPc* const this) [?mDecAtkPauseTime@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mDecAtkPauseTime_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mDecAtkPauseTime()
	{
		_mDecAtkPauseTime_mHRPc__QAEXXZ mFunc = (_mDecAtkPauseTime_mHRPc__QAEXXZ)(GameModule + 0xa51e0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetWait1Frame(class mHRPc* const this) [?mGetWait1Frame@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetWait1Frame_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetWait1Frame()
	{
		_mGetWait1Frame_mHRPc__QAEHXZ mFunc = (_mGetWait1Frame_mHRPc__QAEHXZ)(GameModule + 0xa5200);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDecWait1Frame(class mHRPc* const this) [?mDecWait1Frame@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mDecWait1Frame_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mDecWait1Frame()
	{
		_mDecWait1Frame_mHRPc__QAEXXZ mFunc = (_mDecWait1Frame_mHRPc__QAEXXZ)(GameModule + 0xa5210);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestPlayMiniDemoForSantDestroy(class mHRPc* const this) [?mTestPlayMiniDemoForSantDestroy@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestPlayMiniDemoForSantDestroy_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestPlayMiniDemoForSantDestroy()
	{
		_mTestPlayMiniDemoForSantDestroy_mHRPc__QAE_NXZ mFunc = (_mTestPlayMiniDemoForSantDestroy_mHRPc__QAE_NXZ)(GameModule + 0xa5220);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetHugWalk(class mHRPc* const this) [?mGetHugWalk@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetHugWalk_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetHugWalk()
	{
		_mGetHugWalk_mHRPc__QAE_NXZ mFunc = (_mGetHugWalk_mHRPc__QAE_NXZ)(GameModule + 0xa5230);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetReceiveDamage(class mHRPc* const this) [?mResetReceiveDamage@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetReceiveDamage_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetReceiveDamage()
	{
		_mResetReceiveDamage_mHRPc__QAEXXZ mFunc = (_mResetReceiveDamage_mHRPc__QAEXXZ)(GameModule + 0xa5240);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBikeSight(class mHRPc* const this) [?mGetBikeSight@mHRPc@@QAEEXZ]
	typedef uint8_t(__thiscall* _mGetBikeSight_mHRPc__QAEEXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBikeSight()
	{
		_mGetBikeSight_mHRPc__QAEEXZ mFunc = (_mGetBikeSight_mHRPc__QAEEXZ)(GameModule + 0xa5250);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDontChangeBikeCamera(class mHRPc* const this) [?mGetDontChangeBikeCamera@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDontChangeBikeCamera_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDontChangeBikeCamera()
	{
		_mGetDontChangeBikeCamera_mHRPc__QAE_NXZ mFunc = (_mGetDontChangeBikeCamera_mHRPc__QAE_NXZ)(GameModule + 0xa5260);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCameraOperate(class mHRPc* const this) [?mGetCameraOperate@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetCameraOperate_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetCameraOperate()
	{
		_mGetCameraOperate_mHRPc__QAE_NXZ mFunc = (_mGetCameraOperate_mHRPc__QAE_NXZ)(GameModule + 0xa5270);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPauseAllFlag(class mHRPc* const this) [?mGetPauseAllFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetPauseAllFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetPauseAllFlag()
	{
		_mGetPauseAllFlag_mHRPc__QAE_NXZ mFunc = (_mGetPauseAllFlag_mHRPc__QAE_NXZ)(GameModule + 0xa5280);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::isBeginFinishAttack(class mHRPc* const this) [?isBeginFinishAttack@mHRPc@@QBE_NXZ]
	typedef uint8_t(__thiscall* _isBeginFinishAttack_mHRPc__QBE_NXZ)(class mHRPc* const thisPtr);
	uint8_t isBeginFinishAttack()
	{
		_isBeginFinishAttack_mHRPc__QBE_NXZ mFunc = (_isBeginFinishAttack_mHRPc__QBE_NXZ)(GameModule + 0xa5cd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestTiger(class mHRPc* const this) [?mTestTiger@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestTiger_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestTiger()
	{
		_mTestTiger_mHRPc__QAE_NXZ mFunc = (_mTestTiger_mHRPc__QAE_NXZ)(GameModule + 0xa95b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetMenuDisEnableFrame(class mHRPc* const this, int32_t arg2) [?mSetMenuDisEnableFrame@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetMenuDisEnableFrame_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSetMenuDisEnableFrame(int32_t arg2)
	{
		_mSetMenuDisEnableFrame_mHRPc__QAEXH_Z mFunc = (_mSetMenuDisEnableFrame_mHRPc__QAEXH_Z)(GameModule + 0xa95c0);
		return mFunc(this, arg2);
	}
	// [Function] enum enShakeDir __convention("thiscall") mHRPc::mGetNeedShakeDir(class mHRPc* const this) [?mGetNeedShakeDir@mHRPc@@QAE?AW4enShakeDir@@XZ]
	typedef enum enShakeDir(__thiscall* _mGetNeedShakeDir_mHRPc__QAEAW4enShakeDir__XZ)(class mHRPc* const thisPtr);
	/* enum enShakeDir */ uint32_t mGetNeedShakeDir()
	{
		_mGetNeedShakeDir_mHRPc__QAEAW4enShakeDir__XZ mFunc = (_mGetNeedShakeDir_mHRPc__QAEAW4enShakeDir__XZ)(GameModule + 0xa9fc0);
		return (uint32_t)mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepMotionNo(class mHRPc* const this, int32_t arg2) [?mSetWepMotionNo@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetWepMotionNo_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSetWepMotionNo(int32_t arg2)
	{
		_mSetWepMotionNo_mHRPc__QAEXH_Z mFunc = (_mSetWepMotionNo_mHRPc__QAEXH_Z)(GameModule + 0xa9fd0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetWepMotionNo(class mHRPc* const this) [?mGetWepMotionNo@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetWepMotionNo_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetWepMotionNo()
	{
		_mGetWepMotionNo_mHRPc__QAEHXZ mFunc = (_mGetWepMotionNo_mHRPc__QAEHXZ)(GameModule + 0xa9fe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBikeVisible(class mHRPc* const this, uint8_t arg2) [?mSetBikeVisible@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBikeVisible_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetBikeVisible(uint8_t arg2)
	{
		_mSetBikeVisible_mHRPc__QAEX_N_Z mFunc = (_mSetBikeVisible_mHRPc__QAEX_N_Z)(GameModule + 0xa9ff0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetNowBuf(class mHRPc* const this, int32_t arg2) [?mGetNowBuf@mHRPc@@QAEHH@Z]
	typedef int32_t(__thiscall* _mGetNowBuf_mHRPc__QAEHH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mGetNowBuf(int32_t arg2)
	{
		_mGetNowBuf_mHRPc__QAEHH_Z mFunc = (_mGetNowBuf_mHRPc__QAEHH_Z)(GameModule + 0xaa000);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetTexNowBuf(class mHRPc* const this, int32_t arg2) [?mGetTexNowBuf@mHRPc@@QAEHH@Z]
	typedef int32_t(__thiscall* _mGetTexNowBuf_mHRPc__QAEHH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mGetTexNowBuf(int32_t arg2)
	{
		_mGetTexNowBuf_mHRPc__QAEHH_Z mFunc = (_mGetTexNowBuf_mHRPc__QAEHH_Z)(GameModule + 0xaa020);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckSNBElecDamage(class mHRPc* const this) [?mCheckSNBElecDamage@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckSNBElecDamage_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckSNBElecDamage()
	{
		_mCheckSNBElecDamage_mHRPc__QAE_NXZ mFunc = (_mCheckSNBElecDamage_mHRPc__QAE_NXZ)(GameModule + 0xaa040);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckIntoTsubazeriai(class mHRPc* const this) [?mCheckIntoTsubazeriai@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckIntoTsubazeriai_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckIntoTsubazeriai()
	{
		_mCheckIntoTsubazeriai_mHRPc__UAE_NXZ mFunc = (_mCheckIntoTsubazeriai_mHRPc__UAE_NXZ)(GameModule + 0xaa050);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayMotTsubaszeriai(class mHRPc* const this) [?mPlayMotTsubaszeriai@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mPlayMotTsubaszeriai_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mPlayMotTsubaszeriai()
	{
		_mPlayMotTsubaszeriai_mHRPc__UAEXXZ mFunc = (_mPlayMotTsubaszeriai_mHRPc__UAEXXZ)(GameModule + 0xaa060);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTsubazeriai(class mHRPc* const this) [?mCheckTsubazeriai@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckTsubazeriai_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckTsubazeriai()
	{
		_mCheckTsubazeriai_mHRPc__UAE_NXZ mFunc = (_mCheckTsubazeriai_mHRPc__UAE_NXZ)(GameModule + 0xaa070);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mWinTsubazeriai(class mHRPc* const this) [?mWinTsubazeriai@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mWinTsubazeriai_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mWinTsubazeriai()
	{
		_mWinTsubazeriai_mHRPc__UAEXXZ mFunc = (_mWinTsubazeriai_mHRPc__UAEXXZ)(GameModule + 0xaa080);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mLoseTsubazeriai(class mHRPc* const this) [?mLoseTsubazeriai@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mLoseTsubazeriai_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mLoseTsubazeriai()
	{
		_mLoseTsubazeriai_mHRPc__UAEXXZ mFunc = (_mLoseTsubazeriai_mHRPc__UAEXXZ)(GameModule + 0xaa090);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTsubaOuterMotion(class mHRPc* const this) [?mGetTsubaOuterMotion@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetTsubaOuterMotion_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetTsubaOuterMotion()
	{
		_mGetTsubaOuterMotion_mHRPc__QAE_NXZ mFunc = (_mGetTsubaOuterMotion_mHRPc__QAE_NXZ)(GameModule + 0xaa0a0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetTsubaOuterMotionNo(class mHRPc* const this) [?mGetTsubaOuterMotionNo@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetTsubaOuterMotionNo_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetTsubaOuterMotionNo()
	{
		_mGetTsubaOuterMotionNo_mHRPc__QAEHXZ mFunc = (_mGetTsubaOuterMotionNo_mHRPc__QAEHXZ)(GameModule + 0xaa0b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTsubaDisEnable(class mHRPc* const this) [?mGetTsubaDisEnable@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetTsubaDisEnable_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetTsubaDisEnable()
	{
		_mGetTsubaDisEnable_mHRPc__QAE_NXZ mFunc = (_mGetTsubaDisEnable_mHRPc__QAE_NXZ)(GameModule + 0xaa0c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTsubaEffectVisible(class mHRPc* const this, uint8_t arg2) [?mSetTsubaEffectVisible@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetTsubaEffectVisible_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetTsubaEffectVisible(uint8_t arg2)
	{
		_mSetTsubaEffectVisible_mHRPc__QAEX_N_Z mFunc = (_mSetTsubaEffectVisible_mHRPc__QAEX_N_Z)(GameModule + 0xaa0d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTsubaEffectVisible(class mHRPc* const this) [?mGetTsubaEffectVisible@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetTsubaEffectVisible_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetTsubaEffectVisible()
	{
		_mGetTsubaEffectVisible_mHRPc__QAE_NXZ mFunc = (_mGetTsubaEffectVisible_mHRPc__QAE_NXZ)(GameModule + 0xaa0e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLockOn(class mHRPc* const this) [?mCheckLockOn@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckLockOn_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckLockOn()
	{
		_mCheckLockOn_mHRPc__QAE_NXZ mFunc = (_mCheckLockOn_mHRPc__QAE_NXZ)(GameModule + 0xaa0f0);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetLockOnNpc(class mHRPc* const this) [?mGetLockOnNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mGetLockOnNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mGetLockOnNpc()
	{
		_mGetLockOnNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mGetLockOnNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0xaa100);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAtkPauseTime(class mHRPc* const this, int32_t arg2) [?mSetAtkPauseTime@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetAtkPauseTime_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSetAtkPauseTime(int32_t arg2)
	{
		_mSetAtkPauseTime_mHRPc__QAEXH_Z mFunc = (_mSetAtkPauseTime_mHRPc__QAEXH_Z)(GameModule + 0xaa110);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCmbKind(class mHRPc* const this, enum enPcCmbKind arg2) [?mSetCmbKind@mHRPc@@QAEXW4enPcCmbKind@@@Z]
	typedef void(__thiscall* _mSetCmbKind_mHRPc__QAEXW4enPcCmbKind___Z)(class mHRPc* const thisPtr, enum enPcCmbKind arg2);
	void mSetCmbKind(/* enum enPcCmbKind */ uint32_t arg2)
	{
		_mSetCmbKind_mHRPc__QAEXW4enPcCmbKind___Z mFunc = (_mSetCmbKind_mHRPc__QAEXW4enPcCmbKind___Z)(GameModule + 0xaa130);
		return mFunc(this, (enum enPcCmbKind)arg2);
	}
	// [Function] enum enPcCmbKind __convention("thiscall") mHRPc::mGetCmbKind(class mHRPc* const this) [?mGetCmbKind@mHRPc@@QAE?AW4enPcCmbKind@@XZ]
	typedef enum enPcCmbKind(__thiscall* _mGetCmbKind_mHRPc__QAEAW4enPcCmbKind__XZ)(class mHRPc* const thisPtr);
	/* enum enPcCmbKind */ uint32_t mGetCmbKind()
	{
		_mGetCmbKind_mHRPc__QAEAW4enPcCmbKind__XZ mFunc = (_mGetCmbKind_mHRPc__QAEAW4enPcCmbKind__XZ)(GameModule + 0xaa140);
		return (uint32_t)mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetLockOnThroughWall(class mHRPc* const this) [?mGetLockOnThroughWall@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetLockOnThroughWall_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetLockOnThroughWall()
	{
		_mGetLockOnThroughWall_mHRPc__QAE_NXZ mFunc = (_mGetLockOnThroughWall_mHRPc__QAE_NXZ)(GameModule + 0xaa150);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetThrowModeOnly(class mHRPc* const this) [?mGetThrowModeOnly@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetThrowModeOnly_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetThrowModeOnly()
	{
		_mGetThrowModeOnly_mHRPc__QAE_NXZ mFunc = (_mGetThrowModeOnly_mHRPc__QAE_NXZ)(GameModule + 0xaa160);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCatchModeDisEnable(class mHRPc* const this) [?mGetCatchModeDisEnable@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetCatchModeDisEnable_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetCatchModeDisEnable()
	{
		_mGetCatchModeDisEnable_mHRPc__QAE_NXZ mFunc = (_mGetCatchModeDisEnable_mHRPc__QAE_NXZ)(GameModule + 0xaa170);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDownAttackDisEnable(class mHRPc* const this) [?mGetDownAttackDisEnable@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDownAttackDisEnable_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDownAttackDisEnable()
	{
		_mGetDownAttackDisEnable_mHRPc__QAE_NXZ mFunc = (_mGetDownAttackDisEnable_mHRPc__QAE_NXZ)(GameModule + 0xaa180);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDigDisEnable(class mHRPc* const this) [?mGetDigDisEnable@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDigDisEnable_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDigDisEnable()
	{
		_mGetDigDisEnable_mHRPc__QAE_NXZ mFunc = (_mGetDigDisEnable_mHRPc__QAE_NXZ)(GameModule + 0xaa190);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDigDisEnable4SM(class mHRPc* const this, uint8_t arg2) [?mSetDigDisEnable4SM@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDigDisEnable4SM_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDigDisEnable4SM(uint8_t arg2)
	{
		_mSetDigDisEnable4SM_mHRPc__QAEX_N_Z mFunc = (_mSetDigDisEnable4SM_mHRPc__QAEX_N_Z)(GameModule + 0xaa1a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetSkillCatch(class mHRPc* const this, int32_t arg2) [?mGetSkillCatch@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mGetSkillCatch_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mGetSkillCatch(int32_t arg2)
	{
		_mGetSkillCatch_mHRPc__QAE_NH_Z mFunc = (_mGetSkillCatch_mHRPc__QAE_NH_Z)(GameModule + 0xaa1b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSkillK7(class mHRPc* const this, int32_t arg2) [?mSetSkillK7@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSetSkillK7_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSetSkillK7(int32_t arg2)
	{
		_mSetSkillK7_mHRPc__QAEXH_Z mFunc = (_mSetSkillK7_mHRPc__QAEXH_Z)(GameModule + 0xaa1d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetSkillK7(class mHRPc* const this, int32_t arg2) [?mGetSkillK7@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mGetSkillK7_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mGetSkillK7(int32_t arg2)
	{
		_mGetSkillK7_mHRPc__QAE_NH_Z mFunc = (_mGetSkillK7_mHRPc__QAE_NH_Z)(GameModule + 0xaa1f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPcBtlPose(class mHRPc* const this, enum enPcPose arg2) [?mSetPcBtlPose@mHRPc@@QAEXW4enPcPose@@@Z]
	typedef void(__thiscall* _mSetPcBtlPose_mHRPc__QAEXW4enPcPose___Z)(class mHRPc* const thisPtr, enum enPcPose arg2);
	void mSetPcBtlPose(/* enum enPcPose */ uint32_t arg2)
	{
		_mSetPcBtlPose_mHRPc__QAEXW4enPcPose___Z mFunc = (_mSetPcBtlPose_mHRPc__QAEXW4enPcPose___Z)(GameModule + 0xaa200);
		return mFunc(this, (enum enPcPose)arg2);
	}
	// [Function] enum enPcPose __convention("thiscall") mHRPc::mGetPcBtlPose(class mHRPc* const this) [?mGetPcBtlPose@mHRPc@@QAE?AW4enPcPose@@XZ]
	typedef enum enPcPose(__thiscall* _mGetPcBtlPose_mHRPc__QAEAW4enPcPose__XZ)(class mHRPc* const thisPtr);
	/* enum enPcPose */ uint32_t mGetPcBtlPose()
	{
		_mGetPcBtlPose_mHRPc__QAEAW4enPcPose__XZ mFunc = (_mGetPcBtlPose_mHRPc__QAEAW4enPcPose__XZ)(GameModule + 0xaa210);
		return (uint32_t)mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetEqWepLaser(class mHRPc* const this, bool Input) [?mSetEqWepLaser@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetEqWepLaser_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Input);
	void mSetEqWepLaser(bool Input)
	{
		_mSetEqWepLaser_mHRPc__QAEX_N_Z mFunc = (_mSetEqWepLaser_mHRPc__QAEX_N_Z)(GameModule + 0xaa220);
		return mFunc(this, Input);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetElectroShockWalk(class mHRPc* const this) [?mGetElectroShockWalk@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetElectroShockWalk_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetElectroShockWalk()
	{
		_mGetElectroShockWalk_mHRPc__QAE_NXZ mFunc = (_mGetElectroShockWalk_mHRPc__QAE_NXZ)(GameModule + 0xaa230);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPoisonWalk(class mHRPc* const this) [?mGetPoisonWalk@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetPoisonWalk_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetPoisonWalk()
	{
		_mGetPoisonWalk_mHRPc__QAE_NXZ mFunc = (_mGetPoisonWalk_mHRPc__QAE_NXZ)(GameModule + 0xaa240);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCantDispLaserEffect(class mHRPc* const this) [?mGetCantDispLaserEffect@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetCantDispLaserEffect_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetCantDispLaserEffect()
	{
		_mGetCantDispLaserEffect_mHRPc__QAE_NXZ mFunc = (_mGetCantDispLaserEffect_mHRPc__QAE_NXZ)(GameModule + 0xaa250);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepChangeUnVisible(class mHRPc* const this, uint8_t arg2) [?mSetWepChangeUnVisible@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetWepChangeUnVisible_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetWepChangeUnVisible(uint8_t arg2)
	{
		_mSetWepChangeUnVisible_mHRPc__QAEX_N_Z mFunc = (_mSetWepChangeUnVisible_mHRPc__QAEX_N_Z)(GameModule + 0xaa260);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAtkHitAbsoluteFlag(class mHRPc* const this, uint8_t arg2) [?mSetAtkHitAbsoluteFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetAtkHitAbsoluteFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetAtkHitAbsoluteFlag(uint8_t arg2)
	{
		_mSetAtkHitAbsoluteFlag_mHRPc__QAEX_N_Z mFunc = (_mSetAtkHitAbsoluteFlag_mHRPc__QAEX_N_Z)(GameModule + 0xaa270);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAtkHitAbsoluteFlag(class mHRPc* const this) [?mGetAtkHitAbsoluteFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetAtkHitAbsoluteFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetAtkHitAbsoluteFlag()
	{
		_mGetAtkHitAbsoluteFlag_mHRPc__QAE_NXZ mFunc = (_mGetAtkHitAbsoluteFlag_mHRPc__QAE_NXZ)(GameModule + 0xaa280);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAttackHitToRollEscepe(class mHRPc* const this, uint8_t arg2) [?mSetAttackHitToRollEscepe@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetAttackHitToRollEscepe_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetAttackHitToRollEscepe(uint8_t arg2)
	{
		_mSetAttackHitToRollEscepe_mHRPc__QAEX_N_Z mFunc = (_mSetAttackHitToRollEscepe_mHRPc__QAEX_N_Z)(GameModule + 0xaa290);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAttackHitToRollEscepe(class mHRPc* const this) [?mGetAttackHitToRollEscepe@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetAttackHitToRollEscepe_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetAttackHitToRollEscepe()
	{
		_mGetAttackHitToRollEscepe_mHRPc__QAE_NXZ mFunc = (_mGetAttackHitToRollEscepe_mHRPc__QAE_NXZ)(GameModule + 0xaa2a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPuppetMode(class mHRPc* const this) [?mGetPuppetMode@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetPuppetMode_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetPuppetMode()
	{
		_mGetPuppetMode_mHRPc__QAE_NXZ mFunc = (_mGetPuppetMode_mHRPc__QAE_NXZ)(GameModule + 0xaa2b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetUseWeaponEffect(class mHRPc* const this) [?mGetUseWeaponEffect@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetUseWeaponEffect_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetUseWeaponEffect()
	{
		_mGetUseWeaponEffect_mHRPc__QAE_NXZ mFunc = (_mGetUseWeaponEffect_mHRPc__QAE_NXZ)(GameModule + 0xaa2c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLastAttackNpc(class mHRPc* const this, class mHRChara* Npc) [?mSetLastAttackNpc@mHRPc@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mSetLastAttackNpc_mHRPc__QAEXPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* Npc);
	void mSetLastAttackNpc(class mHRChara* Npc)
	{
		_mSetLastAttackNpc_mHRPc__QAEXPAVmHRChara___Z mFunc = (_mSetLastAttackNpc_mHRPc__QAEXPAVmHRChara___Z)(GameModule + 0xaa2d0);
		return mFunc(this, Npc);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetLastAttackNpc(class mHRPc* const this) [?mGetLastAttackNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mGetLastAttackNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mGetLastAttackNpc()
	{
		_mGetLastAttackNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mGetLastAttackNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0xaa2e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAttackFromBackNpc(class mHRPc* const this, class mHRChara* Npc) [?mSetAttackFromBackNpc@mHRPc@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mSetAttackFromBackNpc_mHRPc__QAEXPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* Npc);
	void mSetAttackFromBackNpc(class mHRChara* Npc)
	{
		_mSetAttackFromBackNpc_mHRPc__QAEXPAVmHRChara___Z mFunc = (_mSetAttackFromBackNpc_mHRPc__QAEXPAVmHRChara___Z)(GameModule + 0xaa2f0);
		return mFunc(this, Npc);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetAttackFromBackNpc(class mHRPc* const this) [?mGetAttackFromBackNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mGetAttackFromBackNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mGetAttackFromBackNpc()
	{
		_mGetAttackFromBackNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mGetAttackFromBackNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0xaa300);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetFinishBonusFlag(class mHRPc* const this) [?mGetFinishBonusFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetFinishBonusFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetFinishBonusFlag()
	{
		_mGetFinishBonusFlag_mHRPc__QAE_NXZ mFunc = (_mGetFinishBonusFlag_mHRPc__QAE_NXZ)(GameModule + 0xaa310);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanRollEscape(class mHRPc* const this, bool Ban) [?mSetBanRollEscape@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanRollEscape_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Ban);
	void mSetBanRollEscape(bool Ban)
	{
		_mSetBanRollEscape_mHRPc__QAEX_N_Z mFunc = (_mSetBanRollEscape_mHRPc__QAEX_N_Z)(GameModule + 0xaa320);
		return mFunc(this, Ban);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanJump(class mHRPc* const this, bool Ban) [?mSetBanJump@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanJump_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Ban);
	void mSetBanJump(bool Ban)
	{
		_mSetBanJump_mHRPc__QAEX_N_Z mFunc = (_mSetBanJump_mHRPc__QAEX_N_Z)(GameModule + 0xaa330);
		return mFunc(this, Ban);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanPiyori(class mHRPc* const this, bool Ban) [?mSetBanPiyori@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanPiyori_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Ban);
	void mSetBanPiyori(bool Ban)
	{
		_mSetBanPiyori_mHRPc__QAEX_N_Z mFunc = (_mSetBanPiyori_mHRPc__QAEX_N_Z)(GameModule + 0xaa340);
		return mFunc(this, Ban);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanDeadFukki(class mHRPc* const this, bool Ban) [?mSetBanDeadFukki@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanDeadFukki_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Ban);
	void mSetBanDeadFukki(bool Ban)
	{
		_mSetBanDeadFukki_mHRPc__QAEX_N_Z mFunc = (_mSetBanDeadFukki_mHRPc__QAEX_N_Z)(GameModule + 0xaa350);
		return mFunc(this, Ban);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanJustGuard(class mHRPc* const this, bool Ban) [?mSetBanJustGuard@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanJustGuard_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Ban);
	void mSetBanJustGuard(bool Ban)
	{
		_mSetBanJustGuard_mHRPc__QAEX_N_Z mFunc = (_mSetBanJustGuard_mHRPc__QAEX_N_Z)(GameModule + 0xaa360);
		return mFunc(this, Ban);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanWinTsubazeri(class mHRPc* const this, bool Ban) [?mSetBanWinTsubazeri@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBanWinTsubazeri_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Ban);
	void mSetBanWinTsubazeri(bool Ban)
	{
		_mSetBanWinTsubazeri_mHRPc__QAEX_N_Z mFunc = (_mSetBanWinTsubazeri_mHRPc__QAEX_N_Z)(GameModule + 0xaa370);
		return mFunc(this, Ban);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanSlotCry(class mHRPc* const this) [?mGetBanSlotCry@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanSlotCry_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanSlotCry()
	{
		_mGetBanSlotCry_mHRPc__QAE_NXZ mFunc = (_mGetBanSlotCry_mHRPc__QAE_NXZ)(GameModule + 0xaa380);
		return mFunc(this);
	}
	// [Function] bool __convention("thiscall") mHRPc::mGetBanSlotBel(class mHRPc* const this) [?mGetBanSlotBel@mHRPc@@QAE_NXZ]
	typedef bool(__thiscall* _mGetBanSlotBel_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	bool mGetBanSlotBel()
	{
		_mGetBanSlotBel_mHRPc__QAE_NXZ mFunc = (_mGetBanSlotBel_mHRPc__QAE_NXZ)(GameModule + 0xaa390);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanSlotBar(class mHRPc* const this) [?mGetBanSlotBar@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanSlotBar_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanSlotBar()
	{
		_mGetBanSlotBar_mHRPc__QAE_NXZ mFunc = (_mGetBanSlotBar_mHRPc__QAE_NXZ)(GameModule + 0xaa3a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanSlot777(class mHRPc* const this) [?mGetBanSlot777@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanSlot777_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanSlot777()
	{
		_mGetBanSlot777_mHRPc__QAE_NXZ mFunc = (_mGetBanSlot777_mHRPc__QAE_NXZ)(GameModule + 0xaa3b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanJump(class mHRPc* const this) [?mGetBanJump@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanJump_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanJump()
	{
		_mGetBanJump_mHRPc__QAE_NXZ mFunc = (_mGetBanJump_mHRPc__QAE_NXZ)(GameModule + 0xaa3c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanPiyori(class mHRPc* const this) [?mGetBanPiyori@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanPiyori_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanPiyori()
	{
		_mGetBanPiyori_mHRPc__QAE_NXZ mFunc = (_mGetBanPiyori_mHRPc__QAE_NXZ)(GameModule + 0xaa3d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanDeadFukki(class mHRPc* const this) [?mGetBanDeadFukki@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanDeadFukki_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanDeadFukki()
	{
		_mGetBanDeadFukki_mHRPc__QAE_NXZ mFunc = (_mGetBanDeadFukki_mHRPc__QAE_NXZ)(GameModule + 0xaa3e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanJustGuard(class mHRPc* const this) [?mGetBanJustGuard@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanJustGuard_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanJustGuard()
	{
		_mGetBanJustGuard_mHRPc__QAE_NXZ mFunc = (_mGetBanJustGuard_mHRPc__QAE_NXZ)(GameModule + 0xaa3f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanWinTsubazeri(class mHRPc* const this) [?mGetBanWinTsubazeri@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanWinTsubazeri_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanWinTsubazeri()
	{
		_mGetBanWinTsubazeri_mHRPc__QAE_NXZ mFunc = (_mGetBanWinTsubazeri_mHRPc__QAE_NXZ)(GameModule + 0xaa400);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetWepStick(class mHRPc* const this) [?mGetWepStick@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetWepStick_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetWepStick()
	{
		_mGetWepStick_mHRPc__QAE_NXZ mFunc = (_mGetWepStick_mHRPc__QAE_NXZ)(GameModule + 0xaa410);
		return mFunc(this);
	}
	// [Function] bool __convention("thiscall") mHRPc::mGetDontSubBattery(class mHRPc* const this) [?mGetDontSubBattery@mHRPc@@QAE_NXZ]
	typedef bool(__thiscall* _mGetDontSubBattery_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	bool mGetDontSubBattery()
	{
		_mGetDontSubBattery_mHRPc__QAE_NXZ mFunc = (_mGetDontSubBattery_mHRPc__QAE_NXZ)(GameModule + 0xaa420);
		return mFunc(this);
	}
	// [Function] bool __convention("thiscall") mHRPc::mGetAutoSubBatteryDisEnable(class mHRPc* const this) [?mGetAutoSubBatteryDisEnable@mHRPc@@QAE_NXZ]
	typedef bool(__thiscall* _mGetAutoSubBatteryDisEnable_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	bool mGetAutoSubBatteryDisEnable()
	{
		_mGetAutoSubBatteryDisEnable_mHRPc__QAE_NXZ mFunc = (_mGetAutoSubBatteryDisEnable_mHRPc__QAE_NXZ)(GameModule + 0xaa430);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetJustGuardDisEnable(class mHRPc* const this) [?mGetJustGuardDisEnable@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetJustGuardDisEnable_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetJustGuardDisEnable()
	{
		_mGetJustGuardDisEnable_mHRPc__QAE_NXZ mFunc = (_mGetJustGuardDisEnable_mHRPc__QAE_NXZ)(GameModule + 0xaa440);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDashAtkExec(class mHRPc* const this, uint8_t arg2) [?mSetDashAtkExec@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDashAtkExec_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDashAtkExec(uint8_t arg2)
	{
		_mSetDashAtkExec_mHRPc__QAEX_N_Z mFunc = (_mSetDashAtkExec_mHRPc__QAEX_N_Z)(GameModule + 0xaa450);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDashAtkExec(class mHRPc* const this) [?mGetDashAtkExec@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDashAtkExec_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDashAtkExec()
	{
		_mGetDashAtkExec_mHRPc__QAE_NXZ mFunc = (_mGetDashAtkExec_mHRPc__QAE_NXZ)(GameModule + 0xaa460);
		return mFunc(this);
	}
	// [Function] bool __convention("thiscall") mHRPc::mGetJustEscapeDisEnable(class mHRPc* const this) [?mGetJustEscapeDisEnable@mHRPc@@QAE_NXZ]
	typedef bool(__thiscall* _mGetJustEscapeDisEnable_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	bool mGetJustEscapeDisEnable()
	{
		_mGetJustEscapeDisEnable_mHRPc__QAE_NXZ mFunc = (_mGetJustEscapeDisEnable_mHRPc__QAE_NXZ)(GameModule + 0xaa470);
		return mFunc(this);
	}
	// [Function] struct tagGHMR_TEX* __convention("thiscall") mHRPc::mGetFpsCursorPtr(class mHRPc* const this) [?mGetFpsCursorPtr@mHRPc@@QAEPAUtagGHMR_TEX@@XZ]
	typedef struct tagGHMR_TEX*(__thiscall* _mGetFpsCursorPtr_mHRPc__QAEPAUtagGHMR_TEX__XZ)(class mHRPc* const thisPtr);
	struct tagGHMR_TEX* mGetFpsCursorPtr()
	{
		_mGetFpsCursorPtr_mHRPc__QAEPAUtagGHMR_TEX__XZ mFunc = (_mGetFpsCursorPtr_mHRPc__QAEPAUtagGHMR_TEX__XZ)(GameModule + 0xaa480);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontRestoreMotion(class mHRPc* const this, bool Input) [?mSetDontRestoreMotion@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDontRestoreMotion_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Input);
	void mSetDontRestoreMotion(bool Input)
	{
		_mSetDontRestoreMotion_mHRPc__QAEX_N_Z mFunc = (_mSetDontRestoreMotion_mHRPc__QAEX_N_Z)(GameModule + 0xaa490);
		return mFunc(this, Input);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDontRestoreMotion(class mHRPc* const this) [?mGetDontRestoreMotion@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDontRestoreMotion_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDontRestoreMotion()
	{
		_mGetDontRestoreMotion_mHRPc__QAE_NXZ mFunc = (_mGetDontRestoreMotion_mHRPc__QAE_NXZ)(GameModule + 0xaa4a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBikeClash2battou(class mHRPc* const this, uint8_t arg2) [?mSetBikeClash2battou@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetBikeClash2battou_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetBikeClash2battou(uint8_t arg2)
	{
		_mSetBikeClash2battou_mHRPc__QAEX_N_Z mFunc = (_mSetBikeClash2battou_mHRPc__QAEX_N_Z)(GameModule + 0xaa4b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetRotInterpolate(class mHRPc* const this, float arg2) [?mSetRotInterpolate@mHRPc@@QAEXM@Z]
	typedef void(__thiscall* _mSetRotInterpolate_mHRPc__QAEXM_Z)(class mHRPc* const thisPtr, float arg2);
	void mSetRotInterpolate(float arg2)
	{
		_mSetRotInterpolate_mHRPc__QAEXM_Z mFunc = (_mSetRotInterpolate_mHRPc__QAEXM_Z)(GameModule + 0xaa4c0);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetRotInterpolateDefault(class mHRPc* const this) [?mGetRotInterpolateDefault@mHRPc@@UAEMXZ]
	typedef float(__thiscall* _mGetRotInterpolateDefault_mHRPc__UAEMXZ)(class mHRPc* const thisPtr);
	float mGetRotInterpolateDefault()
	{
		_mGetRotInterpolateDefault_mHRPc__UAEMXZ mFunc = (_mGetRotInterpolateDefault_mHRPc__UAEMXZ)(GameModule + 0xaa4d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetHiTension(class mHRPc* const this) [?mGetHiTension@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetHiTension_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetHiTension()
	{
		_mGetHiTension_mHRPc__QAE_NXZ mFunc = (_mGetHiTension_mHRPc__QAE_NXZ)(GameModule + 0xaa4e0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mTestDancingCombo(class mHRPc* const this) [?mTestDancingCombo@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mTestDancingCombo_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mTestDancingCombo()
	{
		_mTestDancingCombo_mHRPc__QAEHXZ mFunc = (_mTestDancingCombo_mHRPc__QAEHXZ)(GameModule + 0xaa4f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestBullet(class mHRPc* const this) [?mTestBullet@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestBullet_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestBullet()
	{
		_mTestBullet_mHRPc__QAE_NXZ mFunc = (_mTestBullet_mHRPc__QAE_NXZ)(GameModule + 0xaa500);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestFire(class mHRPc* const this) [?mTestFire@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestFire_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestFire()
	{
		_mTestFire_mHRPc__QAE_NXZ mFunc = (_mTestFire_mHRPc__QAE_NXZ)(GameModule + 0xaa510);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTest360(class mHRPc* const this) [?mTest360@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTest360_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTest360()
	{
		_mTest360_mHRPc__QAE_NXZ mFunc = (_mTest360_mHRPc__QAE_NXZ)(GameModule + 0xaa520);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTigerVisible(class mHRPc* const this, uint8_t arg2) [?mSetTigerVisible@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetTigerVisible_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetTigerVisible(uint8_t arg2)
	{
		_mSetTigerVisible_mHRPc__QAEX_N_Z mFunc = (_mSetTigerVisible_mHRPc__QAEX_N_Z)(GameModule + 0xaa530);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTigerVisible(class mHRPc* const this) [?mGetTigerVisible@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetTigerVisible_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetTigerVisible()
	{
		_mGetTigerVisible_mHRPc__QAE_NXZ mFunc = (_mGetTigerVisible_mHRPc__QAE_NXZ)(GameModule + 0xaa540);
		return mFunc(this);
	}
	// [Function] class ghmTriangle* __convention("thiscall") mHRPc::mGetRightWepTrianglePtr(class mHRPc* const this) [?mGetRightWepTrianglePtr@mHRPc@@QAEPAVghmTriangle@@XZ]
	typedef class ghmTriangle*(__thiscall* _mGetRightWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ)(class mHRPc* const thisPtr);
	class ghmTriangle* mGetRightWepTrianglePtr()
	{
		_mGetRightWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ mFunc = (_mGetRightWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ)(GameModule + 0xaa550);
		return mFunc(this);
	}
	// [Function] class ghmTriangle* __convention("thiscall") mHRPc::mGetWepTrianglePtr(class mHRPc* const this) [?mGetWepTrianglePtr@mHRPc@@QAEPAVghmTriangle@@XZ]
	typedef class ghmTriangle*(__thiscall* _mGetWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ)(class mHRPc* const thisPtr);
	class ghmTriangle* mGetWepTrianglePtr()
	{
		_mGetWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ mFunc = (_mGetWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ)(GameModule + 0xaa560);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRPc::mGetResourceGmfPtr(class mHRPc* const this) [?mGetResourceGmfPtr@mHRPc@@UAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _mGetResourceGmfPtr_mHRPc__UAEPAVTGmf__XZ)(class mHRPc* const thisPtr);
	class TGmf* mGetResourceGmfPtr()
	{
		_mGetResourceGmfPtr_mHRPc__UAEPAVTGmf__XZ mFunc = (_mGetResourceGmfPtr_mHRPc__UAEPAVTGmf__XZ)(GameModule + 0xaa570);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPauseNpcFlag(class mHRPc* const this, uint8_t arg2) [?mSetPauseNpcFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetPauseNpcFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetPauseNpcFlag(uint8_t arg2)
	{
		_mSetPauseNpcFlag_mHRPc__QAEX_N_Z mFunc = (_mSetPauseNpcFlag_mHRPc__QAEX_N_Z)(GameModule + 0xaa590);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPauseNpcFlag(class mHRPc* const this) [?mGetPauseNpcFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetPauseNpcFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetPauseNpcFlag()
	{
		_mGetPauseNpcFlag_mHRPc__QAE_NXZ mFunc = (_mGetPauseNpcFlag_mHRPc__QAE_NXZ)(GameModule + 0xaa5a0);
		return mFunc(this);
	}
	// [Function] char const* __convention("thiscall") mHRPc::getCurTigerMotionName(class mHRPc* const this) [?getCurTigerMotionName@mHRPc@@QBEPBDXZ]
	typedef char const*(__thiscall* _getCurTigerMotionName_mHRPc__QBEPBDXZ)(class mHRPc* const thisPtr);
	std::string getCurTigerMotionName()
	{
		_getCurTigerMotionName_mHRPc__QBEPBDXZ mFunc = (_getCurTigerMotionName_mHRPc__QBEPBDXZ)(GameModule + 0xaa5b0);
		char const* OutResult = mFunc(this);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] char const* __convention("thiscall") mHRPc::getCurMotionName(class mHRPc* const this) [?getCurMotionName@mHRPc@@UBEPBDXZ]
	typedef char const*(__thiscall* _getCurMotionName_mHRPc__UBEPBDXZ)(class mHRPc* const thisPtr);
	std::string getCurMotionName()
	{
		_getCurMotionName_mHRPc__UBEPBDXZ mFunc = (_getCurMotionName_mHRPc__UBEPBDXZ)(GameModule + 0xaa5c0);
		char const* OutResult = mFunc(this);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::isOutResourceMotion(class mHRPc* const this) [?isOutResourceMotion@mHRPc@@QBE_NXZ]
	typedef uint8_t(__thiscall* _isOutResourceMotion_mHRPc__QBE_NXZ)(class mHRPc* const thisPtr);
	uint8_t isOutResourceMotion()
	{
		_isOutResourceMotion_mHRPc__QBE_NXZ mFunc = (_isOutResourceMotion_mHRPc__QBE_NXZ)(GameModule + 0xaa5d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCancelSetPadOffset(class mHRPc* const this) [?mGetCancelSetPadOffset@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetCancelSetPadOffset_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetCancelSetPadOffset()
	{
		_mGetCancelSetPadOffset_mHRPc__QAE_NXZ mFunc = (_mGetCancelSetPadOffset_mHRPc__QAE_NXZ)(GameModule + 0xaa5f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetChangeEquipFromScript(class mHRPc* const this) [?mGetChangeEquipFromScript@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetChangeEquipFromScript_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetChangeEquipFromScript()
	{
		_mGetChangeEquipFromScript_mHRPc__QAE_NXZ mFunc = (_mGetChangeEquipFromScript_mHRPc__QAE_NXZ)(GameModule + 0xaa600);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetNoBatteryThrow(class mHRPc* const this, bool input) [?mSetNoBatteryThrow@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetNoBatteryThrow_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool input);
	void mSetNoBatteryThrow(bool input)
	{
		_mSetNoBatteryThrow_mHRPc__QAEX_N_Z mFunc = (_mSetNoBatteryThrow_mHRPc__QAEX_N_Z)(GameModule + 0xaa610);
		return mFunc(this, input);
	}
	// [Function] bool __convention("thiscall") mHRPc::mGetNoBatteryThrow(class mHRPc* const this) [?mGetNoBatteryThrow@mHRPc@@QAE_NXZ]
	typedef bool(__thiscall* _mGetNoBatteryThrow_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	bool mGetNoBatteryThrow()
	{
		_mGetNoBatteryThrow_mHRPc__QAE_NXZ mFunc = (_mGetNoBatteryThrow_mHRPc__QAE_NXZ)(GameModule + 0xaa620);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetChangeWeaponEffectVisible(class mHRPc* const this, uint8_t arg2) [?mSetChangeWeaponEffectVisible@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetChangeWeaponEffectVisible_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetChangeWeaponEffectVisible(uint8_t arg2)
	{
		_mSetChangeWeaponEffectVisible_mHRPc__QAEX_N_Z mFunc = (_mSetChangeWeaponEffectVisible_mHRPc__QAEX_N_Z)(GameModule + 0xaa630);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetChangeWeaponEffectVisible(class mHRPc* const this) [?mGetChangeWeaponEffectVisible@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetChangeWeaponEffectVisible_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetChangeWeaponEffectVisible()
	{
		_mGetChangeWeaponEffectVisible_mHRPc__QAE_NXZ mFunc = (_mGetChangeWeaponEffectVisible_mHRPc__QAE_NXZ)(GameModule + 0xaa640);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLockOnNockDown(class mHRPc* const this, uint8_t arg2) [?mSetLockOnNockDown@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetLockOnNockDown_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetLockOnNockDown(uint8_t arg2)
	{
		_mSetLockOnNockDown_mHRPc__QAEX_N_Z mFunc = (_mSetLockOnNockDown_mHRPc__QAEX_N_Z)(GameModule + 0xaa650);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetLockOnNockDown(class mHRPc* const this) [?mGetLockOnNockDown@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetLockOnNockDown_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetLockOnNockDown()
	{
		_mGetLockOnNockDown_mHRPc__QAE_NXZ mFunc = (_mGetLockOnNockDown_mHRPc__QAE_NXZ)(GameModule + 0xaa660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAttackHajiki(class mHRPc* const this, uint8_t arg2) [?mSetAttackHajiki@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetAttackHajiki_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetAttackHajiki(uint8_t arg2)
	{
		_mSetAttackHajiki_mHRPc__QAEX_N_Z mFunc = (_mSetAttackHajiki_mHRPc__QAEX_N_Z)(GameModule + 0xaa670);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAttackHajiki(class mHRPc* const this) [?mGetAttackHajiki@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetAttackHajiki_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetAttackHajiki()
	{
		_mGetAttackHajiki_mHRPc__QAE_NXZ mFunc = (_mGetAttackHajiki_mHRPc__QAE_NXZ)(GameModule + 0xaa680);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontPlayLoseTsubazeriMotion(class mHRPc* const this, uint8_t arg2) [?mSetDontPlayLoseTsubazeriMotion@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDontPlayLoseTsubazeriMotion_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDontPlayLoseTsubazeriMotion(uint8_t arg2)
	{
		_mSetDontPlayLoseTsubazeriMotion_mHRPc__QAEX_N_Z mFunc = (_mSetDontPlayLoseTsubazeriMotion_mHRPc__QAEX_N_Z)(GameModule + 0xaa690);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDontPlayLoseTsubazeriMotion(class mHRPc* const this) [?mGetDontPlayLoseTsubazeriMotion@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDontPlayLoseTsubazeriMotion_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDontPlayLoseTsubazeriMotion()
	{
		_mGetDontPlayLoseTsubazeriMotion_mHRPc__QAE_NXZ mFunc = (_mGetDontPlayLoseTsubazeriMotion_mHRPc__QAE_NXZ)(GameModule + 0xaa6a0);
		return mFunc(this);
	}
	// [Function] bool __convention("thiscall") mHRPc::mGetNoWearJacket(class mHRPc* const this) [?mGetNoWearJacket@mHRPc@@QAE_NXZ]
	typedef bool(__thiscall* _mGetNoWearJacket_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	bool mGetNoWearJacket()
	{
		_mGetNoWearJacket_mHRPc__QAE_NXZ mFunc = (_mGetNoWearJacket_mHRPc__QAE_NXZ)(GameModule + 0xaa6b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDispChangeWeaponIcon(class mHRPc* const this, bool Input) [?mSetDispChangeWeaponIcon@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDispChangeWeaponIcon_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Input);
	void mSetDispChangeWeaponIcon(bool Input)
	{
		_mSetDispChangeWeaponIcon_mHRPc__QAEX_N_Z mFunc = (_mSetDispChangeWeaponIcon_mHRPc__QAEX_N_Z)(GameModule + 0xaa6c0);
		return mFunc(this, Input);
	}
	// [Function] bool __convention("thiscall") mHRPc::mGetDispChangeWeaponIcon(class mHRPc* const this) [?mGetDispChangeWeaponIcon@mHRPc@@QAE_NXZ]
	typedef bool(__thiscall* _mGetDispChangeWeaponIcon_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	bool mGetDispChangeWeaponIcon()
	{
		_mGetDispChangeWeaponIcon_mHRPc__QAE_NXZ mFunc = (_mGetDispChangeWeaponIcon_mHRPc__QAE_NXZ)(GameModule + 0xaa6d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetStandUpAttack(class mHRPc* const this, uint8_t arg2) [?mSetStandUpAttack@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetStandUpAttack_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetStandUpAttack(uint8_t arg2)
	{
		_mSetStandUpAttack_mHRPc__QAEX_N_Z mFunc = (_mSetStandUpAttack_mHRPc__QAEX_N_Z)(GameModule + 0xaa6e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetStandUpAttack(class mHRPc* const this) [?mGetStandUpAttack@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetStandUpAttack_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetStandUpAttack()
	{
		_mGetStandUpAttack_mHRPc__QAE_NXZ mFunc = (_mGetStandUpAttack_mHRPc__QAE_NXZ)(GameModule + 0xaa6f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPushingBatteryChargeButton(class mHRPc* const this, bool Input) [?mSetPushingBatteryChargeButton@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetPushingBatteryChargeButton_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, bool Input);
	void mSetPushingBatteryChargeButton(bool Input)
	{
		_mSetPushingBatteryChargeButton_mHRPc__QAEX_N_Z mFunc = (_mSetPushingBatteryChargeButton_mHRPc__QAEX_N_Z)(GameModule + 0xaa700);
		return mFunc(this, Input);
	}
	// [Function] bool __convention("thiscall") mHRPc::mGetPushingBatteryChargeButton(class mHRPc* const this) [?mGetPushingBatteryChargeButton@mHRPc@@QAE_NXZ]
	typedef bool(__thiscall* _mGetPushingBatteryChargeButton_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	bool mGetPushingBatteryChargeButton()
	{
		_mGetPushingBatteryChargeButton_mHRPc__QAE_NXZ mFunc = (_mGetPushingBatteryChargeButton_mHRPc__QAE_NXZ)(GameModule + 0xaa710);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetHitBigConsumeBattertAttack(class mHRPc* const this, uint8_t arg2) [?mSetHitBigConsumeBattertAttack@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetHitBigConsumeBattertAttack_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetHitBigConsumeBattertAttack(uint8_t arg2)
	{
		_mSetHitBigConsumeBattertAttack_mHRPc__QAEX_N_Z mFunc = (_mSetHitBigConsumeBattertAttack_mHRPc__QAEX_N_Z)(GameModule + 0xaa720);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetHitBigConsumeBattertAttack(class mHRPc* const this) [?mGetHitBigConsumeBattertAttack@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetHitBigConsumeBattertAttack_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetHitBigConsumeBattertAttack()
	{
		_mGetHitBigConsumeBattertAttack_mHRPc__QAE_NXZ mFunc = (_mGetHitBigConsumeBattertAttack_mHRPc__QAE_NXZ)(GameModule + 0xaa730);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetStartThrowSlow(class mHRPc* const this, uint8_t arg2) [?mSetStartThrowSlow@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetStartThrowSlow_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetStartThrowSlow(uint8_t arg2)
	{
		_mSetStartThrowSlow_mHRPc__QAEX_N_Z mFunc = (_mSetStartThrowSlow_mHRPc__QAEX_N_Z)(GameModule + 0xaa740);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetStartThrowSlow(class mHRPc* const this) [?mGetStartThrowSlow@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetStartThrowSlow_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetStartThrowSlow()
	{
		_mGetStartThrowSlow_mHRPc__QAE_NXZ mFunc = (_mGetStartThrowSlow_mHRPc__QAE_NXZ)(GameModule + 0xaa750);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetForceLoseTsubazeri(class mHRPc* const this) [?mGetForceLoseTsubazeri@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetForceLoseTsubazeri_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetForceLoseTsubazeri()
	{
		_mGetForceLoseTsubazeri_mHRPc__QAE_NXZ mFunc = (_mGetForceLoseTsubazeri_mHRPc__QAE_NXZ)(GameModule + 0xaa760);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetEqWepID(class mHRPc* const this) [?mGetEqWepID@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetEqWepID_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetEqWepID()
	{
		_mGetEqWepID_mHRPc__QAEHXZ mFunc = (_mGetEqWepID_mHRPc__QAEHXZ)(GameModule + 0xaa770);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetWepCmbExtend(class mHRPc* const this, int32_t arg2) [?mGetWepCmbExtend@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mGetWepCmbExtend_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mGetWepCmbExtend(int32_t arg2)
	{
		_mGetWepCmbExtend_mHRPc__QAE_NH_Z mFunc = (_mGetWepCmbExtend_mHRPc__QAE_NH_Z)(GameModule + 0xaa780);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDeadMotionPlayFlag(class mHRPc* const this, uint8_t arg2) [?mSetDeadMotionPlayFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDeadMotionPlayFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDeadMotionPlayFlag(uint8_t arg2)
	{
		_mSetDeadMotionPlayFlag_mHRPc__QAEX_N_Z mFunc = (_mSetDeadMotionPlayFlag_mHRPc__QAEX_N_Z)(GameModule + 0xadc30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::getNPCInterestPosition(class mHRPc* const this, struct Vec* arg2) [?getNPCInterestPosition@mHRPc@@QBEXPAUVec@@@Z]
	typedef void(__thiscall* _getNPCInterestPosition_mHRPc__QBEXPAUVec___Z)(class mHRPc* const thisPtr, struct Vec* arg2);
	void getNPCInterestPosition(struct Vec* arg2)
	{
		_getNPCInterestPosition_mHRPc__QBEXPAUVec___Z mFunc = (_getNPCInterestPosition_mHRPc__QBEXPAUVec___Z)(GameModule + 0xae390);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetStammina(class mHRPc* const this) [?mGetStammina@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetStammina_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetStammina()
	{
		_mGetStammina_mHRPc__QAEMXZ mFunc = (_mGetStammina_mHRPc__QAEMXZ)(GameModule + 0xaf9f0);
		return mFunc(this);
	}
	// [Function] struct stPcStatus* __convention("thiscall") mHRPc::mGetPcStatusPtr(class mHRPc* const this) [?mGetPcStatusPtr@mHRPc@@QAEPAUstPcStatus@@XZ]
	typedef struct stPcStatus*(__thiscall* _mGetPcStatusPtr_mHRPc__QAEPAUstPcStatus__XZ)(class mHRPc* const thisPtr);
	struct stPcStatus* mGetPcStatusPtr()
	{
		_mGetPcStatusPtr_mHRPc__QAEPAUstPcStatus__XZ mFunc = (_mGetPcStatusPtr_mHRPc__QAEPAUstPcStatus__XZ)(GameModule + 0xaff30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBikeVisible(class mHRPc* const this) [?mGetBikeVisible@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBikeVisible_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBikeVisible()
	{
		_mGetBikeVisible_mHRPc__QAE_NXZ mFunc = (_mGetBikeVisible_mHRPc__QAE_NXZ)(GameModule + 0xaff40);
		return mFunc(this);
	}
	// [Function] char __convention("thiscall") mHRPc::mGetFinishNpcNum(class mHRPc* const this) [?mGetFinishNpcNum@mHRPc@@QAECXZ]
	typedef char(__thiscall* _mGetFinishNpcNum_mHRPc__QAECXZ)(class mHRPc* const thisPtr);
	char mGetFinishNpcNum()
	{
		_mGetFinishNpcNum_mHRPc__QAECXZ mFunc = (_mGetFinishNpcNum_mHRPc__QAECXZ)(GameModule + 0xaff50);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetLockOnDummyPtr(class mHRPc* const this) [?mGetLockOnDummyPtr@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mGetLockOnDummyPtr_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mGetLockOnDummyPtr()
	{
		_mGetLockOnDummyPtr_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mGetLockOnDummyPtr_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0xaff60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCallMotionProcess(class mHRPc* const this) [?mGetCallMotionProcess@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetCallMotionProcess_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetCallMotionProcess()
	{
		_mGetCallMotionProcess_mHRPc__QAE_NXZ mFunc = (_mGetCallMotionProcess_mHRPc__QAE_NXZ)(GameModule + 0xaff70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDeadBossNum(class mHRPc* const this, uint32_t arg2) [?mSetDeadBossNum@mHRPc@@QAEXI@Z]
	typedef void(__thiscall* _mSetDeadBossNum_mHRPc__QAEXI_Z)(class mHRPc* const thisPtr, uint32_t arg2);
	void mSetDeadBossNum(uint32_t arg2)
	{
		_mSetDeadBossNum_mHRPc__QAEXI_Z mFunc = (_mSetDeadBossNum_mHRPc__QAEXI_Z)(GameModule + 0xaff80);
		return mFunc(this, arg2);
	}
	// [Function] struct stThrowInfo* __convention("thiscall") mHRPc::mGetThrowInfoPtr(class mHRPc* const this) [?mGetThrowInfoPtr@mHRPc@@QAEPAUstThrowInfo@@XZ]
	typedef struct stThrowInfo*(__thiscall* _mGetThrowInfoPtr_mHRPc__QAEPAUstThrowInfo__XZ)(class mHRPc* const thisPtr);
	struct stThrowInfo* mGetThrowInfoPtr()
	{
		_mGetThrowInfoPtr_mHRPc__QAEPAUstThrowInfo__XZ mFunc = (_mGetThrowInfoPtr_mHRPc__QAEPAUstThrowInfo__XZ)(GameModule + 0xaff90);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetCatchNpc(class mHRPc* const this) [?mGetCatchNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mGetCatchNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mGetCatchNpc()
	{
		_mGetCatchNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mGetCatchNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0xaffa0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishAttackJustBeforeHitSlow(class mHRPc* const this) [?mCheckFinishAttackJustBeforeHitSlow@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckFinishAttackJustBeforeHitSlow_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckFinishAttackJustBeforeHitSlow()
	{
		_mCheckFinishAttackJustBeforeHitSlow_mHRPc__QAE_NXZ mFunc = (_mCheckFinishAttackJustBeforeHitSlow_mHRPc__QAE_NXZ)(GameModule + 0xb51e0);
		return mFunc(this);
	}
	// [Function] struct stPcEffect* __convention("thiscall") mHRPc::mGetPcEffectPtr(class mHRPc* const this) [?mGetPcEffectPtr@mHRPc@@QAEPAUstPcEffect@@XZ]
	typedef struct stPcEffect*(__thiscall* _mGetPcEffectPtr_mHRPc__QAEPAUstPcEffect__XZ)(class mHRPc* const thisPtr);
	struct stPcEffect* mGetPcEffectPtr()
	{
		_mGetPcEffectPtr_mHRPc__QAEPAUstPcEffect__XZ mFunc = (_mGetPcEffectPtr_mHRPc__QAEPAUstPcEffect__XZ)(GameModule + 0xb9b80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCallBikeFlag(class mHRPc* const this) [?mGetCallBikeFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetCallBikeFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetCallBikeFlag()
	{
		_mGetCallBikeFlag_mHRPc__QAE_NXZ mFunc = (_mGetCallBikeFlag_mHRPc__QAE_NXZ)(GameModule + 0xb9b90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetLostBikeFlag(class mHRPc* const this) [?mGetLostBikeFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetLostBikeFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetLostBikeFlag()
	{
		_mGetLostBikeFlag_mHRPc__QAE_NXZ mFunc = (_mGetLostBikeFlag_mHRPc__QAE_NXZ)(GameModule + 0xb9ba0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBikeSight(class mHRPc* const this, uint8_t arg2) [?mSetBikeSight@mHRPc@@QAEXE@Z]
	typedef void(__thiscall* _mSetBikeSight_mHRPc__QAEXE_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetBikeSight(uint8_t arg2)
	{
		_mSetBikeSight_mHRPc__QAEXE_Z mFunc = (_mSetBikeSight_mHRPc__QAEXE_Z)(GameModule + 0xb9bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontChangeBikeCamera(class mHRPc* const this, uint8_t arg2) [?mSetDontChangeBikeCamera@mHRPc@@QAEXE@Z]
	typedef void(__thiscall* _mSetDontChangeBikeCamera_mHRPc__QAEXE_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDontChangeBikeCamera(uint8_t arg2)
	{
		_mSetDontChangeBikeCamera_mHRPc__QAEXE_Z mFunc = (_mSetDontChangeBikeCamera_mHRPc__QAEXE_Z)(GameModule + 0xb9bc0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetOnlyMove(class mHRPc* const this) [?mGetOnlyMove@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetOnlyMove_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetOnlyMove()
	{
		_mGetOnlyMove_mHRPc__QAE_NXZ mFunc = (_mGetOnlyMove_mHRPc__QAE_NXZ)(GameModule + 0xb9be0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDeadPauseFlag(class mHRPc* const this) [?mGetDeadPauseFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDeadPauseFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDeadPauseFlag()
	{
		_mGetDeadPauseFlag_mHRPc__QAE_NXZ mFunc = (_mGetDeadPauseFlag_mHRPc__QAE_NXZ)(GameModule + 0xba080);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTameMax(class mHRPc* const this) [?mCheckTameMax@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckTameMax_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckTameMax()
	{
		_mCheckTameMax_mHRPc__QAE_NXZ mFunc = (_mCheckTameMax_mHRPc__QAE_NXZ)(GameModule + 0xba6b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestHitFinishAttack(class mHRPc* const this) [?mTestHitFinishAttack@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestHitFinishAttack_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestHitFinishAttack()
	{
		_mTestHitFinishAttack_mHRPc__QAE_NXZ mFunc = (_mTestHitFinishAttack_mHRPc__QAE_NXZ)(GameModule + 0xba6c0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetFinishJudgeFrame(class mHRPc* const this) [?mGetFinishJudgeFrame@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetFinishJudgeFrame_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetFinishJudgeFrame()
	{
		_mGetFinishJudgeFrame_mHRPc__QAEHXZ mFunc = (_mGetFinishJudgeFrame_mHRPc__QAEHXZ)(GameModule + 0xbadc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCmbNum(class mHRPc* const this) [?mGetCmbNum@mHRPc@@QAEEXZ]
	typedef uint8_t(__thiscall* _mGetCmbNum_mHRPc__QAEEXZ)(class mHRPc* const thisPtr);
	uint8_t mGetCmbNum()
	{
		_mGetCmbNum_mHRPc__QAEEXZ mFunc = (_mGetCmbNum_mHRPc__QAEEXZ)(GameModule + 0xbadd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOnlyFlagBattouDemo(class mHRPc* const this, uint8_t arg2) [?mSetOnlyFlagBattouDemo@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetOnlyFlagBattouDemo_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetOnlyFlagBattouDemo(uint8_t arg2)
	{
		_mSetOnlyFlagBattouDemo_mHRPc__QAEX_N_Z mFunc = (_mSetOnlyFlagBattouDemo_mHRPc__QAEX_N_Z)(GameModule + 0xbfc80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOnlyFlagNoutouDemo(class mHRPc* const this, uint8_t arg2) [?mSetOnlyFlagNoutouDemo@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetOnlyFlagNoutouDemo_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetOnlyFlagNoutouDemo(uint8_t arg2)
	{
		_mSetOnlyFlagNoutouDemo_mHRPc__QAEX_N_Z mFunc = (_mSetOnlyFlagNoutouDemo_mHRPc__QAEX_N_Z)(GameModule + 0xbfc90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLockOnThroughWall(class mHRPc* const this, uint8_t arg2) [?mSetLockOnThroughWall@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetLockOnThroughWall_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetLockOnThroughWall(uint8_t arg2)
	{
		_mSetLockOnThroughWall_mHRPc__QAEX_N_Z mFunc = (_mSetLockOnThroughWall_mHRPc__QAEX_N_Z)(GameModule + 0xc2fd0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mIsDoingFinishMotion(class mHRPc* const this) [?mIsDoingFinishMotion@mHRPc@@QBE_NXZ]
	typedef uint8_t(__thiscall* _mIsDoingFinishMotion_mHRPc__QBE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mIsDoingFinishMotion()
	{
		_mIsDoingFinishMotion_mHRPc__QBE_NXZ mFunc = (_mIsDoingFinishMotion_mHRPc__QBE_NXZ)(GameModule + 0xcdb80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetSlashModeOnly(class mHRPc* const this) [?mGetSlashModeOnly@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetSlashModeOnly_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetSlashModeOnly()
	{
		_mGetSlashModeOnly_mHRPc__QAE_NXZ mFunc = (_mGetSlashModeOnly_mHRPc__QAE_NXZ)(GameModule + 0xcdb90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanRollEscape(class mHRPc* const this) [?mGetBanRollEscape@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetBanRollEscape_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetBanRollEscape()
	{
		_mGetBanRollEscape_mHRPc__QAE_NXZ mFunc = (_mGetBanRollEscape_mHRPc__QAE_NXZ)(GameModule + 0xcdba0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDashAtkDisEnable(class mHRPc* const this) [?mGetDashAtkDisEnable@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetDashAtkDisEnable_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetDashAtkDisEnable()
	{
		_mGetDashAtkDisEnable_mHRPc__QAE_NXZ mFunc = (_mGetDashAtkDisEnable_mHRPc__QAE_NXZ)(GameModule + 0xcdbb0);
		return mFunc(this);
	}
	// [Function] struct HRSAVEDATA_SHOP* __convention("thiscall") mHRPc::mGetShopDataPtr(class mHRPc* const this) [?mGetShopDataPtr@mHRPc@@QAEPAUHRSAVEDATA_SHOP@@XZ]
	typedef struct HRSAVEDATA_SHOP*(__thiscall* _mGetShopDataPtr_mHRPc__QAEPAUHRSAVEDATA_SHOP__XZ)(class mHRPc* const thisPtr);
	struct HRSAVEDATA_SHOP* mGetShopDataPtr()
	{
		_mGetShopDataPtr_mHRPc__QAEPAUHRSAVEDATA_SHOP__XZ mFunc = (_mGetShopDataPtr_mHRPc__QAEPAUHRSAVEDATA_SHOP__XZ)(GameModule + 0xd0500);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetCatchTick(class mHRPc* const this) [?mGetCatchTick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetCatchTick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetCatchTick()
	{
		_mGetCatchTick_mHRPc__QAEHXZ mFunc = (_mGetCatchTick_mHRPc__QAEHXZ)(GameModule + 0xd8a50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockAllMoves(class mHRPc* const this) [?UnlockAllMoves@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _UnlockAllMoves_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void UnlockAllMoves()
	{
		_UnlockAllMoves_mHRPc__AAEXXZ mFunc = (_UnlockAllMoves_mHRPc__AAEXXZ)(GameModule + 0x41a030);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockAllUpgrades(class mHRPc* const this) [?UnlockAllUpgrades@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _UnlockAllUpgrades_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void UnlockAllUpgrades()
	{
		_UnlockAllUpgrades_mHRPc__AAEXXZ mFunc = (_UnlockAllUpgrades_mHRPc__AAEXXZ)(GameModule + 0x41a060);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockAllPcUpgrades(class mHRPc* const this) [?UnlockAllPcUpgrades@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _UnlockAllPcUpgrades_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void UnlockAllPcUpgrades()
	{
		_UnlockAllPcUpgrades_mHRPc__AAEXXZ mFunc = (_UnlockAllPcUpgrades_mHRPc__AAEXXZ)(GameModule + 0x41a200);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::SwitchToMainWeapon(class mHRPc* const this) [?SwitchToMainWeapon@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _SwitchToMainWeapon_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void SwitchToMainWeapon()
	{
		_SwitchToMainWeapon_mHRPc__AAEXXZ mFunc = (_SwitchToMainWeapon_mHRPc__AAEXXZ)(GameModule + 0x41a220);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockAllWeapons(class mHRPc* const this) [?UnlockAllWeapons@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _UnlockAllWeapons_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void UnlockAllWeapons()
	{
		_UnlockAllWeapons_mHRPc__AAEXXZ mFunc = (_UnlockAllWeapons_mHRPc__AAEXXZ)(GameModule + 0x41a270);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::SubPcNowEquipBatteryRatio(class mHRPc* const this, float const arg2) [?SubPcNowEquipBatteryRatio@mHRPc@@QAEXM@Z]
	typedef void(__thiscall* _SubPcNowEquipBatteryRatio_mHRPc__QAEXM_Z)(class mHRPc* const thisPtr, float const arg2);
	void SubPcNowEquipBatteryRatio(float const arg2)
	{
		_SubPcNowEquipBatteryRatio_mHRPc__QAEXM_Z mFunc = (_SubPcNowEquipBatteryRatio_mHRPc__QAEXM_Z)(GameModule + 0x41a380);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::isAcceptCameraFollowRotation(class mHRPc* const this) [?isAcceptCameraFollowRotation@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _isAcceptCameraFollowRotation_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t isAcceptCameraFollowRotation()
	{
		_isAcceptCameraFollowRotation_mHRPc__QAE_NXZ mFunc = (_isAcceptCameraFollowRotation_mHRPc__QAE_NXZ)(GameModule + 0x41a3e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestCanDownAttack(class mHRPc* const this, class mHRChara* arg2) [?mTestCanDownAttack@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mTestCanDownAttack_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mTestCanDownAttack(class mHRChara* arg2)
	{
		_mTestCanDownAttack_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mTestCanDownAttack_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x41a400);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestRunWeaponEffect(class mHRPc* const this, int32_t arg2) [?mTestRunWeaponEffect@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mTestRunWeaponEffect_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mTestRunWeaponEffect(int32_t arg2)
	{
		_mTestRunWeaponEffect_mHRPc__QAE_NH_Z mFunc = (_mTestRunWeaponEffect_mHRPc__QAE_NH_Z)(GameModule + 0x41a440);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mFloorEventProc(class mHRPc* const this) [?mFloorEventProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mFloorEventProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mFloorEventProc()
	{
		_mFloorEventProc_mHRPc__QAEXXZ mFunc = (_mFloorEventProc_mHRPc__QAEXXZ)(GameModule + 0x41a550);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallClearProcessBeforeEvent(class mHRPc* const this) [?mCallClearProcessBeforeEvent@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCallClearProcessBeforeEvent_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCallClearProcessBeforeEvent()
	{
		_mCallClearProcessBeforeEvent_mHRPc__QAEXXZ mFunc = (_mCallClearProcessBeforeEvent_mHRPc__QAEXXZ)(GameModule + 0x41aa70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetSlowMotion(class mHRPc* const this) [?mGetSlowMotion@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetSlowMotion_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetSlowMotion()
	{
		_mGetSlowMotion_mHRPc__QAE_NXZ mFunc = (_mGetSlowMotion_mHRPc__QAE_NXZ)(GameModule + 0x41ab40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSlowMotionProc(class mHRPc* const this) [?mSlowMotionProc@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mSlowMotionProc_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mSlowMotionProc()
	{
		_mSlowMotionProc_mHRPc__QAE_NXZ mFunc = (_mSlowMotionProc_mHRPc__QAE_NXZ)(GameModule + 0x41ab60);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mSlowMotionSystem(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mSlowMotionSystem@mHRPc@@QAEHHH@Z]
	typedef int32_t(__thiscall* _mSlowMotionSystem_mHRPc__QAEHHH_Z)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
	int32_t mSlowMotionSystem(int32_t arg2, int32_t arg3)
	{
		_mSlowMotionSystem_mHRPc__QAEHHH_Z mFunc = (_mSlowMotionSystem_mHRPc__QAEHHH_Z)(GameModule + 0x41abc0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mDeadProc(class mHRPc* const this, uint8_t arg2) [?mDeadProc@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mDeadProc_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mDeadProc(uint8_t arg2)
	{
		_mDeadProc_mHRPc__QAEX_N_Z mFunc = (_mDeadProc_mHRPc__QAEX_N_Z)(GameModule + 0x41ac40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::IncSwingCount(class mHRPc* const this) [?IncSwingCount@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _IncSwingCount_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void IncSwingCount()
	{
		_IncSwingCount_mHRPc__QAEXXZ mFunc = (_IncSwingCount_mHRPc__QAEXXZ)(GameModule + 0x41af90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::TestStoreBikePosForSM(class mHRPc* const this) [?TestStoreBikePosForSM@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _TestStoreBikePosForSM_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t TestStoreBikePosForSM()
	{
		_TestStoreBikePosForSM_mHRPc__QAE_NXZ mFunc = (_TestStoreBikePosForSM_mHRPc__QAE_NXZ)(GameModule + 0x41afa0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::ReStoreBikePosForSM(class mHRPc* const this) [?ReStoreBikePosForSM@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _ReStoreBikePosForSM_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void ReStoreBikePosForSM()
	{
		_ReStoreBikePosForSM_mHRPc__QAEXXZ mFunc = (_ReStoreBikePosForSM_mHRPc__QAEXXZ)(GameModule + 0x41afb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDigHoleProc(class mHRPc* const this) [?mDigHoleProc@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mDigHoleProc_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mDigHoleProc()
	{
		_mDigHoleProc_mHRPc__QAE_NXZ mFunc = (_mDigHoleProc_mHRPc__QAE_NXZ)(GameModule + 0x41b040);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestDigHoleAction(class mHRPc* const this) [?mTestDigHoleAction@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestDigHoleAction_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestDigHoleAction()
	{
		_mTestDigHoleAction_mHRPc__QAE_NXZ mFunc = (_mTestDigHoleAction_mHRPc__QAE_NXZ)(GameModule + 0x41b1d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::PcInputMove(class mHRPc* const this) [?PcInputMove@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _PcInputMove_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t PcInputMove()
	{
		_PcInputMove_mHRPc__QAE_NXZ mFunc = (_PcInputMove_mHRPc__QAE_NXZ)(GameModule + 0x41b1e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::PcInputIdleProc(class mHRPc* const this) [?PcInputIdleProc@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _PcInputIdleProc_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t PcInputIdleProc()
	{
		_PcInputIdleProc_mHRPc__QAE_NXZ mFunc = (_PcInputIdleProc_mHRPc__QAE_NXZ)(GameModule + 0x41b410);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestCatchZako(class mHRPc* const this) [?mTestCatchZako@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestCatchZako_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestCatchZako()
	{
		_mTestCatchZako_mHRPc__QAE_NXZ mFunc = (_mTestCatchZako_mHRPc__QAE_NXZ)(GameModule + 0x41b7c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mRestore1stChBGM(class mHRPc* const this, uint8_t arg2) [?mRestore1stChBGM@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mRestore1stChBGM_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mRestore1stChBGM(uint8_t arg2)
	{
		_mRestore1stChBGM_mHRPc__QAEX_N_Z mFunc = (_mRestore1stChBGM_mHRPc__QAEX_N_Z)(GameModule + 0x41b7e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlay2ndChBGM(class mHRPc* const this, int32_t arg2, float arg3, uint8_t arg4) [?mPlay2ndChBGM@mHRPc@@QAEXHM_N@Z]
	typedef void(__thiscall* _mPlay2ndChBGM_mHRPc__QAEXHM_N_Z)(class mHRPc* const thisPtr, int32_t arg2, float arg3, uint8_t arg4);
	void mPlay2ndChBGM(int32_t arg2, float arg3, uint8_t arg4)
	{
		_mPlay2ndChBGM_mHRPc__QAEXHM_N_Z mFunc = (_mPlay2ndChBGM_mHRPc__QAEXHM_N_Z)(GameModule + 0x41b870);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetSmokeColor(class mHRPc* const this, struct GXColor* arg2) [?mGetSmokeColor@mHRPc@@QAEXPAUGXColor@@@Z]
	typedef void(__thiscall* _mGetSmokeColor_mHRPc__QAEXPAUGXColor___Z)(class mHRPc* const thisPtr, struct GXColor* arg2);
	void mGetSmokeColor(struct GXColor* arg2)
	{
		_mGetSmokeColor_mHRPc__QAEXPAUGXColor___Z mFunc = (_mGetSmokeColor_mHRPc__QAEXPAUGXColor___Z)(GameModule + 0x41b8e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mExitBatteryCharge(class mHRPc* const this) [?mExitBatteryCharge@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mExitBatteryCharge_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mExitBatteryCharge()
	{
		_mExitBatteryCharge_mHRPc__QAEXXZ mFunc = (_mExitBatteryCharge_mHRPc__QAEXXZ)(GameModule + 0x41b960);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mHitCheckNpc(class mHRPc* const this) [?mHitCheckNpc@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mHitCheckNpc_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mHitCheckNpc()
	{
		_mHitCheckNpc_mHRPc__QAE_NXZ mFunc = (_mHitCheckNpc_mHRPc__QAE_NXZ)(GameModule + 0x41b980);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCherryFlag(class mHRPc* const this, uint8_t arg2) [?mSetCherryFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCherryFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetCherryFlag(uint8_t arg2)
	{
		_mSetCherryFlag_mHRPc__QAEX_N_Z mFunc = (_mSetCherryFlag_mHRPc__QAEX_N_Z)(GameModule + 0x41bb30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBossThrow(class mHRPc* const this, enum enCharaType arg2) [?mCheckBossThrow@mHRPc@@QAE_NW4enCharaType@@@Z]
	typedef uint8_t(__thiscall* _mCheckBossThrow_mHRPc__QAE_NW4enCharaType___Z)(class mHRPc* const thisPtr, enum enCharaType arg2);
	uint8_t mCheckBossThrow(/* enum enCharaType */ uint32_t arg2)
	{
		_mCheckBossThrow_mHRPc__QAE_NW4enCharaType___Z mFunc = (_mCheckBossThrow_mHRPc__QAE_NW4enCharaType___Z)(GameModule + 0x41bb40);
		return mFunc(this, (enum enCharaType)arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetJustGuardJudgeTick(class mHRPc* const this) [?mGetJustGuardJudgeTick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetJustGuardJudgeTick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetJustGuardJudgeTick()
	{
		_mGetJustGuardJudgeTick_mHRPc__QAEHXZ mFunc = (_mGetJustGuardJudgeTick_mHRPc__QAEHXZ)(GameModule + 0x41bc30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanFight(class mHRPc* const this) [?mCheckCanFight@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanFight_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckCanFight()
	{
		_mCheckCanFight_mHRPc__QAE_NXZ mFunc = (_mCheckCanFight_mHRPc__QAE_NXZ)(GameModule + 0x41bc70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearBomStockNum(class mHRPc* const this) [?mClearBomStockNum@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearBomStockNum_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearBomStockNum()
	{
		_mClearBomStockNum_mHRPc__QAEXXZ mFunc = (_mClearBomStockNum_mHRPc__QAEXXZ)(GameModule + 0x41bcb0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetSpecialAttackRestTick(class mHRPc* const this) [?mGetSpecialAttackRestTick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetSpecialAttackRestTick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetSpecialAttackRestTick()
	{
		_mGetSpecialAttackRestTick_mHRPc__QAEHXZ mFunc = (_mGetSpecialAttackRestTick_mHRPc__QAEHXZ)(GameModule + 0x41bcc0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetEmptyShinkuWaveIndex(class mHRPc* const this) [?mGetEmptyShinkuWaveIndex@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetEmptyShinkuWaveIndex_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetEmptyShinkuWaveIndex()
	{
		_mGetEmptyShinkuWaveIndex_mHRPc__QAEHXZ mFunc = (_mGetEmptyShinkuWaveIndex_mHRPc__QAEHXZ)(GameModule + 0x41bcd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCreateShinkuWave(class mHRPc* const this) [?mCreateShinkuWave@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCreateShinkuWave_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCreateShinkuWave()
	{
		_mCreateShinkuWave_mHRPc__QAEXXZ mFunc = (_mCreateShinkuWave_mHRPc__QAEXXZ)(GameModule + 0x41bcf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallEffectBlur(class mHRPc* const this, int32_t arg2, float arg3, float arg4, int32_t arg5) [?mCallEffectBlur@mHRPc@@QAEXHMMH@Z]
	typedef void(__thiscall* _mCallEffectBlur_mHRPc__QAEXHMMH_Z)(class mHRPc* const thisPtr, int32_t arg2, float arg3, float arg4, int32_t arg5);
	void mCallEffectBlur(int32_t arg2, float arg3, float arg4, int32_t arg5)
	{
		_mCallEffectBlur_mHRPc__QAEXHMMH_Z mFunc = (_mCallEffectBlur_mHRPc__QAEXHMMH_Z)(GameModule + 0x41beb0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLaserTrack(class mHRPc* const this, uint8_t arg2, int32_t arg3, int32_t arg4) [?mSetLaserTrack@mHRPc@@QAEX_NHH@Z]
	typedef void(__thiscall* _mSetLaserTrack_mHRPc__QAEX_NHH_Z)(class mHRPc* const thisPtr, uint8_t arg2, int32_t arg3, int32_t arg4);
	void mSetLaserTrack(uint8_t arg2, int32_t arg3, int32_t arg4)
	{
		_mSetLaserTrack_mHRPc__QAEX_NHH_Z mFunc = (_mSetLaserTrack_mHRPc__QAEX_NHH_Z)(GameModule + 0x41bf30);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLaserScale(class mHRPc* const this, float arg2) [?mSetLaserScale@mHRPc@@QAEXM@Z]
	typedef void(__thiscall* _mSetLaserScale_mHRPc__QAEXM_Z)(class mHRPc* const thisPtr, float arg2);
	void mSetLaserScale(float arg2)
	{
		_mSetLaserScale_mHRPc__QAEXM_Z mFunc = (_mSetLaserScale_mHRPc__QAEXM_Z)(GameModule + 0x41c120);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLaserLogValid(class mHRPc* const this, uint8_t arg2) [?mSetLaserLogValid@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetLaserLogValid_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetLaserLogValid(uint8_t arg2)
	{
		_mSetLaserLogValid_mHRPc__QAEX_N_Z mFunc = (_mSetLaserLogValid_mHRPc__QAEX_N_Z)(GameModule + 0x41c150);
		return mFunc(this, arg2);
	}
	// [Function] uint32_t __convention("thiscall") mHRPc::mGetLaserColor(class mHRPc* const this) [?mGetLaserColor@mHRPc@@QAEIXZ]
	typedef uint32_t(__thiscall* _mGetLaserColor_mHRPc__QAEIXZ)(class mHRPc* const thisPtr);
	uint32_t mGetLaserColor()
	{
		_mGetLaserColor_mHRPc__QAEIXZ mFunc = (_mGetLaserColor_mHRPc__QAEIXZ)(GameModule + 0x41c1a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLaserColor(class mHRPc* const this, uint8_t R, uint8_t G, uint8_t B, uint8_t A) [?mSetLaserColor@mHRPc@@QAEXEEEE@Z]
	typedef void(__thiscall* _mSetLaserColor_mHRPc__QAEXEEEE_Z)(class mHRPc* const thisPtr, uint8_t R, uint8_t G, uint8_t B, uint8_t A);
	void mSetLaserColor(uint8_t R, uint8_t G, uint8_t B, uint8_t A)
	{
		_mSetLaserColor_mHRPc__QAEXEEEE_Z mFunc = (_mSetLaserColor_mHRPc__QAEXEEEE_Z)(GameModule + 0x41c210);
		return mFunc(this, R, G, B, A);
	}
	// [Function] void __convention("thiscall") mHRPc::mCreateLaserEffect(class mHRPc* const this, int32_t arg2) [?mCreateLaserEffect@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mCreateLaserEffect_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mCreateLaserEffect(int32_t arg2)
	{
		_mCreateLaserEffect_mHRPc__QAEXH_Z mFunc = (_mCreateLaserEffect_mHRPc__QAEXH_Z)(GameModule + 0x41c270);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mDeleteChargeEffect(class mHRPc* const this, int32_t arg2) [?mDeleteChargeEffect@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mDeleteChargeEffect_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mDeleteChargeEffect(int32_t arg2)
	{
		_mDeleteChargeEffect_mHRPc__QAEXH_Z mFunc = (_mDeleteChargeEffect_mHRPc__QAEXH_Z)(GameModule + 0x41c540);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mCreateChargeEffect(class mHRPc* const this, int32_t arg2) [?mCreateChargeEffect@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mCreateChargeEffect_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mCreateChargeEffect(int32_t arg2)
	{
		_mCreateChargeEffect_mHRPc__QAEXH_Z mFunc = (_mCreateChargeEffect_mHRPc__QAEXH_Z)(GameModule + 0x41c570);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBigWeapon(class mHRPc* const this) [?mCheckBigWeapon@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckBigWeapon_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckBigWeapon()
	{
		_mCheckBigWeapon_mHRPc__QAE_NXZ mFunc = (_mCheckBigWeapon_mHRPc__QAE_NXZ)(GameModule + 0x41c620);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDigToolFlag(class mHRPc* const this, uint8_t arg2) [?mSetDigToolFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetDigToolFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetDigToolFlag(uint8_t arg2)
	{
		_mSetDigToolFlag_mHRPc__QAEX_N_Z mFunc = (_mSetDigToolFlag_mHRPc__QAEX_N_Z)(GameModule + 0x41c630);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearMMSMInit(class mHRPc* const this) [?mClearMMSMInit@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearMMSMInit_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearMMSMInit()
	{
		_mClearMMSMInit_mHRPc__QAEXXZ mFunc = (_mClearMMSMInit_mHRPc__QAEXXZ)(GameModule + 0x41c660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBikePos2Motel(class mHRPc* const this) [?mSetBikePos2Motel@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetBikePos2Motel_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetBikePos2Motel()
	{
		_mSetBikePos2Motel_mHRPc__QAEXXZ mFunc = (_mSetBikePos2Motel_mHRPc__QAEXXZ)(GameModule + 0x41c6d0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetStopRenderCounter(class mHRPc* const this) [?mGetStopRenderCounter@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetStopRenderCounter_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetStopRenderCounter()
	{
		_mGetStopRenderCounter_mHRPc__QAEHXZ mFunc = (_mGetStopRenderCounter_mHRPc__QAEHXZ)(GameModule + 0x41c700);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetStopRenderCounter(class mHRPc* const this) [?mSetStopRenderCounter@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetStopRenderCounter_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetStopRenderCounter()
	{
		_mSetStopRenderCounter_mHRPc__QAEXXZ mFunc = (_mSetStopRenderCounter_mHRPc__QAEXXZ)(GameModule + 0x41c720);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") mHRPc::mGetLightSideNum(class mHRPc* const this) [?mGetLightSideNum@mHRPc@@QAEIXZ]
	typedef uint32_t(__thiscall* _mGetLightSideNum_mHRPc__QAEIXZ)(class mHRPc* const thisPtr);
	uint32_t mGetLightSideNum()
	{
		_mGetLightSideNum_mHRPc__QAEIXZ mFunc = (_mGetLightSideNum_mHRPc__QAEIXZ)(GameModule + 0x41c730);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetReceiveDamage(class mHRPc* const this) [?mGetReceiveDamage@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetReceiveDamage_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetReceiveDamage()
	{
		_mGetReceiveDamage_mHRPc__QAEMXZ mFunc = (_mGetReceiveDamage_mHRPc__QAEMXZ)(GameModule + 0x41c760);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetMaxCombo(class mHRPc* const this) [?mGetMaxCombo@mHRPc@@QAEEXZ]
	typedef uint8_t(__thiscall* _mGetMaxCombo_mHRPc__QAEEXZ)(class mHRPc* const thisPtr);
	uint8_t mGetMaxCombo()
	{
		_mGetMaxCombo_mHRPc__QAEEXZ mFunc = (_mGetMaxCombo_mHRPc__QAEEXZ)(GameModule + 0x41c780);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDown(class mHRPc* const this, enum enDownStatus arg2, uint8_t arg3) [?mSetDown@mHRPc@@QAEXW4enDownStatus@@_N@Z]
	typedef void(__thiscall* _mSetDown_mHRPc__QAEXW4enDownStatus___N_Z)(class mHRPc* const thisPtr, enum enDownStatus arg2, uint8_t arg3);
	void mSetDown(/* enum enDownStatus */ uint32_t arg2, uint8_t arg3)
	{
		_mSetDown_mHRPc__QAEXW4enDownStatus___N_Z mFunc = (_mSetDown_mHRPc__QAEXW4enDownStatus___N_Z)(GameModule + 0x41c790);
		return mFunc(this, (enum enDownStatus)arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCallBikeFlag(class mHRPc* const this, uint8_t arg2) [?mSetCallBikeFlag@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetCallBikeFlag_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetCallBikeFlag(uint8_t arg2)
	{
		_mSetCallBikeFlag_mHRPc__QAEX_N_Z mFunc = (_mSetCallBikeFlag_mHRPc__QAEX_N_Z)(GameModule + 0x41c810);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetFireMan(class mHRPc* const this, float arg2) [?mSetFireMan@mHRPc@@QAEXM@Z]
	typedef void(__thiscall* _mSetFireMan_mHRPc__QAEXM_Z)(class mHRPc* const thisPtr, float arg2);
	void mSetFireMan(float arg2)
	{
		_mSetFireMan_mHRPc__QAEXM_Z mFunc = (_mSetFireMan_mHRPc__QAEXM_Z)(GameModule + 0x41c950);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetDarkSideUseNum(class mHRPc* const this) [?mGetDarkSideUseNum@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetDarkSideUseNum_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetDarkSideUseNum()
	{
		_mGetDarkSideUseNum_mHRPc__QAEHXZ mFunc = (_mGetDarkSideUseNum_mHRPc__QAEHXZ)(GameModule + 0x41c9d0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetLightSideRate(class mHRPc* const this) [?mGetLightSideRate@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetLightSideRate_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetLightSideRate()
	{
		_mGetLightSideRate_mHRPc__QAEMXZ mFunc = (_mGetLightSideRate_mHRPc__QAEMXZ)(GameModule + 0x41c9e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallSwordCutDmgEffect(class mHRPc* const this, class ghmTriangle* arg2, uint32_t const arg3) [?mCallSwordCutDmgEffect@mHRPc@@QAE_NPBVghmTriangle@@I@Z]
	typedef uint8_t(__thiscall* _mCallSwordCutDmgEffect_mHRPc__QAE_NPBVghmTriangle__I_Z)(class mHRPc* const thisPtr, class ghmTriangle* arg2, uint32_t const arg3);
	uint8_t mCallSwordCutDmgEffect(class ghmTriangle* arg2, uint32_t const arg3)
	{
		_mCallSwordCutDmgEffect_mHRPc__QAE_NPBVghmTriangle__I_Z mFunc = (_mCallSwordCutDmgEffect_mHRPc__QAE_NPBVghmTriangle__I_Z)(GameModule + 0x41ca00);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallBeamCutDmgEffect(class mHRPc* const this, class ghmTriangle* arg2, uint32_t const arg3) [?mCallBeamCutDmgEffect@mHRPc@@QAE_NPBVghmTriangle@@I@Z]
	typedef uint8_t(__thiscall* _mCallBeamCutDmgEffect_mHRPc__QAE_NPBVghmTriangle__I_Z)(class mHRPc* const thisPtr, class ghmTriangle* arg2, uint32_t const arg3);
	uint8_t mCallBeamCutDmgEffect(class ghmTriangle* arg2, uint32_t const arg3)
	{
		_mCallBeamCutDmgEffect_mHRPc__QAE_NPBVghmTriangle__I_Z mFunc = (_mCallBeamCutDmgEffect_mHRPc__QAE_NPBVghmTriangle__I_Z)(GameModule + 0x41cec0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallFightAttackDmgEffect(class mHRPc* const this, class mHRChara* arg2) [?mCallFightAttackDmgEffect@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mCallFightAttackDmgEffect_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mCallFightAttackDmgEffect(class mHRChara* arg2)
	{
		_mCallFightAttackDmgEffect_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mCallFightAttackDmgEffect_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x41d3d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallElectDmgEffect(class mHRPc* const this) [?mCallElectDmgEffect@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCallElectDmgEffect_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCallElectDmgEffect()
	{
		_mCallElectDmgEffect_mHRPc__QAE_NXZ mFunc = (_mCallElectDmgEffect_mHRPc__QAE_NXZ)(GameModule + 0x41d4f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallNormalAttackEffect(class mHRPc* const this, class mHRChara* arg2) [?mCallNormalAttackEffect@mHRPc@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mCallNormalAttackEffect_mHRPc__QAEXPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	void mCallNormalAttackEffect(class mHRChara* arg2)
	{
		_mCallNormalAttackEffect_mHRPc__QAEXPAVmHRChara___Z mFunc = (_mCallNormalAttackEffect_mHRPc__QAEXPAVmHRChara___Z)(GameModule + 0x41d7d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::IsCenteringHoseiCutmark(class mHRPc* const this) [?IsCenteringHoseiCutmark@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsCenteringHoseiCutmark_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t IsCenteringHoseiCutmark()
	{
		_IsCenteringHoseiCutmark_mHRPc__QAE_NXZ mFunc = (_IsCenteringHoseiCutmark_mHRPc__QAE_NXZ)(GameModule + 0x41dd90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::CreateCutMarkEffect(class mHRPc* const this, class mHRChara* arg2, enum eEfDmgLevel arg3) [?CreateCutMarkEffect@mHRPc@@QAEXPAVmHRChara@@W4eEfDmgLevel@@@Z]
	typedef void(__thiscall* _CreateCutMarkEffect_mHRPc__QAEXPAVmHRChara__W4eEfDmgLevel___Z)(class mHRPc* const thisPtr, class mHRChara* arg2, enum eEfDmgLevel arg3);
	void CreateCutMarkEffect(class mHRChara* arg2, /* enum eEfDmgLevel */ uint32_t arg3)
	{
		_CreateCutMarkEffect_mHRPc__QAEXPAVmHRChara__W4eEfDmgLevel___Z mFunc = (_CreateCutMarkEffect_mHRPc__QAEXPAVmHRChara__W4eEfDmgLevel___Z)(GameModule + 0x41ddc0);
		return mFunc(this, arg2, (enum eEfDmgLevel)arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::CreateGuardBreakEffect(class mHRPc* const this) [?CreateGuardBreakEffect@mHRPc@@QAEXXZ]
	/// <summary>
	/// Creates a spark effect at character torso / head.
	/// </summary>
	typedef void(__thiscall* _CreateGuardBreakEffect_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void CreateGuardBreakEffect()
	{
		_CreateGuardBreakEffect_mHRPc__QAEXXZ mFunc = (_CreateGuardBreakEffect_mHRPc__QAEXXZ)(GameModule + 0x41dfc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSePlayChargeAttack(class mHRPc* const this, class mHRChara* arg2) [?mSePlayChargeAttack@mHRPc@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mSePlayChargeAttack_mHRPc__QAEXPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	void mSePlayChargeAttack(class mHRChara* arg2)
	{
		_mSePlayChargeAttack_mHRPc__QAEXPAVmHRChara___Z mFunc = (_mSePlayChargeAttack_mHRPc__QAEXPAVmHRChara___Z)(GameModule + 0x41e010);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallFinishAttackEffect(class mHRPc* const this, class mHRChara* arg2) [?mCallFinishAttackEffect@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mCallFinishAttackEffect_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mCallFinishAttackEffect(class mHRChara* arg2)
	{
		_mCallFinishAttackEffect_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mCallFinishAttackEffect_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x41e090);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCreateHugGan(class mHRPc* const this, char* arg2, int32_t arg3) [?mCreateHugGan@mHRPc@@QAE_NPADH@Z]
	typedef uint8_t(__thiscall* _mCreateHugGan_mHRPc__QAE_NPADH_Z)(class mHRPc* const thisPtr, char* arg2, int32_t arg3);
	uint8_t mCreateHugGan(std::string arg2, int32_t arg3)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_mCreateHugGan_mHRPc__QAE_NPADH_Z mFunc = (_mCreateHugGan_mHRPc__QAE_NPADH_Z)(GameModule + 0x41e0b0);
		return mFunc(this, &arg2_c_str[0], arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayHugMotion(class mHRPc* const this, int32_t arg2, float arg3) [?mPlayHugMotion@mHRPc@@QAEXHM@Z]
	typedef void(__thiscall* _mPlayHugMotion_mHRPc__QAEXHM_Z)(class mHRPc* const thisPtr, int32_t arg2, float arg3);
	void mPlayHugMotion(int32_t arg2, float arg3)
	{
		_mPlayHugMotion_mHRPc__QAEXHM_Z mFunc = (_mPlayHugMotion_mHRPc__QAEXHM_Z)(GameModule + 0x41e1e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPoisonWalk(class mHRPc* const this, uint8_t arg2) [?mSetPoisonWalk@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetPoisonWalk_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetPoisonWalk(uint8_t arg2)
	{
		_mSetPoisonWalk_mHRPc__QAEX_N_Z mFunc = (_mSetPoisonWalk_mHRPc__QAEX_N_Z)(GameModule + 0x41e370);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetElectroShockBGMPitch(class mHRPc* const this) [?mSetElectroShockBGMPitch@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetElectroShockBGMPitch_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetElectroShockBGMPitch()
	{
		_mSetElectroShockBGMPitch_mHRPc__QAEXXZ mFunc = (_mSetElectroShockBGMPitch_mHRPc__QAEXXZ)(GameModule + 0x41e550);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckReadEndAtkMot(class mHRPc* const this) [?mCheckReadEndAtkMot@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckReadEndAtkMot_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckReadEndAtkMot()
	{
		_mCheckReadEndAtkMot_mHRPc__QAE_NXZ mFunc = (_mCheckReadEndAtkMot_mHRPc__QAE_NXZ)(GameModule + 0x41e5b0);
		return mFunc(this);
	}
	// [Function] enum enPcPose __convention("thiscall") mHRPc::mGetPcBtlPoseNowMotion(class mHRPc* const this, int32_t arg2) [?mGetPcBtlPoseNowMotion@mHRPc@@QAE?AW4enPcPose@@H@Z]
	typedef enum enPcPose(__thiscall* _mGetPcBtlPoseNowMotion_mHRPc__QAEAW4enPcPose__H_Z)(class mHRPc* const thisPtr, int32_t arg2);
	/* enum enPcPose */ uint32_t mGetPcBtlPoseNowMotion(int32_t arg2)
	{
		_mGetPcBtlPoseNowMotion_mHRPc__QAEAW4enPcPose__H_Z mFunc = (_mGetPcBtlPoseNowMotion_mHRPc__QAEAW4enPcPose__H_Z)(GameModule + 0x41e5c0);
		return (uint32_t)mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishNpc(class mHRPc* const this, class mHRChara* arg2) [?mCheckFinishNpc@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mCheckFinishNpc_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mCheckFinishNpc(class mHRChara* arg2)
	{
		_mCheckFinishNpc_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mCheckFinishNpc_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x41e830);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetHitEffectPos(class mHRPc* const this, struct Vec* arg2) [?mGetHitEffectPos@mHRPc@@QAEXPAUVec@@@Z]
	typedef void(__thiscall* _mGetHitEffectPos_mHRPc__QAEXPAUVec___Z)(class mHRPc* const thisPtr, struct Vec* arg2);
	void mGetHitEffectPos(struct Vec* arg2)
	{
		_mGetHitEffectPos_mHRPc__QAEXPAUVec___Z mFunc = (_mGetHitEffectPos_mHRPc__QAEXPAUVec___Z)(GameModule + 0x41e860);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetHitEffectPos(class mHRPc* const this, struct Vec* OutPos, struct Vec& arg3, uint8_t arg4) [?mGetHitEffectPos@mHRPc@@QAEXPAUVec@@ABU2@_N@Z]
	typedef void(__thiscall* _mGetHitEffectPos_mHRPc__QAEXPAUVec__ABU2__N_Z_2)(class mHRPc* const thisPtr, struct Vec* OutPos, struct Vec& arg3, uint8_t arg4);
	void mGetHitEffectPos_2(struct Vec* OutPos, struct Vec& arg3, uint8_t arg4)
	{
		_mGetHitEffectPos_mHRPc__QAEXPAUVec__ABU2__N_Z_2 mFunc = (_mGetHitEffectPos_mHRPc__QAEXPAUVec__ABU2__N_Z_2)(GameModule + 0x41e8c0);
		return mFunc(this, OutPos, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetNoutou(class mHRPc* const this, uint8_t arg2) [?mSetNoutou@mHRPc@@UAEX_N@Z]
	typedef void(__thiscall* _mSetNoutou_mHRPc__UAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetNoutou(uint8_t arg2)
	{
		_mSetNoutou_mHRPc__UAEX_N_Z mFunc = (_mSetNoutou_mHRPc__UAEX_N_Z)(GameModule + 0x41e9d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBattou(class mHRPc* const this, uint8_t arg2) [?mSetBattou@mHRPc@@UAEX_N@Z]
	typedef void(__thiscall* _mSetBattou_mHRPc__UAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetBattou(uint8_t arg2)
	{
		_mSetBattou_mHRPc__UAEX_N_Z mFunc = (_mSetBattou_mHRPc__UAEX_N_Z)(GameModule + 0x41eb40);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetBikeNitro(class mHRPc* const this) [?mGetBikeNitro@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetBikeNitro_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetBikeNitro()
	{
		_mGetBikeNitro_mHRPc__QAEMXZ mFunc = (_mGetBikeNitro_mHRPc__QAEMXZ)(GameModule + 0x41ed10);
		return mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") mHRPc::mGetBikeRot(class mHRPc* const this) [?mGetBikeRot@mHRPc@@QAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetBikeRot_mHRPc__QAEAAUVec__XZ)(class mHRPc* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetBikeRot()
	{
		_mGetBikeRot_mHRPc__QAEAAUVec__XZ mFunc = (_mGetBikeRot_mHRPc__QAEAAUVec__XZ)(GameModule + 0x41ed30);
		mFunc(this);
	}
	// [Function] char __convention("thiscall") mHRPc::mGetEquipDurabilityMax(class mHRPc* const this, int32_t arg2) [?mGetEquipDurabilityMax@mHRPc@@QAECH@Z]
	typedef char(__thiscall* _mGetEquipDurabilityMax_mHRPc__QAECH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	char mGetEquipDurabilityMax(int32_t arg2)
	{
		_mGetEquipDurabilityMax_mHRPc__QAECH_Z mFunc = (_mGetEquipDurabilityMax_mHRPc__QAECH_Z)(GameModule + 0x41ed40);
		return mFunc(this, arg2);
	}
	// [Function] char __convention("thiscall") mHRPc::mGetEquipDurability(class mHRPc* const this, int32_t arg2) [?mGetEquipDurability@mHRPc@@QAECH@Z]
	typedef char(__thiscall* _mGetEquipDurability_mHRPc__QAECH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	char mGetEquipDurability(int32_t arg2)
	{
		_mGetEquipDurability_mHRPc__QAECH_Z mFunc = (_mGetEquipDurability_mHRPc__QAECH_Z)(GameModule + 0x41ed50);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetOnlyEquip(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mSetOnlyEquip@mHRPc@@QAE_NH_N@Z]
	typedef uint8_t(__thiscall* _mSetOnlyEquip_mHRPc__QAE_NH_N_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
	uint8_t mSetOnlyEquip(int32_t arg2, uint8_t arg3)
	{
		_mSetOnlyEquip_mHRPc__QAE_NH_N_Z mFunc = (_mSetOnlyEquip_mHRPc__QAE_NH_N_Z)(GameModule + 0x41ed60);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mChangeWeapon4Debug(class mHRPc* const this, int32_t WeaponKind) [?mChangeWeapon4Debug@mHRPc@@QAEXH@Z]
	/// <summary>
	/// Swaps player weapon.
	/// </summary>
	typedef void(__thiscall* _mChangeWeapon4Debug_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t WeaponKind);
	void mChangeWeapon4Debug(int32_t WeaponKind)
	{
		_mChangeWeapon4Debug_mHRPc__QAEXH_Z mFunc = (_mChangeWeapon4Debug_mHRPc__QAEXH_Z)(GameModule + 0x41ede0);
		return mFunc(this, WeaponKind);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mChangeEquipID2KindIndex(class mHRPc* const this, int32_t arg2) [?mChangeEquipID2KindIndex@mHRPc@@QAEHH@Z]
	typedef int32_t(__thiscall* _mChangeEquipID2KindIndex_mHRPc__QAEHH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mChangeEquipID2KindIndex(int32_t arg2)
	{
		_mChangeEquipID2KindIndex_mHRPc__QAEHH_Z mFunc = (_mChangeEquipID2KindIndex_mHRPc__QAEHH_Z)(GameModule + 0x41ee20);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetLockerIndex(class mHRPc* const this, int32_t arg2) [?mGetLockerIndex@mHRPc@@QAEHH@Z]
	typedef int32_t(__thiscall* _mGetLockerIndex_mHRPc__QAEHH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mGetLockerIndex(int32_t arg2)
	{
		_mGetLockerIndex_mHRPc__QAEHH_Z mFunc = (_mGetLockerIndex_mHRPc__QAEHH_Z)(GameModule + 0x41ee40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDelLocker(class mHRPc* const this, int32_t arg2) [?mDelLocker@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mDelLocker_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mDelLocker(int32_t arg2)
	{
		_mDelLocker_mHRPc__QAE_NH_Z mFunc = (_mDelLocker_mHRPc__QAE_NH_Z)(GameModule + 0x41ee70);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetDamageRate(class mHRPc* const this) [?mGetDamageRate@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetDamageRate_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetDamageRate()
	{
		_mGetDamageRate_mHRPc__QAEMXZ mFunc = (_mGetDamageRate_mHRPc__QAEMXZ)(GameModule + 0x41eeb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepCmbExtend(class mHRPc* const this, int32_t InWepID, uint8_t CmbExtend) [?mSetWepCmbExtend@mHRPc@@QAEXH_N@Z]
	typedef void(__thiscall* _mSetWepCmbExtend_mHRPc__QAEXH_N_Z)(class mHRPc* const thisPtr, int32_t InWepID, uint8_t CmbExtend);
	void mSetWepCmbExtend(int32_t InWepID, uint8_t CmbExtend)
	{
		_mSetWepCmbExtend_mHRPc__QAEXH_N_Z mFunc = (_mSetWepCmbExtend_mHRPc__QAEXH_N_Z)(GameModule + 0x41eef0);
		return mFunc(this, InWepID, CmbExtend);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetWepPower(class mHRPc* const this, int32_t arg2) [?mGetWepPower@mHRPc@@QAEMH@Z]
	typedef float(__thiscall* _mGetWepPower_mHRPc__QAEMH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	float mGetWepPower(int32_t arg2)
	{
		_mGetWepPower_mHRPc__QAEMH_Z mFunc = (_mGetWepPower_mHRPc__QAEMH_Z)(GameModule + 0x41ef60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepPower(class mHRPc* const this, int32_t WepID, float Power) [?mSetWepPower@mHRPc@@QAEXHM@Z]
	typedef void(__thiscall* _mSetWepPower_mHRPc__QAEXHM_Z)(class mHRPc* const thisPtr, int32_t WepID, float Power);
	void mSetWepPower(int32_t WepID, float Power)
	{
		_mSetWepPower_mHRPc__QAEXHM_Z mFunc = (_mSetWepPower_mHRPc__QAEXHM_Z)(GameModule + 0x41ef70);
		return mFunc(this, WepID, Power);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDelWep(class mHRPc* const this, int32_t arg2) [?mDelWep@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mDelWep_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mDelWep(int32_t arg2)
	{
		_mDelWep_mHRPc__QAE_NH_Z mFunc = (_mDelWep_mHRPc__QAE_NH_Z)(GameModule + 0x41efa0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAddWep(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mAddWep@mHRPc@@QAE_NHH@Z]
	typedef uint8_t(__thiscall* _mAddWep_mHRPc__QAE_NHH_Z)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
	uint8_t mAddWep(int32_t arg2, int32_t arg3)
	{
		_mAddWep_mHRPc__QAE_NHH_Z mFunc = (_mAddWep_mHRPc__QAE_NHH_Z)(GameModule + 0x41efb0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mMissCatch(class mHRPc* const this) [?mMissCatch@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mMissCatch_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mMissCatch()
	{
		_mMissCatch_mHRPc__QAEXXZ mFunc = (_mMissCatch_mHRPc__QAEXXZ)(GameModule + 0x41efd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayThrowMissMotion(class mHRPc* const this) [?mPlayThrowMissMotion@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mPlayThrowMissMotion_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mPlayThrowMissMotion()
	{
		_mPlayThrowMissMotion_mHRPc__QAEXXZ mFunc = (_mPlayThrowMissMotion_mHRPc__QAEXXZ)(GameModule + 0x41f2a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDispThrowInput(class mHRPc* const this) [?mDispThrowInput@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mDispThrowInput_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mDispThrowInput()
	{
		_mDispThrowInput_mHRPc__QAEXXZ mFunc = (_mDispThrowInput_mHRPc__QAEXXZ)(GameModule + 0x41f3e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartThrowInput(class mHRPc* const this) [?mStartThrowInput@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartThrowInput_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartThrowInput()
	{
		_mStartThrowInput_mHRPc__QAEXXZ mFunc = (_mStartThrowInput_mHRPc__QAEXXZ)(GameModule + 0x41f740);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAdjustHitWallPosition(class mHRPc* const this, struct Vec* arg2) [?mAdjustHitWallPosition@mHRPc@@QAE_NPAUVec@@@Z]
	typedef uint8_t(__thiscall* _mAdjustHitWallPosition_mHRPc__QAE_NPAUVec___Z)(class mHRPc* const thisPtr, struct Vec* arg2);
	uint8_t mAdjustHitWallPosition(struct Vec* arg2)
	{
		_mAdjustHitWallPosition_mHRPc__QAE_NPAUVec___Z mFunc = (_mAdjustHitWallPosition_mHRPc__QAE_NPAUVec___Z)(GameModule + 0x41f840);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mStartThrowSNB(class mHRPc* const this) [?mStartThrowSNB@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mStartThrowSNB_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mStartThrowSNB()
	{
		_mStartThrowSNB_mHRPc__QAE_NXZ mFunc = (_mStartThrowSNB_mHRPc__QAE_NXZ)(GameModule + 0x41fd90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mFrameProcChangeScreen(class mHRPc* const this) [?mFrameProcChangeScreen@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mFrameProcChangeScreen_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mFrameProcChangeScreen()
	{
		_mFrameProcChangeScreen_mHRPc__QAEXXZ mFunc = (_mFrameProcChangeScreen_mHRPc__QAEXXZ)(GameModule + 0x420160);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMiniDemoForWarpPosSantDestroy(class mHRPc* const this) [?mPlayMiniDemoForWarpPosSantDestroy@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mPlayMiniDemoForWarpPosSantDestroy_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mPlayMiniDemoForWarpPosSantDestroy()
	{
		_mPlayMiniDemoForWarpPosSantDestroy_mHRPc__QAE_NXZ mFunc = (_mPlayMiniDemoForWarpPosSantDestroy_mHRPc__QAE_NXZ)(GameModule + 0x420460);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAfterWarpPosForSantDestroy(class mHRPc* const this) [?mSetAfterWarpPosForSantDestroy@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetAfterWarpPosForSantDestroy_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetAfterWarpPosForSantDestroy()
	{
		_mSetAfterWarpPosForSantDestroy_mHRPc__QAEXXZ mFunc = (_mSetAfterWarpPosForSantDestroy_mHRPc__QAEXXZ)(GameModule + 0x4205d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestEndWarpPosForSantDestroy(class mHRPc* const this) [?mTestEndWarpPosForSantDestroy@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestEndWarpPosForSantDestroy_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestEndWarpPosForSantDestroy()
	{
		_mTestEndWarpPosForSantDestroy_mHRPc__QAE_NXZ mFunc = (_mTestEndWarpPosForSantDestroy_mHRPc__QAE_NXZ)(GameModule + 0x420790);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetWarpPosForSantDestroy(class mHRPc* const this, int32_t arg2) [?mSetWarpPosForSantDestroy@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mSetWarpPosForSantDestroy_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mSetWarpPosForSantDestroy(int32_t arg2)
	{
		_mSetWarpPosForSantDestroy_mHRPc__QAE_NH_Z mFunc = (_mSetWarpPosForSantDestroy_mHRPc__QAE_NH_Z)(GameModule + 0x4207c0);
		return mFunc(this, arg2);
	}
	// [Function] enum enScreenChangeStatus __convention("thiscall") mHRPc::mGetChangeScreenStatus(class mHRPc* const this) [?mGetChangeScreenStatus@mHRPc@@QAE?AW4enScreenChangeStatus@@XZ]
	typedef enum enScreenChangeStatus(__thiscall* _mGetChangeScreenStatus_mHRPc__QAEAW4enScreenChangeStatus__XZ)(class mHRPc* const thisPtr);
	/* enum enScreenChangeStatus */ uint32_t mGetChangeScreenStatus()
	{
		_mGetChangeScreenStatus_mHRPc__QAEAW4enScreenChangeStatus__XZ mFunc = (_mGetChangeScreenStatus_mHRPc__QAEAW4enScreenChangeStatus__XZ)(GameModule + 0x420920);
		return (uint32_t)mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mEndChangeScreen(class mHRPc* const this, int32_t arg2) [?mEndChangeScreen@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mEndChangeScreen_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mEndChangeScreen(int32_t arg2)
	{
		_mEndChangeScreen_mHRPc__QAE_NH_Z mFunc = (_mEndChangeScreen_mHRPc__QAE_NH_Z)(GameModule + 0x4209a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mStartChangeScreen(class mHRPc* const this, enum enScreenChangeKind arg2, int32_t arg3) [?mStartChangeScreen@mHRPc@@QAE_NW4enScreenChangeKind@@H@Z]
	typedef uint8_t(__thiscall* _mStartChangeScreen_mHRPc__QAE_NW4enScreenChangeKind__H_Z)(class mHRPc* const thisPtr, enum enScreenChangeKind arg2, int32_t arg3);
	uint8_t mStartChangeScreen(/* enum enScreenChangeKind */ uint32_t arg2, int32_t arg3)
	{
		_mStartChangeScreen_mHRPc__QAE_NW4enScreenChangeKind__H_Z mFunc = (_mStartChangeScreen_mHRPc__QAE_NW4enScreenChangeKind__H_Z)(GameModule + 0x420a10);
		return mFunc(this, (enum enScreenChangeKind)arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBatteryMax(class mHRPc* const this, int16_t arg2, int32_t arg3) [?mSetBatteryMax@mHRPc@@QAEXFH@Z]
	typedef void(__thiscall* _mSetBatteryMax_mHRPc__QAEXFH_Z)(class mHRPc* const thisPtr, int16_t arg2, int32_t arg3);
	void mSetBatteryMax(int16_t arg2, int32_t arg3)
	{
		_mSetBatteryMax_mHRPc__QAEXFH_Z mFunc = (_mSetBatteryMax_mHRPc__QAEXFH_Z)(GameModule + 0x420af0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetBatteryRatio(class mHRPc* const this, int32_t arg2) [?mGetBatteryRatio@mHRPc@@QAEMH@Z]
	typedef float(__thiscall* _mGetBatteryRatio_mHRPc__QAEMH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	float mGetBatteryRatio(int32_t arg2)
	{
		_mGetBatteryRatio_mHRPc__QAEMH_Z mFunc = (_mGetBatteryRatio_mHRPc__QAEMH_Z)(GameModule + 0x420b30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSubBattery(class mHRPc* const this, int32_t arg2) [?mSubBattery@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mSubBattery_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mSubBattery(int32_t arg2)
	{
		_mSubBattery_mHRPc__QAEXH_Z mFunc = (_mSubBattery_mHRPc__QAEXH_Z)(GameModule + 0x420ba0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mAddBattery(class mHRPc* const this, int32_t arg2) [?mAddBattery@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mAddBattery_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mAddBattery(int32_t arg2)
	{
		_mAddBattery_mHRPc__QAEXH_Z mFunc = (_mAddBattery_mHRPc__QAEXH_Z)(GameModule + 0x420ca0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mRecoverNoutouWeaponBattery(class mHRPc* const this, int32_t arg2) [?mRecoverNoutouWeaponBattery@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mRecoverNoutouWeaponBattery_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mRecoverNoutouWeaponBattery(int32_t arg2)
	{
		_mRecoverNoutouWeaponBattery_mHRPc__QAEXH_Z mFunc = (_mRecoverNoutouWeaponBattery_mHRPc__QAEXH_Z)(GameModule + 0x420db0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionEscape(class mHRPc* const this, int32_t arg2) [?mPlayMotionEscape@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mPlayMotionEscape_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mPlayMotionEscape(int32_t arg2)
	{
		_mPlayMotionEscape_mHRPc__QAE_NH_Z mFunc = (_mPlayMotionEscape_mHRPc__QAE_NH_Z)(GameModule + 0x420e70);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetInputGuardSlide(class mHRPc* const this) [?mGetInputGuardSlide@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetInputGuardSlide_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetInputGuardSlide()
	{
		_mGetInputGuardSlide_mHRPc__QAE_NXZ mFunc = (_mGetInputGuardSlide_mHRPc__QAE_NXZ)(GameModule + 0x420f90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestLeftGuard(class mHRPc* const this) [?mTestLeftGuard@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestLeftGuard_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestLeftGuard()
	{
		_mTestLeftGuard_mHRPc__QAE_NXZ mFunc = (_mTestLeftGuard_mHRPc__QAE_NXZ)(GameModule + 0x4210c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestRightGuard(class mHRPc* const this) [?mTestRightGuard@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestRightGuard_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestRightGuard()
	{
		_mTestRightGuard_mHRPc__QAE_NXZ mFunc = (_mTestRightGuard_mHRPc__QAE_NXZ)(GameModule + 0x421110);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestUpGuard(class mHRPc* const this) [?mTestUpGuard@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestUpGuard_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestUpGuard()
	{
		_mTestUpGuard_mHRPc__QAE_NXZ mFunc = (_mTestUpGuard_mHRPc__QAE_NXZ)(GameModule + 0x421160);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetInputTurn(class mHRPc* const this) [?mGetInputTurn@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetInputTurn_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetInputTurn()
	{
		_mGetInputTurn_mHRPc__QAE_NXZ mFunc = (_mGetInputTurn_mHRPc__QAE_NXZ)(GameModule + 0x4211a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetAttackTimingFrame(class mHRPc* const this, int32_t arg2) [?mGetAttackTimingFrame@mHRPc@@QAEMH@Z]
	typedef float(__thiscall* _mGetAttackTimingFrame_mHRPc__QAEMH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	float mGetAttackTimingFrame(int32_t arg2)
	{
		_mGetAttackTimingFrame_mHRPc__QAEMH_Z mFunc = (_mGetAttackTimingFrame_mHRPc__QAEMH_Z)(GameModule + 0x421420);
		return mFunc(this, arg2);
	}
	// [Function] class ghmTriangle* __convention("thiscall") mHRPc::mGetLeftWepTrianglePtr(class mHRPc* const this) [?mGetLeftWepTrianglePtr@mHRPc@@QAEPAVghmTriangle@@XZ]
	typedef class ghmTriangle*(__thiscall* _mGetLeftWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ)(class mHRPc* const thisPtr);
	class ghmTriangle* mGetLeftWepTrianglePtr()
	{
		_mGetLeftWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ mFunc = (_mGetLeftWepTrianglePtr_mHRPc__QAEPAVghmTriangle__XZ)(GameModule + 0x421450);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetExtraComboMotionNo(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mGetExtraComboMotionNo@mHRPc@@UAEHHH@Z]
	typedef int32_t(__thiscall* _mGetExtraComboMotionNo_mHRPc__UAEHHH_Z)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
	int32_t mGetExtraComboMotionNo(int32_t arg2, int32_t arg3)
	{
		_mGetExtraComboMotionNo_mHRPc__UAEHHH_Z mFunc = (_mGetExtraComboMotionNo_mHRPc__UAEHHH_Z)(GameModule + 0x421470);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetNormalComboMotionNo(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mGetNormalComboMotionNo@mHRPc@@UAEHHH@Z]
	typedef int32_t(__thiscall* _mGetNormalComboMotionNo_mHRPc__UAEHHH_Z)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
	int32_t mGetNormalComboMotionNo(int32_t arg2, int32_t arg3)
	{
		_mGetNormalComboMotionNo_mHRPc__UAEHHH_Z mFunc = (_mGetNormalComboMotionNo_mHRPc__UAEHHH_Z)(GameModule + 0x421490);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetComboKind(class mHRPc* const this) [?mSetComboKind@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mSetComboKind_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mSetComboKind()
	{
		_mSetComboKind_mHRPc__UAEXXZ mFunc = (_mSetComboKind_mHRPc__UAEXXZ)(GameModule + 0x4214b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mReturnIdleMove(class mHRPc* const this) [?mReturnIdleMove@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mReturnIdleMove_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mReturnIdleMove()
	{
		_mReturnIdleMove_mHRPc__QAEXXZ mFunc = (_mReturnIdleMove_mHRPc__QAEXXZ)(GameModule + 0x421620);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDashProc(class mHRPc* const this) [?mDashProc@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mDashProc_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mDashProc()
	{
		_mDashProc_mHRPc__UAE_NXZ mFunc = (_mDashProc_mHRPc__UAE_NXZ)(GameModule + 0x421760);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDashStartProc(class mHRPc* const this) [?mDashStartProc@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mDashStartProc_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mDashStartProc()
	{
		_mDashStartProc_mHRPc__UAEXXZ mFunc = (_mDashStartProc_mHRPc__UAEXXZ)(GameModule + 0x421770);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mForceLanding(class mHRPc* const this) [?mForceLanding@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mForceLanding_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mForceLanding()
	{
		_mForceLanding_mHRPc__UAEXXZ mFunc = (_mForceLanding_mHRPc__UAEXXZ)(GameModule + 0x421780);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckJumpAttack(class mHRPc* const this) [?mCheckJumpAttack@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckJumpAttack_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckJumpAttack()
	{
		_mCheckJumpAttack_mHRPc__UAE_NXZ mFunc = (_mCheckJumpAttack_mHRPc__UAE_NXZ)(GameModule + 0x421790);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckJump(class mHRPc* const this) [?mCheckJump@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckJump_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckJump()
	{
		_mCheckJump_mHRPc__UAE_NXZ mFunc = (_mCheckJump_mHRPc__UAE_NXZ)(GameModule + 0x4217b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mJumpProc(class mHRPc* const this) [?mJumpProc@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mJumpProc_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mJumpProc()
	{
		_mJumpProc_mHRPc__UAE_NXZ mFunc = (_mJumpProc_mHRPc__UAE_NXZ)(GameModule + 0x4217c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCheckRouletteAbility(class mHRPc* const this) [?mCheckRouletteAbility@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCheckRouletteAbility_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCheckRouletteAbility()
	{
		_mCheckRouletteAbility_mHRPc__QAEXXZ mFunc = (_mCheckRouletteAbility_mHRPc__QAEXXZ)(GameModule + 0x4217d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPreStartProcessSpecialMode(class mHRPc* const this) [?mPreStartProcessSpecialMode@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mPreStartProcessSpecialMode_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mPreStartProcessSpecialMode()
	{
		_mPreStartProcessSpecialMode_mHRPc__QAEXXZ mFunc = (_mPreStartProcessSpecialMode_mHRPc__QAEXXZ)(GameModule + 0x421ac0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClear360(class mHRPc* const this) [?mClear360@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClear360_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClear360()
	{
		_mClear360_mHRPc__QAEXXZ mFunc = (_mClear360_mHRPc__QAEXXZ)(GameModule + 0x421b40);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearFire(class mHRPc* const this) [?mClearFire@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearFire_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearFire()
	{
		_mClearFire_mHRPc__QAEXXZ mFunc = (_mClearFire_mHRPc__QAEXXZ)(GameModule + 0x421bb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mClearTiger(class mHRPc* const this) [?mClearTiger@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mClearTiger_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mClearTiger()
	{
		_mClearTiger_mHRPc__QAE_NXZ mFunc = (_mClearTiger_mHRPc__QAE_NXZ)(GameModule + 0x421bc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearDancingCombo(class mHRPc* const this) [?mClearDancingCombo@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearDancingCombo_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearDancingCombo()
	{
		_mClearDancingCombo_mHRPc__QAEXXZ mFunc = (_mClearDancingCombo_mHRPc__QAEXXZ)(GameModule + 0x421cb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearRapidFinish(class mHRPc* const this) [?mClearRapidFinish@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearRapidFinish_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearRapidFinish()
	{
		_mClearRapidFinish_mHRPc__QAEXXZ mFunc = (_mClearRapidFinish_mHRPc__QAEXXZ)(GameModule + 0x421d50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearBullet(class mHRPc* const this) [?mClearBullet@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearBullet_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearBullet()
	{
		_mClearBullet_mHRPc__QAEXXZ mFunc = (_mClearBullet_mHRPc__QAEXXZ)(GameModule + 0x421dd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartDarkSide(class mHRPc* const this) [?mStartDarkSide@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartDarkSide_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartDarkSide()
	{
		_mStartDarkSide_mHRPc__QAEXXZ mFunc = (_mStartDarkSide_mHRPc__QAEXXZ)(GameModule + 0x421df0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStart360(class mHRPc* const this) [?mStart360@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStart360_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStart360()
	{
		_mStart360_mHRPc__QAEXXZ mFunc = (_mStart360_mHRPc__QAEXXZ)(GameModule + 0x421fd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartFire(class mHRPc* const this) [?mStartFire@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartFire_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartFire()
	{
		_mStartFire_mHRPc__QAEXXZ mFunc = (_mStartFire_mHRPc__QAEXXZ)(GameModule + 0x422020);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartTiger(class mHRPc* const this) [?mStartTiger@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartTiger_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartTiger()
	{
		_mStartTiger_mHRPc__QAEXXZ mFunc = (_mStartTiger_mHRPc__QAEXXZ)(GameModule + 0x422040);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartDancingCombo(class mHRPc* const this) [?mStartDancingCombo@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartDancingCombo_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartDancingCombo()
	{
		_mStartDancingCombo_mHRPc__QAEXXZ mFunc = (_mStartDancingCombo_mHRPc__QAEXXZ)(GameModule + 0x422150);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartRapidFinish(class mHRPc* const this) [?mStartRapidFinish@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartRapidFinish_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartRapidFinish()
	{
		_mStartRapidFinish_mHRPc__QAEXXZ mFunc = (_mStartRapidFinish_mHRPc__QAEXXZ)(GameModule + 0x422270);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartBullet(class mHRPc* const this) [?mStartBullet@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartBullet_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartBullet()
	{
		_mStartBullet_mHRPc__QAEXXZ mFunc = (_mStartBullet_mHRPc__QAEXXZ)(GameModule + 0x422290);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTigerAttack(class mHRPc* const this) [?mCheckTigerAttack@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckTigerAttack_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckTigerAttack()
	{
		_mCheckTigerAttack_mHRPc__QAE_NXZ mFunc = (_mCheckTigerAttack_mHRPc__QAE_NXZ)(GameModule + 0x4222c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTermTiger(class mHRPc* const this) [?mTermTiger@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTermTiger_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTermTiger()
	{
		_mTermTiger_mHRPc__QAE_NXZ mFunc = (_mTermTiger_mHRPc__QAE_NXZ)(GameModule + 0x4222e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTigerAttackProc(class mHRPc* const this) [?mTigerAttackProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mTigerAttackProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mTigerAttackProc()
	{
		_mTigerAttackProc_mHRPc__QAEXXZ mFunc = (_mTigerAttackProc_mHRPc__QAEXXZ)(GameModule + 0x4223a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTigerProc(class mHRPc* const this) [?mTigerProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mTigerProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mTigerProc()
	{
		_mTigerProc_mHRPc__QAEXXZ mFunc = (_mTigerProc_mHRPc__QAEXXZ)(GameModule + 0x4229c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTigerAttackInput(class mHRPc* const this) [?mTigerAttackInput@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTigerAttackInput_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTigerAttackInput()
	{
		_mTigerAttackInput_mHRPc__QAE_NXZ mFunc = (_mTigerAttackInput_mHRPc__QAE_NXZ)(GameModule + 0x422d80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTigerPadInputProc(class mHRPc* const this) [?mTigerPadInputProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mTigerPadInputProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mTigerPadInputProc()
	{
		_mTigerPadInputProc_mHRPc__QAEXXZ mFunc = (_mTigerPadInputProc_mHRPc__QAEXXZ)(GameModule + 0x422ea0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallTigerSetupMatrix(class mHRPc* const this, float arg2) [?mCallTigerSetupMatrix@mHRPc@@QAEXM@Z]
	typedef void(__thiscall* _mCallTigerSetupMatrix_mHRPc__QAEXM_Z)(class mHRPc* const thisPtr, float arg2);
	void mCallTigerSetupMatrix(float arg2)
	{
		_mCallTigerSetupMatrix_mHRPc__QAEXM_Z mFunc = (_mCallTigerSetupMatrix_mHRPc__QAEXM_Z)(GameModule + 0x4230e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallTigerMotionProcess(class mHRPc* const this) [?mCallTigerMotionProcess@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCallTigerMotionProcess_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCallTigerMotionProcess()
	{
		_mCallTigerMotionProcess_mHRPc__QAEXXZ mFunc = (_mCallTigerMotionProcess_mHRPc__QAEXXZ)(GameModule + 0x423200);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateTigerPos(class mHRPc* const this) [?mUpdateTigerPos@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mUpdateTigerPos_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mUpdateTigerPos()
	{
		_mUpdateTigerPos_mHRPc__QAEXXZ mFunc = (_mUpdateTigerPos_mHRPc__QAEXXZ)(GameModule + 0x423230);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayTigerMotion(class mHRPc* const this, int32_t arg2, uint8_t arg3, float arg4) [?mPlayTigerMotion@mHRPc@@QAE_NH_NM@Z]
	typedef uint8_t(__thiscall* _mPlayTigerMotion_mHRPc__QAE_NH_NM_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, float arg4);
	uint8_t mPlayTigerMotion(int32_t arg2, uint8_t arg3, float arg4)
	{
		_mPlayTigerMotion_mHRPc__QAE_NH_NM_Z mFunc = (_mPlayTigerMotion_mHRPc__QAE_NH_NM_Z)(GameModule + 0x4232a0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearRapidFinishTarget(class mHRPc* const this) [?mClearRapidFinishTarget@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearRapidFinishTarget_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearRapidFinishTarget()
	{
		_mClearRapidFinishTarget_mHRPc__QAEXXZ mFunc = (_mClearRapidFinishTarget_mHRPc__QAEXXZ)(GameModule + 0x423360);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetRapidFinishTarget(class mHRPc* const this) [?mSetRapidFinishTarget@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetRapidFinishTarget_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetRapidFinishTarget()
	{
		_mSetRapidFinishTarget_mHRPc__QAEXXZ mFunc = (_mSetRapidFinishTarget_mHRPc__QAEXXZ)(GameModule + 0x4233d0);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchRapidFinishNpc(class mHRPc* const this) [?mSearchRapidFinishNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mSearchRapidFinishNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mSearchRapidFinishNpc()
	{
		_mSearchRapidFinishNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mSearchRapidFinishNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0x4235b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckResistRapidFinishNpc(class mHRPc* const this, class mHRChara* arg2) [?mCheckResistRapidFinishNpc@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mCheckResistRapidFinishNpc_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mCheckResistRapidFinishNpc(class mHRChara* arg2)
	{
		_mCheckResistRapidFinishNpc_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mCheckResistRapidFinishNpc_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x423740);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetRapidFinishNpc(class mHRPc* const this, class mHRChara* arg2) [?mSetRapidFinishNpc@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetRapidFinishNpc_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mSetRapidFinishNpc(class mHRChara* arg2)
	{
		_mSetRapidFinishNpc_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mSetRapidFinishNpc_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x423770);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGet360Tick(class mHRPc* const this) [?mGet360Tick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGet360Tick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGet360Tick()
	{
		_mGet360Tick_mHRPc__QAEHXZ mFunc = (_mGet360Tick_mHRPc__QAEHXZ)(GameModule + 0x423800);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetFireTick(class mHRPc* const this) [?mGetFireTick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetFireTick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetFireTick()
	{
		_mGetFireTick_mHRPc__QAEHXZ mFunc = (_mGetFireTick_mHRPc__QAEHXZ)(GameModule + 0x423820);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetTigerTick(class mHRPc* const this) [?mGetTigerTick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetTigerTick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetTigerTick()
	{
		_mGetTigerTick_mHRPc__QAEHXZ mFunc = (_mGetTigerTick_mHRPc__QAEHXZ)(GameModule + 0x423840);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetDancingComboTick(class mHRPc* const this) [?mGetDancingComboTick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetDancingComboTick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetDancingComboTick()
	{
		_mGetDancingComboTick_mHRPc__QAEHXZ mFunc = (_mGetDancingComboTick_mHRPc__QAEHXZ)(GameModule + 0x423860);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetRapidFinishTick(class mHRPc* const this) [?mGetRapidFinishTick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetRapidFinishTick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetRapidFinishTick()
	{
		_mGetRapidFinishTick_mHRPc__QAEHXZ mFunc = (_mGetRapidFinishTick_mHRPc__QAEHXZ)(GameModule + 0x423880);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBulletTick(class mHRPc* const this) [?mGetBulletTick@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetBulletTick_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetBulletTick()
	{
		_mGetBulletTick_mHRPc__QAEHXZ mFunc = (_mGetBulletTick_mHRPc__QAEHXZ)(GameModule + 0x4238a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetRotInterpolate(class mHRPc* const this) [?mGetRotInterpolate@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetRotInterpolate_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetRotInterpolate()
	{
		_mGetRotInterpolate_mHRPc__QAEMXZ mFunc = (_mGetRotInterpolate_mHRPc__QAEMXZ)(GameModule + 0x4238c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckChargeMax(class mHRPc* const this) [?mCheckChargeMax@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckChargeMax_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckChargeMax()
	{
		_mCheckChargeMax_mHRPc__QAE_NXZ mFunc = (_mCheckChargeMax_mHRPc__QAE_NXZ)(GameModule + 0x423930);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInputBatteryCharge(class mHRPc* const this) [?mCheckInputBatteryCharge@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckInputBatteryCharge_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckInputBatteryCharge()
	{
		_mCheckInputBatteryCharge_mHRPc__UAE_NXZ mFunc = (_mCheckInputBatteryCharge_mHRPc__UAE_NXZ)(GameModule + 0x423940);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInputGuard(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mCheckInputGuard@mHRPc@@QAE_N_N0@Z]
	typedef uint8_t(__thiscall* _mCheckInputGuard_mHRPc__QAE_N_N0_Z)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
	uint8_t mCheckInputGuard(uint8_t arg2, uint8_t arg3)
	{
		_mCheckInputGuard_mHRPc__QAE_N_N0_Z mFunc = (_mCheckInputGuard_mHRPc__QAE_N_N0_Z)(GameModule + 0x423a10);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::checkAndUpdateWeaponLength(class mHRPc* const this, class TGmf* arg2) [?checkAndUpdateWeaponLength@mHRPc@@QAEXPAVTGmf@@@Z]
	typedef void(__thiscall* _checkAndUpdateWeaponLength_mHRPc__QAEXPAVTGmf___Z)(class mHRPc* const thisPtr, class TGmf* arg2);
	void checkAndUpdateWeaponLength(class TGmf* arg2)
	{
		_checkAndUpdateWeaponLength_mHRPc__QAEXPAVTGmf___Z mFunc = (_checkAndUpdateWeaponLength_mHRPc__QAEXPAVTGmf___Z)(GameModule + 0x423a40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallWepMotionProc(class mHRPc* const this) [?mCallWepMotionProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCallWepMotionProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCallWepMotionProc()
	{
		_mCallWepMotionProc_mHRPc__QAEXXZ mFunc = (_mCallWepMotionProc_mHRPc__QAEXXZ)(GameModule + 0x423c60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepMotionRate(class mHRPc* const this, float arg2, int32_t arg3) [?mSetWepMotionRate@mHRPc@@QAEXMH@Z]
	typedef void(__thiscall* _mSetWepMotionRate_mHRPc__QAEXMH_Z)(class mHRPc* const thisPtr, float arg2, int32_t arg3);
	void mSetWepMotionRate(float arg2, int32_t arg3)
	{
		_mSetWepMotionRate_mHRPc__QAEXMH_Z mFunc = (_mSetWepMotionRate_mHRPc__QAEXMH_Z)(GameModule + 0x423cd0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayWepMotion(class mHRPc* const this, int32_t arg2, uint8_t arg3, float arg4, int32_t arg5) [?mPlayWepMotion@mHRPc@@QAEXH_NMH@Z]
	typedef void(__thiscall* _mPlayWepMotion_mHRPc__QAEXH_NMH_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, float arg4, int32_t arg5);
	void mPlayWepMotion(int32_t arg2, uint8_t arg3, float arg4, int32_t arg5)
	{
		_mPlayWepMotion_mHRPc__QAEXH_NMH_Z mFunc = (_mPlayWepMotion_mHRPc__QAEXH_NMH_Z)(GameModule + 0x423ce0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWeaponLength(class mHRPc* const this) [?mSetWeaponLength@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetWeaponLength_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetWeaponLength()
	{
		_mSetWeaponLength_mHRPc__QAEXXZ mFunc = (_mSetWeaponLength_mHRPc__QAEXXZ)(GameModule + 0x423d80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mResumeEasyDemo(class mHRPc* const this) [?mResumeEasyDemo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mResumeEasyDemo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mResumeEasyDemo()
	{
		_mResumeEasyDemo_mHRPc__QAE_NXZ mFunc = (_mResumeEasyDemo_mHRPc__QAE_NXZ)(GameModule + 0x423e80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayEasyDemo(class mHRPc* const this, int32_t arg2, int32_t arg3, uint8_t arg4) [?mPlayEasyDemo@mHRPc@@QAE_NHH_N@Z]
	typedef uint8_t(__thiscall* _mPlayEasyDemo_mHRPc__QAE_NHH_N_Z)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3, uint8_t arg4);
	uint8_t mPlayEasyDemo(int32_t arg2, int32_t arg3, uint8_t arg4)
	{
		_mPlayEasyDemo_mHRPc__QAE_NHH_N_Z mFunc = (_mPlayEasyDemo_mHRPc__QAE_NHH_N_Z)(GameModule + 0x423ea0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayNoutouDemo(class mHRPc* const this) [?mPlayNoutouDemo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mPlayNoutouDemo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mPlayNoutouDemo()
	{
		_mPlayNoutouDemo_mHRPc__QAE_NXZ mFunc = (_mPlayNoutouDemo_mHRPc__QAE_NXZ)(GameModule + 0x423f80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayBattouDemo(class mHRPc* const this) [?mPlayBattouDemo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mPlayBattouDemo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mPlayBattouDemo()
	{
		_mPlayBattouDemo_mHRPc__QAE_NXZ mFunc = (_mPlayBattouDemo_mHRPc__QAE_NXZ)(GameModule + 0x4241d0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBattouEndMotion(class mHRPc* const this) [?mGetBattouEndMotion@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetBattouEndMotion_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetBattouEndMotion()
	{
		_mGetBattouEndMotion_mHRPc__QAEHXZ mFunc = (_mGetBattouEndMotion_mHRPc__QAEHXZ)(GameModule + 0x4248b0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBattouLoopMotion(class mHRPc* const this) [?mGetBattouLoopMotion@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetBattouLoopMotion_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetBattouLoopMotion()
	{
		_mGetBattouLoopMotion_mHRPc__QAEHXZ mFunc = (_mGetBattouLoopMotion_mHRPc__QAEHXZ)(GameModule + 0x424910);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCmbNumMax(class mHRPc* const this) [?mGetCmbNumMax@mHRPc@@QAEEXZ]
	typedef uint8_t(__thiscall* _mGetCmbNumMax_mHRPc__QAEEXZ)(class mHRPc* const thisPtr);
	uint8_t mGetCmbNumMax()
	{
		_mGetCmbNumMax_mHRPc__QAEEXZ mFunc = (_mGetCmbNumMax_mHRPc__QAEEXZ)(GameModule + 0x424970);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateLockOnDummyLocate(class mHRPc* const this) [?mUpdateLockOnDummyLocate@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mUpdateLockOnDummyLocate_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mUpdateLockOnDummyLocate()
	{
		_mUpdateLockOnDummyLocate_mHRPc__QAEXXZ mFunc = (_mUpdateLockOnDummyLocate_mHRPc__QAEXXZ)(GameModule + 0x4249c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLockOnDummyAtOutOfRange(class mHRPc* const this) [?mSetLockOnDummyAtOutOfRange@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetLockOnDummyAtOutOfRange_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetLockOnDummyAtOutOfRange()
	{
		_mSetLockOnDummyAtOutOfRange_mHRPc__QAEXXZ mFunc = (_mSetLockOnDummyAtOutOfRange_mHRPc__QAEXXZ)(GameModule + 0x424a60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateWatchNpc(class mHRPc* const this) [?mUpdateWatchNpc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mUpdateWatchNpc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mUpdateWatchNpc()
	{
		_mUpdateWatchNpc_mHRPc__QAEXXZ mFunc = (_mUpdateWatchNpc_mHRPc__QAEXXZ)(GameModule + 0x424b60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateLockOnTarget(class mHRPc* const this) [?mUpdateLockOnTarget@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mUpdateLockOnTarget_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mUpdateLockOnTarget()
	{
		_mUpdateLockOnTarget_mHRPc__QAEXXZ mFunc = (_mUpdateLockOnTarget_mHRPc__QAEXXZ)(GameModule + 0x424c00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateLockOnList(class mHRPc* const this, uint8_t arg2) [?mUpdateLockOnList@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mUpdateLockOnList_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mUpdateLockOnList(uint8_t arg2)
	{
		_mUpdateLockOnList_mHRPc__QAEX_N_Z mFunc = (_mUpdateLockOnList_mHRPc__QAEX_N_Z)(GameModule + 0x4250e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mRotate2LockOnTarget(class mHRPc* const this) [?mRotate2LockOnTarget@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mRotate2LockOnTarget_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mRotate2LockOnTarget()
	{
		_mRotate2LockOnTarget_mHRPc__QAEXXZ mFunc = (_mRotate2LockOnTarget_mHRPc__QAEXXZ)(GameModule + 0x4256a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLockOn(class mHRPc* const this) [?mSetLockOn@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetLockOn_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetLockOn()
	{
		_mSetLockOn_mHRPc__QAEXXZ mFunc = (_mSetLockOn_mHRPc__QAEXXZ)(GameModule + 0x4257b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLockOnDummy(class mHRPc* const this) [?mCheckLockOnDummy@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckLockOnDummy_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckLockOnDummy()
	{
		_mCheckLockOnDummy_mHRPc__QAE_NXZ mFunc = (_mCheckLockOnDummy_mHRPc__QAE_NXZ)(GameModule + 0x425800);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mInitLockOn(class mHRPc* const this) [?mInitLockOn@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mInitLockOn_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mInitLockOn()
	{
		_mInitLockOn_mHRPc__QAEXXZ mFunc = (_mInitLockOn_mHRPc__QAEXXZ)(GameModule + 0x425820);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDarkSideSonicProc(class mHRPc* const this) [?mDarkSideSonicProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mDarkSideSonicProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mDarkSideSonicProc()
	{
		_mDarkSideSonicProc_mHRPc__QAEXXZ mFunc = (_mDarkSideSonicProc_mHRPc__QAEXXZ)(GameModule + 0x425920);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::bootGuardLightFlashEffect(class mHRPc* const this, struct Vec& arg2) [?bootGuardLightFlashEffect@mHRPc@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _bootGuardLightFlashEffect_mHRPc__QAEXABUVec___Z)(class mHRPc* const thisPtr, struct Vec& arg2);
	void bootGuardLightFlashEffect(struct Vec& arg2)
	{
		_bootGuardLightFlashEffect_mHRPc__QAEXABUVec___Z mFunc = (_bootGuardLightFlashEffect_mHRPc__QAEXABUVec___Z)(GameModule + 0x425bd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::LaserScaleProc(class mHRPc* const this) [?LaserScaleProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _LaserScaleProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void LaserScaleProc()
	{
		_LaserScaleProc_mHRPc__QAEXXZ mFunc = (_LaserScaleProc_mHRPc__QAEXXZ)(GameModule + 0x425c00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mEffectProc(class mHRPc* const this) [?mEffectProc@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mEffectProc_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mEffectProc()
	{
		_mEffectProc_mHRPc__UAEXXZ mFunc = (_mEffectProc_mHRPc__UAEXXZ)(GameModule + 0x425d20);
		return mFunc(this);
	}
private:
	// Hook: Pre
	inline static _mEffectProc_mHRPc__UAEXXZ _original_mEffectProc = nullptr;
	inline static std::unordered_set<std::string> _callbacks_mEffectProc_pre;
	inline static std::unordered_set<std::string> _callbacks_mEffectProc_post;
	static void __fastcall mEffectProc_OnHook(class mHRPc* const thisPtr, void* EDX)
	{
#if WITH_LUA
		std::unordered_set<std::string>::iterator it = _callbacks_mEffectProc_pre.begin();
		while (it != _callbacks_mEffectProc_pre.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mEffectProc_pre.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		_original_mEffectProc(thisPtr);
#if WITH_LUA
		it = _callbacks_mEffectProc_post.begin();
		while (it != _callbacks_mEffectProc_post.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mEffectProc_post.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
	}
public:
	// Hook: Register
#if WITH_LUA
	static void mEffectProc_RegisterHook(std::string HookName, bool bPostHook)
	{
		if (!HookName.empty() && !bPostHook) _callbacks_mEffectProc_pre.insert(HookName);
		if (!HookName.empty() && bPostHook) _callbacks_mEffectProc_post.insert(HookName);
		if (_original_mEffectProc == nullptr)
		{
			_original_mEffectProc = (_mEffectProc_mHRPc__UAEXXZ)mem::TrampHook((BYTE*)GameModule + 0x425d20, (BYTE*)mEffectProc_OnHook, 0x6);
			assert(_original_mEffectProc);
		}
	}
#endif
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestBeamKatanaShowyEffect(class mHRPc* const this) [?mTestBeamKatanaShowyEffect@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestBeamKatanaShowyEffect_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestBeamKatanaShowyEffect()
	{
		_mTestBeamKatanaShowyEffect_mHRPc__QAE_NXZ mFunc = (_mTestBeamKatanaShowyEffect_mHRPc__QAE_NXZ)(GameModule + 0x4274f0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetCatchDistance(class mHRPc* const this) [?mGetCatchDistance@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetCatchDistance_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetCatchDistance()
	{
		_mGetCatchDistance_mHRPc__QAEMXZ mFunc = (_mGetCatchDistance_mHRPc__QAEMXZ)(GameModule + 0x427520);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetMotionSpeed(class mHRPc* const this) [?mGetMotionSpeed@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetMotionSpeed_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetMotionSpeed()
	{
		_mGetMotionSpeed_mHRPc__QAEMXZ mFunc = (_mGetMotionSpeed_mHRPc__QAEMXZ)(GameModule + 0x427530);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetFinishMotionSpeed(class mHRPc* const this) [?mSetFinishMotionSpeed@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetFinishMotionSpeed_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetFinishMotionSpeed()
	{
		_mSetFinishMotionSpeed_mHRPc__QAEXXZ mFunc = (_mSetFinishMotionSpeed_mHRPc__QAEXXZ)(GameModule + 0x4275e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTargetObject(class mHRPc* const this, class mHRChara* arg2) [?mCheckTargetObject@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mCheckTargetObject_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mCheckTargetObject(class mHRChara* arg2)
	{
		_mCheckTargetObject_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mCheckTargetObject_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x427d40);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchAttackTargetNpc(class mHRPc* const this, float arg2, uint8_t arg3) [?mSearchAttackTargetNpc@mHRPc@@QAEPAVmHRChara@@M_N@Z]
	typedef class mHRChara*(__thiscall* _mSearchAttackTargetNpc_mHRPc__QAEPAVmHRChara__M_N_Z)(class mHRPc* const thisPtr, float arg2, uint8_t arg3);
	class mHRChara* mSearchAttackTargetNpc(float arg2, uint8_t arg3)
	{
		_mSearchAttackTargetNpc_mHRPc__QAEPAVmHRChara__M_N_Z mFunc = (_mSearchAttackTargetNpc_mHRPc__QAEPAVmHRChara__M_N_Z)(GameModule + 0x427d50);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchDarkSideWarpTargetNpc(class mHRPc* const this) [?mSearchDarkSideWarpTargetNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mSearchDarkSideWarpTargetNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mSearchDarkSideWarpTargetNpc()
	{
		_mSearchDarkSideWarpTargetNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mSearchDarkSideWarpTargetNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0x427f00);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchNearNpc(class mHRPc* const this, float arg2) [?mSearchNearNpc@mHRPc@@QAEPAVmHRChara@@M@Z]
	typedef class mHRChara*(__thiscall* _mSearchNearNpc_mHRPc__QAEPAVmHRChara__M_Z)(class mHRPc* const thisPtr, float arg2);
	class mHRChara* mSearchNearNpc(float arg2)
	{
		_mSearchNearNpc_mHRPc__QAEPAVmHRChara__M_Z mFunc = (_mSearchNearNpc_mHRPc__QAEPAVmHRChara__M_Z)(GameModule + 0x428080);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mLookAttackTargetNpc(class mHRPc* const this) [?mLookAttackTargetNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mLookAttackTargetNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mLookAttackTargetNpc()
	{
		_mLookAttackTargetNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mLookAttackTargetNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0x428160);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mLockNearNpc(class mHRPc* const this, float arg2, class mHRChara* arg3) [?mLockNearNpc@mHRPc@@QAEPAVmHRChara@@MPAV2@@Z]
	typedef class mHRChara*(__thiscall* _mLockNearNpc_mHRPc__QAEPAVmHRChara__MPAV2__Z)(class mHRPc* const thisPtr, float arg2, class mHRChara* arg3);
	class mHRChara* mLockNearNpc(float arg2, class mHRChara* arg3)
	{
		_mLockNearNpc_mHRPc__QAEPAVmHRChara__MPAV2__Z mFunc = (_mLockNearNpc_mHRPc__QAEPAVmHRChara__MPAV2__Z)(GameModule + 0x428350);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mLockNearCatchNpc(class mHRPc* const this, float arg2, uint8_t arg3) [?mLockNearCatchNpc@mHRPc@@QAEPAVmHRChara@@M_N@Z]
	typedef class mHRChara*(__thiscall* _mLockNearCatchNpc_mHRPc__QAEPAVmHRChara__M_N_Z)(class mHRPc* const thisPtr, float arg2, uint8_t arg3);
	class mHRChara* mLockNearCatchNpc(float arg2, uint8_t arg3)
	{
		_mLockNearCatchNpc_mHRPc__QAEPAVmHRChara__M_N_Z mFunc = (_mLockNearCatchNpc_mHRPc__QAEPAVmHRChara__M_N_Z)(GameModule + 0x4283b0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mAddKillNpcCombo(class mHRPc* const this, class mHRChara* arg2) [?mAddKillNpcCombo@mHRPc@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mAddKillNpcCombo_mHRPc__QAEXPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	void mAddKillNpcCombo(class mHRChara* arg2)
	{
		_mAddKillNpcCombo_mHRPc__QAEXPAVmHRChara___Z mFunc = (_mAddKillNpcCombo_mHRPc__QAEXPAVmHRChara___Z)(GameModule + 0x428510);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mIntiFinishNpc(class mHRPc* const this, uint8_t arg2) [?mIntiFinishNpc@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mIntiFinishNpc_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mIntiFinishNpc(uint8_t arg2)
	{
		_mIntiFinishNpc_mHRPc__QAEX_N_Z mFunc = (_mIntiFinishNpc_mHRPc__QAEX_N_Z)(GameModule + 0x428540);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDarkSideTarget(class mHRPc* const this) [?mSetDarkSideTarget@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetDarkSideTarget_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetDarkSideTarget()
	{
		_mSetDarkSideTarget_mHRPc__QAEXXZ mFunc = (_mSetDarkSideTarget_mHRPc__QAEXXZ)(GameModule + 0x4286c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mInputDarkSideSuccess(class mHRPc* const this) [?mInputDarkSideSuccess@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mInputDarkSideSuccess_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mInputDarkSideSuccess()
	{
		_mInputDarkSideSuccess_mHRPc__QAEXXZ mFunc = (_mInputDarkSideSuccess_mHRPc__QAEXXZ)(GameModule + 0x428860);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPcMoveFrontOfNpc4DarkSideMode(class mHRPc* const this, class mHRChara* arg2) [?mPcMoveFrontOfNpc4DarkSideMode@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mPcMoveFrontOfNpc4DarkSideMode_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mPcMoveFrontOfNpc4DarkSideMode(class mHRChara* arg2)
	{
		_mPcMoveFrontOfNpc4DarkSideMode_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mPcMoveFrontOfNpc4DarkSideMode_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x428870);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPcMoveFrontOfNpc(class mHRPc* const this, class mHRChara* arg2, uint8_t arg3, int32_t arg4) [?mPcMoveFrontOfNpc@mHRPc@@QAE_NPAVmHRChara@@_NH@Z]
	typedef uint8_t(__thiscall* _mPcMoveFrontOfNpc_mHRPc__QAE_NPAVmHRChara___NH_Z)(class mHRPc* const thisPtr, class mHRChara* arg2, uint8_t arg3, int32_t arg4);
	uint8_t mPcMoveFrontOfNpc(class mHRChara* arg2, uint8_t arg3, int32_t arg4)
	{
		_mPcMoveFrontOfNpc_mHRPc__QAE_NPAVmHRChara___NH_Z mFunc = (_mPcMoveFrontOfNpc_mHRPc__QAE_NPAVmHRChara___NH_Z)(GameModule + 0x428880);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchNextNpc(class mHRPc* const this) [?mSearchNextNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mSearchNextNpc_mHRPc__QAEPAVmHRChara__XZ)(class mHRPc* const thisPtr);
	class mHRChara* mSearchNextNpc()
	{
		_mSearchNextNpc_mHRPc__QAEPAVmHRChara__XZ mFunc = (_mSearchNextNpc_mHRPc__QAEPAVmHRChara__XZ)(GameModule + 0x428aa0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishMode(class mHRPc* const this, class mHRChara* arg2) [?mCheckFinishMode@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mCheckFinishMode_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mCheckFinishMode(class mHRChara* arg2)
	{
		_mCheckFinishMode_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mCheckFinishMode_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x428c00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mPrepareInputFinish(class mHRPc* const this, class mHRChara* arg2) [?mPrepareInputFinish@mHRPc@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mPrepareInputFinish_mHRPc__QAEXPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	void mPrepareInputFinish(class mHRChara* arg2)
	{
		_mPrepareInputFinish_mHRPc__QAEXPAVmHRChara___Z mFunc = (_mPrepareInputFinish_mHRPc__QAEXPAVmHRChara___Z)(GameModule + 0x428d30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetIntoTsubazeriai(class mHRPc* const this, class mHRChara* arg2) [?mSetIntoTsubazeriai@mHRPc@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mSetIntoTsubazeriai_mHRPc__QAEXPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	void mSetIntoTsubazeriai(class mHRChara* arg2)
	{
		_mSetIntoTsubazeriai_mHRPc__QAEXPAVmHRChara___Z mFunc = (_mSetIntoTsubazeriai_mHRPc__QAEXPAVmHRChara___Z)(GameModule + 0x429140);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSePlayUpperAttack(class mHRPc* const this) [?mSePlayUpperAttack@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSePlayUpperAttack_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSePlayUpperAttack()
	{
		_mSePlayUpperAttack_mHRPc__QAEXXZ mFunc = (_mSePlayUpperAttack_mHRPc__QAEXXZ)(GameModule + 0x429500);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTameAttckProc(class mHRPc* const this) [?mTameAttckProc@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTameAttckProc_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTameAttckProc()
	{
		_mTameAttckProc_mHRPc__QAE_NXZ mFunc = (_mTameAttckProc_mHRPc__QAE_NXZ)(GameModule + 0x429590);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mJoyuuLight(class mHRPc* const this, uint8_t arg2) [?mJoyuuLight@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mJoyuuLight_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mJoyuuLight(uint8_t arg2)
	{
		_mJoyuuLight_mHRPc__QAEX_N_Z mFunc = (_mJoyuuLight_mHRPc__QAEX_N_Z)(GameModule + 0x4295a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSlotResult(class mHRPc* const this, int16_t arg2) [?mSlotResult@mHRPc@@QAE_NF@Z]
	typedef uint8_t(__thiscall* _mSlotResult_mHRPc__QAE_NF_Z)(class mHRPc* const thisPtr, int16_t arg2);
	uint8_t mSlotResult(int16_t arg2)
	{
		_mSlotResult_mHRPc__QAE_NF_Z mFunc = (_mSlotResult_mHRPc__QAE_NF_Z)(GameModule + 0x429a60);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAttackHitCheck(class mHRPc* const this) [?mAttackHitCheck@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mAttackHitCheck_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mAttackHitCheck()
	{
		_mAttackHitCheck_mHRPc__QAE_NXZ mFunc = (_mAttackHitCheck_mHRPc__QAE_NXZ)(GameModule + 0x429e90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAttackProc(class mHRPc* const this) [?mAttackProc@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mAttackProc_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mAttackProc()
	{
		_mAttackProc_mHRPc__UAE_NXZ mFunc = (_mAttackProc_mHRPc__UAE_NXZ)(GameModule + 0x42c990);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mFailedInputFinishProcessForVsBoss(class mHRPc* const this) [?mFailedInputFinishProcessForVsBoss@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mFailedInputFinishProcessForVsBoss_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mFailedInputFinishProcessForVsBoss()
	{
		_mFailedInputFinishProcessForVsBoss_mHRPc__QAEXXZ mFunc = (_mFailedInputFinishProcessForVsBoss_mHRPc__QAEXXZ)(GameModule + 0x42f740);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSpecialFightAttackProc(class mHRPc* const this) [?mSpecialFightAttackProc@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mSpecialFightAttackProc_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mSpecialFightAttackProc()
	{
		_mSpecialFightAttackProc_mHRPc__QAE_NXZ mFunc = (_mSpecialFightAttackProc_mHRPc__QAE_NXZ)(GameModule + 0x42f7b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckComboAttackInput(class mHRPc* const this) [?mCheckComboAttackInput@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckComboAttackInput_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckComboAttackInput()
	{
		_mCheckComboAttackInput_mHRPc__QAE_NXZ mFunc = (_mCheckComboAttackInput_mHRPc__QAE_NXZ)(GameModule + 0x42fbd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTrvStartDownAttack(class mHRPc* const this, class mHRChara* arg2) [?mTrvStartDownAttack@mHRPc@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mTrvStartDownAttack_mHRPc__QAEXPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	void mTrvStartDownAttack(class mHRChara* arg2)
	{
		_mTrvStartDownAttack_mHRPc__QAEXPAVmHRChara___Z mFunc = (_mTrvStartDownAttack_mHRPc__QAEXPAVmHRChara___Z)(GameModule + 0x430160);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartFightAttack(class mHRPc* const this) [?mStartFightAttack@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartFightAttack_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartFightAttack()
	{
		_mStartFightAttack_mHRPc__QAEXXZ mFunc = (_mStartFightAttack_mHRPc__QAEXXZ)(GameModule + 0x4304e0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAttackMotionStartFrame30fps(class mHRPc* const this, int32_t arg2) [?mGetAttackMotionStartFrame30fps@mHRPc@@QAEHH@Z]
	typedef int32_t(__thiscall* _mGetAttackMotionStartFrame30fps_mHRPc__QAEHH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mGetAttackMotionStartFrame30fps(int32_t arg2)
	{
		_mGetAttackMotionStartFrame30fps_mHRPc__QAEHH_Z mFunc = (_mGetAttackMotionStartFrame30fps_mHRPc__QAEHH_Z)(GameModule + 0x430560);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanCatchNpc(class mHRPc* const this, uint8_t arg2) [?mCheckCanCatchNpc@mHRPc@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _mCheckCanCatchNpc_mHRPc__QAE_N_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	uint8_t mCheckCanCatchNpc(uint8_t arg2)
	{
		_mCheckCanCatchNpc_mHRPc__QAE_N_N_Z mFunc = (_mCheckCanCatchNpc_mHRPc__QAE_N_N_Z)(GameModule + 0x4305a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSEPlayShakeInputSuccess(class mHRPc* const this) [?mSetSEPlayShakeInputSuccess@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetSEPlayShakeInputSuccess_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetSEPlayShakeInputSuccess()
	{
		_mSetSEPlayShakeInputSuccess_mHRPc__QAEXXZ mFunc = (_mSetSEPlayShakeInputSuccess_mHRPc__QAEXXZ)(GameModule + 0x4305f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayFinishMotion(class mHRPc* const this) [?mPlayFinishMotion@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mPlayFinishMotion_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mPlayFinishMotion()
	{
		_mPlayFinishMotion_mHRPc__QAEXXZ mFunc = (_mPlayFinishMotion_mHRPc__QAEXXZ)(GameModule + 0x430610);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSuccessFinishInput(class mHRPc* const this) [?mSuccessFinishInput@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSuccessFinishInput_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSuccessFinishInput()
	{
		_mSuccessFinishInput_mHRPc__QAEXXZ mFunc = (_mSuccessFinishInput_mHRPc__QAEXXZ)(GameModule + 0x430680);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mFinishMotionFrameKetaAge(class mHRPc* const this) [?mFinishMotionFrameKetaAge@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mFinishMotionFrameKetaAge_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mFinishMotionFrameKetaAge()
	{
		_mFinishMotionFrameKetaAge_mHRPc__QAEXXZ mFunc = (_mFinishMotionFrameKetaAge_mHRPc__QAEXXZ)(GameModule + 0x430a00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayNunchackAttackMotion(class mHRPc* const this) [?mPlayNunchackAttackMotion@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mPlayNunchackAttackMotion_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mPlayNunchackAttackMotion()
	{
		_mPlayNunchackAttackMotion_mHRPc__QAEXXZ mFunc = (_mPlayNunchackAttackMotion_mHRPc__QAEXXZ)(GameModule + 0x430a10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearNpcDamageInfo(class mHRPc* const this) [?mClearNpcDamageInfo@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearNpcDamageInfo_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearNpcDamageInfo()
	{
		_mClearNpcDamageInfo_mHRPc__QAEXXZ mFunc = (_mClearNpcDamageInfo_mHRPc__QAEXXZ)(GameModule + 0x430ba0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetHjkDir(class mHRPc* const this) [?mGetHjkDir@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetHjkDir_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetHjkDir()
	{
		_mGetHjkDir_mHRPc__QAEHXZ mFunc = (_mGetHjkDir_mHRPc__QAEHXZ)(GameModule + 0x430bd0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetFinishAtkMotNo(class mHRPc* const this) [?mGetFinishAtkMotNo@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetFinishAtkMotNo_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetFinishAtkMotNo()
	{
		_mGetFinishAtkMotNo_mHRPc__QAEHXZ mFunc = (_mGetFinishAtkMotNo_mHRPc__QAEHXZ)(GameModule + 0x430c70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSearchThrow(class mHRPc* const this, int32_t arg2, int32_t* arg3) [?mSearchThrow@mHRPc@@QAE_NHPAH@Z]
	typedef uint8_t(__thiscall* _mSearchThrow_mHRPc__QAE_NHPAH_Z)(class mHRPc* const thisPtr, int32_t arg2, int32_t* arg3);
	uint8_t mSearchThrow(int32_t arg2, int32_t* arg3)
	{
		_mSearchThrow_mHRPc__QAE_NHPAH_Z mFunc = (_mSearchThrow_mHRPc__QAE_NHPAH_Z)(GameModule + 0x430e50);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetPcThrowMotNo(class mHRPc* const this, enum enThrowDir arg2, class mHRChara* arg3, int32_t* arg4) [?mGetPcThrowMotNo@mHRPc@@QAEHW4enThrowDir@@PAVmHRChara@@PAH@Z]
	typedef int32_t(__thiscall* _mGetPcThrowMotNo_mHRPc__QAEHW4enThrowDir__PAVmHRChara__PAH_Z)(class mHRPc* const thisPtr, enum enThrowDir arg2, class mHRChara* arg3, int32_t* arg4);
	int32_t mGetPcThrowMotNo(/* enum enThrowDir */ uint32_t arg2, class mHRChara* arg3, int32_t* arg4)
	{
		_mGetPcThrowMotNo_mHRPc__QAEHW4enThrowDir__PAVmHRChara__PAH_Z mFunc = (_mGetPcThrowMotNo_mHRPc__QAEHW4enThrowDir__PAVmHRChara__PAH_Z)(GameModule + 0x430e80);
		return mFunc(this, (enum enThrowDir)arg2, arg3, arg4);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetThrowDamageMotion(class mHRPc* const this, class mHRChara* arg2, int32_t* arg3) [?mGetThrowDamageMotion@mHRPc@@QAEHPAVmHRChara@@PAH@Z]
	typedef int32_t(__thiscall* _mGetThrowDamageMotion_mHRPc__QAEHPAVmHRChara__PAH_Z)(class mHRPc* const thisPtr, class mHRChara* arg2, int32_t* arg3);
	int32_t mGetThrowDamageMotion(class mHRChara* arg2, int32_t* arg3)
	{
		_mGetThrowDamageMotion_mHRPc__QAEHPAVmHRChara__PAH_Z mFunc = (_mGetThrowDamageMotion_mHRPc__QAEHPAVmHRChara__PAH_Z)(GameModule + 0x431500);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetPcThrowMotNo4ZakoB(class mHRPc* const this, int32_t* arg2) [?mGetPcThrowMotNo4ZakoB@mHRPc@@QAEHPAH@Z]
	typedef int32_t(__thiscall* _mGetPcThrowMotNo4ZakoB_mHRPc__QAEHPAH_Z)(class mHRPc* const thisPtr, int32_t* arg2);
	int32_t mGetPcThrowMotNo4ZakoB(int32_t* arg2)
	{
		_mGetPcThrowMotNo4ZakoB_mHRPc__QAEHPAH_Z mFunc = (_mGetPcThrowMotNo4ZakoB_mHRPc__QAEHPAH_Z)(GameModule + 0x4316a0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetPcThrowMotNo4ZakoF(class mHRPc* const this, int32_t* arg2) [?mGetPcThrowMotNo4ZakoF@mHRPc@@QAEHPAH@Z]
	typedef int32_t(__thiscall* _mGetPcThrowMotNo4ZakoF_mHRPc__QAEHPAH_Z)(class mHRPc* const thisPtr, int32_t* arg2);
	int32_t mGetPcThrowMotNo4ZakoF(int32_t* arg2)
	{
		_mGetPcThrowMotNo4ZakoF_mHRPc__QAEHPAH_Z mFunc = (_mGetPcThrowMotNo4ZakoF_mHRPc__QAEHPAH_Z)(GameModule + 0x431820);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckThrowSpace(class mHRPc* const this, struct Vec arg2) [?mCheckThrowSpace@mHRPc@@QAE_NUVec@@@Z]
	typedef uint8_t(__thiscall* _mCheckThrowSpace_mHRPc__QAE_NUVec___Z)(class mHRPc* const thisPtr, struct Vec arg2);
	uint8_t mCheckThrowSpace(struct Vec arg2)
	{
		_mCheckThrowSpace_mHRPc__QAE_NUVec___Z mFunc = (_mCheckThrowSpace_mHRPc__QAE_NUVec___Z)(GameModule + 0x431970);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetDownAtkMotNo(class mHRPc* const this) [?mGetDownAtkMotNo@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetDownAtkMotNo_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetDownAtkMotNo()
	{
		_mGetDownAtkMotNo_mHRPc__QAEHXZ mFunc = (_mGetDownAtkMotNo_mHRPc__QAEHXZ)(GameModule + 0x431a90);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetNextAtkMotNo(class mHRPc* const this) [?mGetNextAtkMotNo@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetNextAtkMotNo_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetNextAtkMotNo()
	{
		_mGetNextAtkMotNo_mHRPc__QAEHXZ mFunc = (_mGetNextAtkMotNo_mHRPc__QAEHXZ)(GameModule + 0x431ae0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mAttackRestoreProc(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mAttackRestoreProc@mHRPc@@QAEX_N0@Z]
	typedef void(__thiscall* _mAttackRestoreProc_mHRPc__QAEX_N0_Z)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
	void mAttackRestoreProc(uint8_t arg2, uint8_t arg3)
	{
		_mAttackRestoreProc_mHRPc__QAEX_N0_Z mFunc = (_mAttackRestoreProc_mHRPc__QAEX_N0_Z)(GameModule + 0x431b20);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mAttackStoreProc(class mHRPc* const this, uint8_t arg2) [?mAttackStoreProc@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mAttackStoreProc_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mAttackStoreProc(uint8_t arg2)
	{
		_mAttackStoreProc_mHRPc__QAEX_N_Z mFunc = (_mAttackStoreProc_mHRPc__QAEX_N_Z)(GameModule + 0x431fd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetCombo(class mHRPc* const this) [?mResetCombo@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetCombo_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetCombo()
	{
		_mResetCombo_mHRPc__QAEXXZ mFunc = (_mResetCombo_mHRPc__QAEXXZ)(GameModule + 0x432060);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mChangeWep(class mHRPc* const this) [?mChangeWep@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mChangeWep_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mChangeWep()
	{
		_mChangeWep_mHRPc__QAE_NXZ mFunc = (_mChangeWep_mHRPc__QAE_NXZ)(GameModule + 0x4320e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mWepSeReleaseRequest(class mHRPc* const this) [?mWepSeReleaseRequest@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mWepSeReleaseRequest_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mWepSeReleaseRequest()
	{
		_mWepSeReleaseRequest_mHRPc__QAE_NXZ mFunc = (_mWepSeReleaseRequest_mHRPc__QAE_NXZ)(GameModule + 0x432160);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mInitWepStatus(class mHRPc* const this) [?mInitWepStatus@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mInitWepStatus_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mInitWepStatus()
	{
		_mInitWepStatus_mHRPc__QAEXXZ mFunc = (_mInitWepStatus_mHRPc__QAEXXZ)(GameModule + 0x4321b0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetWepIndex(class mHRPc* const this, int32_t InWepID) [?mGetWepIndex@mHRPc@@QAEHH@Z]
	typedef int32_t(__thiscall* _mGetWepIndex_mHRPc__QAEHH_Z)(class mHRPc* const thisPtr, int32_t InWepID);
	int32_t mGetWepIndex(int32_t InWepID)
	{
		_mGetWepIndex_mHRPc__QAEHH_Z mFunc = (_mGetWepIndex_mHRPc__QAEHH_Z)(GameModule + 0x432250);
		return mFunc(this, InWepID);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAtkNo(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mGetAtkNo@mHRPc@@QAEHH_N@Z]
	typedef int32_t(__thiscall* _mGetAtkNo_mHRPc__QAEHH_N_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
	int32_t mGetAtkNo(int32_t arg2, uint8_t arg3)
	{
		_mGetAtkNo_mHRPc__QAEHH_N_Z mFunc = (_mGetAtkNo_mHRPc__QAEHH_N_Z)(GameModule + 0x432280);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAtkNo(class mHRPc* const this, int32_t arg2) [?mGetAtkNo@mHRPc@@UAEHH@Z]
	typedef int32_t(__thiscall* _mGetAtkNo_mHRPc__UAEHH_Z_2)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mGetAtkNo_2(int32_t arg2)
	{
		_mGetAtkNo_mHRPc__UAEHH_Z_2 mFunc = (_mGetAtkNo_mHRPc__UAEHH_Z_2)(GameModule + 0x433080);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSideStepProc(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mSideStepProc@mHRPc@@QAE_NHH@Z]
	typedef uint8_t(__thiscall* _mSideStepProc_mHRPc__QAE_NHH_Z)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
	uint8_t mSideStepProc(int32_t arg2, int32_t arg3)
	{
		_mSideStepProc_mHRPc__QAE_NHH_Z mFunc = (_mSideStepProc_mHRPc__QAE_NHH_Z)(GameModule + 0x4330a0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetRollEscMotNo(class mHRPc* const this, int32_t arg2) [?mGetRollEscMotNo@mHRPc@@UAEHH@Z]
	typedef int32_t(__thiscall* _mGetRollEscMotNo_mHRPc__UAEHH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mGetRollEscMotNo(int32_t arg2)
	{
		_mGetRollEscMotNo_mHRPc__UAEHH_Z mFunc = (_mGetRollEscMotNo_mHRPc__UAEHH_Z)(GameModule + 0x4332f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mMoveProc(class mHRPc* const this, float arg2, uint8_t arg3, uint8_t arg4) [?mMoveProc@mHRPc@@QAE_NM_N0@Z]
	typedef uint8_t(__thiscall* _mMoveProc_mHRPc__QAE_NM_N0_Z)(class mHRPc* const thisPtr, float arg2, uint8_t arg3, uint8_t arg4);
	uint8_t mMoveProc(float arg2, uint8_t arg3, uint8_t arg4)
	{
		_mMoveProc_mHRPc__QAE_NM_N0_Z mFunc = (_mMoveProc_mHRPc__QAE_NM_N0_Z)(GameModule + 0x433340);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetPcWillDirectRotY(class mHRPc* const this) [?mGetPcWillDirectRotY@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetPcWillDirectRotY_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetPcWillDirectRotY()
	{
		_mGetPcWillDirectRotY_mHRPc__QAEMXZ mFunc = (_mGetPcWillDirectRotY_mHRPc__QAEMXZ)(GameModule + 0x434250);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetRunSpeed(class mHRPc* const this) [?mGetRunSpeed@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetRunSpeed_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetRunSpeed()
	{
		_mGetRunSpeed_mHRPc__QAEMXZ mFunc = (_mGetRunSpeed_mHRPc__QAEMXZ)(GameModule + 0x4343a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetWalkSpeed(class mHRPc* const this) [?mGetWalkSpeed@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetWalkSpeed_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetWalkSpeed()
	{
		_mGetWalkSpeed_mHRPc__QAEMXZ mFunc = (_mGetWalkSpeed_mHRPc__QAEMXZ)(GameModule + 0x4343b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mMoveCommon(class mHRPc* const this) [?mMoveCommon@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mMoveCommon_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mMoveCommon()
	{
		_mMoveCommon_mHRPc__QAEXXZ mFunc = (_mMoveCommon_mHRPc__QAEXXZ)(GameModule + 0x4343c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mLockOnMoveProc(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mLockOnMoveProc@mHRPc@@QAE_NUVec@@_N@Z]
	typedef uint8_t(__thiscall* _mLockOnMoveProc_mHRPc__QAE_NUVec___N_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
	uint8_t mLockOnMoveProc(int32_t arg2, uint8_t arg3)
	{
		_mLockOnMoveProc_mHRPc__QAE_NUVec___N_Z mFunc = (_mLockOnMoveProc_mHRPc__QAE_NUVec___N_Z)(GameModule + 0x4343d0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateAtkColl(class mHRPc* const this) [?mUpdateAtkColl@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mUpdateAtkColl_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mUpdateAtkColl()
	{
		_mUpdateAtkColl_mHRPc__UAEXXZ mFunc = (_mUpdateAtkColl_mHRPc__UAEXXZ)(GameModule + 0x434550);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartChargeEffect(class mHRPc* const this) [?mStartChargeEffect@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mStartChargeEffect_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartChargeEffect()
	{
		_mStartChargeEffect_mHRPc__QAEXXZ mFunc = (_mStartChargeEffect_mHRPc__QAEXXZ)(GameModule + 0x434830);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPreResetChargeAttack(class mHRPc* const this) [?mPreResetChargeAttack@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mPreResetChargeAttack_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mPreResetChargeAttack()
	{
		_mPreResetChargeAttack_mHRPc__QAEXXZ mFunc = (_mPreResetChargeAttack_mHRPc__QAEXXZ)(GameModule + 0x434900);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLastTarget(class mHRPc* const this, class mHRChara* arg2) [?mCheckLastTarget@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mCheckLastTarget_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mCheckLastTarget(class mHRChara* arg2)
	{
		_mCheckLastTarget_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mCheckLastTarget_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x434a90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBDash(class mHRPc* const this, int32_t arg2) [?mCheckBDash@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckBDash_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckBDash(int32_t arg2)
	{
		_mCheckBDash_mHRPc__QAE_NH_Z mFunc = (_mCheckBDash_mHRPc__QAE_NH_Z)(GameModule + 0x434aa0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckChangeWeapon(class mHRPc* const this, int32_t arg2) [?mCheckChangeWeapon@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckChangeWeapon_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckChangeWeapon(int32_t arg2)
	{
		_mCheckChangeWeapon_mHRPc__QAE_NH_Z mFunc = (_mCheckChangeWeapon_mHRPc__QAE_NH_Z)(GameModule + 0x434ac0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckWakeUpZako(class mHRPc* const this, int32_t arg2) [?mCheckWakeUpZako@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckWakeUpZako_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckWakeUpZako(int32_t arg2)
	{
		_mCheckWakeUpZako_mHRPc__QAE_NH_Z mFunc = (_mCheckWakeUpZako_mHRPc__QAE_NH_Z)(GameModule + 0x434ae0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckSchool3RapidAttack(class mHRPc* const this) [?mCheckSchool3RapidAttack@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckSchool3RapidAttack_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckSchool3RapidAttack()
	{
		_mCheckSchool3RapidAttack_mHRPc__QAE_NXZ mFunc = (_mCheckSchool3RapidAttack_mHRPc__QAE_NXZ)(GameModule + 0x434af0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBackAttack(class mHRPc* const this, int32_t arg2) [?mCheckBackAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckBackAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckBackAttack(int32_t arg2)
	{
		_mCheckBackAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckBackAttack_mHRPc__QAE_NH_Z)(GameModule + 0x434b40);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mCheckInputDirection4Pc(class mHRPc* const this) [?mCheckInputDirection4Pc@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mCheckInputDirection4Pc_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mCheckInputDirection4Pc()
	{
		_mCheckInputDirection4Pc_mHRPc__QAEHXZ mFunc = (_mCheckInputDirection4Pc_mHRPc__QAEHXZ)(GameModule + 0x434b50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckThrowInput(class mHRPc* const this) [?mCheckThrowInput@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckThrowInput_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckThrowInput()
	{
		_mCheckThrowInput_mHRPc__QAE_NXZ mFunc = (_mCheckThrowInput_mHRPc__QAE_NXZ)(GameModule + 0x434d90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInputCombo(class mHRPc* const this) [?mCheckInputCombo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckInputCombo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckInputCombo()
	{
		_mCheckInputCombo_mHRPc__QAE_NXZ mFunc = (_mCheckInputCombo_mHRPc__QAE_NXZ)(GameModule + 0x434dc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFollowThorough(class mHRPc* const this) [?mCheckFollowThorough@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckFollowThorough_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckFollowThorough()
	{
		_mCheckFollowThorough_mHRPc__QAE_NXZ mFunc = (_mCheckFollowThorough_mHRPc__QAE_NXZ)(GameModule + 0x434de0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckSantDash(class mHRPc* const this, int32_t arg2) [?mCheckSantDash@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckSantDash_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckSantDash(int32_t arg2)
	{
		_mCheckSantDash_mHRPc__QAE_NH_Z mFunc = (_mCheckSantDash_mHRPc__QAE_NH_Z)(GameModule + 0x434e90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNormalAttack(class mHRPc* const this, int32_t arg2) [?mCheckNormalAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckNormalAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckNormalAttack(int32_t arg2)
	{
		_mCheckNormalAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckNormalAttack_mHRPc__QAE_NH_Z)(GameModule + 0x434ea0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNormalDashAttack(class mHRPc* const this, int32_t arg2) [?mCheckNormalDashAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckNormalDashAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckNormalDashAttack(int32_t arg2)
	{
		_mCheckNormalDashAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckNormalDashAttack_mHRPc__QAE_NH_Z)(GameModule + 0x4350f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheck777Bomb(class mHRPc* const this, int32_t arg2) [?mCheck777Bomb@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheck777Bomb_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheck777Bomb(int32_t arg2)
	{
		_mCheck777Bomb_mHRPc__QAE_NH_Z mFunc = (_mCheck777Bomb_mHRPc__QAE_NH_Z)(GameModule + 0x435100);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheck777BombStart(class mHRPc* const this, int32_t arg2) [?mCheck777BombStart@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheck777BombStart_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheck777BombStart(int32_t arg2)
	{
		_mCheck777BombStart_mHRPc__QAE_NH_Z mFunc = (_mCheck777BombStart_mHRPc__QAE_NH_Z)(GameModule + 0x435110);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckIdling(class mHRPc* const this, int32_t arg2) [?mCheckIdling@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckIdling_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckIdling(int32_t arg2)
	{
		_mCheckIdling_mHRPc__QAE_NH_Z mFunc = (_mCheckIdling_mHRPc__QAE_NH_Z)(GameModule + 0x435120);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckIdlingMotion(class mHRPc* const this, int32_t arg2) [?mCheckIdlingMotion@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckIdlingMotion_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckIdlingMotion(int32_t arg2)
	{
		_mCheckIdlingMotion_mHRPc__QAE_NH_Z mFunc = (_mCheckIdlingMotion_mHRPc__QAE_NH_Z)(GameModule + 0x435170);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckRollEscape(class mHRPc* const this, int32_t arg2) [?mCheckRollEscape@mHRPc@@UAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckRollEscape_mHRPc__UAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckRollEscape(int32_t arg2)
	{
		_mCheckRollEscape_mHRPc__UAE_NH_Z mFunc = (_mCheckRollEscape_mHRPc__UAE_NH_Z)(GameModule + 0x4351d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGuard(class mHRPc* const this) [?mCheckGuard@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckGuard_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckGuard()
	{
		_mCheckGuard_mHRPc__UAE_NXZ mFunc = (_mCheckGuard_mHRPc__UAE_NXZ)(GameModule + 0x4351f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckChargeUpDown(class mHRPc* const this, int32_t arg2) [?mCheckChargeUpDown@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckChargeUpDown_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckChargeUpDown(int32_t arg2)
	{
		_mCheckChargeUpDown_mHRPc__QAE_NH_Z mFunc = (_mCheckChargeUpDown_mHRPc__QAE_NH_Z)(GameModule + 0x4357b0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCharge(class mHRPc* const this, uint8_t arg2) [?mCheckCharge@mHRPc@@UAE_N_N@Z]
	typedef uint8_t(__thiscall* _mCheckCharge_mHRPc__UAE_N_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	uint8_t mCheckCharge(uint8_t arg2)
	{
		_mCheckCharge_mHRPc__UAE_N_N_Z mFunc = (_mCheckCharge_mHRPc__UAE_N_N_Z)(GameModule + 0x435860);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanCancelLastCombo(class mHRPc* const this) [?mCheckCanCancelLastCombo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanCancelLastCombo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckCanCancelLastCombo()
	{
		_mCheckCanCancelLastCombo_mHRPc__QAE_NXZ mFunc = (_mCheckCanCancelLastCombo_mHRPc__QAE_NXZ)(GameModule + 0x435980);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLastCombo(class mHRPc* const this) [?mCheckLastCombo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckLastCombo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckLastCombo()
	{
		_mCheckLastCombo_mHRPc__QAE_NXZ mFunc = (_mCheckLastCombo_mHRPc__QAE_NXZ)(GameModule + 0x4359b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckStrongComboAttack(class mHRPc* const this) [?mCheckStrongComboAttack@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckStrongComboAttack_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckStrongComboAttack()
	{
		_mCheckStrongComboAttack_mHRPc__QAE_NXZ mFunc = (_mCheckStrongComboAttack_mHRPc__QAE_NXZ)(GameModule + 0x435a10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckPiyoriComboAttack(class mHRPc* const this) [?mCheckPiyoriComboAttack@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckPiyoriComboAttack_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckPiyoriComboAttack()
	{
		_mCheckPiyoriComboAttack_mHRPc__QAE_NXZ mFunc = (_mCheckPiyoriComboAttack_mHRPc__QAE_NXZ)(GameModule + 0x435a30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNockBack(class mHRPc* const this, int32_t arg2) [?mCheckNockBack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckNockBack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckNockBack(int32_t arg2)
	{
		_mCheckNockBack_mHRPc__QAE_NH_Z mFunc = (_mCheckNockBack_mHRPc__QAE_NH_Z)(GameModule + 0x435a50);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDown2StandUp(class mHRPc* const this, int32_t arg2) [?mCheckDown2StandUp@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckDown2StandUp_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckDown2StandUp(int32_t arg2)
	{
		_mCheckDown2StandUp_mHRPc__QAE_NH_Z mFunc = (_mCheckDown2StandUp_mHRPc__QAE_NH_Z)(GameModule + 0x435a90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDown(class mHRPc* const this, int32_t arg2) [?mCheckDown@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckDown_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckDown(int32_t arg2)
	{
		_mCheckDown_mHRPc__QAE_NH_Z mFunc = (_mCheckDown_mHRPc__QAE_NH_Z)(GameModule + 0x435ac0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBlowStatus(class mHRPc* const this) [?mCheckBlowStatus@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckBlowStatus_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckBlowStatus()
	{
		_mCheckBlowStatus_mHRPc__QAE_NXZ mFunc = (_mCheckBlowStatus_mHRPc__QAE_NXZ)(GameModule + 0x435b00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBombAttack(class mHRPc* const this, int32_t arg2) [?mCheckBombAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckBombAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckBombAttack(int32_t arg2)
	{
		_mCheckBombAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckBombAttack_mHRPc__QAE_NH_Z)(GameModule + 0x435b90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckJumpThrustAttack(class mHRPc* const this, int32_t arg2) [?mCheckJumpThrustAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckJumpThrustAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckJumpThrustAttack(int32_t arg2)
	{
		_mCheckJumpThrustAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckJumpThrustAttack_mHRPc__QAE_NH_Z)(GameModule + 0x435ba0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckChargeAttack(class mHRPc* const this, int32_t arg2) [?mCheckChargeAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckChargeAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckChargeAttack(int32_t arg2)
	{
		_mCheckChargeAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckChargeAttack_mHRPc__QAE_NH_Z)(GameModule + 0x435bb0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNunchackAttack(class mHRPc* const this, int32_t arg2) [?mCheckNunchackAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckNunchackAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckNunchackAttack(int32_t arg2)
	{
		_mCheckNunchackAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckNunchackAttack_mHRPc__QAE_NH_Z)(GameModule + 0x435d50);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckRangeAttack(class mHRPc* const this, int32_t arg2) [?mCheckRangeAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckRangeAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckRangeAttack(int32_t arg2)
	{
		_mCheckRangeAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckRangeAttack_mHRPc__QAE_NH_Z)(GameModule + 0x435d80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckThrowBeforeAttack(class mHRPc* const this, int32_t arg2) [?mCheckThrowBeforeAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckThrowBeforeAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckThrowBeforeAttack(int32_t arg2)
	{
		_mCheckThrowBeforeAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckThrowBeforeAttack_mHRPc__QAE_NH_Z)(GameModule + 0x435db0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCatchMiss(class mHRPc* const this, int32_t arg2) [?mCheckCatchMiss@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckCatchMiss_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckCatchMiss(int32_t arg2)
	{
		_mCheckCatchMiss_mHRPc__QAE_NH_Z mFunc = (_mCheckCatchMiss_mHRPc__QAE_NH_Z)(GameModule + 0x435dd0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mStartCatchAttack(class mHRPc* const this, class mHRChara* arg2) [?mStartCatchAttack@mHRPc@@QAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mStartCatchAttack_mHRPc__QAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mStartCatchAttack(class mHRChara* arg2)
	{
		_mStartCatchAttack_mHRPc__QAE_NPAVmHRChara___Z mFunc = (_mStartCatchAttack_mHRPc__QAE_NPAVmHRChara___Z)(GameModule + 0x435e10);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDownAttack(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mCheckDownAttack@mHRPc@@QAE_NH_N@Z]
	typedef uint8_t(__thiscall* _mCheckDownAttack_mHRPc__QAE_NH_N_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
	uint8_t mCheckDownAttack(int32_t arg2, uint8_t arg3)
	{
		_mCheckDownAttack_mHRPc__QAE_NH_N_Z mFunc = (_mCheckDownAttack_mHRPc__QAE_NH_N_Z)(GameModule + 0x435f70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFightCmbAttack(class mHRPc* const this) [?mCheckFightCmbAttack@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckFightCmbAttack_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckFightCmbAttack()
	{
		_mCheckFightCmbAttack_mHRPc__QAE_NXZ mFunc = (_mCheckFightCmbAttack_mHRPc__QAE_NXZ)(GameModule + 0x4360c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCityFightAttack(class mHRPc* const this, int32_t arg2) [?mCheckCityFightAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckCityFightAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckCityFightAttack(int32_t arg2)
	{
		_mCheckCityFightAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckCityFightAttack_mHRPc__QAE_NH_Z)(GameModule + 0x4360e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanAttack(class mHRPc* const this) [?mCheckCanAttack@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanAttack_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckCanAttack()
	{
		_mCheckCanAttack_mHRPc__UAE_NXZ mFunc = (_mCheckCanAttack_mHRPc__UAE_NXZ)(GameModule + 0x4360f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckAttackHit(class mHRPc* const this) [?mCheckAttackHit@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAttackHit_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckAttackHit()
	{
		_mCheckAttackHit_mHRPc__UAE_NXZ mFunc = (_mCheckAttackHit_mHRPc__UAE_NXZ)(GameModule + 0x436400);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckAttack(class mHRPc* const this) [?mCheckAttack@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAttack_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckAttack()
	{
		_mCheckAttack_mHRPc__UAE_NXZ mFunc = (_mCheckAttack_mHRPc__UAE_NXZ)(GameModule + 0x436580);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetHajikareWait(class mHRPc* const this) [?mSetHajikareWait@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetHajikareWait_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetHajikareWait()
	{
		_mSetHajikareWait_mHRPc__QAEXXZ mFunc = (_mSetHajikareWait_mHRPc__QAEXXZ)(GameModule + 0x436660);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckHajikareWait(class mHRPc* const this) [?mCheckHajikareWait@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckHajikareWait_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckHajikareWait()
	{
		_mCheckHajikareWait_mHRPc__QAE_NXZ mFunc = (_mCheckHajikareWait_mHRPc__QAE_NXZ)(GameModule + 0x4366d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetGuardWait(class mHRPc* const this, float arg2) [?mSetGuardWait@mHRPc@@QAEXM@Z]
	typedef void(__thiscall* _mSetGuardWait_mHRPc__QAEXM_Z)(class mHRPc* const thisPtr, float arg2);
	void mSetGuardWait(float arg2)
	{
		_mSetGuardWait_mHRPc__QAEXM_Z mFunc = (_mSetGuardWait_mHRPc__QAEXM_Z)(GameModule + 0x4366e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGuardWait(class mHRPc* const this, int32_t arg2) [?mCheckGuardWait@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckGuardWait_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckGuardWait(int32_t arg2)
	{
		_mCheckGuardWait_mHRPc__QAE_NH_Z mFunc = (_mCheckGuardWait_mHRPc__QAE_NH_Z)(GameModule + 0x436720);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckHajikare(class mHRPc* const this) [?mCheckHajikare@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckHajikare_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckHajikare()
	{
		_mCheckHajikare_mHRPc__QAE_NXZ mFunc = (_mCheckHajikare_mHRPc__QAE_NXZ)(GameModule + 0x436750);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGuardMotion(class mHRPc* const this, uint8_t arg2) [?mCheckGuardMotion@mHRPc@@UAE_N_N@Z]
	typedef uint8_t(__thiscall* _mCheckGuardMotion_mHRPc__UAE_N_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	uint8_t mCheckGuardMotion(uint8_t arg2)
	{
		_mCheckGuardMotion_mHRPc__UAE_N_N_Z mFunc = (_mCheckGuardMotion_mHRPc__UAE_N_N_Z)(GameModule + 0x436790);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mCheckRestorePadOffset(class mHRPc* const this) [?mCheckRestorePadOffset@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCheckRestorePadOffset_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCheckRestorePadOffset()
	{
		_mCheckRestorePadOffset_mHRPc__QAEXXZ mFunc = (_mCheckRestorePadOffset_mHRPc__QAEXXZ)(GameModule + 0x436820);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetPadOffset(class mHRPc* const this) [?mResetPadOffset@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetPadOffset_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetPadOffset()
	{
		_mResetPadOffset_mHRPc__QAEXXZ mFunc = (_mResetPadOffset_mHRPc__QAEXXZ)(GameModule + 0x436a20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetNeedShakeDir(class mHRPc* const this) [?mSetNeedShakeDir@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetNeedShakeDir_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetNeedShakeDir()
	{
		_mSetNeedShakeDir_mHRPc__QAEXXZ mFunc = (_mSetNeedShakeDir_mHRPc__QAEXXZ)(GameModule + 0x436a90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckContinueCombo(class mHRPc* const this) [?mCheckContinueCombo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckContinueCombo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckContinueCombo()
	{
		_mCheckContinueCombo_mHRPc__QAE_NXZ mFunc = (_mCheckContinueCombo_mHRPc__QAE_NXZ)(GameModule + 0x436ba0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckAtkUpper(class mHRPc* const this) [?mCheckAtkUpper@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAtkUpper_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckAtkUpper()
	{
		_mCheckAtkUpper_mHRPc__QAE_NXZ mFunc = (_mCheckAtkUpper_mHRPc__QAE_NXZ)(GameModule + 0x436d10);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetChargeMotionNo(class mHRPc* const this) [?mGetChargeMotionNo@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetChargeMotionNo_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetChargeMotionNo()
	{
		_mGetChargeMotionNo_mHRPc__QAEHXZ mFunc = (_mGetChargeMotionNo_mHRPc__QAEHXZ)(GameModule + 0x436d30);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetUpChargeAttackMotionNo(class mHRPc* const this) [?mGetUpChargeAttackMotionNo@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetUpChargeAttackMotionNo_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetUpChargeAttackMotionNo()
	{
		_mGetUpChargeAttackMotionNo_mHRPc__QAEHXZ mFunc = (_mGetUpChargeAttackMotionNo_mHRPc__QAEHXZ)(GameModule + 0x4370c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetCatch(class mHRPc* const this) [?mResetCatch@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetCatch_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetCatch()
	{
		_mResetCatch_mHRPc__QAEXXZ mFunc = (_mResetCatch_mHRPc__QAEXXZ)(GameModule + 0x437110);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTsubaOuterMotion(class mHRPc* const this, uint8_t arg2, int32_t arg3) [?mSetTsubaOuterMotion@mHRPc@@QAEX_NH@Z]
	typedef void(__thiscall* _mSetTsubaOuterMotion_mHRPc__QAEX_NH_Z)(class mHRPc* const thisPtr, uint8_t arg2, int32_t arg3);
	void mSetTsubaOuterMotion(uint8_t arg2, int32_t arg3)
	{
		_mSetTsubaOuterMotion_mHRPc__QAEX_NH_Z mFunc = (_mSetTsubaOuterMotion_mHRPc__QAEX_NH_Z)(GameModule + 0x4371e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTsubaDat(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mSetTsubaDat@mHRPc@@QAEXHE@Z]
	typedef void(__thiscall* _mSetTsubaDat_mHRPc__QAEXHE_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
	void mSetTsubaDat(int32_t arg2, uint8_t arg3)
	{
		_mSetTsubaDat_mHRPc__QAEXHE_Z mFunc = (_mSetTsubaDat_mHRPc__QAEXHE_Z)(GameModule + 0x437210);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mTsubazeriaiProc(class mHRPc* const this) [?mTsubazeriaiProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mTsubazeriaiProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mTsubazeriaiProc()
	{
		_mTsubazeriaiProc_mHRPc__QAEXXZ mFunc = (_mTsubazeriaiProc_mHRPc__QAEXXZ)(GameModule + 0x4372f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGuardDamageProc(class mHRPc* const this) [?mGuardDamageProc@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGuardDamageProc_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGuardDamageProc()
	{
		_mGuardDamageProc_mHRPc__QAE_NXZ mFunc = (_mGuardDamageProc_mHRPc__QAE_NXZ)(GameModule + 0x4378a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDamageProc(class mHRPc* const this) [?mDamageProc@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mDamageProc_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mDamageProc()
	{
		_mDamageProc_mHRPc__UAE_NXZ mFunc = (_mDamageProc_mHRPc__UAE_NXZ)(GameModule + 0x437c10);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetAttackDistance(class mHRPc* const this) [?mGetAttackDistance@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetAttackDistance_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetAttackDistance()
	{
		_mGetAttackDistance_mHRPc__QAEMXZ mFunc = (_mGetAttackDistance_mHRPc__QAEMXZ)(GameModule + 0x437c20);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetAttackDirection(class mHRPc* const this) [?mGetAttackDirection@mHRPc@@UAEMXZ]
	typedef float(__thiscall* _mGetAttackDirection_mHRPc__UAEMXZ)(class mHRPc* const thisPtr);
	float mGetAttackDirection()
	{
		_mGetAttackDirection_mHRPc__UAEMXZ mFunc = (_mGetAttackDirection_mHRPc__UAEMXZ)(GameModule + 0x437c60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestRunMotion(class mHRPc* const this) [?mTestRunMotion@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mTestRunMotion_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestRunMotion()
	{
		_mTestRunMotion_mHRPc__UAE_NXZ mFunc = (_mTestRunMotion_mHRPc__UAE_NXZ)(GameModule + 0x437ca0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDamageMotion(class mHRPc* const this) [?mCheckDamageMotion@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckDamageMotion_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckDamageMotion()
	{
		_mCheckDamageMotion_mHRPc__UAE_NXZ mFunc = (_mCheckDamageMotion_mHRPc__UAE_NXZ)(GameModule + 0x437d10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanHit(class mHRPc* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mCheckCanHit@mHRPc@@UAE_NH_N0@Z]
	typedef uint8_t(__thiscall* _mCheckCanHit_mHRPc__UAE_NH_N0_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
	uint8_t mCheckCanHit(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		_mCheckCanHit_mHRPc__UAE_NH_N0_Z mFunc = (_mCheckCanHit_mHRPc__UAE_NH_N0_Z)(GameModule + 0x437d90);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mHitCheck(class mHRPc* const this, class mHRChara* arg2) [?mHitCheck@mHRPc@@UAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mHitCheck_mHRPc__UAE_NPAVmHRChara___Z)(class mHRPc* const thisPtr, class mHRChara* arg2);
	uint8_t mHitCheck(class mHRChara* arg2)
	{
		_mHitCheck_mHRPc__UAE_NPAVmHRChara___Z mFunc = (_mHitCheck_mHRPc__UAE_NPAVmHRChara___Z)(GameModule + 0x438070);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetElectricDamage(class mHRPc* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, int32_t arg11) [?mSetElectricDamage@mHRPc@@QAE_NMHHHMHMMPAVmHRChara@@H@Z]
	typedef uint8_t(__thiscall* _mSetElectricDamage_mHRPc__QAE_NMHHHMHMMPAVmHRChara__H_Z)(class mHRPc* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, int32_t arg11);
	uint8_t mSetElectricDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, int32_t arg11)
	{
		_mSetElectricDamage_mHRPc__QAE_NMHHHMHMMPAVmHRChara__H_Z mFunc = (_mSetElectricDamage_mHRPc__QAE_NMHHHMHMMPAVmHRChara__H_Z)(GameModule + 0x4382a0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetDamage(class mHRPc* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@mHRPc@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_mHRPc__UAE_NMHHHMHMMPAVmHRChara___Z)(class mHRPc* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_mHRPc__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_mHRPc__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x438330);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mJudgeJustGuardInput(class mHRPc* const this) [?mJudgeJustGuardInput@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mJudgeJustGuardInput_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mJudgeJustGuardInput()
	{
		_mJudgeJustGuardInput_mHRPc__QAE_NXZ mFunc = (_mJudgeJustGuardInput_mHRPc__QAE_NXZ)(GameModule + 0x4398f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mJudgePiyori(class mHRPc* const this, float arg2) [?mJudgePiyori@mHRPc@@QAE_NM@Z]
	typedef uint8_t(__thiscall* _mJudgePiyori_mHRPc__QAE_NM_Z)(class mHRPc* const thisPtr, float arg2);
	uint8_t mJudgePiyori(float arg2)
	{
		_mJudgePiyori_mHRPc__QAE_NM_Z mFunc = (_mJudgePiyori_mHRPc__QAE_NM_Z)(GameModule + 0x439940);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mConvertGuardMotion(class mHRPc* const this, int32_t arg2, class mHRChara* arg3) [?mConvertGuardMotion@mHRPc@@QAEHHPAVmHRChara@@@Z]
	typedef int32_t(__thiscall* _mConvertGuardMotion_mHRPc__QAEHHPAVmHRChara___Z)(class mHRPc* const thisPtr, int32_t arg2, class mHRChara* arg3);
	int32_t mConvertGuardMotion(int32_t arg2, class mHRChara* arg3)
	{
		_mConvertGuardMotion_mHRPc__QAEHHPAVmHRChara___Z mFunc = (_mConvertGuardMotion_mHRPc__QAEHHPAVmHRChara___Z)(GameModule + 0x439ab0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDamageIK(class mHRPc* const this, class mHRChara* arg2, uint8_t arg3) [?mSetDamageIK@mHRPc@@QAEXPAVmHRChara@@_N@Z]
	typedef void(__thiscall* _mSetDamageIK_mHRPc__QAEXPAVmHRChara___N_Z)(class mHRPc* const thisPtr, class mHRChara* arg2, uint8_t arg3);
	void mSetDamageIK(class mHRChara* arg2, uint8_t arg3)
	{
		_mSetDamageIK_mHRPc__QAEXPAVmHRChara___N_Z mFunc = (_mSetDamageIK_mHRPc__QAEXPAVmHRChara___N_Z)(GameModule + 0x439f90);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckAutoGuard(class mHRPc* const this) [?mCheckAutoGuard@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAutoGuard_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckAutoGuard()
	{
		_mCheckAutoGuard_mHRPc__QAE_NXZ mFunc = (_mCheckAutoGuard_mHRPc__QAE_NXZ)(GameModule + 0x439fd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanGuard(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mCheckCanGuard@mHRPc@@QAE_N_N0@Z]
	typedef uint8_t(__thiscall* _mCheckCanGuard_mHRPc__QAE_N_N0_Z)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
	uint8_t mCheckCanGuard(uint8_t arg2, uint8_t arg3)
	{
		_mCheckCanGuard_mHRPc__QAE_N_N0_Z mFunc = (_mCheckCanGuard_mHRPc__QAE_N_N0_Z)(GameModule + 0x43a010);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBtlCommonMotNo(class mHRPc* const this, int32_t arg2) [?mGetBtlCommonMotNo@mHRPc@@UAEHH@Z]
	typedef int32_t(__thiscall* _mGetBtlCommonMotNo_mHRPc__UAEHH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mGetBtlCommonMotNo(int32_t arg2)
	{
		_mGetBtlCommonMotNo_mHRPc__UAEHH_Z mFunc = (_mGetBtlCommonMotNo_mHRPc__UAEHH_Z)(GameModule + 0x43a160);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepEffectVisible(class mHRPc* const this, uint8_t arg2) [?mSetWepEffectVisible@mHRPc@@UAEX_N@Z]
	typedef void(__thiscall* _mSetWepEffectVisible_mHRPc__UAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetWepEffectVisible(uint8_t arg2)
	{
		_mSetWepEffectVisible_mHRPc__UAEX_N_Z mFunc = (_mSetWepEffectVisible_mHRPc__UAEX_N_Z)(GameModule + 0x43a1d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepVisible(class mHRPc* const this, uint8_t arg2) [?mSetWepVisible@mHRPc@@UAEX_N@Z]
	typedef void(__thiscall* _mSetWepVisible_mHRPc__UAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetWepVisible(uint8_t arg2)
	{
		_mSetWepVisible_mHRPc__UAEX_N_Z mFunc = (_mSetWepVisible_mHRPc__UAEX_N_Z)(GameModule + 0x43a350);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetVisible(class mHRPc* const this, uint8_t arg2) [?mSetVisible@mHRPc@@UAEX_N@Z]
	typedef void(__thiscall* _mSetVisible_mHRPc__UAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetVisible(uint8_t arg2)
	{
		_mSetVisible_mHRPc__UAEX_N_Z mFunc = (_mSetVisible_mHRPc__UAEX_N_Z)(GameModule + 0x43a460);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCamera2TrvBack(class mHRPc* const this) [?mSetCamera2TrvBack@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetCamera2TrvBack_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetCamera2TrvBack()
	{
		_mSetCamera2TrvBack_mHRPc__QAEXXZ mFunc = (_mSetCamera2TrvBack_mHRPc__QAEXXZ)(GameModule + 0x43a4a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCameraInit(class mHRPc* const this) [?mSetCameraInit@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetCameraInit_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetCameraInit()
	{
		_mSetCameraInit_mHRPc__QAEXXZ mFunc = (_mSetCameraInit_mHRPc__QAEXXZ)(GameModule + 0x43a4c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallCameraInit(class mHRPc* const this) [?mCallCameraInit@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCallCameraInit_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCallCameraInit()
	{
		_mCallCameraInit_mHRPc__QAEXXZ mFunc = (_mCallCameraInit_mHRPc__QAEXXZ)(GameModule + 0x43a520);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCameraInitProcess(class mHRPc* const this) [?mCameraInitProcess@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCameraInitProcess_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCameraInitProcess()
	{
		_mCameraInitProcess_mHRPc__QAEXXZ mFunc = (_mCameraInitProcess_mHRPc__QAEXXZ)(GameModule + 0x43a550);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallTsubaBrendMotPorc(class mHRPc* const this, int32_t arg2, char arg3) [?mCallTsubaBrendMotPorc@mHRPc@@QAEXHC@Z]
	typedef void(__thiscall* _mCallTsubaBrendMotPorc_mHRPc__QAEXHC_Z)(class mHRPc* const thisPtr, int32_t arg2, char arg3);
	void mCallTsubaBrendMotPorc(int32_t arg2, char arg3)
	{
		_mCallTsubaBrendMotPorc_mHRPc__QAEXHC_Z mFunc = (_mCallTsubaBrendMotPorc_mHRPc__QAEXHC_Z)(GameModule + 0x43a620);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallCulcBrendRate(class mHRPc* const this, uint8_t arg2) [?mCallCulcBrendRate@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mCallCulcBrendRate_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mCallCulcBrendRate(uint8_t arg2)
	{
		_mCallCulcBrendRate_mHRPc__QAEX_N_Z mFunc = (_mCallCulcBrendRate_mHRPc__QAEX_N_Z)(GameModule + 0x43b3f0);
		return mFunc(this, arg2);
	}
	// [Function] class ghmGcCollObjCapsule* __convention("thiscall") mHRPc::mGetCollPtr(class mHRPc* const this) [?mGetCollPtr@mHRPc@@UAEPAVghmGcCollObjCapsule@@XZ]
	typedef class ghmGcCollObjCapsule*(__thiscall* _mGetCollPtr_mHRPc__UAEPAVghmGcCollObjCapsule__XZ)(class mHRPc* const thisPtr);
	class ghmGcCollObjCapsule* mGetCollPtr()
	{
		_mGetCollPtr_mHRPc__UAEPAVghmGcCollObjCapsule__XZ mFunc = (_mGetCollPtr_mHRPc__UAEPAVghmGcCollObjCapsule__XZ)(GameModule + 0x43b560);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mBossDeadCommonProcess(class mHRPc* const this) [?mBossDeadCommonProcess@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mBossDeadCommonProcess_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mBossDeadCommonProcess()
	{
		_mBossDeadCommonProcess_mHRPc__UAEXXZ mFunc = (_mBossDeadCommonProcess_mHRPc__UAEXXZ)(GameModule + 0x43b5b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayBattleIdolMotion(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mPlayBattleIdolMotion@mHRPc@@QAE_N_N0@Z]
	typedef uint8_t(__thiscall* _mPlayBattleIdolMotion_mHRPc__QAE_N_N0_Z)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
	uint8_t mPlayBattleIdolMotion(uint8_t arg2, uint8_t arg3)
	{
		_mPlayBattleIdolMotion_mHRPc__QAE_N_N0_Z mFunc = (_mPlayBattleIdolMotion_mHRPc__QAE_N_N0_Z)(GameModule + 0x43b5e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetValueAtPlayMotion(class mHRPc* const this) [?mResetValueAtPlayMotion@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetValueAtPlayMotion_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetValueAtPlayMotion()
	{
		_mResetValueAtPlayMotion_mHRPc__QAEXXZ mFunc = (_mResetValueAtPlayMotion_mHRPc__QAEXXZ)(GameModule + 0x43b650);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionBlend(class mHRPc* const this, class TGan** arg2, char arg3) [?mPlayMotionBlend@mHRPc@@UAE_NPAPAVTGan@@C@Z]
	typedef uint8_t(__thiscall* _mPlayMotionBlend_mHRPc__UAE_NPAPAVTGan__C_Z)(class mHRPc* const thisPtr, class TGan** arg2, char arg3);
	uint8_t mPlayMotionBlend(class TGan** arg2, char arg3)
	{
		_mPlayMotionBlend_mHRPc__UAE_NPAPAVTGan__C_Z mFunc = (_mPlayMotionBlend_mHRPc__UAE_NPAPAVTGan__C_Z)(GameModule + 0x43b680);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionBlend(class mHRPc* const this, int32_t arg2, char arg3, uint8_t arg4, uint8_t arg5) [?mPlayMotionBlend@mHRPc@@UAE_NHC_N0@Z]
	typedef uint8_t(__thiscall* _mPlayMotionBlend_mHRPc__UAE_NHC_N0_Z_2)(class mHRPc* const thisPtr, int32_t arg2, char arg3, uint8_t arg4, uint8_t arg5);
	uint8_t mPlayMotionBlend_2(int32_t arg2, char arg3, uint8_t arg4, uint8_t arg5)
	{
		_mPlayMotionBlend_mHRPc__UAE_NHC_N0_Z_2 mFunc = (_mPlayMotionBlend_mHRPc__UAE_NHC_N0_Z_2)(GameModule + 0x43b7c0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotion(class mHRPc* const this, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6) [?mPlayMotion@mHRPc@@UAE_NH_NH0M@Z]
	typedef uint8_t(__thiscall* _mPlayMotion_mHRPc__UAE_NH_NH0M_Z)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6);
	uint8_t mPlayMotion(int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6)
	{
		_mPlayMotion_mHRPc__UAE_NH_NH0M_Z mFunc = (_mPlayMotion_mHRPc__UAE_NH_NH0M_Z)(GameModule + 0x43b810);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] class TGan** __convention("thiscall") mHRPc::mGetAtkMotPPtr(class mHRPc* const this, int32_t arg2) [?mGetAtkMotPPtr@mHRPc@@QAEPAPAVTGan@@H@Z]
	typedef class TGan**(__thiscall* _mGetAtkMotPPtr_mHRPc__QAEPAPAVTGan__H_Z)(class mHRPc* const thisPtr, int32_t arg2);
	// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetAtkMotPPtr(int32_t arg2)
	{
		_mGetAtkMotPPtr_mHRPc__QAEPAPAVTGan__H_Z mFunc = (_mGetAtkMotPPtr_mHRPc__QAEPAPAVTGan__H_Z)(GameModule + 0x43c300);
		mFunc(this, arg2);
	}
	// [Function] class TGan* __convention("thiscall") mHRPc::mGetAtkMotPtr(class mHRPc* const this, int32_t arg2) [?mGetAtkMotPtr@mHRPc@@QAEPAVTGan@@H@Z]
	typedef class TGan*(__thiscall* _mGetAtkMotPtr_mHRPc__QAEPAVTGan__H_Z)(class mHRPc* const thisPtr, int32_t arg2);
	class TGan* mGetAtkMotPtr(int32_t arg2)
	{
		_mGetAtkMotPtr_mHRPc__QAEPAVTGan__H_Z mFunc = (_mGetAtkMotPtr_mHRPc__QAEPAVTGan__H_Z)(GameModule + 0x43c3e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mRequestReadAtkMot(class mHRPc* const this) [?mRequestReadAtkMot@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mRequestReadAtkMot_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mRequestReadAtkMot()
	{
		_mRequestReadAtkMot_mHRPc__QAE_NXZ mFunc = (_mRequestReadAtkMot_mHRPc__QAE_NXZ)(GameModule + 0x43c4b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mReleaseAtkMot(class mHRPc* const this) [?mReleaseAtkMot@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mReleaseAtkMot_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mReleaseAtkMot()
	{
		_mReleaseAtkMot_mHRPc__QAE_NXZ mFunc = (_mReleaseAtkMot_mHRPc__QAE_NXZ)(GameModule + 0x43c520);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNeedModelRead(class mHRPc* const this, int32_t arg2) [?mCheckNeedModelRead@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckNeedModelRead_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckNeedModelRead(int32_t arg2)
	{
		_mCheckNeedModelRead_mHRPc__QAE_NH_Z mFunc = (_mCheckNeedModelRead_mHRPc__QAE_NH_Z)(GameModule + 0x43c570);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mChangeTShirtModel(class mHRPc* const this, int32_t arg2) [?mChangeTShirtModel@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mChangeTShirtModel_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mChangeTShirtModel(int32_t arg2)
	{
		_mChangeTShirtModel_mHRPc__QAE_NH_Z mFunc = (_mChangeTShirtModel_mHRPc__QAE_NH_Z)(GameModule + 0x43c850);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetNoWearJacket(class mHRPc* const this, uint8_t arg2) [?mSetNoWearJacket@mHRPc@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _mSetNoWearJacket_mHRPc__QAE_N_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	uint8_t mSetNoWearJacket(uint8_t arg2)
	{
		_mSetNoWearJacket_mHRPc__QAE_N_N_Z mFunc = (_mSetNoWearJacket_mHRPc__QAE_N_N_Z)(GameModule + 0x43c990);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mControlDispWestWeapon(class mHRPc* const this, int32_t arg2, char* arg3) [?mControlDispWestWeapon@mHRPc@@QAEXHPAD@Z]
	typedef void(__thiscall* _mControlDispWestWeapon_mHRPc__QAEXHPAD_Z)(class mHRPc* const thisPtr, int32_t arg2, char* arg3);
	void mControlDispWestWeapon(int32_t arg2, std::string arg3)
	{
		std::vector<char> arg3_c_str(arg3.c_str(), + arg3.c_str() + arg3.size() + 1);
		_mControlDispWestWeapon_mHRPc__QAEXHPAD_Z mFunc = (_mControlDispWestWeapon_mHRPc__QAEXHPAD_Z)(GameModule + 0x43c9e0);
		return mFunc(this, arg2, &arg3_c_str[0]);
	}
	// [Function] void __convention("thiscall") mHRPc::mDetachWeapon(class mHRPc* const this, int32_t arg2) [?mDetachWeapon@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mDetachWeapon_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mDetachWeapon(int32_t arg2)
	{
		_mDetachWeapon_mHRPc__QAEXH_Z mFunc = (_mDetachWeapon_mHRPc__QAEXH_Z)(GameModule + 0x43caa0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mAttachWeapon(class mHRPc* const this, int32_t arg2) [?mAttachWeapon@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mAttachWeapon_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mAttachWeapon(int32_t arg2)
	{
		_mAttachWeapon_mHRPc__QAEXH_Z mFunc = (_mAttachWeapon_mHRPc__QAEXH_Z)(GameModule + 0x43cb10);
		return mFunc(this, arg2);
	}
	// [Function] void mHRPc::mRenderFpsCursor(void* arg1) [?mRenderFpsCursor@mHRPc@@SAXPAX@Z]
	typedef void(__fastcall* _mRenderFpsCursor_mHRPc__SAXPAX_Z)(void* arg1);
	static void mRenderFpsCursor(void* arg1)
	{
		_mRenderFpsCursor_mHRPc__SAXPAX_Z mFunc = (_mRenderFpsCursor_mHRPc__SAXPAX_Z)(GameModule + 0x43cc10);
		return mFunc(arg1);
	}
	// [Function] void __convention("thiscall") mHRPc::mAddTension(class mHRPc* const this, float arg2) [?mAddTension@mHRPc@@UAEXM@Z]
	typedef void(__thiscall* _mAddTension_mHRPc__UAEXM_Z)(class mHRPc* const thisPtr, float arg2);
	void mAddTension(float arg2)
	{
		_mAddTension_mHRPc__UAEXM_Z mFunc = (_mAddTension_mHRPc__UAEXM_Z)(GameModule + 0x43cca0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWarpPos(class mHRPc* const this, struct Vec& arg2, uint8_t arg3) [?mSetWarpPos@mHRPc@@UAEXABUVec@@_N@Z]
	typedef void(__thiscall* _mSetWarpPos_mHRPc__UAEXABUVec___N_Z)(class mHRPc* const thisPtr, struct Vec& arg2, uint8_t arg3);
	void mSetWarpPos(struct Vec& arg2, uint8_t arg3)
	{
		_mSetWarpPos_mHRPc__UAEXABUVec___N_Z mFunc = (_mSetWarpPos_mHRPc__UAEXABUVec___N_Z)(GameModule + 0x43cd20);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mRenderShadowProc(class mHRPc* const this) [?mRenderShadowProc@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mRenderShadowProc_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mRenderShadowProc()
	{
		_mRenderShadowProc_mHRPc__UAEXXZ mFunc = (_mRenderShadowProc_mHRPc__UAEXXZ)(GameModule + 0x43cdc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPostRenderProc(class mHRPc* const this) [?mPostRenderProc@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostRenderProc_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mPostRenderProc()
	{
		_mPostRenderProc_mHRPc__UAE_NXZ mFunc = (_mPostRenderProc_mHRPc__UAE_NXZ)(GameModule + 0x43ce80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mRenderProc(class mHRPc* const this) [?mRenderProc@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mRenderProc_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mRenderProc()
	{
		_mRenderProc_mHRPc__UAE_NXZ mFunc = (_mRenderProc_mHRPc__UAE_NXZ)(GameModule + 0x43ce90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSemitransparentProcess(class mHRPc* const this) [?mSemitransparentProcess@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mSemitransparentProcess_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mSemitransparentProcess()
	{
		_mSemitransparentProcess_mHRPc__UAEXXZ mFunc = (_mSemitransparentProcess_mHRPc__UAEXXZ)(GameModule + 0x43cf80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPostFrameCommonProc2(class mHRPc* const this) [?mPostFrameCommonProc2@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameCommonProc2_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mPostFrameCommonProc2()
	{
		_mPostFrameCommonProc2_mHRPc__UAE_NXZ mFunc = (_mPostFrameCommonProc2_mHRPc__UAE_NXZ)(GameModule + 0x43d3c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPostFrameProc(class mHRPc* const this) [?mPostFrameProc@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameProc_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mPostFrameProc()
	{
		_mPostFrameProc_mHRPc__UAE_NXZ mFunc = (_mPostFrameProc_mHRPc__UAE_NXZ)(GameModule + 0x43d5c0);
		return mFunc(this);
	}
private:
	// Hook: Pre
	inline static _mPostFrameProc_mHRPc__UAE_NXZ _original_mPostFrameProc = nullptr;
	inline static std::unordered_set<std::string> _callbacks_mPostFrameProc_pre;
	inline static std::unordered_set<std::string> _callbacks_mPostFrameProc_post;
	static uint8_t __fastcall mPostFrameProc_OnHook(class mHRPc* const thisPtr, void* EDX)
	{
#if WITH_LUA
		std::unordered_set<std::string>::iterator it = _callbacks_mPostFrameProc_pre.begin();
		while (it != _callbacks_mPostFrameProc_pre.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mPostFrameProc_pre.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		uint8_t Result = _original_mPostFrameProc(thisPtr);
#if WITH_LUA
		it = _callbacks_mPostFrameProc_post.begin();
		while (it != _callbacks_mPostFrameProc_post.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mPostFrameProc_post.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		return Result;
	}
public:
	// Hook: Register
#if WITH_LUA
	static void mPostFrameProc_RegisterHook(std::string HookName, bool bPostHook)
	{
		if (!HookName.empty() && !bPostHook) _callbacks_mPostFrameProc_pre.insert(HookName);
		if (!HookName.empty() && bPostHook) _callbacks_mPostFrameProc_post.insert(HookName);
		if (_original_mPostFrameProc == nullptr)
		{
			_original_mPostFrameProc = (_mPostFrameProc_mHRPc__UAE_NXZ)mem::TrampHook((BYTE*)GameModule + 0x43d5c0, (BYTE*)mPostFrameProc_OnHook, 0xb);
			assert(_original_mPostFrameProc);
		}
	}
#endif
	// [Function] uint8_t __convention("thiscall") mHRPc::mPcRestoreDamage(class mHRPc* const this, uint8_t arg2) [?mPcRestoreDamage@mHRPc@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _mPcRestoreDamage_mHRPc__QAE_N_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	uint8_t mPcRestoreDamage(uint8_t arg2)
	{
		_mPcRestoreDamage_mHRPc__QAE_N_N_Z mFunc = (_mPcRestoreDamage_mHRPc__QAE_N_N_Z)(GameModule + 0x43d5e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::checkAndPlayCameraBankMotion(class mHRPc* const this) [?checkAndPlayCameraBankMotion@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _checkAndPlayCameraBankMotion_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void checkAndPlayCameraBankMotion()
	{
		_checkAndPlayCameraBankMotion_mHRPc__AAEXXZ mFunc = (_checkAndPlayCameraBankMotion_mHRPc__AAEXXZ)(GameModule + 0x43d750);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::checkAndBootStageHitEffect(class mHRPc* const this) [?checkAndBootStageHitEffect@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _checkAndBootStageHitEffect_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void checkAndBootStageHitEffect()
	{
		_checkAndBootStageHitEffect_mHRPc__AAEXXZ mFunc = (_checkAndBootStageHitEffect_mHRPc__AAEXXZ)(GameModule + 0x43d760);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::onUpdateIK(class mHRPc* const this) [?onUpdateIK@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _onUpdateIK_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void onUpdateIK()
	{
		_onUpdateIK_mHRPc__AAEXXZ mFunc = (_onUpdateIK_mHRPc__AAEXXZ)(GameModule + 0x43da20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDamageElectroShockProc(class mHRPc* const this) [?mDamageElectroShockProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mDamageElectroShockProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mDamageElectroShockProc()
	{
		_mDamageElectroShockProc_mHRPc__QAEXXZ mFunc = (_mDamageElectroShockProc_mHRPc__QAEXXZ)(GameModule + 0x43de30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDamageDownLeverGachaProc(class mHRPc* const this) [?mDamageDownLeverGachaProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mDamageDownLeverGachaProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mDamageDownLeverGachaProc()
	{
		_mDamageDownLeverGachaProc_mHRPc__QAEXXZ mFunc = (_mDamageDownLeverGachaProc_mHRPc__QAEXXZ)(GameModule + 0x43df10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSpecialWalkProc(class mHRPc* const this) [?mSpecialWalkProc@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSpecialWalkProc_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSpecialWalkProc()
	{
		_mSpecialWalkProc_mHRPc__QAEXXZ mFunc = (_mSpecialWalkProc_mHRPc__QAEXXZ)(GameModule + 0x43e340);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckHaveWep(class mHRPc* const this, int32_t WepID) [?mCheckHaveWep@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckHaveWep_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t WepID);
	uint8_t mCheckHaveWep(int32_t WepID)
	{
		_mCheckHaveWep_mHRPc__QAE_NH_Z mFunc = (_mCheckHaveWep_mHRPc__QAE_NH_Z)(GameModule + 0x43e9d0);
		return mFunc(this, WepID);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mChangeWeaponProcess(class mHRPc* const this) [?mChangeWeaponProcess@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mChangeWeaponProcess_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mChangeWeaponProcess()
	{
		_mChangeWeaponProcess_mHRPc__QAE_NXZ mFunc = (_mChangeWeaponProcess_mHRPc__QAE_NXZ)(GameModule + 0x43ea30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::TryChangeWeapon(class mHRPc* const this) [?TryChangeWeapon@mHRPc@@AAEXXZ]
	typedef void(__thiscall* _TryChangeWeapon_mHRPc__AAEXXZ)(class mHRPc* const thisPtr);
	void TryChangeWeapon()
	{
		_TryChangeWeapon_mHRPc__AAEXXZ mFunc = (_TryChangeWeapon_mHRPc__AAEXXZ)(GameModule + 0x43ee70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartChangeWeapon(class mHRPc* const this) [?mStartChangeWeapon@mHRPc@@QAEXXZ]
	/// <summary>
	/// Makes Travis put away his weapon... and then immediately pull it out again.
	/// </summary>
	typedef void(__thiscall* _mStartChangeWeapon_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mStartChangeWeapon()
	{
		_mStartChangeWeapon_mHRPc__QAEXXZ mFunc = (_mStartChangeWeapon_mHRPc__QAEXXZ)(GameModule + 0x43f1f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mFrameProc(class mHRPc* const this) [?mFrameProc@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mFrameProc_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mFrameProc()
	{
		_mFrameProc_mHRPc__UAE_NXZ mFunc = (_mFrameProc_mHRPc__UAE_NXZ)(GameModule + 0x43f290);
		return mFunc(this);
	}
private:
	// Hook: Pre
	inline static _mFrameProc_mHRPc__UAE_NXZ _original_mFrameProc = nullptr;
	inline static std::unordered_set<std::string> _callbacks_mFrameProc_pre;
	inline static std::unordered_set<std::string> _callbacks_mFrameProc_post;
	static uint8_t __fastcall mFrameProc_OnHook(class mHRPc* const thisPtr, void* EDX)
	{
#if WITH_LUA
		std::unordered_set<std::string>::iterator it = _callbacks_mFrameProc_pre.begin();
		while (it != _callbacks_mFrameProc_pre.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mFrameProc_pre.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		uint8_t Result = _original_mFrameProc(thisPtr);
#if WITH_LUA
		it = _callbacks_mFrameProc_post.begin();
		while (it != _callbacks_mFrameProc_post.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mFrameProc_post.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		return Result;
	}
public:
	// Hook: Register
#if WITH_LUA
	static void mFrameProc_RegisterHook(std::string HookName, bool bPostHook)
	{
		if (!HookName.empty() && !bPostHook) _callbacks_mFrameProc_pre.insert(HookName);
		if (!HookName.empty() && bPostHook) _callbacks_mFrameProc_post.insert(HookName);
		if (_original_mFrameProc == nullptr)
		{
			_original_mFrameProc = (_mFrameProc_mHRPc__UAE_NXZ)mem::TrampHook((BYTE*)GameModule + 0x43f290, (BYTE*)mFrameProc_OnHook, 0x6);
			assert(_original_mFrameProc);
		}
	}
#endif
	// [Function] void __convention("thiscall") mHRPc::mSetOffGroundIk(class mHRPc* const this) [?mSetOffGroundIk@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetOffGroundIk_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetOffGroundIk()
	{
		_mSetOffGroundIk_mHRPc__QAEXXZ mFunc = (_mSetOffGroundIk_mHRPc__QAEXXZ)(GameModule + 0x442bc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mInitData(class mHRPc* const this) [?mInitData@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mInitData_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mInitData()
	{
		_mInitData_mHRPc__QAEXXZ mFunc = (_mInitData_mHRPc__QAEXXZ)(GameModule + 0x442c00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mEffectInit(class mHRPc* const this) [?mEffectInit@mHRPc@@UAEXXZ]
	typedef void(__thiscall* _mEffectInit_mHRPc__UAEXXZ)(class mHRPc* const thisPtr);
	void mEffectInit()
	{
		_mEffectInit_mHRPc__UAEXXZ mFunc = (_mEffectInit_mHRPc__UAEXXZ)(GameModule + 0x442c10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTerm(class mHRPc* const this) [?mTerm@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mTerm_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTerm()
	{
		_mTerm_mHRPc__UAE_NXZ mFunc = (_mTerm_mHRPc__UAE_NXZ)(GameModule + 0x442d00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mInit(class mHRPc* const this) [?mInit@mHRPc@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mInit_mHRPc__UAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mInit()
	{
		_mInit_mHRPc__UAE_NXZ mFunc = (_mInit_mHRPc__UAE_NXZ)(GameModule + 0x4433d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanOperate(class mHRPc* const this) [?mCheckCanOperate@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanOperate_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckCanOperate()
	{
		_mCheckCanOperate_mHRPc__QAE_NXZ mFunc = (_mCheckCanOperate_mHRPc__QAE_NXZ)(GameModule + 0x443b70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOutsidePlayMotion(class mHRPc* const this) [?mSetOutsidePlayMotion@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetOutsidePlayMotion_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetOutsidePlayMotion()
	{
		_mSetOutsidePlayMotion_mHRPc__QAEXXZ mFunc = (_mSetOutsidePlayMotion_mHRPc__QAEXXZ)(GameModule + 0x443ca0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetEquipTextureName(class mHRPc* const this, char* arg2, int32_t arg3) [?mGetEquipTextureName@mHRPc@@QAEXPADH@Z]
	typedef void(__thiscall* _mGetEquipTextureName_mHRPc__QAEXPADH_Z)(class mHRPc* const thisPtr, char* arg2, int32_t arg3);
	void mGetEquipTextureName(std::string arg2, int32_t arg3)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_mGetEquipTextureName_mHRPc__QAEXPADH_Z mFunc = (_mGetEquipTextureName_mHRPc__QAEXPADH_Z)(GameModule + 0x443cb0);
		return mFunc(this, &arg2_c_str[0], arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetEquipModelName(class mHRPc* const this, char* arg2, int32_t arg3, uint8_t arg4) [?mGetEquipModelName@mHRPc@@QAEXPADH_N@Z]
	typedef void(__thiscall* _mGetEquipModelName_mHRPc__QAEXPADH_N_Z)(class mHRPc* const thisPtr, char* arg2, int32_t arg3, uint8_t arg4);
	void mGetEquipModelName(std::string arg2, int32_t arg3, uint8_t arg4)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_mGetEquipModelName_mHRPc__QAEXPADH_N_Z mFunc = (_mGetEquipModelName_mHRPc__QAEXPADH_N_Z)(GameModule + 0x443d30);
		return mFunc(this, &arg2_c_str[0], arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mTermWarpPosForSantDestroy(class mHRPc* const this) [?mTermWarpPosForSantDestroy@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mTermWarpPosForSantDestroy_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mTermWarpPosForSantDestroy()
	{
		_mTermWarpPosForSantDestroy_mHRPc__QAEXXZ mFunc = (_mTermWarpPosForSantDestroy_mHRPc__QAEXXZ)(GameModule + 0x445240);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSubDarkSideTick(class mHRPc* const this) [?mSubDarkSideTick@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSubDarkSideTick_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSubDarkSideTick()
	{
		_mSubDarkSideTick_mHRPc__QAEXXZ mFunc = (_mSubDarkSideTick_mHRPc__QAEXXZ)(GameModule + 0x445440);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mEquipProc(class mHRPc* const this) [?mEquipProc@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mEquipProc_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mEquipProc()
	{
		_mEquipProc_mHRPc__QAE_NXZ mFunc = (_mEquipProc_mHRPc__QAE_NXZ)(GameModule + 0x445470);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBeforeAttackHit(class mHRPc* const this) [?mCheckBeforeAttackHit@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckBeforeAttackHit_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckBeforeAttackHit()
	{
		_mCheckBeforeAttackHit_mHRPc__QAE_NXZ mFunc = (_mCheckBeforeAttackHit_mHRPc__QAE_NXZ)(GameModule + 0x446450);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckPcReadEndWithoutWeapon(class mHRPc* const this) [?mCheckPcReadEndWithoutWeapon@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckPcReadEndWithoutWeapon_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckPcReadEndWithoutWeapon()
	{
		_mCheckPcReadEndWithoutWeapon_mHRPc__QAE_NXZ mFunc = (_mCheckPcReadEndWithoutWeapon_mHRPc__QAE_NXZ)(GameModule + 0x4464b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFightAttack(class mHRPc* const this, int32_t arg2) [?mCheckFightAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckFightAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckFightAttack(int32_t arg2)
	{
		_mCheckFightAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckFightAttack_mHRPc__QAE_NH_Z)(GameModule + 0x446500);
		return mFunc(this, arg2);
	}
	// [Function] bool __convention("thiscall") mHRPc::mCheckCatchAttack(class mHRPc* const this, int32_t arg2) [?mCheckCatchAttack@mHRPc@@QAE_NH@Z]
	typedef bool(__thiscall* _mCheckCatchAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	bool mCheckCatchAttack(int32_t arg2)
	{
		_mCheckCatchAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckCatchAttack_mHRPc__QAE_NH_Z)(GameModule + 0x446570);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallAttackEffect(class mHRPc* const this, enum enPcAttackEffect arg2, class mHRChara* arg3, uint8_t arg4, struct Vec* arg5) [?mCallAttackEffect@mHRPc@@QAE_NW4enPcAttackEffect@@PAVmHRChara@@_NPAUVec@@@Z]
	typedef uint8_t(__thiscall* _mCallAttackEffect_mHRPc__QAE_NW4enPcAttackEffect__PAVmHRChara___NPAUVec___Z)(class mHRPc* const thisPtr, enum enPcAttackEffect arg2, class mHRChara* arg3, uint8_t arg4, struct Vec* arg5);
	uint8_t mCallAttackEffect(/* enum enPcAttackEffect */ uint32_t arg2, class mHRChara* arg3, uint8_t arg4, struct Vec* arg5)
	{
		_mCallAttackEffect_mHRPc__QAE_NW4enPcAttackEffect__PAVmHRChara___NPAUVec___Z mFunc = (_mCallAttackEffect_mHRPc__QAE_NW4enPcAttackEffect__PAVmHRChara___NPAUVec___Z)(GameModule + 0x4465c0);
		return mFunc(this, (enum enPcAttackEffect)arg2, arg3, arg4, arg5);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::SetPcSpeedBlurOff(class mHRPc* const this) [?SetPcSpeedBlurOff@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _SetPcSpeedBlurOff_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t SetPcSpeedBlurOff()
	{
		_SetPcSpeedBlurOff_mHRPc__QAE_NXZ mFunc = (_SetPcSpeedBlurOff_mHRPc__QAE_NXZ)(GameModule + 0x446e20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStopLightSabelSound(class mHRPc* const this, uint8_t arg2) [?mStopLightSabelSound@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mStopLightSabelSound_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mStopLightSabelSound(uint8_t arg2)
	{
		_mStopLightSabelSound_mHRPc__QAEX_N_Z mFunc = (_mStopLightSabelSound_mHRPc__QAEX_N_Z)(GameModule + 0x446e40);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetPcPower(class mHRPc* const this) [?mGetPcPower@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetPcPower_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetPcPower()
	{
		_mGetPcPower_mHRPc__QAEMXZ mFunc = (_mGetPcPower_mHRPc__QAEMXZ)(GameModule + 0x446e80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mRestorePcData(class mHRPc* const this, struct stPcSaveData* SaveData) [?mRestorePcData@mHRPc@@QAEXPAUstPcSaveData@@@Z]
	typedef void(__thiscall* _mRestorePcData_mHRPc__QAEXPAUstPcSaveData___Z)(class mHRPc* const thisPtr, struct stPcSaveData* SaveData);
	void mRestorePcData(struct stPcSaveData* SaveData)
	{
		_mRestorePcData_mHRPc__QAEXPAUstPcSaveData___Z mFunc = (_mRestorePcData_mHRPc__QAEXPAUstPcSaveData___Z)(GameModule + 0x446eb0);
		return mFunc(this, SaveData);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockEverythingForDeathmatch(class mHRPc* const this) [?UnlockEverythingForDeathmatch@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _UnlockEverythingForDeathmatch_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void UnlockEverythingForDeathmatch()
	{
		_UnlockEverythingForDeathmatch_mHRPc__QAEXXZ mFunc = (_UnlockEverythingForDeathmatch_mHRPc__QAEXXZ)(GameModule + 0x4473e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetDeadFlag(class mHRPc* const this) [?mResetDeadFlag@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetDeadFlag_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetDeadFlag()
	{
		_mResetDeadFlag_mHRPc__QAEXXZ mFunc = (_mResetDeadFlag_mHRPc__QAEXXZ)(GameModule + 0x447580);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBatteryMaxAllWeapon(class mHRPc* const this) [?mSetBatteryMaxAllWeapon@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetBatteryMaxAllWeapon_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetBatteryMaxAllWeapon()
	{
		_mSetBatteryMaxAllWeapon_mHRPc__QAEXXZ mFunc = (_mSetBatteryMaxAllWeapon_mHRPc__QAEXXZ)(GameModule + 0x4475c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayLightSabelSound(class mHRPc* const this) [?mPlayLightSabelSound@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mPlayLightSabelSound_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mPlayLightSabelSound()
	{
		_mPlayLightSabelSound_mHRPc__QAEXXZ mFunc = (_mPlayLightSabelSound_mHRPc__QAEXXZ)(GameModule + 0x447600);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::TurnOffLaserEffectOnPlayer(class mHRPc* const this) [?TurnOffLaserEffectOnPlayer@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _TurnOffLaserEffectOnPlayer_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void TurnOffLaserEffectOnPlayer()
	{
		_TurnOffLaserEffectOnPlayer_mHRPc__QAEXXZ mFunc = (_TurnOffLaserEffectOnPlayer_mHRPc__QAEXXZ)(GameModule + 0x447710);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearBossInit(class mHRPc* const this) [?mClearBossInit@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearBossInit_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearBossInit()
	{
		_mClearBossInit_mHRPc__QAEXXZ mFunc = (_mClearBossInit_mHRPc__QAEXXZ)(GameModule + 0x4477a0);
		return mFunc(this);
	}
	// [Function] struct stPcSaveData* __convention("thiscall") mHRPc::mGetPcSaveData(class mHRPc* const this, uint8_t arg2, struct stPcSaveData* InSaveData) [?mGetPcSaveData@mHRPc@@QAEPAUstPcSaveData@@_NPAU2@@Z]
	typedef struct stPcSaveData*(__thiscall* _mGetPcSaveData_mHRPc__QAEPAUstPcSaveData___NPAU2__Z)(class mHRPc* const thisPtr, uint8_t arg2, struct stPcSaveData* InSaveData);
	struct stPcSaveData* mGetPcSaveData(uint8_t arg2, struct stPcSaveData* InSaveData)
	{
		_mGetPcSaveData_mHRPc__QAEPAUstPcSaveData___NPAU2__Z mFunc = (_mGetPcSaveData_mHRPc__QAEPAUstPcSaveData___NPAU2__Z)(GameModule + 0x447820);
		return mFunc(this, arg2, InSaveData);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::TestStorePcPosForSM(class mHRPc* const this) [?TestStorePcPosForSM@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _TestStorePcPosForSM_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t TestStorePcPosForSM()
	{
		_TestStorePcPosForSM_mHRPc__QAE_NXZ mFunc = (_TestStorePcPosForSM_mHRPc__QAE_NXZ)(GameModule + 0x447c10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::ReStorePcPosForSM(class mHRPc* const this) [?ReStorePcPosForSM@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _ReStorePcPosForSM_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void ReStorePcPosForSM()
	{
		_ReStorePcPosForSM_mHRPc__QAEXXZ mFunc = (_ReStorePcPosForSM_mHRPc__QAEXXZ)(GameModule + 0x447c20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckIntoStatusScreen(class mHRPc* const this) [?mCheckIntoStatusScreen@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckIntoStatusScreen_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckIntoStatusScreen()
	{
		_mCheckIntoStatusScreen_mHRPc__QAE_NXZ mFunc = (_mCheckIntoStatusScreen_mHRPc__QAE_NXZ)(GameModule + 0x447d40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionFromDatPtr(class mHRPc* const this, class TGan* arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6) [?mPlayMotionFromDatPtr@mHRPc@@QAE_NPAVTGan@@_NH1M@Z]
	typedef uint8_t(__thiscall* _mPlayMotionFromDatPtr_mHRPc__QAE_NPAVTGan___NH1M_Z)(class mHRPc* const thisPtr, class TGan* arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6);
	uint8_t mPlayMotionFromDatPtr(class TGan* arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6)
	{
		_mPlayMotionFromDatPtr_mHRPc__QAE_NPAVTGan___NH1M_Z mFunc = (_mPlayMotionFromDatPtr_mHRPc__QAE_NPAVTGan___NH1M_Z)(GameModule + 0x447d60);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishAttack(class mHRPc* const this, int32_t arg2) [?mCheckFinishAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckFinishAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckFinishAttack(int32_t arg2)
	{
		_mCheckFinishAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckFinishAttack_mHRPc__QAE_NH_Z)(GameModule + 0x4480b0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTsubazering(class mHRPc* const this, int32_t arg2) [?mCheckTsubazering@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckTsubazering_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckTsubazering(int32_t arg2)
	{
		_mCheckTsubazering_mHRPc__QAE_NH_Z mFunc = (_mCheckTsubazering_mHRPc__QAE_NH_Z)(GameModule + 0x4481d0);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") mHRPc::mGetBikePos(class mHRPc* const this) [?mGetBikePos@mHRPc@@QAEAAUVec@@XZ]
	typedef struct Vec&(__thiscall* _mGetBikePos_mHRPc__QAEAAUVec__XZ)(class mHRPc* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetBikePos()
	{
		_mGetBikePos_mHRPc__QAEAAUVec__XZ mFunc = (_mGetBikePos_mHRPc__QAEAAUVec__XZ)(GameModule + 0x448240);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestBikeRide(class mHRPc* const this) [?mTestBikeRide@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestBikeRide_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestBikeRide()
	{
		_mTestBikeRide_mHRPc__QAE_NXZ mFunc = (_mTestBikeRide_mHRPc__QAE_NXZ)(GameModule + 0x448250);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPadOffset(class mHRPc* const this) [?mSetPadOffset@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetPadOffset_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetPadOffset()
	{
		_mSetPadOffset_mHRPc__QAEXXZ mFunc = (_mSetPadOffset_mHRPc__QAEXXZ)(GameModule + 0x4482a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNeutral(class mHRPc* const this, uint8_t arg2) [?mCheckNeutral@mHRPc@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _mCheckNeutral_mHRPc__QAE_N_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	uint8_t mCheckNeutral(uint8_t arg2)
	{
		_mCheckNeutral_mHRPc__QAE_N_N_Z mFunc = (_mCheckNeutral_mHRPc__QAE_N_N_Z)(GameModule + 0x448440);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mIsPlayMotion(class mHRPc* const this) [?mIsPlayMotion@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mIsPlayMotion_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mIsPlayMotion()
	{
		_mIsPlayMotion_mHRPc__QAE_NXZ mFunc = (_mIsPlayMotion_mHRPc__QAE_NXZ)(GameModule + 0x448480);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBatteryCharge(class mHRPc* const this, int32_t arg2) [?mCheckBatteryCharge@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckBatteryCharge_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckBatteryCharge(int32_t arg2)
	{
		_mCheckBatteryCharge_mHRPc__QAE_NH_Z mFunc = (_mCheckBatteryCharge_mHRPc__QAE_NH_Z)(GameModule + 0x4484a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInitCamera(class mHRPc* const this) [?mCheckInitCamera@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckInitCamera_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckInitCamera()
	{
		_mCheckInitCamera_mHRPc__QAE_NXZ mFunc = (_mCheckInitCamera_mHRPc__QAE_NXZ)(GameModule + 0x448510);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDead(class mHRPc* const this, int32_t arg2) [?mCheckDead@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckDead_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckDead(int32_t arg2)
	{
		_mCheckDead_mHRPc__QAE_NH_Z mFunc = (_mCheckDead_mHRPc__QAE_NH_Z)(GameModule + 0x448520);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearDarkSide(class mHRPc* const this) [?mClearDarkSide@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearDarkSide_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearDarkSide()
	{
		_mClearDarkSide_mHRPc__QAEXXZ mFunc = (_mClearDarkSide_mHRPc__QAEXXZ)(GameModule + 0x448540);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mExitChargeBattery4FixCamera(class mHRPc* const this) [?mExitChargeBattery4FixCamera@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mExitChargeBattery4FixCamera_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mExitChargeBattery4FixCamera()
	{
		_mExitChargeBattery4FixCamera_mHRPc__QAEXXZ mFunc = (_mExitChargeBattery4FixCamera_mHRPc__QAEXXZ)(GameModule + 0x448950);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::StorePcPosForSM(class mHRPc* const this, struct Vec& arg2, struct Vec& arg3) [?StorePcPosForSM@mHRPc@@QAEXABUVec@@0@Z]
	typedef void(__thiscall* _StorePcPosForSM_mHRPc__QAEXABUVec__0_Z)(class mHRPc* const thisPtr, struct Vec& arg2, struct Vec& arg3);
	void StorePcPosForSM(struct Vec& arg2, struct Vec& arg3)
	{
		_StorePcPosForSM_mHRPc__QAEXABUVec__0_Z mFunc = (_StorePcPosForSM_mHRPc__QAEXABUVec__0_Z)(GameModule + 0x448a10);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckEquipReadEnd(class mHRPc* const this) [?mCheckEquipReadEnd@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckEquipReadEnd_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckEquipReadEnd()
	{
		_mCheckEquipReadEnd_mHRPc__QAE_NXZ mFunc = (_mCheckEquipReadEnd_mHRPc__QAE_NXZ)(GameModule + 0x448b40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestBattouDemo(class mHRPc* const this) [?mTestBattouDemo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestBattouDemo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestBattouDemo()
	{
		_mTestBattouDemo_mHRPc__QAE_NXZ mFunc = (_mTestBattouDemo_mHRPc__QAE_NXZ)(GameModule + 0x448b70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAddLocker(class mHRPc* const this, int32_t WeaponKind, int16_t arg3, float arg4, uint8_t arg5) [?mAddLocker@mHRPc@@QAE_NHFM_N@Z]
	typedef uint8_t(__thiscall* _mAddLocker_mHRPc__QAE_NHFM_N_Z)(class mHRPc* const thisPtr, int32_t WeaponKind, int16_t arg3, float arg4, uint8_t arg5);
	uint8_t mAddLocker(int32_t WeaponKind, int16_t arg3, float arg4, uint8_t arg5)
	{
		_mAddLocker_mHRPc__QAE_NHFM_N_Z mFunc = (_mAddLocker_mHRPc__QAE_NHFM_N_Z)(GameModule + 0x448b80);
		return mFunc(this, WeaponKind, arg3, arg4, arg5);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mChkLocker(class mHRPc* const this, int32_t arg2) [?mChkLocker@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mChkLocker_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mChkLocker(int32_t arg2)
	{
		_mChkLocker_mHRPc__QAE_NH_Z mFunc = (_mChkLocker_mHRPc__QAE_NH_Z)(GameModule + 0x448bf0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetEquip(class mHRPc* const this, uint32_t WeaponID, uint8_t arg3, uint8_t arg4) [?mSetEquip@mHRPc@@QAE_NH_N0@Z]
	typedef uint8_t(__thiscall* _mSetEquip_mHRPc__QAE_NH_N0_Z)(class mHRPc* const thisPtr, uint32_t WeaponID, uint8_t arg3, uint8_t arg4);
	uint8_t mSetEquip(uint32_t WeaponID, uint8_t arg3, uint8_t arg4)
	{
		_mSetEquip_mHRPc__QAE_NH_N0_Z mFunc = (_mSetEquip_mHRPc__QAE_NH_N0_Z)(GameModule + 0x448c20);
		return mFunc(this, WeaponID, arg3, arg4);
	}
private:
	// Hook: Pre
	inline static _mSetEquip_mHRPc__QAE_NH_N0_Z _original_mSetEquip = nullptr;
	inline static std::unordered_set<std::string> _callbacks_mSetEquip_pre;
	inline static std::unordered_set<std::string> _callbacks_mSetEquip_post;
	static uint8_t __fastcall mSetEquip_OnHook(class mHRPc* const thisPtr, void* EDX, uint32_t WeaponID, uint8_t arg3, uint8_t arg4)
	{
#if WITH_LUA
		std::unordered_set<std::string>::iterator it = _callbacks_mSetEquip_pre.begin();
		while (it != _callbacks_mSetEquip_pre.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mSetEquip_pre.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		uint8_t Result = _original_mSetEquip(thisPtr, WeaponID, arg3, arg4);
#if WITH_LUA
		it = _callbacks_mSetEquip_post.begin();
		while (it != _callbacks_mSetEquip_post.end())
		{
			std::lock_guard<std::mutex> guard(LuaStateMutex);
			lua_getglobal(LuaState, it->c_str());
			if (!lua_isfunction(LuaState, -1))
			{
				lua_pop(LuaState, 1);
				it = _callbacks_mSetEquip_post.erase(it);
			}
			else
			{
				if (!CheckLua(LuaState, lua_pcall(LuaState, 0, 0, 0)))
					lua_pop(LuaState, 1);
				it++;
			}
		}
#endif
		return Result;
	}
public:
	// Hook: Register
#if WITH_LUA
	static void mSetEquip_RegisterHook(std::string HookName, bool bPostHook)
	{
		if (!HookName.empty() && !bPostHook) _callbacks_mSetEquip_pre.insert(HookName);
		if (!HookName.empty() && bPostHook) _callbacks_mSetEquip_post.insert(HookName);
		if (_original_mSetEquip == nullptr)
		{
			_original_mSetEquip = (_mSetEquip_mHRPc__QAE_NH_N0_Z)mem::TrampHook((BYTE*)GameModule + 0x448c20, (BYTE*)mSetEquip_OnHook, 0x6);
			assert(_original_mSetEquip);
		}
	}
#endif
	// [Function] void __convention("thiscall") mHRPc::mControlDispWestWeapons(class mHRPc* const this) [?mControlDispWestWeapons@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mControlDispWestWeapons_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mControlDispWestWeapons()
	{
		_mControlDispWestWeapons_mHRPc__QAEXXZ mFunc = (_mControlDispWestWeapons_mHRPc__QAEXXZ)(GameModule + 0x448e60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckStageChangeInitEnd(class mHRPc* const this) [?mCheckStageChangeInitEnd@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckStageChangeInitEnd_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckStageChangeInitEnd()
	{
		_mCheckStageChangeInitEnd_mHRPc__QAE_NXZ mFunc = (_mCheckStageChangeInitEnd_mHRPc__QAE_NXZ)(GameModule + 0x448ed0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetElectroShockWalk(class mHRPc* const this, uint8_t arg2) [?mSetElectroShockWalk@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetElectroShockWalk_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetElectroShockWalk(uint8_t arg2)
	{
		_mSetElectroShockWalk_mHRPc__QAEX_N_Z mFunc = (_mSetElectroShockWalk_mHRPc__QAEX_N_Z)(GameModule + 0x448ee0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetHugWalk(class mHRPc* const this, uint8_t arg2) [?mSetHugWalk@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mSetHugWalk_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mSetHugWalk(uint8_t arg2)
	{
		_mSetHugWalk_mHRPc__QAEX_N_Z mFunc = (_mSetHugWalk_mHRPc__QAEX_N_Z)(GameModule + 0x449020);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetBikeSpd(class mHRPc* const this) [?mGetBikeSpd@mHRPc@@QAEMXZ]
	typedef float(__thiscall* _mGetBikeSpd_mHRPc__QAEMXZ)(class mHRPc* const thisPtr);
	float mGetBikeSpd()
	{
		_mGetBikeSpd_mHRPc__QAEMXZ mFunc = (_mGetBikeSpd_mHRPc__QAEMXZ)(GameModule + 0x449210);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetFireMan(class mHRPc* const this) [?mResetFireMan@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetFireMan_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetFireMan()
	{
		_mResetFireMan_mHRPc__QAEXXZ mFunc = (_mResetFireMan_mHRPc__QAEXXZ)(GameModule + 0x449240);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetChargeAttack(class mHRPc* const this) [?mResetChargeAttack@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetChargeAttack_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetChargeAttack()
	{
		_mResetChargeAttack_mHRPc__QAEXXZ mFunc = (_mResetChargeAttack_mHRPc__QAEXXZ)(GameModule + 0x449290);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetFPCamera(class mHRPc* const this) [?mResetFPCamera@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mResetFPCamera_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mResetFPCamera()
	{
		_mResetFPCamera_mHRPc__QAEXXZ mFunc = (_mResetFPCamera_mHRPc__QAEXXZ)(GameModule + 0x449300);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDarkSideMode(class mHRPc* const this) [?mCheckDarkSideMode@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckDarkSideMode_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckDarkSideMode()
	{
		_mCheckDarkSideMode_mHRPc__QAE_NXZ mFunc = (_mCheckDarkSideMode_mHRPc__QAE_NXZ)(GameModule + 0x449370);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAttachObj(class mHRPc* const this, class TGmf* arg2, char* arg3, class TGmf* arg4, char* arg5) [?mAttachObj@mHRPc@@QAE_NPAVTGmf@@PAD01@Z]
	typedef uint8_t(__thiscall* _mAttachObj_mHRPc__QAE_NPAVTGmf__PAD01_Z)(class mHRPc* const thisPtr, class TGmf* arg2, char* arg3, class TGmf* arg4, char* arg5);
	uint8_t mAttachObj(class TGmf* arg2, std::string arg3, class TGmf* arg4, std::string arg5)
	{
		std::vector<char> arg3_c_str(arg3.c_str(), + arg3.c_str() + arg3.size() + 1);
		std::vector<char> arg5_c_str(arg5.c_str(), + arg5.c_str() + arg5.size() + 1);
		_mAttachObj_mHRPc__QAE_NPAVTGmf__PAD01_Z mFunc = (_mAttachObj_mHRPc__QAE_NPAVTGmf__PAD01_Z)(GameModule + 0x449380);
		return mFunc(this, arg2, &arg3_c_str[0], arg4, &arg5_c_str[0]);
	}
	// [Function] void __convention("thiscall") mHRPc::mRestoreSubMissionWeapon(class mHRPc* const this) [?mRestoreSubMissionWeapon@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mRestoreSubMissionWeapon_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mRestoreSubMissionWeapon()
	{
		_mRestoreSubMissionWeapon_mHRPc__QAEXXZ mFunc = (_mRestoreSubMissionWeapon_mHRPc__QAEXXZ)(GameModule + 0x4493f0);
		return mFunc(this);
	}
	// [Function] int16_t __convention("thiscall") mHRPc::mGetBattery(class mHRPc* const this, int32_t arg2) [?mGetBattery@mHRPc@@QAEFH@Z]
	typedef int16_t(__thiscall* _mGetBattery_mHRPc__QAEFH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int16_t mGetBattery(int32_t arg2)
	{
		_mGetBattery_mHRPc__QAEFH_Z mFunc = (_mGetBattery_mHRPc__QAEFH_Z)(GameModule + 0x449400);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBatteryMax(class mHRPc* const this, int32_t arg2) [?mGetBatteryMax@mHRPc@@QAEHH@Z]
	typedef int32_t(__thiscall* _mGetBatteryMax_mHRPc__QAEHH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	int32_t mGetBatteryMax(int32_t arg2)
	{
		_mGetBatteryMax_mHRPc__QAEHH_Z mFunc = (_mGetBatteryMax_mHRPc__QAEHH_Z)(GameModule + 0x449440);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBattery(class mHRPc* const this, int16_t arg2, int32_t arg3) [?mSetBattery@mHRPc@@QAEXFH@Z]
	typedef void(__thiscall* _mSetBattery_mHRPc__QAEXFH_Z)(class mHRPc* const thisPtr, int16_t arg2, int32_t arg3);
	void mSetBattery(int16_t arg2, int32_t arg3)
	{
		_mSetBattery_mHRPc__QAEXFH_Z mFunc = (_mSetBattery_mHRPc__QAEXFH_Z)(GameModule + 0x449480);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::StorePcPosForSM(class mHRPc* const this) [?StorePcPosForSM@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _StorePcPosForSM_mHRPc__QAEXXZ_2)(class mHRPc* const thisPtr);
	void StorePcPosForSM_2()
	{
		_StorePcPosForSM_mHRPc__QAEXXZ_2 mFunc = (_StorePcPosForSM_mHRPc__QAEXXZ_2)(GameModule + 0x4494d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::StoreBikePosForSM(class mHRPc* const this) [?StoreBikePosForSM@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _StoreBikePosForSM_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t StoreBikePosForSM()
	{
		_StoreBikePosForSM_mHRPc__QAE_NXZ mFunc = (_StoreBikePosForSM_mHRPc__QAE_NXZ)(GameModule + 0x449560);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetBikePos(class mHRPc* const this, int32_t, float arg3) [?mSetBikePos@mHRPc@@QAE_NUVec@@M@Z]
	typedef uint8_t(__thiscall* _mSetBikePos_mHRPc__QAE_NUVec__M_Z)(class mHRPc* const thisPtr, uint32_t arg2, float arg3);
	uint8_t mSetBikePos(uint32_t arg2, float arg3)
	{
		_mSetBikePos_mHRPc__QAE_NUVec__M_Z mFunc = (_mSetBikePos_mHRPc__QAE_NUVec__M_Z)(GameModule + 0x4495d0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetBikeRot(class mHRPc* const this, struct Vec arg2) [?mSetBikeRot@mHRPc@@QAE_NUVec@@@Z]
	typedef uint8_t(__thiscall* _mSetBikeRot_mHRPc__QAE_NUVec___Z)(class mHRPc* const thisPtr, struct Vec arg2);
	uint8_t mSetBikeRot(struct Vec arg2)
	{
		_mSetBikeRot_mHRPc__QAE_NUVec___Z mFunc = (_mSetBikeRot_mHRPc__QAE_NUVec___Z)(GameModule + 0x4496a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mAddPcMoney(class mHRPc* const this, int32_t arg2) [?mAddPcMoney@mHRPc@@QAEXH@Z]
	typedef void(__thiscall* _mAddPcMoney_mHRPc__QAEXH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	void mAddPcMoney(int32_t arg2)
	{
		_mAddPcMoney_mHRPc__QAEXH_Z mFunc = (_mAddPcMoney_mHRPc__QAEXH_Z)(GameModule + 0x449710);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mSetBikeJumpForSubMission(class mHRPc* const this, uint8_t arg2) [?mSetBikeJumpForSubMission@mHRPc@@QAEH_N@Z]
	typedef int32_t(__thiscall* _mSetBikeJumpForSubMission_mHRPc__QAEH_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	int32_t mSetBikeJumpForSubMission(uint8_t arg2)
	{
		_mSetBikeJumpForSubMission_mHRPc__QAEH_N_Z mFunc = (_mSetBikeJumpForSubMission_mHRPc__QAEH_N_Z)(GameModule + 0x449750);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallDemoBattou(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mCallDemoBattou@mHRPc@@QAE_N_N0@Z]
	typedef uint8_t(__thiscall* _mCallDemoBattou_mHRPc__QAE_N_N0_Z)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
	uint8_t mCallDemoBattou(uint8_t arg2, uint8_t arg3)
	{
		_mCallDemoBattou_mHRPc__QAE_N_N0_Z mFunc = (_mCallDemoBattou_mHRPc__QAE_N_N0_Z)(GameModule + 0x449950);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestPauseBattouDemo(class mHRPc* const this) [?mTestPauseBattouDemo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTestPauseBattouDemo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mTestPauseBattouDemo()
	{
		_mTestPauseBattouDemo_mHRPc__QAE_NXZ mFunc = (_mTestPauseBattouDemo_mHRPc__QAE_NXZ)(GameModule + 0x4499b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mResumeBattouDemo(class mHRPc* const this) [?mResumeBattouDemo@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mResumeBattouDemo_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mResumeBattouDemo()
	{
		_mResumeBattouDemo_mHRPc__QAE_NXZ mFunc = (_mResumeBattouDemo_mHRPc__QAE_NXZ)(GameModule + 0x4499c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallDemoNoutou(class mHRPc* const this) [?mCallDemoNoutou@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCallDemoNoutou_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCallDemoNoutou()
	{
		_mCallDemoNoutou_mHRPc__QAEXXZ mFunc = (_mCallDemoNoutou_mHRPc__QAEXXZ)(GameModule + 0x4499f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCancelBattouNoutouDemo(class mHRPc* const this) [?mCancelBattouNoutouDemo@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mCancelBattouNoutouDemo_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mCancelBattouNoutouDemo()
	{
		_mCancelBattouNoutouDemo_mHRPc__QAEXXZ mFunc = (_mCancelBattouNoutouDemo_mHRPc__QAEXXZ)(GameModule + 0x449af0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mRestorePlayMotionFromDatPtr(class mHRPc* const this, uint8_t arg2) [?mRestorePlayMotionFromDatPtr@mHRPc@@QAEX_N@Z]
	typedef void(__thiscall* _mRestorePlayMotionFromDatPtr_mHRPc__QAEX_N_Z)(class mHRPc* const thisPtr, uint8_t arg2);
	void mRestorePlayMotionFromDatPtr(uint8_t arg2)
	{
		_mRestorePlayMotionFromDatPtr_mHRPc__QAEX_N_Z mFunc = (_mRestorePlayMotionFromDatPtr_mHRPc__QAEX_N_Z)(GameModule + 0x449b30);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAtkScl(class mHRPc* const this) [?mGetAtkScl@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetAtkScl_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t mGetAtkScl()
	{
		_mGetAtkScl_mHRPc__QAEHXZ mFunc = (_mGetAtkScl_mHRPc__QAEHXZ)(GameModule + 0x449ca0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::GetSwingCount(class mHRPc* const this) [?GetSwingCount@mHRPc@@QAEHXZ]
	typedef int32_t(__thiscall* _GetSwingCount_mHRPc__QAEHXZ)(class mHRPc* const thisPtr);
	int32_t GetSwingCount()
	{
		_GetSwingCount_mHRPc__QAEHXZ mFunc = (_GetSwingCount_mHRPc__QAEHXZ)(GameModule + 0x449d00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::ClearSwingCount(class mHRPc* const this) [?ClearSwingCount@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _ClearSwingCount_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void ClearSwingCount()
	{
		_ClearSwingCount_mHRPc__QAEXXZ mFunc = (_ClearSwingCount_mHRPc__QAEXXZ)(GameModule + 0x449d10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLockOnEnemy(class mHRPc* const this) [?mCheckLockOnEnemy@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckLockOnEnemy_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckLockOnEnemy()
	{
		_mCheckLockOnEnemy_mHRPc__QAE_NXZ mFunc = (_mCheckLockOnEnemy_mHRPc__QAE_NXZ)(GameModule + 0x449d20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckThrowAttack(class mHRPc* const this, int32_t arg2) [?mCheckThrowAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckThrowAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckThrowAttack(int32_t arg2)
	{
		_mCheckThrowAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckThrowAttack_mHRPc__QAE_NH_Z)(GameModule + 0x449d40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGetAllWeapon(class mHRPc* const this) [?mCheckGetAllWeapon@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckGetAllWeapon_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckGetAllWeapon()
	{
		_mCheckGetAllWeapon_mHRPc__QAE_NXZ mFunc = (_mCheckGetAllWeapon_mHRPc__QAE_NXZ)(GameModule + 0x449da0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGuardSlide(class mHRPc* const this, int32_t arg2) [?mCheckGuardSlide@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckGuardSlide_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckGuardSlide(int32_t arg2)
	{
		_mCheckGuardSlide_mHRPc__QAE_NH_Z mFunc = (_mCheckGuardSlide_mHRPc__QAE_NH_Z)(GameModule + 0x449e50);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTsubaAttack(class mHRPc* const this, int32_t arg2) [?mCheckTsubaAttack@mHRPc@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckTsubaAttack_mHRPc__QAE_NH_Z)(class mHRPc* const thisPtr, int32_t arg2);
	uint8_t mCheckTsubaAttack(int32_t arg2)
	{
		_mCheckTsubaAttack_mHRPc__QAE_NH_Z mFunc = (_mCheckTsubaAttack_mHRPc__QAE_NH_Z)(GameModule + 0x449e70);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckSuccessInputFinish(class mHRPc* const this) [?mCheckSuccessInputFinish@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckSuccessInputFinish_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckSuccessInputFinish()
	{
		_mCheckSuccessInputFinish_mHRPc__QAE_NXZ mFunc = (_mCheckSuccessInputFinish_mHRPc__QAE_NXZ)(GameModule + 0x449eb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetInputMode(class mHRPc* const this, enum enPcInputMode arg2, uint8_t arg3) [?mSetInputMode@mHRPc@@QAEXW4enPcInputMode@@_N@Z]
	typedef void(__thiscall* _mSetInputMode_mHRPc__QAEXW4enPcInputMode___N_Z)(class mHRPc* const thisPtr, enum enPcInputMode arg2, uint8_t arg3);
	void mSetInputMode(/* enum enPcInputMode */ uint32_t arg2, uint8_t arg3)
	{
		_mSetInputMode_mHRPc__QAEXW4enPcInputMode___N_Z mFunc = (_mSetInputMode_mHRPc__QAEXW4enPcInputMode___N_Z)(GameModule + 0x449ec0);
		return mFunc(this, (enum enPcInputMode)arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInputMove(class mHRPc* const this) [?mCheckInputMove@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckInputMove_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckInputMove()
	{
		_mCheckInputMove_mHRPc__QAE_NXZ mFunc = (_mCheckInputMove_mHRPc__QAE_NXZ)(GameModule + 0x449f20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetEquipMk3(class mHRPc* const this) [?mSetEquipMk3@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mSetEquipMk3_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mSetEquipMk3()
	{
		_mSetEquipMk3_mHRPc__QAE_NXZ mFunc = (_mSetEquipMk3_mHRPc__QAE_NXZ)(GameModule + 0x44a060);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTrvReadEnd(class mHRPc* const this) [?mCheckTrvReadEnd@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckTrvReadEnd_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckTrvReadEnd()
	{
		_mCheckTrvReadEnd_mHRPc__QAE_NXZ mFunc = (_mCheckTrvReadEnd_mHRPc__QAE_NXZ)(GameModule + 0x44a0a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepBattou(class mHRPc* const this) [?mSetWepBattou@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetWepBattou_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetWepBattou()
	{
		_mSetWepBattou_mHRPc__QAEXXZ mFunc = (_mSetWepBattou_mHRPc__QAEXXZ)(GameModule + 0x44a100);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepNoutou(class mHRPc* const this) [?mSetWepNoutou@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mSetWepNoutou_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mSetWepNoutou()
	{
		_mSetWepNoutou_mHRPc__QAEXXZ mFunc = (_mSetWepNoutou_mHRPc__QAEXXZ)(GameModule + 0x44a1c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPauseFlag(class mHRPc* const this) [?mGetPauseFlag@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetPauseFlag_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mGetPauseFlag()
	{
		_mGetPauseFlag_mHRPc__QAE_NXZ mFunc = (_mGetPauseFlag_mHRPc__QAE_NXZ)(GameModule + 0x44a260);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishAttackAndCantLockOn(class mHRPc* const this) [?mCheckFinishAttackAndCantLockOn@mHRPc@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckFinishAttackAndCantLockOn_mHRPc__QAE_NXZ)(class mHRPc* const thisPtr);
	uint8_t mCheckFinishAttackAndCantLockOn()
	{
		_mCheckFinishAttackAndCantLockOn_mHRPc__QAE_NXZ mFunc = (_mCheckFinishAttackAndCantLockOn_mHRPc__QAE_NXZ)(GameModule + 0x44a2b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTremStageChange(class mHRPc* const this) [?mTremStageChange@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mTremStageChange_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mTremStageChange()
	{
		_mTremStageChange_mHRPc__QAEXXZ mFunc = (_mTremStageChange_mHRPc__QAEXXZ)(GameModule + 0x44a2d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetEventWalk(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mSetEventWalk@mHRPc@@QAEX_N0@Z]
	typedef void(__thiscall* _mSetEventWalk_mHRPc__QAEX_N0_Z)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
	void mSetEventWalk(uint8_t arg2, uint8_t arg3)
	{
		_mSetEventWalk_mHRPc__QAEX_N0_Z mFunc = (_mSetEventWalk_mHRPc__QAEX_N0_Z)(GameModule + 0x44a9f0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mInitStageChange(class mHRPc* const this) [?mInitStageChange@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mInitStageChange_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mInitStageChange()
	{
		_mInitStageChange_mHRPc__QAEXXZ mFunc = (_mInitStageChange_mHRPc__QAEXXZ)(GameModule + 0x44aa40);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearGameFlag(class mHRPc* const this) [?mClearGameFlag@mHRPc@@QAEXXZ]
	typedef void(__thiscall* _mClearGameFlag_mHRPc__QAEXXZ)(class mHRPc* const thisPtr);
	void mClearGameFlag()
	{
		_mClearGameFlag_mHRPc__QAEXXZ mFunc = (_mClearGameFlag_mHRPc__QAEXXZ)(GameModule + 0x44b240);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class mHRPc [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(mHRPc& InObject)
	{
		mEscapeActionInit = InObject.mEscapeActionInit;
		mPcStatus = InObject.mPcStatus;
		mMiniDemo = InObject.mMiniDemo;
		mPcSaveData = InObject.mPcSaveData;
		mDarkSideInfo = InObject.mDarkSideInfo;
		mpBike = InObject.mpBike;
		mSnd = InObject.mSnd;
		mInputMode = InObject.mInputMode;
		mInputModeOld = InObject.mInputModeOld;
		mInputModeBefore = InObject.mInputModeBefore;
		mPauseAll = InObject.mPauseAll;
		mPauseNpc = InObject.mPauseNpc;
		mOperate = InObject.mOperate;
		mOnlyMove = InObject.mOnlyMove;
		mMotSpdAdj = InObject.mMotSpdAdj;
		mDead = InObject.mDead;
		mDeadPause = InObject.mDeadPause;
		mCameraOperate = InObject.mCameraOperate;
		mBattouDemoRequest = InObject.mBattouDemoRequest;
		mStageChangeInitEnd = InObject.mStageChangeInitEnd;
		mStageChangeTermEnd = InObject.mStageChangeTermEnd;
		mStageChangeMuteki = InObject.mStageChangeMuteki;
		mBanStatusScreen = InObject.mBanStatusScreen;
		mAtkPauseTime = InObject.mAtkPauseTime;
		mStopRenderFrameNum = InObject.mStopRenderFrameNum;
		mWait1Frame = InObject.mWait1Frame;
		mPcEffect = InObject.mPcEffect;
		mPcHug = InObject.mPcHug;
		mTiger = InObject.mTiger;
		mLockOnPos = InObject.mLockOnPos;
		mpLockOnNpc = InObject.mpLockOnNpc;
		mpTsubaNpc = InObject.mpTsubaNpc;
		mpCatchNpc = InObject.mpCatchNpc;
		mpCatchReserveNpc = InObject.mpCatchReserveNpc;
		mpEscapeNpc = InObject.mpEscapeNpc;
		mpInitFinishNpc = InObject.mpInitFinishNpc;
		mpNextFinishNpc = InObject.mpNextFinishNpc;
		mpFinishReserveNpc = InObject.mpFinishReserveNpc;
		mpDSTargetNpc = InObject.mpDSTargetNpc;
		mpDwnAtkNpc = InObject.mpDwnAtkNpc;
		mpLastAtkNpc = InObject.mpLastAtkNpc;
		mpAttackFromBackNpc = InObject.mpAttackFromBackNpc;
		mLockOnDummy = InObject.mLockOnDummy;
		mSavehitOidashiDisEnable = InObject.mSavehitOidashiDisEnable;
		mSlowMotionSytemMotNo = InObject.mSlowMotionSytemMotNo;
		mSlowMotionSytemButton = InObject.mSlowMotionSytemButton;
		mWepCollL = InObject.mWepCollL;
		m_pAttackHitTriangle = InObject.m_pAttackHitTriangle;
		mFade = InObject.mFade;
		mSubMissionflag = InObject.mSubMissionflag;
		mSubMissionPcPosStoreFlag = InObject.mSubMissionPcPosStoreFlag;
		mSubMissionStorePos = InObject.mSubMissionStorePos;
		mSubMissionStoreRot = InObject.mSubMissionStoreRot;
		mSubMissionBikePosStoreFlag = InObject.mSubMissionBikePosStoreFlag;
		mSubMissionStoreBikePos = InObject.mSubMissionStoreBikePos;
		mSubMissionStoreBikeRot = InObject.mSubMissionStoreBikeRot;
		mpSubMissionJumpCameraHandle = InObject.mpSubMissionJumpCameraHandle;
		mDisEnableBtlPoseCalc = InObject.mDisEnableBtlPoseCalc;
		mTamePush = InObject.mTamePush;
		mTameMax = InObject.mTameMax;
		mTameSe = InObject.mTameSe;
		mDigAction = InObject.mDigAction;
		mChangeWepProc = InObject.mChangeWepProc;
		mChangeWepKind = InObject.mChangeWepKind;
		mMenuDisEnableFrame = InObject.mMenuDisEnableFrame;
		m_sMotName = InObject.m_sMotName;
		m_sPreMotName = InObject.m_sPreMotName;
		m_bIsBootStageHitEffect = InObject.m_bIsBootStageHitEffect;
		m_inPreWeaponTopPosi = InObject.m_inPreWeaponTopPosi;
		m_bIsPreTigerVisible = InObject.m_bIsPreTigerVisible;
		m_bIsPreFinishAttack = InObject.m_bIsPreFinishAttack;
		m_bIsBeginFinishAttack = InObject.m_bIsBeginFinishAttack;
		m_bIsPlayCamBankMotion = InObject.m_bIsPlayCamBankMotion;
		m_inWeaponLengthRatio = InObject.m_inWeaponLengthRatio;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<mHRPc, mHRChara>("mHRPc")
			.addFunction("__tostring", &mHRPc::ToString)
			.addFunction("GetPtrAddr", &mHRPc::GetPtrAddr)
			.addProperty("mEscapeActionInit", &mHRPc::mEscapeActionInit)
			.addProperty("mPcStatus", &mHRPc::mPcStatus)
			.addProperty("mMiniDemo", &mHRPc::mMiniDemo)
			.addProperty("mPcSaveData", &mHRPc::mPcSaveData)
			.addProperty("mDarkSideInfo", &mHRPc::mDarkSideInfo)
			.addProperty("mpBike", &mHRPc::mpBike)
			.addProperty("mSnd", &mHRPc::mSnd)
			.addProperty("mInputMode", &mHRPc::mInputMode)
			.addProperty("mInputModeOld", &mHRPc::mInputModeOld)
			.addProperty("mInputModeBefore", &mHRPc::mInputModeBefore)
			.addProperty("mPauseAll", &mHRPc::mPauseAll)
			.addProperty("mPauseNpc", &mHRPc::mPauseNpc)
			.addProperty("mOperate", &mHRPc::mOperate)
			.addProperty("mOnlyMove", &mHRPc::mOnlyMove)
			.addProperty("mMotSpdAdj", &mHRPc::mMotSpdAdj)
			.addProperty("mDead", &mHRPc::mDead)
			.addProperty("mDeadPause", &mHRPc::mDeadPause)
			.addProperty("mCameraOperate", &mHRPc::mCameraOperate)
			.addProperty("mBattouDemoRequest", &mHRPc::mBattouDemoRequest)
			.addProperty("mStageChangeInitEnd", &mHRPc::mStageChangeInitEnd)
			.addProperty("mStageChangeTermEnd", &mHRPc::mStageChangeTermEnd)
			.addProperty("mStageChangeMuteki", &mHRPc::mStageChangeMuteki)
			.addProperty("mBanStatusScreen", &mHRPc::mBanStatusScreen)
			.addProperty("mAtkPauseTime", &mHRPc::mAtkPauseTime)
			.addProperty("mStopRenderFrameNum", &mHRPc::mStopRenderFrameNum)
			.addProperty("mWait1Frame", &mHRPc::mWait1Frame)
			.addProperty("mPcEffect", &mHRPc::mPcEffect)
			.addProperty("mPcHug", &mHRPc::mPcHug)
			.addProperty("mTiger", &mHRPc::mTiger)
			.addProperty("mLockOnPos", &mHRPc::mLockOnPos)
			.addProperty("mpLockOnNpc", &mHRPc::mpLockOnNpc)
			.addProperty("mpTsubaNpc", &mHRPc::mpTsubaNpc)
			.addProperty("mpCatchNpc", &mHRPc::mpCatchNpc)
			.addProperty("mpCatchReserveNpc", &mHRPc::mpCatchReserveNpc)
			.addProperty("mpEscapeNpc", &mHRPc::mpEscapeNpc)
			.addProperty("mpInitFinishNpc", &mHRPc::mpInitFinishNpc)
			.addProperty("mpNextFinishNpc", &mHRPc::mpNextFinishNpc)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpFinishNpc", &mHRPc::mpFinishNpc)
			.addProperty("mpFinishReserveNpc", &mHRPc::mpFinishReserveNpc)
			.addProperty("mpDSTargetNpc", &mHRPc::mpDSTargetNpc)
			.addProperty("mpDwnAtkNpc", &mHRPc::mpDwnAtkNpc)
			.addProperty("mpLastAtkNpc", &mHRPc::mpLastAtkNpc)
			.addProperty("mpAttackFromBackNpc", &mHRPc::mpAttackFromBackNpc)
			.addProperty("mLockOnDummy", &mHRPc::mLockOnDummy)
			.addProperty("mSavehitOidashiDisEnable", &mHRPc::mSavehitOidashiDisEnable)
			.addProperty("mSlowMotionSytemMotNo", &mHRPc::mSlowMotionSytemMotNo)
			.addProperty("mSlowMotionSytemButton", &mHRPc::mSlowMotionSytemButton)
			.addProperty("mWepCollL", &mHRPc::mWepCollL)
			.addProperty("m_pAttackHitTriangle", &mHRPc::m_pAttackHitTriangle)
			.addProperty("mFade", &mHRPc::mFade)
			.addProperty("mSubMissionflag", &mHRPc::mSubMissionflag)
			.addProperty("mSubMissionPcPosStoreFlag", &mHRPc::mSubMissionPcPosStoreFlag)
			.addProperty("mSubMissionStorePos", &mHRPc::mSubMissionStorePos)
			.addProperty("mSubMissionStoreRot", &mHRPc::mSubMissionStoreRot)
			.addProperty("mSubMissionBikePosStoreFlag", &mHRPc::mSubMissionBikePosStoreFlag)
			.addProperty("mSubMissionStoreBikePos", &mHRPc::mSubMissionStoreBikePos)
			.addProperty("mSubMissionStoreBikeRot", &mHRPc::mSubMissionStoreBikeRot)
			.addProperty("mpSubMissionJumpCameraHandle", &mHRPc::mpSubMissionJumpCameraHandle)
			.addProperty("mDisEnableBtlPoseCalc", &mHRPc::mDisEnableBtlPoseCalc)
			.addProperty("mTamePush", &mHRPc::mTamePush)
			.addProperty("mTameMax", &mHRPc::mTameMax)
			.addProperty("mTameSe", &mHRPc::mTameSe)
			.addProperty("mDigAction", &mHRPc::mDigAction)
			.addProperty("mChangeWepProc", &mHRPc::mChangeWepProc)
			.addProperty("mChangeWepKind", &mHRPc::mChangeWepKind)
			.addProperty("mMenuDisEnableFrame", &mHRPc::mMenuDisEnableFrame)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sMotName", &mHRPc::m_sMotName)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sPreMotName", &mHRPc::m_sPreMotName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_sOutMotName", &mHRPc::m_sOutMotName)
			.addProperty("m_bIsBootStageHitEffect", &mHRPc::m_bIsBootStageHitEffect)
			.addProperty("m_inPreWeaponTopPosi", &mHRPc::m_inPreWeaponTopPosi)
			.addProperty("m_bIsPreTigerVisible", &mHRPc::m_bIsPreTigerVisible)
			.addProperty("m_bIsPreFinishAttack", &mHRPc::m_bIsPreFinishAttack)
			.addProperty("m_bIsBeginFinishAttack", &mHRPc::m_bIsBeginFinishAttack)
			.addProperty("m_bIsPlayCamBankMotion", &mHRPc::m_bIsPlayCamBankMotion)
			.addProperty("m_inWeaponLengthRatio", &mHRPc::m_inWeaponLengthRatio)
			.addFunction("mGetEventWalk", &mHRPc::mGetEventWalk)
			.addFunction("mGetDarkSideTick", &mHRPc::mGetDarkSideTick)
			.addFunction("isFireDarkSideModeActive", &mHRPc::isFireDarkSideModeActive)
			.addFunction("mSetTsubaDisEnable", &mHRPc::mSetTsubaDisEnable)
			.addFunction("mGetInputMode", &mHRPc::mGetInputMode)
			.addFunction("mSetPcMoney", &mHRPc::mSetPcMoney)
			.addFunction("mSubPcMoney", &mHRPc::mSubPcMoney)
			.addFunction("mGetPcMoney", &mHRPc::mGetPcMoney)
			.addFunction("mGetEquipID", &mHRPc::mGetEquipID)
			.addFunction("mGetEquipGmfPtr", &mHRPc::mGetEquipGmfPtr)
			.addFunction("mGetBikePtr", &mHRPc::mGetBikePtr)
			.addFunction("mSetBgmNo4Load", &mHRPc::mSetBgmNo4Load)
			.addFunction("mCheckDemoBattou", &mHRPc::mCheckDemoBattou)
			.addFunction("mCheckDemoNoutou", &mHRPc::mCheckDemoNoutou)
			.addFunction("mSetThrowModeOnly", &mHRPc::mSetThrowModeOnly)
			.addFunction("mSetSlashModeOnly", &mHRPc::mSetSlashModeOnly)
			.addFunction("mSetCatchModeDisEnable", &mHRPc::mSetCatchModeDisEnable)
			.addFunction("mSetFightTameDisEnable", &mHRPc::mSetFightTameDisEnable)
			.addFunction("mSetSlashTameDisEnable", &mHRPc::mSetSlashTameDisEnable)
			.addFunction("mSetDownAttackDisEnable", &mHRPc::mSetDownAttackDisEnable)
			.addFunction("mSetDigDisEnable", &mHRPc::mSetDigDisEnable)
			.addFunction("mGetDigDisEnable4SM", &mHRPc::mGetDigDisEnable4SM)
			.addFunction("mClearSubMissionflag", &mHRPc::mClearSubMissionflag)
			.addFunction("mSetSubMissionActivflag", &mHRPc::mSetSubMissionActivflag)
			.addFunction("mSetSkillCatch", &mHRPc::mSetSkillCatch)
			.addFunction("mSetAtkMode", &mHRPc::mSetAtkMode)
			.addFunction("mGetAtkMode", &mHRPc::mGetAtkMode)
			.addFunction("mGetEqWepLaser", &mHRPc::mGetEqWepLaser)
			.addFunction("mSetAlwaysEmptyBattery", &mHRPc::mSetAlwaysEmptyBattery)
			.addFunction("mSetCantChargeBattery", &mHRPc::mSetCantChargeBattery)
			.addFunction("mSetDontSemitrans", &mHRPc::mSetDontSemitrans)
			.addFunction("mSetCantCallBikeFlag", &mHRPc::mSetCantCallBikeFlag)
			.addFunction("mSetLostBikeFlag", &mHRPc::mSetLostBikeFlag)
			.addFunction("mResetMaxCombo", &mHRPc::mResetMaxCombo)
			.addFunction("mGetDigToolFlag", &mHRPc::mGetDigToolFlag)
			.addFunction("mSetPuppetMode", &mHRPc::mSetPuppetMode)
			.addFunction("mSetUseWeaponEffect", &mHRPc::mSetUseWeaponEffect)
			.addFunction("mGetTodomePrepareMode", &mHRPc::mGetTodomePrepareMode)
			.addFunction("mClearTodomePrepareMode", &mHRPc::mClearTodomePrepareMode)
			.addFunction("mGetThrowPrepareMode", &mHRPc::mGetThrowPrepareMode)
			.addFunction("mGetThrowInputResult", &mHRPc::mGetThrowInputResult)
			.addFunction("mSetShadowDepth", &mHRPc::mSetShadowDepth)
			.addFunction("mSetBanSlotCry", &mHRPc::mSetBanSlotCry)
			.addFunction("mSetBanSlotBel", &mHRPc::mSetBanSlotBel)
			.addFunction("mSetBanSlotBar", &mHRPc::mSetBanSlotBar)
			.addFunction("mSetBanSlot777", &mHRPc::mSetBanSlot777)
			.addFunction("mSetDeadSubmission", &mHRPc::mSetDeadSubmission)
			.addFunction("mSetDontSubBattery", &mHRPc::mSetDontSubBattery)
			.addFunction("mSetAutoSubBatteryDisEnable", &mHRPc::mSetAutoSubBatteryDisEnable)
			.addFunction("mSetJustGuardDisEnable", &mHRPc::mSetJustGuardDisEnable)
			.addFunction("mSetDashAtkDisEnable", &mHRPc::mSetDashAtkDisEnable)
			.addFunction("mSetJustEscapeDisEnable", &mHRPc::mSetJustEscapeDisEnable)
			.addFunction("mGetTsubaNpc", &mHRPc::mGetTsubaNpc)
			.addFunction("mSetOperate", &mHRPc::mSetOperate)
			.addFunction("mGetOperate", &mHRPc::mGetOperate)
			.addFunction("mSetCameraOperate", &mHRPc::mSetCameraOperate)
			.addFunction("mCheckStageChangeTermEnd", &mHRPc::mCheckStageChangeTermEnd)
			.addFunction("mGetDeadFlag", &mHRPc::mGetDeadFlag)
			.addFunction("mGetDebuNekoDataPtr", &mHRPc::mGetDebuNekoDataPtr)
			.addFunction("mSetPauseAllFlag", &mHRPc::mSetPauseAllFlag)
			.addFunction("mSetCancelSetPadOffset", &mHRPc::mSetCancelSetPadOffset)
			.addFunction("mSetChangeEquipFromScript", &mHRPc::mSetChangeEquipFromScript)
			.addFunction("mSetForceLoseTsubazeri", &mHRPc::mSetForceLoseTsubazeri)
			.addFunction("mCheckDeadFukki", &mHRPc::mCheckDeadFukki)
			.addFunction("mPlayMotionFromDatPtrExt", &mHRPc::mPlayMotionFromDatPtrExt)
			.addFunction("mSetPcPower", &mHRPc::mSetPcPower)
			.addFunction("mGetEquipTexPtr", &mHRPc::mGetEquipTexPtr)
			.addFunction("mSetRestartBGM", &mHRPc::mSetRestartBGM)
			.addFunction("mGetSubMissionflag", &mHRPc::mGetSubMissionflag)
			.addStaticFunction("mSetDisplayMiniMapFlag", &mHRPc::mSetDisplayMiniMapFlag)
			.addStaticFunction("mGetDisplayMiniMapFlag", &mHRPc::mGetDisplayMiniMapFlag)
			.addStaticFunction("mSetCameraXReverseControlFlag", &mHRPc::mSetCameraXReverseControlFlag)
			.addStaticFunction("mGetCameraXReverseControlFlag", &mHRPc::mGetCameraXReverseControlFlag)
			.addStaticFunction("mSetCameraYReverseControlFlag", &mHRPc::mSetCameraYReverseControlFlag)
			.addStaticFunction("mGetCameraYReverseControlFlag", &mHRPc::mGetCameraYReverseControlFlag)
			.addFunction("mAddClearNum", &mHRPc::mAddClearNum)
			.addFunction("mGetDeadSubmission", &mHRPc::mGetDeadSubmission)
			.addFunction("mCheckStatusMenuDisp", &mHRPc::mCheckStatusMenuDisp)
			.addFunction("mSetMotionNo", &mHRPc::mSetMotionNo)
			.addFunction("mGetAtkPauseTime", &mHRPc::mGetAtkPauseTime)
			.addFunction("mDecAtkPauseTime", &mHRPc::mDecAtkPauseTime)
			.addFunction("mGetWait1Frame", &mHRPc::mGetWait1Frame)
			.addFunction("mDecWait1Frame", &mHRPc::mDecWait1Frame)
			.addFunction("mTestPlayMiniDemoForSantDestroy", &mHRPc::mTestPlayMiniDemoForSantDestroy)
			.addFunction("mGetHugWalk", &mHRPc::mGetHugWalk)
			.addFunction("mResetReceiveDamage", &mHRPc::mResetReceiveDamage)
			.addFunction("mGetBikeSight", &mHRPc::mGetBikeSight)
			.addFunction("mGetDontChangeBikeCamera", &mHRPc::mGetDontChangeBikeCamera)
			.addFunction("mGetCameraOperate", &mHRPc::mGetCameraOperate)
			.addFunction("mGetPauseAllFlag", &mHRPc::mGetPauseAllFlag)
			.addFunction("isBeginFinishAttack", &mHRPc::isBeginFinishAttack)
			.addFunction("mTestTiger", &mHRPc::mTestTiger)
			.addFunction("mSetMenuDisEnableFrame", &mHRPc::mSetMenuDisEnableFrame)
			.addFunction("mGetNeedShakeDir", &mHRPc::mGetNeedShakeDir)
			.addFunction("mSetWepMotionNo", &mHRPc::mSetWepMotionNo)
			.addFunction("mGetWepMotionNo", &mHRPc::mGetWepMotionNo)
			.addFunction("mSetBikeVisible", &mHRPc::mSetBikeVisible)
			.addFunction("mGetNowBuf", &mHRPc::mGetNowBuf)
			.addFunction("mGetTexNowBuf", &mHRPc::mGetTexNowBuf)
			.addFunction("mCheckSNBElecDamage", &mHRPc::mCheckSNBElecDamage)
			.addFunction("mCheckIntoTsubazeriai", &mHRPc::mCheckIntoTsubazeriai)
			.addFunction("mPlayMotTsubaszeriai", &mHRPc::mPlayMotTsubaszeriai)
			.addFunction("mCheckTsubazeriai", &mHRPc::mCheckTsubazeriai)
			.addFunction("mWinTsubazeriai", &mHRPc::mWinTsubazeriai)
			.addFunction("mLoseTsubazeriai", &mHRPc::mLoseTsubazeriai)
			.addFunction("mGetTsubaOuterMotion", &mHRPc::mGetTsubaOuterMotion)
			.addFunction("mGetTsubaOuterMotionNo", &mHRPc::mGetTsubaOuterMotionNo)
			.addFunction("mGetTsubaDisEnable", &mHRPc::mGetTsubaDisEnable)
			.addFunction("mSetTsubaEffectVisible", &mHRPc::mSetTsubaEffectVisible)
			.addFunction("mGetTsubaEffectVisible", &mHRPc::mGetTsubaEffectVisible)
			.addFunction("mCheckLockOn", &mHRPc::mCheckLockOn)
			.addFunction("mGetLockOnNpc", &mHRPc::mGetLockOnNpc)
			.addFunction("mSetAtkPauseTime", &mHRPc::mSetAtkPauseTime)
			.addFunction("mSetCmbKind", &mHRPc::mSetCmbKind)
			.addFunction("mGetCmbKind", &mHRPc::mGetCmbKind)
			.addFunction("mGetLockOnThroughWall", &mHRPc::mGetLockOnThroughWall)
			.addFunction("mGetThrowModeOnly", &mHRPc::mGetThrowModeOnly)
			.addFunction("mGetCatchModeDisEnable", &mHRPc::mGetCatchModeDisEnable)
			.addFunction("mGetDownAttackDisEnable", &mHRPc::mGetDownAttackDisEnable)
			.addFunction("mGetDigDisEnable", &mHRPc::mGetDigDisEnable)
			.addFunction("mSetDigDisEnable4SM", &mHRPc::mSetDigDisEnable4SM)
			.addFunction("mGetSkillCatch", &mHRPc::mGetSkillCatch)
			.addFunction("mSetSkillK7", &mHRPc::mSetSkillK7)
			.addFunction("mGetSkillK7", &mHRPc::mGetSkillK7)
			.addFunction("mSetPcBtlPose", &mHRPc::mSetPcBtlPose)
			.addFunction("mGetPcBtlPose", &mHRPc::mGetPcBtlPose)
			.addFunction("mSetEqWepLaser", &mHRPc::mSetEqWepLaser)
			.addFunction("mGetElectroShockWalk", &mHRPc::mGetElectroShockWalk)
			.addFunction("mGetPoisonWalk", &mHRPc::mGetPoisonWalk)
			.addFunction("mGetCantDispLaserEffect", &mHRPc::mGetCantDispLaserEffect)
			.addFunction("mSetWepChangeUnVisible", &mHRPc::mSetWepChangeUnVisible)
			.addFunction("mSetAtkHitAbsoluteFlag", &mHRPc::mSetAtkHitAbsoluteFlag)
			.addFunction("mGetAtkHitAbsoluteFlag", &mHRPc::mGetAtkHitAbsoluteFlag)
			.addFunction("mSetAttackHitToRollEscepe", &mHRPc::mSetAttackHitToRollEscepe)
			.addFunction("mGetAttackHitToRollEscepe", &mHRPc::mGetAttackHitToRollEscepe)
			.addFunction("mGetPuppetMode", &mHRPc::mGetPuppetMode)
			.addFunction("mGetUseWeaponEffect", &mHRPc::mGetUseWeaponEffect)
			.addFunction("mSetLastAttackNpc", &mHRPc::mSetLastAttackNpc)
			.addFunction("mGetLastAttackNpc", &mHRPc::mGetLastAttackNpc)
			.addFunction("mSetAttackFromBackNpc", &mHRPc::mSetAttackFromBackNpc)
			.addFunction("mGetAttackFromBackNpc", &mHRPc::mGetAttackFromBackNpc)
			.addFunction("mGetFinishBonusFlag", &mHRPc::mGetFinishBonusFlag)
			.addFunction("mSetBanRollEscape", &mHRPc::mSetBanRollEscape)
			.addFunction("mSetBanJump", &mHRPc::mSetBanJump)
			.addFunction("mSetBanPiyori", &mHRPc::mSetBanPiyori)
			.addFunction("mSetBanDeadFukki", &mHRPc::mSetBanDeadFukki)
			.addFunction("mSetBanJustGuard", &mHRPc::mSetBanJustGuard)
			.addFunction("mSetBanWinTsubazeri", &mHRPc::mSetBanWinTsubazeri)
			.addFunction("mGetBanSlotCry", &mHRPc::mGetBanSlotCry)
			.addFunction("mGetBanSlotBel", &mHRPc::mGetBanSlotBel)
			.addFunction("mGetBanSlotBar", &mHRPc::mGetBanSlotBar)
			.addFunction("mGetBanSlot777", &mHRPc::mGetBanSlot777)
			.addFunction("mGetBanJump", &mHRPc::mGetBanJump)
			.addFunction("mGetBanPiyori", &mHRPc::mGetBanPiyori)
			.addFunction("mGetBanDeadFukki", &mHRPc::mGetBanDeadFukki)
			.addFunction("mGetBanJustGuard", &mHRPc::mGetBanJustGuard)
			.addFunction("mGetBanWinTsubazeri", &mHRPc::mGetBanWinTsubazeri)
			.addFunction("mGetWepStick", &mHRPc::mGetWepStick)
			.addFunction("mGetDontSubBattery", &mHRPc::mGetDontSubBattery)
			.addFunction("mGetAutoSubBatteryDisEnable", &mHRPc::mGetAutoSubBatteryDisEnable)
			.addFunction("mGetJustGuardDisEnable", &mHRPc::mGetJustGuardDisEnable)
			.addFunction("mSetDashAtkExec", &mHRPc::mSetDashAtkExec)
			.addFunction("mGetDashAtkExec", &mHRPc::mGetDashAtkExec)
			.addFunction("mGetJustEscapeDisEnable", &mHRPc::mGetJustEscapeDisEnable)
			.addFunction("mGetFpsCursorPtr", &mHRPc::mGetFpsCursorPtr)
			.addFunction("mSetDontRestoreMotion", &mHRPc::mSetDontRestoreMotion)
			.addFunction("mGetDontRestoreMotion", &mHRPc::mGetDontRestoreMotion)
			.addFunction("mSetBikeClash2battou", &mHRPc::mSetBikeClash2battou)
			.addFunction("mSetRotInterpolate", &mHRPc::mSetRotInterpolate)
			.addFunction("mGetRotInterpolateDefault", &mHRPc::mGetRotInterpolateDefault)
			.addFunction("mGetHiTension", &mHRPc::mGetHiTension)
			.addFunction("mTestDancingCombo", &mHRPc::mTestDancingCombo)
			.addFunction("mTestBullet", &mHRPc::mTestBullet)
			.addFunction("mTestFire", &mHRPc::mTestFire)
			.addFunction("mTest360", &mHRPc::mTest360)
			.addFunction("mSetTigerVisible", &mHRPc::mSetTigerVisible)
			.addFunction("mGetTigerVisible", &mHRPc::mGetTigerVisible)
			.addFunction("mGetRightWepTrianglePtr", &mHRPc::mGetRightWepTrianglePtr)
			.addFunction("mGetWepTrianglePtr", &mHRPc::mGetWepTrianglePtr)
			.addFunction("mGetResourceGmfPtr", &mHRPc::mGetResourceGmfPtr)
			.addFunction("mSetPauseNpcFlag", &mHRPc::mSetPauseNpcFlag)
			.addFunction("mGetPauseNpcFlag", &mHRPc::mGetPauseNpcFlag)
			.addFunction("getCurTigerMotionName", &mHRPc::getCurTigerMotionName)
			.addFunction("getCurMotionName", &mHRPc::getCurMotionName)
			.addFunction("isOutResourceMotion", &mHRPc::isOutResourceMotion)
			.addFunction("mGetCancelSetPadOffset", &mHRPc::mGetCancelSetPadOffset)
			.addFunction("mGetChangeEquipFromScript", &mHRPc::mGetChangeEquipFromScript)
			.addFunction("mSetNoBatteryThrow", &mHRPc::mSetNoBatteryThrow)
			.addFunction("mGetNoBatteryThrow", &mHRPc::mGetNoBatteryThrow)
			.addFunction("mSetChangeWeaponEffectVisible", &mHRPc::mSetChangeWeaponEffectVisible)
			.addFunction("mGetChangeWeaponEffectVisible", &mHRPc::mGetChangeWeaponEffectVisible)
			.addFunction("mSetLockOnNockDown", &mHRPc::mSetLockOnNockDown)
			.addFunction("mGetLockOnNockDown", &mHRPc::mGetLockOnNockDown)
			.addFunction("mSetAttackHajiki", &mHRPc::mSetAttackHajiki)
			.addFunction("mGetAttackHajiki", &mHRPc::mGetAttackHajiki)
			.addFunction("mSetDontPlayLoseTsubazeriMotion", &mHRPc::mSetDontPlayLoseTsubazeriMotion)
			.addFunction("mGetDontPlayLoseTsubazeriMotion", &mHRPc::mGetDontPlayLoseTsubazeriMotion)
			.addFunction("mGetNoWearJacket", &mHRPc::mGetNoWearJacket)
			.addFunction("mSetDispChangeWeaponIcon", &mHRPc::mSetDispChangeWeaponIcon)
			.addFunction("mGetDispChangeWeaponIcon", &mHRPc::mGetDispChangeWeaponIcon)
			.addFunction("mSetStandUpAttack", &mHRPc::mSetStandUpAttack)
			.addFunction("mGetStandUpAttack", &mHRPc::mGetStandUpAttack)
			.addFunction("mSetPushingBatteryChargeButton", &mHRPc::mSetPushingBatteryChargeButton)
			.addFunction("mGetPushingBatteryChargeButton", &mHRPc::mGetPushingBatteryChargeButton)
			.addFunction("mSetHitBigConsumeBattertAttack", &mHRPc::mSetHitBigConsumeBattertAttack)
			.addFunction("mGetHitBigConsumeBattertAttack", &mHRPc::mGetHitBigConsumeBattertAttack)
			.addFunction("mSetStartThrowSlow", &mHRPc::mSetStartThrowSlow)
			.addFunction("mGetStartThrowSlow", &mHRPc::mGetStartThrowSlow)
			.addFunction("mGetForceLoseTsubazeri", &mHRPc::mGetForceLoseTsubazeri)
			.addFunction("mGetEqWepID", &mHRPc::mGetEqWepID)
			.addFunction("mGetWepCmbExtend", &mHRPc::mGetWepCmbExtend)
			.addFunction("mSetDeadMotionPlayFlag", &mHRPc::mSetDeadMotionPlayFlag)
			.addFunction("getNPCInterestPosition", &mHRPc::getNPCInterestPosition)
			.addFunction("mGetStammina", &mHRPc::mGetStammina)
			.addFunction("mGetPcStatusPtr", &mHRPc::mGetPcStatusPtr)
			.addFunction("mGetBikeVisible", &mHRPc::mGetBikeVisible)
			.addFunction("mGetFinishNpcNum", &mHRPc::mGetFinishNpcNum)
			.addFunction("mGetLockOnDummyPtr", &mHRPc::mGetLockOnDummyPtr)
			.addFunction("mGetCallMotionProcess", &mHRPc::mGetCallMotionProcess)
			.addFunction("mSetDeadBossNum", &mHRPc::mSetDeadBossNum)
			.addFunction("mGetThrowInfoPtr", &mHRPc::mGetThrowInfoPtr)
			.addFunction("mGetCatchNpc", &mHRPc::mGetCatchNpc)
			.addFunction("mCheckFinishAttackJustBeforeHitSlow", &mHRPc::mCheckFinishAttackJustBeforeHitSlow)
			.addFunction("mGetPcEffectPtr", &mHRPc::mGetPcEffectPtr)
			.addFunction("mGetCallBikeFlag", &mHRPc::mGetCallBikeFlag)
			.addFunction("mGetLostBikeFlag", &mHRPc::mGetLostBikeFlag)
			.addFunction("mSetBikeSight", &mHRPc::mSetBikeSight)
			.addFunction("mSetDontChangeBikeCamera", &mHRPc::mSetDontChangeBikeCamera)
			.addFunction("mGetOnlyMove", &mHRPc::mGetOnlyMove)
			.addFunction("mGetDeadPauseFlag", &mHRPc::mGetDeadPauseFlag)
			.addFunction("mCheckTameMax", &mHRPc::mCheckTameMax)
			.addFunction("mTestHitFinishAttack", &mHRPc::mTestHitFinishAttack)
			.addFunction("mGetFinishJudgeFrame", &mHRPc::mGetFinishJudgeFrame)
			.addFunction("mGetCmbNum", &mHRPc::mGetCmbNum)
			.addFunction("mSetOnlyFlagBattouDemo", &mHRPc::mSetOnlyFlagBattouDemo)
			.addFunction("mSetOnlyFlagNoutouDemo", &mHRPc::mSetOnlyFlagNoutouDemo)
			.addFunction("mSetLockOnThroughWall", &mHRPc::mSetLockOnThroughWall)
			.addFunction("mIsDoingFinishMotion", &mHRPc::mIsDoingFinishMotion)
			.addFunction("mGetSlashModeOnly", &mHRPc::mGetSlashModeOnly)
			.addFunction("mGetBanRollEscape", &mHRPc::mGetBanRollEscape)
			.addFunction("mGetDashAtkDisEnable", &mHRPc::mGetDashAtkDisEnable)
			.addFunction("mGetShopDataPtr", &mHRPc::mGetShopDataPtr)
			.addFunction("mGetCatchTick", &mHRPc::mGetCatchTick)
			.addFunction("UnlockAllMoves", &mHRPc::UnlockAllMoves)
			.addFunction("UnlockAllUpgrades", &mHRPc::UnlockAllUpgrades)
			.addFunction("UnlockAllPcUpgrades", &mHRPc::UnlockAllPcUpgrades)
			.addFunction("SwitchToMainWeapon", &mHRPc::SwitchToMainWeapon)
			.addFunction("UnlockAllWeapons", &mHRPc::UnlockAllWeapons)
			.addFunction("SubPcNowEquipBatteryRatio", &mHRPc::SubPcNowEquipBatteryRatio)
			.addFunction("isAcceptCameraFollowRotation", &mHRPc::isAcceptCameraFollowRotation)
			.addFunction("mTestCanDownAttack", &mHRPc::mTestCanDownAttack)
			.addFunction("mTestRunWeaponEffect", &mHRPc::mTestRunWeaponEffect)
			.addFunction("mFloorEventProc", &mHRPc::mFloorEventProc)
			.addFunction("mCallClearProcessBeforeEvent", &mHRPc::mCallClearProcessBeforeEvent)
			.addFunction("mGetSlowMotion", &mHRPc::mGetSlowMotion)
			.addFunction("mSlowMotionProc", &mHRPc::mSlowMotionProc)
			.addFunction("mSlowMotionSystem", &mHRPc::mSlowMotionSystem)
			.addFunction("mDeadProc", &mHRPc::mDeadProc)
			.addFunction("IncSwingCount", &mHRPc::IncSwingCount)
			.addFunction("TestStoreBikePosForSM", &mHRPc::TestStoreBikePosForSM)
			.addFunction("ReStoreBikePosForSM", &mHRPc::ReStoreBikePosForSM)
			.addFunction("mDigHoleProc", &mHRPc::mDigHoleProc)
			.addFunction("mTestDigHoleAction", &mHRPc::mTestDigHoleAction)
			.addFunction("PcInputMove", &mHRPc::PcInputMove)
			.addFunction("PcInputIdleProc", &mHRPc::PcInputIdleProc)
			.addFunction("mTestCatchZako", &mHRPc::mTestCatchZako)
			.addFunction("mRestore1stChBGM", &mHRPc::mRestore1stChBGM)
			.addFunction("mPlay2ndChBGM", &mHRPc::mPlay2ndChBGM)
			.addFunction("mGetSmokeColor", &mHRPc::mGetSmokeColor)
			.addFunction("mExitBatteryCharge", &mHRPc::mExitBatteryCharge)
			.addFunction("mHitCheckNpc", &mHRPc::mHitCheckNpc)
			.addFunction("mSetCherryFlag", &mHRPc::mSetCherryFlag)
			.addFunction("mCheckBossThrow", &mHRPc::mCheckBossThrow)
			.addFunction("mGetJustGuardJudgeTick", &mHRPc::mGetJustGuardJudgeTick)
			.addFunction("mCheckCanFight", &mHRPc::mCheckCanFight)
			.addFunction("mClearBomStockNum", &mHRPc::mClearBomStockNum)
			.addFunction("mGetSpecialAttackRestTick", &mHRPc::mGetSpecialAttackRestTick)
			.addFunction("mGetEmptyShinkuWaveIndex", &mHRPc::mGetEmptyShinkuWaveIndex)
			.addFunction("mCreateShinkuWave", &mHRPc::mCreateShinkuWave)
			.addFunction("mCallEffectBlur", &mHRPc::mCallEffectBlur)
			.addFunction("mSetLaserTrack", &mHRPc::mSetLaserTrack)
			.addFunction("mSetLaserScale", &mHRPc::mSetLaserScale)
			.addFunction("mSetLaserLogValid", &mHRPc::mSetLaserLogValid)
			.addFunction("mGetLaserColor", &mHRPc::mGetLaserColor)
			.addFunction("mSetLaserColor", &mHRPc::mSetLaserColor)
			.addFunction("mCreateLaserEffect", &mHRPc::mCreateLaserEffect)
			.addFunction("mDeleteChargeEffect", &mHRPc::mDeleteChargeEffect)
			.addFunction("mCreateChargeEffect", &mHRPc::mCreateChargeEffect)
			.addFunction("mCheckBigWeapon", &mHRPc::mCheckBigWeapon)
			.addFunction("mSetDigToolFlag", &mHRPc::mSetDigToolFlag)
			.addFunction("mClearMMSMInit", &mHRPc::mClearMMSMInit)
			.addFunction("mSetBikePos2Motel", &mHRPc::mSetBikePos2Motel)
			.addFunction("mGetStopRenderCounter", &mHRPc::mGetStopRenderCounter)
			.addFunction("mSetStopRenderCounter", &mHRPc::mSetStopRenderCounter)
			.addFunction("mGetLightSideNum", &mHRPc::mGetLightSideNum)
			.addFunction("mGetReceiveDamage", &mHRPc::mGetReceiveDamage)
			.addFunction("mGetMaxCombo", &mHRPc::mGetMaxCombo)
			.addFunction("mSetDown", &mHRPc::mSetDown)
			.addFunction("mSetCallBikeFlag", &mHRPc::mSetCallBikeFlag)
			.addFunction("mSetFireMan", &mHRPc::mSetFireMan)
			.addFunction("mGetDarkSideUseNum", &mHRPc::mGetDarkSideUseNum)
			.addFunction("mGetLightSideRate", &mHRPc::mGetLightSideRate)
			.addFunction("mCallSwordCutDmgEffect", &mHRPc::mCallSwordCutDmgEffect)
			.addFunction("mCallBeamCutDmgEffect", &mHRPc::mCallBeamCutDmgEffect)
			.addFunction("mCallFightAttackDmgEffect", &mHRPc::mCallFightAttackDmgEffect)
			.addFunction("mCallElectDmgEffect", &mHRPc::mCallElectDmgEffect)
			.addFunction("mCallNormalAttackEffect", &mHRPc::mCallNormalAttackEffect)
			.addFunction("IsCenteringHoseiCutmark", &mHRPc::IsCenteringHoseiCutmark)
			.addFunction("CreateCutMarkEffect", &mHRPc::CreateCutMarkEffect)
			.addFunction("CreateGuardBreakEffect", &mHRPc::CreateGuardBreakEffect)
			.addFunction("mSePlayChargeAttack", &mHRPc::mSePlayChargeAttack)
			.addFunction("mCallFinishAttackEffect", &mHRPc::mCallFinishAttackEffect)
			.addFunction("mCreateHugGan", &mHRPc::mCreateHugGan)
			.addFunction("mPlayHugMotion", &mHRPc::mPlayHugMotion)
			.addFunction("mSetPoisonWalk", &mHRPc::mSetPoisonWalk)
			.addFunction("mSetElectroShockBGMPitch", &mHRPc::mSetElectroShockBGMPitch)
			.addFunction("mCheckReadEndAtkMot", &mHRPc::mCheckReadEndAtkMot)
			.addFunction("mGetPcBtlPoseNowMotion", &mHRPc::mGetPcBtlPoseNowMotion)
			.addFunction("mCheckFinishNpc", &mHRPc::mCheckFinishNpc)
			.addFunction("mGetHitEffectPos", &mHRPc::mGetHitEffectPos)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetHitEffectPos_2", &mHRPc::mGetHitEffectPos_2)
			.addFunction("mSetNoutou", &mHRPc::mSetNoutou)
			.addFunction("mSetBattou", &mHRPc::mSetBattou)
			.addFunction("mGetBikeNitro", &mHRPc::mGetBikeNitro)
			.addFunction("mGetBikeRot", &mHRPc::mGetBikeRot)
			.addFunction("mGetEquipDurabilityMax", &mHRPc::mGetEquipDurabilityMax)
			.addFunction("mGetEquipDurability", &mHRPc::mGetEquipDurability)
			.addFunction("mSetOnlyEquip", &mHRPc::mSetOnlyEquip)
			.addFunction("mChangeWeapon4Debug", &mHRPc::mChangeWeapon4Debug)
			.addFunction("mChangeEquipID2KindIndex", &mHRPc::mChangeEquipID2KindIndex)
			.addFunction("mGetLockerIndex", &mHRPc::mGetLockerIndex)
			.addFunction("mDelLocker", &mHRPc::mDelLocker)
			.addFunction("mGetDamageRate", &mHRPc::mGetDamageRate)
			.addFunction("mSetWepCmbExtend", &mHRPc::mSetWepCmbExtend)
			.addFunction("mGetWepPower", &mHRPc::mGetWepPower)
			.addFunction("mSetWepPower", &mHRPc::mSetWepPower)
			.addFunction("mDelWep", &mHRPc::mDelWep)
			.addFunction("mAddWep", &mHRPc::mAddWep)
			.addFunction("mMissCatch", &mHRPc::mMissCatch)
			.addFunction("mPlayThrowMissMotion", &mHRPc::mPlayThrowMissMotion)
			.addFunction("mDispThrowInput", &mHRPc::mDispThrowInput)
			.addFunction("mStartThrowInput", &mHRPc::mStartThrowInput)
			.addFunction("mAdjustHitWallPosition", &mHRPc::mAdjustHitWallPosition)
			.addFunction("mStartThrowSNB", &mHRPc::mStartThrowSNB)
			.addFunction("mFrameProcChangeScreen", &mHRPc::mFrameProcChangeScreen)
			.addFunction("mPlayMiniDemoForWarpPosSantDestroy", &mHRPc::mPlayMiniDemoForWarpPosSantDestroy)
			.addFunction("mSetAfterWarpPosForSantDestroy", &mHRPc::mSetAfterWarpPosForSantDestroy)
			.addFunction("mTestEndWarpPosForSantDestroy", &mHRPc::mTestEndWarpPosForSantDestroy)
			.addFunction("mSetWarpPosForSantDestroy", &mHRPc::mSetWarpPosForSantDestroy)
			.addFunction("mGetChangeScreenStatus", &mHRPc::mGetChangeScreenStatus)
			.addFunction("mEndChangeScreen", &mHRPc::mEndChangeScreen)
			.addFunction("mStartChangeScreen", &mHRPc::mStartChangeScreen)
			.addFunction("mSetBatteryMax", &mHRPc::mSetBatteryMax)
			.addFunction("mGetBatteryRatio", &mHRPc::mGetBatteryRatio)
			.addFunction("mSubBattery", &mHRPc::mSubBattery)
			.addFunction("mAddBattery", &mHRPc::mAddBattery)
			.addFunction("mRecoverNoutouWeaponBattery", &mHRPc::mRecoverNoutouWeaponBattery)
			.addFunction("mPlayMotionEscape", &mHRPc::mPlayMotionEscape)
			.addFunction("mGetInputGuardSlide", &mHRPc::mGetInputGuardSlide)
			.addFunction("mTestLeftGuard", &mHRPc::mTestLeftGuard)
			.addFunction("mTestRightGuard", &mHRPc::mTestRightGuard)
			.addFunction("mTestUpGuard", &mHRPc::mTestUpGuard)
			.addFunction("mGetInputTurn", &mHRPc::mGetInputTurn)
			.addFunction("mGetAttackTimingFrame", &mHRPc::mGetAttackTimingFrame)
			.addFunction("mGetLeftWepTrianglePtr", &mHRPc::mGetLeftWepTrianglePtr)
			.addFunction("mGetExtraComboMotionNo", &mHRPc::mGetExtraComboMotionNo)
			.addFunction("mGetNormalComboMotionNo", &mHRPc::mGetNormalComboMotionNo)
			.addFunction("mSetComboKind", &mHRPc::mSetComboKind)
			.addFunction("mReturnIdleMove", &mHRPc::mReturnIdleMove)
			.addFunction("mDashProc", &mHRPc::mDashProc)
			.addFunction("mDashStartProc", &mHRPc::mDashStartProc)
			.addFunction("mForceLanding", &mHRPc::mForceLanding)
			.addFunction("mCheckJumpAttack", &mHRPc::mCheckJumpAttack)
			.addFunction("mCheckJump", &mHRPc::mCheckJump)
			.addFunction("mJumpProc", &mHRPc::mJumpProc)
			.addFunction("mCheckRouletteAbility", &mHRPc::mCheckRouletteAbility)
			.addFunction("mPreStartProcessSpecialMode", &mHRPc::mPreStartProcessSpecialMode)
			.addFunction("mClear360", &mHRPc::mClear360)
			.addFunction("mClearFire", &mHRPc::mClearFire)
			.addFunction("mClearTiger", &mHRPc::mClearTiger)
			.addFunction("mClearDancingCombo", &mHRPc::mClearDancingCombo)
			.addFunction("mClearRapidFinish", &mHRPc::mClearRapidFinish)
			.addFunction("mClearBullet", &mHRPc::mClearBullet)
			.addFunction("mStartDarkSide", &mHRPc::mStartDarkSide)
			.addFunction("mStart360", &mHRPc::mStart360)
			.addFunction("mStartFire", &mHRPc::mStartFire)
			.addFunction("mStartTiger", &mHRPc::mStartTiger)
			.addFunction("mStartDancingCombo", &mHRPc::mStartDancingCombo)
			.addFunction("mStartRapidFinish", &mHRPc::mStartRapidFinish)
			.addFunction("mStartBullet", &mHRPc::mStartBullet)
			.addFunction("mCheckTigerAttack", &mHRPc::mCheckTigerAttack)
			.addFunction("mTermTiger", &mHRPc::mTermTiger)
			.addFunction("mTigerAttackProc", &mHRPc::mTigerAttackProc)
			.addFunction("mTigerProc", &mHRPc::mTigerProc)
			.addFunction("mTigerAttackInput", &mHRPc::mTigerAttackInput)
			.addFunction("mTigerPadInputProc", &mHRPc::mTigerPadInputProc)
			.addFunction("mCallTigerSetupMatrix", &mHRPc::mCallTigerSetupMatrix)
			.addFunction("mCallTigerMotionProcess", &mHRPc::mCallTigerMotionProcess)
			.addFunction("mUpdateTigerPos", &mHRPc::mUpdateTigerPos)
			.addFunction("mPlayTigerMotion", &mHRPc::mPlayTigerMotion)
			.addFunction("mClearRapidFinishTarget", &mHRPc::mClearRapidFinishTarget)
			.addFunction("mSetRapidFinishTarget", &mHRPc::mSetRapidFinishTarget)
			.addFunction("mSearchRapidFinishNpc", &mHRPc::mSearchRapidFinishNpc)
			.addFunction("mCheckResistRapidFinishNpc", &mHRPc::mCheckResistRapidFinishNpc)
			.addFunction("mSetRapidFinishNpc", &mHRPc::mSetRapidFinishNpc)
			.addFunction("mGet360Tick", &mHRPc::mGet360Tick)
			.addFunction("mGetFireTick", &mHRPc::mGetFireTick)
			.addFunction("mGetTigerTick", &mHRPc::mGetTigerTick)
			.addFunction("mGetDancingComboTick", &mHRPc::mGetDancingComboTick)
			.addFunction("mGetRapidFinishTick", &mHRPc::mGetRapidFinishTick)
			.addFunction("mGetBulletTick", &mHRPc::mGetBulletTick)
			.addFunction("mGetRotInterpolate", &mHRPc::mGetRotInterpolate)
			.addFunction("mCheckChargeMax", &mHRPc::mCheckChargeMax)
			.addFunction("mCheckInputBatteryCharge", &mHRPc::mCheckInputBatteryCharge)
			.addFunction("mCheckInputGuard", &mHRPc::mCheckInputGuard)
			.addFunction("checkAndUpdateWeaponLength", &mHRPc::checkAndUpdateWeaponLength)
			.addFunction("mCallWepMotionProc", &mHRPc::mCallWepMotionProc)
			.addFunction("mSetWepMotionRate", &mHRPc::mSetWepMotionRate)
			.addFunction("mPlayWepMotion", &mHRPc::mPlayWepMotion)
			.addFunction("mSetWeaponLength", &mHRPc::mSetWeaponLength)
			.addFunction("mResumeEasyDemo", &mHRPc::mResumeEasyDemo)
			.addFunction("mPlayEasyDemo", &mHRPc::mPlayEasyDemo)
			.addFunction("mPlayNoutouDemo", &mHRPc::mPlayNoutouDemo)
			.addFunction("mPlayBattouDemo", &mHRPc::mPlayBattouDemo)
			.addFunction("mGetBattouEndMotion", &mHRPc::mGetBattouEndMotion)
			.addFunction("mGetBattouLoopMotion", &mHRPc::mGetBattouLoopMotion)
			.addFunction("mGetCmbNumMax", &mHRPc::mGetCmbNumMax)
			.addFunction("mUpdateLockOnDummyLocate", &mHRPc::mUpdateLockOnDummyLocate)
			.addFunction("mSetLockOnDummyAtOutOfRange", &mHRPc::mSetLockOnDummyAtOutOfRange)
			.addFunction("mUpdateWatchNpc", &mHRPc::mUpdateWatchNpc)
			.addFunction("mUpdateLockOnTarget", &mHRPc::mUpdateLockOnTarget)
			.addFunction("mUpdateLockOnList", &mHRPc::mUpdateLockOnList)
			.addFunction("mRotate2LockOnTarget", &mHRPc::mRotate2LockOnTarget)
			.addFunction("mSetLockOn", &mHRPc::mSetLockOn)
			.addFunction("mCheckLockOnDummy", &mHRPc::mCheckLockOnDummy)
			.addFunction("mInitLockOn", &mHRPc::mInitLockOn)
			.addFunction("mDarkSideSonicProc", &mHRPc::mDarkSideSonicProc)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("bootGuardLightFlashEffect", &mHRPc::bootGuardLightFlashEffect)
			.addFunction("LaserScaleProc", &mHRPc::LaserScaleProc)
			.addFunction("mEffectProc", &mHRPc::mEffectProc)
			.addFunction("mTestBeamKatanaShowyEffect", &mHRPc::mTestBeamKatanaShowyEffect)
			.addFunction("mGetCatchDistance", &mHRPc::mGetCatchDistance)
			.addFunction("mGetMotionSpeed", &mHRPc::mGetMotionSpeed)
			.addFunction("mSetFinishMotionSpeed", &mHRPc::mSetFinishMotionSpeed)
			.addFunction("mCheckTargetObject", &mHRPc::mCheckTargetObject)
			.addFunction("mSearchAttackTargetNpc", &mHRPc::mSearchAttackTargetNpc)
			.addFunction("mSearchDarkSideWarpTargetNpc", &mHRPc::mSearchDarkSideWarpTargetNpc)
			.addFunction("mSearchNearNpc", &mHRPc::mSearchNearNpc)
			.addFunction("mLookAttackTargetNpc", &mHRPc::mLookAttackTargetNpc)
			.addFunction("mLockNearNpc", &mHRPc::mLockNearNpc)
			.addFunction("mLockNearCatchNpc", &mHRPc::mLockNearCatchNpc)
			.addFunction("mAddKillNpcCombo", &mHRPc::mAddKillNpcCombo)
			.addFunction("mIntiFinishNpc", &mHRPc::mIntiFinishNpc)
			.addFunction("mSetDarkSideTarget", &mHRPc::mSetDarkSideTarget)
			.addFunction("mInputDarkSideSuccess", &mHRPc::mInputDarkSideSuccess)
			.addFunction("mPcMoveFrontOfNpc4DarkSideMode", &mHRPc::mPcMoveFrontOfNpc4DarkSideMode)
			.addFunction("mPcMoveFrontOfNpc", &mHRPc::mPcMoveFrontOfNpc)
			.addFunction("mSearchNextNpc", &mHRPc::mSearchNextNpc)
			.addFunction("mCheckFinishMode", &mHRPc::mCheckFinishMode)
			.addFunction("mPrepareInputFinish", &mHRPc::mPrepareInputFinish)
			.addFunction("mSetIntoTsubazeriai", &mHRPc::mSetIntoTsubazeriai)
			.addFunction("mSePlayUpperAttack", &mHRPc::mSePlayUpperAttack)
			.addFunction("mTameAttckProc", &mHRPc::mTameAttckProc)
			.addFunction("mJoyuuLight", &mHRPc::mJoyuuLight)
			.addFunction("mSlotResult", &mHRPc::mSlotResult)
			.addFunction("mAttackHitCheck", &mHRPc::mAttackHitCheck)
			.addFunction("mAttackProc", &mHRPc::mAttackProc)
			.addFunction("mFailedInputFinishProcessForVsBoss", &mHRPc::mFailedInputFinishProcessForVsBoss)
			.addFunction("mSpecialFightAttackProc", &mHRPc::mSpecialFightAttackProc)
			.addFunction("mCheckComboAttackInput", &mHRPc::mCheckComboAttackInput)
			.addFunction("mTrvStartDownAttack", &mHRPc::mTrvStartDownAttack)
			.addFunction("mStartFightAttack", &mHRPc::mStartFightAttack)
			.addFunction("mGetAttackMotionStartFrame30fps", &mHRPc::mGetAttackMotionStartFrame30fps)
			.addFunction("mCheckCanCatchNpc", &mHRPc::mCheckCanCatchNpc)
			.addFunction("mSetSEPlayShakeInputSuccess", &mHRPc::mSetSEPlayShakeInputSuccess)
			.addFunction("mPlayFinishMotion", &mHRPc::mPlayFinishMotion)
			.addFunction("mSuccessFinishInput", &mHRPc::mSuccessFinishInput)
			.addFunction("mFinishMotionFrameKetaAge", &mHRPc::mFinishMotionFrameKetaAge)
			.addFunction("mPlayNunchackAttackMotion", &mHRPc::mPlayNunchackAttackMotion)
			.addFunction("mClearNpcDamageInfo", &mHRPc::mClearNpcDamageInfo)
			.addFunction("mGetHjkDir", &mHRPc::mGetHjkDir)
			.addFunction("mGetFinishAtkMotNo", &mHRPc::mGetFinishAtkMotNo)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSearchThrow", &mHRPc::mSearchThrow)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetPcThrowMotNo", &mHRPc::mGetPcThrowMotNo)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetThrowDamageMotion", &mHRPc::mGetThrowDamageMotion)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetPcThrowMotNo4ZakoB", &mHRPc::mGetPcThrowMotNo4ZakoB)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetPcThrowMotNo4ZakoF", &mHRPc::mGetPcThrowMotNo4ZakoF)
			.addFunction("mCheckThrowSpace", &mHRPc::mCheckThrowSpace)
			.addFunction("mGetDownAtkMotNo", &mHRPc::mGetDownAtkMotNo)
			.addFunction("mGetNextAtkMotNo", &mHRPc::mGetNextAtkMotNo)
			.addFunction("mAttackRestoreProc", &mHRPc::mAttackRestoreProc)
			.addFunction("mAttackStoreProc", &mHRPc::mAttackStoreProc)
			.addFunction("mResetCombo", &mHRPc::mResetCombo)
			.addFunction("mChangeWep", &mHRPc::mChangeWep)
			.addFunction("mWepSeReleaseRequest", &mHRPc::mWepSeReleaseRequest)
			.addFunction("mInitWepStatus", &mHRPc::mInitWepStatus)
			.addFunction("mGetWepIndex", &mHRPc::mGetWepIndex)
			.addFunction("mGetAtkNo", &mHRPc::mGetAtkNo)
			.addFunction("mGetAtkNo_2", &mHRPc::mGetAtkNo_2)
			.addFunction("mSideStepProc", &mHRPc::mSideStepProc)
			.addFunction("mGetRollEscMotNo", &mHRPc::mGetRollEscMotNo)
			.addFunction("mMoveProc", &mHRPc::mMoveProc)
			.addFunction("mGetPcWillDirectRotY", &mHRPc::mGetPcWillDirectRotY)
			.addFunction("mGetRunSpeed", &mHRPc::mGetRunSpeed)
			.addFunction("mGetWalkSpeed", &mHRPc::mGetWalkSpeed)
			.addFunction("mMoveCommon", &mHRPc::mMoveCommon)
			.addFunction("mLockOnMoveProc", &mHRPc::mLockOnMoveProc)
			.addFunction("mUpdateAtkColl", &mHRPc::mUpdateAtkColl)
			.addFunction("mStartChargeEffect", &mHRPc::mStartChargeEffect)
			.addFunction("mPreResetChargeAttack", &mHRPc::mPreResetChargeAttack)
			.addFunction("mCheckLastTarget", &mHRPc::mCheckLastTarget)
			.addFunction("mCheckBDash", &mHRPc::mCheckBDash)
			.addFunction("mCheckChangeWeapon", &mHRPc::mCheckChangeWeapon)
			.addFunction("mCheckWakeUpZako", &mHRPc::mCheckWakeUpZako)
			.addFunction("mCheckSchool3RapidAttack", &mHRPc::mCheckSchool3RapidAttack)
			.addFunction("mCheckBackAttack", &mHRPc::mCheckBackAttack)
			.addFunction("mCheckInputDirection4Pc", &mHRPc::mCheckInputDirection4Pc)
			.addFunction("mCheckThrowInput", &mHRPc::mCheckThrowInput)
			.addFunction("mCheckInputCombo", &mHRPc::mCheckInputCombo)
			.addFunction("mCheckFollowThorough", &mHRPc::mCheckFollowThorough)
			.addFunction("mCheckSantDash", &mHRPc::mCheckSantDash)
			.addFunction("mCheckNormalAttack", &mHRPc::mCheckNormalAttack)
			.addFunction("mCheckNormalDashAttack", &mHRPc::mCheckNormalDashAttack)
			.addFunction("mCheck777Bomb", &mHRPc::mCheck777Bomb)
			.addFunction("mCheck777BombStart", &mHRPc::mCheck777BombStart)
			.addFunction("mCheckIdling", &mHRPc::mCheckIdling)
			.addFunction("mCheckIdlingMotion", &mHRPc::mCheckIdlingMotion)
			.addFunction("mCheckRollEscape", &mHRPc::mCheckRollEscape)
			.addFunction("mCheckGuard", &mHRPc::mCheckGuard)
			.addFunction("mCheckChargeUpDown", &mHRPc::mCheckChargeUpDown)
			.addFunction("mCheckCharge", &mHRPc::mCheckCharge)
			.addFunction("mCheckCanCancelLastCombo", &mHRPc::mCheckCanCancelLastCombo)
			.addFunction("mCheckLastCombo", &mHRPc::mCheckLastCombo)
			.addFunction("mCheckStrongComboAttack", &mHRPc::mCheckStrongComboAttack)
			.addFunction("mCheckPiyoriComboAttack", &mHRPc::mCheckPiyoriComboAttack)
			.addFunction("mCheckNockBack", &mHRPc::mCheckNockBack)
			.addFunction("mCheckDown2StandUp", &mHRPc::mCheckDown2StandUp)
			.addFunction("mCheckDown", &mHRPc::mCheckDown)
			.addFunction("mCheckBlowStatus", &mHRPc::mCheckBlowStatus)
			.addFunction("mCheckBombAttack", &mHRPc::mCheckBombAttack)
			.addFunction("mCheckJumpThrustAttack", &mHRPc::mCheckJumpThrustAttack)
			.addFunction("mCheckChargeAttack", &mHRPc::mCheckChargeAttack)
			.addFunction("mCheckNunchackAttack", &mHRPc::mCheckNunchackAttack)
			.addFunction("mCheckRangeAttack", &mHRPc::mCheckRangeAttack)
			.addFunction("mCheckThrowBeforeAttack", &mHRPc::mCheckThrowBeforeAttack)
			.addFunction("mCheckCatchMiss", &mHRPc::mCheckCatchMiss)
			.addFunction("mStartCatchAttack", &mHRPc::mStartCatchAttack)
			.addFunction("mCheckDownAttack", &mHRPc::mCheckDownAttack)
			.addFunction("mCheckFightCmbAttack", &mHRPc::mCheckFightCmbAttack)
			.addFunction("mCheckCityFightAttack", &mHRPc::mCheckCityFightAttack)
			.addFunction("mCheckCanAttack", &mHRPc::mCheckCanAttack)
			.addFunction("mCheckAttackHit", &mHRPc::mCheckAttackHit)
			.addFunction("mCheckAttack", &mHRPc::mCheckAttack)
			.addFunction("mSetHajikareWait", &mHRPc::mSetHajikareWait)
			.addFunction("mCheckHajikareWait", &mHRPc::mCheckHajikareWait)
			.addFunction("mSetGuardWait", &mHRPc::mSetGuardWait)
			.addFunction("mCheckGuardWait", &mHRPc::mCheckGuardWait)
			.addFunction("mCheckHajikare", &mHRPc::mCheckHajikare)
			.addFunction("mCheckGuardMotion", &mHRPc::mCheckGuardMotion)
			.addFunction("mCheckRestorePadOffset", &mHRPc::mCheckRestorePadOffset)
			.addFunction("mResetPadOffset", &mHRPc::mResetPadOffset)
			.addFunction("mSetNeedShakeDir", &mHRPc::mSetNeedShakeDir)
			.addFunction("mCheckContinueCombo", &mHRPc::mCheckContinueCombo)
			.addFunction("mCheckAtkUpper", &mHRPc::mCheckAtkUpper)
			.addFunction("mGetChargeMotionNo", &mHRPc::mGetChargeMotionNo)
			.addFunction("mGetUpChargeAttackMotionNo", &mHRPc::mGetUpChargeAttackMotionNo)
			.addFunction("mResetCatch", &mHRPc::mResetCatch)
			.addFunction("mSetTsubaOuterMotion", &mHRPc::mSetTsubaOuterMotion)
			.addFunction("mSetTsubaDat", &mHRPc::mSetTsubaDat)
			.addFunction("mTsubazeriaiProc", &mHRPc::mTsubazeriaiProc)
			.addFunction("mGuardDamageProc", &mHRPc::mGuardDamageProc)
			.addFunction("mDamageProc", &mHRPc::mDamageProc)
			.addFunction("mGetAttackDistance", &mHRPc::mGetAttackDistance)
			.addFunction("mGetAttackDirection", &mHRPc::mGetAttackDirection)
			.addFunction("mTestRunMotion", &mHRPc::mTestRunMotion)
			.addFunction("mCheckDamageMotion", &mHRPc::mCheckDamageMotion)
			.addFunction("mCheckCanHit", &mHRPc::mCheckCanHit)
			.addFunction("mHitCheck", &mHRPc::mHitCheck)
			.addFunction("mSetElectricDamage", &mHRPc::mSetElectricDamage)
			.addFunction("mSetDamage", &mHRPc::mSetDamage)
			.addFunction("mJudgeJustGuardInput", &mHRPc::mJudgeJustGuardInput)
			.addFunction("mJudgePiyori", &mHRPc::mJudgePiyori)
			.addFunction("mConvertGuardMotion", &mHRPc::mConvertGuardMotion)
			.addFunction("mSetDamageIK", &mHRPc::mSetDamageIK)
			.addFunction("mCheckAutoGuard", &mHRPc::mCheckAutoGuard)
			.addFunction("mCheckCanGuard", &mHRPc::mCheckCanGuard)
			.addFunction("mGetBtlCommonMotNo", &mHRPc::mGetBtlCommonMotNo)
			.addFunction("mSetWepEffectVisible", &mHRPc::mSetWepEffectVisible)
			.addFunction("mSetWepVisible", &mHRPc::mSetWepVisible)
			.addFunction("mSetVisible", &mHRPc::mSetVisible)
			.addFunction("mSetCamera2TrvBack", &mHRPc::mSetCamera2TrvBack)
			.addFunction("mSetCameraInit", &mHRPc::mSetCameraInit)
			.addFunction("mCallCameraInit", &mHRPc::mCallCameraInit)
			.addFunction("mCameraInitProcess", &mHRPc::mCameraInitProcess)
			.addFunction("mCallTsubaBrendMotPorc", &mHRPc::mCallTsubaBrendMotPorc)
			.addFunction("mCallCulcBrendRate", &mHRPc::mCallCulcBrendRate)
			.addFunction("mGetCollPtr", &mHRPc::mGetCollPtr)
			.addFunction("mBossDeadCommonProcess", &mHRPc::mBossDeadCommonProcess)
			.addFunction("mPlayBattleIdolMotion", &mHRPc::mPlayBattleIdolMotion)
			.addFunction("mResetValueAtPlayMotion", &mHRPc::mResetValueAtPlayMotion)
			// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mPlayMotionBlend", &mHRPc::mPlayMotionBlend)
			.addFunction("mPlayMotionBlend_2", &mHRPc::mPlayMotionBlend_2)
			.addFunction("mPlayMotion", &mHRPc::mPlayMotion)
			.addFunction("mGetAtkMotPPtr", &mHRPc::mGetAtkMotPPtr)
			.addFunction("mGetAtkMotPtr", &mHRPc::mGetAtkMotPtr)
			.addFunction("mRequestReadAtkMot", &mHRPc::mRequestReadAtkMot)
			.addFunction("mReleaseAtkMot", &mHRPc::mReleaseAtkMot)
			.addFunction("mCheckNeedModelRead", &mHRPc::mCheckNeedModelRead)
			.addFunction("mChangeTShirtModel", &mHRPc::mChangeTShirtModel)
			.addFunction("mSetNoWearJacket", &mHRPc::mSetNoWearJacket)
			.addFunction("mControlDispWestWeapon", &mHRPc::mControlDispWestWeapon)
			.addFunction("mDetachWeapon", &mHRPc::mDetachWeapon)
			.addFunction("mAttachWeapon", &mHRPc::mAttachWeapon)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("mRenderFpsCursor", &mHRPc::mRenderFpsCursor)
			.addFunction("mAddTension", &mHRPc::mAddTension)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetWarpPos", &mHRPc::mSetWarpPos)
			.addFunction("mRenderShadowProc", &mHRPc::mRenderShadowProc)
			.addFunction("mPostRenderProc", &mHRPc::mPostRenderProc)
			.addFunction("mRenderProc", &mHRPc::mRenderProc)
			.addFunction("mSemitransparentProcess", &mHRPc::mSemitransparentProcess)
			.addFunction("mPostFrameCommonProc2", &mHRPc::mPostFrameCommonProc2)
			.addFunction("mPostFrameProc", &mHRPc::mPostFrameProc)
			.addFunction("mPcRestoreDamage", &mHRPc::mPcRestoreDamage)
			.addFunction("checkAndPlayCameraBankMotion", &mHRPc::checkAndPlayCameraBankMotion)
			.addFunction("checkAndBootStageHitEffect", &mHRPc::checkAndBootStageHitEffect)
			.addFunction("onUpdateIK", &mHRPc::onUpdateIK)
			.addFunction("mDamageElectroShockProc", &mHRPc::mDamageElectroShockProc)
			.addFunction("mDamageDownLeverGachaProc", &mHRPc::mDamageDownLeverGachaProc)
			.addFunction("mSpecialWalkProc", &mHRPc::mSpecialWalkProc)
			.addFunction("mCheckHaveWep", &mHRPc::mCheckHaveWep)
			.addFunction("mChangeWeaponProcess", &mHRPc::mChangeWeaponProcess)
			.addFunction("TryChangeWeapon", &mHRPc::TryChangeWeapon)
			.addFunction("mStartChangeWeapon", &mHRPc::mStartChangeWeapon)
			.addFunction("mFrameProc", &mHRPc::mFrameProc)
			.addFunction("mSetOffGroundIk", &mHRPc::mSetOffGroundIk)
			.addFunction("mInitData", &mHRPc::mInitData)
			.addFunction("mEffectInit", &mHRPc::mEffectInit)
			.addFunction("mTerm", &mHRPc::mTerm)
			.addFunction("mInit", &mHRPc::mInit)
			.addFunction("mCheckCanOperate", &mHRPc::mCheckCanOperate)
			.addFunction("mSetOutsidePlayMotion", &mHRPc::mSetOutsidePlayMotion)
			.addFunction("mGetEquipTextureName", &mHRPc::mGetEquipTextureName)
			.addFunction("mGetEquipModelName", &mHRPc::mGetEquipModelName)
			.addFunction("mTermWarpPosForSantDestroy", &mHRPc::mTermWarpPosForSantDestroy)
			.addFunction("mSubDarkSideTick", &mHRPc::mSubDarkSideTick)
			.addFunction("mEquipProc", &mHRPc::mEquipProc)
			.addFunction("mCheckBeforeAttackHit", &mHRPc::mCheckBeforeAttackHit)
			.addFunction("mCheckPcReadEndWithoutWeapon", &mHRPc::mCheckPcReadEndWithoutWeapon)
			.addFunction("mCheckFightAttack", &mHRPc::mCheckFightAttack)
			.addFunction("mCheckCatchAttack", &mHRPc::mCheckCatchAttack)
			.addFunction("mCallAttackEffect", &mHRPc::mCallAttackEffect)
			.addFunction("SetPcSpeedBlurOff", &mHRPc::SetPcSpeedBlurOff)
			.addFunction("mStopLightSabelSound", &mHRPc::mStopLightSabelSound)
			.addFunction("mGetPcPower", &mHRPc::mGetPcPower)
			.addFunction("mRestorePcData", &mHRPc::mRestorePcData)
			.addFunction("UnlockEverythingForDeathmatch", &mHRPc::UnlockEverythingForDeathmatch)
			.addFunction("mResetDeadFlag", &mHRPc::mResetDeadFlag)
			.addFunction("mSetBatteryMaxAllWeapon", &mHRPc::mSetBatteryMaxAllWeapon)
			.addFunction("mPlayLightSabelSound", &mHRPc::mPlayLightSabelSound)
			.addFunction("TurnOffLaserEffectOnPlayer", &mHRPc::TurnOffLaserEffectOnPlayer)
			.addFunction("mClearBossInit", &mHRPc::mClearBossInit)
			.addFunction("mGetPcSaveData", &mHRPc::mGetPcSaveData)
			.addFunction("TestStorePcPosForSM", &mHRPc::TestStorePcPosForSM)
			.addFunction("ReStorePcPosForSM", &mHRPc::ReStorePcPosForSM)
			.addFunction("mCheckIntoStatusScreen", &mHRPc::mCheckIntoStatusScreen)
			.addFunction("mPlayMotionFromDatPtr", &mHRPc::mPlayMotionFromDatPtr)
			.addFunction("mCheckFinishAttack", &mHRPc::mCheckFinishAttack)
			.addFunction("mCheckTsubazering", &mHRPc::mCheckTsubazering)
			.addFunction("mGetBikePos", &mHRPc::mGetBikePos)
			.addFunction("mTestBikeRide", &mHRPc::mTestBikeRide)
			.addFunction("mSetPadOffset", &mHRPc::mSetPadOffset)
			.addFunction("mCheckNeutral", &mHRPc::mCheckNeutral)
			.addFunction("mIsPlayMotion", &mHRPc::mIsPlayMotion)
			.addFunction("mCheckBatteryCharge", &mHRPc::mCheckBatteryCharge)
			.addFunction("mCheckInitCamera", &mHRPc::mCheckInitCamera)
			.addFunction("mCheckDead", &mHRPc::mCheckDead)
			.addFunction("mClearDarkSide", &mHRPc::mClearDarkSide)
			.addFunction("mExitChargeBattery4FixCamera", &mHRPc::mExitChargeBattery4FixCamera)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("StorePcPosForSM", &mHRPc::StorePcPosForSM)
			.addFunction("mCheckEquipReadEnd", &mHRPc::mCheckEquipReadEnd)
			.addFunction("mTestBattouDemo", &mHRPc::mTestBattouDemo)
			.addFunction("mAddLocker", &mHRPc::mAddLocker)
			.addFunction("mChkLocker", &mHRPc::mChkLocker)
			.addFunction("mSetEquip", &mHRPc::mSetEquip)
			.addFunction("mControlDispWestWeapons", &mHRPc::mControlDispWestWeapons)
			.addFunction("mCheckStageChangeInitEnd", &mHRPc::mCheckStageChangeInitEnd)
			.addFunction("mSetElectroShockWalk", &mHRPc::mSetElectroShockWalk)
			.addFunction("mSetHugWalk", &mHRPc::mSetHugWalk)
			.addFunction("mGetBikeSpd", &mHRPc::mGetBikeSpd)
			.addFunction("mResetFireMan", &mHRPc::mResetFireMan)
			.addFunction("mResetChargeAttack", &mHRPc::mResetChargeAttack)
			.addFunction("mResetFPCamera", &mHRPc::mResetFPCamera)
			.addFunction("mCheckDarkSideMode", &mHRPc::mCheckDarkSideMode)
			.addFunction("mAttachObj", &mHRPc::mAttachObj)
			.addFunction("mRestoreSubMissionWeapon", &mHRPc::mRestoreSubMissionWeapon)
			.addFunction("mGetBattery", &mHRPc::mGetBattery)
			.addFunction("mGetBatteryMax", &mHRPc::mGetBatteryMax)
			.addFunction("mSetBattery", &mHRPc::mSetBattery)
			.addFunction("StorePcPosForSM_2", &mHRPc::StorePcPosForSM_2)
			.addFunction("StoreBikePosForSM", &mHRPc::StoreBikePosForSM)
			.addFunction("mSetBikePos", &mHRPc::mSetBikePos)
			.addFunction("mSetBikeRot", &mHRPc::mSetBikeRot)
			.addFunction("mAddPcMoney", &mHRPc::mAddPcMoney)
			.addFunction("mSetBikeJumpForSubMission", &mHRPc::mSetBikeJumpForSubMission)
			.addFunction("mCallDemoBattou", &mHRPc::mCallDemoBattou)
			.addFunction("mTestPauseBattouDemo", &mHRPc::mTestPauseBattouDemo)
			.addFunction("mResumeBattouDemo", &mHRPc::mResumeBattouDemo)
			.addFunction("mCallDemoNoutou", &mHRPc::mCallDemoNoutou)
			.addFunction("mCancelBattouNoutouDemo", &mHRPc::mCancelBattouNoutouDemo)
			.addFunction("mRestorePlayMotionFromDatPtr", &mHRPc::mRestorePlayMotionFromDatPtr)
			.addFunction("mGetAtkScl", &mHRPc::mGetAtkScl)
			.addFunction("GetSwingCount", &mHRPc::GetSwingCount)
			.addFunction("ClearSwingCount", &mHRPc::ClearSwingCount)
			.addFunction("mCheckLockOnEnemy", &mHRPc::mCheckLockOnEnemy)
			.addFunction("mCheckThrowAttack", &mHRPc::mCheckThrowAttack)
			.addFunction("mCheckGetAllWeapon", &mHRPc::mCheckGetAllWeapon)
			.addFunction("mCheckGuardSlide", &mHRPc::mCheckGuardSlide)
			.addFunction("mCheckTsubaAttack", &mHRPc::mCheckTsubaAttack)
			.addFunction("mCheckSuccessInputFinish", &mHRPc::mCheckSuccessInputFinish)
			.addFunction("mSetInputMode", &mHRPc::mSetInputMode)
			.addFunction("mCheckInputMove", &mHRPc::mCheckInputMove)
			.addFunction("mSetEquipMk3", &mHRPc::mSetEquipMk3)
			.addFunction("mCheckTrvReadEnd", &mHRPc::mCheckTrvReadEnd)
			.addFunction("mSetWepBattou", &mHRPc::mSetWepBattou)
			.addFunction("mSetWepNoutou", &mHRPc::mSetWepNoutou)
			.addFunction("mGetPauseFlag", &mHRPc::mGetPauseFlag)
			.addFunction("mCheckFinishAttackAndCantLockOn", &mHRPc::mCheckFinishAttackAndCantLockOn)
			.addFunction("mTremStageChange", &mHRPc::mTremStageChange)
			.addFunction("mSetEventWalk", &mHRPc::mSetEventWalk)
			.addFunction("mInitStageChange", &mHRPc::mInitStageChange)
			.addFunction("mClearGameFlag", &mHRPc::mClearGameFlag)
			.addStaticFunction("mPostFrameProc_RegisterHook", &mHRPc::mPostFrameProc_RegisterHook)
			.addStaticFunction("mFrameProc_RegisterHook", &mHRPc::mFrameProc_RegisterHook)
			.addStaticFunction("mEffectProc_RegisterHook", &mHRPc::mEffectProc_RegisterHook)
			.addStaticFunction("mSetEquip_RegisterHook", &mHRPc::mSetEquip_RegisterHook)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRPc::mEscapeActionInit) == 4, "expected mHRPc::mEscapeActionInit to be size 4");
static_assert(sizeof(mHRPc::mPcStatus) == 2308, "expected mHRPc::mPcStatus to be size 2308");
static_assert(sizeof(mHRPc::mMiniDemo) == 12, "expected mHRPc::mMiniDemo to be size 12");
static_assert(sizeof(mHRPc::mPcSaveData) == 1636, "expected mHRPc::mPcSaveData to be size 1636");
static_assert(sizeof(mHRPc::mDarkSideInfo) == 52, "expected mHRPc::mDarkSideInfo to be size 52");
static_assert(sizeof(mHRPc::mpBike) == 4, "expected mHRPc::mpBike to be size 4");
static_assert(sizeof(mHRPc::mSnd) == 176, "expected mHRPc::mSnd to be size 176");
static_assert(sizeof(mHRPc::mInputMode) == 4, "expected mHRPc::mInputMode to be size 4");
static_assert(sizeof(mHRPc::mInputModeOld) == 4, "expected mHRPc::mInputModeOld to be size 4");
static_assert(sizeof(mHRPc::mInputModeBefore) == 4, "expected mHRPc::mInputModeBefore to be size 4");
static_assert(sizeof(mHRPc::mPauseAll) == 1, "expected mHRPc::mPauseAll to be size 1");
static_assert(sizeof(mHRPc::mPauseNpc) == 1, "expected mHRPc::mPauseNpc to be size 1");
static_assert(sizeof(mHRPc::mOperate) == 1, "expected mHRPc::mOperate to be size 1");
static_assert(sizeof(mHRPc::mOnlyMove) == 1, "expected mHRPc::mOnlyMove to be size 1");
static_assert(sizeof(mHRPc::mMotSpdAdj) == 1, "expected mHRPc::mMotSpdAdj to be size 1");
static_assert(sizeof(mHRPc::mDead) == 1, "expected mHRPc::mDead to be size 1");
static_assert(sizeof(mHRPc::mDeadPause) == 1, "expected mHRPc::mDeadPause to be size 1");
static_assert(sizeof(mHRPc::mCameraOperate) == 1, "expected mHRPc::mCameraOperate to be size 1");
static_assert(sizeof(mHRPc::mBattouDemoRequest) == 1, "expected mHRPc::mBattouDemoRequest to be size 1");
static_assert(sizeof(mHRPc::mStageChangeInitEnd) == 1, "expected mHRPc::mStageChangeInitEnd to be size 1");
static_assert(sizeof(mHRPc::mStageChangeTermEnd) == 1, "expected mHRPc::mStageChangeTermEnd to be size 1");
static_assert(sizeof(mHRPc::mStageChangeMuteki) == 1, "expected mHRPc::mStageChangeMuteki to be size 1");
static_assert(sizeof(mHRPc::mBanStatusScreen) == 1, "expected mHRPc::mBanStatusScreen to be size 1");
static_assert(sizeof(mHRPc::mAtkPauseTime) == 4, "expected mHRPc::mAtkPauseTime to be size 4");
static_assert(sizeof(mHRPc::mStopRenderFrameNum) == 4, "expected mHRPc::mStopRenderFrameNum to be size 4");
static_assert(sizeof(mHRPc::mWait1Frame) == 4, "expected mHRPc::mWait1Frame to be size 4");
static_assert(sizeof(mHRPc::mPcEffect) == 656, "expected mHRPc::mPcEffect to be size 656");
static_assert(sizeof(mHRPc::mPcHug) == 32, "expected mHRPc::mPcHug to be size 32");
static_assert(sizeof(mHRPc::mTiger) == 80, "expected mHRPc::mTiger to be size 80");
static_assert(sizeof(mHRPc::mLockOnPos) == 12, "expected mHRPc::mLockOnPos to be size 12");
static_assert(sizeof(mHRPc::mpLockOnNpc) == 4, "expected mHRPc::mpLockOnNpc to be size 4");
static_assert(sizeof(mHRPc::mpTsubaNpc) == 4, "expected mHRPc::mpTsubaNpc to be size 4");
static_assert(sizeof(mHRPc::mpCatchNpc) == 4, "expected mHRPc::mpCatchNpc to be size 4");
static_assert(sizeof(mHRPc::mpCatchReserveNpc) == 4, "expected mHRPc::mpCatchReserveNpc to be size 4");
static_assert(sizeof(mHRPc::mpEscapeNpc) == 4, "expected mHRPc::mpEscapeNpc to be size 4");
static_assert(sizeof(mHRPc::mpInitFinishNpc) == 4, "expected mHRPc::mpInitFinishNpc to be size 4");
static_assert(sizeof(mHRPc::mpNextFinishNpc) == 4, "expected mHRPc::mpNextFinishNpc to be size 4");
static_assert(sizeof(mHRPc::mpFinishNpc) == 32, "expected mHRPc::mpFinishNpc to be size 32");
static_assert(sizeof(mHRPc::mpFinishReserveNpc) == 4, "expected mHRPc::mpFinishReserveNpc to be size 4");
static_assert(sizeof(mHRPc::mpDSTargetNpc) == 4, "expected mHRPc::mpDSTargetNpc to be size 4");
static_assert(sizeof(mHRPc::mpDwnAtkNpc) == 4, "expected mHRPc::mpDwnAtkNpc to be size 4");
static_assert(sizeof(mHRPc::mpLastAtkNpc) == 4, "expected mHRPc::mpLastAtkNpc to be size 4");
static_assert(sizeof(mHRPc::mpAttackFromBackNpc) == 4, "expected mHRPc::mpAttackFromBackNpc to be size 4");
static_assert(sizeof(mHRPc::mLockOnDummy) == 1408, "expected mHRPc::mLockOnDummy to be size 1408");
static_assert(sizeof(mHRPc::mSavehitOidashiDisEnable) == 1, "expected mHRPc::mSavehitOidashiDisEnable to be size 1");
static_assert(sizeof(mHRPc::mSlowMotionSytemMotNo) == 4, "expected mHRPc::mSlowMotionSytemMotNo to be size 4");
static_assert(sizeof(mHRPc::mSlowMotionSytemButton) == 4, "expected mHRPc::mSlowMotionSytemButton to be size 4");
static_assert(sizeof(mHRPc::mWepCollL) == 36, "expected mHRPc::mWepCollL to be size 36");
static_assert(sizeof(mHRPc::m_pAttackHitTriangle) == 4, "expected mHRPc::m_pAttackHitTriangle to be size 4");
static_assert(sizeof(mHRPc::mFade) == 12, "expected mHRPc::mFade to be size 12");
static_assert(sizeof(mHRPc::mSubMissionflag) == 2, "expected mHRPc::mSubMissionflag to be size 2");
static_assert(sizeof(mHRPc::mSubMissionPcPosStoreFlag) == 1, "expected mHRPc::mSubMissionPcPosStoreFlag to be size 1");
static_assert(sizeof(mHRPc::mSubMissionStorePos) == 12, "expected mHRPc::mSubMissionStorePos to be size 12");
static_assert(sizeof(mHRPc::mSubMissionStoreRot) == 12, "expected mHRPc::mSubMissionStoreRot to be size 12");
static_assert(sizeof(mHRPc::mSubMissionBikePosStoreFlag) == 1, "expected mHRPc::mSubMissionBikePosStoreFlag to be size 1");
static_assert(sizeof(mHRPc::mSubMissionStoreBikePos) == 12, "expected mHRPc::mSubMissionStoreBikePos to be size 12");
static_assert(sizeof(mHRPc::mSubMissionStoreBikeRot) == 12, "expected mHRPc::mSubMissionStoreBikeRot to be size 12");
static_assert(sizeof(mHRPc::mpSubMissionJumpCameraHandle) == 4, "expected mHRPc::mpSubMissionJumpCameraHandle to be size 4");
static_assert(sizeof(mHRPc::mDisEnableBtlPoseCalc) == 4, "expected mHRPc::mDisEnableBtlPoseCalc to be size 4");
static_assert(sizeof(mHRPc::mTamePush) == 1, "expected mHRPc::mTamePush to be size 1");
static_assert(sizeof(mHRPc::mTameMax) == 1, "expected mHRPc::mTameMax to be size 1");
static_assert(sizeof(mHRPc::mTameSe) == 1, "expected mHRPc::mTameSe to be size 1");
static_assert(sizeof(mHRPc::mDigAction) == 4, "expected mHRPc::mDigAction to be size 4");
static_assert(sizeof(mHRPc::mChangeWepProc) == 4, "expected mHRPc::mChangeWepProc to be size 4");
static_assert(sizeof(mHRPc::mChangeWepKind) == 4, "expected mHRPc::mChangeWepKind to be size 4");
static_assert(sizeof(mHRPc::mMenuDisEnableFrame) == 4, "expected mHRPc::mMenuDisEnableFrame to be size 4");
static_assert(sizeof(mHRPc::m_sMotName) == 4, "expected mHRPc::m_sMotName to be size 4");
static_assert(sizeof(mHRPc::m_sPreMotName) == 4, "expected mHRPc::m_sPreMotName to be size 4");
static_assert(sizeof(mHRPc::m_sOutMotName) == 16, "expected mHRPc::m_sOutMotName to be size 16");
static_assert(sizeof(mHRPc::m_bIsBootStageHitEffect) == 1, "expected mHRPc::m_bIsBootStageHitEffect to be size 1");
static_assert(sizeof(mHRPc::m_inPreWeaponTopPosi) == 12, "expected mHRPc::m_inPreWeaponTopPosi to be size 12");
static_assert(sizeof(mHRPc::m_bIsPreTigerVisible) == 1, "expected mHRPc::m_bIsPreTigerVisible to be size 1");
static_assert(sizeof(mHRPc::m_bIsPreFinishAttack) == 1, "expected mHRPc::m_bIsPreFinishAttack to be size 1");
static_assert(sizeof(mHRPc::m_bIsBeginFinishAttack) == 1, "expected mHRPc::m_bIsBeginFinishAttack to be size 1");
static_assert(sizeof(mHRPc::m_bIsPlayCamBankMotion) == 1, "expected mHRPc::m_bIsPlayCamBankMotion to be size 1");
static_assert(sizeof(mHRPc::m_inWeaponLengthRatio) == 12, "expected mHRPc::m_inWeaponLengthRatio to be size 12");
static_assert(sizeof(mHRPc) == 0x1fb0, "expected mHRPc to be size 0x1fb0");

// [Structure] class ghmAABB
class ghmAABB
{
public:
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mExtent, offset 0xc>
	struct Vec mExtent;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmAABB [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmAABB& InObject)
	{
		mCenter = InObject.mCenter;
		mExtent = InObject.mExtent;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmAABB>("ghmAABB")
			.addFunction("__tostring", &ghmAABB::ToString)
			.addFunction("GetPtrAddr", &ghmAABB::GetPtrAddr)
			.addProperty("mCenter", &ghmAABB::mCenter)
			.addProperty("mExtent", &ghmAABB::mExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmAABB::mCenter) == 12, "expected ghmAABB::mCenter to be size 12");
static_assert(sizeof(ghmAABB::mExtent) == 12, "expected ghmAABB::mExtent to be size 12");
static_assert(sizeof(ghmAABB) == 0x18, "expected ghmAABB to be size 0x18");

// [Structure] class ghmGcOctTreeNode
class ghmGcOctTreeNode
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class ghmGcOctTree* mpContainer, offset 0x4>
	class ghmGcOctTree* mpContainer = nullptr;

	// <int32_t mDepthLevel, offset 0x8>
	int32_t mDepthLevel = 0;

	// <int32_t mKey, offset 0xc>
	int32_t mKey = 0;

	// <ghmGcOctTreeNode* mpParent, offset 0x10>
	ghmGcOctTreeNode* mpParent = nullptr;

	// <ghmGcOctTreeNode* mpChildL[0x8], offset 0x14>
	ghmGcOctTreeNode* mpChildL[8];

	// <int32_t mNextKey[0x6], offset 0x34>
	int32_t mNextKey[6];

	// <class ghmGcOctTreeNodeObj* mpObjTop, offset 0x4c>
	class ghmGcOctTreeNodeObj* mpObjTop = nullptr;

	// <class ghmAABB mShape, offset 0x50>
	class ghmAABB mShape;

	// <uint32_t mVisible, offset 0x68>
	uint32_t mVisible = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcOctTreeNode [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcOctTreeNode& InObject)
	{
		mpContainer = InObject.mpContainer;
		mDepthLevel = InObject.mDepthLevel;
		mKey = InObject.mKey;
		mpParent = InObject.mpParent;
		mpObjTop = InObject.mpObjTop;
		mShape = InObject.mShape;
		mVisible = InObject.mVisible;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTreeNode>("ghmGcOctTreeNode")
			.addFunction("__tostring", &ghmGcOctTreeNode::ToString)
			.addFunction("GetPtrAddr", &ghmGcOctTreeNode::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTreeNode::field_0)
			.addProperty("mpContainer", &ghmGcOctTreeNode::mpContainer)
			.addProperty("mDepthLevel", &ghmGcOctTreeNode::mDepthLevel)
			.addProperty("mKey", &ghmGcOctTreeNode::mKey)
			.addProperty("mpParent", &ghmGcOctTreeNode::mpParent)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpChildL", &ghmGcOctTreeNode::mpChildL)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mNextKey", &ghmGcOctTreeNode::mNextKey)
			.addProperty("mpObjTop", &ghmGcOctTreeNode::mpObjTop)
			.addProperty("mShape", &ghmGcOctTreeNode::mShape)
			.addProperty("mVisible", &ghmGcOctTreeNode::mVisible)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTreeNode::field_0) == 4, "expected ghmGcOctTreeNode::field_0 to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpContainer) == 4, "expected ghmGcOctTreeNode::mpContainer to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mDepthLevel) == 4, "expected ghmGcOctTreeNode::mDepthLevel to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mKey) == 4, "expected ghmGcOctTreeNode::mKey to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpParent) == 4, "expected ghmGcOctTreeNode::mpParent to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpChildL) == 32, "expected ghmGcOctTreeNode::mpChildL to be size 32");
static_assert(sizeof(ghmGcOctTreeNode::mNextKey) == 24, "expected ghmGcOctTreeNode::mNextKey to be size 24");
static_assert(sizeof(ghmGcOctTreeNode::mpObjTop) == 4, "expected ghmGcOctTreeNode::mpObjTop to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mShape) == 24, "expected ghmGcOctTreeNode::mShape to be size 24");
static_assert(sizeof(ghmGcOctTreeNode::mVisible) == 4, "expected ghmGcOctTreeNode::mVisible to be size 4");
static_assert(sizeof(ghmGcOctTreeNode) == 0x6c, "expected ghmGcOctTreeNode to be size 0x6c");

// [Structure] class ghmGcOctTree
class ghmGcOctTree
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <int32_t mMaxDepthLevel, offset 0x4>
	int32_t mMaxDepthLevel = 0;

	// <class ghmGcOctTreeNode* mpRootNode, offset 0x8>
	class ghmGcOctTreeNode* mpRootNode = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcOctTree [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcOctTree& InObject)
	{
		mMaxDepthLevel = InObject.mMaxDepthLevel;
		mpRootNode = InObject.mpRootNode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTree>("ghmGcOctTree")
			.addFunction("__tostring", &ghmGcOctTree::ToString)
			.addFunction("GetPtrAddr", &ghmGcOctTree::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTree::field_0)
			.addProperty("mMaxDepthLevel", &ghmGcOctTree::mMaxDepthLevel)
			.addProperty("mpRootNode", &ghmGcOctTree::mpRootNode)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTree::field_0) == 4, "expected ghmGcOctTree::field_0 to be size 4");
static_assert(sizeof(ghmGcOctTree::mMaxDepthLevel) == 4, "expected ghmGcOctTree::mMaxDepthLevel to be size 4");
static_assert(sizeof(ghmGcOctTree::mpRootNode) == 4, "expected ghmGcOctTree::mpRootNode to be size 4");
static_assert(sizeof(ghmGcOctTree) == 0xc, "expected ghmGcOctTree to be size 0xc");

// [Structure] class ghmGcCollObjHitResult
class ghmGcCollObjHitResult
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[48];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcCollObjHitResult [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcCollObjHitResult& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcCollObjHitResult>("ghmGcCollObjHitResult")
			.addFunction("__tostring", &ghmGcCollObjHitResult::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObjHitResult::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjHitResult) == 0x30, "expected ghmGcCollObjHitResult to be size 0x30");

// [Structure] struct WGclMaterialSpec
struct WGclMaterialSpec
{
public:
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mEnable, offset 0x8>
	uint32_t mEnable = 0;

	// <uint32_t mPad[0x5], offset 0xc>
	uint32_t mPad[5];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGclMaterialSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGclMaterialSpec& InObject)
	{
		mEnable = InObject.mEnable;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclMaterialSpec>("WGclMaterialSpec")
			.addFunction("__tostring", &WGclMaterialSpec::ToString)
			.addFunction("GetPtrAddr", &WGclMaterialSpec::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclMaterialSpec::mIDStr)
			.addProperty("mEnable", &WGclMaterialSpec::mEnable)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclMaterialSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclMaterialSpec::mIDStr) == 8, "expected WGclMaterialSpec::mIDStr to be size 8");
static_assert(sizeof(WGclMaterialSpec::mEnable) == 4, "expected WGclMaterialSpec::mEnable to be size 4");
static_assert(sizeof(WGclMaterialSpec::mPad) == 20, "expected WGclMaterialSpec::mPad to be size 20");
static_assert(sizeof(WGclMaterialSpec) == 0x20, "expected WGclMaterialSpec to be size 0x20");

// [Structure] class ghmResGroup
class ghmResGroup
{
public:
	/// Struct member variables

	// <uint32_t mMagicNo, offset 0x0>
	uint32_t mMagicNo = 0;

	// <uint32_t mResourceNum, offset 0x4>
	uint32_t mResourceNum = 0;

	// <uint32_t mAttrOffset, offset 0x8>
	uint32_t mAttrOffset = 0;

	// <uint32_t mVersion, offset 0xc>
	uint32_t mVersion = 0;

	// <class ghmResStrTable* mpStrTablePtr, offset 0x10>
	class ghmResStrTable* mpStrTablePtr = nullptr;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag = 0;

	// <uint32_t mPad[0x3], offset 0x18>
	uint32_t mPad[3];

	/// 14 Functions

	// [Function] uint32_t __convention("thiscall") ghmResGroup::GetResourceNum(class ghmResGroup* const this) [?GetResourceNum@ghmResGroup@@QAEIXZ]
	typedef uint32_t(__thiscall* _GetResourceNum_ghmResGroup__QAEIXZ)(class ghmResGroup* const thisPtr);
	uint32_t GetResourceNum()
	{
		_GetResourceNum_ghmResGroup__QAEIXZ mFunc = (_GetResourceNum_ghmResGroup__QAEIXZ)(GameModule + 0x9dc80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") ghmResGroup::IsNoInstance(class ghmResGroup* const this, int32_t arg2) [?IsNoInstance@ghmResGroup@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _IsNoInstance_ghmResGroup__QAE_NH_Z)(class ghmResGroup* const thisPtr, int32_t arg2);
	uint8_t IsNoInstance(int32_t arg2)
	{
		_IsNoInstance_ghmResGroup__QAE_NH_Z mFunc = (_IsNoInstance_ghmResGroup__QAE_NH_Z)(GameModule + 0x6c5eb0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") ghmResGroup::IsGroup(class ghmResGroup* const this, int32_t arg2) [?IsGroup@ghmResGroup@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _IsGroup_ghmResGroup__QAE_NH_Z)(class ghmResGroup* const thisPtr, int32_t arg2);
	uint8_t IsGroup(int32_t arg2)
	{
		_IsGroup_ghmResGroup__QAE_NH_Z mFunc = (_IsGroup_ghmResGroup__QAE_NH_Z)(GameModule + 0x6c5ef0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ghmResGroup::Initialize(class ghmResGroup* const this, uint8_t arg2) [?Initialize@ghmResGroup@@IAEX_N@Z]
	typedef void(__thiscall* _Initialize_ghmResGroup__IAEX_N_Z)(class ghmResGroup* const thisPtr, uint8_t arg2);
	void Initialize(uint8_t arg2)
	{
		_Initialize_ghmResGroup__IAEX_N_Z mFunc = (_Initialize_ghmResGroup__IAEX_N_Z)(GameModule + 0x6c5f30);
		return mFunc(this, arg2);
	}
	// [Function] uint32_t __convention("thiscall") ghmResGroup::GetResourceSize(class ghmResGroup* const this, int32_t arg2) [?GetResourceSize@ghmResGroup@@QAEIH@Z]
	typedef uint32_t(__thiscall* _GetResourceSize_ghmResGroup__QAEIH_Z)(class ghmResGroup* const thisPtr, int32_t arg2);
	uint32_t GetResourceSize(int32_t arg2)
	{
		_GetResourceSize_ghmResGroup__QAEIH_Z mFunc = (_GetResourceSize_ghmResGroup__QAEIH_Z)(GameModule + 0x6c6430);
		return mFunc(this, arg2);
	}
	// [Function] class ghmResAttr* __convention("thiscall") ghmResGroup::GetFileAttr(class ghmResGroup* const this, int32_t arg2) [?GetFileAttr@ghmResGroup@@QAEPBVghmResAttr@@H@Z]
	typedef class ghmResAttr*(__thiscall* _GetFileAttr_ghmResGroup__QAEPBVghmResAttr__H_Z)(class ghmResGroup* const thisPtr, int32_t arg2);
	class ghmResAttr* GetFileAttr(int32_t arg2)
	{
		_GetFileAttr_ghmResGroup__QAEPBVghmResAttr__H_Z mFunc = (_GetFileAttr_ghmResGroup__QAEPBVghmResAttr__H_Z)(GameModule + 0x6c6470);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") ghmResGroup::GetResourceNameIndex(class ghmResGroup* const this, char const* arg2) [?GetResourceNameIndex@ghmResGroup@@QAEHPBD@Z]
	typedef int32_t(__thiscall* _GetResourceNameIndex_ghmResGroup__QAEHPBD_Z)(class ghmResGroup* const thisPtr, char const* arg2);
	int32_t GetResourceNameIndex(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetResourceNameIndex_ghmResGroup__QAEHPBD_Z mFunc = (_GetResourceNameIndex_ghmResGroup__QAEHPBD_Z)(GameModule + 0x6c64b0);
		return mFunc(this, arg2_c_str);
	}
	// [Function] int32_t __convention("thiscall") ghmResGroup::GetResourceIndex(class ghmResGroup* const this, char const* arg2) [?GetResourceIndex@ghmResGroup@@QAEHPBD@Z]
	typedef int32_t(__thiscall* _GetResourceIndex_ghmResGroup__QAEHPBD_Z)(class ghmResGroup* const thisPtr, char const* arg2);
	int32_t GetResourceIndex(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetResourceIndex_ghmResGroup__QAEHPBD_Z mFunc = (_GetResourceIndex_ghmResGroup__QAEHPBD_Z)(GameModule + 0x6c6540);
		return mFunc(this, arg2_c_str);
	}
	// [Function] void* __convention("thiscall") ghmResGroup::GetResource(class ghmResGroup* const this, char const* ResID) [?GetResource@ghmResGroup@@QAEPAXPBD@Z]
	typedef void*(__thiscall* _GetResource_ghmResGroup__QAEPAXPBD_Z)(class ghmResGroup* const thisPtr, char const* ResID);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void GetResource(std::string ResID)
	{
		char const* ResID_c_str = ResID.c_str();
		_GetResource_ghmResGroup__QAEPAXPBD_Z mFunc = (_GetResource_ghmResGroup__QAEPAXPBD_Z)(GameModule + 0x6c65d0);
		mFunc(this, ResID_c_str);
	}
	// [Function] class ghmResGroup* __convention("thiscall") ghmResGroup::GetGroup(class ghmResGroup* const this, char const* GroupName) [?GetGroup@ghmResGroup@@QAEPAV1@PBD@Z]
	typedef class ghmResGroup*(__thiscall* _GetGroup_ghmResGroup__QAEPAV1_PBD_Z)(class ghmResGroup* const thisPtr, char const* GroupName);
	class ghmResGroup* GetGroup(std::string GroupName)
	{
		char const* GroupName_c_str = GroupName.c_str();
		_GetGroup_ghmResGroup__QAEPAV1_PBD_Z mFunc = (_GetGroup_ghmResGroup__QAEPAV1_PBD_Z)(GameModule + 0x6c6700);
		return mFunc(this, GroupName_c_str);
	}
	// [Function] void* __convention("thiscall") ghmResGroup::GetResource(class ghmResGroup* const this, int32_t idx) [?GetResource@ghmResGroup@@QAEPAXH@Z]
	typedef void*(__thiscall* _GetResource_ghmResGroup__QAEPAXH_Z_2)(class ghmResGroup* const thisPtr, int32_t idx);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void GetResource_2(int32_t idx)
	{
		_GetResource_ghmResGroup__QAEPAXH_Z_2 mFunc = (_GetResource_ghmResGroup__QAEPAXH_Z_2)(GameModule + 0x6c67c0);
		mFunc(this, idx);
	}
	// [Function] char const* __convention("thiscall") ghmResGroup::GetResourceName(class ghmResGroup* const this, int32_t idx) [?GetResourceName@ghmResGroup@@QAEPBDH@Z]
	typedef char const*(__thiscall* _GetResourceName_ghmResGroup__QAEPBDH_Z)(class ghmResGroup* const thisPtr, int32_t idx);
	std::string GetResourceName(int32_t idx)
	{
		_GetResourceName_ghmResGroup__QAEPBDH_Z mFunc = (_GetResourceName_ghmResGroup__QAEPBDH_Z)(GameModule + 0x6c6810);
		char const* OutResult = mFunc(this, idx);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] class ghmResGroup* __convention("thiscall") ghmResGroup::GetGroup(class ghmResGroup* const this, int32_t idx) [?GetGroup@ghmResGroup@@QAEPAV1@H@Z]
	typedef class ghmResGroup*(__thiscall* _GetGroup_ghmResGroup__QAEPAV1_H_Z_2)(class ghmResGroup* const thisPtr, int32_t idx);
	class ghmResGroup* GetGroup_2(int32_t idx)
	{
		_GetGroup_ghmResGroup__QAEPAV1_H_Z_2 mFunc = (_GetGroup_ghmResGroup__QAEPAV1_H_Z_2)(GameModule + 0x6c6850);
		return mFunc(this, idx);
	}
	// [Function] class ghmResGroup* __convention("thiscall") ghmResGroup::GetGroupRecursive(class ghmResGroup* const this, char const* arg2) [?GetGroupRecursive@ghmResGroup@@QAEPAV1@PBD@Z]
	typedef class ghmResGroup*(__thiscall* _GetGroupRecursive_ghmResGroup__QAEPAV1_PBD_Z)(class ghmResGroup* const thisPtr, char const* arg2);
	class ghmResGroup* GetGroupRecursive(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetGroupRecursive_ghmResGroup__QAEPAV1_PBD_Z mFunc = (_GetGroupRecursive_ghmResGroup__QAEPAV1_PBD_Z)(GameModule + 0x6c68a0);
		return mFunc(this, arg2_c_str);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmResGroup (MagicNo: " << mMagicNo << ", Resources: " << mResourceNum << ", Version: " << mVersion << ") [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmResGroup& InObject)
	{
		mMagicNo = InObject.mMagicNo;
		mResourceNum = InObject.mResourceNum;
		mAttrOffset = InObject.mAttrOffset;
		mVersion = InObject.mVersion;
		mpStrTablePtr = InObject.mpStrTablePtr;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmResGroup>("ghmResGroup")
			.addFunction("__tostring", &ghmResGroup::ToString)
			.addFunction("GetPtrAddr", &ghmResGroup::GetPtrAddr)
			.addProperty("mMagicNo", &ghmResGroup::mMagicNo)
			.addProperty("mResourceNum", &ghmResGroup::mResourceNum)
			.addProperty("mAttrOffset", &ghmResGroup::mAttrOffset)
			.addProperty("mVersion", &ghmResGroup::mVersion)
			.addProperty("mpStrTablePtr", &ghmResGroup::mpStrTablePtr)
			.addProperty("mFlag", &ghmResGroup::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmResGroup::mPad)
			.addFunction("GetResourceNum", &ghmResGroup::GetResourceNum)
			.addFunction("IsNoInstance", &ghmResGroup::IsNoInstance)
			.addFunction("IsGroup", &ghmResGroup::IsGroup)
			.addFunction("Initialize", &ghmResGroup::Initialize)
			.addFunction("GetResourceSize", &ghmResGroup::GetResourceSize)
			.addFunction("GetFileAttr", &ghmResGroup::GetFileAttr)
			.addFunction("GetResourceNameIndex", &ghmResGroup::GetResourceNameIndex)
			.addFunction("GetResourceIndex", &ghmResGroup::GetResourceIndex)
			.addFunction("GetResource", &ghmResGroup::GetResource)
			.addFunction("GetGroup", &ghmResGroup::GetGroup)
			.addFunction("GetResource_2", &ghmResGroup::GetResource_2)
			.addFunction("GetResourceName", &ghmResGroup::GetResourceName)
			.addFunction("GetGroup_2", &ghmResGroup::GetGroup_2)
			.addFunction("GetGroupRecursive", &ghmResGroup::GetGroupRecursive)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmResGroup::mMagicNo) == 4, "expected ghmResGroup::mMagicNo to be size 4");
static_assert(sizeof(ghmResGroup::mResourceNum) == 4, "expected ghmResGroup::mResourceNum to be size 4");
static_assert(sizeof(ghmResGroup::mAttrOffset) == 4, "expected ghmResGroup::mAttrOffset to be size 4");
static_assert(sizeof(ghmResGroup::mVersion) == 4, "expected ghmResGroup::mVersion to be size 4");
static_assert(sizeof(ghmResGroup::mpStrTablePtr) == 4, "expected ghmResGroup::mpStrTablePtr to be size 4");
static_assert(sizeof(ghmResGroup::mFlag) == 4, "expected ghmResGroup::mFlag to be size 4");
static_assert(sizeof(ghmResGroup::mPad) == 12, "expected ghmResGroup::mPad to be size 12");
static_assert(sizeof(ghmResGroup) == 0x24, "expected ghmResGroup to be size 0x24");

// [Structure] class ghmResStrTable
class ghmResStrTable
{
public:
	/// Struct member variables

	// <uint32_t mNum, offset 0x0>
	uint32_t mNum = 0;

	// <char const** mppStrings, offset 0x4>
	char const** mppStrings = nullptr;

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag = 0;

	// <uint32_t mPad[0x1], offset 0xc>
	uint32_t mPad[1];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmResStrTable [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmResStrTable& InObject)
	{
		mNum = InObject.mNum;
		mppStrings = InObject.mppStrings;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmResStrTable>("ghmResStrTable")
			.addFunction("__tostring", &ghmResStrTable::ToString)
			.addFunction("GetPtrAddr", &ghmResStrTable::GetPtrAddr)
			.addProperty("mNum", &ghmResStrTable::mNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppStrings", &ghmResStrTable::mppStrings)
			.addProperty("mFlag", &ghmResStrTable::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmResStrTable::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmResStrTable::mNum) == 4, "expected ghmResStrTable::mNum to be size 4");
static_assert(sizeof(ghmResStrTable::mppStrings) == 4, "expected ghmResStrTable::mppStrings to be size 4");
static_assert(sizeof(ghmResStrTable::mFlag) == 4, "expected ghmResStrTable::mFlag to be size 4");
static_assert(sizeof(ghmResStrTable::mPad) == 4, "expected ghmResStrTable::mPad to be size 4");
static_assert(sizeof(ghmResStrTable) == 0x10, "expected ghmResStrTable to be size 0x10");

// [Structure] class TGanPlay
class TGanPlay
{
public:
	// [Structure] struct TGanPlay::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <class TGan* pGan, offset 0x0>
		class TGan* pGan = nullptr;

		// <class TGanPlayNode* pTopNode, offset 0x4>
		class TGanPlayNode* pTopNode = nullptr;

		// <class TFAnm* pFAnm, offset 0x8>
		class TFAnm* pFAnm = nullptr;

		// <int32_t FAnmNum, offset 0xc>
		int32_t FAnmNum = 0;

		// <class TGanPlayNode* pNode, offset 0x10>
		class TGanPlayNode* pNode = nullptr;

		// <int32_t NodeNum, offset 0x14>
		int32_t NodeNum = 0;

		// <uint8_t Loop, offset 0x18>
		uint8_t Loop = 0;

		// <uint8_t PlayTyokugoFlag, offset 0x19>
		uint8_t PlayTyokugoFlag = 0;

		// <uint8_t PlayFlag, offset 0x1a>
		uint8_t PlayFlag = 0;

		// <Unidentified data segment, offset 0x1b>
	private:
		char _UnidentifiedData_27[1];

	public:
		// <float PlayTick, offset 0x1c>
		float PlayTick = 0;

		// <float Rate, offset 0x20>
		float Rate = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TGanPlay::MAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TGanPlay::MAIN& InObject)
		{
			pGan = InObject.pGan;
			pTopNode = InObject.pTopNode;
			pFAnm = InObject.pFAnm;
			FAnmNum = InObject.FAnmNum;
			pNode = InObject.pNode;
			NodeNum = InObject.NodeNum;
			Loop = InObject.Loop;
			PlayTyokugoFlag = InObject.PlayTyokugoFlag;
			PlayFlag = InObject.PlayFlag;
			PlayTick = InObject.PlayTick;
			Rate = InObject.Rate;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MAIN>("TGanPlay_MAIN")
				.addFunction("__tostring", &TGanPlay::MAIN::ToString)
				.addFunction("GetPtrAddr", &TGanPlay::MAIN::GetPtrAddr)
				.addProperty("pGan", &TGanPlay::MAIN::pGan)
				.addProperty("pTopNode", &TGanPlay::MAIN::pTopNode)
				.addProperty("pFAnm", &TGanPlay::MAIN::pFAnm)
				.addProperty("FAnmNum", &TGanPlay::MAIN::FAnmNum)
				.addProperty("pNode", &TGanPlay::MAIN::pNode)
				.addProperty("NodeNum", &TGanPlay::MAIN::NodeNum)
				.addProperty("Loop", &TGanPlay::MAIN::Loop)
				.addProperty("PlayTyokugoFlag", &TGanPlay::MAIN::PlayTyokugoFlag)
				.addProperty("PlayFlag", &TGanPlay::MAIN::PlayFlag)
				.addProperty("PlayTick", &TGanPlay::MAIN::PlayTick)
				.addProperty("Rate", &TGanPlay::MAIN::Rate)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGanPlay::MAIN::pGan) == 4, "expected TGanPlay::MAIN::pGan to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pTopNode) == 4, "expected TGanPlay::MAIN::pTopNode to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pFAnm) == 4, "expected TGanPlay::MAIN::pFAnm to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::FAnmNum) == 4, "expected TGanPlay::MAIN::FAnmNum to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pNode) == 4, "expected TGanPlay::MAIN::pNode to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::NodeNum) == 4, "expected TGanPlay::MAIN::NodeNum to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::Loop) == 1, "expected TGanPlay::MAIN::Loop to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayTyokugoFlag) == 1, "expected TGanPlay::MAIN::PlayTyokugoFlag to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayFlag) == 1, "expected TGanPlay::MAIN::PlayFlag to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayTick) == 4, "expected TGanPlay::MAIN::PlayTick to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::Rate) == 4, "expected TGanPlay::MAIN::Rate to be size 4");
	static_assert(sizeof(TGanPlay::MAIN) == 0x24, "expected TGanPlay::MAIN to be size 0x24");

	/// Struct member variables

	// <struct TGanPlay::MAIN dat, offset 0x0>
	struct TGanPlay::MAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class TGanPlay [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TGanPlay& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGanPlay>("TGanPlay")
			.addFunction("__tostring", &TGanPlay::ToString)
			.addFunction("GetPtrAddr", &TGanPlay::GetPtrAddr)
			.addProperty("dat", &TGanPlay::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGanPlay::dat) == 36, "expected TGanPlay::dat to be size 36");
static_assert(sizeof(TGanPlay) == 0x24, "expected TGanPlay to be size 0x24");

// enum TGAN_STATE
enum TGAN_STATE : uint32_t
{
	// <TGAN_STATE_INIT = 0x0>
	TGAN_STATE_INIT = 0,

	// <TGAN_STATE_STANDBY = 0x1>
	TGAN_STATE_STANDBY = 1,

	// <TGAN_STATE_ERROR = 0x2>
	TGAN_STATE_ERROR = 2

};

// [Structure] class TGan
class TGan
{
public:
	// [Structure] struct TGan::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <uint8_t ProcessBlock, offset 0x0>
		uint8_t ProcessBlock = 0;

		// <uint8_t XYZLS16WKFlag, offset 0x1>
		uint8_t XYZLS16WKFlag = 0;

		// <Unidentified data segment, offset 0x2>
	private:
		char _UnidentifiedData_2[2];

	public:
		// <enum TGAN_STATE State, offset 0x4>
		enum TGAN_STATE State;

		// <struct WGanSpec* pSpec, offset 0x8>
		struct WGanSpec* pSpec = nullptr;

		// <int32_t TimingSoundDataIndex, offset 0xc>
		int32_t TimingSoundDataIndex = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TGan::tagMAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TGan::tagMAIN& InObject)
		{
			ProcessBlock = InObject.ProcessBlock;
			XYZLS16WKFlag = InObject.XYZLS16WKFlag;
			State = InObject.State;
			pSpec = InObject.pSpec;
			TimingSoundDataIndex = InObject.TimingSoundDataIndex;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<tagMAIN>("TGan_tagMAIN")
				.addFunction("__tostring", &TGan::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TGan::tagMAIN::GetPtrAddr)
				.addProperty("ProcessBlock", &TGan::tagMAIN::ProcessBlock)
				.addProperty("XYZLS16WKFlag", &TGan::tagMAIN::XYZLS16WKFlag)
				.addProperty("State", &TGan::tagMAIN::State)
				.addProperty("pSpec", &TGan::tagMAIN::pSpec)
				.addProperty("TimingSoundDataIndex", &TGan::tagMAIN::TimingSoundDataIndex)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGan::tagMAIN::ProcessBlock) == 1, "expected TGan::tagMAIN::ProcessBlock to be size 1");
	static_assert(sizeof(TGan::tagMAIN::XYZLS16WKFlag) == 1, "expected TGan::tagMAIN::XYZLS16WKFlag to be size 1");
	static_assert(sizeof(TGan::tagMAIN::State) == 4, "expected TGan::tagMAIN::State to be size 4");
	static_assert(sizeof(TGan::tagMAIN::pSpec) == 4, "expected TGan::tagMAIN::pSpec to be size 4");
	static_assert(sizeof(TGan::tagMAIN::TimingSoundDataIndex) == 4, "expected TGan::tagMAIN::TimingSoundDataIndex to be size 4");
	static_assert(sizeof(TGan::tagMAIN) == 0x10, "expected TGan::tagMAIN to be size 0x10");

	/// Struct member variables

	// <struct TGan::tagMAIN dat, offset 0x0>
	struct TGan::tagMAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class TGan [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TGan& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGan>("TGan")
			.addFunction("__tostring", &TGan::ToString)
			.addFunction("GetPtrAddr", &TGan::GetPtrAddr)
			.addProperty("dat", &TGan::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGan::dat) == 16, "expected TGan::dat to be size 16");
static_assert(sizeof(TGan) == 0x10, "expected TGan to be size 0x10");

// [Structure] struct WGanSpec
struct WGanSpec
{
public:
	/// Struct member variables

	// <uint32_t mID, offset 0x0>
	uint32_t mID = 0;

	// <uint32_t mVersion, offset 0x4>
	uint32_t mVersion = 0;

	// <uint32_t mStartTick, offset 0x8>
	uint32_t mStartTick = 0;

	// <uint32_t mEndTick, offset 0xc>
	uint32_t mEndTick = 0;

	// <uint32_t mFlag, offset 0x10>
	uint32_t mFlag = 0;

	// <uint16_t mNodeCount, offset 0x14>
	uint16_t mNodeCount = 0;

	// <uint16_t mMaterialCount, offset 0x16>
	uint16_t mMaterialCount = 0;

	// <uint16_t mPad0[0x2], offset 0x18>
	uint16_t mPad0[2];

	// <struct WGanMaterialSpec* mpTopMaterial, offset 0x1c>
	struct WGanMaterialSpec* mpTopMaterial = nullptr;

	// <struct WGanNodeSpec* mpTopNode, offset 0x20>
	struct WGanNodeSpec* mpTopNode = nullptr;

	// <uint32_t mPad1[0x3], offset 0x24>
	uint32_t mPad1[3];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGanSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGanSpec& InObject)
	{
		mID = InObject.mID;
		mVersion = InObject.mVersion;
		mStartTick = InObject.mStartTick;
		mEndTick = InObject.mEndTick;
		mFlag = InObject.mFlag;
		mNodeCount = InObject.mNodeCount;
		mMaterialCount = InObject.mMaterialCount;
		mpTopMaterial = InObject.mpTopMaterial;
		mpTopNode = InObject.mpTopNode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanSpec>("WGanSpec")
			.addFunction("__tostring", &WGanSpec::ToString)
			.addFunction("GetPtrAddr", &WGanSpec::GetPtrAddr)
			.addProperty("mID", &WGanSpec::mID)
			.addProperty("mVersion", &WGanSpec::mVersion)
			.addProperty("mStartTick", &WGanSpec::mStartTick)
			.addProperty("mEndTick", &WGanSpec::mEndTick)
			.addProperty("mFlag", &WGanSpec::mFlag)
			.addProperty("mNodeCount", &WGanSpec::mNodeCount)
			.addProperty("mMaterialCount", &WGanSpec::mMaterialCount)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad0", &WGanSpec::mPad0)
			.addProperty("mpTopMaterial", &WGanSpec::mpTopMaterial)
			.addProperty("mpTopNode", &WGanSpec::mpTopNode)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanSpec::mID) == 4, "expected WGanSpec::mID to be size 4");
static_assert(sizeof(WGanSpec::mVersion) == 4, "expected WGanSpec::mVersion to be size 4");
static_assert(sizeof(WGanSpec::mStartTick) == 4, "expected WGanSpec::mStartTick to be size 4");
static_assert(sizeof(WGanSpec::mEndTick) == 4, "expected WGanSpec::mEndTick to be size 4");
static_assert(sizeof(WGanSpec::mFlag) == 4, "expected WGanSpec::mFlag to be size 4");
static_assert(sizeof(WGanSpec::mNodeCount) == 2, "expected WGanSpec::mNodeCount to be size 2");
static_assert(sizeof(WGanSpec::mMaterialCount) == 2, "expected WGanSpec::mMaterialCount to be size 2");
static_assert(sizeof(WGanSpec::mPad0) == 4, "expected WGanSpec::mPad0 to be size 4");
static_assert(sizeof(WGanSpec::mpTopMaterial) == 4, "expected WGanSpec::mpTopMaterial to be size 4");
static_assert(sizeof(WGanSpec::mpTopNode) == 4, "expected WGanSpec::mpTopNode to be size 4");
static_assert(sizeof(WGanSpec::mPad1) == 12, "expected WGanSpec::mPad1 to be size 12");
static_assert(sizeof(WGanSpec) == 0x30, "expected WGanSpec to be size 0x30");

// [Structure] struct WGanMaterialSpec
struct WGanMaterialSpec
{
public:
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag = 0;

	// <uint32_t mPad0, offset 0xc>
	uint32_t mPad0 = 0;

	// <WGanMaterialSpec* mpPrev, offset 0x10>
	WGanMaterialSpec* mpPrev = nullptr;

	// <WGanMaterialSpec* mpNext, offset 0x14>
	WGanMaterialSpec* mpNext = nullptr;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0x18>
	struct WGanFAnmSpec* mpFAnmSpec = nullptr;

	// <struct WGanMaterialLayerSpec* mpTopLayer, offset 0x1c>
	struct WGanMaterialLayerSpec* mpTopLayer = nullptr;

	// <uint32_t mPad1[0x4], offset 0x20>
	uint32_t mPad1[4];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGanMaterialSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGanMaterialSpec& InObject)
	{
		mFlag = InObject.mFlag;
		mPad0 = InObject.mPad0;
		mpPrev = InObject.mpPrev;
		mpNext = InObject.mpNext;
		mpFAnmSpec = InObject.mpFAnmSpec;
		mpTopLayer = InObject.mpTopLayer;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanMaterialSpec>("WGanMaterialSpec")
			.addFunction("__tostring", &WGanMaterialSpec::ToString)
			.addFunction("GetPtrAddr", &WGanMaterialSpec::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGanMaterialSpec::mIDStr)
			.addProperty("mFlag", &WGanMaterialSpec::mFlag)
			.addProperty("mPad0", &WGanMaterialSpec::mPad0)
			.addProperty("mpPrev", &WGanMaterialSpec::mpPrev)
			.addProperty("mpNext", &WGanMaterialSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanMaterialSpec::mpFAnmSpec)
			.addProperty("mpTopLayer", &WGanMaterialSpec::mpTopLayer)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanMaterialSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanMaterialSpec::mIDStr) == 8, "expected WGanMaterialSpec::mIDStr to be size 8");
static_assert(sizeof(WGanMaterialSpec::mFlag) == 4, "expected WGanMaterialSpec::mFlag to be size 4");
static_assert(sizeof(WGanMaterialSpec::mPad0) == 4, "expected WGanMaterialSpec::mPad0 to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpPrev) == 4, "expected WGanMaterialSpec::mpPrev to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpNext) == 4, "expected WGanMaterialSpec::mpNext to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpFAnmSpec) == 4, "expected WGanMaterialSpec::mpFAnmSpec to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpTopLayer) == 4, "expected WGanMaterialSpec::mpTopLayer to be size 4");
static_assert(sizeof(WGanMaterialSpec::mPad1) == 16, "expected WGanMaterialSpec::mPad1 to be size 16");
static_assert(sizeof(WGanMaterialSpec) == 0x30, "expected WGanMaterialSpec to be size 0x30");

// [Structure] struct WGanFAnmSpec
struct WGanFAnmSpec
{
public:
	/// Struct member variables

	// <uint16_t mFlag, offset 0x0>
	uint16_t mFlag = 0;

	// <uint16_t mTFlag, offset 0x2>
	uint16_t mTFlag = 0;

	// <uint32_t mStartTick, offset 0x4>
	uint32_t mStartTick = 0;

	// <uint32_t mEndTick, offset 0x8>
	uint32_t mEndTick = 0;

	// <uint32_t mHeaderCount, offset 0xc>
	uint32_t mHeaderCount = 0;

	// <uint32_t mPad[0x3], offset 0x10>
	uint32_t mPad[3];

	// <struct _WFAnmObjHeader** mppHeader, offset 0x1c>
	struct _WFAnmObjHeader** mppHeader = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGanFAnmSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGanFAnmSpec& InObject)
	{
		mFlag = InObject.mFlag;
		mTFlag = InObject.mTFlag;
		mStartTick = InObject.mStartTick;
		mEndTick = InObject.mEndTick;
		mHeaderCount = InObject.mHeaderCount;
		mppHeader = InObject.mppHeader;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanFAnmSpec>("WGanFAnmSpec")
			.addFunction("__tostring", &WGanFAnmSpec::ToString)
			.addFunction("GetPtrAddr", &WGanFAnmSpec::GetPtrAddr)
			.addProperty("mFlag", &WGanFAnmSpec::mFlag)
			.addProperty("mTFlag", &WGanFAnmSpec::mTFlag)
			.addProperty("mStartTick", &WGanFAnmSpec::mStartTick)
			.addProperty("mEndTick", &WGanFAnmSpec::mEndTick)
			.addProperty("mHeaderCount", &WGanFAnmSpec::mHeaderCount)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGanFAnmSpec::mPad)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppHeader", &WGanFAnmSpec::mppHeader)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanFAnmSpec::mFlag) == 2, "expected WGanFAnmSpec::mFlag to be size 2");
static_assert(sizeof(WGanFAnmSpec::mTFlag) == 2, "expected WGanFAnmSpec::mTFlag to be size 2");
static_assert(sizeof(WGanFAnmSpec::mStartTick) == 4, "expected WGanFAnmSpec::mStartTick to be size 4");
static_assert(sizeof(WGanFAnmSpec::mEndTick) == 4, "expected WGanFAnmSpec::mEndTick to be size 4");
static_assert(sizeof(WGanFAnmSpec::mHeaderCount) == 4, "expected WGanFAnmSpec::mHeaderCount to be size 4");
static_assert(sizeof(WGanFAnmSpec::mPad) == 12, "expected WGanFAnmSpec::mPad to be size 12");
static_assert(sizeof(WGanFAnmSpec::mppHeader) == 4, "expected WGanFAnmSpec::mppHeader to be size 4");
static_assert(sizeof(WGanFAnmSpec) == 0x20, "expected WGanFAnmSpec to be size 0x20");

// [Structure] struct _WFAnmObjHeader
struct _WFAnmObjHeader
{
public:
	/// Struct member variables

	// <uint16_t mKeyListCount, offset 0x0>
	uint16_t mKeyListCount = 0;

	// <uint16_t mType, offset 0x2>
	uint16_t mType = 0;

	// <uint32_t mPad, offset 0x4>
	uint32_t mPad = 0;

	// <struct _WFAnmObjKeyListHeader* mpListHeader[0x1], offset 0x8>
	struct _WFAnmObjKeyListHeader* mpListHeader[1];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct _WFAnmObjHeader [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(_WFAnmObjHeader& InObject)
	{
		mKeyListCount = InObject.mKeyListCount;
		mType = InObject.mType;
		mPad = InObject.mPad;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmObjHeader>("_WFAnmObjHeader")
			.addFunction("__tostring", &_WFAnmObjHeader::ToString)
			.addFunction("GetPtrAddr", &_WFAnmObjHeader::GetPtrAddr)
			.addProperty("mKeyListCount", &_WFAnmObjHeader::mKeyListCount)
			.addProperty("mType", &_WFAnmObjHeader::mType)
			.addProperty("mPad", &_WFAnmObjHeader::mPad)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpListHeader", &_WFAnmObjHeader::mpListHeader)
		.endClass();
	}
#endif
};
static_assert(sizeof(_WFAnmObjHeader::mKeyListCount) == 2, "expected _WFAnmObjHeader::mKeyListCount to be size 2");
static_assert(sizeof(_WFAnmObjHeader::mType) == 2, "expected _WFAnmObjHeader::mType to be size 2");
static_assert(sizeof(_WFAnmObjHeader::mPad) == 4, "expected _WFAnmObjHeader::mPad to be size 4");
static_assert(sizeof(_WFAnmObjHeader::mpListHeader) == 4, "expected _WFAnmObjHeader::mpListHeader to be size 4");
static_assert(sizeof(_WFAnmObjHeader) == 0xc, "expected _WFAnmObjHeader to be size 0xc");

// [Structure] struct _WFAnmObjKeyListHeader
struct _WFAnmObjKeyListHeader
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[20];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct _WFAnmObjKeyListHeader [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(_WFAnmObjKeyListHeader& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmObjKeyListHeader>("_WFAnmObjKeyListHeader")
			.addFunction("__tostring", &_WFAnmObjKeyListHeader::ToString)
			.addFunction("GetPtrAddr", &_WFAnmObjKeyListHeader::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(_WFAnmObjKeyListHeader) == 0x14, "expected _WFAnmObjKeyListHeader to be size 0x14");

// [Structure] struct WGanMaterialLayerSpec
struct WGanMaterialLayerSpec
{
public:
	/// Struct member variables

	// <uint32_t mFlag, offset 0x0>
	uint32_t mFlag = 0;

	// <WGanMaterialLayerSpec* mpPrev, offset 0x4>
	WGanMaterialLayerSpec* mpPrev = nullptr;

	// <WGanMaterialLayerSpec* mpNext, offset 0x8>
	WGanMaterialLayerSpec* mpNext = nullptr;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0xc>
	struct WGanFAnmSpec* mpFAnmSpec = nullptr;

	// <uint32_t mPad[0x4], offset 0x10>
	uint32_t mPad[4];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGanMaterialLayerSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGanMaterialLayerSpec& InObject)
	{
		mFlag = InObject.mFlag;
		mpPrev = InObject.mpPrev;
		mpNext = InObject.mpNext;
		mpFAnmSpec = InObject.mpFAnmSpec;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanMaterialLayerSpec>("WGanMaterialLayerSpec")
			.addFunction("__tostring", &WGanMaterialLayerSpec::ToString)
			.addFunction("GetPtrAddr", &WGanMaterialLayerSpec::GetPtrAddr)
			.addProperty("mFlag", &WGanMaterialLayerSpec::mFlag)
			.addProperty("mpPrev", &WGanMaterialLayerSpec::mpPrev)
			.addProperty("mpNext", &WGanMaterialLayerSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanMaterialLayerSpec::mpFAnmSpec)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGanMaterialLayerSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanMaterialLayerSpec::mFlag) == 4, "expected WGanMaterialLayerSpec::mFlag to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpPrev) == 4, "expected WGanMaterialLayerSpec::mpPrev to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpNext) == 4, "expected WGanMaterialLayerSpec::mpNext to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpFAnmSpec) == 4, "expected WGanMaterialLayerSpec::mpFAnmSpec to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mPad) == 16, "expected WGanMaterialLayerSpec::mPad to be size 16");
static_assert(sizeof(WGanMaterialLayerSpec) == 0x20, "expected WGanMaterialLayerSpec to be size 0x20");

// [Structure] struct WGanNodeSpec
struct WGanNodeSpec
{
public:
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag = 0;

	// <uint32_t mPad0, offset 0xc>
	uint32_t mPad0 = 0;

	// <WGanNodeSpec* mpParent, offset 0x10>
	WGanNodeSpec* mpParent = nullptr;

	// <WGanNodeSpec* mpChild, offset 0x14>
	WGanNodeSpec* mpChild = nullptr;

	// <WGanNodeSpec* mpPrev, offset 0x18>
	WGanNodeSpec* mpPrev = nullptr;

	// <WGanNodeSpec* mpNext, offset 0x1c>
	WGanNodeSpec* mpNext = nullptr;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0x20>
	struct WGanFAnmSpec* mpFAnmSpec = nullptr;

	// <uint32_t mPad1[0x3], offset 0x24>
	uint32_t mPad1[3];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGanNodeSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGanNodeSpec& InObject)
	{
		mFlag = InObject.mFlag;
		mPad0 = InObject.mPad0;
		mpParent = InObject.mpParent;
		mpChild = InObject.mpChild;
		mpPrev = InObject.mpPrev;
		mpNext = InObject.mpNext;
		mpFAnmSpec = InObject.mpFAnmSpec;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanNodeSpec>("WGanNodeSpec")
			.addFunction("__tostring", &WGanNodeSpec::ToString)
			.addFunction("GetPtrAddr", &WGanNodeSpec::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGanNodeSpec::mIDStr)
			.addProperty("mFlag", &WGanNodeSpec::mFlag)
			.addProperty("mPad0", &WGanNodeSpec::mPad0)
			.addProperty("mpParent", &WGanNodeSpec::mpParent)
			.addProperty("mpChild", &WGanNodeSpec::mpChild)
			.addProperty("mpPrev", &WGanNodeSpec::mpPrev)
			.addProperty("mpNext", &WGanNodeSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanNodeSpec::mpFAnmSpec)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanNodeSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanNodeSpec::mIDStr) == 8, "expected WGanNodeSpec::mIDStr to be size 8");
static_assert(sizeof(WGanNodeSpec::mFlag) == 4, "expected WGanNodeSpec::mFlag to be size 4");
static_assert(sizeof(WGanNodeSpec::mPad0) == 4, "expected WGanNodeSpec::mPad0 to be size 4");
static_assert(sizeof(WGanNodeSpec::mpParent) == 4, "expected WGanNodeSpec::mpParent to be size 4");
static_assert(sizeof(WGanNodeSpec::mpChild) == 4, "expected WGanNodeSpec::mpChild to be size 4");
static_assert(sizeof(WGanNodeSpec::mpPrev) == 4, "expected WGanNodeSpec::mpPrev to be size 4");
static_assert(sizeof(WGanNodeSpec::mpNext) == 4, "expected WGanNodeSpec::mpNext to be size 4");
static_assert(sizeof(WGanNodeSpec::mpFAnmSpec) == 4, "expected WGanNodeSpec::mpFAnmSpec to be size 4");
static_assert(sizeof(WGanNodeSpec::mPad1) == 12, "expected WGanNodeSpec::mPad1 to be size 12");
static_assert(sizeof(WGanNodeSpec) == 0x30, "expected WGanNodeSpec to be size 0x30");

// [Structure] class TGanPlayNode
class TGanPlayNode
{
public:
	// [Structure] struct TGanPlayNode::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <uint8_t ValidAnm, offset 0x0>
		uint8_t ValidAnm = 0;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData_1[3];

	public:
		// <class TFAnm* pAnm, offset 0x4>
		class TFAnm* pAnm = nullptr;

		// <struct WGanNodeSpec* pSpec, offset 0x8>
		struct WGanNodeSpec* pSpec = nullptr;

		// <class TGanPlay* pGanPlay, offset 0xc>
		class TGanPlay* pGanPlay = nullptr;

		// <class TGanPlayNode* pNext, offset 0x10>
		class TGanPlayNode* pNext = nullptr;

		// <class TGanPlayNode* pPrev, offset 0x14>
		class TGanPlayNode* pPrev = nullptr;

		// <class TGanPlayNode* pChild, offset 0x18>
		class TGanPlayNode* pChild = nullptr;

		// <class TGanPlayNode* pParent, offset 0x1c>
		class TGanPlayNode* pParent = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TGanPlayNode::MAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TGanPlayNode::MAIN& InObject)
		{
			ValidAnm = InObject.ValidAnm;
			pAnm = InObject.pAnm;
			pSpec = InObject.pSpec;
			pGanPlay = InObject.pGanPlay;
			pNext = InObject.pNext;
			pPrev = InObject.pPrev;
			pChild = InObject.pChild;
			pParent = InObject.pParent;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MAIN>("TGanPlayNode_MAIN")
				.addFunction("__tostring", &TGanPlayNode::MAIN::ToString)
				.addFunction("GetPtrAddr", &TGanPlayNode::MAIN::GetPtrAddr)
				.addProperty("ValidAnm", &TGanPlayNode::MAIN::ValidAnm)
				.addProperty("pAnm", &TGanPlayNode::MAIN::pAnm)
				.addProperty("pSpec", &TGanPlayNode::MAIN::pSpec)
				.addProperty("pGanPlay", &TGanPlayNode::MAIN::pGanPlay)
				.addProperty("pNext", &TGanPlayNode::MAIN::pNext)
				.addProperty("pPrev", &TGanPlayNode::MAIN::pPrev)
				.addProperty("pChild", &TGanPlayNode::MAIN::pChild)
				.addProperty("pParent", &TGanPlayNode::MAIN::pParent)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGanPlayNode::MAIN::ValidAnm) == 1, "expected TGanPlayNode::MAIN::ValidAnm to be size 1");
	static_assert(sizeof(TGanPlayNode::MAIN::pAnm) == 4, "expected TGanPlayNode::MAIN::pAnm to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pSpec) == 4, "expected TGanPlayNode::MAIN::pSpec to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pGanPlay) == 4, "expected TGanPlayNode::MAIN::pGanPlay to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pNext) == 4, "expected TGanPlayNode::MAIN::pNext to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pPrev) == 4, "expected TGanPlayNode::MAIN::pPrev to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pChild) == 4, "expected TGanPlayNode::MAIN::pChild to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pParent) == 4, "expected TGanPlayNode::MAIN::pParent to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN) == 0x20, "expected TGanPlayNode::MAIN to be size 0x20");

	/// Struct member variables

	// <struct TGanPlayNode::MAIN dat, offset 0x0>
	struct TGanPlayNode::MAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class TGanPlayNode [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TGanPlayNode& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGanPlayNode>("TGanPlayNode")
			.addFunction("__tostring", &TGanPlayNode::ToString)
			.addFunction("GetPtrAddr", &TGanPlayNode::GetPtrAddr)
			.addProperty("dat", &TGanPlayNode::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGanPlayNode::dat) == 32, "expected TGanPlayNode::dat to be size 32");
static_assert(sizeof(TGanPlayNode) == 0x20, "expected TGanPlayNode to be size 0x20");

// [Structure] class TFAnm
class TFAnm
{
public:
	// [Structure] struct TFAnm::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <class TGmfNode* pGmfNode, offset 0x0>
		class TGmfNode* pGmfNode = nullptr;

		// <class TFAnmObjF32_3* pAnmObj3, offset 0x4>
		class TFAnmObjF32_3* pAnmObj3 = nullptr;

		// <int32_t AnmObj3Num, offset 0x8>
		int32_t AnmObj3Num = 0;

		// <class TFAnmObj* pAnmObj, offset 0xc>
		class TFAnmObj* pAnmObj = nullptr;

		// <int32_t AnmObjNum, offset 0x10>
		int32_t AnmObjNum = 0;

		// <float Rate, offset 0x14>
		float Rate = 0;

		// <uint32_t Flag, offset 0x18>
		uint32_t Flag = 0;

		// <float PlayTick, offset 0x1c>
		float PlayTick = 0;

		// <float StartTick, offset 0x20>
		float StartTick = 0;

		// <float EndTick, offset 0x24>
		float EndTick = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TFAnm::tagMAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TFAnm::tagMAIN& InObject)
		{
			pGmfNode = InObject.pGmfNode;
			pAnmObj3 = InObject.pAnmObj3;
			AnmObj3Num = InObject.AnmObj3Num;
			pAnmObj = InObject.pAnmObj;
			AnmObjNum = InObject.AnmObjNum;
			Rate = InObject.Rate;
			Flag = InObject.Flag;
			PlayTick = InObject.PlayTick;
			StartTick = InObject.StartTick;
			EndTick = InObject.EndTick;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<tagMAIN>("TFAnm_tagMAIN")
				.addFunction("__tostring", &TFAnm::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TFAnm::tagMAIN::GetPtrAddr)
				.addProperty("pGmfNode", &TFAnm::tagMAIN::pGmfNode)
				.addProperty("pAnmObj3", &TFAnm::tagMAIN::pAnmObj3)
				.addProperty("AnmObj3Num", &TFAnm::tagMAIN::AnmObj3Num)
				.addProperty("pAnmObj", &TFAnm::tagMAIN::pAnmObj)
				.addProperty("AnmObjNum", &TFAnm::tagMAIN::AnmObjNum)
				.addProperty("Rate", &TFAnm::tagMAIN::Rate)
				.addProperty("Flag", &TFAnm::tagMAIN::Flag)
				.addProperty("PlayTick", &TFAnm::tagMAIN::PlayTick)
				.addProperty("StartTick", &TFAnm::tagMAIN::StartTick)
				.addProperty("EndTick", &TFAnm::tagMAIN::EndTick)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnm::tagMAIN::pGmfNode) == 4, "expected TFAnm::tagMAIN::pGmfNode to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::pAnmObj3) == 4, "expected TFAnm::tagMAIN::pAnmObj3 to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::AnmObj3Num) == 4, "expected TFAnm::tagMAIN::AnmObj3Num to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::pAnmObj) == 4, "expected TFAnm::tagMAIN::pAnmObj to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::AnmObjNum) == 4, "expected TFAnm::tagMAIN::AnmObjNum to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::Rate) == 4, "expected TFAnm::tagMAIN::Rate to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::Flag) == 4, "expected TFAnm::tagMAIN::Flag to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::PlayTick) == 4, "expected TFAnm::tagMAIN::PlayTick to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::StartTick) == 4, "expected TFAnm::tagMAIN::StartTick to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::EndTick) == 4, "expected TFAnm::tagMAIN::EndTick to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN) == 0x28, "expected TFAnm::tagMAIN to be size 0x28");

	/// Struct member variables

	// <struct TFAnm::tagMAIN dat, offset 0x0>
	struct TFAnm::tagMAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class TFAnm [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TFAnm& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnm>("TFAnm")
			.addFunction("__tostring", &TFAnm::ToString)
			.addFunction("GetPtrAddr", &TFAnm::GetPtrAddr)
			.addProperty("dat", &TFAnm::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnm::dat) == 40, "expected TFAnm::dat to be size 40");
static_assert(sizeof(TFAnm) == 0x28, "expected TFAnm to be size 0x28");

// [Structure] class TGmfNode
class TGmfNode
{
public:
	// [Structure] struct TGmfNode::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData_0[32];

	public:
		// <class TGmfNode* AttachModel, offset 0x20>
		class TGmfNode* AttachModel = nullptr;

		// <Unidentified data segment, offset 0x24>
	private:
		char _UnidentifiedData_36[4];

	public:
		// <class TGmfNode* NodeChain, offset 0x28>
		class TGmfNode* NodeChain = nullptr;

		// <Unidentified data segment, offset 0x2c>
	private:
		char _UnidentifiedData_44[200];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TGmfNode::tagMAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TGmfNode::tagMAIN& InObject)
		{
			AttachModel = InObject.AttachModel;
			NodeChain = InObject.NodeChain;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<tagMAIN>("TGmfNode_tagMAIN")
				.addFunction("__tostring", &TGmfNode::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TGmfNode::tagMAIN::GetPtrAddr)
				.addProperty("AttachModel", &TGmfNode::tagMAIN::AttachModel)
				.addProperty("NodeChain", &TGmfNode::tagMAIN::NodeChain)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGmfNode::tagMAIN::AttachModel) == 4, "expected TGmfNode::tagMAIN::AttachModel to be size 4");
	static_assert(sizeof(TGmfNode::tagMAIN::NodeChain) == 4, "expected TGmfNode::tagMAIN::NodeChain to be size 4");
	static_assert(sizeof(TGmfNode::tagMAIN) == 0xf4, "expected TGmfNode::tagMAIN to be size 0xf4");

	/// Struct member variables

	// <struct TGmfNode::tagMAIN dat, offset 0x0>
	struct TGmfNode::tagMAIN dat;

	// <uint8_t m_bIsAlwaysSetupMatrix, offset 0xf4>
	uint8_t m_bIsAlwaysSetupMatrix = 0;

	// <Unidentified data segment, offset 0xf5>
private:
	char _UnidentifiedData_245[3];

public:
	// <int32_t m_nPolyNum, offset 0xf8>
	int32_t m_nPolyNum = 0;

	// <float m_inLocalMat[0x3][0x4], offset 0xfc>
	float m_inLocalMat[3][4];

	// <class CViewClipObjSphere* m_pViewClipObjSphere, offset 0x12c>
	class CViewClipObjSphere* m_pViewClipObjSphere = nullptr;

	// <class CViewClipObjBox* m_pViewClipObjBox, offset 0x130>
	class CViewClipObjBox* m_pViewClipObjBox = nullptr;

	// <float m_fClipDistSqu, offset 0x134>
	float m_fClipDistSqu = 0;

	// <float m_inPreWorldMatMtx[0x3][0x4], offset 0x138>
	float m_inPreWorldMatMtx[3][4];

	// <class EfDestortion* mpDestortion, offset 0x168>
	class EfDestortion* mpDestortion = nullptr;

	// <class CVertexAnimation* m_pVertexAnime, offset 0x16c>
	class CVertexAnimation* m_pVertexAnime = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class TGmfNode [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TGmfNode& InObject)
	{
		dat = InObject.dat;
		m_bIsAlwaysSetupMatrix = InObject.m_bIsAlwaysSetupMatrix;
		m_nPolyNum = InObject.m_nPolyNum;
		m_pViewClipObjSphere = InObject.m_pViewClipObjSphere;
		m_pViewClipObjBox = InObject.m_pViewClipObjBox;
		m_fClipDistSqu = InObject.m_fClipDistSqu;
		mpDestortion = InObject.mpDestortion;
		m_pVertexAnime = InObject.m_pVertexAnime;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGmfNode>("TGmfNode")
			.addFunction("__tostring", &TGmfNode::ToString)
			.addFunction("GetPtrAddr", &TGmfNode::GetPtrAddr)
			.addProperty("dat", &TGmfNode::dat)
			.addProperty("m_bIsAlwaysSetupMatrix", &TGmfNode::m_bIsAlwaysSetupMatrix)
			.addProperty("m_nPolyNum", &TGmfNode::m_nPolyNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_inLocalMat", &TGmfNode::m_inLocalMat)
			.addProperty("m_pViewClipObjSphere", &TGmfNode::m_pViewClipObjSphere)
			.addProperty("m_pViewClipObjBox", &TGmfNode::m_pViewClipObjBox)
			.addProperty("m_fClipDistSqu", &TGmfNode::m_fClipDistSqu)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_inPreWorldMatMtx", &TGmfNode::m_inPreWorldMatMtx)
			.addProperty("mpDestortion", &TGmfNode::mpDestortion)
			.addProperty("m_pVertexAnime", &TGmfNode::m_pVertexAnime)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGmfNode::dat) == 244, "expected TGmfNode::dat to be size 244");
static_assert(sizeof(TGmfNode::m_bIsAlwaysSetupMatrix) == 1, "expected TGmfNode::m_bIsAlwaysSetupMatrix to be size 1");
static_assert(sizeof(TGmfNode::m_nPolyNum) == 4, "expected TGmfNode::m_nPolyNum to be size 4");
static_assert(sizeof(TGmfNode::m_inLocalMat) == 48, "expected TGmfNode::m_inLocalMat to be size 48");
static_assert(sizeof(TGmfNode::m_pViewClipObjSphere) == 4, "expected TGmfNode::m_pViewClipObjSphere to be size 4");
static_assert(sizeof(TGmfNode::m_pViewClipObjBox) == 4, "expected TGmfNode::m_pViewClipObjBox to be size 4");
static_assert(sizeof(TGmfNode::m_fClipDistSqu) == 4, "expected TGmfNode::m_fClipDistSqu to be size 4");
static_assert(sizeof(TGmfNode::m_inPreWorldMatMtx) == 48, "expected TGmfNode::m_inPreWorldMatMtx to be size 48");
static_assert(sizeof(TGmfNode::mpDestortion) == 4, "expected TGmfNode::mpDestortion to be size 4");
static_assert(sizeof(TGmfNode::m_pVertexAnime) == 4, "expected TGmfNode::m_pVertexAnime to be size 4");
static_assert(sizeof(TGmfNode) == 0x170, "expected TGmfNode to be size 0x170");

// [Structure] class CViewClipObjSphere
class CViewClipObjSphere
{
public:
	/// Struct member variables

	// <class tiVector m_inPosi, offset 0x0>
	class tiVector m_inPosi;

	// <float m_fRadius, offset 0x10>
	float m_fRadius = 0;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData_20[12];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CViewClipObjSphere [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CViewClipObjSphere& InObject)
	{
		m_inPosi = InObject.m_inPosi;
		m_fRadius = InObject.m_fRadius;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CViewClipObjSphere>("CViewClipObjSphere")
			.addFunction("__tostring", &CViewClipObjSphere::ToString)
			.addFunction("GetPtrAddr", &CViewClipObjSphere::GetPtrAddr)
			.addProperty("m_inPosi", &CViewClipObjSphere::m_inPosi)
			.addProperty("m_fRadius", &CViewClipObjSphere::m_fRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(CViewClipObjSphere::m_inPosi) == 16, "expected CViewClipObjSphere::m_inPosi to be size 16");
static_assert(sizeof(CViewClipObjSphere::m_fRadius) == 4, "expected CViewClipObjSphere::m_fRadius to be size 4");
static_assert(sizeof(CViewClipObjSphere) == 0x20, "expected CViewClipObjSphere to be size 0x20");

// [Structure] class CViewClipObjBox
class CViewClipObjBox
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[64];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CViewClipObjBox [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CViewClipObjBox& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CViewClipObjBox>("CViewClipObjBox")
			.addFunction("__tostring", &CViewClipObjBox::ToString)
			.addFunction("GetPtrAddr", &CViewClipObjBox::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CViewClipObjBox) == 0x40, "expected CViewClipObjBox to be size 0x40");

// enum GHMR_PRIMTYPE
enum GHMR_PRIMTYPE : uint32_t
{
	// <GHMR_PRIMTYPE_POINTLIST = 0x0>
	GHMR_PRIMTYPE_POINTLIST = 0,

	// <GHMR_PRIMTYPE_LINELIST = 0x1>
	GHMR_PRIMTYPE_LINELIST = 1,

	// <GHMR_PRIMTYPE_LINESTRIP = 0x2>
	GHMR_PRIMTYPE_LINESTRIP = 2,

	// <GHMR_PRIMTYPE_TRIANGLELIST = 0x3>
	GHMR_PRIMTYPE_TRIANGLELIST = 3,

	// <GHMR_PRIMTYPE_TRIANGLESTRIP = 0x4>
	GHMR_PRIMTYPE_TRIANGLESTRIP = 4,

	// <GHMR_PRIMTYPE_TRIANGLEFAN = 0x5>
	GHMR_PRIMTYPE_TRIANGLEFAN = 5,

	// <GHMR_PRIMTYPE_QUADLIST = 0x6>
	GHMR_PRIMTYPE_QUADLIST = 6

};

// enum GHMR_PROJECT
enum GHMR_PROJECT : uint32_t
{
	// <GHMR_PROJECT_PERS = 0x0>
	GHMR_PROJECT_PERS = 0,

	// <GHMR_PROJECT_ORTHO = 0x1>
	GHMR_PROJECT_ORTHO = 1,

	// <GHMR_PROJECT_NUM = 0x2>
	GHMR_PROJECT_NUM = 2

};

// [Structure] class rPrimUnific
class rPrimUnific
{
public:
	/// Struct member variables

	// <class rPrimBase* m_pListTop, offset 0x0>
	class rPrimBase* m_pListTop = nullptr;

	// <class rPrimBase* m_pListEnd, offset 0x4>
	class rPrimBase* m_pListEnd = nullptr;

	// <enum GHMR_PROJECT m_ProjectMode, offset 0x8>
	enum GHMR_PROJECT m_ProjectMode;

	// <enum GHMR_PRIMTYPE m_PrimType, offset 0xc>
	enum GHMR_PRIMTYPE m_PrimType;

	// <uint32_t m_PrimNum, offset 0x10>
	uint32_t m_PrimNum = 0;

	// <struct tagGHMR_TEX* m_pTex, offset 0x14>
	struct tagGHMR_TEX* m_pTex = nullptr;

	// <struct tagGHMR_TEX* m_pMultiTex, offset 0x18>
	struct tagGHMR_TEX* m_pMultiTex = nullptr;

	// <uint32_t m_BitFlag, offset 0x1c>
	uint32_t m_BitFlag = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rPrimUnific [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rPrimUnific& InObject)
	{
		m_pListTop = InObject.m_pListTop;
		m_pListEnd = InObject.m_pListEnd;
		m_ProjectMode = InObject.m_ProjectMode;
		m_PrimType = InObject.m_PrimType;
		m_PrimNum = InObject.m_PrimNum;
		m_pTex = InObject.m_pTex;
		m_pMultiTex = InObject.m_pMultiTex;
		m_BitFlag = InObject.m_BitFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rPrimUnific>("rPrimUnific")
			.addFunction("__tostring", &rPrimUnific::ToString)
			.addFunction("GetPtrAddr", &rPrimUnific::GetPtrAddr)
			.addProperty("m_pListTop", &rPrimUnific::m_pListTop)
			.addProperty("m_pListEnd", &rPrimUnific::m_pListEnd)
			.addProperty("m_ProjectMode", &rPrimUnific::m_ProjectMode)
			.addProperty("m_PrimType", &rPrimUnific::m_PrimType)
			.addProperty("m_PrimNum", &rPrimUnific::m_PrimNum)
			.addProperty("m_pTex", &rPrimUnific::m_pTex)
			.addProperty("m_pMultiTex", &rPrimUnific::m_pMultiTex)
			.addProperty("m_BitFlag", &rPrimUnific::m_BitFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(rPrimUnific::m_pListTop) == 4, "expected rPrimUnific::m_pListTop to be size 4");
static_assert(sizeof(rPrimUnific::m_pListEnd) == 4, "expected rPrimUnific::m_pListEnd to be size 4");
static_assert(sizeof(rPrimUnific::m_ProjectMode) == 4, "expected rPrimUnific::m_ProjectMode to be size 4");
static_assert(sizeof(rPrimUnific::m_PrimType) == 4, "expected rPrimUnific::m_PrimType to be size 4");
static_assert(sizeof(rPrimUnific::m_PrimNum) == 4, "expected rPrimUnific::m_PrimNum to be size 4");
static_assert(sizeof(rPrimUnific::m_pTex) == 4, "expected rPrimUnific::m_pTex to be size 4");
static_assert(sizeof(rPrimUnific::m_pMultiTex) == 4, "expected rPrimUnific::m_pMultiTex to be size 4");
static_assert(sizeof(rPrimUnific::m_BitFlag) == 4, "expected rPrimUnific::m_BitFlag to be size 4");
static_assert(sizeof(rPrimUnific) == 0x20, "expected rPrimUnific to be size 0x20");

// [Structure] class EfDestortion
class EfDestortion : public HrTask
{
public:
	// enum EfDestortion::UV_Type
	enum UV_Type : uint32_t
	{
		// <UV_Sin = 0x1>
		UV_Sin = 1,

		// <UV_Rand = 0x2>
		UV_Rand = 2

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <class TGmfNode* mpNode, offset 0x68>
	class TGmfNode* mpNode = nullptr;

	// <struct TGMFMESH** mppMeshList, offset 0x6c>
	struct TGMFMESH** mppMeshList = nullptr;

	// <uint32_t mTriangleNum, offset 0x70>
	uint32_t mTriangleNum = 0;

	// <float mScreenWidthInv, offset 0x74>
	float mScreenWidthInv = 0;

	// <float mAmplitude, offset 0x78>
	float mAmplitude = 0;

	// <enum EfDestortion::UV_Type mType, offset 0x7c>
	enum EfDestortion::UV_Type mType;

	// <uint8_t* mpRandIdxAry, offset 0x80>
	uint8_t* mpRandIdxAry = nullptr;

	// <class rTriangleList* mpTriangleAry, offset 0x84>
	class rTriangleList* mpTriangleAry = nullptr;

	// <class rPrimUnific mTriangleUni, offset 0x88>
	class rPrimUnific mTriangleUni;

	// <uint8_t mbRenderWait, offset 0xa8>
	uint8_t mbRenderWait = 0;

	// <Unidentified data segment, offset 0xa9>
private:
	char _UnidentifiedData_169[3];

public:
	// <float mSinCnt[0x64], offset 0xac>
	float mSinCnt[100];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfDestortion [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfDestortion& InObject)
	{
		field_50 = InObject.field_50;
		mpNode = InObject.mpNode;
		mppMeshList = InObject.mppMeshList;
		mTriangleNum = InObject.mTriangleNum;
		mScreenWidthInv = InObject.mScreenWidthInv;
		mAmplitude = InObject.mAmplitude;
		mType = InObject.mType;
		mpRandIdxAry = InObject.mpRandIdxAry;
		mpTriangleAry = InObject.mpTriangleAry;
		mTriangleUni = InObject.mTriangleUni;
		mbRenderWait = InObject.mbRenderWait;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfDestortion, HrTask>("EfDestortion")
			.addFunction("__tostring", &EfDestortion::ToString)
			.addFunction("GetPtrAddr", &EfDestortion::GetPtrAddr)
			.addProperty("field_50", &EfDestortion::field_50)
			.addProperty("mpNode", &EfDestortion::mpNode)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppMeshList", &EfDestortion::mppMeshList)
			.addProperty("mTriangleNum", &EfDestortion::mTriangleNum)
			.addProperty("mScreenWidthInv", &EfDestortion::mScreenWidthInv)
			.addProperty("mAmplitude", &EfDestortion::mAmplitude)
			.addProperty("mType", &EfDestortion::mType)
			// native pointer type (uint8_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpRandIdxAry", &EfDestortion::mpRandIdxAry)
			.addProperty("mpTriangleAry", &EfDestortion::mpTriangleAry)
			.addProperty("mTriangleUni", &EfDestortion::mTriangleUni)
			.addProperty("mbRenderWait", &EfDestortion::mbRenderWait)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mSinCnt", &EfDestortion::mSinCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfDestortion::field_50) == 24, "expected EfDestortion::field_50 to be size 24");
static_assert(sizeof(EfDestortion::mpNode) == 4, "expected EfDestortion::mpNode to be size 4");
static_assert(sizeof(EfDestortion::mppMeshList) == 4, "expected EfDestortion::mppMeshList to be size 4");
static_assert(sizeof(EfDestortion::mTriangleNum) == 4, "expected EfDestortion::mTriangleNum to be size 4");
static_assert(sizeof(EfDestortion::mScreenWidthInv) == 4, "expected EfDestortion::mScreenWidthInv to be size 4");
static_assert(sizeof(EfDestortion::mAmplitude) == 4, "expected EfDestortion::mAmplitude to be size 4");
static_assert(sizeof(EfDestortion::mType) == 4, "expected EfDestortion::mType to be size 4");
static_assert(sizeof(EfDestortion::mpRandIdxAry) == 4, "expected EfDestortion::mpRandIdxAry to be size 4");
static_assert(sizeof(EfDestortion::mpTriangleAry) == 4, "expected EfDestortion::mpTriangleAry to be size 4");
static_assert(sizeof(EfDestortion::mTriangleUni) == 32, "expected EfDestortion::mTriangleUni to be size 32");
static_assert(sizeof(EfDestortion::mbRenderWait) == 1, "expected EfDestortion::mbRenderWait to be size 1");
static_assert(sizeof(EfDestortion::mSinCnt) == 400, "expected EfDestortion::mSinCnt to be size 400");
static_assert(sizeof(EfDestortion) == 0x23c, "expected EfDestortion to be size 0x23c");

// [Structure] struct TGMFMESH
struct TGMFMESH
{
public:
	/// Struct member variables

	// <class TGmfNode* pNode, offset 0x0>
	class TGmfNode* pNode = nullptr;

	// <struct tagGHMR_TEX* pTex, offset 0x4>
	struct tagGHMR_TEX* pTex = nullptr;

	// <int32_t VertexNum, offset 0x8>
	int32_t VertexNum = 0;

	// <int32_t PolyNum, offset 0xc>
	int32_t PolyNum = 0;

	// <uint32_t VertexSize, offset 0x10>
	uint32_t VertexSize = 0;

	// <uint32_t TransVertexSize, offset 0x14>
	uint32_t TransVertexSize = 0;

	// <uint8_t HaveNormal, offset 0x18>
	uint8_t HaveNormal = 0;

	// <uint8_t HaveColor, offset 0x19>
	uint8_t HaveColor = 0;

	// <uint8_t HaveUV, offset 0x1a>
	uint8_t HaveUV = 0;

	// <uint8_t Transform, offset 0x1b>
	uint8_t Transform = 0;

	// <float TransMat[0x8][0x3][0x4], offset 0x1c>
	float TransMat[8][3][4];

	// <void* Vertex, offset 0x19c>
	void* Vertex = nullptr;

	// <void* TransVertex, offset 0x1a0>
	void* TransVertex = nullptr;

	// <uint32_t* PolyList, offset 0x1a4>
	uint32_t* PolyList = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct TGMFMESH [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TGMFMESH& InObject)
	{
		pNode = InObject.pNode;
		pTex = InObject.pTex;
		VertexNum = InObject.VertexNum;
		PolyNum = InObject.PolyNum;
		VertexSize = InObject.VertexSize;
		TransVertexSize = InObject.TransVertexSize;
		HaveNormal = InObject.HaveNormal;
		HaveColor = InObject.HaveColor;
		HaveUV = InObject.HaveUV;
		Transform = InObject.Transform;
		Vertex = InObject.Vertex;
		TransVertex = InObject.TransVertex;
		PolyList = InObject.PolyList;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGMFMESH>("TGMFMESH")
			.addFunction("__tostring", &TGMFMESH::ToString)
			.addFunction("GetPtrAddr", &TGMFMESH::GetPtrAddr)
			.addProperty("pNode", &TGMFMESH::pNode)
			.addProperty("pTex", &TGMFMESH::pTex)
			.addProperty("VertexNum", &TGMFMESH::VertexNum)
			.addProperty("PolyNum", &TGMFMESH::PolyNum)
			.addProperty("VertexSize", &TGMFMESH::VertexSize)
			.addProperty("TransVertexSize", &TGMFMESH::TransVertexSize)
			.addProperty("HaveNormal", &TGMFMESH::HaveNormal)
			.addProperty("HaveColor", &TGMFMESH::HaveColor)
			.addProperty("HaveUV", &TGMFMESH::HaveUV)
			.addProperty("Transform", &TGMFMESH::Transform)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("TransMat", &TGMFMESH::TransMat)
			// void type not supported in LuaBridge
			//.addProperty("Vertex", &TGMFMESH::Vertex)
			// void type not supported in LuaBridge
			//.addProperty("TransVertex", &TGMFMESH::TransVertex)
			// native pointer type (uint32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("PolyList", &TGMFMESH::PolyList)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGMFMESH::pNode) == 4, "expected TGMFMESH::pNode to be size 4");
static_assert(sizeof(TGMFMESH::pTex) == 4, "expected TGMFMESH::pTex to be size 4");
static_assert(sizeof(TGMFMESH::VertexNum) == 4, "expected TGMFMESH::VertexNum to be size 4");
static_assert(sizeof(TGMFMESH::PolyNum) == 4, "expected TGMFMESH::PolyNum to be size 4");
static_assert(sizeof(TGMFMESH::VertexSize) == 4, "expected TGMFMESH::VertexSize to be size 4");
static_assert(sizeof(TGMFMESH::TransVertexSize) == 4, "expected TGMFMESH::TransVertexSize to be size 4");
static_assert(sizeof(TGMFMESH::HaveNormal) == 1, "expected TGMFMESH::HaveNormal to be size 1");
static_assert(sizeof(TGMFMESH::HaveColor) == 1, "expected TGMFMESH::HaveColor to be size 1");
static_assert(sizeof(TGMFMESH::HaveUV) == 1, "expected TGMFMESH::HaveUV to be size 1");
static_assert(sizeof(TGMFMESH::Transform) == 1, "expected TGMFMESH::Transform to be size 1");
static_assert(sizeof(TGMFMESH::TransMat) == 384, "expected TGMFMESH::TransMat to be size 384");
static_assert(sizeof(TGMFMESH::Vertex) == 4, "expected TGMFMESH::Vertex to be size 4");
static_assert(sizeof(TGMFMESH::TransVertex) == 4, "expected TGMFMESH::TransVertex to be size 4");
static_assert(sizeof(TGMFMESH::PolyList) == 4, "expected TGMFMESH::PolyList to be size 4");
static_assert(sizeof(TGMFMESH) == 0x1a8, "expected TGMFMESH to be size 0x1a8");

// [Structure] struct rAlphaAnime
struct rAlphaAnime
{
public:
	/// Struct member variables

	// <float Add, offset 0x0>
	float Add = 0;

	// <float Target, offset 0x4>
	float Target = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct rAlphaAnime [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rAlphaAnime& InObject)
	{
		Add = InObject.Add;
		Target = InObject.Target;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rAlphaAnime>("rAlphaAnime")
			.addFunction("__tostring", &rAlphaAnime::ToString)
			.addFunction("GetPtrAddr", &rAlphaAnime::GetPtrAddr)
			.addProperty("Add", &rAlphaAnime::Add)
			.addProperty("Target", &rAlphaAnime::Target)
		.endClass();
	}
#endif
};
static_assert(sizeof(rAlphaAnime::Add) == 4, "expected rAlphaAnime::Add to be size 4");
static_assert(sizeof(rAlphaAnime::Target) == 4, "expected rAlphaAnime::Target to be size 4");
static_assert(sizeof(rAlphaAnime) == 0x8, "expected rAlphaAnime to be size 0x8");

// [Structure] struct rAnimeCounter
struct rAnimeCounter
{
public:
	/// Struct member variables

	// <uint16_t Count, offset 0x0>
	uint16_t Count = 0;

	// <uint16_t Frame, offset 0x2>
	uint16_t Frame = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct rAnimeCounter [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rAnimeCounter& InObject)
	{
		Count = InObject.Count;
		Frame = InObject.Frame;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rAnimeCounter>("rAnimeCounter")
			.addFunction("__tostring", &rAnimeCounter::ToString)
			.addFunction("GetPtrAddr", &rAnimeCounter::GetPtrAddr)
			.addProperty("Count", &rAnimeCounter::Count)
			.addProperty("Frame", &rAnimeCounter::Frame)
		.endClass();
	}
#endif
};
static_assert(sizeof(rAnimeCounter::Count) == 2, "expected rAnimeCounter::Count to be size 2");
static_assert(sizeof(rAnimeCounter::Frame) == 2, "expected rAnimeCounter::Frame to be size 2");
static_assert(sizeof(rAnimeCounter) == 0x4, "expected rAnimeCounter to be size 0x4");

// [Structure] struct rST
struct rST
{
public:
	/// Struct member variables

	// <float s, offset 0x0>
	float s = 0;

	// <float t, offset 0x4>
	float t = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct rST [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rST& InObject)
	{
		s = InObject.s;
		t = InObject.t;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rST>("rST")
			.addFunction("__tostring", &rST::ToString)
			.addFunction("GetPtrAddr", &rST::GetPtrAddr)
			.addProperty("s", &rST::s)
			.addProperty("t", &rST::t)
		.endClass();
	}
#endif
};
static_assert(sizeof(rST::s) == 4, "expected rST::s to be size 4");
static_assert(sizeof(rST::t) == 4, "expected rST::t to be size 4");
static_assert(sizeof(rST) == 0x8, "expected rST to be size 0x8");

// [Structure] struct rColor
struct rColor
{
public:
	/// Struct member variables

	// <float r, offset 0x0>
	float r = 0;

	// <float g, offset 0x4>
	float g = 0;

	// <float b, offset 0x8>
	float b = 0;

	// <float a, offset 0xc>
	float a = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct rColor [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rColor& InObject)
	{
		r = InObject.r;
		g = InObject.g;
		b = InObject.b;
		a = InObject.a;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rColor>("rColor")
			.addFunction("__tostring", &rColor::ToString)
			.addFunction("GetPtrAddr", &rColor::GetPtrAddr)
			.addProperty("r", &rColor::r)
			.addProperty("g", &rColor::g)
			.addProperty("b", &rColor::b)
			.addProperty("a", &rColor::a)
		.endClass();
	}
#endif
};
static_assert(sizeof(rColor::r) == 4, "expected rColor::r to be size 4");
static_assert(sizeof(rColor::g) == 4, "expected rColor::g to be size 4");
static_assert(sizeof(rColor::b) == 4, "expected rColor::b to be size 4");
static_assert(sizeof(rColor::a) == 4, "expected rColor::a to be size 4");
static_assert(sizeof(rColor) == 0x10, "expected rColor to be size 0x10");

// [Structure] class rPrimBase
class rPrimBase
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x3], offset 0x0>
	void* (* field_0)[0x3];

	// <uint32_t m_BitFlag, offset 0x4>
	uint32_t m_BitFlag = 0;

	// <rPrimBase* m_pPrev, offset 0x8>
	rPrimBase* m_pPrev = nullptr;

	// <rPrimBase* m_pNext, offset 0xc>
	rPrimBase* m_pNext = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rPrimBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rPrimBase& InObject)
	{
		m_BitFlag = InObject.m_BitFlag;
		m_pPrev = InObject.m_pPrev;
		m_pNext = InObject.m_pNext;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rPrimBase>("rPrimBase")
			.addFunction("__tostring", &rPrimBase::ToString)
			.addFunction("GetPtrAddr", &rPrimBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &rPrimBase::field_0)
			.addProperty("m_BitFlag", &rPrimBase::m_BitFlag)
			.addProperty("m_pPrev", &rPrimBase::m_pPrev)
			.addProperty("m_pNext", &rPrimBase::m_pNext)
		.endClass();
	}
#endif
};
static_assert(sizeof(rPrimBase::field_0) == 4, "expected rPrimBase::field_0 to be size 4");
static_assert(sizeof(rPrimBase::m_BitFlag) == 4, "expected rPrimBase::m_BitFlag to be size 4");
static_assert(sizeof(rPrimBase::m_pPrev) == 4, "expected rPrimBase::m_pPrev to be size 4");
static_assert(sizeof(rPrimBase::m_pNext) == 4, "expected rPrimBase::m_pNext to be size 4");
static_assert(sizeof(rPrimBase) == 0x10, "expected rPrimBase to be size 0x10");

// [Structure] class rTriangleList
class rTriangleList : public rPrimBase
{
public:
	/// Struct member variables

	// <class rPrimBase field_0, offset 0x0>
	// class rPrimBase Super;

	// <struct Vec m_Position, offset 0x10>
	struct Vec m_Position;

	// <struct rColor m_Color, offset 0x1c>
	struct rColor m_Color;

	// <struct rST m_ST, offset 0x2c>
	struct rST m_ST;

	// <struct rAnimeCounter m_AnimeCounter, offset 0x34>
	struct rAnimeCounter m_AnimeCounter;

	// <struct rAlphaAnime m_ColorAnime, offset 0x38>
	struct rAlphaAnime m_ColorAnime;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rTriangleList [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rTriangleList& InObject)
	{
		m_Position = InObject.m_Position;
		m_Color = InObject.m_Color;
		m_ST = InObject.m_ST;
		m_AnimeCounter = InObject.m_AnimeCounter;
		m_ColorAnime = InObject.m_ColorAnime;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<rTriangleList, rPrimBase>("rTriangleList")
			.addFunction("__tostring", &rTriangleList::ToString)
			.addFunction("GetPtrAddr", &rTriangleList::GetPtrAddr)
			.addProperty("m_Position", &rTriangleList::m_Position)
			.addProperty("m_Color", &rTriangleList::m_Color)
			.addProperty("m_ST", &rTriangleList::m_ST)
			.addProperty("m_AnimeCounter", &rTriangleList::m_AnimeCounter)
			.addProperty("m_ColorAnime", &rTriangleList::m_ColorAnime)
		.endClass();
	}
#endif
};
static_assert(sizeof(rTriangleList::m_Position) == 12, "expected rTriangleList::m_Position to be size 12");
static_assert(sizeof(rTriangleList::m_Color) == 16, "expected rTriangleList::m_Color to be size 16");
static_assert(sizeof(rTriangleList::m_ST) == 8, "expected rTriangleList::m_ST to be size 8");
static_assert(sizeof(rTriangleList::m_AnimeCounter) == 4, "expected rTriangleList::m_AnimeCounter to be size 4");
static_assert(sizeof(rTriangleList::m_ColorAnime) == 8, "expected rTriangleList::m_ColorAnime to be size 8");
static_assert(sizeof(rTriangleList) == 0x40, "expected rTriangleList to be size 0x40");

// [Structure] class CVertexAnimation
class CVertexAnimation
{
public:
	// [Structure] class CVertexAnimation::CVertex
	class CVertex
	{
	public:
		/// Struct member variables

		// <int32_t m_nPosiIndex, offset 0x0>
		int32_t m_nPosiIndex = 0;

		// <float m_fCenter, offset 0x4>
		float m_fCenter = 0;

		// <int32_t m_nSinIndex, offset 0x8>
		int32_t m_nSinIndex = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class CVertexAnimation::CVertex [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(CVertexAnimation::CVertex& InObject)
		{
			m_nPosiIndex = InObject.m_nPosiIndex;
			m_fCenter = InObject.m_fCenter;
			m_nSinIndex = InObject.m_nSinIndex;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CVertex>("CVertexAnimation_CVertex")
				.addFunction("__tostring", &CVertexAnimation::CVertex::ToString)
				.addFunction("GetPtrAddr", &CVertexAnimation::CVertex::GetPtrAddr)
				.addProperty("m_nPosiIndex", &CVertexAnimation::CVertex::m_nPosiIndex)
				.addProperty("m_fCenter", &CVertexAnimation::CVertex::m_fCenter)
				.addProperty("m_nSinIndex", &CVertexAnimation::CVertex::m_nSinIndex)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(CVertexAnimation::CVertex::m_nPosiIndex) == 4, "expected CVertexAnimation::CVertex::m_nPosiIndex to be size 4");
	static_assert(sizeof(CVertexAnimation::CVertex::m_fCenter) == 4, "expected CVertexAnimation::CVertex::m_fCenter to be size 4");
	static_assert(sizeof(CVertexAnimation::CVertex::m_nSinIndex) == 4, "expected CVertexAnimation::CVertex::m_nSinIndex to be size 4");
	static_assert(sizeof(CVertexAnimation::CVertex) == 0xc, "expected CVertexAnimation::CVertex to be size 0xc");

	/// Struct member variables

	// <uint8_t* m_pbyNewMem, offset 0x0>
	uint8_t* m_pbyNewMem = nullptr;

	// <uint8_t* m_abyNodePosiBuf[0x2], offset 0x4>
	uint8_t* m_abyNodePosiBuf[2];

	// <uint32_t m_nBufSize, offset 0xc>
	uint32_t m_nBufSize = 0;

	// <class CStlVector<CVertexAnimation::CVertex> m_ainVertex, offset 0x10>
	class std::vector<CVertexAnimation::CVertex> m_ainVertex;

	// <float m_fOfstMax, offset 0x1c>
	float m_fOfstMax = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CVertexAnimation [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CVertexAnimation& InObject)
	{
		m_pbyNewMem = InObject.m_pbyNewMem;
		m_nBufSize = InObject.m_nBufSize;
		m_ainVertex = InObject.m_ainVertex;
		m_fOfstMax = InObject.m_fOfstMax;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CVertexAnimation>("CVertexAnimation")
			.addFunction("__tostring", &CVertexAnimation::ToString)
			.addFunction("GetPtrAddr", &CVertexAnimation::GetPtrAddr)
			// native pointer type (uint8_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pbyNewMem", &CVertexAnimation::m_pbyNewMem)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_abyNodePosiBuf", &CVertexAnimation::m_abyNodePosiBuf)
			.addProperty("m_nBufSize", &CVertexAnimation::m_nBufSize)
			.addProperty("m_ainVertex", &CVertexAnimation::m_ainVertex)
			.addProperty("m_fOfstMax", &CVertexAnimation::m_fOfstMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(CVertexAnimation::m_pbyNewMem) == 4, "expected CVertexAnimation::m_pbyNewMem to be size 4");
static_assert(sizeof(CVertexAnimation::m_abyNodePosiBuf) == 8, "expected CVertexAnimation::m_abyNodePosiBuf to be size 8");
static_assert(sizeof(CVertexAnimation::m_nBufSize) == 4, "expected CVertexAnimation::m_nBufSize to be size 4");
static_assert(sizeof(CVertexAnimation::m_ainVertex) == 12, "expected CVertexAnimation::m_ainVertex to be size 12");
static_assert(sizeof(CVertexAnimation::m_fOfstMax) == 4, "expected CVertexAnimation::m_fOfstMax to be size 4");
static_assert(sizeof(CVertexAnimation) == 0x20, "expected CVertexAnimation to be size 0x20");

// [Structure] class TFAnmObjF32_3
class TFAnmObjF32_3
{
public:
	// [Structure] struct TFAnmObjF32_3::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData_0[360];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TFAnmObjF32_3::tagMAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TFAnmObjF32_3::tagMAIN& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<tagMAIN>("TFAnmObjF32_3_tagMAIN")
				.addFunction("__tostring", &TFAnmObjF32_3::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TFAnmObjF32_3::tagMAIN::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnmObjF32_3::tagMAIN) == 0x168, "expected TFAnmObjF32_3::tagMAIN to be size 0x168");

	/// Struct member variables

	// <struct TFAnmObjF32_3::tagMAIN dat, offset 0x0>
	struct TFAnmObjF32_3::tagMAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class TFAnmObjF32_3 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TFAnmObjF32_3& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnmObjF32_3>("TFAnmObjF32_3")
			.addFunction("__tostring", &TFAnmObjF32_3::ToString)
			.addFunction("GetPtrAddr", &TFAnmObjF32_3::GetPtrAddr)
			.addProperty("dat", &TFAnmObjF32_3::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnmObjF32_3::dat) == 360, "expected TFAnmObjF32_3::dat to be size 360");
static_assert(sizeof(TFAnmObjF32_3) == 0x168, "expected TFAnmObjF32_3 to be size 0x168");

// [Structure] union _WFAnmVal
union _WFAnmVal
{
public:
	/// Struct member variables

	// <float mFVal, offset 0x0>
	float mFVal = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "union _WFAnmVal [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(_WFAnmVal& InObject)
	{
		mFVal = InObject.mFVal;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmVal>("_WFAnmVal")
			.addFunction("__tostring", &_WFAnmVal::ToString)
			.addFunction("GetPtrAddr", &_WFAnmVal::GetPtrAddr)
			.addProperty("mFVal", &_WFAnmVal::mFVal)
		.endClass();
	}
#endif
};
static_assert(sizeof(_WFAnmVal::mFVal) == 4, "expected _WFAnmVal::mFVal to be size 4");
static_assert(sizeof(_WFAnmVal) == 0x4, "expected _WFAnmVal to be size 0x4");

// enum TFANMOBJDATATYPE
enum TFANMOBJDATATYPE : uint32_t
{
	// <TFANMOBJDATATYPE_NONE = 0x0>
	TFANMOBJDATATYPE_NONE = 0,

	// <TFANMOBJDATATYPE_FLOAT = 0x1>
	TFANMOBJDATATYPE_FLOAT = 1,

	// <TFANMOBJDATATYPE_ROT = 0x2>
	TFANMOBJDATATYPE_ROT = 2,

	// <TFANMOBJDATATYPE_BOOL = 0x3>
	TFANMOBJDATATYPE_BOOL = 3,

	// <TFANMOBJDATATYPE_COLOR = 0x4>
	TFANMOBJDATATYPE_COLOR = 4,

	// <TFANMOBJDATATYPE_INT = 0x5>
	TFANMOBJDATATYPE_INT = 5,

	// <TFANMOBJDATATYPE_CALLBACK = 0x6>
	TFANMOBJDATATYPE_CALLBACK = 6,

	// <TFANMOBJDATATYPE_XYZ_POS = 0x7>
	TFANMOBJDATATYPE_XYZ_POS = 7,

	// <TFANMOBJDATATYPE_XYZ_ROT = 0x8>
	TFANMOBJDATATYPE_XYZ_ROT = 8

};

// [Structure] class TFAnmObj
class TFAnmObj
{
public:
	// [Structure] struct TFAnmObj::tagGETA
	struct tagGETA
	{
	public:
		/// Struct member variables

		// <float Value, offset 0x0>
		float Value = 0;

		// <float Wait, offset 0x4>
		float Wait = 0;

		// <float LockWait, offset 0x8>
		float LockWait = 0;

		// <float InSlope, offset 0xc>
		float InSlope = 0;

		// <float OutSlope, offset 0x10>
		float OutSlope = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TFAnmObj::tagGETA [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TFAnmObj::tagGETA& InObject)
		{
			Value = InObject.Value;
			Wait = InObject.Wait;
			LockWait = InObject.LockWait;
			InSlope = InObject.InSlope;
			OutSlope = InObject.OutSlope;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<tagGETA>("TFAnmObj_tagGETA")
				.addFunction("__tostring", &TFAnmObj::tagGETA::ToString)
				.addFunction("GetPtrAddr", &TFAnmObj::tagGETA::GetPtrAddr)
				.addProperty("Value", &TFAnmObj::tagGETA::Value)
				.addProperty("Wait", &TFAnmObj::tagGETA::Wait)
				.addProperty("LockWait", &TFAnmObj::tagGETA::LockWait)
				.addProperty("InSlope", &TFAnmObj::tagGETA::InSlope)
				.addProperty("OutSlope", &TFAnmObj::tagGETA::OutSlope)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnmObj::tagGETA::Value) == 4, "expected TFAnmObj::tagGETA::Value to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::Wait) == 4, "expected TFAnmObj::tagGETA::Wait to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::LockWait) == 4, "expected TFAnmObj::tagGETA::LockWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::InSlope) == 4, "expected TFAnmObj::tagGETA::InSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::OutSlope) == 4, "expected TFAnmObj::tagGETA::OutSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA) == 0x14, "expected TFAnmObj::tagGETA to be size 0x14");

	// [Structure] struct TFAnmObj::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <struct _WFAnmObjHeader* pAnmData, offset 0x0>
		struct _WFAnmObjHeader* pAnmData = nullptr;

		// <enum TFANMOBJDATATYPE DataType, offset 0x4>
		enum TFANMOBJDATATYPE DataType;

		// <void* pData, offset 0x8>
		void* pData = nullptr;

		// <void (* pCallback)(union _WFAnmVal*, void*), offset 0xc>
		void (* pCallback)(union _WFAnmVal*, void*);

		// <union _WFAnmVal NowValue, offset 0x10>
		union _WFAnmVal NowValue;

		// <uint32_t Flag, offset 0x14>
		uint32_t Flag = 0;

		// <uint8_t NextType, offset 0x18>
		uint8_t NextType = 0;

		// <uint8_t PrevType, offset 0x19>
		uint8_t PrevType = 0;

		// <uint16_t KeyCount, offset 0x1a>
		uint16_t KeyCount = 0;

		// <uint16_t KeyCountMax, offset 0x1c>
		uint16_t KeyCountMax = 0;

		// <uint16_t KeyListCount, offset 0x1e>
		uint16_t KeyListCount = 0;

		// <float Tick, offset 0x20>
		float Tick = 0;

		// <float NextWait, offset 0x24>
		float NextWait = 0;

		// <float PrevWait, offset 0x28>
		float PrevWait = 0;

		// <void* pNextKey, offset 0x2c>
		void* pNextKey = nullptr;

		// <void* pPrevKey, offset 0x30>
		void* pPrevKey = nullptr;

		// <float NextValue, offset 0x34>
		float NextValue = 0;

		// <float PrevValue, offset 0x38>
		float PrevValue = 0;

		// <float NextSlope, offset 0x3c>
		float NextSlope = 0;

		// <float PrevSlope, offset 0x40>
		float PrevSlope = 0;

		// <struct TFAnmObj::tagGETA NextGeta, offset 0x44>
		struct tagGETA NextGeta;

		// <struct TFAnmObj::tagGETA PrevGeta, offset 0x58>
		struct tagGETA PrevGeta;

		// <struct _WFAnmObjKeyListHeader* pNowKeyListHeader, offset 0x6c>
		struct _WFAnmObjKeyListHeader* pNowKeyListHeader = nullptr;

		// <struct TFAnmObj::tagGETA NowKeyGeta, offset 0x70>
		struct tagGETA NowKeyGeta;

		// <uint32_t NowKeyTypeSize, offset 0x84>
		uint32_t NowKeyTypeSize = 0;

		// <void* pNowKey, offset 0x88>
		void* pNowKey = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct TFAnmObj::tagMAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(TFAnmObj::tagMAIN& InObject)
		{
			pAnmData = InObject.pAnmData;
			DataType = InObject.DataType;
			pData = InObject.pData;
			NowValue = InObject.NowValue;
			Flag = InObject.Flag;
			NextType = InObject.NextType;
			PrevType = InObject.PrevType;
			KeyCount = InObject.KeyCount;
			KeyCountMax = InObject.KeyCountMax;
			KeyListCount = InObject.KeyListCount;
			Tick = InObject.Tick;
			NextWait = InObject.NextWait;
			PrevWait = InObject.PrevWait;
			pNextKey = InObject.pNextKey;
			pPrevKey = InObject.pPrevKey;
			NextValue = InObject.NextValue;
			PrevValue = InObject.PrevValue;
			NextSlope = InObject.NextSlope;
			PrevSlope = InObject.PrevSlope;
			NextGeta = InObject.NextGeta;
			PrevGeta = InObject.PrevGeta;
			pNowKeyListHeader = InObject.pNowKeyListHeader;
			NowKeyGeta = InObject.NowKeyGeta;
			NowKeyTypeSize = InObject.NowKeyTypeSize;
			pNowKey = InObject.pNowKey;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<tagMAIN>("TFAnmObj_tagMAIN")
				.addFunction("__tostring", &TFAnmObj::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TFAnmObj::tagMAIN::GetPtrAddr)
				.addProperty("pAnmData", &TFAnmObj::tagMAIN::pAnmData)
				.addProperty("DataType", &TFAnmObj::tagMAIN::DataType)
				// void type not supported in LuaBridge
				//.addProperty("pData", &TFAnmObj::tagMAIN::pData)
				// delegates are not supported in LuaBridge
				//.addProperty("pCallback", &TFAnmObj::tagMAIN::pCallback)
				.addProperty("NowValue", &TFAnmObj::tagMAIN::NowValue)
				.addProperty("Flag", &TFAnmObj::tagMAIN::Flag)
				.addProperty("NextType", &TFAnmObj::tagMAIN::NextType)
				.addProperty("PrevType", &TFAnmObj::tagMAIN::PrevType)
				.addProperty("KeyCount", &TFAnmObj::tagMAIN::KeyCount)
				.addProperty("KeyCountMax", &TFAnmObj::tagMAIN::KeyCountMax)
				.addProperty("KeyListCount", &TFAnmObj::tagMAIN::KeyListCount)
				.addProperty("Tick", &TFAnmObj::tagMAIN::Tick)
				.addProperty("NextWait", &TFAnmObj::tagMAIN::NextWait)
				.addProperty("PrevWait", &TFAnmObj::tagMAIN::PrevWait)
				// void type not supported in LuaBridge
				//.addProperty("pNextKey", &TFAnmObj::tagMAIN::pNextKey)
				// void type not supported in LuaBridge
				//.addProperty("pPrevKey", &TFAnmObj::tagMAIN::pPrevKey)
				.addProperty("NextValue", &TFAnmObj::tagMAIN::NextValue)
				.addProperty("PrevValue", &TFAnmObj::tagMAIN::PrevValue)
				.addProperty("NextSlope", &TFAnmObj::tagMAIN::NextSlope)
				.addProperty("PrevSlope", &TFAnmObj::tagMAIN::PrevSlope)
				.addProperty("NextGeta", &TFAnmObj::tagMAIN::NextGeta)
				.addProperty("PrevGeta", &TFAnmObj::tagMAIN::PrevGeta)
				.addProperty("pNowKeyListHeader", &TFAnmObj::tagMAIN::pNowKeyListHeader)
				.addProperty("NowKeyGeta", &TFAnmObj::tagMAIN::NowKeyGeta)
				.addProperty("NowKeyTypeSize", &TFAnmObj::tagMAIN::NowKeyTypeSize)
				// void type not supported in LuaBridge
				//.addProperty("pNowKey", &TFAnmObj::tagMAIN::pNowKey)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnmObj::tagMAIN::pAnmData) == 4, "expected TFAnmObj::tagMAIN::pAnmData to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::DataType) == 4, "expected TFAnmObj::tagMAIN::DataType to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pData) == 4, "expected TFAnmObj::tagMAIN::pData to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pCallback) == 4, "expected TFAnmObj::tagMAIN::pCallback to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowValue) == 4, "expected TFAnmObj::tagMAIN::NowValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::Flag) == 4, "expected TFAnmObj::tagMAIN::Flag to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextType) == 1, "expected TFAnmObj::tagMAIN::NextType to be size 1");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevType) == 1, "expected TFAnmObj::tagMAIN::PrevType to be size 1");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyCount) == 2, "expected TFAnmObj::tagMAIN::KeyCount to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyCountMax) == 2, "expected TFAnmObj::tagMAIN::KeyCountMax to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyListCount) == 2, "expected TFAnmObj::tagMAIN::KeyListCount to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::Tick) == 4, "expected TFAnmObj::tagMAIN::Tick to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextWait) == 4, "expected TFAnmObj::tagMAIN::NextWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevWait) == 4, "expected TFAnmObj::tagMAIN::PrevWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNextKey) == 4, "expected TFAnmObj::tagMAIN::pNextKey to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pPrevKey) == 4, "expected TFAnmObj::tagMAIN::pPrevKey to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextValue) == 4, "expected TFAnmObj::tagMAIN::NextValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevValue) == 4, "expected TFAnmObj::tagMAIN::PrevValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextSlope) == 4, "expected TFAnmObj::tagMAIN::NextSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevSlope) == 4, "expected TFAnmObj::tagMAIN::PrevSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextGeta) == 20, "expected TFAnmObj::tagMAIN::NextGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevGeta) == 20, "expected TFAnmObj::tagMAIN::PrevGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNowKeyListHeader) == 4, "expected TFAnmObj::tagMAIN::pNowKeyListHeader to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowKeyGeta) == 20, "expected TFAnmObj::tagMAIN::NowKeyGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowKeyTypeSize) == 4, "expected TFAnmObj::tagMAIN::NowKeyTypeSize to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNowKey) == 4, "expected TFAnmObj::tagMAIN::pNowKey to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN) == 0x8c, "expected TFAnmObj::tagMAIN to be size 0x8c");

	/// Struct member variables

	// <struct TFAnmObj::tagMAIN dat, offset 0x0>
	struct TFAnmObj::tagMAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class TFAnmObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TFAnmObj& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnmObj>("TFAnmObj")
			.addFunction("__tostring", &TFAnmObj::ToString)
			.addFunction("GetPtrAddr", &TFAnmObj::GetPtrAddr)
			.addProperty("dat", &TFAnmObj::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnmObj::dat) == 140, "expected TFAnmObj::dat to be size 140");
static_assert(sizeof(TFAnmObj) == 0x8c, "expected TFAnmObj to be size 0x8c");

// [Structure] class mot::IBoneEffectPJ
namespace mot
{
	class IBoneEffectPJ
	{
	public:
		/// Struct member variables

		// <void* (* field_0)[0x17], offset 0x0>
		void* (* field_0)[0x17];

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::IBoneEffectPJ [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::IBoneEffectPJ& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<IBoneEffectPJ>("mot_IBoneEffectPJ")
				.addFunction("__tostring", &mot::IBoneEffectPJ::ToString)
				.addFunction("GetPtrAddr", &mot::IBoneEffectPJ::GetPtrAddr)
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &mot::IBoneEffectPJ::field_0)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectPJ::field_0) == 4, "expected mot::IBoneEffectPJ::field_0 to be size 4");
static_assert(sizeof(mot::IBoneEffectPJ) == 0x4, "expected mot::IBoneEffectPJ to be size 0x4");

// enum ECameraVibAnimeType
enum ECameraVibAnimeType : uint32_t
{
	// <CAMERA_VIB_ANIME_TYPE_DAMAGE_HIT = 0x0>
	CAMERA_VIB_ANIME_TYPE_DAMAGE_HIT = 0,

	// <CAMERA_VIB_ANIME_TYPE_DAMAGE_FALL = 0x1>
	CAMERA_VIB_ANIME_TYPE_DAMAGE_FALL = 1,

	// <CAMERA_VIB_ANIME_TYPE_QUAKE = 0x2>
	CAMERA_VIB_ANIME_TYPE_QUAKE = 2,

	// <CAMERA_VIB_ANIME_TYPE_ATTACK = 0x3>
	CAMERA_VIB_ANIME_TYPE_ATTACK = 3,

	// <CAMERA_VIB_ANIME_TYPE_ATTACK_SIDE = 0x4>
	CAMERA_VIB_ANIME_TYPE_ATTACK_SIDE = 4,

	// <CAMERA_VIB_ANIME_TYPE_EXPLOSION = 0x5>
	CAMERA_VIB_ANIME_TYPE_EXPLOSION = 5,

	// <CAMERA_VIB_ANIME_TYPE_EXPLOSION_LONG = 0x6>
	CAMERA_VIB_ANIME_TYPE_EXPLOSION_LONG = 6,

	// <CAMERA_VIB_ANIME_TYPE_SHOCK = 0x7>
	CAMERA_VIB_ANIME_TYPE_SHOCK = 7,

	// <CAMERA_VIB_ANIME_TYPE_SHOCK_SIDE = 0x8>
	CAMERA_VIB_ANIME_TYPE_SHOCK_SIDE = 8,

	// <CAMERA_VIB_ANIME_TYPE_FILM_NOISE = 0x9>
	CAMERA_VIB_ANIME_TYPE_FILM_NOISE = 9,

	// <CAMERA_VIB_ANIME_TYPE_FILM_NOISE2 = 0xa>
	CAMERA_VIB_ANIME_TYPE_FILM_NOISE2 = 10,

	// <CAMERA_VIB_ANIME_TYPE_WIND_PRESS_SIDE = 0xb>
	CAMERA_VIB_ANIME_TYPE_WIND_PRESS_SIDE = 11,

	// <CAMERA_VIB_ANIME_TYPE_CRASH = 0xc>
	CAMERA_VIB_ANIME_TYPE_CRASH = 12,

	// <CAMERA_VIB_ANIME_TYPE_TURN_BANK = 0xd>
	CAMERA_VIB_ANIME_TYPE_TURN_BANK = 13,

	// <TOTAL_CAMERA_VIB_ANIME_TYPE = 0xe>
	TOTAL_CAMERA_VIB_ANIME_TYPE = 14

};

// [Structure] class CCameraVibTiming
class CCameraVibTiming
{
public:
	/// Struct member variables

	// <char const* m_sMotName, offset 0x0>
	char const* m_sMotName = nullptr;

	// <float m_fMotFrame, offset 0x4>
	float m_fMotFrame = 0;

	// <enum ECameraVibAnimeType m_eAnimeType, offset 0x8>
	enum ECameraVibAnimeType m_eAnimeType;

	// <float m_fAnimeScale, offset 0xc>
	float m_fAnimeScale = 0;

	/// 1 Functions

	// [Function] class CCameraVibTiming* CCameraVibTiming::getTable(int32_t* arg1, class mHRChara& arg2) [?getTable@CCameraVibTiming@@SAPBV1@PAHABVmHRChara@@@Z]
	typedef class CCameraVibTiming*(__fastcall* _getTable_CCameraVibTiming__SAPBV1_PAHABVmHRChara___Z)(int32_t* arg1, class mHRChara& arg2);
	static class CCameraVibTiming* getTable(int32_t* arg1, class mHRChara& arg2)
	{
		_getTable_CCameraVibTiming__SAPBV1_PAHABVmHRChara___Z mFunc = (_getTable_CCameraVibTiming__SAPBV1_PAHABVmHRChara___Z)(GameModule + 0x567740);
		return mFunc(arg1, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraVibTiming [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraVibTiming& InObject)
	{
		m_sMotName = InObject.m_sMotName;
		m_fMotFrame = InObject.m_fMotFrame;
		m_eAnimeType = InObject.m_eAnimeType;
		m_fAnimeScale = InObject.m_fAnimeScale;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraVibTiming>("CCameraVibTiming")
			.addFunction("__tostring", &CCameraVibTiming::ToString)
			.addFunction("GetPtrAddr", &CCameraVibTiming::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sMotName", &CCameraVibTiming::m_sMotName)
			.addProperty("m_fMotFrame", &CCameraVibTiming::m_fMotFrame)
			.addProperty("m_eAnimeType", &CCameraVibTiming::m_eAnimeType)
			.addProperty("m_fAnimeScale", &CCameraVibTiming::m_fAnimeScale)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("getTable", &CCameraVibTiming::getTable)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraVibTiming::m_sMotName) == 4, "expected CCameraVibTiming::m_sMotName to be size 4");
static_assert(sizeof(CCameraVibTiming::m_fMotFrame) == 4, "expected CCameraVibTiming::m_fMotFrame to be size 4");
static_assert(sizeof(CCameraVibTiming::m_eAnimeType) == 4, "expected CCameraVibTiming::m_eAnimeType to be size 4");
static_assert(sizeof(CCameraVibTiming::m_fAnimeScale) == 4, "expected CCameraVibTiming::m_fAnimeScale to be size 4");
static_assert(sizeof(CCameraVibTiming) == 0x10, "expected CCameraVibTiming to be size 0x10");

// enum eENVOICE
enum eENVOICE : uint32_t
{
	// <eENVOICE_A = 0x0>
	eENVOICE_A = 0,

	// <eENVOICE_B = 0x5>
	eENVOICE_B = 5,

	// <eENVOICE_C = 0xa>
	eENVOICE_C = 10,

	// <eENVOICE_D = 0xf>
	eENVOICE_D = 15

};

// [Structure] struct HRCHARAVOICE
struct HRCHARAVOICE
{
public:
	/// Struct member variables

	// <char const* pFileName, offset 0x0>
	char const* pFileName = nullptr;

	// <enum eENVOICE Voice, offset 0x4>
	enum eENVOICE Voice;

	// <uint32_t FileNameLength, offset 0x8>
	uint32_t FileNameLength = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct HRCHARAVOICE [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HRCHARAVOICE& InObject)
	{
		pFileName = InObject.pFileName;
		Voice = InObject.Voice;
		FileNameLength = InObject.FileNameLength;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HRCHARAVOICE>("HRCHARAVOICE")
			.addFunction("__tostring", &HRCHARAVOICE::ToString)
			.addFunction("GetPtrAddr", &HRCHARAVOICE::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("pFileName", &HRCHARAVOICE::pFileName)
			.addProperty("Voice", &HRCHARAVOICE::Voice)
			.addProperty("FileNameLength", &HRCHARAVOICE::FileNameLength)
		.endClass();
	}
#endif
};
static_assert(sizeof(HRCHARAVOICE::pFileName) == 4, "expected HRCHARAVOICE::pFileName to be size 4");
static_assert(sizeof(HRCHARAVOICE::Voice) == 4, "expected HRCHARAVOICE::Voice to be size 4");
static_assert(sizeof(HRCHARAVOICE::FileNameLength) == 4, "expected HRCHARAVOICE::FileNameLength to be size 4");
static_assert(sizeof(HRCHARAVOICE) == 0xc, "expected HRCHARAVOICE to be size 0xc");

// [Structure] class gameUtil::CPlane
namespace gameUtil
{
	class CPlane
	{
	public:
		/// Struct member variables

		// <class tiVector m_inABCD, offset 0x0>
		class tiVector m_inABCD;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class gameUtil::CPlane [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(gameUtil::CPlane& InObject)
		{
			m_inABCD = InObject.m_inABCD;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CPlane>("gameUtil_CPlane")
				.addFunction("__tostring", &gameUtil::CPlane::ToString)
				.addFunction("GetPtrAddr", &gameUtil::CPlane::GetPtrAddr)
				.addProperty("m_inABCD", &gameUtil::CPlane::m_inABCD)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(gameUtil::CPlane::m_inABCD) == 16, "expected gameUtil::CPlane::m_inABCD to be size 16");
static_assert(sizeof(gameUtil::CPlane) == 0x10, "expected gameUtil::CPlane to be size 0x10");

// [Structure] class CStickShadow
class CStickShadow
{
public:
	/// Struct member variables

	// <class gameUtil::CPlane m_inProjPlane, offset 0x0>
	class gameUtil::CPlane m_inProjPlane;

	// <int32_t m_nBoneID, offset 0x10>
	int32_t m_nBoneID = 0;

	// <float m_fWidthHalf, offset 0x14>
	float m_fWidthHalf = 0;

	// <float m_fDepthPlus, offset 0x18>
	float m_fDepthPlus = 0;

	// <float m_fDepthMinus, offset 0x1c>
	float m_fDepthMinus = 0;

	// <float m_fAlphaMaxDist, offset 0x20>
	float m_fAlphaMaxDist = 0;

	// <float m_fAlphaMinDist, offset 0x24>
	float m_fAlphaMinDist = 0;

	// <Unidentified data segment, offset 0x28>
private:
	char _UnidentifiedData_40[8];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CStickShadow [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CStickShadow& InObject)
	{
		m_inProjPlane = InObject.m_inProjPlane;
		m_nBoneID = InObject.m_nBoneID;
		m_fWidthHalf = InObject.m_fWidthHalf;
		m_fDepthPlus = InObject.m_fDepthPlus;
		m_fDepthMinus = InObject.m_fDepthMinus;
		m_fAlphaMaxDist = InObject.m_fAlphaMaxDist;
		m_fAlphaMinDist = InObject.m_fAlphaMinDist;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CStickShadow>("CStickShadow")
			.addFunction("__tostring", &CStickShadow::ToString)
			.addFunction("GetPtrAddr", &CStickShadow::GetPtrAddr)
			.addProperty("m_inProjPlane", &CStickShadow::m_inProjPlane)
			.addProperty("m_nBoneID", &CStickShadow::m_nBoneID)
			.addProperty("m_fWidthHalf", &CStickShadow::m_fWidthHalf)
			.addProperty("m_fDepthPlus", &CStickShadow::m_fDepthPlus)
			.addProperty("m_fDepthMinus", &CStickShadow::m_fDepthMinus)
			.addProperty("m_fAlphaMaxDist", &CStickShadow::m_fAlphaMaxDist)
			.addProperty("m_fAlphaMinDist", &CStickShadow::m_fAlphaMinDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(CStickShadow::m_inProjPlane) == 16, "expected CStickShadow::m_inProjPlane to be size 16");
static_assert(sizeof(CStickShadow::m_nBoneID) == 4, "expected CStickShadow::m_nBoneID to be size 4");
static_assert(sizeof(CStickShadow::m_fWidthHalf) == 4, "expected CStickShadow::m_fWidthHalf to be size 4");
static_assert(sizeof(CStickShadow::m_fDepthPlus) == 4, "expected CStickShadow::m_fDepthPlus to be size 4");
static_assert(sizeof(CStickShadow::m_fDepthMinus) == 4, "expected CStickShadow::m_fDepthMinus to be size 4");
static_assert(sizeof(CStickShadow::m_fAlphaMaxDist) == 4, "expected CStickShadow::m_fAlphaMaxDist to be size 4");
static_assert(sizeof(CStickShadow::m_fAlphaMinDist) == 4, "expected CStickShadow::m_fAlphaMinDist to be size 4");
static_assert(sizeof(CStickShadow) == 0x30, "expected CStickShadow to be size 0x30");

// [Structure] class CharController
class CharController
{
public:
	// enum CharController::eChrCntrlMoveMode
	enum eChrCntrlMoveMode : uint32_t
	{
		// <eChrCntrlMoveMode_WalkSideLeft = 0x0>
		eChrCntrlMoveMode_WalkSideLeft = 0,

		// <eChrCntrlMoveMode_WalkSideRight = 0x1>
		eChrCntrlMoveMode_WalkSideRight = 1,

		// <eChrCntrlMoveMode_WalkForward = 0x2>
		eChrCntrlMoveMode_WalkForward = 2,

		// <eChrCntrlMoveMode_WalkBack = 0x3>
		eChrCntrlMoveMode_WalkBack = 3,

		// <eChrCntrlMoveMode_RunForward = 0x4>
		eChrCntrlMoveMode_RunForward = 4,

		// <eChrCntrlMoveMode_Idle = 0x5>
		eChrCntrlMoveMode_Idle = 5,

		// <eChrCntrlMoveMode_NumMax = 0x6>
		eChrCntrlMoveMode_NumMax = 6

	};

	/// Struct member variables

	// <uint8_t m_boNowUnderControl, offset 0x0>
	uint8_t m_boNowUnderControl = 0;

	// <uint8_t m_boEnableControl, offset 0x1>
	uint8_t m_boEnableControl = 0;

	// <Unidentified data segment, offset 0x2>
private:
	char _UnidentifiedData_2[2];

public:
	// <class mHRChara* m_pOwnerChar, offset 0x4>
	class mHRChara* m_pOwnerChar = nullptr;

	// <struct CharControlMotID m_RegMotID, offset 0x8>
	struct CharControlMotID m_RegMotID;

	// <uint8_t m_boRegistMove, offset 0x2c>
	uint8_t m_boRegistMove = 0;

	// <uint8_t m_boRegistAttack, offset 0x2d>
	uint8_t m_boRegistAttack = 0;

	// <uint8_t m_boLockon, offset 0x2e>
	uint8_t m_boLockon = 0;

	// <Unidentified data segment, offset 0x2f>
private:
	char _UnidentifiedData_47[1];

public:
	// <struct Vec m_PcDirection, offset 0x30>
	struct Vec m_PcDirection;

	// <struct Vec m_MoveVec, offset 0x3c>
	struct Vec m_MoveVec;

	// <struct Vec m_VecStickL, offset 0x48>
	struct Vec m_VecStickL;

	// <float m_fStickInpRatio, offset 0x54>
	float m_fStickInpRatio = 0;

	// <enum CharController::eChrCntrlMoveMode m_MoveMode, offset 0x58>
	enum CharController::eChrCntrlMoveMode m_MoveMode;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CharController [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CharController& InObject)
	{
		m_boNowUnderControl = InObject.m_boNowUnderControl;
		m_boEnableControl = InObject.m_boEnableControl;
		m_pOwnerChar = InObject.m_pOwnerChar;
		m_RegMotID = InObject.m_RegMotID;
		m_boRegistMove = InObject.m_boRegistMove;
		m_boRegistAttack = InObject.m_boRegistAttack;
		m_boLockon = InObject.m_boLockon;
		m_PcDirection = InObject.m_PcDirection;
		m_MoveVec = InObject.m_MoveVec;
		m_VecStickL = InObject.m_VecStickL;
		m_fStickInpRatio = InObject.m_fStickInpRatio;
		m_MoveMode = InObject.m_MoveMode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CharController>("CharController")
			.addFunction("__tostring", &CharController::ToString)
			.addFunction("GetPtrAddr", &CharController::GetPtrAddr)
			.addProperty("m_boNowUnderControl", &CharController::m_boNowUnderControl)
			.addProperty("m_boEnableControl", &CharController::m_boEnableControl)
			.addProperty("m_pOwnerChar", &CharController::m_pOwnerChar)
			.addProperty("m_RegMotID", &CharController::m_RegMotID)
			.addProperty("m_boRegistMove", &CharController::m_boRegistMove)
			.addProperty("m_boRegistAttack", &CharController::m_boRegistAttack)
			.addProperty("m_boLockon", &CharController::m_boLockon)
			.addProperty("m_PcDirection", &CharController::m_PcDirection)
			.addProperty("m_MoveVec", &CharController::m_MoveVec)
			.addProperty("m_VecStickL", &CharController::m_VecStickL)
			.addProperty("m_fStickInpRatio", &CharController::m_fStickInpRatio)
			.addProperty("m_MoveMode", &CharController::m_MoveMode)
		.endClass();
	}
#endif
};
static_assert(sizeof(CharController::m_boNowUnderControl) == 1, "expected CharController::m_boNowUnderControl to be size 1");
static_assert(sizeof(CharController::m_boEnableControl) == 1, "expected CharController::m_boEnableControl to be size 1");
static_assert(sizeof(CharController::m_pOwnerChar) == 4, "expected CharController::m_pOwnerChar to be size 4");
static_assert(sizeof(CharController::m_RegMotID) == 36, "expected CharController::m_RegMotID to be size 36");
static_assert(sizeof(CharController::m_boRegistMove) == 1, "expected CharController::m_boRegistMove to be size 1");
static_assert(sizeof(CharController::m_boRegistAttack) == 1, "expected CharController::m_boRegistAttack to be size 1");
static_assert(sizeof(CharController::m_boLockon) == 1, "expected CharController::m_boLockon to be size 1");
static_assert(sizeof(CharController::m_PcDirection) == 12, "expected CharController::m_PcDirection to be size 12");
static_assert(sizeof(CharController::m_MoveVec) == 12, "expected CharController::m_MoveVec to be size 12");
static_assert(sizeof(CharController::m_VecStickL) == 12, "expected CharController::m_VecStickL to be size 12");
static_assert(sizeof(CharController::m_fStickInpRatio) == 4, "expected CharController::m_fStickInpRatio to be size 4");
static_assert(sizeof(CharController::m_MoveMode) == 4, "expected CharController::m_MoveMode to be size 4");
static_assert(sizeof(CharController) == 0x5c, "expected CharController to be size 0x5c");

// [Structure] class CObjectShadow
class CObjectShadow
{
public:
	/// Struct member variables

	// <struct tagGHMR_TEX m_inUpTex, offset 0x0>
	struct tagGHMR_TEX m_inUpTex;

	// <struct tagGHMR_TEX m_inSideTex, offset 0x28>
	struct tagGHMR_TEX m_inSideTex;

	// <float m_fGroundOfst, offset 0x50>
	float m_fGroundOfst = 0;

	// <float m_fUpWidthHalf, offset 0x54>
	float m_fUpWidthHalf = 0;

	// <float m_fSideWidthHalfMax, offset 0x58>
	float m_fSideWidthHalfMax = 0;

	// <float m_fSideWidthHalfMin, offset 0x5c>
	float m_fSideWidthHalfMin = 0;

	// <float m_fDepthPlus, offset 0x60>
	float m_fDepthPlus = 0;

	// <float m_fDepthMinus, offset 0x64>
	float m_fDepthMinus = 0;

	// <float m_fDepthOfstMax, offset 0x68>
	float m_fDepthOfstMax = 0;

	// <float m_fAlphaMulCoe, offset 0x6c>
	float m_fAlphaMulCoe = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CObjectShadow [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CObjectShadow& InObject)
	{
		m_inUpTex = InObject.m_inUpTex;
		m_inSideTex = InObject.m_inSideTex;
		m_fGroundOfst = InObject.m_fGroundOfst;
		m_fUpWidthHalf = InObject.m_fUpWidthHalf;
		m_fSideWidthHalfMax = InObject.m_fSideWidthHalfMax;
		m_fSideWidthHalfMin = InObject.m_fSideWidthHalfMin;
		m_fDepthPlus = InObject.m_fDepthPlus;
		m_fDepthMinus = InObject.m_fDepthMinus;
		m_fDepthOfstMax = InObject.m_fDepthOfstMax;
		m_fAlphaMulCoe = InObject.m_fAlphaMulCoe;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CObjectShadow>("CObjectShadow")
			.addFunction("__tostring", &CObjectShadow::ToString)
			.addFunction("GetPtrAddr", &CObjectShadow::GetPtrAddr)
			.addProperty("m_inUpTex", &CObjectShadow::m_inUpTex)
			.addProperty("m_inSideTex", &CObjectShadow::m_inSideTex)
			.addProperty("m_fGroundOfst", &CObjectShadow::m_fGroundOfst)
			.addProperty("m_fUpWidthHalf", &CObjectShadow::m_fUpWidthHalf)
			.addProperty("m_fSideWidthHalfMax", &CObjectShadow::m_fSideWidthHalfMax)
			.addProperty("m_fSideWidthHalfMin", &CObjectShadow::m_fSideWidthHalfMin)
			.addProperty("m_fDepthPlus", &CObjectShadow::m_fDepthPlus)
			.addProperty("m_fDepthMinus", &CObjectShadow::m_fDepthMinus)
			.addProperty("m_fDepthOfstMax", &CObjectShadow::m_fDepthOfstMax)
			.addProperty("m_fAlphaMulCoe", &CObjectShadow::m_fAlphaMulCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CObjectShadow::m_inUpTex) == 40, "expected CObjectShadow::m_inUpTex to be size 40");
static_assert(sizeof(CObjectShadow::m_inSideTex) == 40, "expected CObjectShadow::m_inSideTex to be size 40");
static_assert(sizeof(CObjectShadow::m_fGroundOfst) == 4, "expected CObjectShadow::m_fGroundOfst to be size 4");
static_assert(sizeof(CObjectShadow::m_fUpWidthHalf) == 4, "expected CObjectShadow::m_fUpWidthHalf to be size 4");
static_assert(sizeof(CObjectShadow::m_fSideWidthHalfMax) == 4, "expected CObjectShadow::m_fSideWidthHalfMax to be size 4");
static_assert(sizeof(CObjectShadow::m_fSideWidthHalfMin) == 4, "expected CObjectShadow::m_fSideWidthHalfMin to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthPlus) == 4, "expected CObjectShadow::m_fDepthPlus to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthMinus) == 4, "expected CObjectShadow::m_fDepthMinus to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthOfstMax) == 4, "expected CObjectShadow::m_fDepthOfstMax to be size 4");
static_assert(sizeof(CObjectShadow::m_fAlphaMulCoe) == 4, "expected CObjectShadow::m_fAlphaMulCoe to be size 4");
static_assert(sizeof(CObjectShadow) == 0x70, "expected CObjectShadow to be size 0x70");

// [Structure] struct stBikeEffect
struct stBikeEffect
{
public:
	/// Struct member variables

	// <class EffectDriftMark* pDriftMark, offset 0x0>
	class EffectDriftMark* pDriftMark = nullptr;

	// <class EffectKeepSmoke* pKeepSmoke, offset 0x4>
	class EffectKeepSmoke* pKeepSmoke = nullptr;

	// <struct Vec posTireOldL, offset 0x8>
	struct Vec posTireOldL;

	// <struct Vec posTireOldR, offset 0x14>
	struct Vec posTireOldR;

	// <class EffectFixFire* pFixFire[0x2], offset 0x20>
	class EffectFixFire* pFixFire[2];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stBikeEffect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stBikeEffect& InObject)
	{
		pDriftMark = InObject.pDriftMark;
		pKeepSmoke = InObject.pKeepSmoke;
		posTireOldL = InObject.posTireOldL;
		posTireOldR = InObject.posTireOldR;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stBikeEffect>("stBikeEffect")
			.addFunction("__tostring", &stBikeEffect::ToString)
			.addFunction("GetPtrAddr", &stBikeEffect::GetPtrAddr)
			.addProperty("pDriftMark", &stBikeEffect::pDriftMark)
			.addProperty("pKeepSmoke", &stBikeEffect::pKeepSmoke)
			.addProperty("posTireOldL", &stBikeEffect::posTireOldL)
			.addProperty("posTireOldR", &stBikeEffect::posTireOldR)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pFixFire", &stBikeEffect::pFixFire)
		.endClass();
	}
#endif
};
static_assert(sizeof(stBikeEffect::pDriftMark) == 4, "expected stBikeEffect::pDriftMark to be size 4");
static_assert(sizeof(stBikeEffect::pKeepSmoke) == 4, "expected stBikeEffect::pKeepSmoke to be size 4");
static_assert(sizeof(stBikeEffect::posTireOldL) == 12, "expected stBikeEffect::posTireOldL to be size 12");
static_assert(sizeof(stBikeEffect::posTireOldR) == 12, "expected stBikeEffect::posTireOldR to be size 12");
static_assert(sizeof(stBikeEffect::pFixFire) == 8, "expected stBikeEffect::pFixFire to be size 8");
static_assert(sizeof(stBikeEffect) == 0x28, "expected stBikeEffect to be size 0x28");

// enum enBikeSpinDir
enum enBikeSpinDir : uint32_t
{
	// <eBikeSpinL = 0x0>
	eBikeSpinL = 0,

	// <eBikeSpinR = 0x1>
	eBikeSpinR = 1,

	// <eBikeSpinMax = 0x2>
	eBikeSpinMax = 2

};

// enum enBikeFallProc
enum enBikeFallProc : uint32_t
{
	// <eBikeFallSetMotel = 0x0>
	eBikeFallSetMotel = 0,

	// <eBikeFallWaitAreaLoad = 0x1>
	eBikeFallWaitAreaLoad = 1,

	// <eBikeFallMax = 0x2>
	eBikeFallMax = 2

};

// enum enBikeProc
enum enBikeProc : uint32_t
{
	// <eBikeStopIdle = 0x0>
	eBikeStopIdle = 0,

	// <eBikeTrvRiding = 0x1>
	eBikeTrvRiding = 1,

	// <eBikeTrvIdle = 0x2>
	eBikeTrvIdle = 2,

	// <eBikeRun = 0x3>
	eBikeRun = 3,

	// <eBikeBack = 0x4>
	eBikeBack = 4,

	// <eBikeQStart = 0x5>
	eBikeQStart = 5,

	// <eBikeQStartWait = 0x6>
	eBikeQStartWait = 6,

	// <eBikeQBreak = 0x7>
	eBikeQBreak = 7,

	// <eBikeSpin = 0x8>
	eBikeSpin = 8,

	// <eBikeClash = 0x9>
	eBikeClash = 9,

	// <eBikePcClash2Stand = 0xa>
	eBikePcClash2Stand = 10,

	// <eBikeClash2Stand = 0xb>
	eBikeClash2Stand = 11,

	// <eBikeWaitStand = 0xc>
	eBikeWaitStand = 12,

	// <eBikeTrvGetOff = 0xd>
	eBikeTrvGetOff = 13,

	// <eBikeDamege = 0xe>
	eBikeDamege = 14,

	// <eBikeDead = 0xf>
	eBikeDead = 15,

	// <eBikeAccel = 0x10>
	eBikeAccel = 16,

	// <eBikeFall = 0x11>
	eBikeFall = 17,

	// <eBikeWaitSetMotel = 0x12>
	eBikeWaitSetMotel = 18,

	// <eBikeMax = 0x13>
	eBikeMax = 19

};

// [Structure] struct stBike
struct stBike
{
public:
	/// Struct member variables

	// <class TGmf* pGmf, offset 0x0>
	class TGmf* pGmf = nullptr;

	// <class TGan** pGan, offset 0x4>
	class TGan** pGan = nullptr;

	// <enum enBikeProc process, offset 0x8>
	enum enBikeProc process;

	// <enum enBikeFallProc fallProcess, offset 0xc>
	enum enBikeFallProc fallProcess;

	// <int32_t motionNo, offset 0x10>
	int32_t motionNo = 0;

	// <int32_t motionNumMax, offset 0x14>
	int32_t motionNumMax = 0;

	// <int32_t motionBrendNum, offset 0x18>
	int32_t motionBrendNum = 0;

	// <int32_t restoreMotionNo, offset 0x1c>
	int32_t restoreMotionNo = 0;

	// <float rotPerf, offset 0x20>
	float rotPerf = 0;

	// <float spdU, offset 0x24>
	float spdU = 0;

	// <float spdV, offset 0x28>
	float spdV = 0;

	// <float angSpd, offset 0x2c>
	float angSpd = 0;

	// <float prevAngSpd, offset 0x30>
	float prevAngSpd = 0;

	// <float forceU, offset 0x34>
	float forceU = 0;

	// <float forceV, offset 0x38>
	float forceV = 0;

	// <int32_t gripState, offset 0x3c>
	int32_t gripState = 0;

	// <int32_t timerSlipTrigger, offset 0x40>
	int32_t timerSlipTrigger = 0;

	// <int32_t timerMaxSlipTrigger, offset 0x44>
	int32_t timerMaxSlipTrigger = 0;

	// <float slipRate, offset 0x48>
	float slipRate = 0;

	// <float slipAngle, offset 0x4c>
	float slipAngle = 0;

	// <float accelRate, offset 0x50>
	float accelRate = 0;

	// <float brakeRate, offset 0x54>
	float brakeRate = 0;

	// <float rudderAng, offset 0x58>
	float rudderAng = 0;

	// <float length, offset 0x5c>
	float length = 0;

	// <int32_t hitTame, offset 0x60>
	int32_t hitTame = 0;

	// <struct Vec externForce, offset 0x64>
	struct Vec externForce;

	// <float posYF, offset 0x70>
	float posYF = 0;

	// <float posYB, offset 0x74>
	float posYB = 0;

	// <struct Vec pos, offset 0x78>
	struct Vec pos;

	// <struct Vec beforePos, offset 0x84>
	struct Vec beforePos;

	// <struct Vec beforePosF, offset 0x90>
	struct Vec beforePosF;

	// <struct Vec beforePosB, offset 0x9c>
	struct Vec beforePosB;

	// <struct Vec moveTempPos, offset 0xa8>
	struct Vec moveTempPos;

	// <struct Vec moveTempPosF, offset 0xb4>
	struct Vec moveTempPosF;

	// <struct Vec moveTempPosB, offset 0xc0>
	struct Vec moveTempPosB;

	// <struct Vec rot, offset 0xcc>
	struct Vec rot;

	// <struct Vec oldRot, offset 0xd8>
	struct Vec oldRot;

	// <float oldPosY, offset 0xe4>
	float oldPosY = 0;

	// <float oldPosYF, offset 0xe8>
	float oldPosYF = 0;

	// <float oldPosYB, offset 0xec>
	float oldPosYB = 0;

	// <float adjustRotY, offset 0xf0>
	float adjustRotY = 0;

	// <uint8_t hitCheck, offset 0xf4>
	uint8_t hitCheck = 0;

	// <uint8_t clash, offset 0xf5>
	uint8_t clash = 0;

	// <uint8_t hitWall, offset 0xf6>
	uint8_t hitWall = 0;

	// <uint8_t hitWall4Spin, offset 0xf7>
	uint8_t hitWall4Spin = 0;

	// <uint8_t alwaysCheckHitColl, offset 0xf8>
	uint8_t alwaysCheckHitColl = 0;

	// <Unidentified data segment, offset 0xf9>
private:
	char _UnidentifiedData_249[3];

public:
	// <int32_t hp, offset 0xfc>
	int32_t hp = 0;

	// <int32_t bgmHdl, offset 0x100>
	int32_t bgmHdl = 0;

	// <int32_t seHndlEngine, offset 0x104>
	int32_t seHndlEngine = 0;

	// <int32_t seHndlEngineNeutral, offset 0x108>
	int32_t seHndlEngineNeutral = 0;

	// <int32_t seHndlBreak, offset 0x10c>
	int32_t seHndlBreak = 0;

	// <int32_t seHndlQBreak, offset 0x110>
	int32_t seHndlQBreak = 0;

	// <int32_t seHndlAir, offset 0x114>
	int32_t seHndlAir = 0;

	// <int32_t seHndlNitro, offset 0x118>
	int32_t seHndlNitro = 0;

	// <int32_t seHndSqueal, offset 0x11c>
	int32_t seHndSqueal = 0;

	// <float seVolEngine, offset 0x120>
	float seVolEngine = 0;

	// <float seVolEngineNeutral, offset 0x124>
	float seVolEngineNeutral = 0;

	// <float seVolBreak, offset 0x128>
	float seVolBreak = 0;

	// <float seVolQBreak, offset 0x12c>
	float seVolQBreak = 0;

	// <float seVolAir, offset 0x130>
	float seVolAir = 0;

	// <float seVolNitro, offset 0x134>
	float seVolNitro = 0;

	// <float seVolSqueal, offset 0x138>
	float seVolSqueal = 0;

	// <int32_t command, offset 0x13c>
	int32_t command = 0;

	// <float acc, offset 0x140>
	float acc = 0;

	// <uint8_t useNitro, offset 0x144>
	uint8_t useNitro = 0;

	// <Unidentified data segment, offset 0x145>
private:
	char _UnidentifiedData_325[3];

public:
	// <float nitro, offset 0x148>
	float nitro = 0;

	// <int32_t nitroStopTick, offset 0x14c>
	int32_t nitroStopTick = 0;

	// <float turnVal, offset 0x150>
	float turnVal = 0;

	// <float rimTurnVal, offset 0x154>
	float rimTurnVal = 0;

	// <float qBreakRotY, offset 0x158>
	float qBreakRotY = 0;

	// <enum enBikeSpinDir spinDir, offset 0x15c>
	enum enBikeSpinDir spinDir;

	// <float spinY, offset 0x160>
	float spinY = 0;

	// <uint8_t wiry, offset 0x164>
	uint8_t wiry = 0;

	// <uint8_t clashMySelf, offset 0x165>
	uint8_t clashMySelf = 0;

	// <uint8_t battle, offset 0x166>
	uint8_t battle = 0;

	// <uint8_t rideOnStart, offset 0x167>
	uint8_t rideOnStart = 0;

	// <uint8_t initHitJudge, offset 0x168>
	uint8_t initHitJudge = 0;

	// <uint8_t pushAcceling, offset 0x169>
	uint8_t pushAcceling = 0;

	// <uint8_t pushBreaking, offset 0x16a>
	uint8_t pushBreaking = 0;

	// <uint8_t cantRideOn, offset 0x16b>
	uint8_t cantRideOn = 0;

	// <uint8_t cantGetOff, offset 0x16c>
	uint8_t cantGetOff = 0;

	// <uint8_t cantHandling, offset 0x16d>
	uint8_t cantHandling = 0;

	// <uint8_t dispCantGetOff, offset 0x16e>
	uint8_t dispCantGetOff = 0;

	// <uint8_t crash2Stand, offset 0x16f>
	uint8_t crash2Stand = 0;

	// <uint8_t changeVolEngine, offset 0x170>
	uint8_t changeVolEngine = 0;

	// <uint8_t changeVolEngineIdle, offset 0x171>
	uint8_t changeVolEngineIdle = 0;

	// <Unidentified data segment, offset 0x172>
private:
	char _UnidentifiedData_370[2];

public:
	// <int32_t startWait, offset 0x174>
	int32_t startWait = 0;

	// <float rateTbl[0x3], offset 0x178>
	float rateTbl[3];

	// <class WAnimF inputRelay, offset 0x184>
	class WAnimF inputRelay;

	// <class ghmGcCollObjCapsule hitColl, offset 0x1a4>
	class ghmGcCollObjCapsule hitColl;

	// <class ghmGcCollObjCapsule rideColl, offset 0x204>
	class ghmGcCollObjCapsule rideColl;

	// <class ghmGcCollObjCapsule hitStgColl, offset 0x264>
	class ghmGcCollObjCapsule hitStgColl;

	// <class ghmGcCollObjCapsule hitStgCollF, offset 0x2c4>
	class ghmGcCollObjCapsule hitStgCollF;

	// <class ghmGcCollObjCapsule hitStgCollB, offset 0x324>
	class ghmGcCollObjCapsule hitStgCollB;

	// <class ghmGcCollObj* footHitResultObj, offset 0x384>
	class ghmGcCollObj* footHitResultObj = nullptr;

	// <class ghmGcCollObjHitResult* footHitResult, offset 0x388>
	class ghmGcCollObjHitResult* footHitResult = nullptr;

	// <class ghmGcCollObjHitResultObj footHitResultObj2, offset 0x38c>
	class ghmGcCollObjHitResultObj footHitResultObj2;

	// <class EventAreaCircle* pEvIcn, offset 0x3d8>
	class EventAreaCircle* pEvIcn = nullptr;

	// <struct tagGHMR_TEX texSpeed, offset 0x3dc>
	struct tagGHMR_TEX texSpeed;

	// <class WAnimF cameraLength, offset 0x404>
	class WAnimF cameraLength;

	// <class WAnimF cameraAngle, offset 0x424>
	class WAnimF cameraAngle;

	// <float rotZ, offset 0x444>
	float rotZ = 0;

	// <uint8_t forceHitStage, offset 0x448>
	uint8_t forceHitStage = 0;

	// <uint8_t crashFlag, offset 0x449>
	uint8_t crashFlag = 0;

	// <Unidentified data segment, offset 0x44a>
private:
	char _UnidentifiedData_1098[2];

public:
	// <int32_t damageCount, offset 0x44c>
	int32_t damageCount = 0;

	// <class WAnimF prj, offset 0x450>
	class WAnimF prj;

	// <class WAnimF modelAlpha, offset 0x470>
	class WAnimF modelAlpha;

	// <class CAmbientShadow m_inAmbientShadow, offset 0x490>
	class CAmbientShadow m_inAmbientShadow;

	// <uint8_t muteSe, offset 0x4c8>
	uint8_t muteSe = 0;

	// <Unidentified data segment, offset 0x4c9>
private:
	char _UnidentifiedData_1225[3];

public:
	// <int32_t seLoadNoiseNo, offset 0x4cc>
	int32_t seLoadNoiseNo = 0;

	// <int32_t seLoadNoiseHandle, offset 0x4d0>
	int32_t seLoadNoiseHandle = 0;

	// <float seLoadNoisePitch, offset 0x4d4>
	float seLoadNoisePitch = 0;

	// <float seLoadNoiseVolume, offset 0x4d8>
	float seLoadNoiseVolume = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stBike [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stBike& InObject)
	{
		pGmf = InObject.pGmf;
		pGan = InObject.pGan;
		process = InObject.process;
		fallProcess = InObject.fallProcess;
		motionNo = InObject.motionNo;
		motionNumMax = InObject.motionNumMax;
		motionBrendNum = InObject.motionBrendNum;
		restoreMotionNo = InObject.restoreMotionNo;
		rotPerf = InObject.rotPerf;
		spdU = InObject.spdU;
		spdV = InObject.spdV;
		angSpd = InObject.angSpd;
		prevAngSpd = InObject.prevAngSpd;
		forceU = InObject.forceU;
		forceV = InObject.forceV;
		gripState = InObject.gripState;
		timerSlipTrigger = InObject.timerSlipTrigger;
		timerMaxSlipTrigger = InObject.timerMaxSlipTrigger;
		slipRate = InObject.slipRate;
		slipAngle = InObject.slipAngle;
		accelRate = InObject.accelRate;
		brakeRate = InObject.brakeRate;
		rudderAng = InObject.rudderAng;
		length = InObject.length;
		hitTame = InObject.hitTame;
		externForce = InObject.externForce;
		posYF = InObject.posYF;
		posYB = InObject.posYB;
		pos = InObject.pos;
		beforePos = InObject.beforePos;
		beforePosF = InObject.beforePosF;
		beforePosB = InObject.beforePosB;
		moveTempPos = InObject.moveTempPos;
		moveTempPosF = InObject.moveTempPosF;
		moveTempPosB = InObject.moveTempPosB;
		rot = InObject.rot;
		oldRot = InObject.oldRot;
		oldPosY = InObject.oldPosY;
		oldPosYF = InObject.oldPosYF;
		oldPosYB = InObject.oldPosYB;
		adjustRotY = InObject.adjustRotY;
		hitCheck = InObject.hitCheck;
		clash = InObject.clash;
		hitWall = InObject.hitWall;
		hitWall4Spin = InObject.hitWall4Spin;
		alwaysCheckHitColl = InObject.alwaysCheckHitColl;
		hp = InObject.hp;
		bgmHdl = InObject.bgmHdl;
		seHndlEngine = InObject.seHndlEngine;
		seHndlEngineNeutral = InObject.seHndlEngineNeutral;
		seHndlBreak = InObject.seHndlBreak;
		seHndlQBreak = InObject.seHndlQBreak;
		seHndlAir = InObject.seHndlAir;
		seHndlNitro = InObject.seHndlNitro;
		seHndSqueal = InObject.seHndSqueal;
		seVolEngine = InObject.seVolEngine;
		seVolEngineNeutral = InObject.seVolEngineNeutral;
		seVolBreak = InObject.seVolBreak;
		seVolQBreak = InObject.seVolQBreak;
		seVolAir = InObject.seVolAir;
		seVolNitro = InObject.seVolNitro;
		seVolSqueal = InObject.seVolSqueal;
		command = InObject.command;
		acc = InObject.acc;
		useNitro = InObject.useNitro;
		nitro = InObject.nitro;
		nitroStopTick = InObject.nitroStopTick;
		turnVal = InObject.turnVal;
		rimTurnVal = InObject.rimTurnVal;
		qBreakRotY = InObject.qBreakRotY;
		spinDir = InObject.spinDir;
		spinY = InObject.spinY;
		wiry = InObject.wiry;
		clashMySelf = InObject.clashMySelf;
		battle = InObject.battle;
		rideOnStart = InObject.rideOnStart;
		initHitJudge = InObject.initHitJudge;
		pushAcceling = InObject.pushAcceling;
		pushBreaking = InObject.pushBreaking;
		cantRideOn = InObject.cantRideOn;
		cantGetOff = InObject.cantGetOff;
		cantHandling = InObject.cantHandling;
		dispCantGetOff = InObject.dispCantGetOff;
		crash2Stand = InObject.crash2Stand;
		changeVolEngine = InObject.changeVolEngine;
		changeVolEngineIdle = InObject.changeVolEngineIdle;
		startWait = InObject.startWait;
		inputRelay = InObject.inputRelay;
		hitColl = InObject.hitColl;
		rideColl = InObject.rideColl;
		hitStgColl = InObject.hitStgColl;
		hitStgCollF = InObject.hitStgCollF;
		hitStgCollB = InObject.hitStgCollB;
		footHitResultObj = InObject.footHitResultObj;
		footHitResult = InObject.footHitResult;
		footHitResultObj2 = InObject.footHitResultObj2;
		pEvIcn = InObject.pEvIcn;
		texSpeed = InObject.texSpeed;
		cameraLength = InObject.cameraLength;
		cameraAngle = InObject.cameraAngle;
		rotZ = InObject.rotZ;
		forceHitStage = InObject.forceHitStage;
		crashFlag = InObject.crashFlag;
		damageCount = InObject.damageCount;
		prj = InObject.prj;
		modelAlpha = InObject.modelAlpha;
		m_inAmbientShadow = InObject.m_inAmbientShadow;
		muteSe = InObject.muteSe;
		seLoadNoiseNo = InObject.seLoadNoiseNo;
		seLoadNoiseHandle = InObject.seLoadNoiseHandle;
		seLoadNoisePitch = InObject.seLoadNoisePitch;
		seLoadNoiseVolume = InObject.seLoadNoiseVolume;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stBike>("stBike")
			.addFunction("__tostring", &stBike::ToString)
			.addFunction("GetPtrAddr", &stBike::GetPtrAddr)
			.addProperty("pGmf", &stBike::pGmf)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("pGan", &stBike::pGan)
			.addProperty("process", &stBike::process)
			.addProperty("fallProcess", &stBike::fallProcess)
			.addProperty("motionNo", &stBike::motionNo)
			.addProperty("motionNumMax", &stBike::motionNumMax)
			.addProperty("motionBrendNum", &stBike::motionBrendNum)
			.addProperty("restoreMotionNo", &stBike::restoreMotionNo)
			.addProperty("rotPerf", &stBike::rotPerf)
			.addProperty("spdU", &stBike::spdU)
			.addProperty("spdV", &stBike::spdV)
			.addProperty("angSpd", &stBike::angSpd)
			.addProperty("prevAngSpd", &stBike::prevAngSpd)
			.addProperty("forceU", &stBike::forceU)
			.addProperty("forceV", &stBike::forceV)
			.addProperty("gripState", &stBike::gripState)
			.addProperty("timerSlipTrigger", &stBike::timerSlipTrigger)
			.addProperty("timerMaxSlipTrigger", &stBike::timerMaxSlipTrigger)
			.addProperty("slipRate", &stBike::slipRate)
			.addProperty("slipAngle", &stBike::slipAngle)
			.addProperty("accelRate", &stBike::accelRate)
			.addProperty("brakeRate", &stBike::brakeRate)
			.addProperty("rudderAng", &stBike::rudderAng)
			.addProperty("length", &stBike::length)
			.addProperty("hitTame", &stBike::hitTame)
			.addProperty("externForce", &stBike::externForce)
			.addProperty("posYF", &stBike::posYF)
			.addProperty("posYB", &stBike::posYB)
			.addProperty("pos", &stBike::pos)
			.addProperty("beforePos", &stBike::beforePos)
			.addProperty("beforePosF", &stBike::beforePosF)
			.addProperty("beforePosB", &stBike::beforePosB)
			.addProperty("moveTempPos", &stBike::moveTempPos)
			.addProperty("moveTempPosF", &stBike::moveTempPosF)
			.addProperty("moveTempPosB", &stBike::moveTempPosB)
			.addProperty("rot", &stBike::rot)
			.addProperty("oldRot", &stBike::oldRot)
			.addProperty("oldPosY", &stBike::oldPosY)
			.addProperty("oldPosYF", &stBike::oldPosYF)
			.addProperty("oldPosYB", &stBike::oldPosYB)
			.addProperty("adjustRotY", &stBike::adjustRotY)
			.addProperty("hitCheck", &stBike::hitCheck)
			.addProperty("clash", &stBike::clash)
			.addProperty("hitWall", &stBike::hitWall)
			.addProperty("hitWall4Spin", &stBike::hitWall4Spin)
			.addProperty("alwaysCheckHitColl", &stBike::alwaysCheckHitColl)
			.addProperty("hp", &stBike::hp)
			.addProperty("bgmHdl", &stBike::bgmHdl)
			.addProperty("seHndlEngine", &stBike::seHndlEngine)
			.addProperty("seHndlEngineNeutral", &stBike::seHndlEngineNeutral)
			.addProperty("seHndlBreak", &stBike::seHndlBreak)
			.addProperty("seHndlQBreak", &stBike::seHndlQBreak)
			.addProperty("seHndlAir", &stBike::seHndlAir)
			.addProperty("seHndlNitro", &stBike::seHndlNitro)
			.addProperty("seHndSqueal", &stBike::seHndSqueal)
			.addProperty("seVolEngine", &stBike::seVolEngine)
			.addProperty("seVolEngineNeutral", &stBike::seVolEngineNeutral)
			.addProperty("seVolBreak", &stBike::seVolBreak)
			.addProperty("seVolQBreak", &stBike::seVolQBreak)
			.addProperty("seVolAir", &stBike::seVolAir)
			.addProperty("seVolNitro", &stBike::seVolNitro)
			.addProperty("seVolSqueal", &stBike::seVolSqueal)
			.addProperty("command", &stBike::command)
			.addProperty("acc", &stBike::acc)
			.addProperty("useNitro", &stBike::useNitro)
			.addProperty("nitro", &stBike::nitro)
			.addProperty("nitroStopTick", &stBike::nitroStopTick)
			.addProperty("turnVal", &stBike::turnVal)
			.addProperty("rimTurnVal", &stBike::rimTurnVal)
			.addProperty("qBreakRotY", &stBike::qBreakRotY)
			.addProperty("spinDir", &stBike::spinDir)
			.addProperty("spinY", &stBike::spinY)
			.addProperty("wiry", &stBike::wiry)
			.addProperty("clashMySelf", &stBike::clashMySelf)
			.addProperty("battle", &stBike::battle)
			.addProperty("rideOnStart", &stBike::rideOnStart)
			.addProperty("initHitJudge", &stBike::initHitJudge)
			.addProperty("pushAcceling", &stBike::pushAcceling)
			.addProperty("pushBreaking", &stBike::pushBreaking)
			.addProperty("cantRideOn", &stBike::cantRideOn)
			.addProperty("cantGetOff", &stBike::cantGetOff)
			.addProperty("cantHandling", &stBike::cantHandling)
			.addProperty("dispCantGetOff", &stBike::dispCantGetOff)
			.addProperty("crash2Stand", &stBike::crash2Stand)
			.addProperty("changeVolEngine", &stBike::changeVolEngine)
			.addProperty("changeVolEngineIdle", &stBike::changeVolEngineIdle)
			.addProperty("startWait", &stBike::startWait)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("rateTbl", &stBike::rateTbl)
			.addProperty("inputRelay", &stBike::inputRelay)
			.addProperty("hitColl", &stBike::hitColl)
			.addProperty("rideColl", &stBike::rideColl)
			.addProperty("hitStgColl", &stBike::hitStgColl)
			.addProperty("hitStgCollF", &stBike::hitStgCollF)
			.addProperty("hitStgCollB", &stBike::hitStgCollB)
			.addProperty("footHitResultObj", &stBike::footHitResultObj)
			.addProperty("footHitResult", &stBike::footHitResult)
			.addProperty("footHitResultObj2", &stBike::footHitResultObj2)
			.addProperty("pEvIcn", &stBike::pEvIcn)
			.addProperty("texSpeed", &stBike::texSpeed)
			.addProperty("cameraLength", &stBike::cameraLength)
			.addProperty("cameraAngle", &stBike::cameraAngle)
			.addProperty("rotZ", &stBike::rotZ)
			.addProperty("forceHitStage", &stBike::forceHitStage)
			.addProperty("crashFlag", &stBike::crashFlag)
			.addProperty("damageCount", &stBike::damageCount)
			.addProperty("prj", &stBike::prj)
			.addProperty("modelAlpha", &stBike::modelAlpha)
			.addProperty("m_inAmbientShadow", &stBike::m_inAmbientShadow)
			.addProperty("muteSe", &stBike::muteSe)
			.addProperty("seLoadNoiseNo", &stBike::seLoadNoiseNo)
			.addProperty("seLoadNoiseHandle", &stBike::seLoadNoiseHandle)
			.addProperty("seLoadNoisePitch", &stBike::seLoadNoisePitch)
			.addProperty("seLoadNoiseVolume", &stBike::seLoadNoiseVolume)
		.endClass();
	}
#endif
};
static_assert(sizeof(stBike::pGmf) == 4, "expected stBike::pGmf to be size 4");
static_assert(sizeof(stBike::pGan) == 4, "expected stBike::pGan to be size 4");
static_assert(sizeof(stBike::process) == 4, "expected stBike::process to be size 4");
static_assert(sizeof(stBike::fallProcess) == 4, "expected stBike::fallProcess to be size 4");
static_assert(sizeof(stBike::motionNo) == 4, "expected stBike::motionNo to be size 4");
static_assert(sizeof(stBike::motionNumMax) == 4, "expected stBike::motionNumMax to be size 4");
static_assert(sizeof(stBike::motionBrendNum) == 4, "expected stBike::motionBrendNum to be size 4");
static_assert(sizeof(stBike::restoreMotionNo) == 4, "expected stBike::restoreMotionNo to be size 4");
static_assert(sizeof(stBike::rotPerf) == 4, "expected stBike::rotPerf to be size 4");
static_assert(sizeof(stBike::spdU) == 4, "expected stBike::spdU to be size 4");
static_assert(sizeof(stBike::spdV) == 4, "expected stBike::spdV to be size 4");
static_assert(sizeof(stBike::angSpd) == 4, "expected stBike::angSpd to be size 4");
static_assert(sizeof(stBike::prevAngSpd) == 4, "expected stBike::prevAngSpd to be size 4");
static_assert(sizeof(stBike::forceU) == 4, "expected stBike::forceU to be size 4");
static_assert(sizeof(stBike::forceV) == 4, "expected stBike::forceV to be size 4");
static_assert(sizeof(stBike::gripState) == 4, "expected stBike::gripState to be size 4");
static_assert(sizeof(stBike::timerSlipTrigger) == 4, "expected stBike::timerSlipTrigger to be size 4");
static_assert(sizeof(stBike::timerMaxSlipTrigger) == 4, "expected stBike::timerMaxSlipTrigger to be size 4");
static_assert(sizeof(stBike::slipRate) == 4, "expected stBike::slipRate to be size 4");
static_assert(sizeof(stBike::slipAngle) == 4, "expected stBike::slipAngle to be size 4");
static_assert(sizeof(stBike::accelRate) == 4, "expected stBike::accelRate to be size 4");
static_assert(sizeof(stBike::brakeRate) == 4, "expected stBike::brakeRate to be size 4");
static_assert(sizeof(stBike::rudderAng) == 4, "expected stBike::rudderAng to be size 4");
static_assert(sizeof(stBike::length) == 4, "expected stBike::length to be size 4");
static_assert(sizeof(stBike::hitTame) == 4, "expected stBike::hitTame to be size 4");
static_assert(sizeof(stBike::externForce) == 12, "expected stBike::externForce to be size 12");
static_assert(sizeof(stBike::posYF) == 4, "expected stBike::posYF to be size 4");
static_assert(sizeof(stBike::posYB) == 4, "expected stBike::posYB to be size 4");
static_assert(sizeof(stBike::pos) == 12, "expected stBike::pos to be size 12");
static_assert(sizeof(stBike::beforePos) == 12, "expected stBike::beforePos to be size 12");
static_assert(sizeof(stBike::beforePosF) == 12, "expected stBike::beforePosF to be size 12");
static_assert(sizeof(stBike::beforePosB) == 12, "expected stBike::beforePosB to be size 12");
static_assert(sizeof(stBike::moveTempPos) == 12, "expected stBike::moveTempPos to be size 12");
static_assert(sizeof(stBike::moveTempPosF) == 12, "expected stBike::moveTempPosF to be size 12");
static_assert(sizeof(stBike::moveTempPosB) == 12, "expected stBike::moveTempPosB to be size 12");
static_assert(sizeof(stBike::rot) == 12, "expected stBike::rot to be size 12");
static_assert(sizeof(stBike::oldRot) == 12, "expected stBike::oldRot to be size 12");
static_assert(sizeof(stBike::oldPosY) == 4, "expected stBike::oldPosY to be size 4");
static_assert(sizeof(stBike::oldPosYF) == 4, "expected stBike::oldPosYF to be size 4");
static_assert(sizeof(stBike::oldPosYB) == 4, "expected stBike::oldPosYB to be size 4");
static_assert(sizeof(stBike::adjustRotY) == 4, "expected stBike::adjustRotY to be size 4");
static_assert(sizeof(stBike::hitCheck) == 1, "expected stBike::hitCheck to be size 1");
static_assert(sizeof(stBike::clash) == 1, "expected stBike::clash to be size 1");
static_assert(sizeof(stBike::hitWall) == 1, "expected stBike::hitWall to be size 1");
static_assert(sizeof(stBike::hitWall4Spin) == 1, "expected stBike::hitWall4Spin to be size 1");
static_assert(sizeof(stBike::alwaysCheckHitColl) == 1, "expected stBike::alwaysCheckHitColl to be size 1");
static_assert(sizeof(stBike::hp) == 4, "expected stBike::hp to be size 4");
static_assert(sizeof(stBike::bgmHdl) == 4, "expected stBike::bgmHdl to be size 4");
static_assert(sizeof(stBike::seHndlEngine) == 4, "expected stBike::seHndlEngine to be size 4");
static_assert(sizeof(stBike::seHndlEngineNeutral) == 4, "expected stBike::seHndlEngineNeutral to be size 4");
static_assert(sizeof(stBike::seHndlBreak) == 4, "expected stBike::seHndlBreak to be size 4");
static_assert(sizeof(stBike::seHndlQBreak) == 4, "expected stBike::seHndlQBreak to be size 4");
static_assert(sizeof(stBike::seHndlAir) == 4, "expected stBike::seHndlAir to be size 4");
static_assert(sizeof(stBike::seHndlNitro) == 4, "expected stBike::seHndlNitro to be size 4");
static_assert(sizeof(stBike::seHndSqueal) == 4, "expected stBike::seHndSqueal to be size 4");
static_assert(sizeof(stBike::seVolEngine) == 4, "expected stBike::seVolEngine to be size 4");
static_assert(sizeof(stBike::seVolEngineNeutral) == 4, "expected stBike::seVolEngineNeutral to be size 4");
static_assert(sizeof(stBike::seVolBreak) == 4, "expected stBike::seVolBreak to be size 4");
static_assert(sizeof(stBike::seVolQBreak) == 4, "expected stBike::seVolQBreak to be size 4");
static_assert(sizeof(stBike::seVolAir) == 4, "expected stBike::seVolAir to be size 4");
static_assert(sizeof(stBike::seVolNitro) == 4, "expected stBike::seVolNitro to be size 4");
static_assert(sizeof(stBike::seVolSqueal) == 4, "expected stBike::seVolSqueal to be size 4");
static_assert(sizeof(stBike::command) == 4, "expected stBike::command to be size 4");
static_assert(sizeof(stBike::acc) == 4, "expected stBike::acc to be size 4");
static_assert(sizeof(stBike::useNitro) == 1, "expected stBike::useNitro to be size 1");
static_assert(sizeof(stBike::nitro) == 4, "expected stBike::nitro to be size 4");
static_assert(sizeof(stBike::nitroStopTick) == 4, "expected stBike::nitroStopTick to be size 4");
static_assert(sizeof(stBike::turnVal) == 4, "expected stBike::turnVal to be size 4");
static_assert(sizeof(stBike::rimTurnVal) == 4, "expected stBike::rimTurnVal to be size 4");
static_assert(sizeof(stBike::qBreakRotY) == 4, "expected stBike::qBreakRotY to be size 4");
static_assert(sizeof(stBike::spinDir) == 4, "expected stBike::spinDir to be size 4");
static_assert(sizeof(stBike::spinY) == 4, "expected stBike::spinY to be size 4");
static_assert(sizeof(stBike::wiry) == 1, "expected stBike::wiry to be size 1");
static_assert(sizeof(stBike::clashMySelf) == 1, "expected stBike::clashMySelf to be size 1");
static_assert(sizeof(stBike::battle) == 1, "expected stBike::battle to be size 1");
static_assert(sizeof(stBike::rideOnStart) == 1, "expected stBike::rideOnStart to be size 1");
static_assert(sizeof(stBike::initHitJudge) == 1, "expected stBike::initHitJudge to be size 1");
static_assert(sizeof(stBike::pushAcceling) == 1, "expected stBike::pushAcceling to be size 1");
static_assert(sizeof(stBike::pushBreaking) == 1, "expected stBike::pushBreaking to be size 1");
static_assert(sizeof(stBike::cantRideOn) == 1, "expected stBike::cantRideOn to be size 1");
static_assert(sizeof(stBike::cantGetOff) == 1, "expected stBike::cantGetOff to be size 1");
static_assert(sizeof(stBike::cantHandling) == 1, "expected stBike::cantHandling to be size 1");
static_assert(sizeof(stBike::dispCantGetOff) == 1, "expected stBike::dispCantGetOff to be size 1");
static_assert(sizeof(stBike::crash2Stand) == 1, "expected stBike::crash2Stand to be size 1");
static_assert(sizeof(stBike::changeVolEngine) == 1, "expected stBike::changeVolEngine to be size 1");
static_assert(sizeof(stBike::changeVolEngineIdle) == 1, "expected stBike::changeVolEngineIdle to be size 1");
static_assert(sizeof(stBike::startWait) == 4, "expected stBike::startWait to be size 4");
static_assert(sizeof(stBike::rateTbl) == 12, "expected stBike::rateTbl to be size 12");
static_assert(sizeof(stBike::inputRelay) == 32, "expected stBike::inputRelay to be size 32");
static_assert(sizeof(stBike::hitColl) == 96, "expected stBike::hitColl to be size 96");
static_assert(sizeof(stBike::rideColl) == 96, "expected stBike::rideColl to be size 96");
static_assert(sizeof(stBike::hitStgColl) == 96, "expected stBike::hitStgColl to be size 96");
static_assert(sizeof(stBike::hitStgCollF) == 96, "expected stBike::hitStgCollF to be size 96");
static_assert(sizeof(stBike::hitStgCollB) == 96, "expected stBike::hitStgCollB to be size 96");
static_assert(sizeof(stBike::footHitResultObj) == 4, "expected stBike::footHitResultObj to be size 4");
static_assert(sizeof(stBike::footHitResult) == 4, "expected stBike::footHitResult to be size 4");
static_assert(sizeof(stBike::footHitResultObj2) == 76, "expected stBike::footHitResultObj2 to be size 76");
static_assert(sizeof(stBike::pEvIcn) == 4, "expected stBike::pEvIcn to be size 4");
static_assert(sizeof(stBike::texSpeed) == 40, "expected stBike::texSpeed to be size 40");
static_assert(sizeof(stBike::cameraLength) == 32, "expected stBike::cameraLength to be size 32");
static_assert(sizeof(stBike::cameraAngle) == 32, "expected stBike::cameraAngle to be size 32");
static_assert(sizeof(stBike::rotZ) == 4, "expected stBike::rotZ to be size 4");
static_assert(sizeof(stBike::forceHitStage) == 1, "expected stBike::forceHitStage to be size 1");
static_assert(sizeof(stBike::crashFlag) == 1, "expected stBike::crashFlag to be size 1");
static_assert(sizeof(stBike::damageCount) == 4, "expected stBike::damageCount to be size 4");
static_assert(sizeof(stBike::prj) == 32, "expected stBike::prj to be size 32");
static_assert(sizeof(stBike::modelAlpha) == 32, "expected stBike::modelAlpha to be size 32");
static_assert(sizeof(stBike::m_inAmbientShadow) == 56, "expected stBike::m_inAmbientShadow to be size 56");
static_assert(sizeof(stBike::muteSe) == 1, "expected stBike::muteSe to be size 1");
static_assert(sizeof(stBike::seLoadNoiseNo) == 4, "expected stBike::seLoadNoiseNo to be size 4");
static_assert(sizeof(stBike::seLoadNoiseHandle) == 4, "expected stBike::seLoadNoiseHandle to be size 4");
static_assert(sizeof(stBike::seLoadNoisePitch) == 4, "expected stBike::seLoadNoisePitch to be size 4");
static_assert(sizeof(stBike::seLoadNoiseVolume) == 4, "expected stBike::seLoadNoiseVolume to be size 4");
static_assert(sizeof(stBike) == 0x4dc, "expected stBike to be size 0x4dc");

// [Structure] class mHRBike
class mHRBike
{
public:
	/// Struct member variables

	// <struct stBike mBike, offset 0x0>
	struct stBike mBike;

	// <struct stBikeEffect mBikeEffect, offset 0x4dc>
	struct stBikeEffect mBikeEffect;

	// <uint8_t mhitStage, offset 0x504>
	uint8_t mhitStage = 0;

	// <Unidentified data segment, offset 0x505>
private:
	char _UnidentifiedData_1285[3];

public:
	// <float mWryRate, offset 0x508>
	float mWryRate = 0;

	// <float mBankRate, offset 0x50c>
	float mBankRate = 0;

	// <struct Vec mDamegeDir, offset 0x510>
	struct Vec mDamegeDir;

	// <float mDamegeRotY, offset 0x51c>
	float mDamegeRotY = 0;

	// <float mAccel, offset 0x520>
	float mAccel = 0;

	// <struct Vec mPassRot, offset 0x524>
	struct Vec mPassRot;

	// <int32_t mFireSEID, offset 0x530>
	int32_t mFireSEID = 0;

	// <float mHitWait, offset 0x534>
	float mHitWait = 0;

	// <uint8_t mRotLock, offset 0x538>
	uint8_t mRotLock = 0;

	// <uint8_t mBkAtkOk, offset 0x539>
	uint8_t mBkAtkOk = 0;

	// <uint8_t m_bIsDrawShadow, offset 0x53a>
	uint8_t m_bIsDrawShadow = 0;

	// <uint8_t m_boForceDisableDrawShadow, offset 0x53b>
	uint8_t m_boForceDisableDrawShadow = 0;

	// <class CObjectShadow m_inObjectShadow, offset 0x53c>
	class CObjectShadow m_inObjectShadow;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class mHRBike [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(mHRBike& InObject)
	{
		mBike = InObject.mBike;
		mBikeEffect = InObject.mBikeEffect;
		mhitStage = InObject.mhitStage;
		mWryRate = InObject.mWryRate;
		mBankRate = InObject.mBankRate;
		mDamegeDir = InObject.mDamegeDir;
		mDamegeRotY = InObject.mDamegeRotY;
		mAccel = InObject.mAccel;
		mPassRot = InObject.mPassRot;
		mFireSEID = InObject.mFireSEID;
		mHitWait = InObject.mHitWait;
		mRotLock = InObject.mRotLock;
		mBkAtkOk = InObject.mBkAtkOk;
		m_bIsDrawShadow = InObject.m_bIsDrawShadow;
		m_boForceDisableDrawShadow = InObject.m_boForceDisableDrawShadow;
		m_inObjectShadow = InObject.m_inObjectShadow;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRBike>("mHRBike")
			.addFunction("__tostring", &mHRBike::ToString)
			.addFunction("GetPtrAddr", &mHRBike::GetPtrAddr)
			.addProperty("mBike", &mHRBike::mBike)
			.addProperty("mBikeEffect", &mHRBike::mBikeEffect)
			.addProperty("mhitStage", &mHRBike::mhitStage)
			.addProperty("mWryRate", &mHRBike::mWryRate)
			.addProperty("mBankRate", &mHRBike::mBankRate)
			.addProperty("mDamegeDir", &mHRBike::mDamegeDir)
			.addProperty("mDamegeRotY", &mHRBike::mDamegeRotY)
			.addProperty("mAccel", &mHRBike::mAccel)
			.addProperty("mPassRot", &mHRBike::mPassRot)
			.addProperty("mFireSEID", &mHRBike::mFireSEID)
			.addProperty("mHitWait", &mHRBike::mHitWait)
			.addProperty("mRotLock", &mHRBike::mRotLock)
			.addProperty("mBkAtkOk", &mHRBike::mBkAtkOk)
			.addProperty("m_bIsDrawShadow", &mHRBike::m_bIsDrawShadow)
			.addProperty("m_boForceDisableDrawShadow", &mHRBike::m_boForceDisableDrawShadow)
			.addProperty("m_inObjectShadow", &mHRBike::m_inObjectShadow)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRBike::mBike) == 1244, "expected mHRBike::mBike to be size 1244");
static_assert(sizeof(mHRBike::mBikeEffect) == 40, "expected mHRBike::mBikeEffect to be size 40");
static_assert(sizeof(mHRBike::mhitStage) == 1, "expected mHRBike::mhitStage to be size 1");
static_assert(sizeof(mHRBike::mWryRate) == 4, "expected mHRBike::mWryRate to be size 4");
static_assert(sizeof(mHRBike::mBankRate) == 4, "expected mHRBike::mBankRate to be size 4");
static_assert(sizeof(mHRBike::mDamegeDir) == 12, "expected mHRBike::mDamegeDir to be size 12");
static_assert(sizeof(mHRBike::mDamegeRotY) == 4, "expected mHRBike::mDamegeRotY to be size 4");
static_assert(sizeof(mHRBike::mAccel) == 4, "expected mHRBike::mAccel to be size 4");
static_assert(sizeof(mHRBike::mPassRot) == 12, "expected mHRBike::mPassRot to be size 12");
static_assert(sizeof(mHRBike::mFireSEID) == 4, "expected mHRBike::mFireSEID to be size 4");
static_assert(sizeof(mHRBike::mHitWait) == 4, "expected mHRBike::mHitWait to be size 4");
static_assert(sizeof(mHRBike::mRotLock) == 1, "expected mHRBike::mRotLock to be size 1");
static_assert(sizeof(mHRBike::mBkAtkOk) == 1, "expected mHRBike::mBkAtkOk to be size 1");
static_assert(sizeof(mHRBike::m_bIsDrawShadow) == 1, "expected mHRBike::m_bIsDrawShadow to be size 1");
static_assert(sizeof(mHRBike::m_boForceDisableDrawShadow) == 1, "expected mHRBike::m_boForceDisableDrawShadow to be size 1");
static_assert(sizeof(mHRBike::m_inObjectShadow) == 112, "expected mHRBike::m_inObjectShadow to be size 112");
static_assert(sizeof(mHRBike) == 0x5ac, "expected mHRBike to be size 0x5ac");

// [Structure] class EventAreaCircle
class EventAreaCircle : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <int32_t m_Kind, offset 0x10>
	int32_t m_Kind = 0;

	// <struct Vec m_Center, offset 0x14>
	struct Vec m_Center;

	// <float m_sRadius, offset 0x20>
	float m_sRadius = 0;

	// <float m_Rot, offset 0x24>
	float m_Rot = 0;

	// <float m_Scale, offset 0x28>
	float m_Scale = 0;

	// <float m_ScaleHoshi, offset 0x2c>
	float m_ScaleHoshi = 0;

	// <float m_MinScale, offset 0x30>
	float m_MinScale = 0;

	// <float m_MaxScale, offset 0x34>
	float m_MaxScale = 0;

	// <int32_t m_Alpha, offset 0x38>
	int32_t m_Alpha = 0;

	// <uint8_t m_Done, offset 0x3c>
	uint8_t m_Done = 0;

	// <uint8_t m_PcPlayMotionDone, offset 0x3d>
	uint8_t m_PcPlayMotionDone = 0;

	// <uint8_t m_PcMoveDone, offset 0x3e>
	uint8_t m_PcMoveDone = 0;

	// <uint8_t m_firsttouch, offset 0x3f>
	uint8_t m_firsttouch = 0;

	// <uint8_t m_nowtouch, offset 0x40>
	uint8_t m_nowtouch = 0;

	// <char m_EventName[0x20], offset 0x41>
	char m_EventName[32];

	// <char m_StageName[0x10], offset 0x61>
	char m_StageName[16];

	// <Unidentified data segment, offset 0x71>
private:
	char _UnidentifiedData_113[3];

public:
	// <uint32_t m_HrScriptHandle, offset 0x74>
	uint32_t m_HrScriptHandle = 0;

	// <uint8_t m_PlayBossCornMotionFlag, offset 0x78>
	uint8_t m_PlayBossCornMotionFlag = 0;

	// <Unidentified data segment, offset 0x79>
private:
	char _UnidentifiedData_121[3];

public:
	// <class TGmf* m_pCornGmf, offset 0x7c>
	class TGmf* m_pCornGmf = nullptr;

	// <class TGmf* m_pCornSleepGmf, offset 0x80>
	class TGmf* m_pCornSleepGmf = nullptr;

	// <class TGmf* m_pCornShadowGmf, offset 0x84>
	class TGmf* m_pCornShadowGmf = nullptr;

	// <int32_t m_pCornShadowGanNum, offset 0x88>
	int32_t m_pCornShadowGanNum = 0;

	// <class TGan** m_pCornShadowGan, offset 0x8c>
	class TGan** m_pCornShadowGan = nullptr;

	// <uint8_t m_PlaySe[0x2], offset 0x90>
	uint8_t m_PlaySe[2];

	// <Unidentified data segment, offset 0x92>
private:
	char _UnidentifiedData_146[2];

public:
	// <int32_t m_MakerType, offset 0x94>
	int32_t m_MakerType = 0;

	// <int32_t m_SignboardType, offset 0x98>
	int32_t m_SignboardType = 0;

	// <int32_t m_Sleep, offset 0x9c>
	int32_t m_Sleep = 0;

	// <int32_t m_SleepAlpha, offset 0xa0>
	int32_t m_SleepAlpha = 0;

	// <int32_t m_SleepTick, offset 0xa4>
	int32_t m_SleepTick = 0;

	// <uint8_t m_WakeUpCameraEffect, offset 0xa8>
	uint8_t m_WakeUpCameraEffect = 0;

	// <uint8_t m_Visible, offset 0xa9>
	uint8_t m_Visible = 0;

	// <Unidentified data segment, offset 0xaa>
private:
	char _UnidentifiedData_170[2];

public:
	// <int32_t m_SleepMessage, offset 0xac>
	int32_t m_SleepMessage = 0;

	// <int32_t m_SleepMessageProc, offset 0xb0>
	int32_t m_SleepMessageProc = 0;

	// <int32_t mBackDispStatusDisEnable, offset 0xb4>
	int32_t mBackDispStatusDisEnable = 0;

	// <int32_t m_EventRunEffectProcess, offset 0xb8>
	int32_t m_EventRunEffectProcess = 0;

	// <int32_t m_EventRunEffectBit, offset 0xbc>
	int32_t m_EventRunEffectBit = 0;

	// <uint8_t m_CameraOff, offset 0xc0>
	uint8_t m_CameraOff = 0;

	// <uint8_t mCameraPosSetType, offset 0xc1>
	uint8_t mCameraPosSetType = 0;

	// <Unidentified data segment, offset 0xc2>
private:
	char _UnidentifiedData_194[2];

public:
	// <struct Vec mCameraPos, offset 0xc4>
	struct Vec mCameraPos;

	// <struct Vec mCameraTargetPos, offset 0xd0>
	struct Vec mCameraTargetPos;

	// <uint8_t mPcPosSetType, offset 0xdc>
	uint8_t mPcPosSetType = 0;

	// <Unidentified data segment, offset 0xdd>
private:
	char _UnidentifiedData_221[3];

public:
	// <struct Vec mPcPos, offset 0xe0>
	struct Vec mPcPos;

	// <float mCenterRotY, offset 0xec>
	float mCenterRotY = 0;

	// <float mPcRotY, offset 0xf0>
	float mPcRotY = 0;

	// <class HrScriptFunc* mpEventAreaCircleScriptFunc, offset 0xf4>
	class HrScriptFunc* mpEventAreaCircleScriptFunc = nullptr;

	// <int32_t mFunctionCallCount, offset 0xf8>
	int32_t mFunctionCallCount = 0;

	// <int32_t mFunctionCallType, offset 0xfc>
	int32_t mFunctionCallType = 0;

	// <int32_t mPcMotionID, offset 0x100>
	int32_t mPcMotionID = 0;

	// <int32_t mPcMoveFrame, offset 0x104>
	int32_t mPcMoveFrame = 0;

	// <uint8_t mDelete, offset 0x108>
	uint8_t mDelete = 0;

	// <Unidentified data segment, offset 0x109>
private:
	char _UnidentifiedData_265[3];

public:
	// <class EveCorn* mpEveCorn, offset 0x10c>
	class EveCorn* mpEveCorn = nullptr;

	// <uint8_t mEveCornVisible, offset 0x110>
	uint8_t mEveCornVisible = 0;

	// <Unidentified data segment, offset 0x111>
private:
	char _UnidentifiedData_273[3];

public:
	// <int32_t mEveCornRefreshCnt, offset 0x114>
	int32_t mEveCornRefreshCnt = 0;

	// <uint8_t mEventEndCameraHold, offset 0x118>
	uint8_t mEventEndCameraHold = 0;

	// <uint8_t mFlash, offset 0x119>
	uint8_t mFlash = 0;

	// <uint8_t mFlashSE, offset 0x11a>
	uint8_t mFlashSE = 0;

	// <Unidentified data segment, offset 0x11b>
private:
	char _UnidentifiedData_283[1];

public:
	// <int32_t mFlashCounter, offset 0x11c>
	int32_t mFlashCounter = 0;

	// <uint8_t mBikeRide, offset 0x120>
	uint8_t mBikeRide = 0;

	// <Unidentified data segment, offset 0x121>
private:
	char _UnidentifiedData_289[3];

public:
	// <class EventAreaCamera* mpEventAreaCamera, offset 0x124>
	class EventAreaCamera* mpEventAreaCamera = nullptr;

	// <class EventAreaCamera* mpSleepWakeUpCamera, offset 0x128>
	class EventAreaCamera* mpSleepWakeUpCamera = nullptr;

	// <uint32_t m_AreaCircleEventHandle, offset 0x12c>
	uint32_t m_AreaCircleEventHandle = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EventAreaCircle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EventAreaCircle& InObject)
	{
		m_Kind = InObject.m_Kind;
		m_Center = InObject.m_Center;
		m_sRadius = InObject.m_sRadius;
		m_Rot = InObject.m_Rot;
		m_Scale = InObject.m_Scale;
		m_ScaleHoshi = InObject.m_ScaleHoshi;
		m_MinScale = InObject.m_MinScale;
		m_MaxScale = InObject.m_MaxScale;
		m_Alpha = InObject.m_Alpha;
		m_Done = InObject.m_Done;
		m_PcPlayMotionDone = InObject.m_PcPlayMotionDone;
		m_PcMoveDone = InObject.m_PcMoveDone;
		m_firsttouch = InObject.m_firsttouch;
		m_nowtouch = InObject.m_nowtouch;
		m_HrScriptHandle = InObject.m_HrScriptHandle;
		m_PlayBossCornMotionFlag = InObject.m_PlayBossCornMotionFlag;
		m_pCornGmf = InObject.m_pCornGmf;
		m_pCornSleepGmf = InObject.m_pCornSleepGmf;
		m_pCornShadowGmf = InObject.m_pCornShadowGmf;
		m_pCornShadowGanNum = InObject.m_pCornShadowGanNum;
		m_pCornShadowGan = InObject.m_pCornShadowGan;
		m_MakerType = InObject.m_MakerType;
		m_SignboardType = InObject.m_SignboardType;
		m_Sleep = InObject.m_Sleep;
		m_SleepAlpha = InObject.m_SleepAlpha;
		m_SleepTick = InObject.m_SleepTick;
		m_WakeUpCameraEffect = InObject.m_WakeUpCameraEffect;
		m_Visible = InObject.m_Visible;
		m_SleepMessage = InObject.m_SleepMessage;
		m_SleepMessageProc = InObject.m_SleepMessageProc;
		mBackDispStatusDisEnable = InObject.mBackDispStatusDisEnable;
		m_EventRunEffectProcess = InObject.m_EventRunEffectProcess;
		m_EventRunEffectBit = InObject.m_EventRunEffectBit;
		m_CameraOff = InObject.m_CameraOff;
		mCameraPosSetType = InObject.mCameraPosSetType;
		mCameraPos = InObject.mCameraPos;
		mCameraTargetPos = InObject.mCameraTargetPos;
		mPcPosSetType = InObject.mPcPosSetType;
		mPcPos = InObject.mPcPos;
		mCenterRotY = InObject.mCenterRotY;
		mPcRotY = InObject.mPcRotY;
		mpEventAreaCircleScriptFunc = InObject.mpEventAreaCircleScriptFunc;
		mFunctionCallCount = InObject.mFunctionCallCount;
		mFunctionCallType = InObject.mFunctionCallType;
		mPcMotionID = InObject.mPcMotionID;
		mPcMoveFrame = InObject.mPcMoveFrame;
		mDelete = InObject.mDelete;
		mpEveCorn = InObject.mpEveCorn;
		mEveCornVisible = InObject.mEveCornVisible;
		mEveCornRefreshCnt = InObject.mEveCornRefreshCnt;
		mEventEndCameraHold = InObject.mEventEndCameraHold;
		mFlash = InObject.mFlash;
		mFlashSE = InObject.mFlashSE;
		mFlashCounter = InObject.mFlashCounter;
		mBikeRide = InObject.mBikeRide;
		mpEventAreaCamera = InObject.mpEventAreaCamera;
		mpSleepWakeUpCamera = InObject.mpSleepWakeUpCamera;
		m_AreaCircleEventHandle = InObject.m_AreaCircleEventHandle;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EventAreaCircle, ghmListObj>("EventAreaCircle")
			.addFunction("__tostring", &EventAreaCircle::ToString)
			.addFunction("GetPtrAddr", &EventAreaCircle::GetPtrAddr)
			.addProperty("m_Kind", &EventAreaCircle::m_Kind)
			.addProperty("m_Center", &EventAreaCircle::m_Center)
			.addProperty("m_sRadius", &EventAreaCircle::m_sRadius)
			.addProperty("m_Rot", &EventAreaCircle::m_Rot)
			.addProperty("m_Scale", &EventAreaCircle::m_Scale)
			.addProperty("m_ScaleHoshi", &EventAreaCircle::m_ScaleHoshi)
			.addProperty("m_MinScale", &EventAreaCircle::m_MinScale)
			.addProperty("m_MaxScale", &EventAreaCircle::m_MaxScale)
			.addProperty("m_Alpha", &EventAreaCircle::m_Alpha)
			.addProperty("m_Done", &EventAreaCircle::m_Done)
			.addProperty("m_PcPlayMotionDone", &EventAreaCircle::m_PcPlayMotionDone)
			.addProperty("m_PcMoveDone", &EventAreaCircle::m_PcMoveDone)
			.addProperty("m_firsttouch", &EventAreaCircle::m_firsttouch)
			.addProperty("m_nowtouch", &EventAreaCircle::m_nowtouch)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_EventName", &EventAreaCircle::m_EventName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StageName", &EventAreaCircle::m_StageName)
			.addProperty("m_HrScriptHandle", &EventAreaCircle::m_HrScriptHandle)
			.addProperty("m_PlayBossCornMotionFlag", &EventAreaCircle::m_PlayBossCornMotionFlag)
			.addProperty("m_pCornGmf", &EventAreaCircle::m_pCornGmf)
			.addProperty("m_pCornSleepGmf", &EventAreaCircle::m_pCornSleepGmf)
			.addProperty("m_pCornShadowGmf", &EventAreaCircle::m_pCornShadowGmf)
			.addProperty("m_pCornShadowGanNum", &EventAreaCircle::m_pCornShadowGanNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("m_pCornShadowGan", &EventAreaCircle::m_pCornShadowGan)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_PlaySe", &EventAreaCircle::m_PlaySe)
			.addProperty("m_MakerType", &EventAreaCircle::m_MakerType)
			.addProperty("m_SignboardType", &EventAreaCircle::m_SignboardType)
			.addProperty("m_Sleep", &EventAreaCircle::m_Sleep)
			.addProperty("m_SleepAlpha", &EventAreaCircle::m_SleepAlpha)
			.addProperty("m_SleepTick", &EventAreaCircle::m_SleepTick)
			.addProperty("m_WakeUpCameraEffect", &EventAreaCircle::m_WakeUpCameraEffect)
			.addProperty("m_Visible", &EventAreaCircle::m_Visible)
			.addProperty("m_SleepMessage", &EventAreaCircle::m_SleepMessage)
			.addProperty("m_SleepMessageProc", &EventAreaCircle::m_SleepMessageProc)
			.addProperty("mBackDispStatusDisEnable", &EventAreaCircle::mBackDispStatusDisEnable)
			.addProperty("m_EventRunEffectProcess", &EventAreaCircle::m_EventRunEffectProcess)
			.addProperty("m_EventRunEffectBit", &EventAreaCircle::m_EventRunEffectBit)
			.addProperty("m_CameraOff", &EventAreaCircle::m_CameraOff)
			.addProperty("mCameraPosSetType", &EventAreaCircle::mCameraPosSetType)
			.addProperty("mCameraPos", &EventAreaCircle::mCameraPos)
			.addProperty("mCameraTargetPos", &EventAreaCircle::mCameraTargetPos)
			.addProperty("mPcPosSetType", &EventAreaCircle::mPcPosSetType)
			.addProperty("mPcPos", &EventAreaCircle::mPcPos)
			.addProperty("mCenterRotY", &EventAreaCircle::mCenterRotY)
			.addProperty("mPcRotY", &EventAreaCircle::mPcRotY)
			.addProperty("mpEventAreaCircleScriptFunc", &EventAreaCircle::mpEventAreaCircleScriptFunc)
			.addProperty("mFunctionCallCount", &EventAreaCircle::mFunctionCallCount)
			.addProperty("mFunctionCallType", &EventAreaCircle::mFunctionCallType)
			.addProperty("mPcMotionID", &EventAreaCircle::mPcMotionID)
			.addProperty("mPcMoveFrame", &EventAreaCircle::mPcMoveFrame)
			.addProperty("mDelete", &EventAreaCircle::mDelete)
			.addProperty("mpEveCorn", &EventAreaCircle::mpEveCorn)
			.addProperty("mEveCornVisible", &EventAreaCircle::mEveCornVisible)
			.addProperty("mEveCornRefreshCnt", &EventAreaCircle::mEveCornRefreshCnt)
			.addProperty("mEventEndCameraHold", &EventAreaCircle::mEventEndCameraHold)
			.addProperty("mFlash", &EventAreaCircle::mFlash)
			.addProperty("mFlashSE", &EventAreaCircle::mFlashSE)
			.addProperty("mFlashCounter", &EventAreaCircle::mFlashCounter)
			.addProperty("mBikeRide", &EventAreaCircle::mBikeRide)
			.addProperty("mpEventAreaCamera", &EventAreaCircle::mpEventAreaCamera)
			.addProperty("mpSleepWakeUpCamera", &EventAreaCircle::mpSleepWakeUpCamera)
			.addProperty("m_AreaCircleEventHandle", &EventAreaCircle::m_AreaCircleEventHandle)
		.endClass();
	}
#endif
};
static_assert(sizeof(EventAreaCircle::m_Kind) == 4, "expected EventAreaCircle::m_Kind to be size 4");
static_assert(sizeof(EventAreaCircle::m_Center) == 12, "expected EventAreaCircle::m_Center to be size 12");
static_assert(sizeof(EventAreaCircle::m_sRadius) == 4, "expected EventAreaCircle::m_sRadius to be size 4");
static_assert(sizeof(EventAreaCircle::m_Rot) == 4, "expected EventAreaCircle::m_Rot to be size 4");
static_assert(sizeof(EventAreaCircle::m_Scale) == 4, "expected EventAreaCircle::m_Scale to be size 4");
static_assert(sizeof(EventAreaCircle::m_ScaleHoshi) == 4, "expected EventAreaCircle::m_ScaleHoshi to be size 4");
static_assert(sizeof(EventAreaCircle::m_MinScale) == 4, "expected EventAreaCircle::m_MinScale to be size 4");
static_assert(sizeof(EventAreaCircle::m_MaxScale) == 4, "expected EventAreaCircle::m_MaxScale to be size 4");
static_assert(sizeof(EventAreaCircle::m_Alpha) == 4, "expected EventAreaCircle::m_Alpha to be size 4");
static_assert(sizeof(EventAreaCircle::m_Done) == 1, "expected EventAreaCircle::m_Done to be size 1");
static_assert(sizeof(EventAreaCircle::m_PcPlayMotionDone) == 1, "expected EventAreaCircle::m_PcPlayMotionDone to be size 1");
static_assert(sizeof(EventAreaCircle::m_PcMoveDone) == 1, "expected EventAreaCircle::m_PcMoveDone to be size 1");
static_assert(sizeof(EventAreaCircle::m_firsttouch) == 1, "expected EventAreaCircle::m_firsttouch to be size 1");
static_assert(sizeof(EventAreaCircle::m_nowtouch) == 1, "expected EventAreaCircle::m_nowtouch to be size 1");
static_assert(sizeof(EventAreaCircle::m_EventName) == 32, "expected EventAreaCircle::m_EventName to be size 32");
static_assert(sizeof(EventAreaCircle::m_StageName) == 16, "expected EventAreaCircle::m_StageName to be size 16");
static_assert(sizeof(EventAreaCircle::m_HrScriptHandle) == 4, "expected EventAreaCircle::m_HrScriptHandle to be size 4");
static_assert(sizeof(EventAreaCircle::m_PlayBossCornMotionFlag) == 1, "expected EventAreaCircle::m_PlayBossCornMotionFlag to be size 1");
static_assert(sizeof(EventAreaCircle::m_pCornGmf) == 4, "expected EventAreaCircle::m_pCornGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornSleepGmf) == 4, "expected EventAreaCircle::m_pCornSleepGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGmf) == 4, "expected EventAreaCircle::m_pCornShadowGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGanNum) == 4, "expected EventAreaCircle::m_pCornShadowGanNum to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGan) == 4, "expected EventAreaCircle::m_pCornShadowGan to be size 4");
static_assert(sizeof(EventAreaCircle::m_PlaySe) == 2, "expected EventAreaCircle::m_PlaySe to be size 2");
static_assert(sizeof(EventAreaCircle::m_MakerType) == 4, "expected EventAreaCircle::m_MakerType to be size 4");
static_assert(sizeof(EventAreaCircle::m_SignboardType) == 4, "expected EventAreaCircle::m_SignboardType to be size 4");
static_assert(sizeof(EventAreaCircle::m_Sleep) == 4, "expected EventAreaCircle::m_Sleep to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepAlpha) == 4, "expected EventAreaCircle::m_SleepAlpha to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepTick) == 4, "expected EventAreaCircle::m_SleepTick to be size 4");
static_assert(sizeof(EventAreaCircle::m_WakeUpCameraEffect) == 1, "expected EventAreaCircle::m_WakeUpCameraEffect to be size 1");
static_assert(sizeof(EventAreaCircle::m_Visible) == 1, "expected EventAreaCircle::m_Visible to be size 1");
static_assert(sizeof(EventAreaCircle::m_SleepMessage) == 4, "expected EventAreaCircle::m_SleepMessage to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepMessageProc) == 4, "expected EventAreaCircle::m_SleepMessageProc to be size 4");
static_assert(sizeof(EventAreaCircle::mBackDispStatusDisEnable) == 4, "expected EventAreaCircle::mBackDispStatusDisEnable to be size 4");
static_assert(sizeof(EventAreaCircle::m_EventRunEffectProcess) == 4, "expected EventAreaCircle::m_EventRunEffectProcess to be size 4");
static_assert(sizeof(EventAreaCircle::m_EventRunEffectBit) == 4, "expected EventAreaCircle::m_EventRunEffectBit to be size 4");
static_assert(sizeof(EventAreaCircle::m_CameraOff) == 1, "expected EventAreaCircle::m_CameraOff to be size 1");
static_assert(sizeof(EventAreaCircle::mCameraPosSetType) == 1, "expected EventAreaCircle::mCameraPosSetType to be size 1");
static_assert(sizeof(EventAreaCircle::mCameraPos) == 12, "expected EventAreaCircle::mCameraPos to be size 12");
static_assert(sizeof(EventAreaCircle::mCameraTargetPos) == 12, "expected EventAreaCircle::mCameraTargetPos to be size 12");
static_assert(sizeof(EventAreaCircle::mPcPosSetType) == 1, "expected EventAreaCircle::mPcPosSetType to be size 1");
static_assert(sizeof(EventAreaCircle::mPcPos) == 12, "expected EventAreaCircle::mPcPos to be size 12");
static_assert(sizeof(EventAreaCircle::mCenterRotY) == 4, "expected EventAreaCircle::mCenterRotY to be size 4");
static_assert(sizeof(EventAreaCircle::mPcRotY) == 4, "expected EventAreaCircle::mPcRotY to be size 4");
static_assert(sizeof(EventAreaCircle::mpEventAreaCircleScriptFunc) == 4, "expected EventAreaCircle::mpEventAreaCircleScriptFunc to be size 4");
static_assert(sizeof(EventAreaCircle::mFunctionCallCount) == 4, "expected EventAreaCircle::mFunctionCallCount to be size 4");
static_assert(sizeof(EventAreaCircle::mFunctionCallType) == 4, "expected EventAreaCircle::mFunctionCallType to be size 4");
static_assert(sizeof(EventAreaCircle::mPcMotionID) == 4, "expected EventAreaCircle::mPcMotionID to be size 4");
static_assert(sizeof(EventAreaCircle::mPcMoveFrame) == 4, "expected EventAreaCircle::mPcMoveFrame to be size 4");
static_assert(sizeof(EventAreaCircle::mDelete) == 1, "expected EventAreaCircle::mDelete to be size 1");
static_assert(sizeof(EventAreaCircle::mpEveCorn) == 4, "expected EventAreaCircle::mpEveCorn to be size 4");
static_assert(sizeof(EventAreaCircle::mEveCornVisible) == 1, "expected EventAreaCircle::mEveCornVisible to be size 1");
static_assert(sizeof(EventAreaCircle::mEveCornRefreshCnt) == 4, "expected EventAreaCircle::mEveCornRefreshCnt to be size 4");
static_assert(sizeof(EventAreaCircle::mEventEndCameraHold) == 1, "expected EventAreaCircle::mEventEndCameraHold to be size 1");
static_assert(sizeof(EventAreaCircle::mFlash) == 1, "expected EventAreaCircle::mFlash to be size 1");
static_assert(sizeof(EventAreaCircle::mFlashSE) == 1, "expected EventAreaCircle::mFlashSE to be size 1");
static_assert(sizeof(EventAreaCircle::mFlashCounter) == 4, "expected EventAreaCircle::mFlashCounter to be size 4");
static_assert(sizeof(EventAreaCircle::mBikeRide) == 1, "expected EventAreaCircle::mBikeRide to be size 1");
static_assert(sizeof(EventAreaCircle::mpEventAreaCamera) == 4, "expected EventAreaCircle::mpEventAreaCamera to be size 4");
static_assert(sizeof(EventAreaCircle::mpSleepWakeUpCamera) == 4, "expected EventAreaCircle::mpSleepWakeUpCamera to be size 4");
static_assert(sizeof(EventAreaCircle::m_AreaCircleEventHandle) == 4, "expected EventAreaCircle::m_AreaCircleEventHandle to be size 4");
static_assert(sizeof(EventAreaCircle) == 0x130, "expected EventAreaCircle to be size 0x130");

// [Structure] class ghmScriptVariables
class ghmScriptVariables
{
public:
	/// Struct member variables

	// <char* mpChar, offset 0x0>
	char* mpChar = nullptr;

	// <int32_t mCharNum, offset 0x4>
	int32_t mCharNum = 0;

	// <int16_t* mpShort, offset 0x8>
	int16_t* mpShort = nullptr;

	// <int32_t mShortNum, offset 0xc>
	int32_t mShortNum = 0;

	// <int32_t* mpInt, offset 0x10>
	int32_t* mpInt = nullptr;

	// <int32_t mIntNum, offset 0x14>
	int32_t mIntNum = 0;

	// <int64_t* mpLong, offset 0x18>
	int64_t* mpLong = nullptr;

	// <int32_t mLongNum, offset 0x1c>
	int32_t mLongNum = 0;

	// <float* mpFloat, offset 0x20>
	float* mpFloat = nullptr;

	// <int32_t mFloatNum, offset 0x24>
	int32_t mFloatNum = 0;

	// <class ghmString* mpString, offset 0x28>
	class ghmString* mpString = nullptr;

	// <int32_t mStringNum, offset 0x2c>
	int32_t mStringNum = 0;

	// <uint8_t mAdjustEnable, offset 0x30>
	uint8_t mAdjustEnable = 0;

	// <Unidentified data segment, offset 0x31>
private:
	char _UnidentifiedData_49[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScriptVariables [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptVariables& InObject)
	{
		mpChar = InObject.mpChar;
		mCharNum = InObject.mCharNum;
		mpShort = InObject.mpShort;
		mShortNum = InObject.mShortNum;
		mpInt = InObject.mpInt;
		mIntNum = InObject.mIntNum;
		mpLong = InObject.mpLong;
		mLongNum = InObject.mLongNum;
		mpFloat = InObject.mpFloat;
		mFloatNum = InObject.mFloatNum;
		mpString = InObject.mpString;
		mStringNum = InObject.mStringNum;
		mAdjustEnable = InObject.mAdjustEnable;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptVariables>("ghmScriptVariables")
			.addFunction("__tostring", &ghmScriptVariables::ToString)
			.addFunction("GetPtrAddr", &ghmScriptVariables::GetPtrAddr)
			// char* type not supported in LuaBridge
			//.addProperty("mpChar", &ghmScriptVariables::mpChar)
			.addProperty("mCharNum", &ghmScriptVariables::mCharNum)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpShort", &ghmScriptVariables::mpShort)
			.addProperty("mShortNum", &ghmScriptVariables::mShortNum)
			// native pointer type (int32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpInt", &ghmScriptVariables::mpInt)
			.addProperty("mIntNum", &ghmScriptVariables::mIntNum)
			// native pointer type (int64_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpLong", &ghmScriptVariables::mpLong)
			.addProperty("mLongNum", &ghmScriptVariables::mLongNum)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpFloat", &ghmScriptVariables::mpFloat)
			.addProperty("mFloatNum", &ghmScriptVariables::mFloatNum)
			.addProperty("mpString", &ghmScriptVariables::mpString)
			.addProperty("mStringNum", &ghmScriptVariables::mStringNum)
			.addProperty("mAdjustEnable", &ghmScriptVariables::mAdjustEnable)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptVariables::mpChar) == 4, "expected ghmScriptVariables::mpChar to be size 4");
static_assert(sizeof(ghmScriptVariables::mCharNum) == 4, "expected ghmScriptVariables::mCharNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpShort) == 4, "expected ghmScriptVariables::mpShort to be size 4");
static_assert(sizeof(ghmScriptVariables::mShortNum) == 4, "expected ghmScriptVariables::mShortNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpInt) == 4, "expected ghmScriptVariables::mpInt to be size 4");
static_assert(sizeof(ghmScriptVariables::mIntNum) == 4, "expected ghmScriptVariables::mIntNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpLong) == 4, "expected ghmScriptVariables::mpLong to be size 4");
static_assert(sizeof(ghmScriptVariables::mLongNum) == 4, "expected ghmScriptVariables::mLongNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpFloat) == 4, "expected ghmScriptVariables::mpFloat to be size 4");
static_assert(sizeof(ghmScriptVariables::mFloatNum) == 4, "expected ghmScriptVariables::mFloatNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpString) == 4, "expected ghmScriptVariables::mpString to be size 4");
static_assert(sizeof(ghmScriptVariables::mStringNum) == 4, "expected ghmScriptVariables::mStringNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mAdjustEnable) == 1, "expected ghmScriptVariables::mAdjustEnable to be size 1");
static_assert(sizeof(ghmScriptVariables) == 0x34, "expected ghmScriptVariables to be size 0x34");

// [Structure] class ghmScript
class ghmScript : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct ghmScriptObjectType* mpObjectType, offset 0x10>
	struct ghmScriptObjectType* mpObjectType = nullptr;

	// <int32_t mObjectTypeNum, offset 0x14>
	int32_t mObjectTypeNum = 0;

	// <class ghmScriptObject* mpObject, offset 0x18>
	class ghmScriptObject* mpObject = nullptr;

	// <class ghmScriptVariables mLocalVariables, offset 0x1c>
	class ghmScriptVariables mLocalVariables;

	// <uint32_t* mpLocalFlag, offset 0x50>
	uint32_t* mpLocalFlag = nullptr;

	// <uint32_t mLocalFlagNum, offset 0x54>
	uint32_t mLocalFlagNum = 0;

	// <struct ghmScrHeader* mpHeader, offset 0x58>
	struct ghmScrHeader* mpHeader = nullptr;

	// <class ghmScriptProgFunc* mpProgFunc, offset 0x5c>
	class ghmScriptProgFunc* mpProgFunc = nullptr;

	// <class ghmListObj mContextAnchor, offset 0x60>
	class ghmListObj mContextAnchor;

	// <class ghmScriptContext* mpContext, offset 0x70>
	class ghmScriptContext* mpContext = nullptr;

	// <uint8_t mconvendian, offset 0x74>
	uint8_t mconvendian = 0;

	// <Unidentified data segment, offset 0x75>
private:
	char _UnidentifiedData_117[3];

public:
	// <uint32_t mFlag, offset 0x78>
	uint32_t mFlag = 0;

	// <uint32_t mParam[0x4], offset 0x7c>
	uint32_t mParam[4];

	// <class ghmListObj mFuncAnchor, offset 0x8c>
	class ghmListObj mFuncAnchor;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScript [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScript& InObject)
	{
		mpObjectType = InObject.mpObjectType;
		mObjectTypeNum = InObject.mObjectTypeNum;
		mpObject = InObject.mpObject;
		mLocalVariables = InObject.mLocalVariables;
		mpLocalFlag = InObject.mpLocalFlag;
		mLocalFlagNum = InObject.mLocalFlagNum;
		mpHeader = InObject.mpHeader;
		mpProgFunc = InObject.mpProgFunc;
		mContextAnchor = InObject.mContextAnchor;
		mpContext = InObject.mpContext;
		mconvendian = InObject.mconvendian;
		mFlag = InObject.mFlag;
		mFuncAnchor = InObject.mFuncAnchor;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmScript, ghmListObj>("ghmScript")
			.addFunction("__tostring", &ghmScript::ToString)
			.addFunction("GetPtrAddr", &ghmScript::GetPtrAddr)
			.addProperty("mpObjectType", &ghmScript::mpObjectType)
			.addProperty("mObjectTypeNum", &ghmScript::mObjectTypeNum)
			.addProperty("mpObject", &ghmScript::mpObject)
			.addProperty("mLocalVariables", &ghmScript::mLocalVariables)
			// native pointer type (uint32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpLocalFlag", &ghmScript::mpLocalFlag)
			.addProperty("mLocalFlagNum", &ghmScript::mLocalFlagNum)
			.addProperty("mpHeader", &ghmScript::mpHeader)
			.addProperty("mpProgFunc", &ghmScript::mpProgFunc)
			.addProperty("mContextAnchor", &ghmScript::mContextAnchor)
			.addProperty("mpContext", &ghmScript::mpContext)
			.addProperty("mconvendian", &ghmScript::mconvendian)
			.addProperty("mFlag", &ghmScript::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mParam", &ghmScript::mParam)
			.addProperty("mFuncAnchor", &ghmScript::mFuncAnchor)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScript::mpObjectType) == 4, "expected ghmScript::mpObjectType to be size 4");
static_assert(sizeof(ghmScript::mObjectTypeNum) == 4, "expected ghmScript::mObjectTypeNum to be size 4");
static_assert(sizeof(ghmScript::mpObject) == 4, "expected ghmScript::mpObject to be size 4");
static_assert(sizeof(ghmScript::mLocalVariables) == 52, "expected ghmScript::mLocalVariables to be size 52");
static_assert(sizeof(ghmScript::mpLocalFlag) == 4, "expected ghmScript::mpLocalFlag to be size 4");
static_assert(sizeof(ghmScript::mLocalFlagNum) == 4, "expected ghmScript::mLocalFlagNum to be size 4");
static_assert(sizeof(ghmScript::mpHeader) == 4, "expected ghmScript::mpHeader to be size 4");
static_assert(sizeof(ghmScript::mpProgFunc) == 4, "expected ghmScript::mpProgFunc to be size 4");
static_assert(sizeof(ghmScript::mContextAnchor) == 16, "expected ghmScript::mContextAnchor to be size 16");
static_assert(sizeof(ghmScript::mpContext) == 4, "expected ghmScript::mpContext to be size 4");
static_assert(sizeof(ghmScript::mconvendian) == 1, "expected ghmScript::mconvendian to be size 1");
static_assert(sizeof(ghmScript::mFlag) == 4, "expected ghmScript::mFlag to be size 4");
static_assert(sizeof(ghmScript::mParam) == 16, "expected ghmScript::mParam to be size 16");
static_assert(sizeof(ghmScript::mFuncAnchor) == 16, "expected ghmScript::mFuncAnchor to be size 16");
static_assert(sizeof(ghmScript) == 0x9c, "expected ghmScript to be size 0x9c");

// [Structure] class ghmScriptFunc
class ghmScriptFunc : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <char mName[0x40], offset 0x10>
	char mName[64];

	// <uint16_t mReturnType, offset 0x50>
	uint16_t mReturnType = 0;

	// <Unidentified data segment, offset 0x52>
private:
	char _UnidentifiedData_82[2];

public:
	// <class ghmScriptFuncArgBase* mpReturnValue, offset 0x54>
	class ghmScriptFuncArgBase* mpReturnValue = nullptr;

	// <uint16_t mArgNum, offset 0x58>
	uint16_t mArgNum = 0;

	// <uint16_t mArgs[0x12], offset 0x5a>
	uint16_t mArgs[18];

	// <Unidentified data segment, offset 0x7e>
private:
	char _UnidentifiedData_126[2];

public:
	// <class ghmScriptFuncArgBase* mpArgs[0x12], offset 0x80>
	class ghmScriptFuncArgBase* mpArgs[18];

	// <class ghmScript* mpCallScript, offset 0xc8>
	class ghmScript* mpCallScript = nullptr;

	// <uint32_t mFlag, offset 0xcc>
	uint32_t mFlag = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScriptFunc [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptFunc& InObject)
	{
		mReturnType = InObject.mReturnType;
		mpReturnValue = InObject.mpReturnValue;
		mArgNum = InObject.mArgNum;
		mpCallScript = InObject.mpCallScript;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmScriptFunc, ghmListObj>("ghmScriptFunc")
			.addFunction("__tostring", &ghmScriptFunc::ToString)
			.addFunction("GetPtrAddr", &ghmScriptFunc::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mName", &ghmScriptFunc::mName)
			.addProperty("mReturnType", &ghmScriptFunc::mReturnType)
			.addProperty("mpReturnValue", &ghmScriptFunc::mpReturnValue)
			.addProperty("mArgNum", &ghmScriptFunc::mArgNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mArgs", &ghmScriptFunc::mArgs)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpArgs", &ghmScriptFunc::mpArgs)
			.addProperty("mpCallScript", &ghmScriptFunc::mpCallScript)
			.addProperty("mFlag", &ghmScriptFunc::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptFunc::mName) == 64, "expected ghmScriptFunc::mName to be size 64");
static_assert(sizeof(ghmScriptFunc::mReturnType) == 2, "expected ghmScriptFunc::mReturnType to be size 2");
static_assert(sizeof(ghmScriptFunc::mpReturnValue) == 4, "expected ghmScriptFunc::mpReturnValue to be size 4");
static_assert(sizeof(ghmScriptFunc::mArgNum) == 2, "expected ghmScriptFunc::mArgNum to be size 2");
static_assert(sizeof(ghmScriptFunc::mArgs) == 36, "expected ghmScriptFunc::mArgs to be size 36");
static_assert(sizeof(ghmScriptFunc::mpArgs) == 72, "expected ghmScriptFunc::mpArgs to be size 72");
static_assert(sizeof(ghmScriptFunc::mpCallScript) == 4, "expected ghmScriptFunc::mpCallScript to be size 4");
static_assert(sizeof(ghmScriptFunc::mFlag) == 4, "expected ghmScriptFunc::mFlag to be size 4");
static_assert(sizeof(ghmScriptFunc) == 0xd0, "expected ghmScriptFunc to be size 0xd0");

// [Structure] class HrScriptFunc
class HrScriptFunc : public ghmScriptFunc
{
public:
	// enum HrScriptFunc::SCRIPTFUNC_STS
	enum SCRIPTFUNC_STS : uint32_t
	{
		// <SCRIPTFUNC_INIT = 0x0>
		SCRIPTFUNC_INIT = 0,

		// <SCRIPTFUNC_IDLE = 0x1>
		SCRIPTFUNC_IDLE = 1,

		// <SCRIPTFUNC_TERM = 0x2>
		SCRIPTFUNC_TERM = 2,

		// <SCRIPTFUNC_MAX = 0x3>
		SCRIPTFUNC_MAX = 3

	};

	/// Struct member variables

	// <class ghmScriptFunc field_0, offset 0x0>
	// class ghmScriptFunc Super;

	// <enum HrScriptFunc::SCRIPTFUNC_STS m_Status, offset 0xd0>
	enum HrScriptFunc::SCRIPTFUNC_STS m_Status;

	// <uint8_t m_WaitVsync, offset 0xd4>
	uint8_t m_WaitVsync = 0;

	// <Unidentified data segment, offset 0xd5>
private:
	char _UnidentifiedData_213[3];

public:
	// <void* m_pScrData, offset 0xd8>
	void* m_pScrData = nullptr;

	// <class ghmScript m_Script, offset 0xdc>
	class ghmScript m_Script;

	// <char m_SubName[0x10], offset 0x178>
	char m_SubName[16];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrScriptFunc [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrScriptFunc& InObject)
	{
		m_Status = InObject.m_Status;
		m_WaitVsync = InObject.m_WaitVsync;
		m_pScrData = InObject.m_pScrData;
		m_Script = InObject.m_Script;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrScriptFunc, ghmScriptFunc>("HrScriptFunc")
			.addFunction("__tostring", &HrScriptFunc::ToString)
			.addFunction("GetPtrAddr", &HrScriptFunc::GetPtrAddr)
			.addProperty("m_Status", &HrScriptFunc::m_Status)
			.addProperty("m_WaitVsync", &HrScriptFunc::m_WaitVsync)
			// void type not supported in LuaBridge
			//.addProperty("m_pScrData", &HrScriptFunc::m_pScrData)
			.addProperty("m_Script", &HrScriptFunc::m_Script)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_SubName", &HrScriptFunc::m_SubName)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrScriptFunc::m_Status) == 4, "expected HrScriptFunc::m_Status to be size 4");
static_assert(sizeof(HrScriptFunc::m_WaitVsync) == 1, "expected HrScriptFunc::m_WaitVsync to be size 1");
static_assert(sizeof(HrScriptFunc::m_pScrData) == 4, "expected HrScriptFunc::m_pScrData to be size 4");
static_assert(sizeof(HrScriptFunc::m_Script) == 156, "expected HrScriptFunc::m_Script to be size 156");
static_assert(sizeof(HrScriptFunc::m_SubName) == 16, "expected HrScriptFunc::m_SubName to be size 16");
static_assert(sizeof(HrScriptFunc) == 0x188, "expected HrScriptFunc to be size 0x188");

// [Structure] class ghmScriptBase
class ghmScriptBase
{
public:
	/// Struct member variables

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScriptBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptBase& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptBase>("ghmScriptBase")
			.addFunction("__tostring", &ghmScriptBase::ToString)
			.addFunction("GetPtrAddr", &ghmScriptBase::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptBase) == 0x1, "expected ghmScriptBase to be size 0x1");

// [Structure] class CCameraCollision
class CCameraCollision
{
public:
	/// Struct member variables

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraCollision [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraCollision& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraCollision>("CCameraCollision")
			.addFunction("__tostring", &CCameraCollision::ToString)
			.addFunction("GetPtrAddr", &CCameraCollision::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraCollision) == 0x1, "expected CCameraCollision to be size 0x1");

// [Structure] class FkPjLib
class FkPjLib
{
public:
	/// Struct member variables

	/// 5 Functions

	// [Function] float FkPjLib::GetCharaNowPlayMotionTick(class mHRChara* arg1) [?GetCharaNowPlayMotionTick@FkPjLib@@SAMPAVmHRChara@@@Z]
	typedef float(__fastcall* _GetCharaNowPlayMotionTick_FkPjLib__SAMPAVmHRChara___Z)(class mHRChara* arg1);
	static float GetCharaNowPlayMotionTick(class mHRChara* arg1)
	{
		_GetCharaNowPlayMotionTick_FkPjLib__SAMPAVmHRChara___Z mFunc = (_GetCharaNowPlayMotionTick_FkPjLib__SAMPAVmHRChara___Z)(GameModule + 0x4bca80);
		return mFunc(arg1);
	}
	// [Function] class HrTalk* FkPjLib::StartNpcTalkSysMessageFromStageResource(char const* arg1, char const* arg2) [?StartNpcTalkSysMessageFromStageResource@FkPjLib@@SAPAVHrTalk@@PBD0@Z]
	typedef class HrTalk*(__fastcall* _StartNpcTalkSysMessageFromStageResource_FkPjLib__SAPAVHrTalk__PBD0_Z)(char const* arg1, char const* arg2);
	static class HrTalk* StartNpcTalkSysMessageFromStageResource(std::string arg1, std::string arg2)
	{
		char const* arg1_c_str = arg1.c_str();
		char const* arg2_c_str = arg2.c_str();
		_StartNpcTalkSysMessageFromStageResource_FkPjLib__SAPAVHrTalk__PBD0_Z mFunc = (_StartNpcTalkSysMessageFromStageResource_FkPjLib__SAPAVHrTalk__PBD0_Z)(GameModule + 0x4bcb00);
		return mFunc(arg1_c_str, arg2_c_str);
	}
	// [Function] uint8_t FkPjLib::CheckValidCharaPtr(class mHRChara* arg1) [?CheckValidCharaPtr@FkPjLib@@SA_NPAVmHRChara@@@Z]
	typedef uint8_t(__fastcall* _CheckValidCharaPtr_FkPjLib__SA_NPAVmHRChara___Z)(class mHRChara* arg1);
	static uint8_t CheckValidCharaPtr(class mHRChara* arg1)
	{
		_CheckValidCharaPtr_FkPjLib__SA_NPAVmHRChara___Z mFunc = (_CheckValidCharaPtr_FkPjLib__SA_NPAVmHRChara___Z)(GameModule + 0x4bd1a0);
		return mFunc(arg1);
	}
	// [Function] uint8_t FkPjLib::CheckCharSurroundStageCollisionAndAdjustSafetyPos(class mHRChara* arg1, float arg2, float arg3) [?CheckCharSurroundStageCollisionAndAdjustSafetyPos@FkPjLib@@SA_NPAVmHRChara@@MM@Z]
	typedef uint8_t(__fastcall* _CheckCharSurroundStageCollisionAndAdjustSafetyPos_FkPjLib__SA_NPAVmHRChara__MM_Z)(class mHRChara* arg1, float arg2, float arg3);
	static uint8_t CheckCharSurroundStageCollisionAndAdjustSafetyPos(class mHRChara* arg1, float arg2, float arg3)
	{
		_CheckCharSurroundStageCollisionAndAdjustSafetyPos_FkPjLib__SA_NPAVmHRChara__MM_Z mFunc = (_CheckCharSurroundStageCollisionAndAdjustSafetyPos_FkPjLib__SA_NPAVmHRChara__MM_Z)(GameModule + 0x4bd530);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] class mHRChara* FkPjLib::GetCharaPtrByNpcID(int32_t const arg1, uint8_t const arg2) [?GetCharaPtrByNpcID@FkPjLib@@SAPAVmHRChara@@H_N@Z]
	typedef class mHRChara*(__fastcall* _GetCharaPtrByNpcID_FkPjLib__SAPAVmHRChara__H_N_Z)(int32_t const arg1, uint8_t const arg2);
	static class mHRChara* GetCharaPtrByNpcID(int32_t const arg1, uint8_t const arg2)
	{
		_GetCharaPtrByNpcID_FkPjLib__SAPAVmHRChara__H_N_Z mFunc = (_GetCharaPtrByNpcID_FkPjLib__SAPAVmHRChara__H_N_Z)(GameModule + 0x4bdf20);
		return mFunc(arg1, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class FkPjLib [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkPjLib& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkPjLib>("FkPjLib")
			.addFunction("__tostring", &FkPjLib::ToString)
			.addFunction("GetPtrAddr", &FkPjLib::GetPtrAddr)
			.addStaticFunction("GetCharaNowPlayMotionTick", &FkPjLib::GetCharaNowPlayMotionTick)
			.addStaticFunction("StartNpcTalkSysMessageFromStageResource", &FkPjLib::StartNpcTalkSysMessageFromStageResource)
			.addStaticFunction("CheckValidCharaPtr", &FkPjLib::CheckValidCharaPtr)
			.addStaticFunction("CheckCharSurroundStageCollisionAndAdjustSafetyPos", &FkPjLib::CheckCharSurroundStageCollisionAndAdjustSafetyPos)
			.addStaticFunction("GetCharaPtrByNpcID", &FkPjLib::GetCharaPtrByNpcID)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkPjLib) == 0x1, "expected FkPjLib to be size 0x1");

// [Structure] class ghmScriptFuncArgBase
class ghmScriptFuncArgBase
{
public:
	/// Struct member variables

	// <void* (* field_0)[0xe], offset 0x0>
	void* (* field_0)[0xe];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScriptFuncArgBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptFuncArgBase& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptFuncArgBase>("ghmScriptFuncArgBase")
			.addFunction("__tostring", &ghmScriptFuncArgBase::ToString)
			.addFunction("GetPtrAddr", &ghmScriptFuncArgBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmScriptFuncArgBase::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptFuncArgBase::field_0) == 4, "expected ghmScriptFuncArgBase::field_0 to be size 4");
static_assert(sizeof(ghmScriptFuncArgBase) == 0x4, "expected ghmScriptFuncArgBase to be size 0x4");

// [Structure] struct ghmScriptObjectType
struct ghmScriptObjectType
{
public:
	/// Struct member variables

	// <uint8_t (* mpMethod)(class ghmScript*, uint16_t, uint16_t), offset 0x0>
	uint8_t (* mpMethod)(class ghmScript*, uint16_t, uint16_t);

	// <int32_t mObjectNum, offset 0x4>
	int32_t mObjectNum = 0;

	// <int32_t mPropCharNum, offset 0x8>
	int32_t mPropCharNum = 0;

	// <int32_t mPropShortNum, offset 0xc>
	int32_t mPropShortNum = 0;

	// <int32_t mPropIntNum, offset 0x10>
	int32_t mPropIntNum = 0;

	// <int32_t mPropLongNum, offset 0x14>
	int32_t mPropLongNum = 0;

	// <int32_t mPropFloatNum, offset 0x18>
	int32_t mPropFloatNum = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct ghmScriptObjectType [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptObjectType& InObject)
	{
		mObjectNum = InObject.mObjectNum;
		mPropCharNum = InObject.mPropCharNum;
		mPropShortNum = InObject.mPropShortNum;
		mPropIntNum = InObject.mPropIntNum;
		mPropLongNum = InObject.mPropLongNum;
		mPropFloatNum = InObject.mPropFloatNum;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptObjectType>("ghmScriptObjectType")
			.addFunction("__tostring", &ghmScriptObjectType::ToString)
			.addFunction("GetPtrAddr", &ghmScriptObjectType::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("mpMethod", &ghmScriptObjectType::mpMethod)
			.addProperty("mObjectNum", &ghmScriptObjectType::mObjectNum)
			.addProperty("mPropCharNum", &ghmScriptObjectType::mPropCharNum)
			.addProperty("mPropShortNum", &ghmScriptObjectType::mPropShortNum)
			.addProperty("mPropIntNum", &ghmScriptObjectType::mPropIntNum)
			.addProperty("mPropLongNum", &ghmScriptObjectType::mPropLongNum)
			.addProperty("mPropFloatNum", &ghmScriptObjectType::mPropFloatNum)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptObjectType::mpMethod) == 4, "expected ghmScriptObjectType::mpMethod to be size 4");
static_assert(sizeof(ghmScriptObjectType::mObjectNum) == 4, "expected ghmScriptObjectType::mObjectNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropCharNum) == 4, "expected ghmScriptObjectType::mPropCharNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropShortNum) == 4, "expected ghmScriptObjectType::mPropShortNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropIntNum) == 4, "expected ghmScriptObjectType::mPropIntNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropLongNum) == 4, "expected ghmScriptObjectType::mPropLongNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropFloatNum) == 4, "expected ghmScriptObjectType::mPropFloatNum to be size 4");
static_assert(sizeof(ghmScriptObjectType) == 0x1c, "expected ghmScriptObjectType to be size 0x1c");

// [Structure] class ghmScriptObject
class ghmScriptObject
{
public:
	/// Struct member variables

	// <class ghmScriptVariables* mpProperty, offset 0x0>
	class ghmScriptVariables* mpProperty = nullptr;

	// <struct ghmScriptObjectType* mpType, offset 0x4>
	struct ghmScriptObjectType* mpType = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScriptObject [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptObject& InObject)
	{
		mpProperty = InObject.mpProperty;
		mpType = InObject.mpType;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptObject>("ghmScriptObject")
			.addFunction("__tostring", &ghmScriptObject::ToString)
			.addFunction("GetPtrAddr", &ghmScriptObject::GetPtrAddr)
			.addProperty("mpProperty", &ghmScriptObject::mpProperty)
			.addProperty("mpType", &ghmScriptObject::mpType)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptObject::mpProperty) == 4, "expected ghmScriptObject::mpProperty to be size 4");
static_assert(sizeof(ghmScriptObject::mpType) == 4, "expected ghmScriptObject::mpType to be size 4");
static_assert(sizeof(ghmScriptObject) == 0x8, "expected ghmScriptObject to be size 0x8");

// [Structure] class ghmString
class ghmString
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <char* mpBuff, offset 0x4>
	char* mpBuff = nullptr;

	// <int32_t mAllocSize, offset 0x8>
	int32_t mAllocSize = 0;

	// <int32_t mLength, offset 0xc>
	int32_t mLength = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmString [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmString& InObject)
	{
		mpBuff = InObject.mpBuff;
		mAllocSize = InObject.mAllocSize;
		mLength = InObject.mLength;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmString>("ghmString")
			.addFunction("__tostring", &ghmString::ToString)
			.addFunction("GetPtrAddr", &ghmString::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmString::field_0)
			// char* type not supported in LuaBridge
			//.addProperty("mpBuff", &ghmString::mpBuff)
			.addProperty("mAllocSize", &ghmString::mAllocSize)
			.addProperty("mLength", &ghmString::mLength)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmString::field_0) == 4, "expected ghmString::field_0 to be size 4");
static_assert(sizeof(ghmString::mpBuff) == 4, "expected ghmString::mpBuff to be size 4");
static_assert(sizeof(ghmString::mAllocSize) == 4, "expected ghmString::mAllocSize to be size 4");
static_assert(sizeof(ghmString::mLength) == 4, "expected ghmString::mLength to be size 4");
static_assert(sizeof(ghmString) == 0x10, "expected ghmString to be size 0x10");

// [Structure] struct ghmScrHeader
struct ghmScrHeader
{
public:
	/// Struct member variables

	// <uint8_t mMagicNoStr[0x4], offset 0x0>
	uint8_t mMagicNoStr[4];

	// <uint32_t mFlag, offset 0x4>
	uint32_t mFlag = 0;

	// <uint16_t mIntFuncNum, offset 0x8>
	uint16_t mIntFuncNum = 0;

	// <uint16_t mExtFuncNum, offset 0xa>
	uint16_t mExtFuncNum = 0;

	// <struct ghmScrFuncHeader** mppIntFuncTable, offset 0xc>
	struct ghmScrFuncHeader** mppIntFuncTable = nullptr;

	// <struct ghmScrFuncHeader** mppExtFuncTable, offset 0x10>
	struct ghmScrFuncHeader** mppExtFuncTable = nullptr;

	// <uint16_t mStringNum, offset 0x14>
	uint16_t mStringNum = 0;

	// <uint16_t mStringNumPad, offset 0x16>
	uint16_t mStringNumPad = 0;

	// <char const** mppString, offset 0x18>
	char const** mppString = nullptr;

	// <uint32_t mPad[0x1], offset 0x1c>
	uint32_t mPad[1];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct ghmScrHeader [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScrHeader& InObject)
	{
		mFlag = InObject.mFlag;
		mIntFuncNum = InObject.mIntFuncNum;
		mExtFuncNum = InObject.mExtFuncNum;
		mppIntFuncTable = InObject.mppIntFuncTable;
		mppExtFuncTable = InObject.mppExtFuncTable;
		mStringNum = InObject.mStringNum;
		mStringNumPad = InObject.mStringNumPad;
		mppString = InObject.mppString;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScrHeader>("ghmScrHeader")
			.addFunction("__tostring", &ghmScrHeader::ToString)
			.addFunction("GetPtrAddr", &ghmScrHeader::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mMagicNoStr", &ghmScrHeader::mMagicNoStr)
			.addProperty("mFlag", &ghmScrHeader::mFlag)
			.addProperty("mIntFuncNum", &ghmScrHeader::mIntFuncNum)
			.addProperty("mExtFuncNum", &ghmScrHeader::mExtFuncNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppIntFuncTable", &ghmScrHeader::mppIntFuncTable)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppExtFuncTable", &ghmScrHeader::mppExtFuncTable)
			.addProperty("mStringNum", &ghmScrHeader::mStringNum)
			.addProperty("mStringNumPad", &ghmScrHeader::mStringNumPad)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppString", &ghmScrHeader::mppString)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmScrHeader::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScrHeader::mMagicNoStr) == 4, "expected ghmScrHeader::mMagicNoStr to be size 4");
static_assert(sizeof(ghmScrHeader::mFlag) == 4, "expected ghmScrHeader::mFlag to be size 4");
static_assert(sizeof(ghmScrHeader::mIntFuncNum) == 2, "expected ghmScrHeader::mIntFuncNum to be size 2");
static_assert(sizeof(ghmScrHeader::mExtFuncNum) == 2, "expected ghmScrHeader::mExtFuncNum to be size 2");
static_assert(sizeof(ghmScrHeader::mppIntFuncTable) == 4, "expected ghmScrHeader::mppIntFuncTable to be size 4");
static_assert(sizeof(ghmScrHeader::mppExtFuncTable) == 4, "expected ghmScrHeader::mppExtFuncTable to be size 4");
static_assert(sizeof(ghmScrHeader::mStringNum) == 2, "expected ghmScrHeader::mStringNum to be size 2");
static_assert(sizeof(ghmScrHeader::mStringNumPad) == 2, "expected ghmScrHeader::mStringNumPad to be size 2");
static_assert(sizeof(ghmScrHeader::mppString) == 4, "expected ghmScrHeader::mppString to be size 4");
static_assert(sizeof(ghmScrHeader::mPad) == 4, "expected ghmScrHeader::mPad to be size 4");
static_assert(sizeof(ghmScrHeader) == 0x20, "expected ghmScrHeader to be size 0x20");

// [Structure] struct ghmScrFuncHeader
struct ghmScrFuncHeader
{
public:
	/// Struct member variables

	// <char const* mpName, offset 0x0>
	char const* mpName = nullptr;

	// <uint16_t mReturnType, offset 0x4>
	uint16_t mReturnType = 0;

	// <uint16_t mArgNum, offset 0x6>
	uint16_t mArgNum = 0;

	// <uint16_t* mpArgs, offset 0x8>
	uint16_t* mpArgs = nullptr;

	// <uint16_t* mpDataTop, offset 0xc>
	uint16_t* mpDataTop = nullptr;

	// <uint32_t mDataSize, offset 0x10>
	uint32_t mDataSize = 0;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag = 0;

	// <uint32_t mPad[0x2], offset 0x18>
	uint32_t mPad[2];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct ghmScrFuncHeader [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScrFuncHeader& InObject)
	{
		mpName = InObject.mpName;
		mReturnType = InObject.mReturnType;
		mArgNum = InObject.mArgNum;
		mpArgs = InObject.mpArgs;
		mpDataTop = InObject.mpDataTop;
		mDataSize = InObject.mDataSize;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScrFuncHeader>("ghmScrFuncHeader")
			.addFunction("__tostring", &ghmScrFuncHeader::ToString)
			.addFunction("GetPtrAddr", &ghmScrFuncHeader::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpName", &ghmScrFuncHeader::mpName)
			.addProperty("mReturnType", &ghmScrFuncHeader::mReturnType)
			.addProperty("mArgNum", &ghmScrFuncHeader::mArgNum)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpArgs", &ghmScrFuncHeader::mpArgs)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpDataTop", &ghmScrFuncHeader::mpDataTop)
			.addProperty("mDataSize", &ghmScrFuncHeader::mDataSize)
			.addProperty("mFlag", &ghmScrFuncHeader::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmScrFuncHeader::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScrFuncHeader::mpName) == 4, "expected ghmScrFuncHeader::mpName to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mReturnType) == 2, "expected ghmScrFuncHeader::mReturnType to be size 2");
static_assert(sizeof(ghmScrFuncHeader::mArgNum) == 2, "expected ghmScrFuncHeader::mArgNum to be size 2");
static_assert(sizeof(ghmScrFuncHeader::mpArgs) == 4, "expected ghmScrFuncHeader::mpArgs to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mpDataTop) == 4, "expected ghmScrFuncHeader::mpDataTop to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mDataSize) == 4, "expected ghmScrFuncHeader::mDataSize to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mFlag) == 4, "expected ghmScrFuncHeader::mFlag to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mPad) == 8, "expected ghmScrFuncHeader::mPad to be size 8");
static_assert(sizeof(ghmScrFuncHeader) == 0x20, "expected ghmScrFuncHeader to be size 0x20");

// [Structure] class ghmScriptProgFunc
class ghmScriptProgFunc : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class ghmScriptFunc mFunc, offset 0x10>
	class ghmScriptFunc mFunc;

	// <uint8_t (* mpCallback)(class ghmScriptFunc*), offset 0xe0>
	uint8_t (* mpCallback)(class ghmScriptFunc*);

	// <uint32_t mHashKey, offset 0xe4>
	uint32_t mHashKey = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScriptProgFunc [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptProgFunc& InObject)
	{
		mFunc = InObject.mFunc;
		mHashKey = InObject.mHashKey;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmScriptProgFunc, ghmListObj>("ghmScriptProgFunc")
			.addFunction("__tostring", &ghmScriptProgFunc::ToString)
			.addFunction("GetPtrAddr", &ghmScriptProgFunc::GetPtrAddr)
			.addProperty("mFunc", &ghmScriptProgFunc::mFunc)
			// delegates are not supported in LuaBridge
			//.addProperty("mpCallback", &ghmScriptProgFunc::mpCallback)
			.addProperty("mHashKey", &ghmScriptProgFunc::mHashKey)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptProgFunc::mFunc) == 208, "expected ghmScriptProgFunc::mFunc to be size 208");
static_assert(sizeof(ghmScriptProgFunc::mpCallback) == 4, "expected ghmScriptProgFunc::mpCallback to be size 4");
static_assert(sizeof(ghmScriptProgFunc::mHashKey) == 4, "expected ghmScriptProgFunc::mHashKey to be size 4");
static_assert(sizeof(ghmScriptProgFunc) == 0xe8, "expected ghmScriptProgFunc to be size 0xe8");

// [Structure] struct ghmScriptStackData
struct ghmScriptStackData
{
public:
	/// Struct member variables

	// <uint16_t mData[0x5], offset 0x0>
	uint16_t mData[5];

	// <uint8_t mSize, offset 0xa>
	uint8_t mSize = 0;

	// <uint8_t mType, offset 0xb>
	uint8_t mType = 0;

	// <Unidentified data segment, offset 0xc>
private:
	char _UnidentifiedData_12[4];

public:
	// <float mFloat, offset 0x10>
	float mFloat = 0;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData_20[4];

public:
	// <class ghmString mString, offset 0x18>
	class ghmString mString;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct ghmScriptStackData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptStackData& InObject)
	{
		mSize = InObject.mSize;
		mType = InObject.mType;
		mFloat = InObject.mFloat;
		mString = InObject.mString;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptStackData>("ghmScriptStackData")
			.addFunction("__tostring", &ghmScriptStackData::ToString)
			.addFunction("GetPtrAddr", &ghmScriptStackData::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mData", &ghmScriptStackData::mData)
			.addProperty("mSize", &ghmScriptStackData::mSize)
			.addProperty("mType", &ghmScriptStackData::mType)
			.addProperty("mFloat", &ghmScriptStackData::mFloat)
			.addProperty("mString", &ghmScriptStackData::mString)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptStackData::mData) == 10, "expected ghmScriptStackData::mData to be size 10");
static_assert(sizeof(ghmScriptStackData::mSize) == 1, "expected ghmScriptStackData::mSize to be size 1");
static_assert(sizeof(ghmScriptStackData::mType) == 1, "expected ghmScriptStackData::mType to be size 1");
static_assert(sizeof(ghmScriptStackData::mFloat) == 4, "expected ghmScriptStackData::mFloat to be size 4");
static_assert(sizeof(ghmScriptStackData::mString) == 16, "expected ghmScriptStackData::mString to be size 16");
static_assert(sizeof(ghmScriptStackData) == 0x28, "expected ghmScriptStackData to be size 0x28");

// [Structure] class ghmScriptStack
class ghmScriptStack
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[744];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScriptStack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptStack& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptStack>("ghmScriptStack")
			.addFunction("__tostring", &ghmScriptStack::ToString)
			.addFunction("GetPtrAddr", &ghmScriptStack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptStack) == 0x2e8, "expected ghmScriptStack to be size 0x2e8");

// [Structure] class ghmScriptContext
class ghmScriptContext : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class ghmScript* mpContainer, offset 0x10>
	class ghmScript* mpContainer = nullptr;

	// <class ghmScript* mpDataSource, offset 0x14>
	class ghmScript* mpDataSource = nullptr;

	// <class ghmScriptVariables mAutoVariables, offset 0x18>
	class ghmScriptVariables mAutoVariables;

	// <struct ghmScrFuncHeader* mpFuncHeader, offset 0x4c>
	struct ghmScrFuncHeader* mpFuncHeader = nullptr;

	// <uint16_t* mpCode, offset 0x50>
	uint16_t* mpCode = nullptr;

	// <int32_t mCodeCnt, offset 0x54>
	int32_t mCodeCnt = 0;

	// <class ghmScriptStack mStack, offset 0x58>
	class ghmScriptStack mStack;

	// <struct ghmScriptStackData mReturnData, offset 0x340>
	struct ghmScriptStackData mReturnData;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmScriptContext [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmScriptContext& InObject)
	{
		mpContainer = InObject.mpContainer;
		mpDataSource = InObject.mpDataSource;
		mAutoVariables = InObject.mAutoVariables;
		mpFuncHeader = InObject.mpFuncHeader;
		mpCode = InObject.mpCode;
		mCodeCnt = InObject.mCodeCnt;
		mStack = InObject.mStack;
		mReturnData = InObject.mReturnData;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmScriptContext, ghmListObj>("ghmScriptContext")
			.addFunction("__tostring", &ghmScriptContext::ToString)
			.addFunction("GetPtrAddr", &ghmScriptContext::GetPtrAddr)
			.addProperty("mpContainer", &ghmScriptContext::mpContainer)
			.addProperty("mpDataSource", &ghmScriptContext::mpDataSource)
			.addProperty("mAutoVariables", &ghmScriptContext::mAutoVariables)
			.addProperty("mpFuncHeader", &ghmScriptContext::mpFuncHeader)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpCode", &ghmScriptContext::mpCode)
			.addProperty("mCodeCnt", &ghmScriptContext::mCodeCnt)
			.addProperty("mStack", &ghmScriptContext::mStack)
			.addProperty("mReturnData", &ghmScriptContext::mReturnData)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptContext::mpContainer) == 4, "expected ghmScriptContext::mpContainer to be size 4");
static_assert(sizeof(ghmScriptContext::mpDataSource) == 4, "expected ghmScriptContext::mpDataSource to be size 4");
static_assert(sizeof(ghmScriptContext::mAutoVariables) == 52, "expected ghmScriptContext::mAutoVariables to be size 52");
static_assert(sizeof(ghmScriptContext::mpFuncHeader) == 4, "expected ghmScriptContext::mpFuncHeader to be size 4");
static_assert(sizeof(ghmScriptContext::mpCode) == 4, "expected ghmScriptContext::mpCode to be size 4");
static_assert(sizeof(ghmScriptContext::mCodeCnt) == 4, "expected ghmScriptContext::mCodeCnt to be size 4");
static_assert(sizeof(ghmScriptContext::mStack) == 744, "expected ghmScriptContext::mStack to be size 744");
static_assert(sizeof(ghmScriptContext::mReturnData) == 40, "expected ghmScriptContext::mReturnData to be size 40");
static_assert(sizeof(ghmScriptContext) == 0x368, "expected ghmScriptContext to be size 0x368");

// [Structure] class EveCorn
class EveCorn
{
public:
	/// Struct member variables

	// <uint8_t flag, offset 0x0>
	uint8_t flag = 0;

	// <Unidentified data segment, offset 0x1>
private:
	char _UnidentifiedData_1[3];

public:
	// <float mScale, offset 0x4>
	float mScale = 0;

	// <uint32_t mColor, offset 0x8>
	uint32_t mColor = 0;

	// <struct Vec mRootPosition, offset 0xc>
	struct Vec mRootPosition;

	// <float mRootRotY, offset 0x18>
	float mRootRotY = 0;

	// <float mRootRotY2, offset 0x1c>
	float mRootRotY2 = 0;

	// <int32_t mMoveProcess, offset 0x20>
	int32_t mMoveProcess = 0;

	// <int32_t mMakerType, offset 0x24>
	int32_t mMakerType = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EveCorn [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EveCorn& InObject)
	{
		flag = InObject.flag;
		mScale = InObject.mScale;
		mColor = InObject.mColor;
		mRootPosition = InObject.mRootPosition;
		mRootRotY = InObject.mRootRotY;
		mRootRotY2 = InObject.mRootRotY2;
		mMoveProcess = InObject.mMoveProcess;
		mMakerType = InObject.mMakerType;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EveCorn>("EveCorn")
			.addFunction("__tostring", &EveCorn::ToString)
			.addFunction("GetPtrAddr", &EveCorn::GetPtrAddr)
			.addProperty("flag", &EveCorn::flag)
			.addProperty("mScale", &EveCorn::mScale)
			.addProperty("mColor", &EveCorn::mColor)
			.addProperty("mRootPosition", &EveCorn::mRootPosition)
			.addProperty("mRootRotY", &EveCorn::mRootRotY)
			.addProperty("mRootRotY2", &EveCorn::mRootRotY2)
			.addProperty("mMoveProcess", &EveCorn::mMoveProcess)
			.addProperty("mMakerType", &EveCorn::mMakerType)
		.endClass();
	}
#endif
};
static_assert(sizeof(EveCorn::flag) == 1, "expected EveCorn::flag to be size 1");
static_assert(sizeof(EveCorn::mScale) == 4, "expected EveCorn::mScale to be size 4");
static_assert(sizeof(EveCorn::mColor) == 4, "expected EveCorn::mColor to be size 4");
static_assert(sizeof(EveCorn::mRootPosition) == 12, "expected EveCorn::mRootPosition to be size 12");
static_assert(sizeof(EveCorn::mRootRotY) == 4, "expected EveCorn::mRootRotY to be size 4");
static_assert(sizeof(EveCorn::mRootRotY2) == 4, "expected EveCorn::mRootRotY2 to be size 4");
static_assert(sizeof(EveCorn::mMoveProcess) == 4, "expected EveCorn::mMoveProcess to be size 4");
static_assert(sizeof(EveCorn::mMakerType) == 4, "expected EveCorn::mMakerType to be size 4");
static_assert(sizeof(EveCorn) == 0x28, "expected EveCorn to be size 0x28");

// [Structure] class EventAreaCamera
class EventAreaCamera : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct EVENTAREACAMERA_DATA* pd, offset 0x10>
	struct EVENTAREACAMERA_DATA* pd = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EventAreaCamera [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EventAreaCamera& InObject)
	{
		pd = InObject.pd;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EventAreaCamera, ghmListObj>("EventAreaCamera")
			.addFunction("__tostring", &EventAreaCamera::ToString)
			.addFunction("GetPtrAddr", &EventAreaCamera::GetPtrAddr)
			.addProperty("pd", &EventAreaCamera::pd)
		.endClass();
	}
#endif
};
static_assert(sizeof(EventAreaCamera::pd) == 4, "expected EventAreaCamera::pd to be size 4");
static_assert(sizeof(EventAreaCamera) == 0x14, "expected EventAreaCamera to be size 0x14");

// enum HRCAMERA_MODE
enum HRCAMERA_MODE : uint32_t
{
	// <HRCAMERA_MODE_NONE = 0xffffffffffffffff>
	HRCAMERA_MODE_NONE = UINT32_MAX,

	// <HRCAMERA_MODE_RAIL = 0x0>
	HRCAMERA_MODE_RAIL = 0,

	// <HRCAMERA_MODE_TEPPEI = 0x1>
	HRCAMERA_MODE_TEPPEI = 1,

	// <HRCAMERA_MODE_MOTION = 0x2>
	HRCAMERA_MODE_MOTION = 2,

	// <HRCAMERA_MODE_NORMAL = 0x3>
	HRCAMERA_MODE_NORMAL = 3,

	// <HRCAMERA_MODE_FREE = 0x4>
	HRCAMERA_MODE_FREE = 4

};

// [Structure] struct EVENTAREACAMERA_DATA
struct EVENTAREACAMERA_DATA
{
public:
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mCameraPos, offset 0xc>
	struct Vec mCameraPos;

	// <struct Vec mTargetPos, offset 0x18>
	struct Vec mTargetPos;

	// <struct Vec mCameraDirec, offset 0x24>
	struct Vec mCameraDirec;

	// <float mCameraDist, offset 0x30>
	float mCameraDist = 0;

	// <float mRadius, offset 0x34>
	float mRadius = 0;

	// <int32_t mWalkWait, offset 0x38>
	int32_t mWalkWait = 0;

	// <uint32_t mScriptHandle, offset 0x3c>
	uint32_t mScriptHandle = 0;

	// <uint8_t mDone, offset 0x40>
	uint8_t mDone = 0;

	// <uint8_t mFirstTouch, offset 0x41>
	uint8_t mFirstTouch = 0;

	// <char mStageName[0x10], offset 0x42>
	char mStageName[16];

	// <Unidentified data segment, offset 0x52>
private:
	char _UnidentifiedData_82[2];

public:
	// <int32_t mStatus, offset 0x54>
	int32_t mStatus = 0;

	// <enum HRCAMERA_MODE mCameraModeSave, offset 0x58>
	enum HRCAMERA_MODE mCameraModeSave;

	// <int32_t mType, offset 0x5c>
	int32_t mType = 0;

	// <class EventAreaCircle* mpEvAreaCircle, offset 0x60>
	class EventAreaCircle* mpEvAreaCircle = nullptr;

	// <class TGmf* mpGmfTgt, offset 0x64>
	class TGmf* mpGmfTgt = nullptr;

	// <uint8_t mEventEndCameraHold, offset 0x68>
	uint8_t mEventEndCameraHold = 0;

	// <uint8_t mEventEndPcNoRefresh, offset 0x69>
	uint8_t mEventEndPcNoRefresh = 0;

	// <Unidentified data segment, offset 0x6a>
private:
	char _UnidentifiedData_106[2];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct EVENTAREACAMERA_DATA [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EVENTAREACAMERA_DATA& InObject)
	{
		mCenter = InObject.mCenter;
		mCameraPos = InObject.mCameraPos;
		mTargetPos = InObject.mTargetPos;
		mCameraDirec = InObject.mCameraDirec;
		mCameraDist = InObject.mCameraDist;
		mRadius = InObject.mRadius;
		mWalkWait = InObject.mWalkWait;
		mScriptHandle = InObject.mScriptHandle;
		mDone = InObject.mDone;
		mFirstTouch = InObject.mFirstTouch;
		mStatus = InObject.mStatus;
		mCameraModeSave = InObject.mCameraModeSave;
		mType = InObject.mType;
		mpEvAreaCircle = InObject.mpEvAreaCircle;
		mpGmfTgt = InObject.mpGmfTgt;
		mEventEndCameraHold = InObject.mEventEndCameraHold;
		mEventEndPcNoRefresh = InObject.mEventEndPcNoRefresh;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EVENTAREACAMERA_DATA>("EVENTAREACAMERA_DATA")
			.addFunction("__tostring", &EVENTAREACAMERA_DATA::ToString)
			.addFunction("GetPtrAddr", &EVENTAREACAMERA_DATA::GetPtrAddr)
			.addProperty("mCenter", &EVENTAREACAMERA_DATA::mCenter)
			.addProperty("mCameraPos", &EVENTAREACAMERA_DATA::mCameraPos)
			.addProperty("mTargetPos", &EVENTAREACAMERA_DATA::mTargetPos)
			.addProperty("mCameraDirec", &EVENTAREACAMERA_DATA::mCameraDirec)
			.addProperty("mCameraDist", &EVENTAREACAMERA_DATA::mCameraDist)
			.addProperty("mRadius", &EVENTAREACAMERA_DATA::mRadius)
			.addProperty("mWalkWait", &EVENTAREACAMERA_DATA::mWalkWait)
			.addProperty("mScriptHandle", &EVENTAREACAMERA_DATA::mScriptHandle)
			.addProperty("mDone", &EVENTAREACAMERA_DATA::mDone)
			.addProperty("mFirstTouch", &EVENTAREACAMERA_DATA::mFirstTouch)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mStageName", &EVENTAREACAMERA_DATA::mStageName)
			.addProperty("mStatus", &EVENTAREACAMERA_DATA::mStatus)
			.addProperty("mCameraModeSave", &EVENTAREACAMERA_DATA::mCameraModeSave)
			.addProperty("mType", &EVENTAREACAMERA_DATA::mType)
			.addProperty("mpEvAreaCircle", &EVENTAREACAMERA_DATA::mpEvAreaCircle)
			.addProperty("mpGmfTgt", &EVENTAREACAMERA_DATA::mpGmfTgt)
			.addProperty("mEventEndCameraHold", &EVENTAREACAMERA_DATA::mEventEndCameraHold)
			.addProperty("mEventEndPcNoRefresh", &EVENTAREACAMERA_DATA::mEventEndPcNoRefresh)
		.endClass();
	}
#endif
};
static_assert(sizeof(EVENTAREACAMERA_DATA::mCenter) == 12, "expected EVENTAREACAMERA_DATA::mCenter to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraPos) == 12, "expected EVENTAREACAMERA_DATA::mCameraPos to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mTargetPos) == 12, "expected EVENTAREACAMERA_DATA::mTargetPos to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraDirec) == 12, "expected EVENTAREACAMERA_DATA::mCameraDirec to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraDist) == 4, "expected EVENTAREACAMERA_DATA::mCameraDist to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mRadius) == 4, "expected EVENTAREACAMERA_DATA::mRadius to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mWalkWait) == 4, "expected EVENTAREACAMERA_DATA::mWalkWait to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mScriptHandle) == 4, "expected EVENTAREACAMERA_DATA::mScriptHandle to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mDone) == 1, "expected EVENTAREACAMERA_DATA::mDone to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mFirstTouch) == 1, "expected EVENTAREACAMERA_DATA::mFirstTouch to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mStageName) == 16, "expected EVENTAREACAMERA_DATA::mStageName to be size 16");
static_assert(sizeof(EVENTAREACAMERA_DATA::mStatus) == 4, "expected EVENTAREACAMERA_DATA::mStatus to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraModeSave) == 4, "expected EVENTAREACAMERA_DATA::mCameraModeSave to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mType) == 4, "expected EVENTAREACAMERA_DATA::mType to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mpEvAreaCircle) == 4, "expected EVENTAREACAMERA_DATA::mpEvAreaCircle to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mpGmfTgt) == 4, "expected EVENTAREACAMERA_DATA::mpGmfTgt to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mEventEndCameraHold) == 1, "expected EVENTAREACAMERA_DATA::mEventEndCameraHold to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mEventEndPcNoRefresh) == 1, "expected EVENTAREACAMERA_DATA::mEventEndPcNoRefresh to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA) == 0x6c, "expected EVENTAREACAMERA_DATA to be size 0x6c");

// [Structure] class EffectDriftMark
class EffectDriftMark
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[388];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectDriftMark [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectDriftMark& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectDriftMark>("EffectDriftMark")
			.addFunction("__tostring", &EffectDriftMark::ToString)
			.addFunction("GetPtrAddr", &EffectDriftMark::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectDriftMark) == 0x184, "expected EffectDriftMark to be size 0x184");

// [Structure] class EffectKeepSmoke
class EffectKeepSmoke : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag = 0;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData_81[3];

public:
	// <class rPrimUnific m_QuadUni, offset 0x54>
	class rPrimUnific m_QuadUni;

	// <class rQuad* m_pQuadArray, offset 0x74>
	class rQuad* m_pQuadArray = nullptr;

	// <struct tagGHMR_TEX m_SubTex, offset 0x78>
	struct tagGHMR_TEX m_SubTex;

	// <struct Vec* m_pMoveVecArray, offset 0xa0>
	struct Vec* m_pMoveVecArray = nullptr;

	// <int32_t* m_pCountArray, offset 0xa4>
	int32_t* m_pCountArray = nullptr;

	// <float* m_pSpeedArray, offset 0xa8>
	float* m_pSpeedArray = nullptr;

	// <int32_t m_PrimNum, offset 0xac>
	int32_t m_PrimNum = 0;

	// <float m_Scale, offset 0xb0>
	float m_Scale = 0;

	// <int32_t m_FadeTime, offset 0xb4>
	int32_t m_FadeTime = 0;

	// <void* m_pRes, offset 0xb8>
	void* m_pRes = nullptr;

	// <float m_TimeCount, offset 0xbc>
	float m_TimeCount = 0;

	// <int32_t m_TimeFrame, offset 0xc0>
	int32_t m_TimeFrame = 0;

	// <float m_TimeRate, offset 0xc4>
	float m_TimeRate = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectKeepSmoke [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectKeepSmoke& InObject)
	{
		m_Flag = InObject.m_Flag;
		m_QuadUni = InObject.m_QuadUni;
		m_pQuadArray = InObject.m_pQuadArray;
		m_SubTex = InObject.m_SubTex;
		m_pMoveVecArray = InObject.m_pMoveVecArray;
		m_pCountArray = InObject.m_pCountArray;
		m_pSpeedArray = InObject.m_pSpeedArray;
		m_PrimNum = InObject.m_PrimNum;
		m_Scale = InObject.m_Scale;
		m_FadeTime = InObject.m_FadeTime;
		m_pRes = InObject.m_pRes;
		m_TimeCount = InObject.m_TimeCount;
		m_TimeFrame = InObject.m_TimeFrame;
		m_TimeRate = InObject.m_TimeRate;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectKeepSmoke, HrTask>("EffectKeepSmoke")
			.addFunction("__tostring", &EffectKeepSmoke::ToString)
			.addFunction("GetPtrAddr", &EffectKeepSmoke::GetPtrAddr)
			.addProperty("m_Flag", &EffectKeepSmoke::m_Flag)
			.addProperty("m_QuadUni", &EffectKeepSmoke::m_QuadUni)
			.addProperty("m_pQuadArray", &EffectKeepSmoke::m_pQuadArray)
			.addProperty("m_SubTex", &EffectKeepSmoke::m_SubTex)
			.addProperty("m_pMoveVecArray", &EffectKeepSmoke::m_pMoveVecArray)
			// native pointer type (int32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pCountArray", &EffectKeepSmoke::m_pCountArray)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pSpeedArray", &EffectKeepSmoke::m_pSpeedArray)
			.addProperty("m_PrimNum", &EffectKeepSmoke::m_PrimNum)
			.addProperty("m_Scale", &EffectKeepSmoke::m_Scale)
			.addProperty("m_FadeTime", &EffectKeepSmoke::m_FadeTime)
			// void type not supported in LuaBridge
			//.addProperty("m_pRes", &EffectKeepSmoke::m_pRes)
			.addProperty("m_TimeCount", &EffectKeepSmoke::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectKeepSmoke::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectKeepSmoke::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectKeepSmoke::m_Flag) == 1, "expected EffectKeepSmoke::m_Flag to be size 1");
static_assert(sizeof(EffectKeepSmoke::m_QuadUni) == 32, "expected EffectKeepSmoke::m_QuadUni to be size 32");
static_assert(sizeof(EffectKeepSmoke::m_pQuadArray) == 4, "expected EffectKeepSmoke::m_pQuadArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_SubTex) == 40, "expected EffectKeepSmoke::m_SubTex to be size 40");
static_assert(sizeof(EffectKeepSmoke::m_pMoveVecArray) == 4, "expected EffectKeepSmoke::m_pMoveVecArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pCountArray) == 4, "expected EffectKeepSmoke::m_pCountArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pSpeedArray) == 4, "expected EffectKeepSmoke::m_pSpeedArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_PrimNum) == 4, "expected EffectKeepSmoke::m_PrimNum to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_Scale) == 4, "expected EffectKeepSmoke::m_Scale to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_FadeTime) == 4, "expected EffectKeepSmoke::m_FadeTime to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pRes) == 4, "expected EffectKeepSmoke::m_pRes to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeCount) == 4, "expected EffectKeepSmoke::m_TimeCount to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeFrame) == 4, "expected EffectKeepSmoke::m_TimeFrame to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeRate) == 4, "expected EffectKeepSmoke::m_TimeRate to be size 4");
static_assert(sizeof(EffectKeepSmoke) == 0xc8, "expected EffectKeepSmoke to be size 0xc8");

// [Structure] class rQuad
class rQuad
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[172];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rQuad [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rQuad& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rQuad>("rQuad")
			.addFunction("__tostring", &rQuad::ToString)
			.addFunction("GetPtrAddr", &rQuad::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(rQuad) == 0xac, "expected rQuad to be size 0xac");

// [Structure] class EffectFixFire
class EffectFixFire : public HrTask
{
public:
	// [Structure] struct EffectFixFire::Object
	struct Object
	{
	public:
		/// Struct member variables

		// <EffectFixFire::Object* m_pNext, offset 0x0>
		Object* m_pNext = nullptr;

		// <EffectFixFire::Object* m_pPrev, offset 0x4>
		Object* m_pPrev = nullptr;

		// <uint8_t m_Fade, offset 0x8>
		uint8_t m_Fade = 0;

		// <Unidentified data segment, offset 0x9>
	private:
		char _UnidentifiedData_9[3];

	public:
		// <struct Vec m_MoveVec, offset 0xc>
		struct Vec m_MoveVec;

		// <struct Vec m_LocalPos, offset 0x18>
		struct Vec m_LocalPos;

		// <float m_Scale, offset 0x24>
		float m_Scale = 0;

		// <float m_u, offset 0x28>
		float m_u = 0;

		// <float m_v, offset 0x2c>
		float m_v = 0;

		// <int32_t m_Alpha, offset 0x30>
		int32_t m_Alpha = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectFixFire::Object [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectFixFire::Object& InObject)
		{
			m_pNext = InObject.m_pNext;
			m_pPrev = InObject.m_pPrev;
			m_Fade = InObject.m_Fade;
			m_MoveVec = InObject.m_MoveVec;
			m_LocalPos = InObject.m_LocalPos;
			m_Scale = InObject.m_Scale;
			m_u = InObject.m_u;
			m_v = InObject.m_v;
			m_Alpha = InObject.m_Alpha;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<Object>("EffectFixFire_Object")
				.addFunction("__tostring", &EffectFixFire::Object::ToString)
				.addFunction("GetPtrAddr", &EffectFixFire::Object::GetPtrAddr)
				.addProperty("m_pNext", &EffectFixFire::Object::m_pNext)
				.addProperty("m_pPrev", &EffectFixFire::Object::m_pPrev)
				.addProperty("m_Fade", &EffectFixFire::Object::m_Fade)
				.addProperty("m_MoveVec", &EffectFixFire::Object::m_MoveVec)
				.addProperty("m_LocalPos", &EffectFixFire::Object::m_LocalPos)
				.addProperty("m_Scale", &EffectFixFire::Object::m_Scale)
				.addProperty("m_u", &EffectFixFire::Object::m_u)
				.addProperty("m_v", &EffectFixFire::Object::m_v)
				.addProperty("m_Alpha", &EffectFixFire::Object::m_Alpha)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFixFire::Object::m_pNext) == 4, "expected EffectFixFire::Object::m_pNext to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_pPrev) == 4, "expected EffectFixFire::Object::m_pPrev to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_Fade) == 1, "expected EffectFixFire::Object::m_Fade to be size 1");
	static_assert(sizeof(EffectFixFire::Object::m_MoveVec) == 12, "expected EffectFixFire::Object::m_MoveVec to be size 12");
	static_assert(sizeof(EffectFixFire::Object::m_LocalPos) == 12, "expected EffectFixFire::Object::m_LocalPos to be size 12");
	static_assert(sizeof(EffectFixFire::Object::m_Scale) == 4, "expected EffectFixFire::Object::m_Scale to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_u) == 4, "expected EffectFixFire::Object::m_u to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_v) == 4, "expected EffectFixFire::Object::m_v to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_Alpha) == 4, "expected EffectFixFire::Object::m_Alpha to be size 4");
	static_assert(sizeof(EffectFixFire::Object) == 0x34, "expected EffectFixFire::Object to be size 0x34");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag = 0;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData_81[3];

public:
	// <struct EffectFixFire::Object* m_pObject, offset 0x54>
	struct EffectFixFire::Object* m_pObject = nullptr;

	// <struct EffectFixFire::Object m_ValidFirst, offset 0x58>
	struct EffectFixFire::Object m_ValidFirst;

	// <struct EffectFixFire::Object m_ValidLast, offset 0x8c>
	struct EffectFixFire::Object m_ValidLast;

	// <struct EffectFixFire::Object m_FreeFirst, offset 0xc0>
	struct EffectFixFire::Object m_FreeFirst;

	// <struct EffectFixFire::Object m_FreeLast, offset 0xf4>
	struct EffectFixFire::Object m_FreeLast;

	// <struct tagGHMR_TEX m_Tex, offset 0x128>
	struct tagGHMR_TEX m_Tex;

	// <enum GHMR_BLEND m_BlendMode, offset 0x150>
	enum GHMR_BLEND m_BlendMode;

	// <int32_t m_FadeAlphaSpeed, offset 0x154>
	int32_t m_FadeAlphaSpeed = 0;

	// <int32_t m_PrimNum, offset 0x158>
	int32_t m_PrimNum = 0;

	// <int32_t m_ValidPrimNum, offset 0x15c>
	int32_t m_ValidPrimNum = 0;

	// <struct Vec m_CenterPos, offset 0x160>
	struct Vec m_CenterPos;

	// <struct Vec m_Direc, offset 0x16c>
	struct Vec m_Direc;

	// <struct Vec m_RotRange, offset 0x178>
	struct Vec m_RotRange;

	// <float m_Speed, offset 0x184>
	float m_Speed = 0;

	// <struct GXColor m_Color, offset 0x188>
	struct GXColor m_Color;

	// <float m_Scale, offset 0x18c>
	float m_Scale = 0;

	// <float m_ScaleAnime, offset 0x190>
	float m_ScaleAnime = 0;

	// <float m_TimeCount, offset 0x194>
	float m_TimeCount = 0;

	// <int32_t m_TimeFrame, offset 0x198>
	int32_t m_TimeFrame = 0;

	// <float m_TimeRate, offset 0x19c>
	float m_TimeRate = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectFixFire [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectFixFire& InObject)
	{
		m_Flag = InObject.m_Flag;
		m_pObject = InObject.m_pObject;
		m_ValidFirst = InObject.m_ValidFirst;
		m_ValidLast = InObject.m_ValidLast;
		m_FreeFirst = InObject.m_FreeFirst;
		m_FreeLast = InObject.m_FreeLast;
		m_Tex = InObject.m_Tex;
		m_BlendMode = InObject.m_BlendMode;
		m_FadeAlphaSpeed = InObject.m_FadeAlphaSpeed;
		m_PrimNum = InObject.m_PrimNum;
		m_ValidPrimNum = InObject.m_ValidPrimNum;
		m_CenterPos = InObject.m_CenterPos;
		m_Direc = InObject.m_Direc;
		m_RotRange = InObject.m_RotRange;
		m_Speed = InObject.m_Speed;
		m_Color = InObject.m_Color;
		m_Scale = InObject.m_Scale;
		m_ScaleAnime = InObject.m_ScaleAnime;
		m_TimeCount = InObject.m_TimeCount;
		m_TimeFrame = InObject.m_TimeFrame;
		m_TimeRate = InObject.m_TimeRate;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectFixFire, HrTask>("EffectFixFire")
			.addFunction("__tostring", &EffectFixFire::ToString)
			.addFunction("GetPtrAddr", &EffectFixFire::GetPtrAddr)
			.addProperty("m_Flag", &EffectFixFire::m_Flag)
			.addProperty("m_pObject", &EffectFixFire::m_pObject)
			.addProperty("m_ValidFirst", &EffectFixFire::m_ValidFirst)
			.addProperty("m_ValidLast", &EffectFixFire::m_ValidLast)
			.addProperty("m_FreeFirst", &EffectFixFire::m_FreeFirst)
			.addProperty("m_FreeLast", &EffectFixFire::m_FreeLast)
			.addProperty("m_Tex", &EffectFixFire::m_Tex)
			.addProperty("m_BlendMode", &EffectFixFire::m_BlendMode)
			.addProperty("m_FadeAlphaSpeed", &EffectFixFire::m_FadeAlphaSpeed)
			.addProperty("m_PrimNum", &EffectFixFire::m_PrimNum)
			.addProperty("m_ValidPrimNum", &EffectFixFire::m_ValidPrimNum)
			.addProperty("m_CenterPos", &EffectFixFire::m_CenterPos)
			.addProperty("m_Direc", &EffectFixFire::m_Direc)
			.addProperty("m_RotRange", &EffectFixFire::m_RotRange)
			.addProperty("m_Speed", &EffectFixFire::m_Speed)
			.addProperty("m_Color", &EffectFixFire::m_Color)
			.addProperty("m_Scale", &EffectFixFire::m_Scale)
			.addProperty("m_ScaleAnime", &EffectFixFire::m_ScaleAnime)
			.addProperty("m_TimeCount", &EffectFixFire::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectFixFire::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectFixFire::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectFixFire::m_Flag) == 1, "expected EffectFixFire::m_Flag to be size 1");
static_assert(sizeof(EffectFixFire::m_pObject) == 4, "expected EffectFixFire::m_pObject to be size 4");
static_assert(sizeof(EffectFixFire::m_ValidFirst) == 52, "expected EffectFixFire::m_ValidFirst to be size 52");
static_assert(sizeof(EffectFixFire::m_ValidLast) == 52, "expected EffectFixFire::m_ValidLast to be size 52");
static_assert(sizeof(EffectFixFire::m_FreeFirst) == 52, "expected EffectFixFire::m_FreeFirst to be size 52");
static_assert(sizeof(EffectFixFire::m_FreeLast) == 52, "expected EffectFixFire::m_FreeLast to be size 52");
static_assert(sizeof(EffectFixFire::m_Tex) == 40, "expected EffectFixFire::m_Tex to be size 40");
static_assert(sizeof(EffectFixFire::m_BlendMode) == 4, "expected EffectFixFire::m_BlendMode to be size 4");
static_assert(sizeof(EffectFixFire::m_FadeAlphaSpeed) == 4, "expected EffectFixFire::m_FadeAlphaSpeed to be size 4");
static_assert(sizeof(EffectFixFire::m_PrimNum) == 4, "expected EffectFixFire::m_PrimNum to be size 4");
static_assert(sizeof(EffectFixFire::m_ValidPrimNum) == 4, "expected EffectFixFire::m_ValidPrimNum to be size 4");
static_assert(sizeof(EffectFixFire::m_CenterPos) == 12, "expected EffectFixFire::m_CenterPos to be size 12");
static_assert(sizeof(EffectFixFire::m_Direc) == 12, "expected EffectFixFire::m_Direc to be size 12");
static_assert(sizeof(EffectFixFire::m_RotRange) == 12, "expected EffectFixFire::m_RotRange to be size 12");
static_assert(sizeof(EffectFixFire::m_Speed) == 4, "expected EffectFixFire::m_Speed to be size 4");
static_assert(sizeof(EffectFixFire::m_Color) == 4, "expected EffectFixFire::m_Color to be size 4");
static_assert(sizeof(EffectFixFire::m_Scale) == 4, "expected EffectFixFire::m_Scale to be size 4");
static_assert(sizeof(EffectFixFire::m_ScaleAnime) == 4, "expected EffectFixFire::m_ScaleAnime to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeCount) == 4, "expected EffectFixFire::m_TimeCount to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeFrame) == 4, "expected EffectFixFire::m_TimeFrame to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeRate) == 4, "expected EffectFixFire::m_TimeRate to be size 4");
static_assert(sizeof(EffectFixFire) == 0x1a0, "expected EffectFixFire to be size 0x1a0");

// [Structure] class EffectCloseContest
class EffectCloseContest : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag = 0;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData_81[3];

public:
	// <class rPrimUnific m_QuadUni, offset 0x54>
	class rPrimUnific m_QuadUni;

	// <class rQuad m_Quad, offset 0x74>
	class rQuad m_Quad;

	// <uint8_t m_QuadScale, offset 0x120>
	uint8_t m_QuadScale = 0;

	// <Unidentified data segment, offset 0x121>
private:
	char _UnidentifiedData_289[3];

public:
	// <float m_SetCount, offset 0x124>
	float m_SetCount = 0;

	// <float m_SetRate, offset 0x128>
	float m_SetRate = 0;

	// <float m_TimeCount, offset 0x12c>
	float m_TimeCount = 0;

	// <int32_t m_TimeFrame, offset 0x130>
	int32_t m_TimeFrame = 0;

	// <float m_TimeRate, offset 0x134>
	float m_TimeRate = 0;

	// <class EfLineSpark* mpLineSpark, offset 0x138>
	class EfLineSpark* mpLineSpark = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectCloseContest [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectCloseContest& InObject)
	{
		m_Flag = InObject.m_Flag;
		m_QuadUni = InObject.m_QuadUni;
		m_Quad = InObject.m_Quad;
		m_QuadScale = InObject.m_QuadScale;
		m_SetCount = InObject.m_SetCount;
		m_SetRate = InObject.m_SetRate;
		m_TimeCount = InObject.m_TimeCount;
		m_TimeFrame = InObject.m_TimeFrame;
		m_TimeRate = InObject.m_TimeRate;
		mpLineSpark = InObject.mpLineSpark;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectCloseContest, HrTask>("EffectCloseContest")
			.addFunction("__tostring", &EffectCloseContest::ToString)
			.addFunction("GetPtrAddr", &EffectCloseContest::GetPtrAddr)
			.addProperty("m_Flag", &EffectCloseContest::m_Flag)
			.addProperty("m_QuadUni", &EffectCloseContest::m_QuadUni)
			.addProperty("m_Quad", &EffectCloseContest::m_Quad)
			.addProperty("m_QuadScale", &EffectCloseContest::m_QuadScale)
			.addProperty("m_SetCount", &EffectCloseContest::m_SetCount)
			.addProperty("m_SetRate", &EffectCloseContest::m_SetRate)
			.addProperty("m_TimeCount", &EffectCloseContest::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectCloseContest::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectCloseContest::m_TimeRate)
			.addProperty("mpLineSpark", &EffectCloseContest::mpLineSpark)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectCloseContest::m_Flag) == 1, "expected EffectCloseContest::m_Flag to be size 1");
static_assert(sizeof(EffectCloseContest::m_QuadUni) == 32, "expected EffectCloseContest::m_QuadUni to be size 32");
static_assert(sizeof(EffectCloseContest::m_Quad) == 172, "expected EffectCloseContest::m_Quad to be size 172");
static_assert(sizeof(EffectCloseContest::m_QuadScale) == 1, "expected EffectCloseContest::m_QuadScale to be size 1");
static_assert(sizeof(EffectCloseContest::m_SetCount) == 4, "expected EffectCloseContest::m_SetCount to be size 4");
static_assert(sizeof(EffectCloseContest::m_SetRate) == 4, "expected EffectCloseContest::m_SetRate to be size 4");
static_assert(sizeof(EffectCloseContest::m_TimeCount) == 4, "expected EffectCloseContest::m_TimeCount to be size 4");
static_assert(sizeof(EffectCloseContest::m_TimeFrame) == 4, "expected EffectCloseContest::m_TimeFrame to be size 4");
static_assert(sizeof(EffectCloseContest::m_TimeRate) == 4, "expected EffectCloseContest::m_TimeRate to be size 4");
static_assert(sizeof(EffectCloseContest::mpLineSpark) == 4, "expected EffectCloseContest::mpLineSpark to be size 4");
static_assert(sizeof(EffectCloseContest) == 0x13c, "expected EffectCloseContest to be size 0x13c");

// [Structure] class EfLineSpark
class EfLineSpark : public HrTask
{
public:
	// [Structure] struct EfLineSpark::LinePrim
	struct LinePrim
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData_0[136];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EfLineSpark::LinePrim [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EfLineSpark::LinePrim& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<LinePrim>("EfLineSpark_LinePrim")
				.addFunction("__tostring", &EfLineSpark::LinePrim::ToString)
				.addFunction("GetPtrAddr", &EfLineSpark::LinePrim::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EfLineSpark::LinePrim) == 0x88, "expected EfLineSpark::LinePrim to be size 0x88");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <struct EfLineSpark::LinePrim* mpPrimAry, offset 0x68>
	struct EfLineSpark::LinePrim* mpPrimAry = nullptr;

	// <struct EfLineSpark::LinePrim* mpValidList, offset 0x6c>
	struct EfLineSpark::LinePrim* mpValidList = nullptr;

	// <struct EfLineSpark::LinePrim* mpActiveList, offset 0x70>
	struct EfLineSpark::LinePrim* mpActiveList = nullptr;

	// <struct tagGHMR_TEX mTex, offset 0x74>
	struct tagGHMR_TEX mTex;

	// <int32_t mActiveNum, offset 0x9c>
	int32_t mActiveNum = 0;

	// <int32_t mSparkMax, offset 0xa0>
	int32_t mSparkMax = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfLineSpark [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfLineSpark& InObject)
	{
		field_50 = InObject.field_50;
		mpPrimAry = InObject.mpPrimAry;
		mpValidList = InObject.mpValidList;
		mpActiveList = InObject.mpActiveList;
		mTex = InObject.mTex;
		mActiveNum = InObject.mActiveNum;
		mSparkMax = InObject.mSparkMax;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfLineSpark, HrTask>("EfLineSpark")
			.addFunction("__tostring", &EfLineSpark::ToString)
			.addFunction("GetPtrAddr", &EfLineSpark::GetPtrAddr)
			.addProperty("field_50", &EfLineSpark::field_50)
			.addProperty("mpPrimAry", &EfLineSpark::mpPrimAry)
			.addProperty("mpValidList", &EfLineSpark::mpValidList)
			.addProperty("mpActiveList", &EfLineSpark::mpActiveList)
			.addProperty("mTex", &EfLineSpark::mTex)
			.addProperty("mActiveNum", &EfLineSpark::mActiveNum)
			.addProperty("mSparkMax", &EfLineSpark::mSparkMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfLineSpark::field_50) == 24, "expected EfLineSpark::field_50 to be size 24");
static_assert(sizeof(EfLineSpark::mpPrimAry) == 4, "expected EfLineSpark::mpPrimAry to be size 4");
static_assert(sizeof(EfLineSpark::mpValidList) == 4, "expected EfLineSpark::mpValidList to be size 4");
static_assert(sizeof(EfLineSpark::mpActiveList) == 4, "expected EfLineSpark::mpActiveList to be size 4");
static_assert(sizeof(EfLineSpark::mTex) == 40, "expected EfLineSpark::mTex to be size 40");
static_assert(sizeof(EfLineSpark::mActiveNum) == 4, "expected EfLineSpark::mActiveNum to be size 4");
static_assert(sizeof(EfLineSpark::mSparkMax) == 4, "expected EfLineSpark::mSparkMax to be size 4");
static_assert(sizeof(EfLineSpark) == 0xa4, "expected EfLineSpark to be size 0xa4");

// [Structure] class HrOverLap
class HrOverLap
{
public:
	/// Struct member variables

	// <uint8_t mAlloc, offset 0x0>
	uint8_t mAlloc = 0;

	// <Unidentified data segment, offset 0x1>
private:
	char _UnidentifiedData_1[3];

public:
	// <int32_t mStatus, offset 0x4>
	int32_t mStatus = 0;

	// <float mAlpha, offset 0x8>
	float mAlpha = 0;

	// <float mSpeed, offset 0xc>
	float mSpeed = 0;

	// <struct tagGHMR_TEX mTex, offset 0x10>
	struct tagGHMR_TEX mTex;

	// <uint8_t mbVisible, offset 0x38>
	uint8_t mbVisible = 0;

	// <Unidentified data segment, offset 0x39>
private:
	char _UnidentifiedData_57[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrOverLap [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrOverLap& InObject)
	{
		mAlloc = InObject.mAlloc;
		mStatus = InObject.mStatus;
		mAlpha = InObject.mAlpha;
		mSpeed = InObject.mSpeed;
		mTex = InObject.mTex;
		mbVisible = InObject.mbVisible;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrOverLap>("HrOverLap")
			.addFunction("__tostring", &HrOverLap::ToString)
			.addFunction("GetPtrAddr", &HrOverLap::GetPtrAddr)
			.addProperty("mAlloc", &HrOverLap::mAlloc)
			.addProperty("mStatus", &HrOverLap::mStatus)
			.addProperty("mAlpha", &HrOverLap::mAlpha)
			.addProperty("mSpeed", &HrOverLap::mSpeed)
			.addProperty("mTex", &HrOverLap::mTex)
			.addProperty("mbVisible", &HrOverLap::mbVisible)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrOverLap::mAlloc) == 1, "expected HrOverLap::mAlloc to be size 1");
static_assert(sizeof(HrOverLap::mStatus) == 4, "expected HrOverLap::mStatus to be size 4");
static_assert(sizeof(HrOverLap::mAlpha) == 4, "expected HrOverLap::mAlpha to be size 4");
static_assert(sizeof(HrOverLap::mSpeed) == 4, "expected HrOverLap::mSpeed to be size 4");
static_assert(sizeof(HrOverLap::mTex) == 40, "expected HrOverLap::mTex to be size 40");
static_assert(sizeof(HrOverLap::mbVisible) == 1, "expected HrOverLap::mbVisible to be size 1");
static_assert(sizeof(HrOverLap) == 0x3c, "expected HrOverLap to be size 0x3c");

// [Structure] class CBgCtrl
class CBgCtrl
{
public:
	// enum CBgCtrl::CBGCTRL_LOADSTATUS
	enum CBGCTRL_LOADSTATUS : uint32_t
	{
		// <CBGCTRL_LOADSTATUS_SETUP = 0x0>
		CBGCTRL_LOADSTATUS_SETUP = 0,

		// <CBGCTRL_LOADSTATUS_LOADING = 0x1>
		CBGCTRL_LOADSTATUS_LOADING = 1,

		// <CBGCTRL_LOADSTATUS_SCR_POOL = 0x2>
		CBGCTRL_LOADSTATUS_SCR_POOL = 2,

		// <CBGCTRL_LOADSTATUS_SUBMISSIONSTATICSOUND_SET = 0x3>
		CBGCTRL_LOADSTATUS_SUBMISSIONSTATICSOUND_SET = 3,

		// <CBGCTRL_LOADSTATUS_SUBMISSIONSTATICSOUND_POOL = 0x4>
		CBGCTRL_LOADSTATUS_SUBMISSIONSTATICSOUND_POOL = 4,

		// <CBGCTRL_LOADSTATUS_RESULTSOUND_SET = 0x5>
		CBGCTRL_LOADSTATUS_RESULTSOUND_SET = 5,

		// <CBGCTRL_LOADSTATUS_RESULTSOUND_POOL = 0x6>
		CBGCTRL_LOADSTATUS_RESULTSOUND_POOL = 6,

		// <CBGCTRL_LOADSTATUS_SUBMISSIONSOUND_SET = 0x7>
		CBGCTRL_LOADSTATUS_SUBMISSIONSOUND_SET = 7,

		// <CBGCTRL_LOADSTATUS_SUBMISSIONSOUND_POOL = 0x8>
		CBGCTRL_LOADSTATUS_SUBMISSIONSOUND_POOL = 8,

		// <CBGCTRL_LOADSTATUS_SOUND_SET = 0x9>
		CBGCTRL_LOADSTATUS_SOUND_SET = 9,

		// <CBGCTRL_LOADSTATUS_SOUND_POOL = 0xa>
		CBGCTRL_LOADSTATUS_SOUND_POOL = 10,

		// <CBGCTRL_LOADSTATUS_SUB_SOUND_SET = 0xb>
		CBGCTRL_LOADSTATUS_SUB_SOUND_SET = 11,

		// <CBGCTRL_LOADSTATUS_SUB_SOUND_POOL = 0xc>
		CBGCTRL_LOADSTATUS_SUB_SOUND_POOL = 12,

		// <CBGCTRL_LOADSTATUS_ENB_SOUND_SET = 0xd>
		CBGCTRL_LOADSTATUS_ENB_SOUND_SET = 13,

		// <CBGCTRL_LOADSTATUS_ENB_SOUND_POOL = 0xe>
		CBGCTRL_LOADSTATUS_ENB_SOUND_POOL = 14,

		// <CBGCTRL_LOADSTATUS_SOUND_SETOK = 0xf>
		CBGCTRL_LOADSTATUS_SOUND_SETOK = 15,

		// <CBGCTRL_LOADSTATUS_STG_PG_LOAD = 0x10>
		CBGCTRL_LOADSTATUS_STG_PG_LOAD = 16,

		// <CBGCTRL_LOADSTATUS_READY = 0x11>
		CBGCTRL_LOADSTATUS_READY = 17,

		// <CBGCTRL_LOADSTATUS_REQUEST = 0x12>
		CBGCTRL_LOADSTATUS_REQUEST = 18,

		// <CBGCTRL_LOADSTATUS_NPCLOADREQUEST = 0x13>
		CBGCTRL_LOADSTATUS_NPCLOADREQUEST = 19,

		// <CBGCTRL_LOADSTATUS_NPCLOADING = 0x14>
		CBGCTRL_LOADSTATUS_NPCLOADING = 20,

		// <CBGCTRL_LOADSTATUS_MAX = 0x15>
		CBGCTRL_LOADSTATUS_MAX = 21

	};

	// enum CBgCtrl::CBGCTRL_STATUS
	enum CBGCTRL_STATUS : uint32_t
	{
		// <CBGCTRL_STATUS_NO_DATA = 0x0>
		CBGCTRL_STATUS_NO_DATA = 0,

		// <CBGCTRL_STATUS_LOAD = 0x1>
		CBGCTRL_STATUS_LOAD = 1,

		// <CBGCTRL_STATUS_INIT = 0x2>
		CBGCTRL_STATUS_INIT = 2,

		// <CBGCTRL_STATUS_IDLE = 0x3>
		CBGCTRL_STATUS_IDLE = 3,

		// <CBGCTRL_STATUS_RELEASESETUP = 0x4>
		CBGCTRL_STATUS_RELEASESETUP = 4,

		// <CBGCTRL_STATUS_NPCRELEASE = 0x5>
		CBGCTRL_STATUS_NPCRELEASE = 5,

		// <CBGCTRL_STATUS_RELEASE = 0x6>
		CBGCTRL_STATUS_RELEASE = 6,

		// <CBGCTRL_STATUS_SNDGROUPRELEASE = 0x7>
		CBGCTRL_STATUS_SNDGROUPRELEASE = 7,

		// <CBGCTRL_STATUS_TESTDEMO = 0x8>
		CBGCTRL_STATUS_TESTDEMO = 8,

		// <CBGCTRL_STATUS_DEMOSETUP = 0x9>
		CBGCTRL_STATUS_DEMOSETUP = 9,

		// <CBGCTRL_STATUS_DEMOPLAY = 0xa>
		CBGCTRL_STATUS_DEMOPLAY = 10,

		// <CBGCTRL_STATUS_BOSSRESULTWAIT = 0xb>
		CBGCTRL_STATUS_BOSSRESULTWAIT = 11,

		// <CBGCTRL_STATUS_STAFF1WAIT = 0xc>
		CBGCTRL_STATUS_STAFF1WAIT = 12,

		// <CBGCTRL_STATUS_STAFF2WAIT = 0xd>
		CBGCTRL_STATUS_STAFF2WAIT = 13,

		// <CBGCTRL_STATUS_SHOOTINGWAIT = 0xe>
		CBGCTRL_STATUS_SHOOTINGWAIT = 14,

		// <CBGCTRL_STATUS_CHANGESTAGE = 0xf>
		CBGCTRL_STATUS_CHANGESTAGE = 15,

		// <CBGCTRL_STATUS_NPCRSLLOAD = 0x10>
		CBGCTRL_STATUS_NPCRSLLOAD = 16,

		// <CBGCTRL_STATUS_DEMO_WAIT = 0x11>
		CBGCTRL_STATUS_DEMO_WAIT = 17,

		// <CBGCTRL_STATUS_LOADTOILETEFC = 0x12>
		CBGCTRL_STATUS_LOADTOILETEFC = 18,

		// <CBGCTRL_STATUS_LOADINGTOILETEFC = 0x13>
		CBGCTRL_STATUS_LOADINGTOILETEFC = 19,

		// <CBGCTRL_STATUS_FILLINTOILETEFC = 0x14>
		CBGCTRL_STATUS_FILLINTOILETEFC = 20,

		// <CBGCTRL_STATUS_FILLINOUTTOILETEFC = 0x15>
		CBGCTRL_STATUS_FILLINOUTTOILETEFC = 21,

		// <CBGCTRL_STATUS_TESTMOVIE = 0x16>
		CBGCTRL_STATUS_TESTMOVIE = 22,

		// <CBGCTRL_STATUS_MOVIESETUP = 0x17>
		CBGCTRL_STATUS_MOVIESETUP = 23,

		// <CBGCTRL_STATUS_MOVIEPLAY = 0x18>
		CBGCTRL_STATUS_MOVIEPLAY = 24,

		// <CBGCTRL_STATUS_MAX = 0x19>
		CBGCTRL_STATUS_MAX = 25

	};

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[2866];

public:
	// <bool IsDarkStage, offset 0xb32>
	bool IsDarkStage;

	// <Unidentified data segment, offset 0xb33>
private:
	char _UnidentifiedData_2867[5];

public:
	// <char* StageName, offset 0xb38>
	char* StageName = nullptr;

	// <Unidentified data segment, offset 0xb3c>
private:
	char _UnidentifiedData_2876[60];

public:
	// <int32_t StageID, offset 0xb78>
	int32_t StageID = 0;

	// <Unidentified data segment, offset 0xb7c>
private:
	char _UnidentifiedData_2940[32];

public:
	// <class ghmResGroup* ResGroup, offset 0xb9c>
	class ghmResGroup* ResGroup = nullptr;

	// <Unidentified data segment, offset 0xba0>
private:
	char _UnidentifiedData_2976[155];

public:
	// <bool ToneMapEnabled, offset 0xc3b>
	bool ToneMapEnabled;

	// <Unidentified data segment, offset 0xc3c>
private:
	char _UnidentifiedData_3132[4];

public:
	// <class rSkyMap* SkyMap, offset 0xc40>
	class rSkyMap* SkyMap = nullptr;

	// <Unidentified data segment, offset 0xc44>
private:
	char _UnidentifiedData_3140[496];

public:
	// <uint32_t Status, offset 0xe34>
	uint32_t Status = 0;

	// <int32_t UnknownResourceFlag, offset 0xe38>
	int32_t UnknownResourceFlag = 0;

	// <Unidentified data segment, offset 0xe3c>
private:
	char _UnidentifiedData_3644[12];

public:
	/// 123 Functions

	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsVisible(class CBgCtrl* const this) [?IsVisible@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsVisible_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsVisible()
	{
		_IsVisible_CBgCtrl__QAE_NXZ mFunc = (_IsVisible_CBgCtrl__QAE_NXZ)(GameModule + 0x9cd70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetDarkStage(class CBgCtrl* const this, uint8_t arg2) [?SetDarkStage@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetDarkStage_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetDarkStage(uint8_t arg2)
	{
		_SetDarkStage_CBgCtrl__QAEX_N_Z mFunc = (_SetDarkStage_CBgCtrl__QAEX_N_Z)(GameModule + 0x9cd80);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") CBgCtrl::GetStageID(class CBgCtrl* const this) [?GetStageID@CBgCtrl@@QBEHXZ]
	typedef int32_t(__thiscall* _GetStageID_CBgCtrl__QBEHXZ)(class CBgCtrl* const thisPtr);
	int32_t GetStageID()
	{
		_GetStageID_CBgCtrl__QBEHXZ mFunc = (_GetStageID_CBgCtrl__QBEHXZ)(GameModule + 0x9cd90);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") CBgCtrl::GetScrHandle(class CBgCtrl* const this) [?GetScrHandle@CBgCtrl@@QAEIXZ]
	typedef uint32_t(__thiscall* _GetScrHandle_CBgCtrl__QAEIXZ)(class CBgCtrl* const thisPtr);
	uint32_t GetScrHandle()
	{
		_GetScrHandle_CBgCtrl__QAEIXZ mFunc = (_GetScrHandle_CBgCtrl__QAEIXZ)(GameModule + 0xa2260);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetPositionChange(class CBgCtrl* const this) [?SetPositionChange@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _SetPositionChange_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void SetPositionChange()
	{
		_SetPositionChange_CBgCtrl__QAEXXZ mFunc = (_SetPositionChange_CBgCtrl__QAEXXZ)(GameModule + 0xa2270);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetNpcVisible(class CBgCtrl* const this, uint8_t arg2) [?SetNpcVisible@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetNpcVisible_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetNpcVisible(uint8_t arg2)
	{
		_SetNpcVisible_CBgCtrl__QAEX_N_Z mFunc = (_SetNpcVisible_CBgCtrl__QAEX_N_Z)(GameModule + 0xa2280);
		return mFunc(this, arg2);
	}
	// [Function] class TGmf* __convention("thiscall") CBgCtrl::GetStageGmfPtr(class CBgCtrl* const this) [?GetStageGmfPtr@CBgCtrl@@QAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _GetStageGmfPtr_CBgCtrl__QAEPAVTGmf__XZ)(class CBgCtrl* const thisPtr);
	class TGmf* GetStageGmfPtr()
	{
		_GetStageGmfPtr_CBgCtrl__QAEPAVTGmf__XZ mFunc = (_GetStageGmfPtr_CBgCtrl__QAEPAVTGmf__XZ)(GameModule + 0xa3970);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetDisEnableLoadingEffect(class CBgCtrl* const this, uint8_t arg2) [?SetDisEnableLoadingEffect@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetDisEnableLoadingEffect_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetDisEnableLoadingEffect(uint8_t arg2)
	{
		_SetDisEnableLoadingEffect_CBgCtrl__QAEX_N_Z mFunc = (_SetDisEnableLoadingEffect_CBgCtrl__QAEX_N_Z)(GameModule + 0xa3980);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetFarBloomEnable(class CBgCtrl* const this, uint8_t arg2) [?SetFarBloomEnable@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetFarBloomEnable_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetFarBloomEnable(uint8_t arg2)
	{
		_SetFarBloomEnable_CBgCtrl__QAEX_N_Z mFunc = (_SetFarBloomEnable_CBgCtrl__QAEX_N_Z)(GameModule + 0xa39a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetThresholdEnable(class CBgCtrl* const this, uint8_t arg2) [?SetThresholdEnable@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetThresholdEnable_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetThresholdEnable(uint8_t arg2)
	{
		_SetThresholdEnable_CBgCtrl__QAEX_N_Z mFunc = (_SetThresholdEnable_CBgCtrl__QAEX_N_Z)(GameModule + 0xa39c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsRailData(class CBgCtrl* const this) [?IsRailData@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsRailData_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsRailData()
	{
		_IsRailData_CBgCtrl__QAE_NXZ mFunc = (_IsRailData_CBgCtrl__QAE_NXZ)(GameModule + 0xa5330);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::isSantaDestroyStage(class CBgCtrl* const this) [?isSantaDestroyStage@CBgCtrl@@QBE_NXZ]
	typedef uint8_t(__thiscall* _isSantaDestroyStage_CBgCtrl__QBE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t isSantaDestroyStage()
	{
		_isSantaDestroyStage_CBgCtrl__QBE_NXZ mFunc = (_isSantaDestroyStage_CBgCtrl__QBE_NXZ)(GameModule + 0xa5340);
		return mFunc(this);
	}
	// [Function] class CLensFlare* __convention("thiscall") CBgCtrl::getLensFlare(class CBgCtrl* const this) [?getLensFlare@CBgCtrl@@QAEPAVCLensFlare@@XZ]
	typedef class CLensFlare*(__thiscall* _getLensFlare_CBgCtrl__QAEPAVCLensFlare__XZ)(class CBgCtrl* const thisPtr);
	class CLensFlare* getLensFlare()
	{
		_getLensFlare_CBgCtrl__QAEPAVCLensFlare__XZ mFunc = (_getLensFlare_CBgCtrl__QAEPAVCLensFlare__XZ)(GameModule + 0xa8f40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::GetRankingUpRequest(class CBgCtrl* const this) [?GetRankingUpRequest@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetRankingUpRequest_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t GetRankingUpRequest()
	{
		_GetRankingUpRequest_CBgCtrl__QAE_NXZ mFunc = (_GetRankingUpRequest_CBgCtrl__QAE_NXZ)(GameModule + 0xa8f50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetFarBloomColor(class CBgCtrl* const this, struct GXColor arg2) [?SetFarBloomColor@CBgCtrl@@QAEXUGXColor@@@Z]
	typedef void(__thiscall* _SetFarBloomColor_CBgCtrl__QAEXUGXColor___Z)(class CBgCtrl* const thisPtr, struct GXColor arg2);
	void SetFarBloomColor(struct GXColor arg2)
	{
		_SetFarBloomColor_CBgCtrl__QAEXUGXColor___Z mFunc = (_SetFarBloomColor_CBgCtrl__QAEXUGXColor___Z)(GameModule + 0xa8f60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetThresholdColor(class CBgCtrl* const this, struct GXColor arg2) [?SetThresholdColor@CBgCtrl@@QAEXUGXColor@@@Z]
	typedef void(__thiscall* _SetThresholdColor_CBgCtrl__QAEXUGXColor___Z)(class CBgCtrl* const thisPtr, struct GXColor arg2);
	void SetThresholdColor(struct GXColor arg2)
	{
		_SetThresholdColor_CBgCtrl__QAEXUGXColor___Z mFunc = (_SetThresholdColor_CBgCtrl__QAEXUGXColor___Z)(GameModule + 0xa8f80);
		return mFunc(this, arg2);
	}
	// [Function] class ghmResGroup* __convention("thiscall") CBgCtrl::getTopResourceGroup(class CBgCtrl* const this) [?getTopResourceGroup@CBgCtrl@@QAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _getTopResourceGroup_CBgCtrl__QAEPAVghmResGroup__XZ)(class CBgCtrl* const thisPtr);
	class ghmResGroup* getTopResourceGroup()
	{
		_getTopResourceGroup_CBgCtrl__QAEPAVghmResGroup__XZ mFunc = (_getTopResourceGroup_CBgCtrl__QAEPAVghmResGroup__XZ)(GameModule + 0xa9be0);
		return mFunc(this);
	}
	// [Function] uint8_t CBgCtrl::IsCBgCtrl() [?IsCBgCtrl@CBgCtrl@@SA_NXZ]
	typedef uint8_t(__fastcall* _IsCBgCtrl_CBgCtrl__SA_NXZ)();
	static uint8_t IsCBgCtrl()
	{
		_IsCBgCtrl_CBgCtrl__SA_NXZ mFunc = (_IsCBgCtrl_CBgCtrl__SA_NXZ)(GameModule + 0xaa8a0);
		return mFunc();
	}
	// [Function] void __convention("thiscall") CBgCtrl::checkAndUpdateFarGmfPosition(class CBgCtrl* const this, struct Vec& arg2) [?checkAndUpdateFarGmfPosition@CBgCtrl@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _checkAndUpdateFarGmfPosition_CBgCtrl__QAEXABUVec___Z)(class CBgCtrl* const thisPtr, struct Vec& arg2);
	void checkAndUpdateFarGmfPosition(struct Vec& arg2)
	{
		_checkAndUpdateFarGmfPosition_CBgCtrl__QAEXABUVec___Z mFunc = (_checkAndUpdateFarGmfPosition_CBgCtrl__QAEXABUVec___Z)(GameModule + 0xac290);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::GetDrawStageDraw(class CBgCtrl* const this) [?GetDrawStageDraw@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetDrawStageDraw_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t GetDrawStageDraw()
	{
		_GetDrawStageDraw_CBgCtrl__QAE_NXZ mFunc = (_GetDrawStageDraw_CBgCtrl__QAE_NXZ)(GameModule + 0xad680);
		return mFunc(this);
	}
	// [Function] struct GXColor __convention("thiscall") CBgCtrl::GetFarBloomColor(class CBgCtrl* const this) [?GetFarBloomColor@CBgCtrl@@QAE?AUGXColor@@XZ]
	typedef struct GXColor(__thiscall* _GetFarBloomColor_CBgCtrl__QAEAUGXColor__XZ)(class CBgCtrl* const thisPtr);
	struct GXColor GetFarBloomColor()
	{
		_GetFarBloomColor_CBgCtrl__QAEAUGXColor__XZ mFunc = (_GetFarBloomColor_CBgCtrl__QAEAUGXColor__XZ)(GameModule + 0xadbd0);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") CBgCtrl::GetFarGmfPtr(class CBgCtrl* const this) [?GetFarGmfPtr@CBgCtrl@@QAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _GetFarGmfPtr_CBgCtrl__QAEPAVTGmf__XZ)(class CBgCtrl* const thisPtr);
	class TGmf* GetFarGmfPtr()
	{
		_GetFarGmfPtr_CBgCtrl__QAEPAVTGmf__XZ mFunc = (_GetFarGmfPtr_CBgCtrl__QAEPAVTGmf__XZ)(GameModule + 0xadbf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetDrawStageDraw(class CBgCtrl* const this, uint8_t arg2) [?SetDrawStageDraw@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetDrawStageDraw_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetDrawStageDraw(uint8_t arg2)
	{
		_SetDrawStageDraw_CBgCtrl__QAEX_N_Z mFunc = (_SetDrawStageDraw_CBgCtrl__QAEX_N_Z)(GameModule + 0xadce0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetVisible(class CBgCtrl* const this, uint8_t arg2) [?SetVisible@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetVisible_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetVisible(uint8_t arg2)
	{
		_SetVisible_CBgCtrl__QAEX_N_Z mFunc = (_SetVisible_CBgCtrl__QAEX_N_Z)(GameModule + 0xadd00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::getFarGmfTransformPosition(class CBgCtrl* const this, struct Vec* arg2, struct Vec& arg3) [?getFarGmfTransformPosition@CBgCtrl@@QBEXPAUVec@@ABU2@@Z]
	typedef void(__thiscall* _getFarGmfTransformPosition_CBgCtrl__QBEXPAUVec__ABU2__Z)(class CBgCtrl* const thisPtr, struct Vec* arg2, struct Vec& arg3);
	void getFarGmfTransformPosition(struct Vec* arg2, struct Vec& arg3)
	{
		_getFarGmfTransformPosition_CBgCtrl__QBEXPAUVec__ABU2__Z mFunc = (_getFarGmfTransformPosition_CBgCtrl__QBEXPAUVec__ABU2__Z)(GameModule + 0xaea40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetStgFuncOnlyVisible(class CBgCtrl* const this, uint8_t arg2) [?SetStgFuncOnlyVisible@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetStgFuncOnlyVisible_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetStgFuncOnlyVisible(uint8_t arg2)
	{
		_SetStgFuncOnlyVisible_CBgCtrl__QAEX_N_Z mFunc = (_SetStgFuncOnlyVisible_CBgCtrl__QAEX_N_Z)(GameModule + 0xaf310);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsStgFuncOnlyVisible(class CBgCtrl* const this) [?IsStgFuncOnlyVisible@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsStgFuncOnlyVisible_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsStgFuncOnlyVisible()
	{
		_IsStgFuncOnlyVisible_CBgCtrl__QAE_NXZ mFunc = (_IsStgFuncOnlyVisible_CBgCtrl__QAE_NXZ)(GameModule + 0xaf340);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetDontExecNpcProcess(class CBgCtrl* const this, uint8_t arg2) [?SetDontExecNpcProcess@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetDontExecNpcProcess_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetDontExecNpcProcess(uint8_t arg2)
	{
		_SetDontExecNpcProcess_CBgCtrl__QAEX_N_Z mFunc = (_SetDontExecNpcProcess_CBgCtrl__QAEX_N_Z)(GameModule + 0xbd230);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetFarVisible(class CBgCtrl* const this, uint8_t arg2) [?SetFarVisible@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetFarVisible_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetFarVisible(uint8_t arg2)
	{
		_SetFarVisible_CBgCtrl__QAEX_N_Z mFunc = (_SetFarVisible_CBgCtrl__QAEX_N_Z)(GameModule + 0xbe200);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetToneMapEnable(class CBgCtrl* const this, uint8_t arg2) [?SetToneMapEnable@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetToneMapEnable_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetToneMapEnable(uint8_t arg2)
	{
		_SetToneMapEnable_CBgCtrl__QAEX_N_Z mFunc = (_SetToneMapEnable_CBgCtrl__QAEX_N_Z)(GameModule + 0xbe220);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::GetFarBloomEnable(class CBgCtrl* const this) [?GetFarBloomEnable@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetFarBloomEnable_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t GetFarBloomEnable()
	{
		_GetFarBloomEnable_CBgCtrl__QAE_NXZ mFunc = (_GetFarBloomEnable_CBgCtrl__QAE_NXZ)(GameModule + 0xd4f50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::GetThresholdEnable(class CBgCtrl* const this) [?GetThresholdEnable@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetThresholdEnable_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t GetThresholdEnable()
	{
		_GetThresholdEnable_CBgCtrl__QAE_NXZ mFunc = (_GetThresholdEnable_CBgCtrl__QAE_NXZ)(GameModule + 0xd4f60);
		return mFunc(this);
	}
	// [Function] class rSkyMap* __convention("thiscall") CBgCtrl::GetSkyMap(class CBgCtrl* const this) [?GetSkyMap@CBgCtrl@@QAEPAVrSkyMap@@XZ]
	typedef class rSkyMap*(__thiscall* _GetSkyMap_CBgCtrl__QAEPAVrSkyMap__XZ)(class CBgCtrl* const thisPtr);
	class rSkyMap* GetSkyMap()
	{
		_GetSkyMap_CBgCtrl__QAEPAVrSkyMap__XZ mFunc = (_GetSkyMap_CBgCtrl__QAEPAVrSkyMap__XZ)(GameModule + 0x38b570);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsTermToiletEffect(class CBgCtrl* const this) [?IsTermToiletEffect@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsTermToiletEffect_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsTermToiletEffect()
	{
		_IsTermToiletEffect_CBgCtrl__QAE_NXZ mFunc = (_IsTermToiletEffect_CBgCtrl__QAE_NXZ)(GameModule + 0x38b580);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::TermToiletEffect(class CBgCtrl* const this) [?TermToiletEffect@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _TermToiletEffect_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t TermToiletEffect()
	{
		_TermToiletEffect_CBgCtrl__QAE_NXZ mFunc = (_TermToiletEffect_CBgCtrl__QAE_NXZ)(GameModule + 0x38b600);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::TermTutoResult(class CBgCtrl* const this) [?TermTutoResult@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _TermTutoResult_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t TermTutoResult()
	{
		_TermTutoResult_CBgCtrl__QAE_NXZ mFunc = (_TermTutoResult_CBgCtrl__QAE_NXZ)(GameModule + 0x38b620);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsDispTutoResult(class CBgCtrl* const this, int32_t arg2) [?IsDispTutoResult@CBgCtrl@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _IsDispTutoResult_CBgCtrl__QAE_NH_Z)(class CBgCtrl* const thisPtr, int32_t arg2);
	uint8_t IsDispTutoResult(int32_t arg2)
	{
		_IsDispTutoResult_CBgCtrl__QAE_NH_Z mFunc = (_IsDispTutoResult_CBgCtrl__QAE_NH_Z)(GameModule + 0x38b680);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::DispTutoResult(class CBgCtrl* const this, int32_t arg2) [?DispTutoResult@CBgCtrl@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _DispTutoResult_CBgCtrl__QAE_NH_Z)(class CBgCtrl* const thisPtr, int32_t arg2);
	uint8_t DispTutoResult(int32_t arg2)
	{
		_DispTutoResult_CBgCtrl__QAE_NH_Z mFunc = (_DispTutoResult_CBgCtrl__QAE_NH_Z)(GameModule + 0x38b690);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetStaffRoll2Request(class CBgCtrl* const this) [?SetStaffRoll2Request@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _SetStaffRoll2Request_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void SetStaffRoll2Request()
	{
		_SetStaffRoll2Request_CBgCtrl__QAEXXZ mFunc = (_SetStaffRoll2Request_CBgCtrl__QAEXXZ)(GameModule + 0x38b780);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetStaffRoll1Request(class CBgCtrl* const this) [?SetStaffRoll1Request@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _SetStaffRoll1Request_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void SetStaffRoll1Request()
	{
		_SetStaffRoll1Request_CBgCtrl__QAEXXZ mFunc = (_SetStaffRoll1Request_CBgCtrl__QAEXXZ)(GameModule + 0x38b790);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetDemoToDemoStgRequest(class CBgCtrl* const this, char* arg2, int32_t arg3, int32_t arg4) [?SetDemoToDemoStgRequest@CBgCtrl@@QAEXPADHH@Z]
	typedef void(__thiscall* _SetDemoToDemoStgRequest_CBgCtrl__QAEXPADHH_Z)(class CBgCtrl* const thisPtr, char* arg2, int32_t arg3, int32_t arg4);
	void SetDemoToDemoStgRequest(std::string arg2, int32_t arg3, int32_t arg4)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_SetDemoToDemoStgRequest_CBgCtrl__QAEXPADHH_Z mFunc = (_SetDemoToDemoStgRequest_CBgCtrl__QAEXPADHH_Z)(GameModule + 0x38b7a0);
		return mFunc(this, &arg2_c_str[0], arg3, arg4);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetDemoToDemoRequest(class CBgCtrl* const this, int32_t arg2) [?SetDemoToDemoRequest@CBgCtrl@@QAEXH@Z]
	typedef void(__thiscall* _SetDemoToDemoRequest_CBgCtrl__QAEXH_Z)(class CBgCtrl* const thisPtr, int32_t arg2);
	void SetDemoToDemoRequest(int32_t arg2)
	{
		_SetDemoToDemoRequest_CBgCtrl__QAEXH_Z mFunc = (_SetDemoToDemoRequest_CBgCtrl__QAEXH_Z)(GameModule + 0x38b7e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetBossResultRequest(class CBgCtrl* const this, int32_t arg2) [?SetBossResultRequest@CBgCtrl@@QAEXH@Z]
	typedef void(__thiscall* _SetBossResultRequest_CBgCtrl__QAEXH_Z)(class CBgCtrl* const thisPtr, int32_t arg2);
	void SetBossResultRequest(int32_t arg2)
	{
		_SetBossResultRequest_CBgCtrl__QAEXH_Z mFunc = (_SetBossResultRequest_CBgCtrl__QAEXH_Z)(GameModule + 0x38b800);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetRankingUpRequest(class CBgCtrl* const this) [?SetRankingUpRequest@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _SetRankingUpRequest_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void SetRankingUpRequest()
	{
		_SetRankingUpRequest_CBgCtrl__QAEXXZ mFunc = (_SetRankingUpRequest_CBgCtrl__QAEXXZ)(GameModule + 0x38b820);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::ClearDisEnableLoadingEffect(class CBgCtrl* const this) [?ClearDisEnableLoadingEffect@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _ClearDisEnableLoadingEffect_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void ClearDisEnableLoadingEffect()
	{
		_ClearDisEnableLoadingEffect_CBgCtrl__QAEXXZ mFunc = (_ClearDisEnableLoadingEffect_CBgCtrl__QAEXXZ)(GameModule + 0x38b830);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::TestDisEnableLoadingEffect(class CBgCtrl* const this) [?TestDisEnableLoadingEffect@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _TestDisEnableLoadingEffect_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t TestDisEnableLoadingEffect()
	{
		_TestDisEnableLoadingEffect_CBgCtrl__QAE_NXZ mFunc = (_TestDisEnableLoadingEffect_CBgCtrl__QAE_NXZ)(GameModule + 0x38b840);
		return mFunc(this);
	}
	// [Function] class ghmResGroup* __convention("thiscall") CBgCtrl::GetNpcResLink(class CBgCtrl* const this) [?GetNpcResLink@CBgCtrl@@QAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _GetNpcResLink_CBgCtrl__QAEPAVghmResGroup__XZ)(class CBgCtrl* const thisPtr);
	class ghmResGroup* GetNpcResLink()
	{
		_GetNpcResLink_CBgCtrl__QAEPAVghmResGroup__XZ mFunc = (_GetNpcResLink_CBgCtrl__QAEPAVghmResGroup__XZ)(GameModule + 0x38b850);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::TestNpcRslRead(class CBgCtrl* const this) [?TestNpcRslRead@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _TestNpcRslRead_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t TestNpcRslRead()
	{
		_TestNpcRslRead_CBgCtrl__QAE_NXZ mFunc = (_TestNpcRslRead_CBgCtrl__QAE_NXZ)(GameModule + 0x38b860);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsNpcRslRead(class CBgCtrl* const this) [?IsNpcRslRead@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsNpcRslRead_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsNpcRslRead()
	{
		_IsNpcRslRead_CBgCtrl__QAE_NXZ mFunc = (_IsNpcRslRead_CBgCtrl__QAE_NXZ)(GameModule + 0x38b870);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::NpcRslRead(class CBgCtrl* const this, char* arg2) [?NpcRslRead@CBgCtrl@@QAE_NPAD@Z]
	typedef uint8_t(__thiscall* _NpcRslRead_CBgCtrl__QAE_NPAD_Z)(class CBgCtrl* const thisPtr, char* arg2);
	uint8_t NpcRslRead(std::string arg2)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_NpcRslRead_CBgCtrl__QAE_NPAD_Z mFunc = (_NpcRslRead_CBgCtrl__QAE_NPAD_Z)(GameModule + 0x38b880);
		return mFunc(this, &arg2_c_str[0]);
	}
	// [Function] void __convention("thiscall") CBgCtrl::StageGayaStopSE(class CBgCtrl* const this) [?StageGayaStopSE@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _StageGayaStopSE_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void StageGayaStopSE()
	{
		_StageGayaStopSE_CBgCtrl__QAEXXZ mFunc = (_StageGayaStopSE_CBgCtrl__QAEXXZ)(GameModule + 0x38d040);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetGayaVolume(class CBgCtrl* const this, float arg2) [?SetGayaVolume@CBgCtrl@@QAEXM@Z]
	typedef void(__thiscall* _SetGayaVolume_CBgCtrl__QAEXM_Z)(class CBgCtrl* const thisPtr, float arg2);
	void SetGayaVolume(float arg2)
	{
		_SetGayaVolume_CBgCtrl__QAEXM_Z mFunc = (_SetGayaVolume_CBgCtrl__QAEXM_Z)(GameModule + 0x38d070);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::StageGayaPlaySE(class CBgCtrl* const this, int32_t arg2) [?StageGayaPlaySE@CBgCtrl@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _StageGayaPlaySE_CBgCtrl__QAE_NH_Z)(class CBgCtrl* const thisPtr, int32_t arg2);
	uint8_t StageGayaPlaySE(int32_t arg2)
	{
		_StageGayaPlaySE_CBgCtrl__QAE_NH_Z mFunc = (_StageGayaPlaySE_CBgCtrl__QAE_NH_Z)(GameModule + 0x38d0e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::SubMissionSndGroupReleaseReq(class CBgCtrl* const this) [?SubMissionSndGroupReleaseReq@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _SubMissionSndGroupReleaseReq_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t SubMissionSndGroupReleaseReq()
	{
		_SubMissionSndGroupReleaseReq_CBgCtrl__QAE_NXZ mFunc = (_SubMissionSndGroupReleaseReq_CBgCtrl__QAE_NXZ)(GameModule + 0x38d120);
		return mFunc(this);
	}
	// [Function] char* __convention("thiscall") CBgCtrl::GetStageName(class CBgCtrl* const this) [?GetStageName@CBgCtrl@@QAEPADXZ]
	typedef char*(__thiscall* _GetStageName_CBgCtrl__QAEPADXZ)(class CBgCtrl* const thisPtr);
	std::string GetStageName()
	{
		_GetStageName_CBgCtrl__QAEPADXZ mFunc = (_GetStageName_CBgCtrl__QAEPADXZ)(GameModule + 0x38d170);
		char* OutResult = mFunc(this);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] void __convention("thiscall") CBgCtrl::DebugRelayPoint(class CBgCtrl* const this) [?DebugRelayPoint@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _DebugRelayPoint_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void DebugRelayPoint()
	{
		_DebugRelayPoint_CBgCtrl__QAEXXZ mFunc = (_DebugRelayPoint_CBgCtrl__QAEXXZ)(GameModule + 0x38d180);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::PlayMotion(class CBgCtrl* const this, class TGan* arg2, uint8_t arg3) [?PlayMotion@CBgCtrl@@QAE_NPAVTGan@@_N@Z]
	typedef uint8_t(__thiscall* _PlayMotion_CBgCtrl__QAE_NPAVTGan___N_Z)(class CBgCtrl* const thisPtr, class TGan* arg2, uint8_t arg3);
	uint8_t PlayMotion(class TGan* arg2, uint8_t arg3)
	{
		_PlayMotion_CBgCtrl__QAE_NPAVTGan___N_Z mFunc = (_PlayMotion_CBgCtrl__QAE_NPAVTGan___N_Z)(GameModule + 0x38d190);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::AttachBgMotion(class CBgCtrl* const this, int32_t arg2, float arg3) [?AttachBgMotion@CBgCtrl@@QAE_NHM@Z]
	typedef uint8_t(__thiscall* _AttachBgMotion_CBgCtrl__QAE_NHM_Z)(class CBgCtrl* const thisPtr, int32_t arg2, float arg3);
	uint8_t AttachBgMotion(int32_t arg2, float arg3)
	{
		_AttachBgMotion_CBgCtrl__QAE_NHM_Z mFunc = (_AttachBgMotion_CBgCtrl__QAE_NHM_Z)(GameModule + 0x38d210);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") CBgCtrl::CmnObjProFrame(class CBgCtrl* const this) [?CmnObjProFrame@CBgCtrl@@AAEXXZ]
	typedef void(__thiscall* _CmnObjProFrame_CBgCtrl__AAEXXZ)(class CBgCtrl* const thisPtr);
	void CmnObjProFrame()
	{
		_CmnObjProFrame_CBgCtrl__AAEXXZ mFunc = (_CmnObjProFrame_CBgCtrl__AAEXXZ)(GameModule + 0x38d220);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsColliData(class CBgCtrl* const this) [?IsColliData@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsColliData_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsColliData()
	{
		_IsColliData_CBgCtrl__QAE_NXZ mFunc = (_IsColliData_CBgCtrl__QAE_NXZ)(GameModule + 0x38d230);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") CBgCtrl::GetGmf(class CBgCtrl* const this) [?GetGmf@CBgCtrl@@QAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _GetGmf_CBgCtrl__QAEPAVTGmf__XZ)(class CBgCtrl* const thisPtr);
	class TGmf* GetGmf()
	{
		_GetGmf_CBgCtrl__QAEPAVTGmf__XZ mFunc = (_GetGmf_CBgCtrl__QAEPAVTGmf__XZ)(GameModule + 0x38d260);
		return mFunc(this);
	}
	// [Function] class HrScript* __convention("thiscall") CBgCtrl::GetScript(class CBgCtrl* const this) [?GetScript@CBgCtrl@@QAEPAVHrScript@@XZ]
	typedef class HrScript*(__thiscall* _GetScript_CBgCtrl__QAEPAVHrScript__XZ)(class CBgCtrl* const thisPtr);
	class HrScript* GetScript()
	{
		_GetScript_CBgCtrl__QAEPAVHrScript__XZ mFunc = (_GetScript_CBgCtrl__QAEPAVHrScript__XZ)(GameModule + 0x38d270);
		return mFunc(this);
	}
	// [Function] class HrStageDraw* __convention("thiscall") CBgCtrl::GetStageDraw(class CBgCtrl* const this) [?GetStageDraw@CBgCtrl@@QAEPAVHrStageDraw@@XZ]
	typedef class HrStageDraw*(__thiscall* _GetStageDraw_CBgCtrl__QAEPAVHrStageDraw__XZ)(class CBgCtrl* const thisPtr);
	class HrStageDraw* GetStageDraw()
	{
		_GetStageDraw_CBgCtrl__QAEPAVHrStageDraw__XZ mFunc = (_GetStageDraw_CBgCtrl__QAEPAVHrStageDraw__XZ)(GameModule + 0x38d2a0);
		return mFunc(this);
	}
	// [Function] uint8_t CBgCtrl::IsCollisionData() [?IsCollisionData@CBgCtrl@@SA_NXZ]
	typedef uint8_t(__fastcall* _IsCollisionData_CBgCtrl__SA_NXZ)();
	static uint8_t IsCollisionData()
	{
		_IsCollisionData_CBgCtrl__SA_NXZ mFunc = (_IsCollisionData_CBgCtrl__SA_NXZ)(GameModule + 0x38d2b0);
		return mFunc();
	}
	// [Function] uint32_t __convention("thiscall") CBgCtrl::GetResourceNum(class CBgCtrl* const this, char* GroupName) [?GetResourceNum@CBgCtrl@@QAEIPAD@Z]
	typedef uint32_t(__thiscall* _GetResourceNum_CBgCtrl__QAEIPAD_Z)(class CBgCtrl* const thisPtr, char* GroupName);
	uint32_t GetResourceNum(std::string GroupName)
	{
		std::vector<char> GroupName_c_str(GroupName.c_str(), + GroupName.c_str() + GroupName.size() + 1);
		_GetResourceNum_CBgCtrl__QAEIPAD_Z mFunc = (_GetResourceNum_CBgCtrl__QAEIPAD_Z)(GameModule + 0x38d2e0);
		return mFunc(this, &GroupName_c_str[0]);
	}
	// [Function] class ghmResGroup* __convention("thiscall") CBgCtrl::GetResourceGroup(class CBgCtrl* const this, char const* arg2) [?GetResourceGroup@CBgCtrl@@QAEPAVghmResGroup@@PBD@Z]
	typedef class ghmResGroup*(__thiscall* _GetResourceGroup_CBgCtrl__QAEPAVghmResGroup__PBD_Z)(class CBgCtrl* const thisPtr, char const* arg2);
	class ghmResGroup* GetResourceGroup(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetResourceGroup_CBgCtrl__QAEPAVghmResGroup__PBD_Z mFunc = (_GetResourceGroup_CBgCtrl__QAEPAVghmResGroup__PBD_Z)(GameModule + 0x38d320);
		return mFunc(this, arg2_c_str);
	}
	// [Function] void* __convention("thiscall") CBgCtrl::GetResource(class CBgCtrl* const this, char const* arg2, char const* ResID) [?GetResource@CBgCtrl@@QAEPAXPAD0@Z]
	typedef void*(__thiscall* _GetResource_CBgCtrl__QAEPAXPAD0_Z)(class CBgCtrl* const thisPtr, char const* arg2, char const* ResID);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void GetResource(std::string arg2, std::string ResID)
	{
		char const* arg2_c_str = arg2.c_str();
		char const* ResID_c_str = ResID.c_str();
		_GetResource_CBgCtrl__QAEPAXPAD0_Z mFunc = (_GetResource_CBgCtrl__QAEPAXPAD0_Z)(GameModule + 0x38d340);
		mFunc(this, arg2_c_str, ResID_c_str);
	}
	// [Function] void* __convention("thiscall") CBgCtrl::GetResource4LoadingTex(class CBgCtrl* const this, char* GroupName, int32_t ResourceIndex) [?GetResource4LoadingTex@CBgCtrl@@QAEPAXPADH@Z]
	typedef void*(__thiscall* _GetResource4LoadingTex_CBgCtrl__QAEPAXPADH_Z)(class CBgCtrl* const thisPtr, char* GroupName, int32_t ResourceIndex);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void GetResource4LoadingTex(std::string GroupName, int32_t ResourceIndex)
	{
		std::vector<char> GroupName_c_str(GroupName.c_str(), + GroupName.c_str() + GroupName.size() + 1);
		_GetResource4LoadingTex_CBgCtrl__QAEPAXPADH_Z mFunc = (_GetResource4LoadingTex_CBgCtrl__QAEPAXPADH_Z)(GameModule + 0x38d380);
		mFunc(this, &GroupName_c_str[0], ResourceIndex);
	}
	// [Function] void* __convention("thiscall") CBgCtrl::GetResource(class CBgCtrl* const this, char* arg2, int32_t arg3) [?GetResource@CBgCtrl@@QAEPAXPADH@Z]
	typedef void*(__thiscall* _GetResource_CBgCtrl__QAEPAXPADH_Z_2)(class CBgCtrl* const thisPtr, char* arg2, int32_t arg3);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void GetResource_2(std::string arg2, int32_t arg3)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_GetResource_CBgCtrl__QAEPAXPADH_Z_2 mFunc = (_GetResource_CBgCtrl__QAEPAXPADH_Z_2)(GameModule + 0x38d3e0);
		mFunc(this, &arg2_c_str[0], arg3);
	}
	// [Function] char const* __convention("thiscall") CBgCtrl::GetFileName(class CBgCtrl* const this) [?GetFileName@CBgCtrl@@QAEPBDXZ]
	typedef char const*(__thiscall* _GetFileName_CBgCtrl__QAEPBDXZ)(class CBgCtrl* const thisPtr);
	std::string GetFileName()
	{
		_GetFileName_CBgCtrl__QAEPBDXZ mFunc = (_GetFileName_CBgCtrl__QAEPBDXZ)(GameModule + 0x38d420);
		char const* OutResult = mFunc(this);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::CancelRequestStage(class CBgCtrl* const this) [?CancelRequestStage@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _CancelRequestStage_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t CancelRequestStage()
	{
		_CancelRequestStage_CBgCtrl__QAE_NXZ mFunc = (_CancelRequestStage_CBgCtrl__QAE_NXZ)(GameModule + 0x38d450);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsRequestStage(class CBgCtrl* const this) [?IsRequestStage@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsRequestStage_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsRequestStage()
	{
		_IsRequestStage_CBgCtrl__QAE_NXZ mFunc = (_IsRequestStage_CBgCtrl__QAE_NXZ)(GameModule + 0x38d480);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsRequestStageLoaded(class CBgCtrl* const this) [?IsRequestStageLoaded@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsRequestStageLoaded_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsRequestStageLoaded()
	{
		_IsRequestStageLoaded_CBgCtrl__QAE_NXZ mFunc = (_IsRequestStageLoaded_CBgCtrl__QAE_NXZ)(GameModule + 0x38d490);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsReleased(class CBgCtrl* const this) [?IsReleased@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsReleased_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsReleased()
	{
		_IsReleased_CBgCtrl__QAE_NXZ mFunc = (_IsReleased_CBgCtrl__QAE_NXZ)(GameModule + 0x38d4c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsLoaded(class CBgCtrl* const this) [?IsLoaded@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsLoaded_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsLoaded()
	{
		_IsLoaded_CBgCtrl__QAE_NXZ mFunc = (_IsLoaded_CBgCtrl__QAE_NXZ)(GameModule + 0x38d4d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::BgLoad(class CBgCtrl* const this, int32_t arg2, int32_t arg3) [?BgLoad@CBgCtrl@@AAE_NHH@Z]
	typedef uint8_t(__thiscall* _BgLoad_CBgCtrl__AAE_NHH_Z)(class CBgCtrl* const thisPtr, int32_t arg2, int32_t arg3);
	uint8_t BgLoad(int32_t arg2, int32_t arg3)
	{
		_BgLoad_CBgCtrl__AAE_NHH_Z mFunc = (_BgLoad_CBgCtrl__AAE_NHH_Z)(GameModule + 0x38d4e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint32_t __convention("thiscall") CBgCtrl::SearchBg(class CBgCtrl* const this) [?SearchBg@CBgCtrl@@AAEIXZ]
	typedef uint32_t(__thiscall* _SearchBg_CBgCtrl__AAEIXZ)(class CBgCtrl* const thisPtr);
	uint32_t SearchBg()
	{
		_SearchBg_CBgCtrl__AAEIXZ mFunc = (_SearchBg_CBgCtrl__AAEIXZ)(GameModule + 0x38d4f0);
		return mFunc(this);
	}
	// [Function] void CBgCtrl::prPostBGDraw(void* arg1) [?prPostBGDraw@CBgCtrl@@CAXPAX@Z]
	typedef void(__fastcall* _prPostBGDraw_CBgCtrl__CAXPAX_Z)(void* arg1);
	static void prPostBGDraw(void* arg1)
	{
		_prPostBGDraw_CBgCtrl__CAXPAX_Z mFunc = (_prPostBGDraw_CBgCtrl__CAXPAX_Z)(GameModule + 0x38d500);
		return mFunc(arg1);
	}
	// [Function] void CBgCtrl::prDrawTutoResultFadeTile(void* arg1) [?prDrawTutoResultFadeTile@CBgCtrl@@SAXPAX@Z]
	typedef void(__fastcall* _prDrawTutoResultFadeTile_CBgCtrl__SAXPAX_Z)(void* arg1);
	static void prDrawTutoResultFadeTile(void* arg1)
	{
		_prDrawTutoResultFadeTile_CBgCtrl__SAXPAX_Z mFunc = (_prDrawTutoResultFadeTile_CBgCtrl__SAXPAX_Z)(GameModule + 0x38d510);
		return mFunc(arg1);
	}
	// [Function] void CBgCtrl::prDrawTutoResult(void* arg1) [?prDrawTutoResult@CBgCtrl@@SAXPAX@Z]
	typedef void(__fastcall* _prDrawTutoResult_CBgCtrl__SAXPAX_Z)(void* arg1);
	static void prDrawTutoResult(void* arg1)
	{
		_prDrawTutoResult_CBgCtrl__SAXPAX_Z mFunc = (_prDrawTutoResult_CBgCtrl__SAXPAX_Z)(GameModule + 0x38d580);
		return mFunc(arg1);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::beginThresholdBloomEffect(class CBgCtrl* const this, struct GXColor& arg2, float const arg3, float const arg4, float const arg5, uint8_t const arg6) [?beginThresholdBloomEffect@CBgCtrl@@QAE_NABUGXColor@@MMM_N@Z]
	typedef uint8_t(__thiscall* _beginThresholdBloomEffect_CBgCtrl__QAE_NABUGXColor__MMM_N_Z)(class CBgCtrl* const thisPtr, struct GXColor& arg2, float const arg3, float const arg4, float const arg5, uint8_t const arg6);
	uint8_t beginThresholdBloomEffect(struct GXColor& arg2, float const arg3, float const arg4, float const arg5, uint8_t const arg6)
	{
		_beginThresholdBloomEffect_CBgCtrl__QAE_NABUGXColor__MMM_N_Z mFunc = (_beginThresholdBloomEffect_CBgCtrl__QAE_NABUGXColor__MMM_N_Z)(GameModule + 0x38d930);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] void __convention("thiscall") CBgCtrl::BloomRender(class CBgCtrl* const this) [?BloomRender@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _BloomRender_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void BloomRender()
	{
		_BloomRender_CBgCtrl__QAEXXZ mFunc = (_BloomRender_CBgCtrl__QAEXXZ)(GameModule + 0x38d9c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::CreateThesholdBloom(class CBgCtrl* const this) [?CreateThesholdBloom@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _CreateThesholdBloom_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void CreateThesholdBloom()
	{
		_CreateThesholdBloom_CBgCtrl__QAEXXZ mFunc = (_CreateThesholdBloom_CBgCtrl__QAEXXZ)(GameModule + 0x38dd30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::CreateFarBloom(class CBgCtrl* const this) [?CreateFarBloom@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _CreateFarBloom_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void CreateFarBloom()
	{
		_CreateFarBloom_CBgCtrl__QAEXXZ mFunc = (_CreateFarBloom_CBgCtrl__QAEXXZ)(GameModule + 0x38e740);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::RenderIdle(class CBgCtrl* const this) [?RenderIdle@CBgCtrl@@AAEXXZ]
	typedef void(__thiscall* _RenderIdle_CBgCtrl__AAEXXZ)(class CBgCtrl* const thisPtr);
	void RenderIdle()
	{
		_RenderIdle_CBgCtrl__AAEXXZ mFunc = (_RenderIdle_CBgCtrl__AAEXXZ)(GameModule + 0x38ed30);
		return mFunc(this);
	}
	// [Function] void* __convention("thiscall") CBgCtrl::GetMessageGroup(class CBgCtrl* const this, char* arg2) [?GetMessageGroup@CBgCtrl@@QAEPAXPAD@Z]
	typedef void*(__thiscall* _GetMessageGroup_CBgCtrl__QAEPAXPAD_Z)(class CBgCtrl* const thisPtr, char* arg2);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void GetMessageGroup(std::string arg2)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_GetMessageGroup_CBgCtrl__QAEPAXPAD_Z mFunc = (_GetMessageGroup_CBgCtrl__QAEPAXPAD_Z)(GameModule + 0x38f010);
		mFunc(this, &arg2_c_str[0]);
	}
	// [Function] void __convention("thiscall") CBgCtrl::FarModelRender(class CBgCtrl* const this) [?FarModelRender@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _FarModelRender_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void FarModelRender()
	{
		_FarModelRender_CBgCtrl__QAEXXZ mFunc = (_FarModelRender_CBgCtrl__QAEXXZ)(GameModule + 0x38f040);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetVisibleLensFlare(class CBgCtrl* const this, uint8_t arg2) [?SetVisibleLensFlare@CBgCtrl@@QAEX_N@Z]
	typedef void(__thiscall* _SetVisibleLensFlare_CBgCtrl__QAEX_N_Z)(class CBgCtrl* const thisPtr, uint8_t arg2);
	void SetVisibleLensFlare(uint8_t arg2)
	{
		_SetVisibleLensFlare_CBgCtrl__QAEX_N_Z mFunc = (_SetVisibleLensFlare_CBgCtrl__QAEX_N_Z)(GameModule + 0x38f170);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::FrameIdle(class CBgCtrl* const this) [?FrameIdle@CBgCtrl@@AAEXXZ]
	typedef void(__thiscall* _FrameIdle_CBgCtrl__AAEXXZ)(class CBgCtrl* const thisPtr);
	void FrameIdle()
	{
		_FrameIdle_CBgCtrl__AAEXXZ mFunc = (_FrameIdle_CBgCtrl__AAEXXZ)(GameModule + 0x38f190);
		return mFunc(this);
	}
	// [Function] enum CBgCtrl::CBGCTRL_LOADSTATUS __convention("thiscall") CBgCtrl::SetLDstatus(class CBgCtrl* const this, enum CBgCtrl::CBGCTRL_LOADSTATUS arg2) [?SetLDstatus@CBgCtrl@@AAE?AW4CBGCTRL_LOADSTATUS@1@W421@@Z]
	typedef enum CBgCtrl::CBGCTRL_LOADSTATUS(__thiscall* _SetLDstatus_CBgCtrl__AAEAW4CBGCTRL_LOADSTATUS_1_W421__Z)(class CBgCtrl* const thisPtr, enum CBgCtrl::CBGCTRL_LOADSTATUS arg2);
	/* enum CBgCtrl::CBGCTRL_LOADSTATUS */ uint32_t SetLDstatus(/* enum CBgCtrl::CBGCTRL_LOADSTATUS */ uint32_t arg2)
	{
		_SetLDstatus_CBgCtrl__AAEAW4CBGCTRL_LOADSTATUS_1_W421__Z mFunc = (_SetLDstatus_CBgCtrl__AAEAW4CBGCTRL_LOADSTATUS_1_W421__Z)(GameModule + 0x38f340);
		return (uint32_t)mFunc(this, (enum CBgCtrl::CBGCTRL_LOADSTATUS)arg2);
	}
	// [Function] void __convention("thiscall") CBgCtrl::InitStage(class CBgCtrl* const this) [?InitStage@CBgCtrl@@AAEXXZ]
	typedef void(__thiscall* _InitStage_CBgCtrl__AAEXXZ)(class CBgCtrl* const thisPtr);
	void InitStage()
	{
		_InitStage_CBgCtrl__AAEXXZ mFunc = (_InitStage_CBgCtrl__AAEXXZ)(GameModule + 0x38f360);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::SetupSignalOnly(class CBgCtrl* const this) [?SetupSignalOnly@CBgCtrl@@AAE_NXZ]
	typedef uint8_t(__thiscall* _SetupSignalOnly_CBgCtrl__AAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t SetupSignalOnly()
	{
		_SetupSignalOnly_CBgCtrl__AAE_NXZ mFunc = (_SetupSignalOnly_CBgCtrl__AAE_NXZ)(GameModule + 0x38f940);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::FrameLoad(class CBgCtrl* const this) [?FrameLoad@CBgCtrl@@AAE_NXZ]
	typedef uint8_t(__thiscall* _FrameLoad_CBgCtrl__AAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t FrameLoad()
	{
		_FrameLoad_CBgCtrl__AAE_NXZ mFunc = (_FrameLoad_CBgCtrl__AAE_NXZ)(GameModule + 0x38f950);
		return mFunc(this);
	}
	// [Function] enum CBgCtrl::CBGCTRL_STATUS __convention("thiscall") CBgCtrl::SetStatus(class CBgCtrl* const this, enum CBgCtrl::CBGCTRL_STATUS arg2) [?SetStatus@CBgCtrl@@AAE?AW4CBGCTRL_STATUS@1@W421@@Z]
	typedef enum CBgCtrl::CBGCTRL_STATUS(__thiscall* _SetStatus_CBgCtrl__AAEAW4CBGCTRL_STATUS_1_W421__Z)(class CBgCtrl* const thisPtr, enum CBgCtrl::CBGCTRL_STATUS arg2);
	/* enum CBgCtrl::CBGCTRL_STATUS */ uint32_t SetStatus(/* enum CBgCtrl::CBGCTRL_STATUS */ uint32_t arg2)
	{
		_SetStatus_CBgCtrl__AAEAW4CBGCTRL_STATUS_1_W421__Z mFunc = (_SetStatus_CBgCtrl__AAEAW4CBGCTRL_STATUS_1_W421__Z)(GameModule + 0x390d50);
		return (uint32_t)mFunc(this, (enum CBgCtrl::CBGCTRL_STATUS)arg2);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::StageSetUp(class CBgCtrl* const this) [?StageSetUp@CBgCtrl@@AAE_NXZ]
	typedef uint8_t(__thiscall* _StageSetUp_CBgCtrl__AAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t StageSetUp()
	{
		_StageSetUp_CBgCtrl__AAE_NXZ mFunc = (_StageSetUp_CBgCtrl__AAE_NXZ)(GameModule + 0x390d70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::IsReleaseSetUp(class CBgCtrl* const this) [?IsReleaseSetUp@CBgCtrl@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsReleaseSetUp_CBgCtrl__AAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t IsReleaseSetUp()
	{
		_IsReleaseSetUp_CBgCtrl__AAE_NXZ mFunc = (_IsReleaseSetUp_CBgCtrl__AAE_NXZ)(GameModule + 0x390f80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::SetReleaseSetUp(class CBgCtrl* const this, char const* arg2, int32_t arg3, int32_t arg4, uint8_t arg5, float arg6, int32_t arg7, uint8_t arg8, int32_t arg9, uint32_t arg10, uint8_t arg11) [?SetReleaseSetUp@CBgCtrl@@AAE_NPBDHH_NMH1HI1@Z]
	typedef uint8_t(__thiscall* _SetReleaseSetUp_CBgCtrl__AAE_NPBDHH_NMH1HI1_Z)(class CBgCtrl* const thisPtr, char const* arg2, int32_t arg3, int32_t arg4, uint8_t arg5, float arg6, int32_t arg7, uint8_t arg8, int32_t arg9, uint32_t arg10, uint8_t arg11);
	uint8_t SetReleaseSetUp(std::string arg2, int32_t arg3, int32_t arg4, uint8_t arg5, float arg6, int32_t arg7, uint8_t arg8, int32_t arg9, uint32_t arg10, uint8_t arg11)
	{
		char const* arg2_c_str = arg2.c_str();
		_SetReleaseSetUp_CBgCtrl__AAE_NPBDHH_NMH1HI1_Z mFunc = (_SetReleaseSetUp_CBgCtrl__AAE_NPBDHH_NMH1HI1_Z)(GameModule + 0x390ff0);
		return mFunc(this, arg2_c_str, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::RequestReleaseStage(class CBgCtrl* const this, int32_t arg2, int32_t arg3, uint8_t arg4, int32_t arg5, uint32_t arg6, uint8_t arg7) [?RequestReleaseStage@CBgCtrl@@QAE_NHH_NHI0@Z]
	typedef uint8_t(__thiscall* _RequestReleaseStage_CBgCtrl__QAE_NHH_NHI0_Z)(class CBgCtrl* const thisPtr, int32_t arg2, int32_t arg3, uint8_t arg4, int32_t arg5, uint32_t arg6, uint8_t arg7);
	uint8_t RequestReleaseStage(int32_t arg2, int32_t arg3, uint8_t arg4, int32_t arg5, uint32_t arg6, uint8_t arg7)
	{
		_RequestReleaseStage_CBgCtrl__QAE_NHH_NHI0_Z mFunc = (_RequestReleaseStage_CBgCtrl__QAE_NHH_NHI0_Z)(GameModule + 0x3910f0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::SetStageRequestRun(class CBgCtrl* const this) [?SetStageRequestRun@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _SetStageRequestRun_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t SetStageRequestRun()
	{
		_SetStageRequestRun_CBgCtrl__QAE_NXZ mFunc = (_SetStageRequestRun_CBgCtrl__QAE_NXZ)(GameModule + 0x391130);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::SetStageRequestParam(class CBgCtrl* const this, char* arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6) [?SetStageRequestParam@CBgCtrl@@QAEXPADHHH_N@Z]
	typedef void(__thiscall* _SetStageRequestParam_CBgCtrl__QAEXPADHHH_N_Z)(class CBgCtrl* const thisPtr, char* arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6);
	void SetStageRequestParam(std::string arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_SetStageRequestParam_CBgCtrl__QAEXPADHHH_N_Z mFunc = (_SetStageRequestParam_CBgCtrl__QAEXPADHHH_N_Z)(GameModule + 0x391170);
		return mFunc(this, &arg2_c_str[0], arg3, arg4, arg5, arg6);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::SetStage(class CBgCtrl* const this, char const* arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6, int32_t arg7, float arg8, int32_t arg9, uint8_t arg10, uint32_t arg11) [?SetStage@CBgCtrl@@QAE_NPBDHHH_NHMH1I@Z]
	typedef uint8_t(__thiscall* _SetStage_CBgCtrl__QAE_NPBDHHH_NHMH1I_Z)(class CBgCtrl* const thisPtr, char const* arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6, int32_t arg7, float arg8, int32_t arg9, uint8_t arg10, uint32_t arg11);
	uint8_t SetStage(std::string arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6, int32_t arg7, float arg8, int32_t arg9, uint8_t arg10, uint32_t arg11)
	{
		char const* arg2_c_str = arg2.c_str();
		_SetStage_CBgCtrl__QAE_NPBDHHH_NHMH1I_Z mFunc = (_SetStage_CBgCtrl__QAE_NPBDHHH_NHMH1I_Z)(GameModule + 0x3911d0);
		return mFunc(this, arg2_c_str, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::SetStage(class CBgCtrl* const this, uint32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6, int32_t arg7, float arg8, int32_t arg9, uint8_t arg10, uint32_t arg11) [?SetStage@CBgCtrl@@QAE_NIHHH_NHMH0I@Z]
	typedef uint8_t(__thiscall* _SetStage_CBgCtrl__QAE_NIHHH_NHMH0I_Z_2)(class CBgCtrl* const thisPtr, uint32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6, int32_t arg7, float arg8, int32_t arg9, uint8_t arg10, uint32_t arg11);
	uint8_t SetStage_2(uint32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, uint8_t arg6, int32_t arg7, float arg8, int32_t arg9, uint8_t arg10, uint32_t arg11)
	{
		_SetStage_CBgCtrl__QAE_NIHHH_NHMH0I_Z_2 mFunc = (_SetStage_CBgCtrl__QAE_NIHHH_NHMH0I_Z_2)(GameModule + 0x3913b0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::SetPlayDemoStatus(class CBgCtrl* const this) [?SetPlayDemoStatus@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _SetPlayDemoStatus_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t SetPlayDemoStatus()
	{
		_SetPlayDemoStatus_CBgCtrl__QAE_NXZ mFunc = (_SetPlayDemoStatus_CBgCtrl__QAE_NXZ)(GameModule + 0x3913f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::TestDemoSetUp(class CBgCtrl* const this) [?TestDemoSetUp@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _TestDemoSetUp_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t TestDemoSetUp()
	{
		_TestDemoSetUp_CBgCtrl__QAE_NXZ mFunc = (_TestDemoSetUp_CBgCtrl__QAE_NXZ)(GameModule + 0x391430);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::TestLoadStageStatus(class CBgCtrl* const this) [?TestLoadStageStatus@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _TestLoadStageStatus_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t TestLoadStageStatus()
	{
		_TestLoadStageStatus_CBgCtrl__QAE_NXZ mFunc = (_TestLoadStageStatus_CBgCtrl__QAE_NXZ)(GameModule + 0x391450);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::TestDemo(class CBgCtrl* const this) [?TestDemo@CBgCtrl@@AAE_NXZ]
	typedef uint8_t(__thiscall* _TestDemo_CBgCtrl__AAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t TestDemo()
	{
		_TestDemo_CBgCtrl__AAE_NXZ mFunc = (_TestDemo_CBgCtrl__AAE_NXZ)(GameModule + 0x391470);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::EndMovie(class CBgCtrl* const this) [?EndMovie@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _EndMovie_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t EndMovie()
	{
		_EndMovie_CBgCtrl__QAE_NXZ mFunc = (_EndMovie_CBgCtrl__QAE_NXZ)(GameModule + 0x391490);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::TestMovie(class CBgCtrl* const this) [?TestMovie@CBgCtrl@@AAE_NXZ]
	typedef uint8_t(__thiscall* _TestMovie_CBgCtrl__AAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t TestMovie()
	{
		_TestMovie_CBgCtrl__AAE_NXZ mFunc = (_TestMovie_CBgCtrl__AAE_NXZ)(GameModule + 0x3914c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::RequestMovie(class CBgCtrl* const this) [?RequestMovie@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _RequestMovie_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t RequestMovie()
	{
		_RequestMovie_CBgCtrl__QAE_NXZ mFunc = (_RequestMovie_CBgCtrl__QAE_NXZ)(GameModule + 0x3914d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::onDrawShadow(class CBgCtrl* const this) [?onDrawShadow@CBgCtrl@@UAEXXZ]
	typedef void(__thiscall* _onDrawShadow_CBgCtrl__UAEXXZ)(class CBgCtrl* const thisPtr);
	void onDrawShadow()
	{
		_onDrawShadow_CBgCtrl__UAEXXZ mFunc = (_onDrawShadow_CBgCtrl__UAEXXZ)(GameModule + 0x391500);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::RenderProcess(class CBgCtrl* const this) [?RenderProcess@CBgCtrl@@UAEXXZ]
	typedef void(__thiscall* _RenderProcess_CBgCtrl__UAEXXZ)(class CBgCtrl* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_CBgCtrl__UAEXXZ mFunc = (_RenderProcess_CBgCtrl__UAEXXZ)(GameModule + 0x391510);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::FrameProcess(class CBgCtrl* const this) [?FrameProcess@CBgCtrl@@UAEXXZ]
	typedef void(__thiscall* _FrameProcess_CBgCtrl__UAEXXZ)(class CBgCtrl* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_CBgCtrl__UAEXXZ mFunc = (_FrameProcess_CBgCtrl__UAEXXZ)(GameModule + 0x3915a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::ClearStageName(class CBgCtrl* const this) [?ClearStageName@CBgCtrl@@QAEXXZ]
	typedef void(__thiscall* _ClearStageName_CBgCtrl__QAEXXZ)(class CBgCtrl* const thisPtr);
	void ClearStageName()
	{
		_ClearStageName_CBgCtrl__QAEXXZ mFunc = (_ClearStageName_CBgCtrl__QAEXXZ)(GameModule + 0x391dc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::Terminate(class CBgCtrl* const this) [?Terminate@CBgCtrl@@UAEXXZ]
	typedef void(__thiscall* _Terminate_CBgCtrl__UAEXXZ)(class CBgCtrl* const thisPtr);
	void Terminate()
	{
		_Terminate_CBgCtrl__UAEXXZ mFunc = (_Terminate_CBgCtrl__UAEXXZ)(GameModule + 0x391df0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::Release(class CBgCtrl* const this) [?Release@CBgCtrl@@AAE_NXZ]
	typedef uint8_t(__thiscall* _Release_CBgCtrl__AAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t Release()
	{
		_Release_CBgCtrl__AAE_NXZ mFunc = (_Release_CBgCtrl__AAE_NXZ)(GameModule + 0x392010);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CBgCtrl::Initialize(class CBgCtrl* const this) [?Initialize@CBgCtrl@@UAEXXZ]
	typedef void(__thiscall* _Initialize_CBgCtrl__UAEXXZ)(class CBgCtrl* const thisPtr);
	void Initialize()
	{
		_Initialize_CBgCtrl__UAEXXZ mFunc = (_Initialize_CBgCtrl__UAEXXZ)(GameModule + 0x392600);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::ReleaseRequest(class CBgCtrl* const this) [?ReleaseRequest@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _ReleaseRequest_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t ReleaseRequest()
	{
		_ReleaseRequest_CBgCtrl__QAE_NXZ mFunc = (_ReleaseRequest_CBgCtrl__QAE_NXZ)(GameModule + 0x392630);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") CBgCtrl::LoadRequest(class CBgCtrl* const this) [?LoadRequest@CBgCtrl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _LoadRequest_CBgCtrl__QAE_NXZ)(class CBgCtrl* const thisPtr);
	uint8_t LoadRequest()
	{
		_LoadRequest_CBgCtrl__QAE_NXZ mFunc = (_LoadRequest_CBgCtrl__QAE_NXZ)(GameModule + 0x392650);
		return mFunc(this);
	}
	// [Function] class CBgCtrl* CBgCtrl::Create() [?Create@CBgCtrl@@SAPAV1@XZ]
	typedef class CBgCtrl*(__fastcall* _Create_CBgCtrl__SAPAV1_XZ)();
	static class CBgCtrl* Create()
	{
		_Create_CBgCtrl__SAPAV1_XZ mFunc = (_Create_CBgCtrl__SAPAV1_XZ)(GameModule + 0x392670);
		return mFunc();
	}
	// [Function] void __convention("thiscall") CBgCtrl::ReadParam(class CBgCtrl* const this, void* arg2) [?ReadParam@CBgCtrl@@QAEXPAX@Z]
	typedef void(__thiscall* _ReadParam_CBgCtrl__QAEXPAX_Z)(class CBgCtrl* const thisPtr, void* arg2);
	void ReadParam(void* arg2)
	{
		_ReadParam_CBgCtrl__QAEXPAX_Z mFunc = (_ReadParam_CBgCtrl__QAEXPAX_Z)(GameModule + 0x393bc0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CBgCtrl [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CBgCtrl& InObject)
	{
		IsDarkStage = InObject.IsDarkStage;
		StageName = InObject.StageName;
		StageID = InObject.StageID;
		ResGroup = InObject.ResGroup;
		ToneMapEnabled = InObject.ToneMapEnabled;
		SkyMap = InObject.SkyMap;
		Status = InObject.Status;
		UnknownResourceFlag = InObject.UnknownResourceFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CBgCtrl>("CBgCtrl")
			.addFunction("__tostring", &CBgCtrl::ToString)
			.addFunction("GetPtrAddr", &CBgCtrl::GetPtrAddr)
			.addProperty("IsDarkStage", &CBgCtrl::IsDarkStage)
			// char* type not supported in LuaBridge
			//.addProperty("StageName", &CBgCtrl::StageName)
			.addProperty("StageID", &CBgCtrl::StageID)
			.addProperty("ResGroup", &CBgCtrl::ResGroup)
			.addProperty("ToneMapEnabled", &CBgCtrl::ToneMapEnabled)
			.addProperty("SkyMap", &CBgCtrl::SkyMap)
			.addProperty("Status", &CBgCtrl::Status)
			.addProperty("UnknownResourceFlag", &CBgCtrl::UnknownResourceFlag)
			.addFunction("IsVisible", &CBgCtrl::IsVisible)
			.addFunction("SetDarkStage", &CBgCtrl::SetDarkStage)
			.addFunction("GetStageID", &CBgCtrl::GetStageID)
			.addFunction("GetScrHandle", &CBgCtrl::GetScrHandle)
			.addFunction("SetPositionChange", &CBgCtrl::SetPositionChange)
			.addFunction("SetNpcVisible", &CBgCtrl::SetNpcVisible)
			.addFunction("GetStageGmfPtr", &CBgCtrl::GetStageGmfPtr)
			.addFunction("SetDisEnableLoadingEffect", &CBgCtrl::SetDisEnableLoadingEffect)
			.addFunction("SetFarBloomEnable", &CBgCtrl::SetFarBloomEnable)
			.addFunction("SetThresholdEnable", &CBgCtrl::SetThresholdEnable)
			.addFunction("IsRailData", &CBgCtrl::IsRailData)
			.addFunction("isSantaDestroyStage", &CBgCtrl::isSantaDestroyStage)
			.addFunction("getLensFlare", &CBgCtrl::getLensFlare)
			.addFunction("GetRankingUpRequest", &CBgCtrl::GetRankingUpRequest)
			.addFunction("SetFarBloomColor", &CBgCtrl::SetFarBloomColor)
			.addFunction("SetThresholdColor", &CBgCtrl::SetThresholdColor)
			.addFunction("getTopResourceGroup", &CBgCtrl::getTopResourceGroup)
			.addStaticFunction("IsCBgCtrl", &CBgCtrl::IsCBgCtrl)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("checkAndUpdateFarGmfPosition", &CBgCtrl::checkAndUpdateFarGmfPosition)
			.addFunction("GetDrawStageDraw", &CBgCtrl::GetDrawStageDraw)
			.addFunction("GetFarBloomColor", &CBgCtrl::GetFarBloomColor)
			.addFunction("GetFarGmfPtr", &CBgCtrl::GetFarGmfPtr)
			.addFunction("SetDrawStageDraw", &CBgCtrl::SetDrawStageDraw)
			.addFunction("SetVisible", &CBgCtrl::SetVisible)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("getFarGmfTransformPosition", &CBgCtrl::getFarGmfTransformPosition)
			.addFunction("SetStgFuncOnlyVisible", &CBgCtrl::SetStgFuncOnlyVisible)
			.addFunction("IsStgFuncOnlyVisible", &CBgCtrl::IsStgFuncOnlyVisible)
			.addFunction("SetDontExecNpcProcess", &CBgCtrl::SetDontExecNpcProcess)
			.addFunction("SetFarVisible", &CBgCtrl::SetFarVisible)
			.addFunction("SetToneMapEnable", &CBgCtrl::SetToneMapEnable)
			.addFunction("GetFarBloomEnable", &CBgCtrl::GetFarBloomEnable)
			.addFunction("GetThresholdEnable", &CBgCtrl::GetThresholdEnable)
			.addFunction("GetSkyMap", &CBgCtrl::GetSkyMap)
			.addFunction("IsTermToiletEffect", &CBgCtrl::IsTermToiletEffect)
			.addFunction("TermToiletEffect", &CBgCtrl::TermToiletEffect)
			.addFunction("TermTutoResult", &CBgCtrl::TermTutoResult)
			.addFunction("IsDispTutoResult", &CBgCtrl::IsDispTutoResult)
			.addFunction("DispTutoResult", &CBgCtrl::DispTutoResult)
			.addFunction("SetStaffRoll2Request", &CBgCtrl::SetStaffRoll2Request)
			.addFunction("SetStaffRoll1Request", &CBgCtrl::SetStaffRoll1Request)
			.addFunction("SetDemoToDemoStgRequest", &CBgCtrl::SetDemoToDemoStgRequest)
			.addFunction("SetDemoToDemoRequest", &CBgCtrl::SetDemoToDemoRequest)
			.addFunction("SetBossResultRequest", &CBgCtrl::SetBossResultRequest)
			.addFunction("SetRankingUpRequest", &CBgCtrl::SetRankingUpRequest)
			.addFunction("ClearDisEnableLoadingEffect", &CBgCtrl::ClearDisEnableLoadingEffect)
			.addFunction("TestDisEnableLoadingEffect", &CBgCtrl::TestDisEnableLoadingEffect)
			.addFunction("GetNpcResLink", &CBgCtrl::GetNpcResLink)
			.addFunction("TestNpcRslRead", &CBgCtrl::TestNpcRslRead)
			.addFunction("IsNpcRslRead", &CBgCtrl::IsNpcRslRead)
			.addFunction("NpcRslRead", &CBgCtrl::NpcRslRead)
			.addFunction("StageGayaStopSE", &CBgCtrl::StageGayaStopSE)
			.addFunction("SetGayaVolume", &CBgCtrl::SetGayaVolume)
			.addFunction("StageGayaPlaySE", &CBgCtrl::StageGayaPlaySE)
			.addFunction("SubMissionSndGroupReleaseReq", &CBgCtrl::SubMissionSndGroupReleaseReq)
			.addFunction("GetStageName", &CBgCtrl::GetStageName)
			.addFunction("DebugRelayPoint", &CBgCtrl::DebugRelayPoint)
			.addFunction("PlayMotion", &CBgCtrl::PlayMotion)
			.addFunction("AttachBgMotion", &CBgCtrl::AttachBgMotion)
			.addFunction("CmnObjProFrame", &CBgCtrl::CmnObjProFrame)
			.addFunction("IsColliData", &CBgCtrl::IsColliData)
			.addFunction("GetGmf", &CBgCtrl::GetGmf)
			.addFunction("GetScript", &CBgCtrl::GetScript)
			.addFunction("GetStageDraw", &CBgCtrl::GetStageDraw)
			.addStaticFunction("IsCollisionData", &CBgCtrl::IsCollisionData)
			.addFunction("GetResourceNum", &CBgCtrl::GetResourceNum)
			.addFunction("GetResourceGroup", &CBgCtrl::GetResourceGroup)
			.addFunction("GetResource", &CBgCtrl::GetResource)
			.addFunction("GetResource4LoadingTex", &CBgCtrl::GetResource4LoadingTex)
			.addFunction("GetResource_2", &CBgCtrl::GetResource_2)
			.addFunction("GetFileName", &CBgCtrl::GetFileName)
			.addFunction("CancelRequestStage", &CBgCtrl::CancelRequestStage)
			.addFunction("IsRequestStage", &CBgCtrl::IsRequestStage)
			.addFunction("IsRequestStageLoaded", &CBgCtrl::IsRequestStageLoaded)
			.addFunction("IsReleased", &CBgCtrl::IsReleased)
			.addFunction("IsLoaded", &CBgCtrl::IsLoaded)
			.addFunction("BgLoad", &CBgCtrl::BgLoad)
			.addFunction("SearchBg", &CBgCtrl::SearchBg)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("prPostBGDraw", &CBgCtrl::prPostBGDraw)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("prDrawTutoResultFadeTile", &CBgCtrl::prDrawTutoResultFadeTile)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("prDrawTutoResult", &CBgCtrl::prDrawTutoResult)
			// Can't export & pointer 'struct GXColor&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("beginThresholdBloomEffect", &CBgCtrl::beginThresholdBloomEffect)
			.addFunction("BloomRender", &CBgCtrl::BloomRender)
			.addFunction("CreateThesholdBloom", &CBgCtrl::CreateThesholdBloom)
			.addFunction("CreateFarBloom", &CBgCtrl::CreateFarBloom)
			.addFunction("RenderIdle", &CBgCtrl::RenderIdle)
			.addFunction("GetMessageGroup", &CBgCtrl::GetMessageGroup)
			.addFunction("FarModelRender", &CBgCtrl::FarModelRender)
			.addFunction("SetVisibleLensFlare", &CBgCtrl::SetVisibleLensFlare)
			.addFunction("FrameIdle", &CBgCtrl::FrameIdle)
			.addFunction("SetLDstatus", &CBgCtrl::SetLDstatus)
			.addFunction("InitStage", &CBgCtrl::InitStage)
			.addFunction("SetupSignalOnly", &CBgCtrl::SetupSignalOnly)
			.addFunction("FrameLoad", &CBgCtrl::FrameLoad)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("FenseCallBackPost", &CBgCtrl::FenseCallBackPost)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("FenseCallBack", &CBgCtrl::FenseCallBack)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("DenseCallBack", &CBgCtrl::DenseCallBack)
			.addFunction("SetStatus", &CBgCtrl::SetStatus)
			.addFunction("StageSetUp", &CBgCtrl::StageSetUp)
			.addFunction("IsReleaseSetUp", &CBgCtrl::IsReleaseSetUp)
			.addFunction("SetReleaseSetUp", &CBgCtrl::SetReleaseSetUp)
			.addFunction("RequestReleaseStage", &CBgCtrl::RequestReleaseStage)
			.addFunction("SetStageRequestRun", &CBgCtrl::SetStageRequestRun)
			.addFunction("SetStageRequestParam", &CBgCtrl::SetStageRequestParam)
			.addFunction("SetStage", &CBgCtrl::SetStage)
			.addFunction("SetStage_2", &CBgCtrl::SetStage_2)
			.addFunction("SetPlayDemoStatus", &CBgCtrl::SetPlayDemoStatus)
			.addFunction("TestDemoSetUp", &CBgCtrl::TestDemoSetUp)
			.addFunction("TestLoadStageStatus", &CBgCtrl::TestLoadStageStatus)
			.addFunction("TestDemo", &CBgCtrl::TestDemo)
			.addFunction("EndMovie", &CBgCtrl::EndMovie)
			.addFunction("TestMovie", &CBgCtrl::TestMovie)
			.addFunction("RequestMovie", &CBgCtrl::RequestMovie)
			.addFunction("onDrawShadow", &CBgCtrl::onDrawShadow)
			.addFunction("RenderProcess", &CBgCtrl::RenderProcess)
			.addFunction("FrameProcess", &CBgCtrl::FrameProcess)
			.addFunction("ClearStageName", &CBgCtrl::ClearStageName)
			.addFunction("Terminate", &CBgCtrl::Terminate)
			.addFunction("Release", &CBgCtrl::Release)
			.addFunction("Initialize", &CBgCtrl::Initialize)
			.addFunction("ReleaseRequest", &CBgCtrl::ReleaseRequest)
			.addFunction("LoadRequest", &CBgCtrl::LoadRequest)
			.addStaticFunction("Create", &CBgCtrl::Create)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("ReadParam", &CBgCtrl::ReadParam)
		.endClass();
	}
#endif
};
static_assert(sizeof(CBgCtrl::IsDarkStage) == 1, "expected CBgCtrl::IsDarkStage to be size 1");
static_assert(sizeof(CBgCtrl::StageName) == 4, "expected CBgCtrl::StageName to be size 4");
static_assert(sizeof(CBgCtrl::StageID) == 4, "expected CBgCtrl::StageID to be size 4");
static_assert(sizeof(CBgCtrl::ResGroup) == 4, "expected CBgCtrl::ResGroup to be size 4");
static_assert(sizeof(CBgCtrl::ToneMapEnabled) == 1, "expected CBgCtrl::ToneMapEnabled to be size 1");
static_assert(sizeof(CBgCtrl::SkyMap) == 4, "expected CBgCtrl::SkyMap to be size 4");
static_assert(sizeof(CBgCtrl::Status) == 4, "expected CBgCtrl::Status to be size 4");
static_assert(sizeof(CBgCtrl::UnknownResourceFlag) == 4, "expected CBgCtrl::UnknownResourceFlag to be size 4");
static_assert(sizeof(CBgCtrl) == 0xe48, "expected CBgCtrl to be size 0xe48");

// enum MapAreaID
enum MapAreaID : uint32_t
{
	// <MapID_Init = 0x0>
	MapID_Init = 0,

	// <MapID_ResortHotel = 0x1>
	MapID_ResortHotel = 1,

	// <MapID_UniversityCanvas_Charlie = 0x2>
	MapID_UniversityCanvas_Charlie = 2,

	// <MapID_UniversityCanvas_Kimmy = 0x3>
	MapID_UniversityCanvas_Kimmy = 3,

	// <MapID_DesertedHouse = 0x4>
	MapID_DesertedHouse = 4,

	// <MapID_PrisonIsland = 0x5>
	MapID_PrisonIsland = 5,

	// <MapID_Stadium = 0x6>
	MapID_Stadium = 6,

	// <MapID_Cliff = 0x7>
	MapID_Cliff = 7,

	// <MapID_Supermarket = 0x8>
	MapID_Supermarket = 8,

	// <MapID_Highway = 0x9>
	MapID_Highway = 9,

	// <MapID_ApartmentHouse = 0xa>
	MapID_ApartmentHouse = 10,

	// <MapID_PizzaBatHeadquarters = 0xb>
	MapID_PizzaBatHeadquarters = 11,

	// <MapID_OfficeUAA_Chapter3 = 0xc>
	MapID_OfficeUAA_Chapter3 = 12,

	// <MapID_OfficeUAA_Chapter7 = 0xd>
	MapID_OfficeUAA_Chapter7 = 13,

	// <MapID_OfficeUAA_Chapter12 = 0xe>
	MapID_OfficeUAA_Chapter12 = 14,

	// <MapID_PizzaSuplex = 0xf>
	MapID_PizzaSuplex = 15,

	// <MapID_Motel = 0x10>
	MapID_Motel = 16,

	// <MapID_Area51 = 0x11>
	MapID_Area51 = 17,

	// <MapID_NaomiRabo = 0x12>
	MapID_NaomiRabo = 18,

	// <MapID_TrainingGym = 0x13>
	MapID_TrainingGym = 19,

	// <MapID_BugExtermi = 0x14>
	MapID_BugExtermi = 20,

	// <MapID_PipeRepair = 0x15>
	MapID_PipeRepair = 21,

	// <MapID_CoconutCollector = 0x16>
	MapID_CoconutCollector = 22,

	// <MapID_PizzaDeli = 0x17>
	MapID_PizzaDeli = 23,

	// <MapID_SteakHouse = 0x18>
	MapID_SteakHouse = 24,

	// <MapID_TilePuzzle = 0x19>
	MapID_TilePuzzle = 25,

	// <MapID_GettinggTrashed = 0x1a>
	MapID_GettinggTrashed = 26,

	// <MapID_ScorpionEexterm = 0x1b>
	MapID_ScorpionEexterm = 27,

	// <MapID_RevengeMission1 = 0x1c>
	MapID_RevengeMission1 = 28,

	// <MapID_RevengeMission2 = 0x1d>
	MapID_RevengeMission2 = 29,

	// <MapID_RevengeMission3 = 0x1e>
	MapID_RevengeMission3 = 30,

	// <MapID_RevengeMission4 = 0x1f>
	MapID_RevengeMission4 = 31,

	// <MapID_RevengeMission5 = 0x20>
	MapID_RevengeMission5 = 32,

	// <MapID_RevengeMission6 = 0x21>
	MapID_RevengeMission6 = 33,

	// <MapID_RevengeMission7 = 0x22>
	MapID_RevengeMission7 = 34,

	// <MapID_RevengeMission8 = 0x23>
	MapID_RevengeMission8 = 35,

	// <MapID_RevengeMission9 = 0x24>
	MapID_RevengeMission9 = 36,

	// <MapID_RevengeMission10 = 0x25>
	MapID_RevengeMission10 = 37,

	// <MapID_Max = 0x26>
	MapID_Max = 38

};

// [Structure] class rSkyMap
class rSkyMap
{
public:
	// enum rSkyMap::SkyMapState
	enum SkyMapState : uint32_t
	{
		// <State_Init = 0x0>
		State_Init = 0,

		// <State_MoveSky = 0x1>
		State_MoveSky = 1,

		// <State_Select = 0x2>
		State_Select = 2,

		// <State_Enter = 0x3>
		State_Enter = 3,

		// <State_MoveGround = 0x4>
		State_MoveGround = 4,

		// <State_End = 0x5>
		State_End = 5

	};

	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <enum rSkyMap::SkyMapState mState, offset 0x4>
	enum rSkyMap::SkyMapState mState;

	// <class TGmf* mpLowModel, offset 0x8>
	class TGmf* mpLowModel = nullptr;

	// <class TGmfNode* mpLowNode, offset 0xc>
	class TGmfNode* mpLowNode = nullptr;

	// <class TGmfNode* mpSuperLowNode, offset 0x10>
	class TGmfNode* mpSuperLowNode = nullptr;

	// <uint8_t mbHiModelLoad, offset 0x14>
	uint8_t mbHiModelLoad = 0;

	// <Unidentified data segment, offset 0x15>
private:
	char _UnidentifiedData_21[3];

public:
	// <float mChangeRate, offset 0x18>
	float mChangeRate = 0;

	// <float mChangeSpeed, offset 0x1c>
	float mChangeSpeed = 0;

	// <struct Vec mCamPos, offset 0x20>
	struct Vec mCamPos;

	// <struct Vec mCamTarget, offset 0x2c>
	struct Vec mCamTarget;

	// <struct Vec mCamAttainPos, offset 0x38>
	struct Vec mCamAttainPos;

	// <struct Vec mCamAttainTarget, offset 0x44>
	struct Vec mCamAttainTarget;

	// <struct Vec mCamAngleDirec, offset 0x50>
	struct Vec mCamAngleDirec;

	// <struct Vec mBefCamAngleDirec, offset 0x5c>
	struct Vec mBefCamAngleDirec;

	// <struct Vec mCamStartPos, offset 0x68>
	struct Vec mCamStartPos;

	// <struct Vec mCamStartTarget, offset 0x74>
	struct Vec mCamStartTarget;

	// <struct Vec mCamEndPos, offset 0x80>
	struct Vec mCamEndPos;

	// <struct Vec mCamEndTarget, offset 0x8c>
	struct Vec mCamEndTarget;

	// <float mCamBaseHeight, offset 0x98>
	float mCamBaseHeight = 0;

	// <float mCamZoomRange, offset 0x9c>
	float mCamZoomRange = 0;

	// <float mCamZoomRate, offset 0xa0>
	float mCamZoomRate = 0;

	// <float mCamAngleRate, offset 0xa4>
	float mCamAngleRate = 0;

	// <float mCamMoveLen, offset 0xa8>
	float mCamMoveLen = 0;

	// <uint8_t mbCamMove, offset 0xac>
	uint8_t mbCamMove = 0;

	// <Unidentified data segment, offset 0xad>
private:
	char _UnidentifiedData_173[3];

public:
	// <float mChangeHeight, offset 0xb0>
	float mChangeHeight = 0;

	// <class EffectSpeedBlur* mpBlur, offset 0xb4>
	class EffectSpeedBlur* mpBlur = nullptr;

	// <float mBlurScale, offset 0xb8>
	float mBlurScale = 0;

	// <int32_t mBlurRep, offset 0xbc>
	int32_t mBlurRep = 0;

	// <float mBlurAlpha, offset 0xc0>
	float mBlurAlpha = 0;

	// <float mBlurRange, offset 0xc4>
	float mBlurRange = 0;

	// <enum MapAreaID mSelectMapID, offset 0xc8>
	enum MapAreaID mSelectMapID;

	// <class TGmfNode* mSelectNode, offset 0xcc>
	class TGmfNode* mSelectNode = nullptr;

	// <class TGmfNode* mBefSelectNode, offset 0xd0>
	class TGmfNode* mBefSelectNode = nullptr;

	// <class TGmfNode* mSelectIconNode, offset 0xd4>
	class TGmfNode* mSelectIconNode = nullptr;

	// <int32_t mSelectWait, offset 0xd8>
	int32_t mSelectWait = 0;

	// <class rSkyMapMenu* mpMenu, offset 0xdc>
	class rSkyMapMenu* mpMenu = nullptr;

	// <int32_t mBokashiRez, offset 0xe0>
	int32_t mBokashiRez = 0;

	// <int32_t mBokashiKosa, offset 0xe4>
	int32_t mBokashiKosa = 0;

	// <int32_t mNoizeKosa, offset 0xe8>
	int32_t mNoizeKosa = 0;

	// <int32_t mNoizeAnimWait, offset 0xec>
	int32_t mNoizeAnimWait = 0;

	// <int32_t mBokashi_R, offset 0xf0>
	int32_t mBokashi_R = 0;

	// <int32_t mBokashi_G, offset 0xf4>
	int32_t mBokashi_G = 0;

	// <int32_t mBokashi_B, offset 0xf8>
	int32_t mBokashi_B = 0;

	// <int32_t mLoadWaitSE, offset 0xfc>
	int32_t mLoadWaitSE = 0;

	// <int32_t mhSkyMapBgm, offset 0x100>
	int32_t mhSkyMapBgm = 0;

	// <float mMarkScale, offset 0x104>
	float mMarkScale = 0;

	// <float mMarkSin, offset 0x108>
	float mMarkSin = 0;

	/// 17 Functions

	// [Function] int32_t __convention("thiscall") rSkyMap::GetSelectMapID(class rSkyMap* const this) [?GetSelectMapID@rSkyMap@@QAEHXZ]
	typedef int32_t(__thiscall* _GetSelectMapID_rSkyMap__QAEHXZ)(class rSkyMap* const thisPtr);
	int32_t GetSelectMapID()
	{
		_GetSelectMapID_rSkyMap__QAEHXZ mFunc = (_GetSelectMapID_rSkyMap__QAEHXZ)(GameModule + 0xa2430);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") rSkyMap::GetState(class rSkyMap* const this) [?GetState@rSkyMap@@QAEHXZ]
	typedef int32_t(__thiscall* _GetState_rSkyMap__QAEHXZ)(class rSkyMap* const thisPtr);
	int32_t GetState()
	{
		_GetState_rSkyMap__QAEHXZ mFunc = (_GetState_rSkyMap__QAEHXZ)(GameModule + 0xa2440);
		return mFunc(this);
	}
	// [Function] class TGmfNode* __convention("thiscall") rSkyMap::GetSuperLowNode(class rSkyMap* const this) [?GetSuperLowNode@rSkyMap@@QAEPAVTGmfNode@@XZ]
	typedef class TGmfNode*(__thiscall* _GetSuperLowNode_rSkyMap__QAEPAVTGmfNode__XZ)(class rSkyMap* const thisPtr);
	class TGmfNode* GetSuperLowNode()
	{
		_GetSuperLowNode_rSkyMap__QAEPAVTGmfNode__XZ mFunc = (_GetSuperLowNode_rSkyMap__QAEPAVTGmfNode__XZ)(GameModule + 0xaf300);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") rSkyMap::GetMulColor(class rSkyMap* const this, float arg2) [?GetMulColor@rSkyMap@@AAEIM@Z]
	typedef uint32_t(__thiscall* _GetMulColor_rSkyMap__AAEIM_Z)(class rSkyMap* const thisPtr, float arg2);
	uint32_t GetMulColor(float arg2)
	{
		_GetMulColor_rSkyMap__AAEIM_Z mFunc = (_GetMulColor_rSkyMap__AAEIM_Z)(GameModule + 0x466680);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") rSkyMap::SetCamAngleDirec(class rSkyMap* const this) [?SetCamAngleDirec@rSkyMap@@AAEXXZ]
	typedef void(__thiscall* _SetCamAngleDirec_rSkyMap__AAEXXZ)(class rSkyMap* const thisPtr);
	void SetCamAngleDirec()
	{
		_SetCamAngleDirec_rSkyMap__AAEXXZ mFunc = (_SetCamAngleDirec_rSkyMap__AAEXXZ)(GameModule + 0x466690);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMap::AddNodeVisible(class rSkyMap* const this, uint8_t arg2) [?AddNodeVisible@rSkyMap@@AAEX_N@Z]
	typedef void(__thiscall* _AddNodeVisible_rSkyMap__AAEX_N_Z)(class rSkyMap* const thisPtr, uint8_t arg2);
	void AddNodeVisible(uint8_t arg2)
	{
		_AddNodeVisible_rSkyMap__AAEX_N_Z mFunc = (_AddNodeVisible_rSkyMap__AAEX_N_Z)(GameModule + 0x4666f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") rSkyMap::ResetNoizeParam(class rSkyMap* const this) [?ResetNoizeParam@rSkyMap@@AAEXXZ]
	typedef void(__thiscall* _ResetNoizeParam_rSkyMap__AAEXXZ)(class rSkyMap* const thisPtr);
	void ResetNoizeParam()
	{
		_ResetNoizeParam_rSkyMap__AAEXXZ mFunc = (_ResetNoizeParam_rSkyMap__AAEXXZ)(GameModule + 0x466740);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMap::SetSuperLowNoizeParam(class rSkyMap* const this) [?SetSuperLowNoizeParam@rSkyMap@@AAEXXZ]
	typedef void(__thiscall* _SetSuperLowNoizeParam_rSkyMap__AAEXXZ)(class rSkyMap* const thisPtr);
	void SetSuperLowNoizeParam()
	{
		_SetSuperLowNoizeParam_rSkyMap__AAEXXZ mFunc = (_SetSuperLowNoizeParam_rSkyMap__AAEXXZ)(GameModule + 0x466790);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMap::SetState(class rSkyMap* const this, enum rSkyMap::SkyMapState arg2) [?SetState@rSkyMap@@QAEXW4SkyMapState@1@@Z]
	typedef void(__thiscall* _SetState_rSkyMap__QAEXW4SkyMapState_1__Z)(class rSkyMap* const thisPtr, enum rSkyMap::SkyMapState arg2);
	void SetState(/* enum rSkyMap::SkyMapState */ uint32_t arg2)
	{
		_SetState_rSkyMap__QAEXW4SkyMapState_1__Z mFunc = (_SetState_rSkyMap__QAEXW4SkyMapState_1__Z)(GameModule + 0x4667c0);
		return mFunc(this, (enum rSkyMap::SkyMapState)arg2);
	}
	// [Function] void __convention("thiscall") rSkyMap::AreaSelect(class rSkyMap* const this, int32_t MapID) [?AreaSelect@rSkyMap@@QAEXH@Z]
	typedef void(__thiscall* _AreaSelect_rSkyMap__QAEXH_Z)(class rSkyMap* const thisPtr, int32_t MapID);
	void AreaSelect(int32_t MapID)
	{
		_AreaSelect_rSkyMap__QAEXH_Z mFunc = (_AreaSelect_rSkyMap__QAEXH_Z)(GameModule + 0x4667e0);
		return mFunc(this, MapID);
	}
	// [Function] uint8_t __convention("thiscall") rSkyMap::MoveSky(class rSkyMap* const this, int32_t arg2) [?MoveSky@rSkyMap@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _MoveSky_rSkyMap__QAE_NH_Z)(class rSkyMap* const thisPtr, int32_t arg2);
	uint8_t MoveSky(int32_t arg2)
	{
		_MoveSky_rSkyMap__QAE_NH_Z mFunc = (_MoveSky_rSkyMap__QAE_NH_Z)(GameModule + 0x4689b0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") rSkyMap::MoveGround(class rSkyMap* const this, struct Vec& arg2, struct Vec& arg3) [?MoveGround@rSkyMap@@QAE_NABUVec@@0@Z]
	typedef uint8_t(__thiscall* _MoveGround_rSkyMap__QAE_NABUVec__0_Z)(class rSkyMap* const thisPtr, struct Vec& arg2, struct Vec& arg3);
	uint8_t MoveGround(struct Vec& arg2, struct Vec& arg3)
	{
		_MoveGround_rSkyMap__QAE_NABUVec__0_Z mFunc = (_MoveGround_rSkyMap__QAE_NABUVec__0_Z)(GameModule + 0x468d10);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") rSkyMap::IsEnter(class rSkyMap* const this) [?IsEnter@rSkyMap@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsEnter_rSkyMap__QAE_NXZ)(class rSkyMap* const thisPtr);
	uint8_t IsEnter()
	{
		_IsEnter_rSkyMap__QAE_NXZ mFunc = (_IsEnter_rSkyMap__QAE_NXZ)(GameModule + 0x468dd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") rSkyMap::Terminate(class rSkyMap* const this) [?Terminate@rSkyMap@@QAE_NXZ]
	typedef uint8_t(__thiscall* _Terminate_rSkyMap__QAE_NXZ)(class rSkyMap* const thisPtr);
	uint8_t Terminate()
	{
		_Terminate_rSkyMap__QAE_NXZ mFunc = (_Terminate_rSkyMap__QAE_NXZ)(GameModule + 0x468df0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") rSkyMap::Initialize(class rSkyMap* const this) [?Initialize@rSkyMap@@QAE_NXZ]
	typedef uint8_t(__thiscall* _Initialize_rSkyMap__QAE_NXZ)(class rSkyMap* const thisPtr);
	uint8_t Initialize()
	{
		_Initialize_rSkyMap__QAE_NXZ mFunc = (_Initialize_rSkyMap__QAE_NXZ)(GameModule + 0x468ed0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMap::FrameProc(class rSkyMap* const this) [?FrameProc@rSkyMap@@QAEXXZ]
	typedef void(__thiscall* _FrameProc_rSkyMap__QAEXXZ)(class rSkyMap* const thisPtr);
	void FrameProc()
	{
		_FrameProc_rSkyMap__QAEXXZ mFunc = (_FrameProc_rSkyMap__QAEXXZ)(GameModule + 0x4690b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMap::RenderProc(class rSkyMap* const this) [?RenderProc@rSkyMap@@QAEXXZ]
	typedef void(__thiscall* _RenderProc_rSkyMap__QAEXXZ)(class rSkyMap* const thisPtr);
	void RenderProc()
	{
		_RenderProc_rSkyMap__QAEXXZ mFunc = (_RenderProc_rSkyMap__QAEXXZ)(GameModule + 0x469c60);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rSkyMap [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rSkyMap& InObject)
	{
		mState = InObject.mState;
		mpLowModel = InObject.mpLowModel;
		mpLowNode = InObject.mpLowNode;
		mpSuperLowNode = InObject.mpSuperLowNode;
		mbHiModelLoad = InObject.mbHiModelLoad;
		mChangeRate = InObject.mChangeRate;
		mChangeSpeed = InObject.mChangeSpeed;
		mCamPos = InObject.mCamPos;
		mCamTarget = InObject.mCamTarget;
		mCamAttainPos = InObject.mCamAttainPos;
		mCamAttainTarget = InObject.mCamAttainTarget;
		mCamAngleDirec = InObject.mCamAngleDirec;
		mBefCamAngleDirec = InObject.mBefCamAngleDirec;
		mCamStartPos = InObject.mCamStartPos;
		mCamStartTarget = InObject.mCamStartTarget;
		mCamEndPos = InObject.mCamEndPos;
		mCamEndTarget = InObject.mCamEndTarget;
		mCamBaseHeight = InObject.mCamBaseHeight;
		mCamZoomRange = InObject.mCamZoomRange;
		mCamZoomRate = InObject.mCamZoomRate;
		mCamAngleRate = InObject.mCamAngleRate;
		mCamMoveLen = InObject.mCamMoveLen;
		mbCamMove = InObject.mbCamMove;
		mChangeHeight = InObject.mChangeHeight;
		mpBlur = InObject.mpBlur;
		mBlurScale = InObject.mBlurScale;
		mBlurRep = InObject.mBlurRep;
		mBlurAlpha = InObject.mBlurAlpha;
		mBlurRange = InObject.mBlurRange;
		mSelectMapID = InObject.mSelectMapID;
		mSelectNode = InObject.mSelectNode;
		mBefSelectNode = InObject.mBefSelectNode;
		mSelectIconNode = InObject.mSelectIconNode;
		mSelectWait = InObject.mSelectWait;
		mpMenu = InObject.mpMenu;
		mBokashiRez = InObject.mBokashiRez;
		mBokashiKosa = InObject.mBokashiKosa;
		mNoizeKosa = InObject.mNoizeKosa;
		mNoizeAnimWait = InObject.mNoizeAnimWait;
		mBokashi_R = InObject.mBokashi_R;
		mBokashi_G = InObject.mBokashi_G;
		mBokashi_B = InObject.mBokashi_B;
		mLoadWaitSE = InObject.mLoadWaitSE;
		mhSkyMapBgm = InObject.mhSkyMapBgm;
		mMarkScale = InObject.mMarkScale;
		mMarkSin = InObject.mMarkSin;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rSkyMap>("rSkyMap")
			.addFunction("__tostring", &rSkyMap::ToString)
			.addFunction("GetPtrAddr", &rSkyMap::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &rSkyMap::field_0)
			.addProperty("mState", &rSkyMap::mState)
			.addProperty("mpLowModel", &rSkyMap::mpLowModel)
			.addProperty("mpLowNode", &rSkyMap::mpLowNode)
			.addProperty("mpSuperLowNode", &rSkyMap::mpSuperLowNode)
			.addProperty("mbHiModelLoad", &rSkyMap::mbHiModelLoad)
			.addProperty("mChangeRate", &rSkyMap::mChangeRate)
			.addProperty("mChangeSpeed", &rSkyMap::mChangeSpeed)
			.addProperty("mCamPos", &rSkyMap::mCamPos)
			.addProperty("mCamTarget", &rSkyMap::mCamTarget)
			.addProperty("mCamAttainPos", &rSkyMap::mCamAttainPos)
			.addProperty("mCamAttainTarget", &rSkyMap::mCamAttainTarget)
			.addProperty("mCamAngleDirec", &rSkyMap::mCamAngleDirec)
			.addProperty("mBefCamAngleDirec", &rSkyMap::mBefCamAngleDirec)
			.addProperty("mCamStartPos", &rSkyMap::mCamStartPos)
			.addProperty("mCamStartTarget", &rSkyMap::mCamStartTarget)
			.addProperty("mCamEndPos", &rSkyMap::mCamEndPos)
			.addProperty("mCamEndTarget", &rSkyMap::mCamEndTarget)
			.addProperty("mCamBaseHeight", &rSkyMap::mCamBaseHeight)
			.addProperty("mCamZoomRange", &rSkyMap::mCamZoomRange)
			.addProperty("mCamZoomRate", &rSkyMap::mCamZoomRate)
			.addProperty("mCamAngleRate", &rSkyMap::mCamAngleRate)
			.addProperty("mCamMoveLen", &rSkyMap::mCamMoveLen)
			.addProperty("mbCamMove", &rSkyMap::mbCamMove)
			.addProperty("mChangeHeight", &rSkyMap::mChangeHeight)
			.addProperty("mpBlur", &rSkyMap::mpBlur)
			.addProperty("mBlurScale", &rSkyMap::mBlurScale)
			.addProperty("mBlurRep", &rSkyMap::mBlurRep)
			.addProperty("mBlurAlpha", &rSkyMap::mBlurAlpha)
			.addProperty("mBlurRange", &rSkyMap::mBlurRange)
			.addProperty("mSelectMapID", &rSkyMap::mSelectMapID)
			.addProperty("mSelectNode", &rSkyMap::mSelectNode)
			.addProperty("mBefSelectNode", &rSkyMap::mBefSelectNode)
			.addProperty("mSelectIconNode", &rSkyMap::mSelectIconNode)
			.addProperty("mSelectWait", &rSkyMap::mSelectWait)
			.addProperty("mpMenu", &rSkyMap::mpMenu)
			.addProperty("mBokashiRez", &rSkyMap::mBokashiRez)
			.addProperty("mBokashiKosa", &rSkyMap::mBokashiKosa)
			.addProperty("mNoizeKosa", &rSkyMap::mNoizeKosa)
			.addProperty("mNoizeAnimWait", &rSkyMap::mNoizeAnimWait)
			.addProperty("mBokashi_R", &rSkyMap::mBokashi_R)
			.addProperty("mBokashi_G", &rSkyMap::mBokashi_G)
			.addProperty("mBokashi_B", &rSkyMap::mBokashi_B)
			.addProperty("mLoadWaitSE", &rSkyMap::mLoadWaitSE)
			.addProperty("mhSkyMapBgm", &rSkyMap::mhSkyMapBgm)
			.addProperty("mMarkScale", &rSkyMap::mMarkScale)
			.addProperty("mMarkSin", &rSkyMap::mMarkSin)
			.addFunction("GetSelectMapID", &rSkyMap::GetSelectMapID)
			.addFunction("GetState", &rSkyMap::GetState)
			.addFunction("GetSuperLowNode", &rSkyMap::GetSuperLowNode)
			.addFunction("GetMulColor", &rSkyMap::GetMulColor)
			.addFunction("SetCamAngleDirec", &rSkyMap::SetCamAngleDirec)
			.addFunction("AddNodeVisible", &rSkyMap::AddNodeVisible)
			.addFunction("ResetNoizeParam", &rSkyMap::ResetNoizeParam)
			.addFunction("SetSuperLowNoizeParam", &rSkyMap::SetSuperLowNoizeParam)
			.addFunction("SetState", &rSkyMap::SetState)
			.addFunction("AreaSelect", &rSkyMap::AreaSelect)
			.addFunction("MoveSky", &rSkyMap::MoveSky)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("MoveGround", &rSkyMap::MoveGround)
			.addFunction("IsEnter", &rSkyMap::IsEnter)
			.addFunction("Terminate", &rSkyMap::Terminate)
			.addFunction("Initialize", &rSkyMap::Initialize)
			.addFunction("FrameProc", &rSkyMap::FrameProc)
			.addFunction("RenderProc", &rSkyMap::RenderProc)
		.endClass();
	}
#endif
};
static_assert(sizeof(rSkyMap::field_0) == 4, "expected rSkyMap::field_0 to be size 4");
static_assert(sizeof(rSkyMap::mState) == 4, "expected rSkyMap::mState to be size 4");
static_assert(sizeof(rSkyMap::mpLowModel) == 4, "expected rSkyMap::mpLowModel to be size 4");
static_assert(sizeof(rSkyMap::mpLowNode) == 4, "expected rSkyMap::mpLowNode to be size 4");
static_assert(sizeof(rSkyMap::mpSuperLowNode) == 4, "expected rSkyMap::mpSuperLowNode to be size 4");
static_assert(sizeof(rSkyMap::mbHiModelLoad) == 1, "expected rSkyMap::mbHiModelLoad to be size 1");
static_assert(sizeof(rSkyMap::mChangeRate) == 4, "expected rSkyMap::mChangeRate to be size 4");
static_assert(sizeof(rSkyMap::mChangeSpeed) == 4, "expected rSkyMap::mChangeSpeed to be size 4");
static_assert(sizeof(rSkyMap::mCamPos) == 12, "expected rSkyMap::mCamPos to be size 12");
static_assert(sizeof(rSkyMap::mCamTarget) == 12, "expected rSkyMap::mCamTarget to be size 12");
static_assert(sizeof(rSkyMap::mCamAttainPos) == 12, "expected rSkyMap::mCamAttainPos to be size 12");
static_assert(sizeof(rSkyMap::mCamAttainTarget) == 12, "expected rSkyMap::mCamAttainTarget to be size 12");
static_assert(sizeof(rSkyMap::mCamAngleDirec) == 12, "expected rSkyMap::mCamAngleDirec to be size 12");
static_assert(sizeof(rSkyMap::mBefCamAngleDirec) == 12, "expected rSkyMap::mBefCamAngleDirec to be size 12");
static_assert(sizeof(rSkyMap::mCamStartPos) == 12, "expected rSkyMap::mCamStartPos to be size 12");
static_assert(sizeof(rSkyMap::mCamStartTarget) == 12, "expected rSkyMap::mCamStartTarget to be size 12");
static_assert(sizeof(rSkyMap::mCamEndPos) == 12, "expected rSkyMap::mCamEndPos to be size 12");
static_assert(sizeof(rSkyMap::mCamEndTarget) == 12, "expected rSkyMap::mCamEndTarget to be size 12");
static_assert(sizeof(rSkyMap::mCamBaseHeight) == 4, "expected rSkyMap::mCamBaseHeight to be size 4");
static_assert(sizeof(rSkyMap::mCamZoomRange) == 4, "expected rSkyMap::mCamZoomRange to be size 4");
static_assert(sizeof(rSkyMap::mCamZoomRate) == 4, "expected rSkyMap::mCamZoomRate to be size 4");
static_assert(sizeof(rSkyMap::mCamAngleRate) == 4, "expected rSkyMap::mCamAngleRate to be size 4");
static_assert(sizeof(rSkyMap::mCamMoveLen) == 4, "expected rSkyMap::mCamMoveLen to be size 4");
static_assert(sizeof(rSkyMap::mbCamMove) == 1, "expected rSkyMap::mbCamMove to be size 1");
static_assert(sizeof(rSkyMap::mChangeHeight) == 4, "expected rSkyMap::mChangeHeight to be size 4");
static_assert(sizeof(rSkyMap::mpBlur) == 4, "expected rSkyMap::mpBlur to be size 4");
static_assert(sizeof(rSkyMap::mBlurScale) == 4, "expected rSkyMap::mBlurScale to be size 4");
static_assert(sizeof(rSkyMap::mBlurRep) == 4, "expected rSkyMap::mBlurRep to be size 4");
static_assert(sizeof(rSkyMap::mBlurAlpha) == 4, "expected rSkyMap::mBlurAlpha to be size 4");
static_assert(sizeof(rSkyMap::mBlurRange) == 4, "expected rSkyMap::mBlurRange to be size 4");
static_assert(sizeof(rSkyMap::mSelectMapID) == 4, "expected rSkyMap::mSelectMapID to be size 4");
static_assert(sizeof(rSkyMap::mSelectNode) == 4, "expected rSkyMap::mSelectNode to be size 4");
static_assert(sizeof(rSkyMap::mBefSelectNode) == 4, "expected rSkyMap::mBefSelectNode to be size 4");
static_assert(sizeof(rSkyMap::mSelectIconNode) == 4, "expected rSkyMap::mSelectIconNode to be size 4");
static_assert(sizeof(rSkyMap::mSelectWait) == 4, "expected rSkyMap::mSelectWait to be size 4");
static_assert(sizeof(rSkyMap::mpMenu) == 4, "expected rSkyMap::mpMenu to be size 4");
static_assert(sizeof(rSkyMap::mBokashiRez) == 4, "expected rSkyMap::mBokashiRez to be size 4");
static_assert(sizeof(rSkyMap::mBokashiKosa) == 4, "expected rSkyMap::mBokashiKosa to be size 4");
static_assert(sizeof(rSkyMap::mNoizeKosa) == 4, "expected rSkyMap::mNoizeKosa to be size 4");
static_assert(sizeof(rSkyMap::mNoizeAnimWait) == 4, "expected rSkyMap::mNoizeAnimWait to be size 4");
static_assert(sizeof(rSkyMap::mBokashi_R) == 4, "expected rSkyMap::mBokashi_R to be size 4");
static_assert(sizeof(rSkyMap::mBokashi_G) == 4, "expected rSkyMap::mBokashi_G to be size 4");
static_assert(sizeof(rSkyMap::mBokashi_B) == 4, "expected rSkyMap::mBokashi_B to be size 4");
static_assert(sizeof(rSkyMap::mLoadWaitSE) == 4, "expected rSkyMap::mLoadWaitSE to be size 4");
static_assert(sizeof(rSkyMap::mhSkyMapBgm) == 4, "expected rSkyMap::mhSkyMapBgm to be size 4");
static_assert(sizeof(rSkyMap::mMarkScale) == 4, "expected rSkyMap::mMarkScale to be size 4");
static_assert(sizeof(rSkyMap::mMarkSin) == 4, "expected rSkyMap::mMarkSin to be size 4");
static_assert(sizeof(rSkyMap) == 0x10c, "expected rSkyMap to be size 0x10c");

// [Structure] class EffectSpeedBlur
class EffectSpeedBlur : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag = 0;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData_81[3];

public:
	// <float m_BlurValue, offset 0x54>
	float m_BlurValue = 0;

	// <float m_Scale, offset 0x58>
	float m_Scale = 0;

	// <int32_t m_RepNum, offset 0x5c>
	int32_t m_RepNum = 0;

	// <uint8_t m_Wait, offset 0x60>
	uint8_t m_Wait = 0;

	// <Unidentified data segment, offset 0x61>
private:
	char _UnidentifiedData_97[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectSpeedBlur [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectSpeedBlur& InObject)
	{
		m_Flag = InObject.m_Flag;
		m_BlurValue = InObject.m_BlurValue;
		m_Scale = InObject.m_Scale;
		m_RepNum = InObject.m_RepNum;
		m_Wait = InObject.m_Wait;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSpeedBlur, HrTask>("EffectSpeedBlur")
			.addFunction("__tostring", &EffectSpeedBlur::ToString)
			.addFunction("GetPtrAddr", &EffectSpeedBlur::GetPtrAddr)
			.addProperty("m_Flag", &EffectSpeedBlur::m_Flag)
			.addProperty("m_BlurValue", &EffectSpeedBlur::m_BlurValue)
			.addProperty("m_Scale", &EffectSpeedBlur::m_Scale)
			.addProperty("m_RepNum", &EffectSpeedBlur::m_RepNum)
			.addProperty("m_Wait", &EffectSpeedBlur::m_Wait)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSpeedBlur::m_Flag) == 1, "expected EffectSpeedBlur::m_Flag to be size 1");
static_assert(sizeof(EffectSpeedBlur::m_BlurValue) == 4, "expected EffectSpeedBlur::m_BlurValue to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_Scale) == 4, "expected EffectSpeedBlur::m_Scale to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_RepNum) == 4, "expected EffectSpeedBlur::m_RepNum to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_Wait) == 1, "expected EffectSpeedBlur::m_Wait to be size 1");
static_assert(sizeof(EffectSpeedBlur) == 0x64, "expected EffectSpeedBlur to be size 0x64");

// [Structure] class rSkyMapMenu
class rSkyMapMenu
{
public:
	// [Structure] struct rSkyMapMenu::ListParam
	struct ListParam
	{
	public:
		/// Struct member variables

		// <class TGmfNode* pNode, offset 0x0>
		class TGmfNode* pNode = nullptr;

		// <class TGmfNode* pIconNode, offset 0x4>
		class TGmfNode* pIconNode = nullptr;

		// <char ListName[0x40], offset 0x8>
		char ListName[64];

		// <int32_t MapID, offset 0x48>
		int32_t MapID = 0;

		/// 0 Functions

		/// Meta

		std::string GetName() const { return std::string(ListName); }
		void SetName(std::string InName) { strncpy_s(ListName, InName.c_str(), sizeof(ListName)); }
		std::string ToString() const { std::stringstream stream; stream << "struct rSkyMapMenu::ListParam (MapID: " << MapID << ", Name: " << GetName() << ") [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(rSkyMapMenu::ListParam& InObject)
		{
			pNode = InObject.pNode;
			pIconNode = InObject.pIconNode;
			MapID = InObject.MapID;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<ListParam>("rSkyMapMenu_ListParam")
				.addFunction("__tostring", &rSkyMapMenu::ListParam::ToString)
				.addFunction("GetPtrAddr", &rSkyMapMenu::ListParam::GetPtrAddr)
				.addProperty("pNode", &rSkyMapMenu::ListParam::pNode)
				.addProperty("pIconNode", &rSkyMapMenu::ListParam::pIconNode)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("ListName", &rSkyMapMenu::ListParam::ListName)
				.addProperty("MapID", &rSkyMapMenu::ListParam::MapID)
				.addFunction("GetName", &ListParam::GetName)
				.addFunction("SetName", &ListParam::SetName)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(rSkyMapMenu::ListParam::pNode) == 4, "expected rSkyMapMenu::ListParam::pNode to be size 4");
	static_assert(sizeof(rSkyMapMenu::ListParam::pIconNode) == 4, "expected rSkyMapMenu::ListParam::pIconNode to be size 4");
	static_assert(sizeof(rSkyMapMenu::ListParam::ListName) == 64, "expected rSkyMapMenu::ListParam::ListName to be size 64");
	static_assert(sizeof(rSkyMapMenu::ListParam::MapID) == 4, "expected rSkyMapMenu::ListParam::MapID to be size 4");
	static_assert(sizeof(rSkyMapMenu::ListParam) == 0x4c, "expected rSkyMapMenu::ListParam to be size 0x4c");

	// enum rSkyMapMenu::MenuState
	enum MenuState : uint32_t
	{
		// <State_Init = 0x0>
		State_Init = 0,

		// <State_FadeIn = 0x1>
		State_FadeIn = 1,

		// <State_Select = 0x2>
		State_Select = 2,

		// <State_FadeOut = 0x3>
		State_FadeOut = 3

	};

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[96];

public:
	// <uint32_t UnknownRenderConstant, offset 0x60>
	uint32_t UnknownRenderConstant = 0;

	// <Unidentified data segment, offset 0x64>
private:
	char _UnidentifiedData_100[1524];

public:
	// <uint32_t Initialized, offset 0x658>
	uint32_t Initialized = 0;

	// <Unidentified data segment, offset 0x65c>
private:
	char _UnidentifiedData_1628[2428];

public:
	// <class rSkyMap* SkyMap, offset 0xfd8>
	class rSkyMap* SkyMap = nullptr;

	// <uint32_t MenuState, offset 0xfdc>
	uint32_t MenuState = 0;

	// <Unidentified data segment, offset 0xfe0>
private:
	char _UnidentifiedData_4064[1200];

public:
	// <struct rSkyMapMenu::ListParam ListParameters[0x1e], offset 0x1490>
	struct rSkyMapMenu::ListParam ListParameters[30];

	// <Unidentified data segment, offset 0x1d78>
private:
	char _UnidentifiedData_7544[608];

public:
	// <int32_t ListItemNum, offset 0x1fd8>
	int32_t ListItemNum = 0;

	// <Unidentified data segment, offset 0x1fdc>
private:
	char _UnidentifiedData_8156[4];

public:
	// <int32_t UnknownHoverInt, offset 0x1fe0>
	int32_t UnknownHoverInt = 0;

	// <int32_t HoverID, offset 0x1fe4>
	int32_t HoverID = 0;

	// <Unidentified data segment, offset 0x1fe8>
private:
	char _UnidentifiedData_8168[136];

public:
	/// 17 Functions

	// [Function] void __convention("thiscall") rSkyMapMenu::SetSkyMap(class rSkyMapMenu* const this, class rSkyMap* SkyMap) [?SetSkyMap@rSkyMapMenu@@QAEXPAVrSkyMap@@@Z]
	typedef void(__thiscall* _SetSkyMap_rSkyMapMenu__QAEXPAVrSkyMap___Z)(class rSkyMapMenu* const thisPtr, class rSkyMap* SkyMap);
	void SetSkyMap(class rSkyMap* SkyMap)
	{
		_SetSkyMap_rSkyMapMenu__QAEXPAVrSkyMap___Z mFunc = (_SetSkyMap_rSkyMapMenu__QAEXPAVrSkyMap___Z)(GameModule + 0xaf2e0);
		return mFunc(this, SkyMap);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::onClickCallback(class rSkyMapMenu* const this, int32_t arg2) [?onClickCallback@rSkyMapMenu@@AAEXH@Z]
	typedef void(__thiscall* _onClickCallback_rSkyMapMenu__AAEXH_Z)(class rSkyMapMenu* const thisPtr, int32_t arg2);
	void onClickCallback(int32_t arg2)
	{
		_onClickCallback_rSkyMapMenu__AAEXH_Z mFunc = (_onClickCallback_rSkyMapMenu__AAEXH_Z)(GameModule + 0x4669d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::onHoverCallback(class rSkyMapMenu* const this, int32_t arg2) [?onHoverCallback@rSkyMapMenu@@AAEXH@Z]
	typedef void(__thiscall* _onHoverCallback_rSkyMapMenu__AAEXH_Z)(class rSkyMapMenu* const thisPtr, int32_t arg2);
	void onHoverCallback(int32_t arg2)
	{
		_onHoverCallback_rSkyMapMenu__AAEXH_Z mFunc = (_onHoverCallback_rSkyMapMenu__AAEXH_Z)(GameModule + 0x466a50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::InitMouseInteractions(class rSkyMapMenu* const this) [?InitMouseInteractions@rSkyMapMenu@@AAEXXZ]
	typedef void(__thiscall* _InitMouseInteractions_rSkyMapMenu__AAEXXZ)(class rSkyMapMenu* const thisPtr);
	void InitMouseInteractions()
	{
		_InitMouseInteractions_rSkyMapMenu__AAEXXZ mFunc = (_InitMouseInteractions_rSkyMapMenu__AAEXXZ)(GameModule + 0x466ad0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") rSkyMapMenu::GetFontData(class rSkyMapMenu* const this, char* arg2, struct GTEX_UVSET* arg3, enum GFONTTYPE_NUM arg4) [?GetFontData@rSkyMapMenu@@AAEHPADPAUGTEX_UVSET@@W4GFONTTYPE_NUM@@@Z]
	typedef int32_t(__thiscall* _GetFontData_rSkyMapMenu__AAEHPADPAUGTEX_UVSET__W4GFONTTYPE_NUM___Z)(class rSkyMapMenu* const thisPtr, char* arg2, struct GTEX_UVSET* arg3, enum GFONTTYPE_NUM arg4);
	int32_t GetFontData(std::string arg2, struct GTEX_UVSET* arg3, /* enum GFONTTYPE_NUM */ uint32_t arg4)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_GetFontData_rSkyMapMenu__AAEHPADPAUGTEX_UVSET__W4GFONTTYPE_NUM___Z mFunc = (_GetFontData_rSkyMapMenu__AAEHPADPAUGTEX_UVSET__W4GFONTTYPE_NUM___Z)(GameModule + 0x466dc0);
		return mFunc(this, &arg2_c_str[0], arg3, (enum GFONTTYPE_NUM)arg4);
	}
	// [Function] int32_t __convention("thiscall") rSkyMapMenu::DrawMes(class rSkyMapMenu* const this, float PosX, float PosY, char* mes, enum GFONTTYPE_NUM FontType, uint32_t color, float rate, uint8_t arg8, uint8_t arg9) [?DrawMes@rSkyMapMenu@@AAEHMMPADW4GFONTTYPE_NUM@@IM_N2@Z]
	typedef int32_t(__thiscall* _DrawMes_rSkyMapMenu__AAEHMMPADW4GFONTTYPE_NUM__IM_N2_Z)(class rSkyMapMenu* const thisPtr, float PosX, float PosY, char* mes, enum GFONTTYPE_NUM FontType, uint32_t color, float rate, uint8_t arg8, uint8_t arg9);
	int32_t DrawMes(float PosX, float PosY, std::string mes, /* enum GFONTTYPE_NUM */ uint32_t FontType, uint32_t color, float rate, uint8_t arg8, uint8_t arg9)
	{
		std::vector<char> mes_c_str(mes.c_str(), + mes.c_str() + mes.size() + 1);
		_DrawMes_rSkyMapMenu__AAEHMMPADW4GFONTTYPE_NUM__IM_N2_Z mFunc = (_DrawMes_rSkyMapMenu__AAEHMMPADW4GFONTTYPE_NUM__IM_N2_Z)(GameModule + 0x466e60);
		return mFunc(this, PosX, PosY, &mes_c_str[0], (enum GFONTTYPE_NUM)FontType, color, rate, arg8, arg9);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::SetPolaroid(class rSkyMapMenu* const this) [?SetPolaroid@rSkyMapMenu@@AAEXXZ]
	typedef void(__thiscall* _SetPolaroid_rSkyMapMenu__AAEXXZ)(class rSkyMapMenu* const thisPtr);
	void SetPolaroid()
	{
		_SetPolaroid_rSkyMapMenu__AAEXXZ mFunc = (_SetPolaroid_rSkyMapMenu__AAEXXZ)(GameModule + 0x467200);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::ListCreate(class rSkyMapMenu* const this) [?ListCreate@rSkyMapMenu@@AAEXXZ]
	typedef void(__thiscall* _ListCreate_rSkyMapMenu__AAEXXZ)(class rSkyMapMenu* const thisPtr);
	void ListCreate()
	{
		_ListCreate_rSkyMapMenu__AAEXXZ mFunc = (_ListCreate_rSkyMapMenu__AAEXXZ)(GameModule + 0x4672a0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") rSkyMapMenu::GetSelectMapID(class rSkyMapMenu* const this) [?GetSelectMapID@rSkyMapMenu@@QAEHXZ]
	typedef int32_t(__thiscall* _GetSelectMapID_rSkyMapMenu__QAEHXZ)(class rSkyMapMenu* const thisPtr);
	int32_t GetSelectMapID()
	{
		_GetSelectMapID_rSkyMapMenu__QAEHXZ mFunc = (_GetSelectMapID_rSkyMapMenu__QAEHXZ)(GameModule + 0x467630);
		return mFunc(this);
	}
	// [Function] class TGmfNode* __convention("thiscall") rSkyMapMenu::GetSelectIconNode(class rSkyMapMenu* const this) [?GetSelectIconNode@rSkyMapMenu@@QAEPAVTGmfNode@@XZ]
	typedef class TGmfNode*(__thiscall* _GetSelectIconNode_rSkyMapMenu__QAEPAVTGmfNode__XZ)(class rSkyMapMenu* const thisPtr);
	class TGmfNode* GetSelectIconNode()
	{
		_GetSelectIconNode_rSkyMapMenu__QAEPAVTGmfNode__XZ mFunc = (_GetSelectIconNode_rSkyMapMenu__QAEPAVTGmfNode__XZ)(GameModule + 0x467640);
		return mFunc(this);
	}
	// [Function] class TGmfNode* __convention("thiscall") rSkyMapMenu::GetSelectNode(class rSkyMapMenu* const this) [?GetSelectNode@rSkyMapMenu@@QAEPAVTGmfNode@@XZ]
	typedef class TGmfNode*(__thiscall* _GetSelectNode_rSkyMapMenu__QAEPAVTGmfNode__XZ)(class rSkyMapMenu* const thisPtr);
	class TGmfNode* GetSelectNode()
	{
		_GetSelectNode_rSkyMapMenu__QAEPAVTGmfNode__XZ mFunc = (_GetSelectNode_rSkyMapMenu__QAEPAVTGmfNode__XZ)(GameModule + 0x467660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::SetState(class rSkyMapMenu* const this, enum rSkyMapMenu::MenuState arg2) [?SetState@rSkyMapMenu@@QAEXW4MenuState@1@@Z]
	typedef void(__thiscall* _SetState_rSkyMapMenu__QAEXW4MenuState_1__Z)(class rSkyMapMenu* const thisPtr, enum rSkyMapMenu::MenuState arg2);
	void SetState(/* enum rSkyMapMenu::MenuState */ uint32_t arg2)
	{
		_SetState_rSkyMapMenu__QAEXW4MenuState_1__Z mFunc = (_SetState_rSkyMapMenu__QAEXW4MenuState_1__Z)(GameModule + 0x467670);
		return mFunc(this, (enum rSkyMapMenu::MenuState)arg2);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::RenderProcess(class rSkyMapMenu* const this) [?RenderProcess@rSkyMapMenu@@EAEXXZ]
	typedef void(__thiscall* _RenderProcess_rSkyMapMenu__EAEXXZ)(class rSkyMapMenu* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_rSkyMapMenu__EAEXXZ mFunc = (_RenderProcess_rSkyMapMenu__EAEXXZ)(GameModule + 0x467730);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::FrameProcess(class rSkyMapMenu* const this) [?FrameProcess@rSkyMapMenu@@EAEXXZ]
	typedef void(__thiscall* _FrameProcess_rSkyMapMenu__EAEXXZ)(class rSkyMapMenu* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_rSkyMapMenu__EAEXXZ mFunc = (_FrameProcess_rSkyMapMenu__EAEXXZ)(GameModule + 0x467b70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") rSkyMapMenu::Terminate(class rSkyMapMenu* const this) [?Terminate@rSkyMapMenu@@EAEXXZ]
	typedef void(__thiscall* _Terminate_rSkyMapMenu__EAEXXZ)(class rSkyMapMenu* const thisPtr);
	void Terminate()
	{
		_Terminate_rSkyMapMenu__EAEXXZ mFunc = (_Terminate_rSkyMapMenu__EAEXXZ)(GameModule + 0x468000);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") rSkyMapMenu::Initialize(class rSkyMapMenu* const this) [?Initialize@rSkyMapMenu@@AAE_NXZ]
	typedef uint8_t(__thiscall* _Initialize_rSkyMapMenu__AAE_NXZ)(class rSkyMapMenu* const thisPtr);
	uint8_t Initialize()
	{
		_Initialize_rSkyMapMenu__AAE_NXZ mFunc = (_Initialize_rSkyMapMenu__AAE_NXZ)(GameModule + 0x4681a0);
		return mFunc(this);
	}
	// [Function] class rSkyMapMenu* rSkyMapMenu::Create() [?Create@rSkyMapMenu@@SAPAV1@XZ]
	typedef class rSkyMapMenu*(__fastcall* _Create_rSkyMapMenu__SAPAV1_XZ)();
	static class rSkyMapMenu* Create()
	{
		_Create_rSkyMapMenu__SAPAV1_XZ mFunc = (_Create_rSkyMapMenu__SAPAV1_XZ)(GameModule + 0x4688b0);
		return mFunc();
	}
	/// Meta

	rSkyMapMenu::ListParam GetListParam(uint32_t Index) { return ListParameters[std::min<uint32_t>(Index, ListItemNum-1)]; }
	void SetListParam(uint32_t Index, rSkyMapMenu::ListParam InParam) { ListParameters[std::min<uint32_t>(Index, 29)] = InParam; }
	std::string ToString() const { std::stringstream stream; stream << "class rSkyMapMenu (" << ListItemNum << " list items) [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rSkyMapMenu& InObject)
	{
		UnknownRenderConstant = InObject.UnknownRenderConstant;
		Initialized = InObject.Initialized;
		SkyMap = InObject.SkyMap;
		MenuState = InObject.MenuState;
		ListItemNum = InObject.ListItemNum;
		UnknownHoverInt = InObject.UnknownHoverInt;
		HoverID = InObject.HoverID;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rSkyMapMenu>("rSkyMapMenu")
			.addFunction("__tostring", &rSkyMapMenu::ToString)
			.addFunction("GetPtrAddr", &rSkyMapMenu::GetPtrAddr)
			.addProperty("UnknownRenderConstant", &rSkyMapMenu::UnknownRenderConstant)
			.addProperty("Initialized", &rSkyMapMenu::Initialized)
			.addProperty("SkyMap", &rSkyMapMenu::SkyMap)
			.addProperty("MenuState", &rSkyMapMenu::MenuState)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("ListParameters", &rSkyMapMenu::ListParameters)
			.addProperty("ListItemNum", &rSkyMapMenu::ListItemNum)
			.addProperty("UnknownHoverInt", &rSkyMapMenu::UnknownHoverInt)
			.addProperty("HoverID", &rSkyMapMenu::HoverID)
			.addFunction("SetSkyMap", &rSkyMapMenu::SetSkyMap)
			.addFunction("onClickCallback", &rSkyMapMenu::onClickCallback)
			.addFunction("onHoverCallback", &rSkyMapMenu::onHoverCallback)
			.addFunction("InitMouseInteractions", &rSkyMapMenu::InitMouseInteractions)
			.addFunction("GetFontData", &rSkyMapMenu::GetFontData)
			.addFunction("DrawMes", &rSkyMapMenu::DrawMes)
			.addFunction("SetPolaroid", &rSkyMapMenu::SetPolaroid)
			.addFunction("ListCreate", &rSkyMapMenu::ListCreate)
			.addFunction("GetSelectMapID", &rSkyMapMenu::GetSelectMapID)
			.addFunction("GetSelectIconNode", &rSkyMapMenu::GetSelectIconNode)
			.addFunction("GetSelectNode", &rSkyMapMenu::GetSelectNode)
			.addFunction("SetState", &rSkyMapMenu::SetState)
			.addFunction("RenderProcess", &rSkyMapMenu::RenderProcess)
			.addFunction("FrameProcess", &rSkyMapMenu::FrameProcess)
			.addFunction("Terminate", &rSkyMapMenu::Terminate)
			.addFunction("Initialize", &rSkyMapMenu::Initialize)
			.addStaticFunction("Create", &rSkyMapMenu::Create)
			.addFunction("GetListParam", &rSkyMapMenu::GetListParam)
			.addFunction("SetListParam", &rSkyMapMenu::SetListParam)
		.endClass();
	}
#endif
};
static_assert(sizeof(rSkyMapMenu::UnknownRenderConstant) == 4, "expected rSkyMapMenu::UnknownRenderConstant to be size 4");
static_assert(sizeof(rSkyMapMenu::Initialized) == 4, "expected rSkyMapMenu::Initialized to be size 4");
static_assert(sizeof(rSkyMapMenu::SkyMap) == 4, "expected rSkyMapMenu::SkyMap to be size 4");
static_assert(sizeof(rSkyMapMenu::MenuState) == 4, "expected rSkyMapMenu::MenuState to be size 4");
static_assert(sizeof(rSkyMapMenu::ListParameters) == 2280, "expected rSkyMapMenu::ListParameters to be size 2280");
static_assert(sizeof(rSkyMapMenu::ListItemNum) == 4, "expected rSkyMapMenu::ListItemNum to be size 4");
static_assert(sizeof(rSkyMapMenu::UnknownHoverInt) == 4, "expected rSkyMapMenu::UnknownHoverInt to be size 4");
static_assert(sizeof(rSkyMapMenu::HoverID) == 4, "expected rSkyMapMenu::HoverID to be size 4");
static_assert(sizeof(rSkyMapMenu) == 0x2070, "expected rSkyMapMenu to be size 0x2070");

// [Structure] class HrStageDraw
class HrStageDraw
{
public:
	// [Structure] struct HrStageDraw::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData_0[20728];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct HrStageDraw::MAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(HrStageDraw::MAIN& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MAIN>("HrStageDraw_MAIN")
				.addFunction("__tostring", &HrStageDraw::MAIN::ToString)
				.addFunction("GetPtrAddr", &HrStageDraw::MAIN::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrStageDraw::MAIN) == 0x50f8, "expected HrStageDraw::MAIN to be size 0x50f8");

	// [Structure] struct HrStageDraw::AREA
	struct AREA
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData_0[388];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct HrStageDraw::AREA [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(HrStageDraw::AREA& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<AREA>("HrStageDraw_AREA")
				.addFunction("__tostring", &HrStageDraw::AREA::ToString)
				.addFunction("GetPtrAddr", &HrStageDraw::AREA::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrStageDraw::AREA) == 0x184, "expected HrStageDraw::AREA to be size 0x184");

	/// Struct member variables

	// <void* pAreaBuffer, offset 0x0>
	void* pAreaBuffer = nullptr;

	// <Unidentified data segment, offset 0x4>
private:
	char _UnidentifiedData_4[4];

public:
	// <struct HrStageDraw::MAIN dat, offset 0x8>
	struct HrStageDraw::MAIN dat;

	/// 40 Functions

	// [Function] class TGmf* __convention("thiscall") HrStageDraw::GetGmf(class HrStageDraw* const this) [?GetGmf@HrStageDraw@@QAEPAVTGmf@@XZ]
	typedef class TGmf*(__thiscall* _GetGmf_HrStageDraw__QAEPAVTGmf__XZ)(class HrStageDraw* const thisPtr);
	class TGmf* GetGmf()
	{
		_GetGmf_HrStageDraw__QAEPAVTGmf__XZ mFunc = (_GetGmf_HrStageDraw__QAEPAVTGmf__XZ)(GameModule + 0x9dd00);
		return mFunc(this);
	}
	// [Function] class WGcl* __convention("thiscall") HrStageDraw::GetGcl(class HrStageDraw* const this) [?GetGcl@HrStageDraw@@QAEPAVWGcl@@XZ]
	typedef class WGcl*(__thiscall* _GetGcl_HrStageDraw__QAEPAVWGcl__XZ)(class HrStageDraw* const thisPtr);
	class WGcl* GetGcl()
	{
		_GetGcl_HrStageDraw__QAEPAVWGcl__XZ mFunc = (_GetGcl_HrStageDraw__QAEPAVWGcl__XZ)(GameModule + 0xa2eb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrStageDraw::IsGcl(class HrStageDraw* const this) [?IsGcl@HrStageDraw@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsGcl_HrStageDraw__QAE_NXZ)(class HrStageDraw* const thisPtr);
	uint8_t IsGcl()
	{
		_IsGcl_HrStageDraw__QAE_NXZ mFunc = (_IsGcl_HrStageDraw__QAE_NXZ)(GameModule + 0xa2ec0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") HrStageDraw::GetDrawOrderType(class HrStageDraw* const this) [?GetDrawOrderType@HrStageDraw@@QAEHXZ]
	typedef int32_t(__thiscall* _GetDrawOrderType_HrStageDraw__QAEHXZ)(class HrStageDraw* const thisPtr);
	int32_t GetDrawOrderType()
	{
		_GetDrawOrderType_HrStageDraw__QAEHXZ mFunc = (_GetDrawOrderType_HrStageDraw__QAEHXZ)(GameModule + 0xa3ab0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrStageDraw::SetClipCheckPos(class HrStageDraw* const this, struct Vec& arg2) [?SetClipCheckPos@HrStageDraw@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _SetClipCheckPos_HrStageDraw__QAEXABUVec___Z)(class HrStageDraw* const thisPtr, struct Vec& arg2);
	void SetClipCheckPos(struct Vec& arg2)
	{
		_SetClipCheckPos_HrStageDraw__QAEXABUVec___Z mFunc = (_SetClipCheckPos_HrStageDraw__QAEXABUVec___Z)(GameModule + 0xa9b40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrStageDraw::SetLoadAreaPos(class HrStageDraw* const this, uint8_t arg2, struct Vec& arg3, struct Vec& arg4) [?SetLoadAreaPos@HrStageDraw@@QAEX_NABUVec@@1@Z]
	typedef void(__thiscall* _SetLoadAreaPos_HrStageDraw__QAEX_NABUVec__1_Z)(class HrStageDraw* const thisPtr, uint8_t arg2, struct Vec& arg3, struct Vec& arg4);
	void SetLoadAreaPos(uint8_t arg2, struct Vec& arg3, struct Vec& arg4)
	{
		_SetLoadAreaPos_HrStageDraw__QAEX_NABUVec__1_Z mFunc = (_SetLoadAreaPos_HrStageDraw__QAEX_NABUVec__1_Z)(GameModule + 0xaf950);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") HrStageDraw::setCollisionValidFlag(class HrStageDraw* const this, uint8_t const arg2, uint8_t const arg3) [?setCollisionValidFlag@HrStageDraw@@QAEX_N0@Z]
	typedef void(__thiscall* _setCollisionValidFlag_HrStageDraw__QAEX_N0_Z)(class HrStageDraw* const thisPtr, uint8_t const arg2, uint8_t const arg3);
	void setCollisionValidFlag(uint8_t const arg2, uint8_t const arg3)
	{
		_setCollisionValidFlag_HrStageDraw__QAEX_N0_Z mFunc = (_setCollisionValidFlag_HrStageDraw__QAEX_N0_Z)(GameModule + 0x416290);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") HrStageDraw::GetLoadCompleteAreaNum(class HrStageDraw* const this) [?GetLoadCompleteAreaNum@HrStageDraw@@QBEHXZ]
	typedef int32_t(__thiscall* _GetLoadCompleteAreaNum_HrStageDraw__QBEHXZ)(class HrStageDraw* const thisPtr);
	int32_t GetLoadCompleteAreaNum()
	{
		_GetLoadCompleteAreaNum_HrStageDraw__QBEHXZ mFunc = (_GetLoadCompleteAreaNum_HrStageDraw__QBEHXZ)(GameModule + 0x416440);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrStageDraw::prReleaseArea(class HrStageDraw* const this, struct HrStageDraw::AREA* arg2) [?prReleaseArea@HrStageDraw@@IAEXPAUAREA@1@@Z]
	typedef void(__thiscall* _prReleaseArea_HrStageDraw__IAEXPAUAREA_1__Z)(class HrStageDraw* const thisPtr, struct HrStageDraw::AREA* arg2);
	void prReleaseArea(struct HrStageDraw::AREA* arg2)
	{
		_prReleaseArea_HrStageDraw__IAEXPAUAREA_1__Z mFunc = (_prReleaseArea_HrStageDraw__IAEXPAUAREA_1__Z)(GameModule + 0x416490);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrStageDraw::AreaNodeVisibleRefresh(class HrStageDraw* const this, int32_t arg2) [?AreaNodeVisibleRefresh@HrStageDraw@@IAEXH@Z]
	typedef void(__thiscall* _AreaNodeVisibleRefresh_HrStageDraw__IAEXH_Z)(class HrStageDraw* const thisPtr, int32_t arg2);
	void AreaNodeVisibleRefresh(int32_t arg2)
	{
		_AreaNodeVisibleRefresh_HrStageDraw__IAEXH_Z mFunc = (_AreaNodeVisibleRefresh_HrStageDraw__IAEXH_Z)(GameModule + 0x4166a0);
		return mFunc(this, arg2);
	}
	// [Function] void HrStageDraw::AreaSelectDraw(void* arg1) [?AreaSelectDraw@HrStageDraw@@KAXPAX@Z]
	typedef void(__fastcall* _AreaSelectDraw_HrStageDraw__KAXPAX_Z)(void* arg1);
	static void AreaSelectDraw(void* arg1)
	{
		_AreaSelectDraw_HrStageDraw__KAXPAX_Z mFunc = (_AreaSelectDraw_HrStageDraw__KAXPAX_Z)(GameModule + 0x416780);
		return mFunc(arg1);
	}
	// [Function] void HrStageDraw::SetAmbLight(int32_t arg1, uint8_t arg2, uint32_t arg3) [?SetAmbLight@HrStageDraw@@SAXH_NI@Z]
	typedef void(__fastcall* _SetAmbLight_HrStageDraw__SAXH_NI_Z)(int32_t arg1, uint8_t arg2, uint32_t arg3);
	static void SetAmbLight(int32_t arg1, uint8_t arg2, uint32_t arg3)
	{
		_SetAmbLight_HrStageDraw__SAXH_NI_Z mFunc = (_SetAmbLight_HrStageDraw__SAXH_NI_Z)(GameModule + 0x416790);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] void HrStageDraw::SetToonModelMulColor(int32_t arg1, uint8_t arg2, uint32_t arg3) [?SetToonModelMulColor@HrStageDraw@@SAXH_NI@Z]
	typedef void(__fastcall* _SetToonModelMulColor_HrStageDraw__SAXH_NI_Z)(int32_t arg1, uint8_t arg2, uint32_t arg3);
	static void SetToonModelMulColor(int32_t arg1, uint8_t arg2, uint32_t arg3)
	{
		_SetToonModelMulColor_HrStageDraw__SAXH_NI_Z mFunc = (_SetToonModelMulColor_HrStageDraw__SAXH_NI_Z)(GameModule + 0x4167b0);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrStageDraw::DrawColl(class HrStageDraw* const this) [?DrawColl@HrStageDraw@@QAEXXZ]
	typedef void(__thiscall* _DrawColl_HrStageDraw__QAEXXZ)(class HrStageDraw* const thisPtr);
	void DrawColl()
	{
		_DrawColl_HrStageDraw__QAEXXZ mFunc = (_DrawColl_HrStageDraw__QAEXXZ)(GameModule + 0x4167d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrStageDraw::ClipNodeColision(class HrStageDraw* const this) [?ClipNodeColision@HrStageDraw@@QAEXXZ]
	typedef void(__thiscall* _ClipNodeColision_HrStageDraw__QAEXXZ)(class HrStageDraw* const thisPtr);
	void ClipNodeColision()
	{
		_ClipNodeColision_HrStageDraw__QAEXXZ mFunc = (_ClipNodeColision_HrStageDraw__QAEXXZ)(GameModule + 0x4167e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrStageDraw::SetBikeCollisionEnable(class HrStageDraw* const this, int32_t arg2, uint8_t arg3) [?SetBikeCollisionEnable@HrStageDraw@@QAEXH_N@Z]
	typedef void(__thiscall* _SetBikeCollisionEnable_HrStageDraw__QAEXH_N_Z)(class HrStageDraw* const thisPtr, int32_t arg2, uint8_t arg3);
	void SetBikeCollisionEnable(int32_t arg2, uint8_t arg3)
	{
		_SetBikeCollisionEnable_HrStageDraw__QAEXH_N_Z mFunc = (_SetBikeCollisionEnable_HrStageDraw__QAEXH_N_Z)(GameModule + 0x416b40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrStageDraw::SetAreaBikeCollisionEnable(class HrStageDraw* const this, uint8_t arg2) [?SetAreaBikeCollisionEnable@HrStageDraw@@QAEX_N@Z]
	typedef void(__thiscall* _SetAreaBikeCollisionEnable_HrStageDraw__QAEX_N_Z)(class HrStageDraw* const thisPtr, uint8_t arg2);
	void SetAreaBikeCollisionEnable(uint8_t arg2)
	{
		_SetAreaBikeCollisionEnable_HrStageDraw__QAEX_N_Z mFunc = (_SetAreaBikeCollisionEnable_HrStageDraw__QAEX_N_Z)(GameModule + 0x416b90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrStageDraw::initVertexAnimation(class HrStageDraw* const this, class TGmf* arg2, uint8_t const arg3) [?initVertexAnimation@HrStageDraw@@AAEXPAVTGmf@@_N@Z]
	typedef void(__thiscall* _initVertexAnimation_HrStageDraw__AAEXPAVTGmf___N_Z)(class HrStageDraw* const thisPtr, class TGmf* arg2, uint8_t const arg3);
	void initVertexAnimation(class TGmf* arg2, uint8_t const arg3)
	{
		_initVertexAnimation_HrStageDraw__AAEXPAVTGmf___N_Z mFunc = (_initVertexAnimation_HrStageDraw__AAEXPAVTGmf___N_Z)(GameModule + 0x416bf0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrStageDraw::AddNodeMotion(class HrStageDraw* const this, class TGan* arg2) [?AddNodeMotion@HrStageDraw@@QAEXPAVTGan@@@Z]
	typedef void(__thiscall* _AddNodeMotion_HrStageDraw__QAEXPAVTGan___Z)(class HrStageDraw* const thisPtr, class TGan* arg2);
	void AddNodeMotion(class TGan* arg2)
	{
		_AddNodeMotion_HrStageDraw__QAEXPAVTGan___Z mFunc = (_AddNodeMotion_HrStageDraw__QAEXPAVTGan___Z)(GameModule + 0x4170a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrStageDraw::AddNodeModel(class HrStageDraw* const this, class TGmf* arg2, char const* arg3) [?AddNodeModel@HrStageDraw@@QAEXPAVTGmf@@PBD@Z]
	typedef void(__thiscall* _AddNodeModel_HrStageDraw__QAEXPAVTGmf__PBD_Z)(class HrStageDraw* const thisPtr, class TGmf* arg2, char const* arg3);
	void AddNodeModel(class TGmf* arg2, std::string arg3)
	{
		char const* arg3_c_str = arg3.c_str();
		_AddNodeModel_HrStageDraw__QAEXPAVTGmf__PBD_Z mFunc = (_AddNodeModel_HrStageDraw__QAEXPAVTGmf__PBD_Z)(GameModule + 0x4170d0);
		return mFunc(this, arg2, arg3_c_str);
	}
	// [Function] void __convention("thiscall") HrStageDraw::LightSetup(class HrStageDraw* const this) [?LightSetup@HrStageDraw@@QAEXXZ]
	typedef void(__thiscall* _LightSetup_HrStageDraw__QAEXXZ)(class HrStageDraw* const thisPtr);
	void LightSetup()
	{
		_LightSetup_HrStageDraw__QAEXXZ mFunc = (_LightSetup_HrStageDraw__QAEXXZ)(GameModule + 0x417130);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrStageDraw::AreaAllRelease(class HrStageDraw* const this) [?AreaAllRelease@HrStageDraw@@QAEXXZ]
	typedef void(__thiscall* _AreaAllRelease_HrStageDraw__QAEXXZ)(class HrStageDraw* const thisPtr);
	void AreaAllRelease()
	{
		_AreaAllRelease_HrStageDraw__QAEXXZ mFunc = (_AreaAllRelease_HrStageDraw__QAEXXZ)(GameModule + 0x417240);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrStageDraw::IsAreaLoading(class HrStageDraw* const this) [?IsAreaLoading@HrStageDraw@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsAreaLoading_HrStageDraw__QAE_NXZ)(class HrStageDraw* const thisPtr);
	uint8_t IsAreaLoading()
	{
		_IsAreaLoading_HrStageDraw__QAE_NXZ mFunc = (_IsAreaLoading_HrStageDraw__QAE_NXZ)(GameModule + 0x417250);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrStageDraw::IsDoneLoading(class HrStageDraw* const this) [?IsDoneLoading@HrStageDraw@@QBE_NXZ]
	typedef uint8_t(__thiscall* _IsDoneLoading_HrStageDraw__QBE_NXZ)(class HrStageDraw* const thisPtr);
	uint8_t IsDoneLoading()
	{
		_IsDoneLoading_HrStageDraw__QBE_NXZ mFunc = (_IsDoneLoading_HrStageDraw__QBE_NXZ)(GameModule + 0x4172a0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") HrStageDraw::GetAreaNumberToPos(class HrStageDraw* const this, struct Vec* arg2) [?GetAreaNumberToPos@HrStageDraw@@QAEHPAUVec@@@Z]
	typedef int32_t(__thiscall* _GetAreaNumberToPos_HrStageDraw__QAEHPAUVec___Z)(class HrStageDraw* const thisPtr, struct Vec* arg2);
	int32_t GetAreaNumberToPos(struct Vec* arg2)
	{
		_GetAreaNumberToPos_HrStageDraw__QAEHPAUVec___Z mFunc = (_GetAreaNumberToPos_HrStageDraw__QAEHPAUVec___Z)(GameModule + 0x4172f0);
		return mFunc(this, arg2);
	}
	// [Function] class WGcl* __convention("thiscall") HrStageDraw::GetHiModelGclToPos(class HrStageDraw* const this, struct Vec* arg2) [?GetHiModelGclToPos@HrStageDraw@@QAEPAVWGcl@@PAUVec@@@Z]
	typedef class WGcl*(__thiscall* _GetHiModelGclToPos_HrStageDraw__QAEPAVWGcl__PAUVec___Z)(class HrStageDraw* const thisPtr, struct Vec* arg2);
	class WGcl* GetHiModelGclToPos(struct Vec* arg2)
	{
		_GetHiModelGclToPos_HrStageDraw__QAEPAVWGcl__PAUVec___Z mFunc = (_GetHiModelGclToPos_HrStageDraw__QAEPAVWGcl__PAUVec___Z)(GameModule + 0x417360);
		return mFunc(this, arg2);
	}
	// [Function] class TGmf* __convention("thiscall") HrStageDraw::GetNodeModel(class HrStageDraw* const this, char const* arg2) [?GetNodeModel@HrStageDraw@@QAEPAVTGmf@@PBD@Z]
	typedef class TGmf*(__thiscall* _GetNodeModel_HrStageDraw__QAEPAVTGmf__PBD_Z)(class HrStageDraw* const thisPtr, char const* arg2);
	class TGmf* GetNodeModel(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetNodeModel_HrStageDraw__QAEPAVTGmf__PBD_Z mFunc = (_GetNodeModel_HrStageDraw__QAEPAVTGmf__PBD_Z)(GameModule + 0x4173e0);
		return mFunc(this, arg2_c_str);
	}
	// [Function] void __convention("thiscall") HrStageDraw::SetAreaNodeVisible(class HrStageDraw* const this, int32_t arg2, char const* arg3, uint8_t arg4) [?SetAreaNodeVisible@HrStageDraw@@QAEXHPBD_N@Z]
	typedef void(__thiscall* _SetAreaNodeVisible_HrStageDraw__QAEXHPBD_N_Z)(class HrStageDraw* const thisPtr, int32_t arg2, char const* arg3, uint8_t arg4);
	void SetAreaNodeVisible(int32_t arg2, std::string arg3, uint8_t arg4)
	{
		char const* arg3_c_str = arg3.c_str();
		_SetAreaNodeVisible_HrStageDraw__QAEXHPBD_N_Z mFunc = (_SetAreaNodeVisible_HrStageDraw__QAEXHPBD_N_Z)(GameModule + 0x417450);
		return mFunc(this, arg2, arg3_c_str, arg4);
	}
	// [Function] void HrStageDraw::SetToonModelMulColorValidFlag(int32_t arg1, uint8_t arg2) [?SetToonModelMulColorValidFlag@HrStageDraw@@SAXH_N@Z]
	typedef void(__fastcall* _SetToonModelMulColorValidFlag_HrStageDraw__SAXH_N_Z)(int32_t arg1, uint8_t arg2);
	static void SetToonModelMulColorValidFlag(int32_t arg1, uint8_t arg2)
	{
		_SetToonModelMulColorValidFlag_HrStageDraw__SAXH_N_Z mFunc = (_SetToonModelMulColorValidFlag_HrStageDraw__SAXH_N_Z)(GameModule + 0x417610);
		return mFunc(arg1, arg2);
	}
	// [Function] void HrStageDraw::SetAmbLightValidFlag(int32_t arg1, uint8_t arg2) [?SetAmbLightValidFlag@HrStageDraw@@SAXH_N@Z]
	typedef void(__fastcall* _SetAmbLightValidFlag_HrStageDraw__SAXH_N_Z)(int32_t arg1, uint8_t arg2);
	static void SetAmbLightValidFlag(int32_t arg1, uint8_t arg2)
	{
		_SetAmbLightValidFlag_HrStageDraw__SAXH_N_Z mFunc = (_SetAmbLightValidFlag_HrStageDraw__SAXH_N_Z)(GameModule + 0x417620);
		return mFunc(arg1, arg2);
	}
	// [Function] void HrStageDraw::GetLight(uint32_t arg1, int32_t arg2, struct TGMFLIGHT* arg3) [?GetLight@HrStageDraw@@SAXIHPAUTGMFLIGHT@@@Z]
	typedef void(__fastcall* _GetLight_HrStageDraw__SAXIHPAUTGMFLIGHT___Z)(uint32_t arg1, int32_t arg2, struct TGMFLIGHT* arg3);
	static void GetLight(uint32_t arg1, int32_t arg2, struct TGMFLIGHT* arg3)
	{
		_GetLight_HrStageDraw__SAXIHPAUTGMFLIGHT___Z mFunc = (_GetLight_HrStageDraw__SAXIHPAUTGMFLIGHT___Z)(GameModule + 0x417630);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] void HrStageDraw::SetLight(uint32_t arg1, int32_t arg2, struct TGMFLIGHT* arg3) [?SetLight@HrStageDraw@@SAXIHPAUTGMFLIGHT@@@Z]
	typedef void(__fastcall* _SetLight_HrStageDraw__SAXIHPAUTGMFLIGHT___Z)(uint32_t arg1, int32_t arg2, struct TGMFLIGHT* arg3);
	static void SetLight(uint32_t arg1, int32_t arg2, struct TGMFLIGHT* arg3)
	{
		_SetLight_HrStageDraw__SAXIHPAUTGMFLIGHT___Z mFunc = (_SetLight_HrStageDraw__SAXIHPAUTGMFLIGHT___Z)(GameModule + 0x417680);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrStageDraw::RefreshLight(class HrStageDraw* const this) [?RefreshLight@HrStageDraw@@QAEXXZ]
	typedef void(__thiscall* _RefreshLight_HrStageDraw__QAEXXZ)(class HrStageDraw* const thisPtr);
	void RefreshLight()
	{
		_RefreshLight_HrStageDraw__QAEXXZ mFunc = (_RefreshLight_HrStageDraw__QAEXXZ)(GameModule + 0x4176d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrStageDraw::Terminate(class HrStageDraw* const this) [?Terminate@HrStageDraw@@QAE_NXZ]
	typedef uint8_t(__thiscall* _Terminate_HrStageDraw__QAE_NXZ)(class HrStageDraw* const thisPtr);
	uint8_t Terminate()
	{
		_Terminate_HrStageDraw__QAE_NXZ mFunc = (_Terminate_HrStageDraw__QAE_NXZ)(GameModule + 0x417aa0);
		return mFunc(this);
	}
	// [Function] void HrStageDraw::ReadParam2(void* arg1) [?ReadParam2@HrStageDraw@@SAXPAX@Z]
	typedef void(__fastcall* _ReadParam2_HrStageDraw__SAXPAX_Z)(void* arg1);
	static void ReadParam2(void* arg1)
	{
		_ReadParam2_HrStageDraw__SAXPAX_Z mFunc = (_ReadParam2_HrStageDraw__SAXPAX_Z)(GameModule + 0x417e10);
		return mFunc(arg1);
	}
	// [Function] uint8_t __convention("thiscall") HrStageDraw::Setup(class HrStageDraw* const this, void* arg2, class ghmResGroup* arg3, class ghmResGroup* arg4, class ghmResGroup* arg5, class Archive* arg6, int32_t arg7, void* arg8, void* arg9, void* arg10) [?Setup@HrStageDraw@@QAE_NPAXPAVghmResGroup@@11PAVArchive@@H000@Z]
	typedef uint8_t(__thiscall* _Setup_HrStageDraw__QAE_NPAXPAVghmResGroup__11PAVArchive__H000_Z)(class HrStageDraw* const thisPtr, void* arg2, class ghmResGroup* arg3, class ghmResGroup* arg4, class ghmResGroup* arg5, class Archive* arg6, int32_t arg7, void* arg8, void* arg9, void* arg10);
	uint8_t Setup(void* arg2, class ghmResGroup* arg3, class ghmResGroup* arg4, class ghmResGroup* arg5, class Archive* arg6, int32_t arg7, void* arg8, void* arg9, void* arg10)
	{
		_Setup_HrStageDraw__QAE_NPAXPAVghmResGroup__11PAVArchive__H000_Z mFunc = (_Setup_HrStageDraw__QAE_NPAXPAVghmResGroup__11PAVArchive__H000_Z)(GameModule + 0x417eb0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] void __convention("thiscall") HrStageDraw::FrameProcess(class HrStageDraw* const this) [?FrameProcess@HrStageDraw@@QAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrStageDraw__QAEXXZ)(class HrStageDraw* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrStageDraw__QAEXXZ mFunc = (_FrameProcess_HrStageDraw__QAEXXZ)(GameModule + 0x418e10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrStageDraw::Draw(class HrStageDraw* const this) [?Draw@HrStageDraw@@QAEXXZ]
	typedef void(__thiscall* _Draw_HrStageDraw__QAEXXZ)(class HrStageDraw* const thisPtr);
	void Draw()
	{
		_Draw_HrStageDraw__QAEXXZ mFunc = (_Draw_HrStageDraw__QAEXXZ)(GameModule + 0x419b80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrStageDraw::PlayMotion(class HrStageDraw* const this, class TGan* arg2, uint8_t arg3) [?PlayMotion@HrStageDraw@@QAE_NPAVTGan@@_N@Z]
	typedef uint8_t(__thiscall* _PlayMotion_HrStageDraw__QAE_NPAVTGan___N_Z)(class HrStageDraw* const thisPtr, class TGan* arg2, uint8_t arg3);
	uint8_t PlayMotion(class TGan* arg2, uint8_t arg3)
	{
		_PlayMotion_HrStageDraw__QAE_NPAVTGan___N_Z mFunc = (_PlayMotion_HrStageDraw__QAE_NPAVTGan___N_Z)(GameModule + 0x419d30);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void HrStageDraw::ReadParam(void* arg1, int32_t* arg2) [?ReadParam@HrStageDraw@@SAXPAXPAH@Z]
	typedef void(__fastcall* _ReadParam_HrStageDraw__SAXPAXPAH_Z)(void* arg1, int32_t* arg2);
	static void ReadParam(void* arg1, int32_t* arg2)
	{
		_ReadParam_HrStageDraw__SAXPAXPAH_Z mFunc = (_ReadParam_HrStageDraw__SAXPAXPAH_Z)(GameModule + 0x419da0);
		return mFunc(arg1, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrStageDraw [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrStageDraw& InObject)
	{
		pAreaBuffer = InObject.pAreaBuffer;
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrStageDraw>("HrStageDraw")
			.addFunction("__tostring", &HrStageDraw::ToString)
			.addFunction("GetPtrAddr", &HrStageDraw::GetPtrAddr)
			// void type not supported in LuaBridge
			//.addProperty("pAreaBuffer", &HrStageDraw::pAreaBuffer)
			.addProperty("dat", &HrStageDraw::dat)
			.addFunction("GetGmf", &HrStageDraw::GetGmf)
			.addFunction("GetGcl", &HrStageDraw::GetGcl)
			.addFunction("IsGcl", &HrStageDraw::IsGcl)
			.addFunction("GetDrawOrderType", &HrStageDraw::GetDrawOrderType)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetClipCheckPos", &HrStageDraw::SetClipCheckPos)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetLoadAreaPos", &HrStageDraw::SetLoadAreaPos)
			.addFunction("setCollisionValidFlag", &HrStageDraw::setCollisionValidFlag)
			.addFunction("GetLoadCompleteAreaNum", &HrStageDraw::GetLoadCompleteAreaNum)
			.addFunction("prReleaseArea", &HrStageDraw::prReleaseArea)
			.addFunction("AreaNodeVisibleRefresh", &HrStageDraw::AreaNodeVisibleRefresh)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("AreaSelectDraw", &HrStageDraw::AreaSelectDraw)
			.addStaticFunction("SetAmbLight", &HrStageDraw::SetAmbLight)
			.addStaticFunction("SetToonModelMulColor", &HrStageDraw::SetToonModelMulColor)
			.addFunction("DrawColl", &HrStageDraw::DrawColl)
			.addFunction("ClipNodeColision", &HrStageDraw::ClipNodeColision)
			.addFunction("SetBikeCollisionEnable", &HrStageDraw::SetBikeCollisionEnable)
			.addFunction("SetAreaBikeCollisionEnable", &HrStageDraw::SetAreaBikeCollisionEnable)
			.addFunction("initVertexAnimation", &HrStageDraw::initVertexAnimation)
			.addFunction("AddNodeMotion", &HrStageDraw::AddNodeMotion)
			.addFunction("AddNodeModel", &HrStageDraw::AddNodeModel)
			.addFunction("LightSetup", &HrStageDraw::LightSetup)
			.addFunction("AreaAllRelease", &HrStageDraw::AreaAllRelease)
			.addFunction("IsAreaLoading", &HrStageDraw::IsAreaLoading)
			.addFunction("IsDoneLoading", &HrStageDraw::IsDoneLoading)
			.addFunction("GetAreaNumberToPos", &HrStageDraw::GetAreaNumberToPos)
			.addFunction("GetHiModelGclToPos", &HrStageDraw::GetHiModelGclToPos)
			.addFunction("GetNodeModel", &HrStageDraw::GetNodeModel)
			.addFunction("SetAreaNodeVisible", &HrStageDraw::SetAreaNodeVisible)
			.addStaticFunction("SetToonModelMulColorValidFlag", &HrStageDraw::SetToonModelMulColorValidFlag)
			.addStaticFunction("SetAmbLightValidFlag", &HrStageDraw::SetAmbLightValidFlag)
			.addStaticFunction("GetLight", &HrStageDraw::GetLight)
			.addStaticFunction("SetLight", &HrStageDraw::SetLight)
			.addFunction("RefreshLight", &HrStageDraw::RefreshLight)
			.addFunction("Terminate", &HrStageDraw::Terminate)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("ReadParam2", &HrStageDraw::ReadParam2)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("Setup", &HrStageDraw::Setup)
			.addFunction("FrameProcess", &HrStageDraw::FrameProcess)
			.addFunction("Draw", &HrStageDraw::Draw)
			.addFunction("PlayMotion", &HrStageDraw::PlayMotion)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("ReadParam", &HrStageDraw::ReadParam)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrStageDraw::pAreaBuffer) == 4, "expected HrStageDraw::pAreaBuffer to be size 4");
static_assert(sizeof(HrStageDraw::dat) == 20728, "expected HrStageDraw::dat to be size 20728");
static_assert(sizeof(HrStageDraw) == 0x5100, "expected HrStageDraw to be size 0x5100");

// Unsupported operator
//void* __convention("thiscall") HrStageDraw::`scalar deleting destructor'(class HrStageDraw* const this, uint32_t arg2)
// Unsupported operator
//void __convention("thiscall") <lambda_bf30f43eadff87346257660a44fab5ac>::operator()(class CBgCtrl::Release::__l47::<lambda_bf30f43eadff87346257660a44fab5ac>* const this, void* arg2)
// Unsupported operator
//void (*)(void*) __convention("thiscall") <lambda_bf30f43eadff87346257660a44fab5ac>::operator void (__cdecl*)(void *)(class CBgCtrl::Release::__l47::<lambda_bf30f43eadff87346257660a44fab5ac>* const this)
// Unsupported operator
//void __convention("thiscall") <lambda_6bb7992eea8bcffc29a6b7bd191d7095>::operator()(class CBgCtrl::Release::__l50::<lambda_6bb7992eea8bcffc29a6b7bd191d7095>* const this, void* arg2)
// Unsupported operator
//void (*)(void*) __convention("thiscall") <lambda_6bb7992eea8bcffc29a6b7bd191d7095>::operator void (__cdecl*)(void *)(class CBgCtrl::Release::__l50::<lambda_6bb7992eea8bcffc29a6b7bd191d7095>* const this)
// Unsupported operator
//void* __convention("thiscall") CBgCtrl::`scalar deleting destructor'(class CBgCtrl* const this, uint32_t arg2)
// [Structure] struct HRSAVEDATA_DEBUNEKO
struct HRSAVEDATA_DEBUNEKO
{
public:
	/// Struct member variables

	// <uint8_t boEndTraining[0x5], offset 0x0>
	uint8_t boEndTraining[5];

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	// <int32_t CatWeight, offset 0x8>
	int32_t CatWeight = 0;

	// <int32_t CatMood, offset 0xc>
	int32_t CatMood = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct HRSAVEDATA_DEBUNEKO [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HRSAVEDATA_DEBUNEKO& InObject)
	{
		CatWeight = InObject.CatWeight;
		CatMood = InObject.CatMood;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HRSAVEDATA_DEBUNEKO>("HRSAVEDATA_DEBUNEKO")
			.addFunction("__tostring", &HRSAVEDATA_DEBUNEKO::ToString)
			.addFunction("GetPtrAddr", &HRSAVEDATA_DEBUNEKO::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("boEndTraining", &HRSAVEDATA_DEBUNEKO::boEndTraining)
			.addProperty("CatWeight", &HRSAVEDATA_DEBUNEKO::CatWeight)
			.addProperty("CatMood", &HRSAVEDATA_DEBUNEKO::CatMood)
		.endClass();
	}
#endif
};
static_assert(sizeof(HRSAVEDATA_DEBUNEKO::boEndTraining) == 5, "expected HRSAVEDATA_DEBUNEKO::boEndTraining to be size 5");
static_assert(sizeof(HRSAVEDATA_DEBUNEKO::CatWeight) == 4, "expected HRSAVEDATA_DEBUNEKO::CatWeight to be size 4");
static_assert(sizeof(HRSAVEDATA_DEBUNEKO::CatMood) == 4, "expected HRSAVEDATA_DEBUNEKO::CatMood to be size 4");
static_assert(sizeof(HRSAVEDATA_DEBUNEKO) == 0x10, "expected HRSAVEDATA_DEBUNEKO to be size 0x10");

// enum eControlMove
enum eControlMove : uint32_t
{
	// <eControlMove_WalkFront = 0x0>
	eControlMove_WalkFront = 0,

	// <eControlMove_WalkBack = 0x1>
	eControlMove_WalkBack = 1,

	// <eControlMove_WalkSideLeft = 0x2>
	eControlMove_WalkSideLeft = 2,

	// <eControlMove_WalkSideRight = 0x3>
	eControlMove_WalkSideRight = 3,

	// <eControlMove_RotLeft = 0x4>
	eControlMove_RotLeft = 4,

	// <eControlMove_RotRight = 0x5>
	eControlMove_RotRight = 5,

	// <eControlMove_PcCenterCircleLeft = 0x6>
	eControlMove_PcCenterCircleLeft = 6,

	// <eControlMove_PcCenterCircleRight = 0x7>
	eControlMove_PcCenterCircleRight = 7,

	// <eControlMove_WalkClosePc = 0x8>
	eControlMove_WalkClosePc = 8,

	// <eControlMove_WalkAwayPc = 0x9>
	eControlMove_WalkAwayPc = 9,

	// <eControlMove_StandObservPc = 0xa>
	eControlMove_StandObservPc = 10

};

// enum eZkMaai
enum eZkMaai : uint32_t
{
	// <eZkMaai_CLOSEST = 0x0>
	eZkMaai_CLOSEST = 0,

	// <eZkMaai_CHIKAMA = 0x1>
	eZkMaai_CHIKAMA = 1,

	// <eZkMaai_1TO1SOKU = 0x2>
	eZkMaai_1TO1SOKU = 2,

	// <eZkMaai_TOMA = 0x3>
	eZkMaai_TOMA = 3,

	// <eZkMaai_CIRCLE_MOV_IN = 0x4>
	eZkMaai_CIRCLE_MOV_IN = 4,

	// <eZkMaai_CIRCLE_MOV_OUT = 0x5>
	eZkMaai_CIRCLE_MOV_OUT = 5,

	// <eZkMaai_CIRCLE_OUTFIELD_IN = 0x6>
	eZkMaai_CIRCLE_OUTFIELD_IN = 6,

	// <eZkMaai_CIRCLE_OUTFIELD_OUT = 0x7>
	eZkMaai_CIRCLE_OUTFIELD_OUT = 7,

	// <eZkMaai_Num = 0x8>
	eZkMaai_Num = 8

};

// enum e_ZkMotTimingType
enum e_ZkMotTimingType : uint32_t
{
	// <e_ZkMotTimingType_Invin = 0x0>
	e_ZkMotTimingType_Invin = 0,

	// <e_ZkMotTimingType_Cancel = 0x1>
	e_ZkMotTimingType_Cancel = 1,

	// <e_ZkMotTimingType_NUM = 0x2>
	e_ZkMotTimingType_NUM = 2

};

// enum eAtkType
enum eAtkType : uint32_t
{
	// <eAtkType_Random = 0xffffffffffffffff>
	eAtkType_Random = UINT32_MAX,

	// <eAtkType_WalkAndCombo = 0x0>
	eAtkType_WalkAndCombo = 0,

	// <eAtkType_HereCombo = 0x1>
	eAtkType_HereCombo = 1,

	// <eAtkType_StepInAtk = 0x2>
	eAtkType_StepInAtk = 2,

	// <eAtkType_NUM = 0x3>
	eAtkType_NUM = 3

};

// enum eEvacuateDir
enum eEvacuateDir : uint32_t
{
	// <eEvacuateDir_UNKONOWN = 0xffffffffffffffff>
	eEvacuateDir_UNKONOWN = UINT32_MAX,

	// <eEvacuateDir_Side = 0x0>
	eEvacuateDir_Side = 0,

	// <eEvacuateDir_Back = 0x1>
	eEvacuateDir_Back = 1,

	// <eEvacuateDir_ZkTypeOptional = 0x2>
	eEvacuateDir_ZkTypeOptional = 2,

	// <eEvacuateDir_NUM = 0x3>
	eEvacuateDir_NUM = 3

};

// [Structure] class PJState
class PJState
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x5], offset 0x0>
	void* (* field_0)[0x5];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJState>("PJState")
			.addFunction("__tostring", &PJState::ToString)
			.addFunction("GetPtrAddr", &PJState::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &PJState::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJState::field_0) == 4, "expected PJState::field_0 to be size 4");
static_assert(sizeof(PJState) == 0x4, "expected PJState to be size 0x4");

// [Structure] class ZkState_DownAttack
class ZkState_DownAttack : public PJState
{
public:
	// enum ZkState_DownAttack::eStat
	enum eStat : uint32_t
	{
		// <eStat_Close = 0x0>
		eStat_Close = 0,

		// <eStat_Attacking = 0x1>
		eStat_Attacking = 1

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum ZkState_DownAttack::eStat m_eStat, offset 0x4>
	enum ZkState_DownAttack::eStat m_eStat;

	/// 4 Functions

	// [Function] void __convention("thiscall") ZkState_DownAttack::ChangeStateCondition(class ZkState_DownAttack* const this, class PJZAKO* arg2) [?ChangeStateCondition@ZkState_DownAttack@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_ZkState_DownAttack__QAEXPAVPJZAKO___Z)(class ZkState_DownAttack* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_ZkState_DownAttack__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_ZkState_DownAttack__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5b90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_DownAttack::Enter(class ZkState_DownAttack* const this, class PJZAKO* arg2) [?Enter@ZkState_DownAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_DownAttack__UAEXPAVPJZAKO___Z)(class ZkState_DownAttack* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_DownAttack__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_DownAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5db320);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_DownAttack::Execute(class ZkState_DownAttack* const this, class PJZAKO* arg2) [?Execute@ZkState_DownAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_DownAttack__UAEXPAVPJZAKO___Z)(class ZkState_DownAttack* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_DownAttack__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_DownAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5db3c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_DownAttack::Exit(class ZkState_DownAttack* const this, class PJZAKO* arg2) [?Exit@ZkState_DownAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkState_DownAttack__UAEXPAVPJZAKO___Z)(class ZkState_DownAttack* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkState_DownAttack__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkState_DownAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5db590);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_DownAttack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_DownAttack& InObject)
	{
		m_eStat = InObject.m_eStat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_DownAttack, PJState>("ZkState_DownAttack")
			.addFunction("__tostring", &ZkState_DownAttack::ToString)
			.addFunction("GetPtrAddr", &ZkState_DownAttack::GetPtrAddr)
			.addProperty("m_eStat", &ZkState_DownAttack::m_eStat)
			.addFunction("ChangeStateCondition", &ZkState_DownAttack::ChangeStateCondition)
			.addFunction("Enter", &ZkState_DownAttack::Enter)
			.addFunction("Execute", &ZkState_DownAttack::Execute)
			.addFunction("Exit", &ZkState_DownAttack::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_DownAttack::m_eStat) == 4, "expected ZkState_DownAttack::m_eStat to be size 4");
static_assert(sizeof(ZkState_DownAttack) == 0x8, "expected ZkState_DownAttack to be size 0x8");

// [Structure] class State_AwayAfterAttack
class State_AwayAfterAttack : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_AwayAfterAttack::ChangeStateCondition(class State_AwayAfterAttack* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_AwayAfterAttack@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_AwayAfterAttack__QAEXPAVPJZAKO___Z)(class State_AwayAfterAttack* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_AwayAfterAttack__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_AwayAfterAttack__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7580);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_AwayAfterAttack::Enter(class State_AwayAfterAttack* const this, class PJZAKO* arg2) [?Enter@State_AwayAfterAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_AwayAfterAttack__UAEXPAVPJZAKO___Z)(class State_AwayAfterAttack* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_AwayAfterAttack__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_AwayAfterAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9b80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_AwayAfterAttack::Execute(class State_AwayAfterAttack* const this, class PJZAKO* arg2) [?Execute@State_AwayAfterAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_AwayAfterAttack__UAEXPAVPJZAKO___Z)(class State_AwayAfterAttack* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_AwayAfterAttack__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_AwayAfterAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9ba0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_AwayAfterAttack::Exit(class State_AwayAfterAttack* const this, class PJZAKO* arg2) [?Exit@State_AwayAfterAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_AwayAfterAttack__UAEXPAVPJZAKO___Z)(class State_AwayAfterAttack* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_AwayAfterAttack__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_AwayAfterAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9c40);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_AwayAfterAttack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_AwayAfterAttack& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_AwayAfterAttack, PJState>("State_AwayAfterAttack")
			.addFunction("__tostring", &State_AwayAfterAttack::ToString)
			.addFunction("GetPtrAddr", &State_AwayAfterAttack::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_AwayAfterAttack::ChangeStateCondition)
			.addFunction("Enter", &State_AwayAfterAttack::Enter)
			.addFunction("Execute", &State_AwayAfterAttack::Execute)
			.addFunction("Exit", &State_AwayAfterAttack::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_AwayAfterAttack) == 0x4, "expected State_AwayAfterAttack to be size 0x4");

// [Structure] class State_CloseBeforeAttack
class State_CloseBeforeAttack : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 3 Functions

	// [Function] void __convention("thiscall") State_CloseBeforeAttack::Enter(class State_CloseBeforeAttack* const this, class PJZAKO* arg2) [?Enter@State_CloseBeforeAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z)(class State_CloseBeforeAttack* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d97f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_CloseBeforeAttack::Execute(class State_CloseBeforeAttack* const this, class PJZAKO* arg2) [?Execute@State_CloseBeforeAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z)(class State_CloseBeforeAttack* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9860);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_CloseBeforeAttack::Exit(class State_CloseBeforeAttack* const this, class PJZAKO* arg2) [?Exit@State_CloseBeforeAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z)(class State_CloseBeforeAttack* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_CloseBeforeAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9b70);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_CloseBeforeAttack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_CloseBeforeAttack& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_CloseBeforeAttack, PJState>("State_CloseBeforeAttack")
			.addFunction("__tostring", &State_CloseBeforeAttack::ToString)
			.addFunction("GetPtrAddr", &State_CloseBeforeAttack::GetPtrAddr)
			.addFunction("Enter", &State_CloseBeforeAttack::Enter)
			.addFunction("Execute", &State_CloseBeforeAttack::Execute)
			.addFunction("Exit", &State_CloseBeforeAttack::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_CloseBeforeAttack) == 0x4, "expected State_CloseBeforeAttack to be size 0x4");

// [Structure] class State_StepInAttack
class State_StepInAttack : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_StepInAttack::ChangeStateCondition(class State_StepInAttack* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_StepInAttack@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_StepInAttack__QAEXPAVPJZAKO___Z)(class State_StepInAttack* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_StepInAttack__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_StepInAttack__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7520);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_StepInAttack::Enter(class State_StepInAttack* const this, class PJZAKO* arg2) [?Enter@State_StepInAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_StepInAttack__UAEXPAVPJZAKO___Z)(class State_StepInAttack* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_StepInAttack__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_StepInAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9430);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_StepInAttack::Execute(class State_StepInAttack* const this, class PJZAKO* arg2) [?Execute@State_StepInAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_StepInAttack__UAEXPAVPJZAKO___Z)(class State_StepInAttack* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_StepInAttack__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_StepInAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9450);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_StepInAttack::Exit(class State_StepInAttack* const this, class PJZAKO* arg2) [?Exit@State_StepInAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_StepInAttack__UAEXPAVPJZAKO___Z)(class State_StepInAttack* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_StepInAttack__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_StepInAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9590);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_StepInAttack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_StepInAttack& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_StepInAttack, PJState>("State_StepInAttack")
			.addFunction("__tostring", &State_StepInAttack::ToString)
			.addFunction("GetPtrAddr", &State_StepInAttack::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_StepInAttack::ChangeStateCondition)
			.addFunction("Enter", &State_StepInAttack::Enter)
			.addFunction("Execute", &State_StepInAttack::Execute)
			.addFunction("Exit", &State_StepInAttack::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_StepInAttack) == 0x4, "expected State_StepInAttack to be size 0x4");

// [Structure] class State_DownDamage
class State_DownDamage : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_DownDamage::ChangeStateCondition(class State_DownDamage* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_DownDamage@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_DownDamage__QAEXPAVPJZAKO___Z)(class State_DownDamage* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_DownDamage__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_DownDamage__QAEXPAVPJZAKO___Z)(GameModule + 0x5d6090);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_DownDamage::Enter(class State_DownDamage* const this, class PJZAKO* arg2) [?Enter@State_DownDamage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_DownDamage__UAEXPAVPJZAKO___Z)(class State_DownDamage* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_DownDamage__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_DownDamage__UAEXPAVPJZAKO___Z)(GameModule + 0x5db2f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_DownDamage::Execute(class State_DownDamage* const this, class PJZAKO* arg2) [?Execute@State_DownDamage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_DownDamage__UAEXPAVPJZAKO___Z)(class State_DownDamage* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_DownDamage__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_DownDamage__UAEXPAVPJZAKO___Z)(GameModule + 0x5db300);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_DownDamage::Exit(class State_DownDamage* const this, class PJZAKO* arg2) [?Exit@State_DownDamage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_DownDamage__UAEXPAVPJZAKO___Z)(class State_DownDamage* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_DownDamage__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_DownDamage__UAEXPAVPJZAKO___Z)(GameModule + 0x5db310);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_DownDamage [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_DownDamage& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_DownDamage, PJState>("State_DownDamage")
			.addFunction("__tostring", &State_DownDamage::ToString)
			.addFunction("GetPtrAddr", &State_DownDamage::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_DownDamage::ChangeStateCondition)
			.addFunction("Enter", &State_DownDamage::Enter)
			.addFunction("Execute", &State_DownDamage::Execute)
			.addFunction("Exit", &State_DownDamage::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_DownDamage) == 0x4, "expected State_DownDamage to be size 0x4");

// [Structure] class State_TojoBaseState
class State_TojoBaseState : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_TojoBaseState::Enter(class State_TojoBaseState* const this, class PJZAKO* arg2) [?Enter@State_TojoBaseState@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_TojoBaseState__UAEXPAVPJZAKO___Z)(class State_TojoBaseState* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_TojoBaseState__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_TojoBaseState__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd660);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_TojoBaseState::Execute(class State_TojoBaseState* const this, class PJZAKO* arg2) [?Execute@State_TojoBaseState@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_TojoBaseState__UAEXPAVPJZAKO___Z)(class State_TojoBaseState* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_TojoBaseState__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_TojoBaseState__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd6a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_TojoBaseState::Exit(class State_TojoBaseState* const this, class PJZAKO* arg2) [?Exit@State_TojoBaseState@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_TojoBaseState__UAEXPAVPJZAKO___Z)(class State_TojoBaseState* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_TojoBaseState__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_TojoBaseState__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd6b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_TojoBaseState::ChangeStateCondition(class State_TojoBaseState* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_TojoBaseState@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_TojoBaseState__UAEXPAVPJZAKO___Z)(class State_TojoBaseState* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_TojoBaseState__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_TojoBaseState__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd710);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_TojoBaseState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_TojoBaseState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_TojoBaseState, PJState>("State_TojoBaseState")
			.addFunction("__tostring", &State_TojoBaseState::ToString)
			.addFunction("GetPtrAddr", &State_TojoBaseState::GetPtrAddr)
			.addFunction("Enter", &State_TojoBaseState::Enter)
			.addFunction("Execute", &State_TojoBaseState::Execute)
			.addFunction("Exit", &State_TojoBaseState::Exit)
			.addFunction("ChangeStateCondition", &State_TojoBaseState::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_TojoBaseState) == 0x4, "expected State_TojoBaseState to be size 0x4");

// [Structure] class State_LeadPcWayPointMove
class State_LeadPcWayPointMove : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_LeadPcWayPointMove::ChangeStateCondition(class State_LeadPcWayPointMove* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_LeadPcWayPointMove@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_LeadPcWayPointMove__QAEXPAVPJZAKO___Z)(class State_LeadPcWayPointMove* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_LeadPcWayPointMove__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_LeadPcWayPointMove__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5a80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_LeadPcWayPointMove::Enter(class State_LeadPcWayPointMove* const this, class PJZAKO* arg2) [?Enter@State_LeadPcWayPointMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z)(class State_LeadPcWayPointMove* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5dcbb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_LeadPcWayPointMove::Execute(class State_LeadPcWayPointMove* const this, class PJZAKO* arg2) [?Execute@State_LeadPcWayPointMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z)(class State_LeadPcWayPointMove* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5dcbd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_LeadPcWayPointMove::Exit(class State_LeadPcWayPointMove* const this, class PJZAKO* arg2) [?Exit@State_LeadPcWayPointMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z)(class State_LeadPcWayPointMove* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_LeadPcWayPointMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5dcc70);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_LeadPcWayPointMove [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_LeadPcWayPointMove& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_LeadPcWayPointMove, PJState>("State_LeadPcWayPointMove")
			.addFunction("__tostring", &State_LeadPcWayPointMove::ToString)
			.addFunction("GetPtrAddr", &State_LeadPcWayPointMove::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_LeadPcWayPointMove::ChangeStateCondition)
			.addFunction("Enter", &State_LeadPcWayPointMove::Enter)
			.addFunction("Execute", &State_LeadPcWayPointMove::Execute)
			.addFunction("Exit", &State_LeadPcWayPointMove::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_LeadPcWayPointMove) == 0x4, "expected State_LeadPcWayPointMove to be size 0x4");

// [Structure] class State_FixTurret
class State_FixTurret : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_FixTurret::ChangeStateCondition(class State_FixTurret* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_FixTurret@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_FixTurret__QAEXPAVPJZAKO___Z)(class State_FixTurret* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_FixTurret__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_FixTurret__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5a70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_FixTurret::Enter(class State_FixTurret* const this, class PJZAKO* arg2) [?Enter@State_FixTurret@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_FixTurret__UAEXPAVPJZAKO___Z)(class State_FixTurret* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_FixTurret__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_FixTurret__UAEXPAVPJZAKO___Z)(GameModule + 0x5dcc80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_FixTurret::Execute(class State_FixTurret* const this, class PJZAKO* arg2) [?Execute@State_FixTurret@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_FixTurret__UAEXPAVPJZAKO___Z)(class State_FixTurret* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_FixTurret__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_FixTurret__UAEXPAVPJZAKO___Z)(GameModule + 0x5dccd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_FixTurret::Exit(class State_FixTurret* const this, class PJZAKO* arg2) [?Exit@State_FixTurret@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_FixTurret__UAEXPAVPJZAKO___Z)(class State_FixTurret* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_FixTurret__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_FixTurret__UAEXPAVPJZAKO___Z)(GameModule + 0x5dcd50);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_FixTurret [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_FixTurret& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_FixTurret, PJState>("State_FixTurret")
			.addFunction("__tostring", &State_FixTurret::ToString)
			.addFunction("GetPtrAddr", &State_FixTurret::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_FixTurret::ChangeStateCondition)
			.addFunction("Enter", &State_FixTurret::Enter)
			.addFunction("Execute", &State_FixTurret::Execute)
			.addFunction("Exit", &State_FixTurret::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_FixTurret) == 0x4, "expected State_FixTurret to be size 0x4");

// [Structure] class State_WayPointMoveAfterPop
class State_WayPointMoveAfterPop : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_WayPointMoveAfterPop::ChangeStateCondition(class State_WayPointMoveAfterPop* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_WayPointMoveAfterPop@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_WayPointMoveAfterPop__QAEXPAVPJZAKO___Z)(class State_WayPointMoveAfterPop* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_WayPointMoveAfterPop__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_WayPointMoveAfterPop__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5a60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_WayPointMoveAfterPop::Enter(class State_WayPointMoveAfterPop* const this, class PJZAKO* arg2) [?Enter@State_WayPointMoveAfterPop@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z)(class State_WayPointMoveAfterPop* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z)(GameModule + 0x5dcd70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_WayPointMoveAfterPop::Execute(class State_WayPointMoveAfterPop* const this, class PJZAKO* arg2) [?Execute@State_WayPointMoveAfterPop@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z)(class State_WayPointMoveAfterPop* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z)(GameModule + 0x5dcd90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_WayPointMoveAfterPop::Exit(class State_WayPointMoveAfterPop* const this, class PJZAKO* arg2) [?Exit@State_WayPointMoveAfterPop@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z)(class State_WayPointMoveAfterPop* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_WayPointMoveAfterPop__UAEXPAVPJZAKO___Z)(GameModule + 0x5dce00);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_WayPointMoveAfterPop [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_WayPointMoveAfterPop& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_WayPointMoveAfterPop, PJState>("State_WayPointMoveAfterPop")
			.addFunction("__tostring", &State_WayPointMoveAfterPop::ToString)
			.addFunction("GetPtrAddr", &State_WayPointMoveAfterPop::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_WayPointMoveAfterPop::ChangeStateCondition)
			.addFunction("Enter", &State_WayPointMoveAfterPop::Enter)
			.addFunction("Execute", &State_WayPointMoveAfterPop::Execute)
			.addFunction("Exit", &State_WayPointMoveAfterPop::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_WayPointMoveAfterPop) == 0x4, "expected State_WayPointMoveAfterPop to be size 0x4");

// [Structure] class State_Global
class State_Global : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 5 Functions

	// [Function] void __convention("thiscall") State_Global::ChangeStateCondition(class State_Global* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Global@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Global__QAEXPAVPJZAKO___Z)(class State_Global* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Global__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Global__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7d80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Global::Enter(class State_Global* const this, class PJZAKO* arg2) [?Enter@State_Global@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Global__UAEXPAVPJZAKO___Z)(class State_Global* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Global__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Global__UAEXPAVPJZAKO___Z)(GameModule + 0x5d7ef0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Global::Execute(class State_Global* const this, class PJZAKO* arg2) [?Execute@State_Global@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Global__UAEXPAVPJZAKO___Z)(class State_Global* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Global__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Global__UAEXPAVPJZAKO___Z)(GameModule + 0x5d7f00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Global::Exit(class State_Global* const this, class PJZAKO* arg2) [?Exit@State_Global@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Global__UAEXPAVPJZAKO___Z)(class State_Global* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Global__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Global__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8510);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Global::CheckEvacuateTiming(class State_Global* const this, class PJZAKO* arg2) [?CheckEvacuateTiming@State_Global@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _CheckEvacuateTiming_State_Global__UAEXPAVPJZAKO___Z)(class State_Global* const thisPtr, class PJZAKO* arg2);
	void CheckEvacuateTiming(class PJZAKO* arg2)
	{
		_CheckEvacuateTiming_State_Global__UAEXPAVPJZAKO___Z mFunc = (_CheckEvacuateTiming_State_Global__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8520);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Global [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Global& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Global, PJState>("State_Global")
			.addFunction("__tostring", &State_Global::ToString)
			.addFunction("GetPtrAddr", &State_Global::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_Global::ChangeStateCondition)
			.addFunction("Enter", &State_Global::Enter)
			.addFunction("Execute", &State_Global::Execute)
			.addFunction("Exit", &State_Global::Exit)
			.addFunction("CheckEvacuateTiming", &State_Global::CheckEvacuateTiming)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Global) == 0x4, "expected State_Global to be size 0x4");

// [Structure] class State_Dying
class State_Dying : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Dying::ChangeStateCondition(class State_Dying* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Dying@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Dying__QAEXPAVPJZAKO___Z)(class State_Dying* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Dying__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Dying__QAEXPAVPJZAKO___Z)(GameModule + 0x5d6070);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Dying::Enter(class State_Dying* const this, class PJZAKO* arg2) [?Enter@State_Dying@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Dying__UAEXPAVPJZAKO___Z)(class State_Dying* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Dying__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Dying__UAEXPAVPJZAKO___Z)(GameModule + 0x5db910);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Dying::Execute(class State_Dying* const this, class PJZAKO* arg2) [?Execute@State_Dying@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Dying__UAEXPAVPJZAKO___Z)(class State_Dying* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Dying__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Dying__UAEXPAVPJZAKO___Z)(GameModule + 0x5db930);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Dying::Exit(class State_Dying* const this, class PJZAKO* arg2) [?Exit@State_Dying@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Dying__UAEXPAVPJZAKO___Z)(class State_Dying* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Dying__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Dying__UAEXPAVPJZAKO___Z)(GameModule + 0x5db970);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Dying [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Dying& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Dying, PJState>("State_Dying")
			.addFunction("__tostring", &State_Dying::ToString)
			.addFunction("GetPtrAddr", &State_Dying::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_Dying::ChangeStateCondition)
			.addFunction("Enter", &State_Dying::Enter)
			.addFunction("Execute", &State_Dying::Execute)
			.addFunction("Exit", &State_Dying::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Dying) == 0x4, "expected State_Dying to be size 0x4");

// [Structure] class ZkState_Knife_Evacuation
class ZkState_Knife_Evacuation : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 3 Functions

	// [Function] void __convention("thiscall") ZkState_Knife_Evacuation::Exit(class ZkState_Knife_Evacuation* const this, class PJZAKO* arg2) [?Exit@ZkState_Knife_Evacuation@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z)(class ZkState_Knife_Evacuation* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z)(GameModule + 0x4fdfb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_Knife_Evacuation::Execute(class ZkState_Knife_Evacuation* const this, class PJZAKO* arg2) [?Execute@ZkState_Knife_Evacuation@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z)(class ZkState_Knife_Evacuation* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z)(GameModule + 0x4fdfc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_Knife_Evacuation::Enter(class ZkState_Knife_Evacuation* const this, class PJZAKO* arg2) [?Enter@ZkState_Knife_Evacuation@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z)(class ZkState_Knife_Evacuation* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_Knife_Evacuation__UAEXPAVPJZAKO___Z)(GameModule + 0x4fe0f0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_Knife_Evacuation [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_Knife_Evacuation& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_Knife_Evacuation, PJState>("ZkState_Knife_Evacuation")
			.addFunction("__tostring", &ZkState_Knife_Evacuation::ToString)
			.addFunction("GetPtrAddr", &ZkState_Knife_Evacuation::GetPtrAddr)
			.addFunction("Exit", &ZkState_Knife_Evacuation::Exit)
			.addFunction("Execute", &ZkState_Knife_Evacuation::Execute)
			.addFunction("Enter", &ZkState_Knife_Evacuation::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_Knife_Evacuation) == 0x4, "expected ZkState_Knife_Evacuation to be size 0x4");

// [Structure] class ZkState_Knife_Defence
class ZkState_Knife_Defence : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 3 Functions

	// [Function] void __convention("thiscall") ZkState_Knife_Defence::Exit(class ZkState_Knife_Defence* const this, class PJZAKO* arg2) [?Exit@ZkState_Knife_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z)(class ZkState_Knife_Defence* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x4fe110);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_Knife_Defence::Execute(class ZkState_Knife_Defence* const this, class PJZAKO* arg2) [?Execute@ZkState_Knife_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z)(class ZkState_Knife_Defence* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x4fe120);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_Knife_Defence::Enter(class ZkState_Knife_Defence* const this, class PJZAKO* arg2) [?Enter@ZkState_Knife_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z)(class ZkState_Knife_Defence* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_Knife_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x4fe300);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_Knife_Defence [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_Knife_Defence& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_Knife_Defence, PJState>("ZkState_Knife_Defence")
			.addFunction("__tostring", &ZkState_Knife_Defence::ToString)
			.addFunction("GetPtrAddr", &ZkState_Knife_Defence::GetPtrAddr)
			.addFunction("Exit", &ZkState_Knife_Defence::Exit)
			.addFunction("Execute", &ZkState_Knife_Defence::Execute)
			.addFunction("Enter", &ZkState_Knife_Defence::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_Knife_Defence) == 0x4, "expected ZkState_Knife_Defence to be size 0x4");

// [Structure] class State_Close
class State_Close : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Close::ChangeStateCondition(class State_Close* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Close@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Close__QAEXPAVPJZAKO___Z)(class State_Close* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Close__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Close__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Close::Enter(class State_Close* const this, class PJZAKO* arg2) [?Enter@State_Close@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Close__UAEXPAVPJZAKO___Z)(class State_Close* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Close__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Close__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8760);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Close::Execute(class State_Close* const this, class PJZAKO* arg2) [?Execute@State_Close@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Close__UAEXPAVPJZAKO___Z)(class State_Close* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Close__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Close__UAEXPAVPJZAKO___Z)(GameModule + 0x5d87c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Close::Exit(class State_Close* const this, class PJZAKO* arg2) [?Exit@State_Close@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Close__UAEXPAVPJZAKO___Z)(class State_Close* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Close__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Close__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8b90);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Close [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Close& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Close, PJState>("State_Close")
			.addFunction("__tostring", &State_Close::ToString)
			.addFunction("GetPtrAddr", &State_Close::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_Close::ChangeStateCondition)
			.addFunction("Enter", &State_Close::Enter)
			.addFunction("Execute", &State_Close::Execute)
			.addFunction("Exit", &State_Close::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Close) == 0x4, "expected State_Close to be size 0x4");

// [Structure] class State_NoProc
class State_NoProc : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_NoProc::ChangeStateCondition(class State_NoProc* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_NoProc@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_NoProc__QAEXPAVPJZAKO___Z)(class State_NoProc* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_NoProc__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_NoProc__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5b80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_NoProc::Enter(class State_NoProc* const this, class PJZAKO* arg2) [?Enter@State_NoProc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_NoProc__UAEXPAVPJZAKO___Z)(class State_NoProc* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_NoProc__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_NoProc__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc6c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_NoProc::Execute(class State_NoProc* const this, class PJZAKO* arg2) [?Execute@State_NoProc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_NoProc__UAEXPAVPJZAKO___Z)(class State_NoProc* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_NoProc__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_NoProc__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc6d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_NoProc::Exit(class State_NoProc* const this, class PJZAKO* arg2) [?Exit@State_NoProc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_NoProc__UAEXPAVPJZAKO___Z)(class State_NoProc* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_NoProc__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_NoProc__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc710);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_NoProc [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_NoProc& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_NoProc, PJState>("State_NoProc")
			.addFunction("__tostring", &State_NoProc::ToString)
			.addFunction("GetPtrAddr", &State_NoProc::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_NoProc::ChangeStateCondition)
			.addFunction("Enter", &State_NoProc::Enter)
			.addFunction("Execute", &State_NoProc::Execute)
			.addFunction("Exit", &State_NoProc::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_NoProc) == 0x4, "expected State_NoProc to be size 0x4");

// [Structure] class State_Caution
class State_Caution : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Caution::ChangeStateCondition(class State_Caution* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Caution@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Caution__QAEXPAVPJZAKO___Z)(class State_Caution* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Caution__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Caution__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5c80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Caution::Enter(class State_Caution* const this, class PJZAKO* arg2) [?Enter@State_Caution@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Caution__UAEXPAVPJZAKO___Z)(class State_Caution* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Caution__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Caution__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc4a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Caution::Execute(class State_Caution* const this, class PJZAKO* arg2) [?Execute@State_Caution@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Caution__UAEXPAVPJZAKO___Z)(class State_Caution* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Caution__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Caution__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc4e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Caution::Exit(class State_Caution* const this, class PJZAKO* arg2) [?Exit@State_Caution@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Caution__UAEXPAVPJZAKO___Z)(class State_Caution* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Caution__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Caution__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc6b0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Caution [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Caution& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Caution, PJState>("State_Caution")
			.addFunction("__tostring", &State_Caution::ToString)
			.addFunction("GetPtrAddr", &State_Caution::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_Caution::ChangeStateCondition)
			.addFunction("Enter", &State_Caution::Enter)
			.addFunction("Execute", &State_Caution::Execute)
			.addFunction("Exit", &State_Caution::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Caution) == 0x4, "expected State_Caution to be size 0x4");

// [Structure] class State_OutField
class State_OutField : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_OutField::ChangeStateCondition(class State_OutField* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_OutField@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_OutField__QAEXPAVPJZAKO___Z)(class State_OutField* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_OutField__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_OutField__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5c90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_OutField::Enter(class State_OutField* const this, class PJZAKO* arg2) [?Enter@State_OutField@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_OutField__UAEXPAVPJZAKO___Z)(class State_OutField* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_OutField__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_OutField__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc1a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_OutField::Execute(class State_OutField* const this, class PJZAKO* arg2) [?Execute@State_OutField@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_OutField__UAEXPAVPJZAKO___Z)(class State_OutField* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_OutField__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_OutField__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc1c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_OutField::Exit(class State_OutField* const this, class PJZAKO* arg2) [?Exit@State_OutField@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_OutField__UAEXPAVPJZAKO___Z)(class State_OutField* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_OutField__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_OutField__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc490);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_OutField [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_OutField& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_OutField, PJState>("State_OutField")
			.addFunction("__tostring", &State_OutField::ToString)
			.addFunction("GetPtrAddr", &State_OutField::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_OutField::ChangeStateCondition)
			.addFunction("Enter", &State_OutField::Enter)
			.addFunction("Execute", &State_OutField::Execute)
			.addFunction("Exit", &State_OutField::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_OutField) == 0x4, "expected State_OutField to be size 0x4");

// [Structure] class State_GoToFightLine
class State_GoToFightLine : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_GoToFightLine::ChangeStateCondition(class State_GoToFightLine* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_GoToFightLine@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_GoToFightLine__QAEXPAVPJZAKO___Z)(class State_GoToFightLine* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_GoToFightLine__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_GoToFightLine__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5f40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_GoToFightLine::Enter(class State_GoToFightLine* const this, class PJZAKO* arg2) [?Enter@State_GoToFightLine@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_GoToFightLine__UAEXPAVPJZAKO___Z)(class State_GoToFightLine* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_GoToFightLine__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_GoToFightLine__UAEXPAVPJZAKO___Z)(GameModule + 0x5dbe30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_GoToFightLine::Execute(class State_GoToFightLine* const this, class PJZAKO* arg2) [?Execute@State_GoToFightLine@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_GoToFightLine__UAEXPAVPJZAKO___Z)(class State_GoToFightLine* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_GoToFightLine__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_GoToFightLine__UAEXPAVPJZAKO___Z)(GameModule + 0x5dbe40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_GoToFightLine::Exit(class State_GoToFightLine* const this, class PJZAKO* arg2) [?Exit@State_GoToFightLine@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_GoToFightLine__UAEXPAVPJZAKO___Z)(class State_GoToFightLine* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_GoToFightLine__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_GoToFightLine__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc190);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_GoToFightLine [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_GoToFightLine& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_GoToFightLine, PJState>("State_GoToFightLine")
			.addFunction("__tostring", &State_GoToFightLine::ToString)
			.addFunction("GetPtrAddr", &State_GoToFightLine::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_GoToFightLine::ChangeStateCondition)
			.addFunction("Enter", &State_GoToFightLine::Enter)
			.addFunction("Execute", &State_GoToFightLine::Execute)
			.addFunction("Exit", &State_GoToFightLine::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_GoToFightLine) == 0x4, "expected State_GoToFightLine to be size 0x4");

// [Structure] class State_GetPcBehind
class State_GetPcBehind : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_GetPcBehind::ChangeStateCondition(class State_GetPcBehind* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_GetPcBehind@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_GetPcBehind__QAEXPAVPJZAKO___Z)(class State_GetPcBehind* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_GetPcBehind__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_GetPcBehind__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5f50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_GetPcBehind::Enter(class State_GetPcBehind* const this, class PJZAKO* arg2) [?Enter@State_GetPcBehind@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_GetPcBehind__UAEXPAVPJZAKO___Z)(class State_GetPcBehind* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_GetPcBehind__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_GetPcBehind__UAEXPAVPJZAKO___Z)(GameModule + 0x5dbaf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_GetPcBehind::Execute(class State_GetPcBehind* const this, class PJZAKO* arg2) [?Execute@State_GetPcBehind@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_GetPcBehind__UAEXPAVPJZAKO___Z)(class State_GetPcBehind* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_GetPcBehind__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_GetPcBehind__UAEXPAVPJZAKO___Z)(GameModule + 0x5dbd20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_GetPcBehind::Exit(class State_GetPcBehind* const this, class PJZAKO* arg2) [?Exit@State_GetPcBehind@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_GetPcBehind__UAEXPAVPJZAKO___Z)(class State_GetPcBehind* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_GetPcBehind__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_GetPcBehind__UAEXPAVPJZAKO___Z)(GameModule + 0x5dbe20);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_GetPcBehind [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_GetPcBehind& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_GetPcBehind, PJState>("State_GetPcBehind")
			.addFunction("__tostring", &State_GetPcBehind::ToString)
			.addFunction("GetPtrAddr", &State_GetPcBehind::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_GetPcBehind::ChangeStateCondition)
			.addFunction("Enter", &State_GetPcBehind::Enter)
			.addFunction("Execute", &State_GetPcBehind::Execute)
			.addFunction("Exit", &State_GetPcBehind::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_GetPcBehind) == 0x4, "expected State_GetPcBehind to be size 0x4");

// [Structure] class State_Debug
class State_Debug : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Debug::ChangeStateCondition(class State_Debug* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Debug@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Debug__QAEXPAVPJZAKO___Z)(class State_Debug* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Debug__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Debug__QAEXPAVPJZAKO___Z)(GameModule + 0x5d6060);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Debug::Enter(class State_Debug* const this, class PJZAKO* arg2) [?Enter@State_Debug@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Debug__UAEXPAVPJZAKO___Z)(class State_Debug* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Debug__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Debug__UAEXPAVPJZAKO___Z)(GameModule + 0x5db980);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Debug::Execute(class State_Debug* const this, class PJZAKO* arg2) [?Execute@State_Debug@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Debug__UAEXPAVPJZAKO___Z)(class State_Debug* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Debug__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Debug__UAEXPAVPJZAKO___Z)(GameModule + 0x5db990);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Debug::Exit(class State_Debug* const this, class PJZAKO* arg2) [?Exit@State_Debug@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Debug__UAEXPAVPJZAKO___Z)(class State_Debug* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Debug__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Debug__UAEXPAVPJZAKO___Z)(GameModule + 0x5db9d0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Debug [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Debug& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Debug, PJState>("State_Debug")
			.addFunction("__tostring", &State_Debug::ToString)
			.addFunction("GetPtrAddr", &State_Debug::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_Debug::ChangeStateCondition)
			.addFunction("Enter", &State_Debug::Enter)
			.addFunction("Execute", &State_Debug::Execute)
			.addFunction("Exit", &State_Debug::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Debug) == 0x4, "expected State_Debug to be size 0x4");

// [Structure] class State_Guard
class State_Guard : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Guard::ChangeStateCondition(class State_Guard* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Guard@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Guard__QAEXPAVPJZAKO___Z)(class State_Guard* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Guard__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Guard__QAEXPAVPJZAKO___Z)(GameModule + 0x5d6080);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Guard::Enter(class State_Guard* const this, class PJZAKO* arg2) [?Enter@State_Guard@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Guard__UAEXPAVPJZAKO___Z)(class State_Guard* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Guard__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Guard__UAEXPAVPJZAKO___Z)(GameModule + 0x5db5a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Guard::Execute(class State_Guard* const this, class PJZAKO* arg2) [?Execute@State_Guard@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Guard__UAEXPAVPJZAKO___Z)(class State_Guard* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Guard__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Guard__UAEXPAVPJZAKO___Z)(GameModule + 0x5db620);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Guard::Exit(class State_Guard* const this, class PJZAKO* arg2) [?Exit@State_Guard@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Guard__UAEXPAVPJZAKO___Z)(class State_Guard* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Guard__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Guard__UAEXPAVPJZAKO___Z)(GameModule + 0x5db8f0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Guard [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Guard& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Guard, PJState>("State_Guard")
			.addFunction("__tostring", &State_Guard::ToString)
			.addFunction("GetPtrAddr", &State_Guard::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_Guard::ChangeStateCondition)
			.addFunction("Enter", &State_Guard::Enter)
			.addFunction("Execute", &State_Guard::Execute)
			.addFunction("Exit", &State_Guard::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Guard) == 0x4, "expected State_Guard to be size 0x4");

// [Structure] class State_RunAway
class State_RunAway : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_RunAway::ChangeStateCondition(class State_RunAway* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_RunAway@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_RunAway__QAEXPAVPJZAKO___Z)(class State_RunAway* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_RunAway__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_RunAway__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7460);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_RunAway::Enter(class State_RunAway* const this, class PJZAKO* arg2) [?Enter@State_RunAway@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_RunAway__UAEXPAVPJZAKO___Z)(class State_RunAway* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_RunAway__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_RunAway__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9c50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_RunAway::Execute(class State_RunAway* const this, class PJZAKO* arg2) [?Execute@State_RunAway@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_RunAway__UAEXPAVPJZAKO___Z)(class State_RunAway* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_RunAway__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_RunAway__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9c60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_RunAway::Exit(class State_RunAway* const this, class PJZAKO* arg2) [?Exit@State_RunAway@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_RunAway__UAEXPAVPJZAKO___Z)(class State_RunAway* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_RunAway__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_RunAway__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9d50);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_RunAway [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_RunAway& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_RunAway, PJState>("State_RunAway")
			.addFunction("__tostring", &State_RunAway::ToString)
			.addFunction("GetPtrAddr", &State_RunAway::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_RunAway::ChangeStateCondition)
			.addFunction("Enter", &State_RunAway::Enter)
			.addFunction("Execute", &State_RunAway::Execute)
			.addFunction("Exit", &State_RunAway::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_RunAway) == 0x4, "expected State_RunAway to be size 0x4");

// [Structure] class State_Observ
class State_Observ : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Observ::ChangeStateCondition(class State_Observ* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Observ@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Observ__QAEXPAVPJZAKO___Z)(class State_Observ* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Observ__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Observ__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7ba0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Observ::Enter(class State_Observ* const this, class PJZAKO* arg2) [?Enter@State_Observ@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Observ__UAEXPAVPJZAKO___Z)(class State_Observ* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Observ__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Observ__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Observ::Execute(class State_Observ* const this, class PJZAKO* arg2) [?Execute@State_Observ@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Observ__UAEXPAVPJZAKO___Z)(class State_Observ* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Observ__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Observ__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8bd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Observ::Exit(class State_Observ* const this, class PJZAKO* arg2) [?Exit@State_Observ@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Observ__UAEXPAVPJZAKO___Z)(class State_Observ* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Observ__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Observ__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9080);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Observ [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Observ& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Observ, PJState>("State_Observ")
			.addFunction("__tostring", &State_Observ::ToString)
			.addFunction("GetPtrAddr", &State_Observ::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_Observ::ChangeStateCondition)
			.addFunction("Enter", &State_Observ::Enter)
			.addFunction("Execute", &State_Observ::Execute)
			.addFunction("Exit", &State_Observ::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Observ) == 0x4, "expected State_Observ to be size 0x4");

// [Structure] class State_PathFindToPc
class State_PathFindToPc : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_PathFindToPc::ChangeStateCondition(class State_PathFindToPc* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_PathFindToPc@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_PathFindToPc__QAEXPAVPJZAKO___Z)(class State_PathFindToPc* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_PathFindToPc__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_PathFindToPc__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7bc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_PathFindToPc::Enter(class State_PathFindToPc* const this, class PJZAKO* arg2) [?Enter@State_PathFindToPc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_PathFindToPc__UAEXPAVPJZAKO___Z)(class State_PathFindToPc* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_PathFindToPc__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_PathFindToPc__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8610);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_PathFindToPc::Execute(class State_PathFindToPc* const this, class PJZAKO* arg2) [?Execute@State_PathFindToPc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_PathFindToPc__UAEXPAVPJZAKO___Z)(class State_PathFindToPc* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_PathFindToPc__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_PathFindToPc__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8630);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_PathFindToPc::Exit(class State_PathFindToPc* const this, class PJZAKO* arg2) [?Exit@State_PathFindToPc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_PathFindToPc__UAEXPAVPJZAKO___Z)(class State_PathFindToPc* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_PathFindToPc__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_PathFindToPc__UAEXPAVPJZAKO___Z)(GameModule + 0x5d8750);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_PathFindToPc [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_PathFindToPc& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_PathFindToPc, PJState>("State_PathFindToPc")
			.addFunction("__tostring", &State_PathFindToPc::ToString)
			.addFunction("GetPtrAddr", &State_PathFindToPc::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_PathFindToPc::ChangeStateCondition)
			.addFunction("Enter", &State_PathFindToPc::Enter)
			.addFunction("Execute", &State_PathFindToPc::Execute)
			.addFunction("Exit", &State_PathFindToPc::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_PathFindToPc) == 0x4, "expected State_PathFindToPc to be size 0x4");

// [Structure] class State_UnderCtrl_Move
class State_UnderCtrl_Move : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_UnderCtrl_Move::ChangeStateCondition(class State_UnderCtrl_Move* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_UnderCtrl_Move@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_UnderCtrl_Move__QAEXPAVPJZAKO___Z)(class State_UnderCtrl_Move* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_UnderCtrl_Move__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_UnderCtrl_Move__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7d60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_UnderCtrl_Move::Enter(class State_UnderCtrl_Move* const this, class PJZAKO* arg2) [?Enter@State_UnderCtrl_Move@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z)(class State_UnderCtrl_Move* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z)(GameModule + 0x5dce10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_UnderCtrl_Move::Execute(class State_UnderCtrl_Move* const this, class PJZAKO* arg2) [?Execute@State_UnderCtrl_Move@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z)(class State_UnderCtrl_Move* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z)(GameModule + 0x5dce50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_UnderCtrl_Move::Exit(class State_UnderCtrl_Move* const this, class PJZAKO* arg2) [?Exit@State_UnderCtrl_Move@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z)(class State_UnderCtrl_Move* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_UnderCtrl_Move__UAEXPAVPJZAKO___Z)(GameModule + 0x5dce60);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_UnderCtrl_Move [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_UnderCtrl_Move& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_UnderCtrl_Move, PJState>("State_UnderCtrl_Move")
			.addFunction("__tostring", &State_UnderCtrl_Move::ToString)
			.addFunction("GetPtrAddr", &State_UnderCtrl_Move::GetPtrAddr)
			.addFunction("ChangeStateCondition", &State_UnderCtrl_Move::ChangeStateCondition)
			.addFunction("Enter", &State_UnderCtrl_Move::Enter)
			.addFunction("Execute", &State_UnderCtrl_Move::Execute)
			.addFunction("Exit", &State_UnderCtrl_Move::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_UnderCtrl_Move) == 0x4, "expected State_UnderCtrl_Move to be size 0x4");

// [Structure] class ZkState_FatBase_Defence
class ZkState_FatBase_Defence : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") ZkState_FatBase_Defence::ChangeStateCondition(class ZkState_FatBase_Defence* const this, class PJZAKO* arg2) [?ChangeStateCondition@ZkState_FatBase_Defence@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_ZkState_FatBase_Defence__QAEXPAVPJZAKO___Z)(class ZkState_FatBase_Defence* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_ZkState_FatBase_Defence__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_ZkState_FatBase_Defence__QAEXPAVPJZAKO___Z)(GameModule + 0x624660);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_FatBase_Defence::Enter(class ZkState_FatBase_Defence* const this, class PJZAKO* arg2) [?Enter@ZkState_FatBase_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z)(class ZkState_FatBase_Defence* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x624b30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_FatBase_Defence::Execute(class ZkState_FatBase_Defence* const this, class PJZAKO* arg2) [?Execute@ZkState_FatBase_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z)(class ZkState_FatBase_Defence* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x624b50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_FatBase_Defence::Exit(class ZkState_FatBase_Defence* const this, class PJZAKO* arg2) [?Exit@ZkState_FatBase_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z)(class ZkState_FatBase_Defence* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkState_FatBase_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x624d70);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_FatBase_Defence [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_FatBase_Defence& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_FatBase_Defence, PJState>("ZkState_FatBase_Defence")
			.addFunction("__tostring", &ZkState_FatBase_Defence::ToString)
			.addFunction("GetPtrAddr", &ZkState_FatBase_Defence::GetPtrAddr)
			.addFunction("ChangeStateCondition", &ZkState_FatBase_Defence::ChangeStateCondition)
			.addFunction("Enter", &ZkState_FatBase_Defence::Enter)
			.addFunction("Execute", &ZkState_FatBase_Defence::Execute)
			.addFunction("Exit", &ZkState_FatBase_Defence::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_FatBase_Defence) == 0x4, "expected ZkState_FatBase_Defence to be size 0x4");

// [Structure] class State_Tojo_RoomRunner
class State_Tojo_RoomRunner : public State_TojoBaseState
{
public:
	// enum State_Tojo_RoomRunner::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_Ready = 0x1>
		eStat_Ready = 1

	};

	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_RoomRunner::eStat m_eStat, offset 0x4>
	enum State_Tojo_RoomRunner::eStat m_eStat;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_RoomRunner::Enter(class State_Tojo_RoomRunner* const this, class PJZAKO* arg2) [?Enter@State_Tojo_RoomRunner@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z)(class State_Tojo_RoomRunner* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z)(GameModule + 0x5ded70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_RoomRunner::Execute(class State_Tojo_RoomRunner* const this, class PJZAKO* arg2) [?Execute@State_Tojo_RoomRunner@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z)(class State_Tojo_RoomRunner* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z)(GameModule + 0x5dede0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_RoomRunner::Exit(class State_Tojo_RoomRunner* const this, class PJZAKO* arg2) [?Exit@State_Tojo_RoomRunner@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z)(class State_Tojo_RoomRunner* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z)(GameModule + 0x5df010);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_RoomRunner::ChangeStateCondition(class State_Tojo_RoomRunner* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_RoomRunner@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z)(class State_Tojo_RoomRunner* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_RoomRunner__UAEXPAVPJZAKO___Z)(GameModule + 0x5df030);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_RoomRunner [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_RoomRunner& InObject)
	{
		m_eStat = InObject.m_eStat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_RoomRunner, State_TojoBaseState>("State_Tojo_RoomRunner")
			.addFunction("__tostring", &State_Tojo_RoomRunner::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_RoomRunner::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_RoomRunner::m_eStat)
			.addFunction("Enter", &State_Tojo_RoomRunner::Enter)
			.addFunction("Execute", &State_Tojo_RoomRunner::Execute)
			.addFunction("Exit", &State_Tojo_RoomRunner::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_RoomRunner::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_RoomRunner::m_eStat) == 4, "expected State_Tojo_RoomRunner::m_eStat to be size 4");
static_assert(sizeof(State_Tojo_RoomRunner) == 0x8, "expected State_Tojo_RoomRunner to be size 0x8");

// [Structure] class State_Tojo_AeroBike
class State_Tojo_AeroBike : public State_TojoBaseState
{
public:
	// enum State_Tojo_AeroBike::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_Ready = 0x1>
		eStat_Ready = 1

	};

	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_AeroBike::eStat m_eStat, offset 0x4>
	enum State_Tojo_AeroBike::eStat m_eStat;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_AeroBike::Enter(class State_Tojo_AeroBike* const this, class PJZAKO* arg2) [?Enter@State_Tojo_AeroBike@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z)(class State_Tojo_AeroBike* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z)(GameModule + 0x5dea70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_AeroBike::Execute(class State_Tojo_AeroBike* const this, class PJZAKO* arg2) [?Execute@State_Tojo_AeroBike@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z)(class State_Tojo_AeroBike* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z)(GameModule + 0x5deae0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_AeroBike::Exit(class State_Tojo_AeroBike* const this, class PJZAKO* arg2) [?Exit@State_Tojo_AeroBike@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z)(class State_Tojo_AeroBike* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z)(GameModule + 0x5ded40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_AeroBike::ChangeStateCondition(class State_Tojo_AeroBike* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_AeroBike@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z)(class State_Tojo_AeroBike* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_AeroBike__UAEXPAVPJZAKO___Z)(GameModule + 0x5ded60);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_AeroBike [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_AeroBike& InObject)
	{
		m_eStat = InObject.m_eStat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_AeroBike, State_TojoBaseState>("State_Tojo_AeroBike")
			.addFunction("__tostring", &State_Tojo_AeroBike::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_AeroBike::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_AeroBike::m_eStat)
			.addFunction("Enter", &State_Tojo_AeroBike::Enter)
			.addFunction("Execute", &State_Tojo_AeroBike::Execute)
			.addFunction("Exit", &State_Tojo_AeroBike::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_AeroBike::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_AeroBike::m_eStat) == 4, "expected State_Tojo_AeroBike::m_eStat to be size 4");
static_assert(sizeof(State_Tojo_AeroBike) == 0x8, "expected State_Tojo_AeroBike to be size 0x8");

// [Structure] class State_Tojo_BreakCmnObj
class State_Tojo_BreakCmnObj : public State_TojoBaseState
{
public:
	// enum State_Tojo_BreakCmnObj::eStat
	enum eStat : uint32_t
	{
		// <eStat_WaitBreak = 0x0>
		eStat_WaitBreak = 0,

		// <eStat_BreakMotionPlay = 0x1>
		eStat_BreakMotionPlay = 1

	};

	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_BreakCmnObj::eStat m_eStat, offset 0x4>
	enum State_Tojo_BreakCmnObj::eStat m_eStat;

	// <uint8_t m_boAttacked, offset 0x8>
	uint8_t m_boAttacked = 0;

	// <Unidentified data segment, offset 0x9>
private:
	char _UnidentifiedData_9[3];

public:
	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_BreakCmnObj::Enter(class State_Tojo_BreakCmnObj* const this, class PJZAKO* arg2) [?Enter@State_Tojo_BreakCmnObj@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z)(class State_Tojo_BreakCmnObj* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z)(GameModule + 0x5de8c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_BreakCmnObj::Execute(class State_Tojo_BreakCmnObj* const this, class PJZAKO* arg2) [?Execute@State_Tojo_BreakCmnObj@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z)(class State_Tojo_BreakCmnObj* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z)(GameModule + 0x5de930);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_BreakCmnObj::Exit(class State_Tojo_BreakCmnObj* const this, class PJZAKO* arg2) [?Exit@State_Tojo_BreakCmnObj@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z)(class State_Tojo_BreakCmnObj* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z)(GameModule + 0x5dea50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_BreakCmnObj::ChangeStateCondition(class State_Tojo_BreakCmnObj* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_BreakCmnObj@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z)(class State_Tojo_BreakCmnObj* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_BreakCmnObj__UAEXPAVPJZAKO___Z)(GameModule + 0x5dea60);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_BreakCmnObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_BreakCmnObj& InObject)
	{
		m_eStat = InObject.m_eStat;
		m_boAttacked = InObject.m_boAttacked;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_BreakCmnObj, State_TojoBaseState>("State_Tojo_BreakCmnObj")
			.addFunction("__tostring", &State_Tojo_BreakCmnObj::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_BreakCmnObj::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_BreakCmnObj::m_eStat)
			.addProperty("m_boAttacked", &State_Tojo_BreakCmnObj::m_boAttacked)
			.addFunction("Enter", &State_Tojo_BreakCmnObj::Enter)
			.addFunction("Execute", &State_Tojo_BreakCmnObj::Execute)
			.addFunction("Exit", &State_Tojo_BreakCmnObj::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_BreakCmnObj::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_BreakCmnObj::m_eStat) == 4, "expected State_Tojo_BreakCmnObj::m_eStat to be size 4");
static_assert(sizeof(State_Tojo_BreakCmnObj::m_boAttacked) == 1, "expected State_Tojo_BreakCmnObj::m_boAttacked to be size 1");
static_assert(sizeof(State_Tojo_BreakCmnObj) == 0xc, "expected State_Tojo_BreakCmnObj to be size 0xc");

// [Structure] class State_Tojo_JumpOff
class State_Tojo_JumpOff : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <float m_fSpdY, offset 0x4>
	float m_fSpdY = 0;

	/// 5 Functions

	// [Function] void __convention("thiscall") State_Tojo_JumpOff::RotateToLandingPos(class State_Tojo_JumpOff* const this, class PJZAKO* arg2) [?RotateToLandingPos@State_Tojo_JumpOff@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _RotateToLandingPos_State_Tojo_JumpOff__QAEXPAVPJZAKO___Z)(class State_Tojo_JumpOff* const thisPtr, class PJZAKO* arg2);
	void RotateToLandingPos(class PJZAKO* arg2)
	{
		_RotateToLandingPos_State_Tojo_JumpOff__QAEXPAVPJZAKO___Z mFunc = (_RotateToLandingPos_State_Tojo_JumpOff__QAEXPAVPJZAKO___Z)(GameModule + 0x5d59a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_JumpOff::Enter(class State_Tojo_JumpOff* const this, class PJZAKO* arg2) [?Enter@State_Tojo_JumpOff@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z)(class State_Tojo_JumpOff* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z)(GameModule + 0x5de3c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_JumpOff::Execute(class State_Tojo_JumpOff* const this, class PJZAKO* arg2) [?Execute@State_Tojo_JumpOff@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z)(class State_Tojo_JumpOff* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z)(GameModule + 0x5de440);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_JumpOff::Exit(class State_Tojo_JumpOff* const this, class PJZAKO* arg2) [?Exit@State_Tojo_JumpOff@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z)(class State_Tojo_JumpOff* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z)(GameModule + 0x5de7e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_JumpOff::ChangeStateCondition(class State_Tojo_JumpOff* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_JumpOff@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z)(class State_Tojo_JumpOff* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_JumpOff__UAEXPAVPJZAKO___Z)(GameModule + 0x5de8b0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_JumpOff [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_JumpOff& InObject)
	{
		m_fSpdY = InObject.m_fSpdY;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_JumpOff, State_TojoBaseState>("State_Tojo_JumpOff")
			.addFunction("__tostring", &State_Tojo_JumpOff::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_JumpOff::GetPtrAddr)
			.addProperty("m_fSpdY", &State_Tojo_JumpOff::m_fSpdY)
			.addFunction("RotateToLandingPos", &State_Tojo_JumpOff::RotateToLandingPos)
			.addFunction("Enter", &State_Tojo_JumpOff::Enter)
			.addFunction("Execute", &State_Tojo_JumpOff::Execute)
			.addFunction("Exit", &State_Tojo_JumpOff::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_JumpOff::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_JumpOff::m_fSpdY) == 4, "expected State_Tojo_JumpOff::m_fSpdY to be size 4");
static_assert(sizeof(State_Tojo_JumpOff) == 0x8, "expected State_Tojo_JumpOff to be size 0x8");

// [Structure] class State_Tojo_Car
class State_Tojo_Car : public State_TojoBaseState
{
public:
	// enum State_Tojo_Car::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_GetOff = 0x1>
		eStat_GetOff = 1

	};

	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_Car::eStat m_eStat, offset 0x4>
	enum State_Tojo_Car::eStat m_eStat;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_Car::Enter(class State_Tojo_Car* const this, class PJZAKO* arg2) [?Enter@State_Tojo_Car@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_Car__UAEXPAVPJZAKO___Z)(class State_Tojo_Car* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_Car__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_Car__UAEXPAVPJZAKO___Z)(GameModule + 0x5de230);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Car::Execute(class State_Tojo_Car* const this, class PJZAKO* arg2) [?Execute@State_Tojo_Car@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_Car__UAEXPAVPJZAKO___Z)(class State_Tojo_Car* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_Car__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_Car__UAEXPAVPJZAKO___Z)(GameModule + 0x5de2a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Car::Exit(class State_Tojo_Car* const this, class PJZAKO* arg2) [?Exit@State_Tojo_Car@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_Car__UAEXPAVPJZAKO___Z)(class State_Tojo_Car* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_Car__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_Car__UAEXPAVPJZAKO___Z)(GameModule + 0x5de390);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Car::ChangeStateCondition(class State_Tojo_Car* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_Car@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_Car__UAEXPAVPJZAKO___Z)(class State_Tojo_Car* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_Car__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_Car__UAEXPAVPJZAKO___Z)(GameModule + 0x5de3b0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_Car [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_Car& InObject)
	{
		m_eStat = InObject.m_eStat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Car, State_TojoBaseState>("State_Tojo_Car")
			.addFunction("__tostring", &State_Tojo_Car::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Car::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_Car::m_eStat)
			.addFunction("Enter", &State_Tojo_Car::Enter)
			.addFunction("Execute", &State_Tojo_Car::Execute)
			.addFunction("Exit", &State_Tojo_Car::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_Car::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Car::m_eStat) == 4, "expected State_Tojo_Car::m_eStat to be size 4");
static_assert(sizeof(State_Tojo_Car) == 0x8, "expected State_Tojo_Car to be size 0x8");

// [Structure] class State_Tojo_RunAndTurnPc
class State_Tojo_RunAndTurnPc : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_RunAndTurnPc::Enter(class State_Tojo_RunAndTurnPc* const this, class PJZAKO* arg2) [?Enter@State_Tojo_RunAndTurnPc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z)(class State_Tojo_RunAndTurnPc* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd820);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_RunAndTurnPc::Execute(class State_Tojo_RunAndTurnPc* const this, class PJZAKO* arg2) [?Execute@State_Tojo_RunAndTurnPc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z)(class State_Tojo_RunAndTurnPc* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd890);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_RunAndTurnPc::Exit(class State_Tojo_RunAndTurnPc* const this, class PJZAKO* arg2) [?Exit@State_Tojo_RunAndTurnPc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z)(class State_Tojo_RunAndTurnPc* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z)(GameModule + 0x5dda90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_RunAndTurnPc::ChangeStateCondition(class State_Tojo_RunAndTurnPc* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_RunAndTurnPc@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z)(class State_Tojo_RunAndTurnPc* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_RunAndTurnPc__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddaa0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_RunAndTurnPc [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_RunAndTurnPc& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_RunAndTurnPc, State_TojoBaseState>("State_Tojo_RunAndTurnPc")
			.addFunction("__tostring", &State_Tojo_RunAndTurnPc::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_RunAndTurnPc::GetPtrAddr)
			.addFunction("Enter", &State_Tojo_RunAndTurnPc::Enter)
			.addFunction("Execute", &State_Tojo_RunAndTurnPc::Execute)
			.addFunction("Exit", &State_Tojo_RunAndTurnPc::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_RunAndTurnPc::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_RunAndTurnPc) == 0x4, "expected State_Tojo_RunAndTurnPc to be size 0x4");

// [Structure] class State_Idle
class State_Idle : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	/// 5 Functions

	// [Function] uint8_t __convention("thiscall") State_Idle::IsEnableReleaseIdleState(class State_Idle* const this, class PJZAKO* arg2) [?IsEnableReleaseIdleState@State_Idle@@QAE_NPAVPJZAKO@@@Z]
	typedef uint8_t(__thiscall* _IsEnableReleaseIdleState_State_Idle__QAE_NPAVPJZAKO___Z)(class State_Idle* const thisPtr, class PJZAKO* arg2);
	uint8_t IsEnableReleaseIdleState(class PJZAKO* arg2)
	{
		_IsEnableReleaseIdleState_State_Idle__QAE_NPAVPJZAKO___Z mFunc = (_IsEnableReleaseIdleState_State_Idle__QAE_NPAVPJZAKO___Z)(GameModule + 0x5d7ce0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Idle::Enter(class State_Idle* const this, class PJZAKO* arg2) [?Enter@State_Idle@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Idle__UAEXPAVPJZAKO___Z)(class State_Idle* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Idle__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Idle__UAEXPAVPJZAKO___Z)(GameModule + 0x5df040);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Idle::Execute(class State_Idle* const this, class PJZAKO* arg2) [?Execute@State_Idle@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Idle__UAEXPAVPJZAKO___Z)(class State_Idle* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Idle__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Idle__UAEXPAVPJZAKO___Z)(GameModule + 0x5df090);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Idle::Exit(class State_Idle* const this, class PJZAKO* arg2) [?Exit@State_Idle@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Idle__UAEXPAVPJZAKO___Z)(class State_Idle* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Idle__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Idle__UAEXPAVPJZAKO___Z)(GameModule + 0x5df210);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Idle::ChangeStateCondition(class State_Idle* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Idle@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Idle__UAEXPAVPJZAKO___Z)(class State_Idle* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Idle__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Idle__UAEXPAVPJZAKO___Z)(GameModule + 0x5df230);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Idle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Idle& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Idle, State_TojoBaseState>("State_Idle")
			.addFunction("__tostring", &State_Idle::ToString)
			.addFunction("GetPtrAddr", &State_Idle::GetPtrAddr)
			.addFunction("IsEnableReleaseIdleState", &State_Idle::IsEnableReleaseIdleState)
			.addFunction("Enter", &State_Idle::Enter)
			.addFunction("Execute", &State_Idle::Execute)
			.addFunction("Exit", &State_Idle::Exit)
			.addFunction("ChangeStateCondition", &State_Idle::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Idle) == 0x4, "expected State_Idle to be size 0x4");

// [Structure] class State_Tojo_AgainstWall
class State_Tojo_AgainstWall : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_AgainstWall::Enter(class State_Tojo_AgainstWall* const this, class PJZAKO* arg2) [?Enter@State_Tojo_AgainstWall@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z)(class State_Tojo_AgainstWall* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddab0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_AgainstWall::Execute(class State_Tojo_AgainstWall* const this, class PJZAKO* arg2) [?Execute@State_Tojo_AgainstWall@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z)(class State_Tojo_AgainstWall* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddb10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_AgainstWall::Exit(class State_Tojo_AgainstWall* const this, class PJZAKO* arg2) [?Exit@State_Tojo_AgainstWall@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z)(class State_Tojo_AgainstWall* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddc00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_AgainstWall::ChangeStateCondition(class State_Tojo_AgainstWall* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_AgainstWall@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z)(class State_Tojo_AgainstWall* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_AgainstWall__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddc10);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_AgainstWall [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_AgainstWall& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_AgainstWall, State_TojoBaseState>("State_Tojo_AgainstWall")
			.addFunction("__tostring", &State_Tojo_AgainstWall::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_AgainstWall::GetPtrAddr)
			.addFunction("Enter", &State_Tojo_AgainstWall::Enter)
			.addFunction("Execute", &State_Tojo_AgainstWall::Execute)
			.addFunction("Exit", &State_Tojo_AgainstWall::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_AgainstWall::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_AgainstWall) == 0x4, "expected State_Tojo_AgainstWall to be size 0x4");

// [Structure] class State_Tojo_LookAround
class State_Tojo_LookAround : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_LookAround::Enter(class State_Tojo_LookAround* const this, class PJZAKO* arg2) [?Enter@State_Tojo_LookAround@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_LookAround__UAEXPAVPJZAKO___Z)(class State_Tojo_LookAround* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_LookAround__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_LookAround__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddc20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_LookAround::Execute(class State_Tojo_LookAround* const this, class PJZAKO* arg2) [?Execute@State_Tojo_LookAround@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_LookAround__UAEXPAVPJZAKO___Z)(class State_Tojo_LookAround* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_LookAround__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_LookAround__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddc80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_LookAround::Exit(class State_Tojo_LookAround* const this, class PJZAKO* arg2) [?Exit@State_Tojo_LookAround@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_LookAround__UAEXPAVPJZAKO___Z)(class State_Tojo_LookAround* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_LookAround__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_LookAround__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddd70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_LookAround::ChangeStateCondition(class State_Tojo_LookAround* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_LookAround@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_LookAround__UAEXPAVPJZAKO___Z)(class State_Tojo_LookAround* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_LookAround__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_LookAround__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddd80);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_LookAround [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_LookAround& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_LookAround, State_TojoBaseState>("State_Tojo_LookAround")
			.addFunction("__tostring", &State_Tojo_LookAround::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_LookAround::GetPtrAddr)
			.addFunction("Enter", &State_Tojo_LookAround::Enter)
			.addFunction("Execute", &State_Tojo_LookAround::Execute)
			.addFunction("Exit", &State_Tojo_LookAround::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_LookAround::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_LookAround) == 0x4, "expected State_Tojo_LookAround to be size 0x4");

// [Structure] class State_Tojo_Stand
class State_Tojo_Stand : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_Stand::Enter(class State_Tojo_Stand* const this, class PJZAKO* arg2) [?Enter@State_Tojo_Stand@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_Stand__UAEXPAVPJZAKO___Z)(class State_Tojo_Stand* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_Stand__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_Stand__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddd90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Stand::Execute(class State_Tojo_Stand* const this, class PJZAKO* arg2) [?Execute@State_Tojo_Stand@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_Stand__UAEXPAVPJZAKO___Z)(class State_Tojo_Stand* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_Stand__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_Stand__UAEXPAVPJZAKO___Z)(GameModule + 0x5dddf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Stand::Exit(class State_Tojo_Stand* const this, class PJZAKO* arg2) [?Exit@State_Tojo_Stand@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_Stand__UAEXPAVPJZAKO___Z)(class State_Tojo_Stand* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_Stand__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_Stand__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddee0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Stand::ChangeStateCondition(class State_Tojo_Stand* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_Stand@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_Stand__UAEXPAVPJZAKO___Z)(class State_Tojo_Stand* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_Stand__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_Stand__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddef0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_Stand [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_Stand& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Stand, State_TojoBaseState>("State_Tojo_Stand")
			.addFunction("__tostring", &State_Tojo_Stand::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Stand::GetPtrAddr)
			.addFunction("Enter", &State_Tojo_Stand::Enter)
			.addFunction("Execute", &State_Tojo_Stand::Execute)
			.addFunction("Exit", &State_Tojo_Stand::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_Stand::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Stand) == 0x4, "expected State_Tojo_Stand to be size 0x4");

// [Structure] class State_Tojo_Bench
class State_Tojo_Bench : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_Bench::Enter(class State_Tojo_Bench* const this, class PJZAKO* arg2) [?Enter@State_Tojo_Bench@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_Bench__UAEXPAVPJZAKO___Z)(class State_Tojo_Bench* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_Bench__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_Bench__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddf00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Bench::Execute(class State_Tojo_Bench* const this, class PJZAKO* arg2) [?Execute@State_Tojo_Bench@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_Bench__UAEXPAVPJZAKO___Z)(class State_Tojo_Bench* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_Bench__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_Bench__UAEXPAVPJZAKO___Z)(GameModule + 0x5ddfc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Bench::Exit(class State_Tojo_Bench* const this, class PJZAKO* arg2) [?Exit@State_Tojo_Bench@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_Bench__UAEXPAVPJZAKO___Z)(class State_Tojo_Bench* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_Bench__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_Bench__UAEXPAVPJZAKO___Z)(GameModule + 0x5de0a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Bench::ChangeStateCondition(class State_Tojo_Bench* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_Bench@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_Bench__UAEXPAVPJZAKO___Z)(class State_Tojo_Bench* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_Bench__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_Bench__UAEXPAVPJZAKO___Z)(GameModule + 0x5de0c0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_Bench [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_Bench& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Bench, State_TojoBaseState>("State_Tojo_Bench")
			.addFunction("__tostring", &State_Tojo_Bench::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Bench::GetPtrAddr)
			.addFunction("Enter", &State_Tojo_Bench::Enter)
			.addFunction("Execute", &State_Tojo_Bench::Execute)
			.addFunction("Exit", &State_Tojo_Bench::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_Bench::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Bench) == 0x4, "expected State_Tojo_Bench to be size 0x4");

// [Structure] class State_Tojo_Sit
class State_Tojo_Sit : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_Sit::Enter(class State_Tojo_Sit* const this, class PJZAKO* arg2) [?Enter@State_Tojo_Sit@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_Sit__UAEXPAVPJZAKO___Z)(class State_Tojo_Sit* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_Sit__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_Sit__UAEXPAVPJZAKO___Z)(GameModule + 0x5de0d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Sit::Execute(class State_Tojo_Sit* const this, class PJZAKO* arg2) [?Execute@State_Tojo_Sit@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_Sit__UAEXPAVPJZAKO___Z)(class State_Tojo_Sit* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_Sit__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_Sit__UAEXPAVPJZAKO___Z)(GameModule + 0x5de130);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Sit::Exit(class State_Tojo_Sit* const this, class PJZAKO* arg2) [?Exit@State_Tojo_Sit@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_Sit__UAEXPAVPJZAKO___Z)(class State_Tojo_Sit* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_Sit__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_Sit__UAEXPAVPJZAKO___Z)(GameModule + 0x5de210);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Sit::ChangeStateCondition(class State_Tojo_Sit* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_Sit@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_Sit__UAEXPAVPJZAKO___Z)(class State_Tojo_Sit* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_Sit__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_Sit__UAEXPAVPJZAKO___Z)(GameModule + 0x5de220);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_Sit [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_Sit& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Sit, State_TojoBaseState>("State_Tojo_Sit")
			.addFunction("__tostring", &State_Tojo_Sit::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Sit::GetPtrAddr)
			.addFunction("Enter", &State_Tojo_Sit::Enter)
			.addFunction("Execute", &State_Tojo_Sit::Execute)
			.addFunction("Exit", &State_Tojo_Sit::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_Sit::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Sit) == 0x4, "expected State_Tojo_Sit to be size 0x4");

// [Structure] class State_Tojo_SuddenAttack
class State_Tojo_SuddenAttack : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_SuddenAttack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_SuddenAttack& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_SuddenAttack, State_TojoBaseState>("State_Tojo_SuddenAttack")
			.addFunction("__tostring", &State_Tojo_SuddenAttack::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_SuddenAttack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_SuddenAttack) == 0x4, "expected State_Tojo_SuddenAttack to be size 0x4");

// [Structure] class State_ReleaseWaitIdle
class State_ReleaseWaitIdle : public State_Idle
{
public:
	/// Struct member variables

	// <class State_Idle field_0, offset 0x0>
	// class State_Idle Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_ReleaseWaitIdle::Enter(class State_ReleaseWaitIdle* const this, class PJZAKO* arg2) [?Enter@State_ReleaseWaitIdle@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z)(class State_ReleaseWaitIdle* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z)(GameModule + 0x5df240);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ReleaseWaitIdle::Execute(class State_ReleaseWaitIdle* const this, class PJZAKO* arg2) [?Execute@State_ReleaseWaitIdle@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z)(class State_ReleaseWaitIdle* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z)(GameModule + 0x5df290);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ReleaseWaitIdle::Exit(class State_ReleaseWaitIdle* const this, class PJZAKO* arg2) [?Exit@State_ReleaseWaitIdle@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z)(class State_ReleaseWaitIdle* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z)(GameModule + 0x5df2f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ReleaseWaitIdle::ChangeStateCondition(class State_ReleaseWaitIdle* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_ReleaseWaitIdle@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z)(class State_ReleaseWaitIdle* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_ReleaseWaitIdle__UAEXPAVPJZAKO___Z)(GameModule + 0x5df310);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_ReleaseWaitIdle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_ReleaseWaitIdle& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_ReleaseWaitIdle, State_Idle>("State_ReleaseWaitIdle")
			.addFunction("__tostring", &State_ReleaseWaitIdle::ToString)
			.addFunction("GetPtrAddr", &State_ReleaseWaitIdle::GetPtrAddr)
			.addFunction("Enter", &State_ReleaseWaitIdle::Enter)
			.addFunction("Execute", &State_ReleaseWaitIdle::Execute)
			.addFunction("Exit", &State_ReleaseWaitIdle::Exit)
			.addFunction("ChangeStateCondition", &State_ReleaseWaitIdle::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ReleaseWaitIdle) == 0x4, "expected State_ReleaseWaitIdle to be size 0x4");

// [Structure] class State_Scare_Base
class State_Scare_Base : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_Cnt, offset 0x4>
	int32_t m_Cnt = 0;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Scare_Base::Exit(class State_Scare_Base* const this, class PJZAKO* arg2) [?Exit@State_Scare_Base@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Scare_Base__UAEXPAVPJZAKO___Z)(class State_Scare_Base* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Scare_Base__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Scare_Base__UAEXPAVPJZAKO___Z)(GameModule + 0x5d5a90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Base::ChangeStateCondition(class State_Scare_Base* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Scare_Base@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Scare_Base__UAEXPAVPJZAKO___Z)(class State_Scare_Base* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Scare_Base__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Scare_Base__UAEXPAVPJZAKO___Z)(GameModule + 0x5d5ab0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Base::Enter(class State_Scare_Base* const this, class PJZAKO* arg2) [?Enter@State_Scare_Base@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Scare_Base__UAEXPAVPJZAKO___Z)(class State_Scare_Base* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Scare_Base__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Scare_Base__UAEXPAVPJZAKO___Z)(GameModule + 0x5d5b70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Base::Execute(class State_Scare_Base* const this, class PJZAKO* arg2) [?Execute@State_Scare_Base@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Scare_Base__UAEXPAVPJZAKO___Z)(class State_Scare_Base* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Scare_Base__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Scare_Base__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd120);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Scare_Base [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Scare_Base& InObject)
	{
		m_Cnt = InObject.m_Cnt;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Base, PJState>("State_Scare_Base")
			.addFunction("__tostring", &State_Scare_Base::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Base::GetPtrAddr)
			.addProperty("m_Cnt", &State_Scare_Base::m_Cnt)
			.addFunction("Exit", &State_Scare_Base::Exit)
			.addFunction("ChangeStateCondition", &State_Scare_Base::ChangeStateCondition)
			.addFunction("Enter", &State_Scare_Base::Enter)
			.addFunction("Execute", &State_Scare_Base::Execute)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Base::m_Cnt) == 4, "expected State_Scare_Base::m_Cnt to be size 4");
static_assert(sizeof(State_Scare_Base) == 0x8, "expected State_Scare_Base to be size 0x8");

// [Structure] class State_Scare_Kosinukasi
class State_Scare_Kosinukasi : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Scare_Kosinukasi::Enter(class State_Scare_Kosinukasi* const this, class PJZAKO* arg2) [?Enter@State_Scare_Kosinukasi@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z)(class State_Scare_Kosinukasi* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd270);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Kosinukasi::Execute(class State_Scare_Kosinukasi* const this, class PJZAKO* arg2) [?Execute@State_Scare_Kosinukasi@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z)(class State_Scare_Kosinukasi* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd2e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Kosinukasi::Exit(class State_Scare_Kosinukasi* const this, class PJZAKO* arg2) [?Exit@State_Scare_Kosinukasi@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z)(class State_Scare_Kosinukasi* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd380);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Kosinukasi::ChangeStateCondition(class State_Scare_Kosinukasi* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Scare_Kosinukasi@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z)(class State_Scare_Kosinukasi* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Scare_Kosinukasi__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd3a0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Scare_Kosinukasi [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Scare_Kosinukasi& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Kosinukasi, State_Scare_Base>("State_Scare_Kosinukasi")
			.addFunction("__tostring", &State_Scare_Kosinukasi::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Kosinukasi::GetPtrAddr)
			.addFunction("Enter", &State_Scare_Kosinukasi::Enter)
			.addFunction("Execute", &State_Scare_Kosinukasi::Execute)
			.addFunction("Exit", &State_Scare_Kosinukasi::Exit)
			.addFunction("ChangeStateCondition", &State_Scare_Kosinukasi::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Kosinukasi) == 0x8, "expected State_Scare_Kosinukasi to be size 0x8");

// [Structure] class State_Scare_Run
class State_Scare_Run : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Scare_Run::Enter(class State_Scare_Run* const this, class PJZAKO* arg2) [?Enter@State_Scare_Run@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Scare_Run__UAEXPAVPJZAKO___Z)(class State_Scare_Run* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Scare_Run__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Scare_Run__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd130);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Run::Execute(class State_Scare_Run* const this, class PJZAKO* arg2) [?Execute@State_Scare_Run@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Scare_Run__UAEXPAVPJZAKO___Z)(class State_Scare_Run* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Scare_Run__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Scare_Run__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd1a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Run::Exit(class State_Scare_Run* const this, class PJZAKO* arg2) [?Exit@State_Scare_Run@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Scare_Run__UAEXPAVPJZAKO___Z)(class State_Scare_Run* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Scare_Run__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Scare_Run__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd240);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Run::ChangeStateCondition(class State_Scare_Run* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Scare_Run@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Scare_Run__UAEXPAVPJZAKO___Z)(class State_Scare_Run* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Scare_Run__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Scare_Run__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd260);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Scare_Run [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Scare_Run& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Run, State_Scare_Base>("State_Scare_Run")
			.addFunction("__tostring", &State_Scare_Run::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Run::GetPtrAddr)
			.addFunction("Enter", &State_Scare_Run::Enter)
			.addFunction("Execute", &State_Scare_Run::Execute)
			.addFunction("Exit", &State_Scare_Run::Exit)
			.addFunction("ChangeStateCondition", &State_Scare_Run::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Run) == 0x8, "expected State_Scare_Run to be size 0x8");

// [Structure] class State_WayPointMove
class State_WayPointMove : public PJState
{
public:
	// enum State_WayPointMove::eWaypointSbSt
	enum eWaypointSbSt : uint32_t
	{
		// <eWaypointSbSt_UNKNOWN = 0xffffffffffffffff>
		eWaypointSbSt_UNKNOWN = UINT32_MAX,

		// <eWaypointSbSt_WayPoint = 0x0>
		eWaypointSbSt_WayPoint = 0,

		// <eWaypointSbSt_ClosePc = 0x1>
		eWaypointSbSt_ClosePc = 1

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_WayPointMove::eWaypointSbSt m_eStat, offset 0x4>
	enum State_WayPointMove::eWaypointSbSt m_eStat;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_WayPointMove::ChangeStateCondition(class State_WayPointMove* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_WayPointMove@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_WayPointMove__QAEXPAVPJZAKO___Z)(class State_WayPointMove* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_WayPointMove__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_WayPointMove__QAEXPAVPJZAKO___Z)(GameModule + 0x5d6050);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_WayPointMove::Enter(class State_WayPointMove* const this, class PJZAKO* arg2) [?Enter@State_WayPointMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_WayPointMove__UAEXPAVPJZAKO___Z)(class State_WayPointMove* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_WayPointMove__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_WayPointMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5db9e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_WayPointMove::Execute(class State_WayPointMove* const this, class PJZAKO* arg2) [?Execute@State_WayPointMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_WayPointMove__UAEXPAVPJZAKO___Z)(class State_WayPointMove* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_WayPointMove__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_WayPointMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5dba00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_WayPointMove::Exit(class State_WayPointMove* const this, class PJZAKO* arg2) [?Exit@State_WayPointMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_WayPointMove__UAEXPAVPJZAKO___Z)(class State_WayPointMove* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_WayPointMove__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_WayPointMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5dbae0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_WayPointMove [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_WayPointMove& InObject)
	{
		m_eStat = InObject.m_eStat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_WayPointMove, PJState>("State_WayPointMove")
			.addFunction("__tostring", &State_WayPointMove::ToString)
			.addFunction("GetPtrAddr", &State_WayPointMove::GetPtrAddr)
			.addProperty("m_eStat", &State_WayPointMove::m_eStat)
			.addFunction("ChangeStateCondition", &State_WayPointMove::ChangeStateCondition)
			.addFunction("Enter", &State_WayPointMove::Enter)
			.addFunction("Execute", &State_WayPointMove::Execute)
			.addFunction("Exit", &State_WayPointMove::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_WayPointMove::m_eStat) == 4, "expected State_WayPointMove::m_eStat to be size 4");
static_assert(sizeof(State_WayPointMove) == 0x8, "expected State_WayPointMove to be size 0x8");

// [Structure] class State_Pressure
class State_Pressure : public PJState
{
public:
	// enum State_Pressure::eStat
	enum eStat : uint32_t
	{
		// <eStat_CLOSE = 0x0>
		eStat_CLOSE = 0,

		// <eStat_WAIT = 0x1>
		eStat_WAIT = 1,

		// <eStat_AWAY = 0x2>
		eStat_AWAY = 2

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_Pressure::eStat m_eStat, offset 0x4>
	enum State_Pressure::eStat m_eStat;

	// <int32_t m_WaitCnt, offset 0x8>
	int32_t m_WaitCnt = 0;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Pressure::ChangeStateCondition(class State_Pressure* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Pressure@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Pressure__QAEXPAVPJZAKO___Z)(class State_Pressure* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Pressure__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Pressure__QAEXPAVPJZAKO___Z)(GameModule + 0x5d5bf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Pressure::Enter(class State_Pressure* const this, class PJZAKO* arg2) [?Enter@State_Pressure@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Pressure__UAEXPAVPJZAKO___Z)(class State_Pressure* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Pressure__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Pressure__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc720);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Pressure::Execute(class State_Pressure* const this, class PJZAKO* arg2) [?Execute@State_Pressure@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Pressure__UAEXPAVPJZAKO___Z)(class State_Pressure* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Pressure__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Pressure__UAEXPAVPJZAKO___Z)(GameModule + 0x5dc870);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Pressure::Exit(class State_Pressure* const this, class PJZAKO* arg2) [?Exit@State_Pressure@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Pressure__UAEXPAVPJZAKO___Z)(class State_Pressure* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Pressure__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Pressure__UAEXPAVPJZAKO___Z)(GameModule + 0x5dcba0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Pressure [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Pressure& InObject)
	{
		m_eStat = InObject.m_eStat;
		m_WaitCnt = InObject.m_WaitCnt;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Pressure, PJState>("State_Pressure")
			.addFunction("__tostring", &State_Pressure::ToString)
			.addFunction("GetPtrAddr", &State_Pressure::GetPtrAddr)
			.addProperty("m_eStat", &State_Pressure::m_eStat)
			.addProperty("m_WaitCnt", &State_Pressure::m_WaitCnt)
			.addFunction("ChangeStateCondition", &State_Pressure::ChangeStateCondition)
			.addFunction("Enter", &State_Pressure::Enter)
			.addFunction("Execute", &State_Pressure::Execute)
			.addFunction("Exit", &State_Pressure::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Pressure::m_eStat) == 4, "expected State_Pressure::m_eStat to be size 4");
static_assert(sizeof(State_Pressure::m_WaitCnt) == 4, "expected State_Pressure::m_WaitCnt to be size 4");
static_assert(sizeof(State_Pressure) == 0xc, "expected State_Pressure to be size 0xc");

// [Structure] class State_ThroughDamage
class State_ThroughDamage : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <uint8_t m_boHitSword, offset 0x4>
	uint8_t m_boHitSword = 0;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	/// 4 Functions

	// [Function] void __convention("thiscall") State_ThroughDamage::ChangeStateCondition(class State_ThroughDamage* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_ThroughDamage@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_ThroughDamage__QAEXPAVPJZAKO___Z)(class State_ThroughDamage* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_ThroughDamage__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_ThroughDamage__QAEXPAVPJZAKO___Z)(GameModule + 0x5d60a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ThroughDamage::Enter(class State_ThroughDamage* const this, class PJZAKO* arg2) [?Enter@State_ThroughDamage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_ThroughDamage__UAEXPAVPJZAKO___Z)(class State_ThroughDamage* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_ThroughDamage__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_ThroughDamage__UAEXPAVPJZAKO___Z)(GameModule + 0x5da970);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ThroughDamage::Execute(class State_ThroughDamage* const this, class PJZAKO* arg2) [?Execute@State_ThroughDamage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_ThroughDamage__UAEXPAVPJZAKO___Z)(class State_ThroughDamage* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_ThroughDamage__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_ThroughDamage__UAEXPAVPJZAKO___Z)(GameModule + 0x5da9c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ThroughDamage::Exit(class State_ThroughDamage* const this, class PJZAKO* arg2) [?Exit@State_ThroughDamage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_ThroughDamage__UAEXPAVPJZAKO___Z)(class State_ThroughDamage* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_ThroughDamage__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_ThroughDamage__UAEXPAVPJZAKO___Z)(GameModule + 0x5db2d0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_ThroughDamage [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_ThroughDamage& InObject)
	{
		m_boHitSword = InObject.m_boHitSword;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_ThroughDamage, PJState>("State_ThroughDamage")
			.addFunction("__tostring", &State_ThroughDamage::ToString)
			.addFunction("GetPtrAddr", &State_ThroughDamage::GetPtrAddr)
			.addProperty("m_boHitSword", &State_ThroughDamage::m_boHitSword)
			.addFunction("ChangeStateCondition", &State_ThroughDamage::ChangeStateCondition)
			.addFunction("Enter", &State_ThroughDamage::Enter)
			.addFunction("Execute", &State_ThroughDamage::Execute)
			.addFunction("Exit", &State_ThroughDamage::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ThroughDamage::m_boHitSword) == 1, "expected State_ThroughDamage::m_boHitSword to be size 1");
static_assert(sizeof(State_ThroughDamage) == 0x8, "expected State_ThroughDamage to be size 0x8");

// enum eMoveDir
enum eMoveDir : uint32_t
{
	// <eMoveDir_Left = 0x0>
	eMoveDir_Left = 0,

	// <eMoveDir_Right = 0x1>
	eMoveDir_Right = 1,

	// <eMoveDir_Forward = 0x2>
	eMoveDir_Forward = 2,

	// <eMoveDir_Back = 0x3>
	eMoveDir_Back = 3,

	// <eMoveDir_Idle = 0x4>
	eMoveDir_Idle = 4,

	// <eMoveDir_NumMax = 0x5>
	eMoveDir_NumMax = 5

};

// [Structure] class State_Defence
class State_Defence : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum eMoveDir m_eStateMovDir, offset 0x4>
	enum eMoveDir m_eStateMovDir;

	/// 5 Functions

	// [Function] void __convention("thiscall") State_Defence::MaaiMoveProc(class State_Defence* const this, class PJZAKO* arg2) [?MaaiMoveProc@State_Defence@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _MaaiMoveProc_State_Defence__QAEXPAVPJZAKO___Z)(class State_Defence* const thisPtr, class PJZAKO* arg2);
	void MaaiMoveProc(class PJZAKO* arg2)
	{
		_MaaiMoveProc_State_Defence__QAEXPAVPJZAKO___Z mFunc = (_MaaiMoveProc_State_Defence__QAEXPAVPJZAKO___Z)(GameModule + 0x5d6bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Defence::ChangeStateCondition(class State_Defence* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Defence@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Defence__QAEXPAVPJZAKO___Z)(class State_Defence* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Defence__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Defence__QAEXPAVPJZAKO___Z)(GameModule + 0x5d6e60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Defence::Enter(class State_Defence* const this, class PJZAKO* arg2) [?Enter@State_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Defence__UAEXPAVPJZAKO___Z)(class State_Defence* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Defence__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9d60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Defence::Execute(class State_Defence* const this, class PJZAKO* arg2) [?Execute@State_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Defence__UAEXPAVPJZAKO___Z)(class State_Defence* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Defence__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9d90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Defence::Exit(class State_Defence* const this, class PJZAKO* arg2) [?Exit@State_Defence@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Defence__UAEXPAVPJZAKO___Z)(class State_Defence* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Defence__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Defence__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9e40);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Defence [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Defence& InObject)
	{
		m_eStateMovDir = InObject.m_eStateMovDir;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Defence, PJState>("State_Defence")
			.addFunction("__tostring", &State_Defence::ToString)
			.addFunction("GetPtrAddr", &State_Defence::GetPtrAddr)
			.addProperty("m_eStateMovDir", &State_Defence::m_eStateMovDir)
			.addFunction("MaaiMoveProc", &State_Defence::MaaiMoveProc)
			.addFunction("ChangeStateCondition", &State_Defence::ChangeStateCondition)
			.addFunction("Enter", &State_Defence::Enter)
			.addFunction("Execute", &State_Defence::Execute)
			.addFunction("Exit", &State_Defence::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Defence::m_eStateMovDir) == 4, "expected State_Defence::m_eStateMovDir to be size 4");
static_assert(sizeof(State_Defence) == 0x8, "expected State_Defence to be size 0x8");

// [Structure] class State_Evacuate
class State_Evacuate : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_nContinueEvacuate, offset 0x4>
	int32_t m_nContinueEvacuate = 0;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Evacuate::ChangeStateCondition(class State_Evacuate* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Evacuate@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Evacuate__QAEXPAVPJZAKO___Z)(class State_Evacuate* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Evacuate__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Evacuate__QAEXPAVPJZAKO___Z)(GameModule + 0x5d65a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Evacuate::Enter(class State_Evacuate* const this, class PJZAKO* arg2) [?Enter@State_Evacuate@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Evacuate__UAEXPAVPJZAKO___Z)(class State_Evacuate* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Evacuate__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Evacuate__UAEXPAVPJZAKO___Z)(GameModule + 0x5da000);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Evacuate::Execute(class State_Evacuate* const this, class PJZAKO* arg2) [?Execute@State_Evacuate@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Evacuate__UAEXPAVPJZAKO___Z)(class State_Evacuate* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Evacuate__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Evacuate__UAEXPAVPJZAKO___Z)(GameModule + 0x5da060);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Evacuate::Exit(class State_Evacuate* const this, class PJZAKO* arg2) [?Exit@State_Evacuate@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Evacuate__UAEXPAVPJZAKO___Z)(class State_Evacuate* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Evacuate__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Evacuate__UAEXPAVPJZAKO___Z)(GameModule + 0x5da0d0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Evacuate [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Evacuate& InObject)
	{
		m_nContinueEvacuate = InObject.m_nContinueEvacuate;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Evacuate, PJState>("State_Evacuate")
			.addFunction("__tostring", &State_Evacuate::ToString)
			.addFunction("GetPtrAddr", &State_Evacuate::GetPtrAddr)
			.addProperty("m_nContinueEvacuate", &State_Evacuate::m_nContinueEvacuate)
			.addFunction("ChangeStateCondition", &State_Evacuate::ChangeStateCondition)
			.addFunction("Enter", &State_Evacuate::Enter)
			.addFunction("Execute", &State_Evacuate::Execute)
			.addFunction("Exit", &State_Evacuate::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Evacuate::m_nContinueEvacuate) == 4, "expected State_Evacuate::m_nContinueEvacuate to be size 4");
static_assert(sizeof(State_Evacuate) == 0x8, "expected State_Evacuate to be size 0x8");

// [Structure] class State_ComboAttack
class State_ComboAttack : public PJState
{
public:
	// enum State_ComboAttack::eStat
	enum eStat : uint32_t
	{
		// <eStat_ATTACKSTART = 0x0>
		eStat_ATTACKSTART = 0,

		// <eStat_ATTACKING = 0x1>
		eStat_ATTACKING = 1

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_ComboAttack::eStat m_eStat, offset 0x4>
	enum State_ComboAttack::eStat m_eStat;

	// <uint8_t m_ComboRequest, offset 0x8>
	uint8_t m_ComboRequest = 0;

	// <Unidentified data segment, offset 0x9>
private:
	char _UnidentifiedData_9[3];

public:
	/// 5 Functions

	// [Function] uint8_t __convention("thiscall") State_ComboAttack::CancelAtkByFarDist(class State_ComboAttack* const this, class PJZAKO* arg2) [?CancelAtkByFarDist@State_ComboAttack@@QAE_NPAVPJZAKO@@@Z]
	typedef uint8_t(__thiscall* _CancelAtkByFarDist_State_ComboAttack__QAE_NPAVPJZAKO___Z)(class State_ComboAttack* const thisPtr, class PJZAKO* arg2);
	uint8_t CancelAtkByFarDist(class PJZAKO* arg2)
	{
		_CancelAtkByFarDist_State_ComboAttack__QAE_NPAVPJZAKO___Z mFunc = (_CancelAtkByFarDist_State_ComboAttack__QAE_NPAVPJZAKO___Z)(GameModule + 0x5d7470);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ComboAttack::Enter(class State_ComboAttack* const this, class PJZAKO* arg2) [?Enter@State_ComboAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_ComboAttack__UAEXPAVPJZAKO___Z)(class State_ComboAttack* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_ComboAttack__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_ComboAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d95a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ComboAttack::Execute(class State_ComboAttack* const this, class PJZAKO* arg2) [?Execute@State_ComboAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_ComboAttack__UAEXPAVPJZAKO___Z)(class State_ComboAttack* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_ComboAttack__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_ComboAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9600);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ComboAttack::Exit(class State_ComboAttack* const this, class PJZAKO* arg2) [?Exit@State_ComboAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_ComboAttack__UAEXPAVPJZAKO___Z)(class State_ComboAttack* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_ComboAttack__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_ComboAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d97d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ComboAttack::ChangeStateCondition(class State_ComboAttack* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_ComboAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_ComboAttack__UAEXPAVPJZAKO___Z)(class State_ComboAttack* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_ComboAttack__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_ComboAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x5d97e0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_ComboAttack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_ComboAttack& InObject)
	{
		m_eStat = InObject.m_eStat;
		m_ComboRequest = InObject.m_ComboRequest;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_ComboAttack, PJState>("State_ComboAttack")
			.addFunction("__tostring", &State_ComboAttack::ToString)
			.addFunction("GetPtrAddr", &State_ComboAttack::GetPtrAddr)
			.addProperty("m_eStat", &State_ComboAttack::m_eStat)
			.addProperty("m_ComboRequest", &State_ComboAttack::m_ComboRequest)
			.addFunction("CancelAtkByFarDist", &State_ComboAttack::CancelAtkByFarDist)
			.addFunction("Enter", &State_ComboAttack::Enter)
			.addFunction("Execute", &State_ComboAttack::Execute)
			.addFunction("Exit", &State_ComboAttack::Exit)
			.addFunction("ChangeStateCondition", &State_ComboAttack::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ComboAttack::m_eStat) == 4, "expected State_ComboAttack::m_eStat to be size 4");
static_assert(sizeof(State_ComboAttack::m_ComboRequest) == 1, "expected State_ComboAttack::m_ComboRequest to be size 1");
static_assert(sizeof(State_ComboAttack) == 0xc, "expected State_ComboAttack to be size 0xc");

// [Structure] class State_Damage
class State_Damage : public PJState
{
public:
	// enum State_Damage::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0xffffffffffffffff>
		eStat_Init = UINT32_MAX,

		// <eStat_DmgNormal = 0x0>
		eStat_DmgNormal = 0,

		// <eStat_DmgUchiage = 0x1>
		eStat_DmgUchiage = 1,

		// <eStat_Dmg2Down = 0x2>
		eStat_Dmg2Down = 2,

		// <eStat_DmgDownLoop = 0x3>
		eStat_DmgDownLoop = 3,

		// <eStat_DmgWakeUp = 0x4>
		eStat_DmgWakeUp = 4,

		// <eStat_DmgPiyori = 0x5>
		eStat_DmgPiyori = 5,

		// <eStat_ExitDamageState = 0x6>
		eStat_ExitDamageState = 6

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_DownCnt, offset 0x4>
	int32_t m_DownCnt = 0;

	// <enum State_Damage::eStat m_eStat, offset 0x8>
	enum State_Damage::eStat m_eStat;

	/// 7 Functions

	// [Function] void __convention("thiscall") State_Damage::ChangeStateCondition(class State_Damage* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Damage@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Damage__QAEXPAVPJZAKO___Z)(class State_Damage* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Damage__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Damage__QAEXPAVPJZAKO___Z)(GameModule + 0x5d61a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") State_Damage::Continue2DownLoopProc(class State_Damage* const this, class PJZAKO* arg2) [?Continue2DownLoopProc@State_Damage@@QAE_NPAVPJZAKO@@@Z]
	typedef uint8_t(__thiscall* _Continue2DownLoopProc_State_Damage__QAE_NPAVPJZAKO___Z)(class State_Damage* const thisPtr, class PJZAKO* arg2);
	uint8_t Continue2DownLoopProc(class PJZAKO* arg2)
	{
		_Continue2DownLoopProc_State_Damage__QAE_NPAVPJZAKO___Z mFunc = (_Continue2DownLoopProc_State_Damage__QAE_NPAVPJZAKO___Z)(GameModule + 0x5d62a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") State_Damage::ContinueDown2WakeUpProc(class State_Damage* const this, class PJZAKO* arg2) [?ContinueDown2WakeUpProc@State_Damage@@QAE_NPAVPJZAKO@@@Z]
	typedef uint8_t(__thiscall* _ContinueDown2WakeUpProc_State_Damage__QAE_NPAVPJZAKO___Z)(class State_Damage* const thisPtr, class PJZAKO* arg2);
	uint8_t ContinueDown2WakeUpProc(class PJZAKO* arg2)
	{
		_ContinueDown2WakeUpProc_State_Damage__QAE_NPAVPJZAKO___Z mFunc = (_ContinueDown2WakeUpProc_State_Damage__QAE_NPAVPJZAKO___Z)(GameModule + 0x5d6430);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Damage::DamageToOtherChar(class State_Damage* const this, class PJZAKO* arg2) [?DamageToOtherChar@State_Damage@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _DamageToOtherChar_State_Damage__QAEXPAVPJZAKO___Z)(class State_Damage* const thisPtr, class PJZAKO* arg2);
	void DamageToOtherChar(class PJZAKO* arg2)
	{
		_DamageToOtherChar_State_Damage__QAEXPAVPJZAKO___Z mFunc = (_DamageToOtherChar_State_Damage__QAEXPAVPJZAKO___Z)(GameModule + 0x5d64a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Damage::Enter(class State_Damage* const this, class PJZAKO* arg2) [?Enter@State_Damage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Damage__UAEXPAVPJZAKO___Z)(class State_Damage* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Damage__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Damage__UAEXPAVPJZAKO___Z)(GameModule + 0x5da0e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Damage::Execute(class State_Damage* const this, class PJZAKO* arg2) [?Execute@State_Damage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Damage__UAEXPAVPJZAKO___Z)(class State_Damage* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Damage__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Damage__UAEXPAVPJZAKO___Z)(GameModule + 0x5da210);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Damage::Exit(class State_Damage* const this, class PJZAKO* arg2) [?Exit@State_Damage@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Damage__UAEXPAVPJZAKO___Z)(class State_Damage* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Damage__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Damage__UAEXPAVPJZAKO___Z)(GameModule + 0x5da930);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Damage [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Damage& InObject)
	{
		m_DownCnt = InObject.m_DownCnt;
		m_eStat = InObject.m_eStat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Damage, PJState>("State_Damage")
			.addFunction("__tostring", &State_Damage::ToString)
			.addFunction("GetPtrAddr", &State_Damage::GetPtrAddr)
			.addProperty("m_DownCnt", &State_Damage::m_DownCnt)
			.addProperty("m_eStat", &State_Damage::m_eStat)
			.addFunction("ChangeStateCondition", &State_Damage::ChangeStateCondition)
			.addFunction("Continue2DownLoopProc", &State_Damage::Continue2DownLoopProc)
			.addFunction("ContinueDown2WakeUpProc", &State_Damage::ContinueDown2WakeUpProc)
			.addFunction("DamageToOtherChar", &State_Damage::DamageToOtherChar)
			.addFunction("Enter", &State_Damage::Enter)
			.addFunction("Execute", &State_Damage::Execute)
			.addFunction("Exit", &State_Damage::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Damage::m_DownCnt) == 4, "expected State_Damage::m_DownCnt to be size 4");
static_assert(sizeof(State_Damage::m_eStat) == 4, "expected State_Damage::m_eStat to be size 4");
static_assert(sizeof(State_Damage) == 0xc, "expected State_Damage to be size 0xc");

// [Structure] struct CollInfo
struct CollInfo
{
public:
	/// Struct member variables

	// <float fDistLeft, offset 0x0>
	float fDistLeft = 0;

	// <float fDistRight, offset 0x4>
	float fDistRight = 0;

	// <float fDistBack, offset 0x8>
	float fDistBack = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct CollInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CollInfo& InObject)
	{
		fDistLeft = InObject.fDistLeft;
		fDistRight = InObject.fDistRight;
		fDistBack = InObject.fDistBack;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CollInfo>("CollInfo")
			.addFunction("__tostring", &CollInfo::ToString)
			.addFunction("GetPtrAddr", &CollInfo::GetPtrAddr)
			.addProperty("fDistLeft", &CollInfo::fDistLeft)
			.addProperty("fDistRight", &CollInfo::fDistRight)
			.addProperty("fDistBack", &CollInfo::fDistBack)
		.endClass();
	}
#endif
};
static_assert(sizeof(CollInfo::fDistLeft) == 4, "expected CollInfo::fDistLeft to be size 4");
static_assert(sizeof(CollInfo::fDistRight) == 4, "expected CollInfo::fDistRight to be size 4");
static_assert(sizeof(CollInfo::fDistBack) == 4, "expected CollInfo::fDistBack to be size 4");
static_assert(sizeof(CollInfo) == 0xc, "expected CollInfo to be size 0xc");

// [Structure] struct tagHRTASKCHECK
struct tagHRTASKCHECK
{
public:
	/// Struct member variables

	// <class HrTask* Task, offset 0x0>
	class HrTask* Task = nullptr;

	// <uint32_t MagicNumber, offset 0x4>
	uint32_t MagicNumber = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct tagHRTASKCHECK [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tagHRTASKCHECK& InObject)
	{
		Task = InObject.Task;
		MagicNumber = InObject.MagicNumber;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagHRTASKCHECK>("tagHRTASKCHECK")
			.addFunction("__tostring", &tagHRTASKCHECK::ToString)
			.addFunction("GetPtrAddr", &tagHRTASKCHECK::GetPtrAddr)
			.addProperty("Task", &tagHRTASKCHECK::Task)
			.addProperty("MagicNumber", &tagHRTASKCHECK::MagicNumber)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagHRTASKCHECK::Task) == 4, "expected tagHRTASKCHECK::Task to be size 4");
static_assert(sizeof(tagHRTASKCHECK::MagicNumber) == 4, "expected tagHRTASKCHECK::MagicNumber to be size 4");
static_assert(sizeof(tagHRTASKCHECK) == 0x8, "expected tagHRTASKCHECK to be size 0x8");

// enum eScareType
enum eScareType : uint32_t
{
	// <eScareType_NO_SCARE = 0xffffffffffffffff>
	eScareType_NO_SCARE = UINT32_MAX,

	// <eScareType_Tiger = 0x0>
	eScareType_Tiger = 0,

	// <eScareType_FriendDead = 0x1>
	eScareType_FriendDead = 1

};

// enum eZkStat
enum eZkStat : uint32_t
{
	// <eZkCmnStat_INVALID = 0xffffffffffffffff>
	eZkCmnStat_INVALID = UINT32_MAX,

	// <eZkCmnStat_IDLE = 0x0>
	eZkCmnStat_IDLE = 0,

	// <eZkCmnStat_GLOBAL = 0x1>
	eZkCmnStat_GLOBAL = 1,

	// <eZkCmnStat_CLOSE = 0x2>
	eZkCmnStat_CLOSE = 2,

	// <eZkCmnStat_OBSERV = 0x3>
	eZkCmnStat_OBSERV = 3,

	// <eZkCmnStat_SIDEMOVE = 0x4>
	eZkCmnStat_SIDEMOVE = 4,

	// <eZkCmnStat_CloseBeforeATK = 0x5>
	eZkCmnStat_CloseBeforeATK = 5,

	// <eZkCmnStat_AwayAfterATK = 0x6>
	eZkCmnStat_AwayAfterATK = 6,

	// <eZkCmnStat_StepInATK = 0x7>
	eZkCmnStat_StepInATK = 7,

	// <eZkCmnStat_ComboATK = 0x8>
	eZkCmnStat_ComboATK = 8,

	// <eZkCmnStat_RUNAWAY = 0x9>
	eZkCmnStat_RUNAWAY = 9,

	// <eZkCmnStat_DEFENCE = 0xa>
	eZkCmnStat_DEFENCE = 10,

	// <eZkCmnStat_RANDOMMOVE = 0xb>
	eZkCmnStat_RANDOMMOVE = 11,

	// <eZkCmnStat_EVACUATION = 0xc>
	eZkCmnStat_EVACUATION = 12,

	// <eZkCmnStat_DAMAGE = 0xd>
	eZkCmnStat_DAMAGE = 13,

	// <eZkCmnStat_THROUGHDAMAGE = 0xe>
	eZkCmnStat_THROUGHDAMAGE = 14,

	// <eZkCmnStat_DOWNDAMAGE = 0xf>
	eZkCmnStat_DOWNDAMAGE = 15,

	// <eZkCmnStat_GUARD = 0x10>
	eZkCmnStat_GUARD = 16,

	// <eZkCmnStat_DYING = 0x11>
	eZkCmnStat_DYING = 17,

	// <eZkCmnStat_DEBUG = 0x12>
	eZkCmnStat_DEBUG = 18,

	// <eZkCmnStat_GETPCBEHIND = 0x13>
	eZkCmnStat_GETPCBEHIND = 19,

	// <eZkCmnStat_GO2FIGHTLINE = 0x14>
	eZkCmnStat_GO2FIGHTLINE = 20,

	// <eZkCmnStat_OUTFIELD = 0x15>
	eZkCmnStat_OUTFIELD = 21,

	// <eZkCmnStat_CAUTION = 0x16>
	eZkCmnStat_CAUTION = 22,

	// <eZkCmnStat_NOPROC = 0x17>
	eZkCmnStat_NOPROC = 23,

	// <eZkCmnStat_PRESSURE = 0x18>
	eZkCmnStat_PRESSURE = 24,

	// <eZkCmnStat_PATHFIND2PC = 0x19>
	eZkCmnStat_PATHFIND2PC = 25,

	// <eZkCmnStat_WAYPOINTMOVE = 0x1a>
	eZkCmnStat_WAYPOINTMOVE = 26,

	// <eZkCmnStat_LeadPcWayPointMove = 0x1b>
	eZkCmnStat_LeadPcWayPointMove = 27,

	// <eZkCmnStat_FixTurret = 0x1c>
	eZkCmnStat_FixTurret = 28,

	// <eZkCmnStat_WayPointMoveAfterPop = 0x1d>
	eZkCmnStat_WayPointMoveAfterPop = 29,

	// <eZkCmnStat_DownAttack = 0x1e>
	eZkCmnStat_DownAttack = 30,

	// <eZkCmnStat_SCARE_RUN = 0x1f>
	eZkCmnStat_SCARE_RUN = 31,

	// <eZkCmnStat_SCARE_KOSINUKASI = 0x20>
	eZkCmnStat_SCARE_KOSINUKASI = 32,

	// <eZkCmnStat_SCARE_YOTUNBAI = 0x21>
	eZkCmnStat_SCARE_YOTUNBAI = 33,

	// <eZkCmnStat_SCARE_STAND = 0x22>
	eZkCmnStat_SCARE_STAND = 34,

	// <eZkCmnStat_PerformIll = 0x23>
	eZkCmnStat_PerformIll = 35,

	// <eZkCmnStat_RELEASEWAIT_IDLE = 0x24>
	eZkCmnStat_RELEASEWAIT_IDLE = 36,

	// <eZkCmnStat_TOJO_RunAndTurnPc = 0x25>
	eZkCmnStat_TOJO_RunAndTurnPc = 37,

	// <eZkCmnStat_TOJO_AgainstWall = 0x26>
	eZkCmnStat_TOJO_AgainstWall = 38,

	// <eZkCmnStat_TOJO_LookAround = 0x27>
	eZkCmnStat_TOJO_LookAround = 39,

	// <eZkCmnStat_TOJO_Stand = 0x28>
	eZkCmnStat_TOJO_Stand = 40,

	// <eZkCmnStat_TOJO_Bench = 0x29>
	eZkCmnStat_TOJO_Bench = 41,

	// <eZkCmnStat_TOJO_Sit = 0x2a>
	eZkCmnStat_TOJO_Sit = 42,

	// <eZkCmnStat_TOJO_Car = 0x2b>
	eZkCmnStat_TOJO_Car = 43,

	// <eZkCmnStat_TOJO_JumpOff = 0x2c>
	eZkCmnStat_TOJO_JumpOff = 44,

	// <eZkCmnStat_TOJO_BreakCmnObj = 0x2d>
	eZkCmnStat_TOJO_BreakCmnObj = 45,

	// <eZkCmnStat_TOJO_AeroBike = 0x2e>
	eZkCmnStat_TOJO_AeroBike = 46,

	// <eZkCmnStat_TOJO_RoomRunner = 0x2f>
	eZkCmnStat_TOJO_RoomRunner = 47,

	// <eZkCmnStat_TOJO_SuddenAttack = 0x30>
	eZkCmnStat_TOJO_SuddenAttack = 48,

	// <eZkCmnStat_UNDERCTRL_MOVE = 0x31>
	eZkCmnStat_UNDERCTRL_MOVE = 49,

	// <eZkCmnStat_UNDERCTRL_ATTACK = 0x32>
	eZkCmnStat_UNDERCTRL_ATTACK = 50,

	// <eZkCmnStat_UNDERCTRL_EVACUATE = 0x33>
	eZkCmnStat_UNDERCTRL_EVACUATE = 51,

	// <eZkCmnStat_UNDERCTRL_GUARD = 0x34>
	eZkCmnStat_UNDERCTRL_GUARD = 52,

	// <eZkCmnStat_UNDERCTRL_DAMAGE = 0x35>
	eZkCmnStat_UNDERCTRL_DAMAGE = 53,

	// <eZkCmnStat_NUM = 0x36>
	eZkCmnStat_NUM = 54

};

// enum FightSpirit
enum FightSpirit : uint32_t
{
	// <e_Defensive = 0x0>
	e_Defensive = 0,

	// <e_Offensive = 0x1>
	e_Offensive = 1,

	// <e_FsStatNum = 0x2>
	e_FsStatNum = 2

};

// enum eFightLine
enum eFightLine : uint32_t
{
	// <eFightLine_Init = 0xffffffffffffffff>
	eFightLine_Init = UINT32_MAX,

	// <eFightLine_Defence = 0x0>
	eFightLine_Defence = 0,

	// <eFightLine_SideMove = 0x1>
	eFightLine_SideMove = 1,

	// <eFightLine_OutField = 0x2>
	eFightLine_OutField = 2,

	// <eFightLine_NUM = 0x3>
	eFightLine_NUM = 3

};

// [Structure] struct ZkGuardParam
struct ZkGuardParam
{
public:
	/// Struct member variables

	// <int32_t GrdCnt, offset 0x0>
	int32_t GrdCnt = 0;

	// <int32_t nGrdCombo, offset 0x4>
	int32_t nGrdCombo = 0;

	// <int32_t GrdStiffCnt, offset 0x8>
	int32_t GrdStiffCnt = 0;

	// <uint8_t boGrdStiff, offset 0xc>
	uint8_t boGrdStiff = 0;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData_13[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct ZkGuardParam [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkGuardParam& InObject)
	{
		GrdCnt = InObject.GrdCnt;
		nGrdCombo = InObject.nGrdCombo;
		GrdStiffCnt = InObject.GrdStiffCnt;
		boGrdStiff = InObject.boGrdStiff;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkGuardParam>("ZkGuardParam")
			.addFunction("__tostring", &ZkGuardParam::ToString)
			.addFunction("GetPtrAddr", &ZkGuardParam::GetPtrAddr)
			.addProperty("GrdCnt", &ZkGuardParam::GrdCnt)
			.addProperty("nGrdCombo", &ZkGuardParam::nGrdCombo)
			.addProperty("GrdStiffCnt", &ZkGuardParam::GrdStiffCnt)
			.addProperty("boGrdStiff", &ZkGuardParam::boGrdStiff)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkGuardParam::GrdCnt) == 4, "expected ZkGuardParam::GrdCnt to be size 4");
static_assert(sizeof(ZkGuardParam::nGrdCombo) == 4, "expected ZkGuardParam::nGrdCombo to be size 4");
static_assert(sizeof(ZkGuardParam::GrdStiffCnt) == 4, "expected ZkGuardParam::GrdStiffCnt to be size 4");
static_assert(sizeof(ZkGuardParam::boGrdStiff) == 1, "expected ZkGuardParam::boGrdStiff to be size 1");
static_assert(sizeof(ZkGuardParam) == 0x10, "expected ZkGuardParam to be size 0x10");

// [Structure] struct ZkEvacuateParam
struct ZkEvacuateParam
{
public:
	/// Struct member variables

	// <int32_t EvcCnt, offset 0x0>
	int32_t EvcCnt = 0;

	// <int32_t nEvcCombo, offset 0x4>
	int32_t nEvcCombo = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct ZkEvacuateParam [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkEvacuateParam& InObject)
	{
		EvcCnt = InObject.EvcCnt;
		nEvcCombo = InObject.nEvcCombo;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkEvacuateParam>("ZkEvacuateParam")
			.addFunction("__tostring", &ZkEvacuateParam::ToString)
			.addFunction("GetPtrAddr", &ZkEvacuateParam::GetPtrAddr)
			.addProperty("EvcCnt", &ZkEvacuateParam::EvcCnt)
			.addProperty("nEvcCombo", &ZkEvacuateParam::nEvcCombo)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkEvacuateParam::EvcCnt) == 4, "expected ZkEvacuateParam::EvcCnt to be size 4");
static_assert(sizeof(ZkEvacuateParam::nEvcCombo) == 4, "expected ZkEvacuateParam::nEvcCombo to be size 4");
static_assert(sizeof(ZkEvacuateParam) == 0x8, "expected ZkEvacuateParam to be size 0x8");

// enum eDownDir
enum eDownDir : uint32_t
{
	// <eDownDir_UNKNOWN = 0xffffffffffffffff>
	eDownDir_UNKNOWN = UINT32_MAX,

	// <eDownDir_UP = 0x0>
	eDownDir_UP = 0,

	// <eDownDir_DOWN = 0x1>
	eDownDir_DOWN = 1

};

// enum eZkCarSheet
enum eZkCarSheet : uint32_t
{
	// <eZkCarSheet_UNKONOWN = 0xffffffffffffffff>
	eZkCarSheet_UNKONOWN = UINT32_MAX,

	// <eZkCarSheet_FR = 0x0>
	eZkCarSheet_FR = 0,

	// <eZkCarSheet_FL = 0x1>
	eZkCarSheet_FL = 1,

	// <eZkCarSheet_BR = 0x2>
	eZkCarSheet_BR = 2,

	// <eZkCarSheet_BL = 0x3>
	eZkCarSheet_BL = 3,

	// <eZkCarSheet_VAN = 0x4>
	eZkCarSheet_VAN = 4,

	// <eZkCarSheet_NUM = 0x5>
	eZkCarSheet_NUM = 5

};

// [Structure] class FkCounter
class FkCounter
{
public:
	/// Struct member variables

	// <int32_t NowCnt, offset 0x0>
	int32_t NowCnt = 0;

	// <int32_t MaxCnt, offset 0x4>
	int32_t MaxCnt = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class FkCounter [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkCounter& InObject)
	{
		NowCnt = InObject.NowCnt;
		MaxCnt = InObject.MaxCnt;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkCounter>("FkCounter")
			.addFunction("__tostring", &FkCounter::ToString)
			.addFunction("GetPtrAddr", &FkCounter::GetPtrAddr)
			.addProperty("NowCnt", &FkCounter::NowCnt)
			.addProperty("MaxCnt", &FkCounter::MaxCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkCounter::NowCnt) == 4, "expected FkCounter::NowCnt to be size 4");
static_assert(sizeof(FkCounter::MaxCnt) == 4, "expected FkCounter::MaxCnt to be size 4");
static_assert(sizeof(FkCounter) == 0x8, "expected FkCounter to be size 0x8");

// enum ePcSideFromMe
enum ePcSideFromMe : uint32_t
{
	// <ePcSideFromMe_Unknown = 0xffffffffffffffff>
	ePcSideFromMe_Unknown = UINT32_MAX,

	// <ePcSideFromMe_Left = 0x0>
	ePcSideFromMe_Left = 0,

	// <ePcSideFromMe_Right = 0x1>
	ePcSideFromMe_Right = 1

};

// enum eSideFromPc
enum eSideFromPc : uint32_t
{
	// <eSideFromPC_Left = 0x0>
	eSideFromPC_Left = 0,

	// <eSideFromPC_Right = 0x1>
	eSideFromPC_Right = 1

};

// [Structure] struct ZkSetDamageInfo
struct ZkSetDamageInfo
{
public:
	/// Struct member variables

	// <uint8_t boCounterHit, offset 0x0>
	uint8_t boCounterHit = 0;

	// <uint8_t boFollowThroughHit, offset 0x1>
	uint8_t boFollowThroughHit = 0;

	// <uint8_t boNoConvertMotionTypeDamage, offset 0x2>
	uint8_t boNoConvertMotionTypeDamage = 0;

	// <uint8_t boGuard, offset 0x3>
	uint8_t boGuard = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct ZkSetDamageInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkSetDamageInfo& InObject)
	{
		boCounterHit = InObject.boCounterHit;
		boFollowThroughHit = InObject.boFollowThroughHit;
		boNoConvertMotionTypeDamage = InObject.boNoConvertMotionTypeDamage;
		boGuard = InObject.boGuard;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkSetDamageInfo>("ZkSetDamageInfo")
			.addFunction("__tostring", &ZkSetDamageInfo::ToString)
			.addFunction("GetPtrAddr", &ZkSetDamageInfo::GetPtrAddr)
			.addProperty("boCounterHit", &ZkSetDamageInfo::boCounterHit)
			.addProperty("boFollowThroughHit", &ZkSetDamageInfo::boFollowThroughHit)
			.addProperty("boNoConvertMotionTypeDamage", &ZkSetDamageInfo::boNoConvertMotionTypeDamage)
			.addProperty("boGuard", &ZkSetDamageInfo::boGuard)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkSetDamageInfo::boCounterHit) == 1, "expected ZkSetDamageInfo::boCounterHit to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boFollowThroughHit) == 1, "expected ZkSetDamageInfo::boFollowThroughHit to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boNoConvertMotionTypeDamage) == 1, "expected ZkSetDamageInfo::boNoConvertMotionTypeDamage to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boGuard) == 1, "expected ZkSetDamageInfo::boGuard to be size 1");
static_assert(sizeof(ZkSetDamageInfo) == 0x4, "expected ZkSetDamageInfo to be size 0x4");

// enum eZkBoneScale
enum eZkBoneScale : uint32_t
{
	// <eZkBoneScale_UNKNOWN = 0xffffffffffffffff>
	eZkBoneScale_UNKNOWN = UINT32_MAX,

	// <eZkBoneScale_A = 0x0>
	eZkBoneScale_A = 0,

	// <eZkBoneScale_B = 0x1>
	eZkBoneScale_B = 1,

	// <eZkBoneScale_C = 0x2>
	eZkBoneScale_C = 2,

	// <eZkBoneScale_D = 0x3>
	eZkBoneScale_D = 3,

	// <eZkBoneScale_Five = 0x4>
	eZkBoneScale_Five = 4,

	// <eZkBoneScaleNum = 0x5>
	eZkBoneScaleNum = 5

};

// [Structure] class State_Scare_Yotunbai
class State_Scare_Yotunbai : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Scare_Yotunbai::Enter(class State_Scare_Yotunbai* const this, class PJZAKO* arg2) [?Enter@State_Scare_Yotunbai@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z)(class State_Scare_Yotunbai* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd3b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Yotunbai::Execute(class State_Scare_Yotunbai* const this, class PJZAKO* arg2) [?Execute@State_Scare_Yotunbai@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z)(class State_Scare_Yotunbai* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd420);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Yotunbai::Exit(class State_Scare_Yotunbai* const this, class PJZAKO* arg2) [?Exit@State_Scare_Yotunbai@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z)(class State_Scare_Yotunbai* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd470);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Yotunbai::ChangeStateCondition(class State_Scare_Yotunbai* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Scare_Yotunbai@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z)(class State_Scare_Yotunbai* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Scare_Yotunbai__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd490);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Scare_Yotunbai [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Scare_Yotunbai& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Yotunbai, State_Scare_Base>("State_Scare_Yotunbai")
			.addFunction("__tostring", &State_Scare_Yotunbai::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Yotunbai::GetPtrAddr)
			.addFunction("Enter", &State_Scare_Yotunbai::Enter)
			.addFunction("Execute", &State_Scare_Yotunbai::Execute)
			.addFunction("Exit", &State_Scare_Yotunbai::Exit)
			.addFunction("ChangeStateCondition", &State_Scare_Yotunbai::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Yotunbai) == 0x8, "expected State_Scare_Yotunbai to be size 0x8");

// [Structure] class State_Scare_Stand
class State_Scare_Stand : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Scare_Stand::Enter(class State_Scare_Stand* const this, class PJZAKO* arg2) [?Enter@State_Scare_Stand@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Scare_Stand__UAEXPAVPJZAKO___Z)(class State_Scare_Stand* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Scare_Stand__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Scare_Stand__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd4a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Stand::Execute(class State_Scare_Stand* const this, class PJZAKO* arg2) [?Execute@State_Scare_Stand@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Scare_Stand__UAEXPAVPJZAKO___Z)(class State_Scare_Stand* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Scare_Stand__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Scare_Stand__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd510);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Stand::Exit(class State_Scare_Stand* const this, class PJZAKO* arg2) [?Exit@State_Scare_Stand@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Scare_Stand__UAEXPAVPJZAKO___Z)(class State_Scare_Stand* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Scare_Stand__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Scare_Stand__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd5b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Scare_Stand::ChangeStateCondition(class State_Scare_Stand* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Scare_Stand@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Scare_Stand__UAEXPAVPJZAKO___Z)(class State_Scare_Stand* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Scare_Stand__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Scare_Stand__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd5d0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Scare_Stand [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Scare_Stand& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Stand, State_Scare_Base>("State_Scare_Stand")
			.addFunction("__tostring", &State_Scare_Stand::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Stand::GetPtrAddr)
			.addFunction("Enter", &State_Scare_Stand::Enter)
			.addFunction("Execute", &State_Scare_Stand::Execute)
			.addFunction("Exit", &State_Scare_Stand::Exit)
			.addFunction("ChangeStateCondition", &State_Scare_Stand::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Stand) == 0x8, "expected State_Scare_Stand to be size 0x8");

// [Structure] class State_SideMove
class State_SideMove : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum eMoveDir m_eStateMovDir, offset 0x4>
	enum eMoveDir m_eStateMovDir;

	/// 5 Functions

	// [Function] void __convention("thiscall") State_SideMove::ChangeStateCondition(class State_SideMove* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_SideMove@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_SideMove__QAEXPAVPJZAKO___Z)(class State_SideMove* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_SideMove__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_SideMove__QAEXPAVPJZAKO___Z)(GameModule + 0x5d78d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_SideMove::CheckValid(class State_SideMove* const this, class PJZAKO* arg2) [?CheckValid@State_SideMove@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _CheckValid_State_SideMove__QAEXPAVPJZAKO___Z)(class State_SideMove* const thisPtr, class PJZAKO* arg2);
	void CheckValid(class PJZAKO* arg2)
	{
		_CheckValid_State_SideMove__QAEXPAVPJZAKO___Z mFunc = (_CheckValid_State_SideMove__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7b90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_SideMove::Enter(class State_SideMove* const this, class PJZAKO* arg2) [?Enter@State_SideMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_SideMove__UAEXPAVPJZAKO___Z)(class State_SideMove* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_SideMove__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_SideMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9090);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_SideMove::Execute(class State_SideMove* const this, class PJZAKO* arg2) [?Execute@State_SideMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_SideMove__UAEXPAVPJZAKO___Z)(class State_SideMove* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_SideMove__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_SideMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5d90b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_SideMove::Exit(class State_SideMove* const this, class PJZAKO* arg2) [?Exit@State_SideMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_SideMove__UAEXPAVPJZAKO___Z)(class State_SideMove* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_SideMove__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_SideMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9420);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_SideMove [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_SideMove& InObject)
	{
		m_eStateMovDir = InObject.m_eStateMovDir;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_SideMove, PJState>("State_SideMove")
			.addFunction("__tostring", &State_SideMove::ToString)
			.addFunction("GetPtrAddr", &State_SideMove::GetPtrAddr)
			.addProperty("m_eStateMovDir", &State_SideMove::m_eStateMovDir)
			.addFunction("ChangeStateCondition", &State_SideMove::ChangeStateCondition)
			.addFunction("CheckValid", &State_SideMove::CheckValid)
			.addFunction("Enter", &State_SideMove::Enter)
			.addFunction("Execute", &State_SideMove::Execute)
			.addFunction("Exit", &State_SideMove::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_SideMove::m_eStateMovDir) == 4, "expected State_SideMove::m_eStateMovDir to be size 4");
static_assert(sizeof(State_SideMove) == 0x8, "expected State_SideMove to be size 0x8");

// [Structure] class State_RandomMove
class State_RandomMove : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum eMoveDir m_eStateMovDir, offset 0x4>
	enum eMoveDir m_eStateMovDir;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_RandomMove::ChangeStateCondition(class State_RandomMove* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_RandomMove@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_RandomMove__QAEXPAVPJZAKO___Z)(class State_RandomMove* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_RandomMove__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_RandomMove__QAEXPAVPJZAKO___Z)(GameModule + 0x5d6820);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_RandomMove::Enter(class State_RandomMove* const this, class PJZAKO* arg2) [?Enter@State_RandomMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_RandomMove__UAEXPAVPJZAKO___Z)(class State_RandomMove* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_RandomMove__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_RandomMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9e50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_RandomMove::Execute(class State_RandomMove* const this, class PJZAKO* arg2) [?Execute@State_RandomMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_RandomMove__UAEXPAVPJZAKO___Z)(class State_RandomMove* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_RandomMove__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_RandomMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9e70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_RandomMove::Exit(class State_RandomMove* const this, class PJZAKO* arg2) [?Exit@State_RandomMove@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_RandomMove__UAEXPAVPJZAKO___Z)(class State_RandomMove* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_RandomMove__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_RandomMove__UAEXPAVPJZAKO___Z)(GameModule + 0x5d9ff0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_RandomMove [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_RandomMove& InObject)
	{
		m_eStateMovDir = InObject.m_eStateMovDir;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_RandomMove, PJState>("State_RandomMove")
			.addFunction("__tostring", &State_RandomMove::ToString)
			.addFunction("GetPtrAddr", &State_RandomMove::GetPtrAddr)
			.addProperty("m_eStateMovDir", &State_RandomMove::m_eStateMovDir)
			.addFunction("ChangeStateCondition", &State_RandomMove::ChangeStateCondition)
			.addFunction("Enter", &State_RandomMove::Enter)
			.addFunction("Execute", &State_RandomMove::Execute)
			.addFunction("Exit", &State_RandomMove::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_RandomMove::m_eStateMovDir) == 4, "expected State_RandomMove::m_eStateMovDir to be size 4");
static_assert(sizeof(State_RandomMove) == 0x8, "expected State_RandomMove to be size 0x8");

// [Structure] class State_PerformIll
class State_PerformIll : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_PerformIll::Enter(class State_PerformIll* const this, class PJZAKO* arg2) [?Enter@State_PerformIll@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_PerformIll__UAEXPAVPJZAKO___Z)(class State_PerformIll* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_PerformIll__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_PerformIll__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd5e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_PerformIll::Execute(class State_PerformIll* const this, class PJZAKO* arg2) [?Execute@State_PerformIll@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_PerformIll__UAEXPAVPJZAKO___Z)(class State_PerformIll* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_PerformIll__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_PerformIll__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd630);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_PerformIll::Exit(class State_PerformIll* const this, class PJZAKO* arg2) [?Exit@State_PerformIll@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_PerformIll__UAEXPAVPJZAKO___Z)(class State_PerformIll* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_PerformIll__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_PerformIll__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd640);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_PerformIll::ChangeStateCondition(class State_PerformIll* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_PerformIll@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_PerformIll__UAEXPAVPJZAKO___Z)(class State_PerformIll* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_PerformIll__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_PerformIll__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd650);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_PerformIll [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_PerformIll& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_PerformIll, State_Scare_Base>("State_PerformIll")
			.addFunction("__tostring", &State_PerformIll::ToString)
			.addFunction("GetPtrAddr", &State_PerformIll::GetPtrAddr)
			.addFunction("Enter", &State_PerformIll::Enter)
			.addFunction("Execute", &State_PerformIll::Execute)
			.addFunction("Exit", &State_PerformIll::Exit)
			.addFunction("ChangeStateCondition", &State_PerformIll::ChangeStateCondition)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_PerformIll) == 0x8, "expected State_PerformIll to be size 0x8");

// [Structure] class PJZAKO
class PJZAKO : public mHRChara
{
public:
	// [Structure] struct PJZAKO::ZakoInfo
	struct ZakoInfo
	{
	public:
		/// Struct member variables

		// <int32_t m_ComboAtkTbl[0x4], offset 0x0>
		int32_t m_ComboAtkTbl[4];

		// <int32_t m_NowComboAtkNo, offset 0x10>
		int32_t m_NowComboAtkNo = 0;

		// <uint8_t m_ComboAtkReq, offset 0x14>
		uint8_t m_ComboAtkReq = 0;

		// <Unidentified data segment, offset 0x15>
	private:
		char _UnidentifiedData_21[3];

	public:
		// <int32_t m_nMaxComboAtk, offset 0x18>
		int32_t m_nMaxComboAtk = 0;

		// <enum eMoveDir m_eMaaiMovDir, offset 0x1c>
		enum eMoveDir m_eMaaiMovDir;

		// <enum eSideFromPc m_SideFromPc, offset 0x20>
		enum eSideFromPc m_SideFromPc;

		// <enum ePcSideFromMe m_PcSideFromMe, offset 0x24>
		enum ePcSideFromMe m_PcSideFromMe;

		// <class FkCounter m_MoveCnt, offset 0x28>
		class FkCounter m_MoveCnt;

		// <struct Vec m_MoveVec, offset 0x30>
		struct Vec m_MoveVec;

		// <struct Vec m_FrontVec, offset 0x3c>
		struct Vec m_FrontVec;

		// <float m_EnmSubAngle, offset 0x48>
		float m_EnmSubAngle = 0;

		// <float m_fMaaiTbl[0x8], offset 0x4c>
		float m_fMaaiTbl[8];

		// <float m_fMovSpd[0x1], offset 0x6c>
		float m_fMovSpd[1];

		// <int32_t m_CirclePcPointHnd, offset 0x70>
		int32_t m_CirclePcPointHnd = 0;

		// <struct Vec m_PrevPos, offset 0x74>
		struct Vec m_PrevPos;

		// <float m_fWayPointMoveLength, offset 0x80>
		float m_fWayPointMoveLength = 0;

		// <int32_t m_WayPointCnt, offset 0x84>
		int32_t m_WayPointCnt = 0;

		// <uint8_t m_boWaypointMoveStopping, offset 0x88>
		uint8_t m_boWaypointMoveStopping = 0;

		// <Unidentified data segment, offset 0x89>
	private:
		char _UnidentifiedData_137[3];

	public:
		// <int32_t m_GoPointKuruKuruCnt, offset 0x8c>
		int32_t m_GoPointKuruKuruCnt = 0;

		// <uint8_t m_boLookPC, offset 0x90>
		uint8_t m_boLookPC = 0;

		// <Unidentified data segment, offset 0x91>
	private:
		char _UnidentifiedData_145[3];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct PJZAKO::ZakoInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(PJZAKO::ZakoInfo& InObject)
		{
			m_NowComboAtkNo = InObject.m_NowComboAtkNo;
			m_ComboAtkReq = InObject.m_ComboAtkReq;
			m_nMaxComboAtk = InObject.m_nMaxComboAtk;
			m_eMaaiMovDir = InObject.m_eMaaiMovDir;
			m_SideFromPc = InObject.m_SideFromPc;
			m_PcSideFromMe = InObject.m_PcSideFromMe;
			m_MoveCnt = InObject.m_MoveCnt;
			m_MoveVec = InObject.m_MoveVec;
			m_FrontVec = InObject.m_FrontVec;
			m_EnmSubAngle = InObject.m_EnmSubAngle;
			m_CirclePcPointHnd = InObject.m_CirclePcPointHnd;
			m_PrevPos = InObject.m_PrevPos;
			m_fWayPointMoveLength = InObject.m_fWayPointMoveLength;
			m_WayPointCnt = InObject.m_WayPointCnt;
			m_boWaypointMoveStopping = InObject.m_boWaypointMoveStopping;
			m_GoPointKuruKuruCnt = InObject.m_GoPointKuruKuruCnt;
			m_boLookPC = InObject.m_boLookPC;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<ZakoInfo>("PJZAKO_ZakoInfo")
				.addFunction("__tostring", &PJZAKO::ZakoInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::ZakoInfo::GetPtrAddr)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_ComboAtkTbl", &PJZAKO::ZakoInfo::m_ComboAtkTbl)
				.addProperty("m_NowComboAtkNo", &PJZAKO::ZakoInfo::m_NowComboAtkNo)
				.addProperty("m_ComboAtkReq", &PJZAKO::ZakoInfo::m_ComboAtkReq)
				.addProperty("m_nMaxComboAtk", &PJZAKO::ZakoInfo::m_nMaxComboAtk)
				.addProperty("m_eMaaiMovDir", &PJZAKO::ZakoInfo::m_eMaaiMovDir)
				.addProperty("m_SideFromPc", &PJZAKO::ZakoInfo::m_SideFromPc)
				.addProperty("m_PcSideFromMe", &PJZAKO::ZakoInfo::m_PcSideFromMe)
				.addProperty("m_MoveCnt", &PJZAKO::ZakoInfo::m_MoveCnt)
				.addProperty("m_MoveVec", &PJZAKO::ZakoInfo::m_MoveVec)
				.addProperty("m_FrontVec", &PJZAKO::ZakoInfo::m_FrontVec)
				.addProperty("m_EnmSubAngle", &PJZAKO::ZakoInfo::m_EnmSubAngle)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_fMaaiTbl", &PJZAKO::ZakoInfo::m_fMaaiTbl)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_fMovSpd", &PJZAKO::ZakoInfo::m_fMovSpd)
				.addProperty("m_CirclePcPointHnd", &PJZAKO::ZakoInfo::m_CirclePcPointHnd)
				.addProperty("m_PrevPos", &PJZAKO::ZakoInfo::m_PrevPos)
				.addProperty("m_fWayPointMoveLength", &PJZAKO::ZakoInfo::m_fWayPointMoveLength)
				.addProperty("m_WayPointCnt", &PJZAKO::ZakoInfo::m_WayPointCnt)
				.addProperty("m_boWaypointMoveStopping", &PJZAKO::ZakoInfo::m_boWaypointMoveStopping)
				.addProperty("m_GoPointKuruKuruCnt", &PJZAKO::ZakoInfo::m_GoPointKuruKuruCnt)
				.addProperty("m_boLookPC", &PJZAKO::ZakoInfo::m_boLookPC)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::ZakoInfo::m_ComboAtkTbl) == 16, "expected PJZAKO::ZakoInfo::m_ComboAtkTbl to be size 16");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_NowComboAtkNo) == 4, "expected PJZAKO::ZakoInfo::m_NowComboAtkNo to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_ComboAtkReq) == 1, "expected PJZAKO::ZakoInfo::m_ComboAtkReq to be size 1");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_nMaxComboAtk) == 4, "expected PJZAKO::ZakoInfo::m_nMaxComboAtk to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_eMaaiMovDir) == 4, "expected PJZAKO::ZakoInfo::m_eMaaiMovDir to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_SideFromPc) == 4, "expected PJZAKO::ZakoInfo::m_SideFromPc to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_PcSideFromMe) == 4, "expected PJZAKO::ZakoInfo::m_PcSideFromMe to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_MoveCnt) == 8, "expected PJZAKO::ZakoInfo::m_MoveCnt to be size 8");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_MoveVec) == 12, "expected PJZAKO::ZakoInfo::m_MoveVec to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_FrontVec) == 12, "expected PJZAKO::ZakoInfo::m_FrontVec to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_EnmSubAngle) == 4, "expected PJZAKO::ZakoInfo::m_EnmSubAngle to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fMaaiTbl) == 32, "expected PJZAKO::ZakoInfo::m_fMaaiTbl to be size 32");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fMovSpd) == 4, "expected PJZAKO::ZakoInfo::m_fMovSpd to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_CirclePcPointHnd) == 4, "expected PJZAKO::ZakoInfo::m_CirclePcPointHnd to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_PrevPos) == 12, "expected PJZAKO::ZakoInfo::m_PrevPos to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fWayPointMoveLength) == 4, "expected PJZAKO::ZakoInfo::m_fWayPointMoveLength to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_WayPointCnt) == 4, "expected PJZAKO::ZakoInfo::m_WayPointCnt to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_boWaypointMoveStopping) == 1, "expected PJZAKO::ZakoInfo::m_boWaypointMoveStopping to be size 1");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_GoPointKuruKuruCnt) == 4, "expected PJZAKO::ZakoInfo::m_GoPointKuruKuruCnt to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_boLookPC) == 1, "expected PJZAKO::ZakoInfo::m_boLookPC to be size 1");
	static_assert(sizeof(PJZAKO::ZakoInfo) == 0x94, "expected PJZAKO::ZakoInfo to be size 0x94");

	// [Structure] struct PJZAKO::MotionInfo
	struct MotionInfo
	{
	public:
		/// Struct member variables

		// <int32_t m_MotionFrame, offset 0x0>
		int32_t m_MotionFrame = 0;

		// <float m_fMotSpd, offset 0x4>
		float m_fMotSpd = 0;

		// <int32_t m_nMaxCommonMot, offset 0x8>
		int32_t m_nMaxCommonMot = 0;

		// <int32_t m_nMaxWepMot, offset 0xc>
		int32_t m_nMaxWepMot = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct PJZAKO::MotionInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(PJZAKO::MotionInfo& InObject)
		{
			m_MotionFrame = InObject.m_MotionFrame;
			m_fMotSpd = InObject.m_fMotSpd;
			m_nMaxCommonMot = InObject.m_nMaxCommonMot;
			m_nMaxWepMot = InObject.m_nMaxWepMot;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MotionInfo>("PJZAKO_MotionInfo")
				.addFunction("__tostring", &PJZAKO::MotionInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::MotionInfo::GetPtrAddr)
				.addProperty("m_MotionFrame", &PJZAKO::MotionInfo::m_MotionFrame)
				.addProperty("m_fMotSpd", &PJZAKO::MotionInfo::m_fMotSpd)
				.addProperty("m_nMaxCommonMot", &PJZAKO::MotionInfo::m_nMaxCommonMot)
				.addProperty("m_nMaxWepMot", &PJZAKO::MotionInfo::m_nMaxWepMot)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::MotionInfo::m_MotionFrame) == 4, "expected PJZAKO::MotionInfo::m_MotionFrame to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_fMotSpd) == 4, "expected PJZAKO::MotionInfo::m_fMotSpd to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_nMaxCommonMot) == 4, "expected PJZAKO::MotionInfo::m_nMaxCommonMot to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_nMaxWepMot) == 4, "expected PJZAKO::MotionInfo::m_nMaxWepMot to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo) == 0x10, "expected PJZAKO::MotionInfo to be size 0x10");

	// [Structure] struct PJZAKO::TojoInfo
	struct TojoInfo
	{
	public:
		/// Struct member variables

		// <uint8_t m_boWaitReleaseIdleState, offset 0x0>
		uint8_t m_boWaitReleaseIdleState = 0;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData_1[3];

	public:
		// <class commonObj* m_pSyncStgObj, offset 0x4>
		class commonObj* m_pSyncStgObj = nullptr;

		// <uint8_t m_boGetOffCar, offset 0x8>
		uint8_t m_boGetOffCar = 0;

		// <Unidentified data segment, offset 0x9>
	private:
		char _UnidentifiedData_9[3];

	public:
		// <enum eZkCarSheet m_eCarSheet, offset 0xc>
		enum eZkCarSheet m_eCarSheet;

		// <uint8_t m_boBreakPopCmnObjStart, offset 0x10>
		uint8_t m_boBreakPopCmnObjStart = 0;

		// <Unidentified data segment, offset 0x11>
	private:
		char _UnidentifiedData_17[3];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct PJZAKO::TojoInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(PJZAKO::TojoInfo& InObject)
		{
			m_boWaitReleaseIdleState = InObject.m_boWaitReleaseIdleState;
			m_pSyncStgObj = InObject.m_pSyncStgObj;
			m_boGetOffCar = InObject.m_boGetOffCar;
			m_eCarSheet = InObject.m_eCarSheet;
			m_boBreakPopCmnObjStart = InObject.m_boBreakPopCmnObjStart;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TojoInfo>("PJZAKO_TojoInfo")
				.addFunction("__tostring", &PJZAKO::TojoInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::TojoInfo::GetPtrAddr)
				.addProperty("m_boWaitReleaseIdleState", &PJZAKO::TojoInfo::m_boWaitReleaseIdleState)
				.addProperty("m_pSyncStgObj", &PJZAKO::TojoInfo::m_pSyncStgObj)
				.addProperty("m_boGetOffCar", &PJZAKO::TojoInfo::m_boGetOffCar)
				.addProperty("m_eCarSheet", &PJZAKO::TojoInfo::m_eCarSheet)
				.addProperty("m_boBreakPopCmnObjStart", &PJZAKO::TojoInfo::m_boBreakPopCmnObjStart)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::TojoInfo::m_boWaitReleaseIdleState) == 1, "expected PJZAKO::TojoInfo::m_boWaitReleaseIdleState to be size 1");
	static_assert(sizeof(PJZAKO::TojoInfo::m_pSyncStgObj) == 4, "expected PJZAKO::TojoInfo::m_pSyncStgObj to be size 4");
	static_assert(sizeof(PJZAKO::TojoInfo::m_boGetOffCar) == 1, "expected PJZAKO::TojoInfo::m_boGetOffCar to be size 1");
	static_assert(sizeof(PJZAKO::TojoInfo::m_eCarSheet) == 4, "expected PJZAKO::TojoInfo::m_eCarSheet to be size 4");
	static_assert(sizeof(PJZAKO::TojoInfo::m_boBreakPopCmnObjStart) == 1, "expected PJZAKO::TojoInfo::m_boBreakPopCmnObjStart to be size 1");
	static_assert(sizeof(PJZAKO::TojoInfo) == 0x14, "expected PJZAKO::TojoInfo to be size 0x14");

	// [Structure] struct PJZAKO::PcInfo
	struct PcInfo
	{
	public:
		/// Struct member variables

		// <struct Vec m_PcPosition, offset 0x0>
		struct Vec m_PcPosition;

		// <struct Vec m_PcDirection, offset 0xc>
		struct Vec m_PcDirection;

		// <struct Vec m_PcNavel, offset 0x18>
		struct Vec m_PcNavel;

		// <float m_PcDistance, offset 0x24>
		float m_PcDistance = 0;

		// <struct Vec m_PcRot, offset 0x28>
		struct Vec m_PcRot;

		// <float m_PcSubAngle, offset 0x34>
		float m_PcSubAngle = 0;

		// <enum enPcPose m_PcPose, offset 0x38>
		enum enPcPose m_PcPose;

		// <uint8_t m_LockonPc, offset 0x3c>
		uint8_t m_LockonPc = 0;

		// <uint8_t m_boPcInSight, offset 0x3d>
		uint8_t m_boPcInSight = 0;

		// <Unidentified data segment, offset 0x3e>
	private:
		char _UnidentifiedData_62[2];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct PJZAKO::PcInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(PJZAKO::PcInfo& InObject)
		{
			m_PcPosition = InObject.m_PcPosition;
			m_PcDirection = InObject.m_PcDirection;
			m_PcNavel = InObject.m_PcNavel;
			m_PcDistance = InObject.m_PcDistance;
			m_PcRot = InObject.m_PcRot;
			m_PcSubAngle = InObject.m_PcSubAngle;
			m_PcPose = InObject.m_PcPose;
			m_LockonPc = InObject.m_LockonPc;
			m_boPcInSight = InObject.m_boPcInSight;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PcInfo>("PJZAKO_PcInfo")
				.addFunction("__tostring", &PJZAKO::PcInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::PcInfo::GetPtrAddr)
				.addProperty("m_PcPosition", &PJZAKO::PcInfo::m_PcPosition)
				.addProperty("m_PcDirection", &PJZAKO::PcInfo::m_PcDirection)
				.addProperty("m_PcNavel", &PJZAKO::PcInfo::m_PcNavel)
				.addProperty("m_PcDistance", &PJZAKO::PcInfo::m_PcDistance)
				.addProperty("m_PcRot", &PJZAKO::PcInfo::m_PcRot)
				.addProperty("m_PcSubAngle", &PJZAKO::PcInfo::m_PcSubAngle)
				.addProperty("m_PcPose", &PJZAKO::PcInfo::m_PcPose)
				.addProperty("m_LockonPc", &PJZAKO::PcInfo::m_LockonPc)
				.addProperty("m_boPcInSight", &PJZAKO::PcInfo::m_boPcInSight)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::PcInfo::m_PcPosition) == 12, "expected PJZAKO::PcInfo::m_PcPosition to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcDirection) == 12, "expected PJZAKO::PcInfo::m_PcDirection to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcNavel) == 12, "expected PJZAKO::PcInfo::m_PcNavel to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcDistance) == 4, "expected PJZAKO::PcInfo::m_PcDistance to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcRot) == 12, "expected PJZAKO::PcInfo::m_PcRot to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcSubAngle) == 4, "expected PJZAKO::PcInfo::m_PcSubAngle to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcPose) == 4, "expected PJZAKO::PcInfo::m_PcPose to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_LockonPc) == 1, "expected PJZAKO::PcInfo::m_LockonPc to be size 1");
	static_assert(sizeof(PJZAKO::PcInfo::m_boPcInSight) == 1, "expected PJZAKO::PcInfo::m_boPcInSight to be size 1");
	static_assert(sizeof(PJZAKO::PcInfo) == 0x40, "expected PJZAKO::PcInfo to be size 0x40");

	// [Structure] struct PJZAKO::DmgInfo
	struct DmgInfo
	{
	public:
		/// Struct member variables

		// <int32_t mLoseSightTick, offset 0x0>
		int32_t mLoseSightTick = 0;

		// <int32_t m_PiyoDuration, offset 0x4>
		int32_t m_PiyoDuration = 0;

		// <int32_t m_mSetDmgDir, offset 0x8>
		int32_t m_mSetDmgDir = 0;

		// <enum eDownDir m_eDownDir, offset 0xc>
		enum eDownDir m_eDownDir;

		// <int32_t m_FuttobiDur, offset 0x10>
		int32_t m_FuttobiDur = 0;

		// <int32_t m_DagekiCounterCnt, offset 0x14>
		int32_t m_DagekiCounterCnt = 0;

		// <uint8_t m_boDagekiCounterAttack, offset 0x18>
		uint8_t m_boDagekiCounterAttack = 0;

		// <Unidentified data segment, offset 0x19>
	private:
		char _UnidentifiedData_25[3];

	public:
		// <int32_t m_PiyoTick, offset 0x1c>
		int32_t m_PiyoTick = 0;

		// <int32_t m_RestStompDropMoneyTime, offset 0x20>
		int32_t m_RestStompDropMoneyTime = 0;

		// <float m_fKnockBackDist, offset 0x24>
		float m_fKnockBackDist = 0;

		// <float m_fKnockBackSpd, offset 0x28>
		float m_fKnockBackSpd = 0;

		// <float m_fDbgKnockBackSum, offset 0x2c>
		float m_fDbgKnockBackSum = 0;

		// <struct Vec m_VecKnocBack, offset 0x30>
		struct Vec m_VecKnocBack;

		// <float m_fInAtkRotY, offset 0x3c>
		float m_fInAtkRotY = 0;

		// <uint8_t m_boCantCreaatedDeadModelByNoMemory, offset 0x40>
		uint8_t m_boCantCreaatedDeadModelByNoMemory = 0;

		// <Unidentified data segment, offset 0x41>
	private:
		char _UnidentifiedData_65[3];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct PJZAKO::DmgInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(PJZAKO::DmgInfo& InObject)
		{
			mLoseSightTick = InObject.mLoseSightTick;
			m_PiyoDuration = InObject.m_PiyoDuration;
			m_mSetDmgDir = InObject.m_mSetDmgDir;
			m_eDownDir = InObject.m_eDownDir;
			m_FuttobiDur = InObject.m_FuttobiDur;
			m_DagekiCounterCnt = InObject.m_DagekiCounterCnt;
			m_boDagekiCounterAttack = InObject.m_boDagekiCounterAttack;
			m_PiyoTick = InObject.m_PiyoTick;
			m_RestStompDropMoneyTime = InObject.m_RestStompDropMoneyTime;
			m_fKnockBackDist = InObject.m_fKnockBackDist;
			m_fKnockBackSpd = InObject.m_fKnockBackSpd;
			m_fDbgKnockBackSum = InObject.m_fDbgKnockBackSum;
			m_VecKnocBack = InObject.m_VecKnocBack;
			m_fInAtkRotY = InObject.m_fInAtkRotY;
			m_boCantCreaatedDeadModelByNoMemory = InObject.m_boCantCreaatedDeadModelByNoMemory;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<DmgInfo>("PJZAKO_DmgInfo")
				.addFunction("__tostring", &PJZAKO::DmgInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::DmgInfo::GetPtrAddr)
				.addProperty("mLoseSightTick", &PJZAKO::DmgInfo::mLoseSightTick)
				.addProperty("m_PiyoDuration", &PJZAKO::DmgInfo::m_PiyoDuration)
				.addProperty("m_mSetDmgDir", &PJZAKO::DmgInfo::m_mSetDmgDir)
				.addProperty("m_eDownDir", &PJZAKO::DmgInfo::m_eDownDir)
				.addProperty("m_FuttobiDur", &PJZAKO::DmgInfo::m_FuttobiDur)
				.addProperty("m_DagekiCounterCnt", &PJZAKO::DmgInfo::m_DagekiCounterCnt)
				.addProperty("m_boDagekiCounterAttack", &PJZAKO::DmgInfo::m_boDagekiCounterAttack)
				.addProperty("m_PiyoTick", &PJZAKO::DmgInfo::m_PiyoTick)
				.addProperty("m_RestStompDropMoneyTime", &PJZAKO::DmgInfo::m_RestStompDropMoneyTime)
				.addProperty("m_fKnockBackDist", &PJZAKO::DmgInfo::m_fKnockBackDist)
				.addProperty("m_fKnockBackSpd", &PJZAKO::DmgInfo::m_fKnockBackSpd)
				.addProperty("m_fDbgKnockBackSum", &PJZAKO::DmgInfo::m_fDbgKnockBackSum)
				.addProperty("m_VecKnocBack", &PJZAKO::DmgInfo::m_VecKnocBack)
				.addProperty("m_fInAtkRotY", &PJZAKO::DmgInfo::m_fInAtkRotY)
				.addProperty("m_boCantCreaatedDeadModelByNoMemory", &PJZAKO::DmgInfo::m_boCantCreaatedDeadModelByNoMemory)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::DmgInfo::mLoseSightTick) == 4, "expected PJZAKO::DmgInfo::mLoseSightTick to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_PiyoDuration) == 4, "expected PJZAKO::DmgInfo::m_PiyoDuration to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_mSetDmgDir) == 4, "expected PJZAKO::DmgInfo::m_mSetDmgDir to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_eDownDir) == 4, "expected PJZAKO::DmgInfo::m_eDownDir to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_FuttobiDur) == 4, "expected PJZAKO::DmgInfo::m_FuttobiDur to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_DagekiCounterCnt) == 4, "expected PJZAKO::DmgInfo::m_DagekiCounterCnt to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_boDagekiCounterAttack) == 1, "expected PJZAKO::DmgInfo::m_boDagekiCounterAttack to be size 1");
	static_assert(sizeof(PJZAKO::DmgInfo::m_PiyoTick) == 4, "expected PJZAKO::DmgInfo::m_PiyoTick to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_RestStompDropMoneyTime) == 4, "expected PJZAKO::DmgInfo::m_RestStompDropMoneyTime to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fKnockBackDist) == 4, "expected PJZAKO::DmgInfo::m_fKnockBackDist to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fKnockBackSpd) == 4, "expected PJZAKO::DmgInfo::m_fKnockBackSpd to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fDbgKnockBackSum) == 4, "expected PJZAKO::DmgInfo::m_fDbgKnockBackSum to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_VecKnocBack) == 12, "expected PJZAKO::DmgInfo::m_VecKnocBack to be size 12");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fInAtkRotY) == 4, "expected PJZAKO::DmgInfo::m_fInAtkRotY to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_boCantCreaatedDeadModelByNoMemory) == 1, "expected PJZAKO::DmgInfo::m_boCantCreaatedDeadModelByNoMemory to be size 1");
	static_assert(sizeof(PJZAKO::DmgInfo) == 0x44, "expected PJZAKO::DmgInfo to be size 0x44");

	// [Structure] struct PJZAKO::AiInfo
	struct AiInfo
	{
	public:
		/// Struct member variables

		// <uint8_t m_boCutAi, offset 0x0>
		uint8_t m_boCutAi = 0;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData_1[3];

	public:
		// <int32_t m_ThinkCnt, offset 0x4>
		int32_t m_ThinkCnt = 0;

		// <struct ZkEvacuateParam m_EvacuateParam, offset 0x8>
		struct ZkEvacuateParam m_EvacuateParam;

		// <struct ZkGuardParam m_GuardParam, offset 0x10>
		struct ZkGuardParam m_GuardParam;

		// <enum eFightLine m_FightLine, offset 0x20>
		enum eFightLine m_FightLine;

		// <class FkCounter m_AtkCnt, offset 0x24>
		class FkCounter m_AtkCnt;

		// <int32_t m_OffensiveMol, offset 0x2c>
		int32_t m_OffensiveMol = 0;

		// <enum FightSpirit m_FS, offset 0x30>
		enum FightSpirit m_FS;

		// <int32_t m_boHitPrevAttack, offset 0x34>
		int32_t m_boHitPrevAttack = 0;

		// <int32_t m_AtkAiLvRand, offset 0x38>
		int32_t m_AtkAiLvRand = 0;

		// <class FkCounter m_PressureCnt, offset 0x3c>
		class FkCounter m_PressureCnt;

		// <int32_t m_ReactRatio, offset 0x44>
		int32_t m_ReactRatio = 0;

		// <int32_t m_PathFindIntervalCnt, offset 0x48>
		int32_t m_PathFindIntervalCnt = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct PJZAKO::AiInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(PJZAKO::AiInfo& InObject)
		{
			m_boCutAi = InObject.m_boCutAi;
			m_ThinkCnt = InObject.m_ThinkCnt;
			m_EvacuateParam = InObject.m_EvacuateParam;
			m_GuardParam = InObject.m_GuardParam;
			m_FightLine = InObject.m_FightLine;
			m_AtkCnt = InObject.m_AtkCnt;
			m_OffensiveMol = InObject.m_OffensiveMol;
			m_FS = InObject.m_FS;
			m_boHitPrevAttack = InObject.m_boHitPrevAttack;
			m_AtkAiLvRand = InObject.m_AtkAiLvRand;
			m_PressureCnt = InObject.m_PressureCnt;
			m_ReactRatio = InObject.m_ReactRatio;
			m_PathFindIntervalCnt = InObject.m_PathFindIntervalCnt;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<AiInfo>("PJZAKO_AiInfo")
				.addFunction("__tostring", &PJZAKO::AiInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::AiInfo::GetPtrAddr)
				.addProperty("m_boCutAi", &PJZAKO::AiInfo::m_boCutAi)
				.addProperty("m_ThinkCnt", &PJZAKO::AiInfo::m_ThinkCnt)
				.addProperty("m_EvacuateParam", &PJZAKO::AiInfo::m_EvacuateParam)
				.addProperty("m_GuardParam", &PJZAKO::AiInfo::m_GuardParam)
				.addProperty("m_FightLine", &PJZAKO::AiInfo::m_FightLine)
				.addProperty("m_AtkCnt", &PJZAKO::AiInfo::m_AtkCnt)
				.addProperty("m_OffensiveMol", &PJZAKO::AiInfo::m_OffensiveMol)
				.addProperty("m_FS", &PJZAKO::AiInfo::m_FS)
				.addProperty("m_boHitPrevAttack", &PJZAKO::AiInfo::m_boHitPrevAttack)
				.addProperty("m_AtkAiLvRand", &PJZAKO::AiInfo::m_AtkAiLvRand)
				.addProperty("m_PressureCnt", &PJZAKO::AiInfo::m_PressureCnt)
				.addProperty("m_ReactRatio", &PJZAKO::AiInfo::m_ReactRatio)
				.addProperty("m_PathFindIntervalCnt", &PJZAKO::AiInfo::m_PathFindIntervalCnt)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::AiInfo::m_boCutAi) == 1, "expected PJZAKO::AiInfo::m_boCutAi to be size 1");
	static_assert(sizeof(PJZAKO::AiInfo::m_ThinkCnt) == 4, "expected PJZAKO::AiInfo::m_ThinkCnt to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_EvacuateParam) == 8, "expected PJZAKO::AiInfo::m_EvacuateParam to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_GuardParam) == 16, "expected PJZAKO::AiInfo::m_GuardParam to be size 16");
	static_assert(sizeof(PJZAKO::AiInfo::m_FightLine) == 4, "expected PJZAKO::AiInfo::m_FightLine to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_AtkCnt) == 8, "expected PJZAKO::AiInfo::m_AtkCnt to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_OffensiveMol) == 4, "expected PJZAKO::AiInfo::m_OffensiveMol to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_FS) == 4, "expected PJZAKO::AiInfo::m_FS to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_boHitPrevAttack) == 4, "expected PJZAKO::AiInfo::m_boHitPrevAttack to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_AtkAiLvRand) == 4, "expected PJZAKO::AiInfo::m_AtkAiLvRand to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_PressureCnt) == 8, "expected PJZAKO::AiInfo::m_PressureCnt to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_ReactRatio) == 4, "expected PJZAKO::AiInfo::m_ReactRatio to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_PathFindIntervalCnt) == 4, "expected PJZAKO::AiInfo::m_PathFindIntervalCnt to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo) == 0x4c, "expected PJZAKO::AiInfo to be size 0x4c");

	// [Structure] struct PJZAKO::EfDanmen
	struct EfDanmen
	{
	public:
		/// Struct member variables

		// <class EffectDanmenFlash* pEf, offset 0x0>
		class EffectDanmenFlash* pEf = nullptr;

		// <struct tagHRTASKCHECK taskCheck, offset 0x4>
		struct tagHRTASKCHECK taskCheck;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct PJZAKO::EfDanmen [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(PJZAKO::EfDanmen& InObject)
		{
			pEf = InObject.pEf;
			taskCheck = InObject.taskCheck;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EfDanmen>("PJZAKO_EfDanmen")
				.addFunction("__tostring", &PJZAKO::EfDanmen::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::EfDanmen::GetPtrAddr)
				.addProperty("pEf", &PJZAKO::EfDanmen::pEf)
				.addProperty("taskCheck", &PJZAKO::EfDanmen::taskCheck)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::EfDanmen::pEf) == 4, "expected PJZAKO::EfDanmen::pEf to be size 4");
	static_assert(sizeof(PJZAKO::EfDanmen::taskCheck) == 8, "expected PJZAKO::EfDanmen::taskCheck to be size 8");
	static_assert(sizeof(PJZAKO::EfDanmen) == 0xc, "expected PJZAKO::EfDanmen to be size 0xc");

	// enum PJZAKO::eSuddenAtkPopDir
	enum eSuddenAtkPopDir : uint32_t
	{
		// <eSuddenAtkPopDir_UNKNOWN = 0xffffffffffffffff>
		eSuddenAtkPopDir_UNKNOWN = UINT32_MAX,

		// <eSuddenAtkPopDir_Above = 0x0>
		eSuddenAtkPopDir_Above = 0,

		// <eSuddenAtkPopDir_FromR = 0x1>
		eSuddenAtkPopDir_FromR = 1,

		// <eSuddenAtkPopDir_FromL = 0x2>
		eSuddenAtkPopDir_FromL = 2

	};

	// enum PJZAKO::eTimeShare
	enum eTimeShare : uint32_t
	{
		// <eTimeShare_Begin = 0x0>
		eTimeShare_Begin = 0,

		// <eTimeShare_ColBack = 0x1>
		eTimeShare_ColBack = 1,

		// <eTimeShare_ColLeft = 0x2>
		eTimeShare_ColLeft = 2,

		// <eTimeShare_ColRight = 0x3>
		eTimeShare_ColRight = 3,

		// <eTimeShare_PcInSight = 0x4>
		eTimeShare_PcInSight = 4,

		// <eTimeShare_End = 0x5>
		eTimeShare_End = 5

	};

	// enum PJZAKO::ZakoSeType
	enum ZakoSeType : uint32_t
	{
		// <SETYPE_ATK = 0x0>
		SETYPE_ATK = 0,

		// <SETYPE_LONGATK = 0x1>
		SETYPE_LONGATK = 1,

		// <SETYPE_DOWN = 0x2>
		SETYPE_DOWN = 2

	};

	// enum PJZAKO::eFrameType
	enum eFrameType : uint32_t
	{
		// <eFrameType_ThroughCrushGround = 0x0>
		eFrameType_ThroughCrushGround = 0,

		// <eFrameType_ThroughDmgHitSword = 0x1>
		eFrameType_ThroughDmgHitSword = 1,

		// <eFrameType_SmokeDead = 0x2>
		eFrameType_SmokeDead = 2

	};

	// enum PJZAKO::eVoiceType
	enum eVoiceType : uint32_t
	{
		// <eVoiceType_DEATH = 0x0>
		eVoiceType_DEATH = 0,

		// <eVoiceType_NOTICE = 0x1>
		eVoiceType_NOTICE = 1,

		// <eVoiceType_PROVOKE = 0x2>
		eVoiceType_PROVOKE = 2,

		// <eVoiceType_LAUGH = 0x3>
		eVoiceType_LAUGH = 3,

		// <eVoiceType_ABUSE = 0x4>
		eVoiceType_ABUSE = 4,

		// <eVoiceType_YURUSI = 0x5>
		eVoiceType_YURUSI = 5,

		// <eVoiceType_DmgSml = 0x6>
		eVoiceType_DmgSml = 6,

		// <eVoiceType_DmgBig = 0x7>
		eVoiceType_DmgBig = 7,

		// <eVoiceType_PcDownAtked = 0x8>
		eVoiceType_PcDownAtked = 8,

		// <eVoiceType_TB_Win1 = 0x9>
		eVoiceType_TB_Win1 = 9,

		// <eVoiceType_TB_Win2 = 0xa>
		eVoiceType_TB_Win2 = 10,

		// <eVoiceType_TB_Win3 = 0xb>
		eVoiceType_TB_Win3 = 11,

		// <eVoiceType_TB_Lose1 = 0xc>
		eVoiceType_TB_Lose1 = 12,

		// <eVoiceType_TB_Lose2 = 0xd>
		eVoiceType_TB_Lose2 = 13,

		// <eVoiceType_TB_Lose3 = 0xe>
		eVoiceType_TB_Lose3 = 14,

		// <eVoiceType_NUM = 0xf>
		eVoiceType_NUM = 15

	};

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <class PJState* m_StatePtrArr[0x3c], offset 0x580>
	class PJState* m_StatePtrArr[60];

	// <enum eZkBoneScale m_BoneScale, offset 0x670>
	enum eZkBoneScale m_BoneScale;

	// <struct ZkSetDamageInfo m_SetDamageInfo, offset 0x674>
	struct ZkSetDamageInfo m_SetDamageInfo;

	// <struct PJZAKO::ZakoInfo m_ZakoInfo, offset 0x678>
	struct PJZAKO::ZakoInfo m_ZakoInfo;

	// <struct PJZAKO::MotionInfo m_MotionInfo, offset 0x70c>
	struct PJZAKO::MotionInfo m_MotionInfo;

	// <struct PJZAKO::TojoInfo m_TojoInfo, offset 0x71c>
	struct PJZAKO::TojoInfo m_TojoInfo;

	// <struct PJZAKO::PcInfo m_PcInfo, offset 0x730>
	struct PJZAKO::PcInfo m_PcInfo;

	// <struct PJZAKO::DmgInfo m_DmgInfo, offset 0x770>
	struct PJZAKO::DmgInfo m_DmgInfo;

	// <struct PJZAKO::AiInfo m_AiInfo, offset 0x7b4>
	struct PJZAKO::AiInfo m_AiInfo;

	// <int32_t m_Counter, offset 0x800>
	int32_t m_Counter = 0;

	// <int32_t m_CheckCanHitPrevCnt, offset 0x804>
	int32_t m_CheckCanHitPrevCnt = 0;

	// <int32_t m_AddKillNumWaitCounter, offset 0x808>
	int32_t m_AddKillNumWaitCounter = 0;

	// <uint8_t m_boAddedKillNum, offset 0x80c>
	uint8_t m_boAddedKillNum = 0;

	// <uint8_t m_boMoveTurretFlag, offset 0x80d>
	uint8_t m_boMoveTurretFlag = 0;

	// <uint8_t m_boWayPointMoveAfterPop, offset 0x80e>
	uint8_t m_boWayPointMoveAfterPop = 0;

	// <Unidentified data segment, offset 0x80f>
private:
	char _UnidentifiedData_2063[1];

public:
	// <class PJStateMachine* m_pStateMachine, offset 0x810>
	class PJStateMachine* m_pStateMachine = nullptr;

	// <enum eZkStat m_eNowStateIdx, offset 0x814>
	enum eZkStat m_eNowStateIdx;

	// <enum eZkStat m_ePrevStateIdx, offset 0x818>
	enum eZkStat m_ePrevStateIdx;

	// <enum eScareType m_eScareType, offset 0x81c>
	enum eScareType m_eScareType;

	// <float mTargetDirec, offset 0x820>
	float mTargetDirec = 0;

	// <float mNowDirecY, offset 0x824>
	float mNowDirecY = 0;

	// <int32_t mDeadModelType, offset 0x828>
	int32_t mDeadModelType = 0;

	// <struct PJZAKO::EfDanmen m_EfDanmen, offset 0x82c>
	struct PJZAKO::EfDanmen m_EfDanmen;

	// <class EffectCutMark* m_pCutMark, offset 0x838>
	class EffectCutMark* m_pCutMark = nullptr;

	// <class EffectQuestion* mpEfQuestion, offset 0x83c>
	class EffectQuestion* mpEfQuestion = nullptr;

	// <class PJZakoMotMng* m_pMotMng, offset 0x840>
	class PJZakoMotMng* m_pMotMng = nullptr;

	// <class FkStlVector<Vec> m_WayPointArry, offset 0x844>
	class FkStlVector<Vec> m_WayPointArry;

	// <int32_t m_iWayPoint, offset 0x858>
	int32_t m_iWayPoint = 0;

	// <class PathPlanner* m_pPathPlanner, offset 0x85c>
	class PathPlanner* m_pPathPlanner = nullptr;

	// <uint8_t m_boUseObstacleSensor, offset 0x860>
	uint8_t m_boUseObstacleSensor = 0;

	// <uint8_t m_boDisableInterestIK, offset 0x861>
	uint8_t m_boDisableInterestIK = 0;

	// <uint8_t m_boBerserkAtk, offset 0x862>
	uint8_t m_boBerserkAtk = 0;

	// <uint8_t m_boRequestDeathOutOfCamera, offset 0x863>
	uint8_t m_boRequestDeathOutOfCamera = 0;

	// <uint8_t m_boFirstBombDeadFxPlay, offset 0x864>
	uint8_t m_boFirstBombDeadFxPlay = 0;

	// <Unidentified data segment, offset 0x865>
private:
	char _UnidentifiedData_2149[3];

public:
	// <struct Vec m_JumpOffTojoLandingPos, offset 0x868>
	struct Vec m_JumpOffTojoLandingPos;

	// <uint8_t m_boFixTurret, offset 0x874>
	uint8_t m_boFixTurret = 0;

	// <Unidentified data segment, offset 0x875>
private:
	char _UnidentifiedData_2165[3];

public:
	// <enum PJZAKO::eSuddenAtkPopDir m_eSdnAtkPopDir, offset 0x878>
	enum PJZAKO::eSuddenAtkPopDir m_eSdnAtkPopDir;

	// <class FkDynamicParam* m_pDP, offset 0x87c>
	class FkDynamicParam* m_pDP = nullptr;

	// <class FkObstacleSensor* m_pObsSens, offset 0x880>
	class FkObstacleSensor* m_pObsSens = nullptr;

	// <int32_t m_Atk2PcHitAfterCnt, offset 0x884>
	int32_t m_Atk2PcHitAfterCnt = 0;

	// <uint8_t m_boPcDownLaugh, offset 0x888>
	uint8_t m_boPcDownLaugh = 0;

	// <Unidentified data segment, offset 0x889>
private:
	char _UnidentifiedData_2185[3];

public:
	// <class FkBulletManager* m_pBulletManager, offset 0x88c>
	class FkBulletManager* m_pBulletManager = nullptr;

	// <uint8_t m_boPhysicDeadProc, offset 0x890>
	uint8_t m_boPhysicDeadProc = 0;

	// <uint8_t m_bIsHeadPhysicsEnd, offset 0x891>
	uint8_t m_bIsHeadPhysicsEnd = 0;

	// <Unidentified data segment, offset 0x892>
private:
	char _UnidentifiedData_2194[2];

public:
	// <class TGmf* m_pPhysicDeadGmf, offset 0x894>
	class TGmf* m_pPhysicDeadGmf = nullptr;

	// <uint8_t m_boTodomeDead, offset 0x898>
	uint8_t m_boTodomeDead = 0;

	// <uint8_t m_boDeadEffectReq, offset 0x899>
	uint8_t m_boDeadEffectReq = 0;

	// <Unidentified data segment, offset 0x89a>
private:
	char _UnidentifiedData_2202[2];

public:
	// <int32_t m_DeadEffectCountCown, offset 0x89c>
	int32_t m_DeadEffectCountCown = 0;

	// <int32_t m_ParticleDeadZakoTerminateWaitTick, offset 0x8a0>
	int32_t m_ParticleDeadZakoTerminateWaitTick = 0;

	// <class mot::CBoneEffectDamageData* m_pBnFxDmgDat, offset 0x8a4>
	class mot::CBoneEffectDamageData* m_pBnFxDmgDat = nullptr;

	// <uint8_t m_boTimeShareUpdate, offset 0x8a8>
	uint8_t m_boTimeShareUpdate = 0;

	// <Unidentified data segment, offset 0x8a9>
private:
	char _UnidentifiedData_2217[3];

public:
	// <enum PJZAKO::eTimeShare m_eTimeShareStat, offset 0x8ac>
	enum PJZAKO::eTimeShare m_eTimeShareStat;

	// <struct CollInfo m_CollInfo, offset 0x8b0>
	struct CollInfo m_CollInfo;

	// <struct tagGHMR_TEX m_Tex, offset 0x8bc>
	struct tagGHMR_TEX m_Tex;

	// <int32_t m_ChangeStateLimitTick, offset 0x8e4>
	int32_t m_ChangeStateLimitTick = 0;

	// <float m_fRotSpd, offset 0x8e8>
	float m_fRotSpd = 0;

	// <class FkStlList<commonObj *> m_BreakPopCmnObjPtrList, offset 0x8ec>
	class FkStlList<commonObj *> m_BreakPopCmnObjPtrList;

	// <class commonObj* m_pSyncPopCmnObj, offset 0x8f8>
	class commonObj* m_pSyncPopCmnObj = nullptr;

	// <uint8_t m_boCalledNoGuardEfOnce, offset 0x8fc>
	uint8_t m_boCalledNoGuardEfOnce = 0;

	// <Unidentified data segment, offset 0x8fd>
private:
	char _UnidentifiedData_2301[3];

public:
	// <int32_t m_OutOfCameraIkakuShootTime, offset 0x900>
	int32_t m_OutOfCameraIkakuShootTime = 0;

	// <class State_Damage m_State_Damage, offset 0x904>
	class State_Damage m_State_Damage;

	// <class State_CloseBeforeAttack m_State_CloseForAtk, offset 0x910>
	class State_CloseBeforeAttack m_State_CloseForAtk;

	// <class State_AwayAfterAttack m_State_AwayAfterAtk, offset 0x914>
	class State_AwayAfterAttack m_State_AwayAfterAtk;

	// <class State_ComboAttack m_State_ComboAttack, offset 0x918>
	class State_ComboAttack m_State_ComboAttack;

	// <class State_StepInAttack m_State_StepInAttack, offset 0x924>
	class State_StepInAttack m_State_StepInAttack;

	// <class State_Defence m_State_Defence, offset 0x928>
	class State_Defence m_State_Defence;

	// <class State_Evacuate m_State_Evacuate, offset 0x930>
	class State_Evacuate m_State_Evacuate;

	// <class State_RandomMove m_State_RandomMove, offset 0x938>
	class State_RandomMove m_State_RandomMove;

	// <class State_ThroughDamage m_State_ThroughDamage, offset 0x940>
	class State_ThroughDamage m_State_ThroughDamage;

	// <class State_DownDamage m_State_DownDamage, offset 0x948>
	class State_DownDamage m_State_DownDamage;

	// <class State_Pressure m_State_Pressure, offset 0x94c>
	class State_Pressure m_State_Pressure;

	// <class State_WayPointMove m_State_WayPointMove, offset 0x958>
	class State_WayPointMove m_State_WayPointMove;

	// <class State_Scare_Run m_State_Run, offset 0x960>
	class State_Scare_Run m_State_Run;

	// <class State_Scare_Kosinukasi m_State_Kosinukasi, offset 0x968>
	class State_Scare_Kosinukasi m_State_Kosinukasi;

	// <class State_Scare_Yotunbai m_State_Yotunbai, offset 0x970>
	class State_Scare_Yotunbai m_State_Yotunbai;

	// <class State_Scare_Stand m_State_Stand, offset 0x978>
	class State_Scare_Stand m_State_Stand;

	// <class State_PerformIll m_StatePerformIll, offset 0x980>
	class State_PerformIll m_StatePerformIll;

	// <class State_ReleaseWaitIdle m_ReleaseWaitIdle, offset 0x988>
	class State_ReleaseWaitIdle m_ReleaseWaitIdle;

	// <class State_Tojo_RunAndTurnPc m_State_Tojo_RunAndTurnPc, offset 0x98c>
	class State_Tojo_RunAndTurnPc m_State_Tojo_RunAndTurnPc;

	// <class State_Tojo_AgainstWall m_State_Tojo_AgainstWall, offset 0x990>
	class State_Tojo_AgainstWall m_State_Tojo_AgainstWall;

	// <class State_Tojo_LookAround m_State_Tojo_LookAround, offset 0x994>
	class State_Tojo_LookAround m_State_Tojo_LookAround;

	// <class State_Tojo_Stand m_State_Tojo_Stand, offset 0x998>
	class State_Tojo_Stand m_State_Tojo_Stand;

	// <class State_Tojo_Bench m_State_Tojo_Bench, offset 0x99c>
	class State_Tojo_Bench m_State_Tojo_Bench;

	// <class State_Tojo_Sit m_State_Tojo_Sit, offset 0x9a0>
	class State_Tojo_Sit m_State_Tojo_Sit;

	// <class State_Tojo_Car m_State_Tojo_Car, offset 0x9a4>
	class State_Tojo_Car m_State_Tojo_Car;

	// <class State_Tojo_JumpOff m_State_Tojo_JumpOff, offset 0x9ac>
	class State_Tojo_JumpOff m_State_Tojo_JumpOff;

	// <class State_Tojo_BreakCmnObj m_State_Tojo_BreakCmnObj, offset 0x9b4>
	class State_Tojo_BreakCmnObj m_State_Tojo_BreakCmnObj;

	// <class State_Tojo_AeroBike m_State_Tojo_AeroBike, offset 0x9c0>
	class State_Tojo_AeroBike m_State_Tojo_AeroBike;

	// <class State_Tojo_RoomRunner m_State_Tojo_RoomRunner, offset 0x9c8>
	class State_Tojo_RoomRunner m_State_Tojo_RoomRunner;

	// <class State_LeadPcWayPointMove m_State_LeadPcWayPointMove, offset 0x9d0>
	class State_LeadPcWayPointMove m_State_LeadPcWayPointMove;

	// <class State_FixTurret m_State_FixTurret, offset 0x9d4>
	class State_FixTurret m_State_FixTurret;

	// <class State_WayPointMoveAfterPop m_State_WayPointMoveAfterPop, offset 0x9d8>
	class State_WayPointMoveAfterPop m_State_WayPointMoveAfterPop;

	// <class ZkState_DownAttack m_State_DownAttack, offset 0x9dc>
	class ZkState_DownAttack m_State_DownAttack;

	/// 296 Functions

	// [Function] void __convention("thiscall") PJZAKO::SetJumpOffTojoLandingPos(class PJZAKO* const this, struct Vec& arg2) [?SetJumpOffTojoLandingPos@PJZAKO@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _SetJumpOffTojoLandingPos_PJZAKO__QAEXABUVec___Z)(class PJZAKO* const thisPtr, struct Vec& arg2);
	void SetJumpOffTojoLandingPos(struct Vec& arg2)
	{
		_SetJumpOffTojoLandingPos_PJZAKO__QAEXABUVec___Z mFunc = (_SetJumpOffTojoLandingPos_PJZAKO__QAEXABUVec___Z)(GameModule + 0xa2340);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetWaitReleaseIdleStateFlag(class PJZAKO* const this, uint8_t arg2) [?SetWaitReleaseIdleStateFlag@PJZAKO@@QAEX_N@Z]
	typedef void(__thiscall* _SetWaitReleaseIdleStateFlag_PJZAKO__QAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void SetWaitReleaseIdleStateFlag(uint8_t arg2)
	{
		_SetWaitReleaseIdleStateFlag_PJZAKO__QAEX_N_Z mFunc = (_SetWaitReleaseIdleStateFlag_PJZAKO__QAEX_N_Z)(GameModule + 0xa2360);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetMoveTurretFlag(class PJZAKO* const this, uint8_t arg2) [?SetMoveTurretFlag@PJZAKO@@QAEX_N@Z]
	typedef void(__thiscall* _SetMoveTurretFlag_PJZAKO__QAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void SetMoveTurretFlag(uint8_t arg2)
	{
		_SetMoveTurretFlag_PJZAKO__QAEX_N_Z mFunc = (_SetMoveTurretFlag_PJZAKO__QAEX_N_Z)(GameModule + 0xa2370);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::GetMoveTurretFlag(class PJZAKO* const this) [?GetMoveTurretFlag@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetMoveTurretFlag_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t GetMoveTurretFlag()
	{
		_GetMoveTurretFlag_PJZAKO__QAE_NXZ mFunc = (_GetMoveTurretFlag_PJZAKO__QAE_NXZ)(GameModule + 0xa2380);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetWayPointMoveAfterPopFlag(class PJZAKO* const this, uint8_t arg2) [?SetWayPointMoveAfterPopFlag@PJZAKO@@QAEX_N@Z]
	typedef void(__thiscall* _SetWayPointMoveAfterPopFlag_PJZAKO__QAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void SetWayPointMoveAfterPopFlag(uint8_t arg2)
	{
		_SetWayPointMoveAfterPopFlag_PJZAKO__QAEX_N_Z mFunc = (_SetWayPointMoveAfterPopFlag_PJZAKO__QAEX_N_Z)(GameModule + 0xa2390);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::GetWayPointMoveAfterPopFlag(class PJZAKO* const this) [?GetWayPointMoveAfterPopFlag@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetWayPointMoveAfterPopFlag_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t GetWayPointMoveAfterPopFlag()
	{
		_GetWayPointMoveAfterPopFlag_PJZAKO__QAE_NXZ mFunc = (_GetWayPointMoveAfterPopFlag_PJZAKO__QAE_NXZ)(GameModule + 0xa23a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetSyncPopCmnObjPtr(class PJZAKO* const this, class commonObj* arg2) [?SetSyncPopCmnObjPtr@PJZAKO@@QAEXPAVcommonObj@@@Z]
	typedef void(__thiscall* _SetSyncPopCmnObjPtr_PJZAKO__QAEXPAVcommonObj___Z)(class PJZAKO* const thisPtr, class commonObj* arg2);
	void SetSyncPopCmnObjPtr(class commonObj* arg2)
	{
		_SetSyncPopCmnObjPtr_PJZAKO__QAEXPAVcommonObj___Z mFunc = (_SetSyncPopCmnObjPtr_PJZAKO__QAEXPAVcommonObj___Z)(GameModule + 0xa23b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetDeadEffectDelayCnt(class PJZAKO* const this, int32_t arg2) [?SetDeadEffectDelayCnt@PJZAKO@@QAEXH@Z]
	typedef void(__thiscall* _SetDeadEffectDelayCnt_PJZAKO__QAEXH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	void SetDeadEffectDelayCnt(int32_t arg2)
	{
		_SetDeadEffectDelayCnt_PJZAKO__QAEXH_Z mFunc = (_SetDeadEffectDelayCnt_PJZAKO__QAEXH_Z)(GameModule + 0xaabc0);
		return mFunc(this, arg2);
	}
	// [Function] enum eDownDir __convention("thiscall") PJZAKO::GetDownDir(class PJZAKO* const this) [?GetDownDir@PJZAKO@@QAE?AW4eDownDir@@XZ]
	typedef enum eDownDir(__thiscall* _GetDownDir_PJZAKO__QAEAW4eDownDir__XZ)(class PJZAKO* const thisPtr);
	/* enum eDownDir */ uint32_t GetDownDir()
	{
		_GetDownDir_PJZAKO__QAEAW4eDownDir__XZ mFunc = (_GetDownDir_PJZAKO__QAEAW4eDownDir__XZ)(GameModule + 0xaabd0);
		return (uint32_t)mFunc(this);
	}
	// [Function] enum eZkBoneScale __convention("thiscall") PJZAKO::GetBoneScale(class PJZAKO* const this) [?GetBoneScale@PJZAKO@@QAE?AW4eZkBoneScale@@XZ]
	typedef enum eZkBoneScale(__thiscall* _GetBoneScale_PJZAKO__QAEAW4eZkBoneScale__XZ)(class PJZAKO* const thisPtr);
	/* enum eZkBoneScale */ uint32_t GetBoneScale()
	{
		_GetBoneScale_PJZAKO__QAEAW4eZkBoneScale__XZ mFunc = (_GetBoneScale_PJZAKO__QAEAW4eZkBoneScale__XZ)(GameModule + 0xaabe0);
		return (uint32_t)mFunc(this);
	}
	// [Function] struct PJZAKO::PcInfo* __convention("thiscall") PJZAKO::GetPcInfoPtr(class PJZAKO* const this) [?GetPcInfoPtr@PJZAKO@@QAEPAUPcInfo@1@XZ]
	typedef struct PJZAKO::PcInfo*(__thiscall* _GetPcInfoPtr_PJZAKO__QAEPAUPcInfo_1_XZ)(class PJZAKO* const thisPtr);
	struct PJZAKO::PcInfo* GetPcInfoPtr()
	{
		_GetPcInfoPtr_PJZAKO__QAEPAUPcInfo_1_XZ mFunc = (_GetPcInfoPtr_PJZAKO__QAEPAUPcInfo_1_XZ)(GameModule + 0xb9670);
		return mFunc(this);
	}
	// [Function] struct PJZAKO::AiInfo* __convention("thiscall") PJZAKO::GetAiInfoPtr(class PJZAKO* const this) [?GetAiInfoPtr@PJZAKO@@QAEPAUAiInfo@1@XZ]
	typedef struct PJZAKO::AiInfo*(__thiscall* _GetAiInfoPtr_PJZAKO__QAEPAUAiInfo_1_XZ)(class PJZAKO* const thisPtr);
	struct PJZAKO::AiInfo* GetAiInfoPtr()
	{
		_GetAiInfoPtr_PJZAKO__QAEPAUAiInfo_1_XZ mFunc = (_GetAiInfoPtr_PJZAKO__QAEPAUAiInfo_1_XZ)(GameModule + 0xb9680);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetFightLine(class PJZAKO* const this, enum eFightLine arg2) [?SetFightLine@PJZAKO@@QAEXW4eFightLine@@@Z]
	typedef void(__thiscall* _SetFightLine_PJZAKO__QAEXW4eFightLine___Z)(class PJZAKO* const thisPtr, enum eFightLine arg2);
	void SetFightLine(/* enum eFightLine */ uint32_t arg2)
	{
		_SetFightLine_PJZAKO__QAEXW4eFightLine___Z mFunc = (_SetFightLine_PJZAKO__QAEXW4eFightLine___Z)(GameModule + 0xb9690);
		return mFunc(this, (enum eFightLine)arg2);
	}
	// [Function] enum eFightLine __convention("thiscall") PJZAKO::GetFightLine(class PJZAKO* const this) [?GetFightLine@PJZAKO@@QAE?AW4eFightLine@@XZ]
	typedef enum eFightLine(__thiscall* _GetFightLine_PJZAKO__QAEAW4eFightLine__XZ)(class PJZAKO* const thisPtr);
	/* enum eFightLine */ uint32_t GetFightLine()
	{
		_GetFightLine_PJZAKO__QAEAW4eFightLine__XZ mFunc = (_GetFightLine_PJZAKO__QAEAW4eFightLine__XZ)(GameModule + 0xb96a0);
		return (uint32_t)mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::RequestDeadOutOfCamera(class PJZAKO* const this) [?RequestDeadOutOfCamera@PJZAKO@@QAEXXZ]
	typedef void(__thiscall* _RequestDeadOutOfCamera_PJZAKO__QAEXXZ)(class PJZAKO* const thisPtr);
	void RequestDeadOutOfCamera()
	{
		_RequestDeadOutOfCamera_PJZAKO__QAEXXZ mFunc = (_RequestDeadOutOfCamera_PJZAKO__QAEXXZ)(GameModule + 0xb96b0);
		return mFunc(this);
	}
	// [Function] enum eZkStat __convention("thiscall") PJZAKO::GetNowStateIdx(class PJZAKO* const this) [?GetNowStateIdx@PJZAKO@@QBE?AW4eZkStat@@XZ]
	typedef enum eZkStat(__thiscall* _GetNowStateIdx_PJZAKO__QBEAW4eZkStat__XZ)(class PJZAKO* const thisPtr);
	/* enum eZkStat */ uint32_t GetNowStateIdx()
	{
		_GetNowStateIdx_PJZAKO__QBEAW4eZkStat__XZ mFunc = (_GetNowStateIdx_PJZAKO__QBEAW4eZkStat__XZ)(GameModule + 0xb96c0);
		return (uint32_t)mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetCutAiFlag(class PJZAKO* const this, uint8_t arg2) [?SetCutAiFlag@PJZAKO@@QAEX_N@Z]
	typedef void(__thiscall* _SetCutAiFlag_PJZAKO__QAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void SetCutAiFlag(uint8_t arg2)
	{
		_SetCutAiFlag_PJZAKO__QAEX_N_Z mFunc = (_SetCutAiFlag_PJZAKO__QAEX_N_Z)(GameModule + 0xbc0d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::GetCutAiFlag(class PJZAKO* const this) [?GetCutAiFlag@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetCutAiFlag_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t GetCutAiFlag()
	{
		_GetCutAiFlag_PJZAKO__QAE_NXZ mFunc = (_GetCutAiFlag_PJZAKO__QAE_NXZ)(GameModule + 0xbc0e0);
		return mFunc(this);
	}
	// [Function] class PJZakoMotMng* __convention("thiscall") PJZAKO::GetMotMngPtr(class PJZAKO* const this) [?GetMotMngPtr@PJZAKO@@QAEPAVPJZakoMotMng@@XZ]
	typedef class PJZakoMotMng*(__thiscall* _GetMotMngPtr_PJZAKO__QAEPAVPJZakoMotMng__XZ)(class PJZAKO* const thisPtr);
	class PJZakoMotMng* GetMotMngPtr()
	{
		_GetMotMngPtr_PJZAKO__QAEPAVPJZakoMotMng__XZ mFunc = (_GetMotMngPtr_PJZAKO__QAEPAVPJZakoMotMng__XZ)(GameModule + 0xbc0f0);
		return mFunc(this);
	}
	// [Function] struct PJZAKO::ZakoInfo* __convention("thiscall") PJZAKO::GetZakoInfoPtr(class PJZAKO* const this) [?GetZakoInfoPtr@PJZAKO@@QAEPAUZakoInfo@1@XZ]
	typedef struct PJZAKO::ZakoInfo*(__thiscall* _GetZakoInfoPtr_PJZAKO__QAEPAUZakoInfo_1_XZ)(class PJZAKO* const thisPtr);
	struct PJZAKO::ZakoInfo* GetZakoInfoPtr()
	{
		_GetZakoInfoPtr_PJZAKO__QAEPAUZakoInfo_1_XZ mFunc = (_GetZakoInfoPtr_PJZAKO__QAEPAUZakoInfo_1_XZ)(GameModule + 0xbc100);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetBoneMotMax(class PJZAKO* const this) [?GetBoneMotMax@PJZAKO@@UBEHXZ]
	typedef int32_t(__thiscall* _GetBoneMotMax_PJZAKO__UBEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetBoneMotMax()
	{
		_GetBoneMotMax_PJZAKO__UBEHXZ mFunc = (_GetBoneMotMax_PJZAKO__UBEHXZ)(GameModule + 0xbc110);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") PJZAKO::GetBackDist(class PJZAKO* const this) [?GetBackDist@PJZAKO@@QAEMXZ]
	typedef float(__thiscall* _GetBackDist_PJZAKO__QAEMXZ)(class PJZAKO* const thisPtr);
	float GetBackDist()
	{
		_GetBackDist_PJZAKO__QAEMXZ mFunc = (_GetBackDist_PJZAKO__QAEMXZ)(GameModule + 0xbc120);
		return mFunc(this);
	}
	// [Function] class TGan* __convention("thiscall") PJZAKO::mpGetGan(class PJZAKO* const this, int32_t arg2) [?mpGetGan@PJZAKO@@UAEPAVTGan@@H@Z]
	typedef class TGan*(__thiscall* _mpGetGan_PJZAKO__UAEPAVTGan__H_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	class TGan* mpGetGan(int32_t arg2)
	{
		_mpGetGan_PJZAKO__UAEPAVTGan__H_Z mFunc = (_mpGetGan_PJZAKO__UAEPAVTGan__H_Z)(GameModule + 0xbc130);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") PJZAKO::GetPcDist(class PJZAKO* const this) [?GetPcDist@PJZAKO@@QBEMXZ]
	typedef float(__thiscall* _GetPcDist_PJZAKO__QBEMXZ)(class PJZAKO* const thisPtr);
	float GetPcDist()
	{
		_GetPcDist_PJZAKO__QBEMXZ mFunc = (_GetPcDist_PJZAKO__QBEMXZ)(GameModule + 0xbc140);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetStepInAtkMotIdx(class PJZAKO* const this) [?GetStepInAtkMotIdx@PJZAKO@@UAEHXZ]
	typedef int32_t(__thiscall* _GetStepInAtkMotIdx_PJZAKO__UAEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetStepInAtkMotIdx()
	{
		_GetStepInAtkMotIdx_PJZAKO__UAEHXZ mFunc = (_GetStepInAtkMotIdx_PJZAKO__UAEHXZ)(GameModule + 0xbc150);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetScareType(class PJZAKO* const this, enum eScareType arg2) [?SetScareType@PJZAKO@@QAEXW4eScareType@@@Z]
	typedef void(__thiscall* _SetScareType_PJZAKO__QAEXW4eScareType___Z)(class PJZAKO* const thisPtr, enum eScareType arg2);
	void SetScareType(/* enum eScareType */ uint32_t arg2)
	{
		_SetScareType_PJZAKO__QAEXW4eScareType___Z mFunc = (_SetScareType_PJZAKO__QAEXW4eScareType___Z)(GameModule + 0xbc160);
		return mFunc(this, (enum eScareType)arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::GetGetOffCarFlag(class PJZAKO* const this) [?GetGetOffCarFlag@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetGetOffCarFlag_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t GetGetOffCarFlag()
	{
		_GetGetOffCarFlag_PJZAKO__QAE_NXZ mFunc = (_GetGetOffCarFlag_PJZAKO__QAE_NXZ)(GameModule + 0xbc170);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetDownAtkMot(class PJZAKO* const this) [?GetDownAtkMot@PJZAKO@@UAEHXZ]
	typedef int32_t(__thiscall* _GetDownAtkMot_PJZAKO__UAEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetDownAtkMot()
	{
		_GetDownAtkMot_PJZAKO__UAEHXZ mFunc = (_GetDownAtkMot_PJZAKO__UAEHXZ)(GameModule + 0xbc180);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCheckGuard(class PJZAKO* const this) [?mCheckGuard@PJZAKO@@MAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckGuard_PJZAKO__MAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mCheckGuard()
	{
		_mCheckGuard_PJZAKO__MAE_NXZ mFunc = (_mCheckGuard_PJZAKO__MAE_NXZ)(GameModule + 0xbc190);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::FireBullet(class PJZAKO* const this, uint8_t arg2, uint8_t arg3) [?FireBullet@PJZAKO@@MAEX_N0@Z]
	typedef void(__thiscall* _FireBullet_PJZAKO__MAEX_N0_Z)(class PJZAKO* const thisPtr, uint8_t arg2, uint8_t arg3);
	void FireBullet(uint8_t arg2, uint8_t arg3)
	{
		_FireBullet_PJZAKO__MAEX_N0_Z mFunc = (_FireBullet_PJZAKO__MAEX_N0_Z)(GameModule + 0xbc1a0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class PJState* __convention("thiscall") PJZAKO::GetStatePtr(class PJZAKO* const this, enum eZkStat arg2) [?GetStatePtr@PJZAKO@@AAEPAVPJState@@W4eZkStat@@@Z]
	typedef class PJState*(__thiscall* _GetStatePtr_PJZAKO__AAEPAVPJState__W4eZkStat___Z)(class PJZAKO* const thisPtr, enum eZkStat arg2);
	class PJState* GetStatePtr(/* enum eZkStat */ uint32_t arg2)
	{
		_GetStatePtr_PJZAKO__AAEPAVPJState__W4eZkStat___Z mFunc = (_GetStatePtr_PJZAKO__AAEPAVPJState__W4eZkStat___Z)(GameModule + 0xbc1b0);
		return mFunc(this, (enum eZkStat)arg2);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetReactRatio(class PJZAKO* const this) [?GetReactRatio@PJZAKO@@ABEHXZ]
	typedef int32_t(__thiscall* _GetReactRatio_PJZAKO__ABEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetReactRatio()
	{
		_GetReactRatio_PJZAKO__ABEHXZ mFunc = (_GetReactRatio_PJZAKO__ABEHXZ)(GameModule + 0xbc1d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetRideCarSheet(class PJZAKO* const this, enum eZkCarSheet& arg2) [?SetRideCarSheet@PJZAKO@@QAEXABW4eZkCarSheet@@@Z]
	typedef void(__thiscall* _SetRideCarSheet_PJZAKO__QAEXABW4eZkCarSheet___Z)(class PJZAKO* const thisPtr, enum eZkCarSheet& arg2);
	void SetRideCarSheet(/* enum eZkCarSheet& */ uint32_t arg2)
	{
		_SetRideCarSheet_PJZAKO__QAEXABW4eZkCarSheet___Z mFunc = (_SetRideCarSheet_PJZAKO__QAEXABW4eZkCarSheet___Z)(GameModule + 0xbd2d0);
		return mFunc(this, (enum eZkCarSheet&)arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::ZeroMove(class PJZAKO* const this) [?ZeroMove@PJZAKO@@QAEXXZ]
	typedef void(__thiscall* _ZeroMove_PJZAKO__QAEXXZ)(class PJZAKO* const thisPtr);
	void ZeroMove()
	{
		_ZeroMove_PJZAKO__QAEXXZ mFunc = (_ZeroMove_PJZAKO__QAEXXZ)(GameModule + 0xbfed0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::GetFixTurretFlag(class PJZAKO* const this) [?GetFixTurretFlag@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetFixTurretFlag_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t GetFixTurretFlag()
	{
		_GetFixTurretFlag_PJZAKO__QAE_NXZ mFunc = (_GetFixTurretFlag_PJZAKO__QAE_NXZ)(GameModule + 0xbff00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetUseObstacleSensor(class PJZAKO* const this, uint8_t arg2) [?SetUseObstacleSensor@PJZAKO@@QAEX_N@Z]
	typedef void(__thiscall* _SetUseObstacleSensor_PJZAKO__QAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void SetUseObstacleSensor(uint8_t arg2)
	{
		_SetUseObstacleSensor_PJZAKO__QAEX_N_Z mFunc = (_SetUseObstacleSensor_PJZAKO__QAEX_N_Z)(GameModule + 0xc02e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetDisableInterestIK(class PJZAKO* const this, uint8_t arg2) [?SetDisableInterestIK@PJZAKO@@QAEX_N@Z]
	typedef void(__thiscall* _SetDisableInterestIK_PJZAKO__QAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void SetDisableInterestIK(uint8_t arg2)
	{
		_SetDisableInterestIK_PJZAKO__QAEX_N_Z mFunc = (_SetDisableInterestIK_PJZAKO__QAEX_N_Z)(GameModule + 0xd8a60);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") PJZAKO::GetJumpOffTojoLandingPos(class PJZAKO* const this) [?GetJumpOffTojoLandingPos@PJZAKO@@QAEABUVec@@XZ]
	typedef struct Vec&(__thiscall* _GetJumpOffTojoLandingPos_PJZAKO__QAEABUVec__XZ)(class PJZAKO* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void GetJumpOffTojoLandingPos()
	{
		_GetJumpOffTojoLandingPos_PJZAKO__QAEABUVec__XZ mFunc = (_GetJumpOffTojoLandingPos_PJZAKO__QAEABUVec__XZ)(GameModule + 0xd8a70);
		mFunc(this);
	}
	// [Function] struct PJZAKO::TojoInfo* __convention("thiscall") PJZAKO::GetTojoInfoPtr(class PJZAKO* const this) [?GetTojoInfoPtr@PJZAKO@@QAEPAUTojoInfo@1@XZ]
	typedef struct PJZAKO::TojoInfo*(__thiscall* _GetTojoInfoPtr_PJZAKO__QAEPAUTojoInfo_1_XZ)(class PJZAKO* const thisPtr);
	struct PJZAKO::TojoInfo* GetTojoInfoPtr()
	{
		_GetTojoInfoPtr_PJZAKO__QAEPAUTojoInfo_1_XZ mFunc = (_GetTojoInfoPtr_PJZAKO__QAEPAUTojoInfo_1_XZ)(GameModule + 0xd8a80);
		return mFunc(this);
	}
	// [Function] struct PJZAKO::DmgInfo* __convention("thiscall") PJZAKO::GetDmgInfoPtr(class PJZAKO* const this) [?GetDmgInfoPtr@PJZAKO@@QAEPAUDmgInfo@1@XZ]
	typedef struct PJZAKO::DmgInfo*(__thiscall* _GetDmgInfoPtr_PJZAKO__QAEPAUDmgInfo_1_XZ)(class PJZAKO* const thisPtr);
	struct PJZAKO::DmgInfo* GetDmgInfoPtr()
	{
		_GetDmgInfoPtr_PJZAKO__QAEPAUDmgInfo_1_XZ mFunc = (_GetDmgInfoPtr_PJZAKO__QAEPAUDmgInfo_1_XZ)(GameModule + 0xd8a90);
		return mFunc(this);
	}
	// [Function] enum eZkCarSheet& __convention("thiscall") PJZAKO::GetRideCarSheet(class PJZAKO* const this) [?GetRideCarSheet@PJZAKO@@QAEABW4eZkCarSheet@@XZ]
	typedef enum eZkCarSheet&(__thiscall* _GetRideCarSheet_PJZAKO__QAEABW4eZkCarSheet__XZ)(class PJZAKO* const thisPtr);
	// Can't export & pointer 'enum eZkCarSheet&' [TypeClass.PointerTypeClass] in LuaBridge
	void GetRideCarSheet()
	{
		_GetRideCarSheet_PJZAKO__QAEABW4eZkCarSheet__XZ mFunc = (_GetRideCarSheet_PJZAKO__QAEABW4eZkCarSheet__XZ)(GameModule + 0xd8aa0);
		mFunc(this);
	}
	// [Function] enum ePcSideFromMe __convention("thiscall") PJZAKO::GetPcSideFromMe(class PJZAKO* const this) [?GetPcSideFromMe@PJZAKO@@QAE?AW4ePcSideFromMe@@XZ]
	typedef enum ePcSideFromMe(__thiscall* _GetPcSideFromMe_PJZAKO__QAEAW4ePcSideFromMe__XZ)(class PJZAKO* const thisPtr);
	/* enum ePcSideFromMe */ uint32_t GetPcSideFromMe()
	{
		_GetPcSideFromMe_PJZAKO__QAEAW4ePcSideFromMe__XZ mFunc = (_GetPcSideFromMe_PJZAKO__QAEAW4ePcSideFromMe__XZ)(GameModule + 0xd8ab0);
		return (uint32_t)mFunc(this);
	}
	// [Function] float __convention("thiscall") PJZAKO::GetLeftDist(class PJZAKO* const this) [?GetLeftDist@PJZAKO@@QAEMXZ]
	typedef float(__thiscall* _GetLeftDist_PJZAKO__QAEMXZ)(class PJZAKO* const thisPtr);
	float GetLeftDist()
	{
		_GetLeftDist_PJZAKO__QAEMXZ mFunc = (_GetLeftDist_PJZAKO__QAEMXZ)(GameModule + 0xd8ac0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") PJZAKO::GetRightDist(class PJZAKO* const this) [?GetRightDist@PJZAKO@@QAEMXZ]
	typedef float(__thiscall* _GetRightDist_PJZAKO__QAEMXZ)(class PJZAKO* const thisPtr);
	float GetRightDist()
	{
		_GetRightDist_PJZAKO__QAEMXZ mFunc = (_GetRightDist_PJZAKO__QAEMXZ)(GameModule + 0xd8ad0);
		return mFunc(this);
	}
	// [Function] enum eZkStat __convention("thiscall") PJZAKO::GetPrevStateIdx(class PJZAKO* const this) [?GetPrevStateIdx@PJZAKO@@QAE?AW4eZkStat@@XZ]
	typedef enum eZkStat(__thiscall* _GetPrevStateIdx_PJZAKO__QAEAW4eZkStat__XZ)(class PJZAKO* const thisPtr);
	/* enum eZkStat */ uint32_t GetPrevStateIdx()
	{
		_GetPrevStateIdx_PJZAKO__QAEAW4eZkStat__XZ mFunc = (_GetPrevStateIdx_PJZAKO__QAEAW4eZkStat__XZ)(GameModule + 0xd8ae0);
		return (uint32_t)mFunc(this);
	}
	// [Function] enum eScareType __convention("thiscall") PJZAKO::GetScareType(class PJZAKO* const this) [?GetScareType@PJZAKO@@QAE?AW4eScareType@@XZ]
	typedef enum eScareType(__thiscall* _GetScareType_PJZAKO__QAEAW4eScareType__XZ)(class PJZAKO* const thisPtr);
	/* enum eScareType */ uint32_t GetScareType()
	{
		_GetScareType_PJZAKO__QAEAW4eScareType__XZ mFunc = (_GetScareType_PJZAKO__QAEAW4eScareType__XZ)(GameModule + 0xd8af0);
		return (uint32_t)mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::GetWaitReleaseIdleStateFlag(class PJZAKO* const this) [?GetWaitReleaseIdleStateFlag@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetWaitReleaseIdleStateFlag_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t GetWaitReleaseIdleStateFlag()
	{
		_GetWaitReleaseIdleStateFlag_PJZAKO__QAE_NXZ mFunc = (_GetWaitReleaseIdleStateFlag_PJZAKO__QAE_NXZ)(GameModule + 0xd8b00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::GetBreakPopCmnObjStartFlag(class PJZAKO* const this) [?GetBreakPopCmnObjStartFlag@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetBreakPopCmnObjStartFlag_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t GetBreakPopCmnObjStartFlag()
	{
		_GetBreakPopCmnObjStartFlag_PJZAKO__QAE_NXZ mFunc = (_GetBreakPopCmnObjStartFlag_PJZAKO__QAE_NXZ)(GameModule + 0xd8b10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetThinkCntReady(class PJZAKO* const this) [?SetThinkCntReady@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _SetThinkCntReady_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void SetThinkCntReady()
	{
		_SetThinkCntReady_PJZAKO__AAEXXZ mFunc = (_SetThinkCntReady_PJZAKO__AAEXXZ)(GameModule + 0xd8b20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsWayPointMoveStopping(class PJZAKO* const this) [?IsWayPointMoveStopping@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsWayPointMoveStopping_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsWayPointMoveStopping()
	{
		_IsWayPointMoveStopping_PJZAKO__AAE_NXZ mFunc = (_IsWayPointMoveStopping_PJZAKO__AAE_NXZ)(GameModule + 0xd8b30);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetPiyoTick(class PJZAKO* const this) [?GetPiyoTick@PJZAKO@@AAEHXZ]
	typedef int32_t(__thiscall* _GetPiyoTick_PJZAKO__AAEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetPiyoTick()
	{
		_GetPiyoTick_PJZAKO__AAEHXZ mFunc = (_GetPiyoTick_PJZAKO__AAEHXZ)(GameModule + 0xd8b40);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetRotateSpeed(class PJZAKO* const this, float arg2) [?SetRotateSpeed@PJZAKO@@QAEXM@Z]
	typedef void(__thiscall* _SetRotateSpeed_PJZAKO__QAEXM_Z)(class PJZAKO* const thisPtr, float arg2);
	void SetRotateSpeed(float arg2)
	{
		_SetRotateSpeed_PJZAKO__QAEXM_Z mFunc = (_SetRotateSpeed_PJZAKO__QAEXM_Z)(GameModule + 0xdc730);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetStompingDmgDropMoney(class PJZAKO* const this) [?SetStompingDmgDropMoney@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _SetStompingDmgDropMoney_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void SetStompingDmgDropMoney()
	{
		_SetStompingDmgDropMoney_PJZAKO__AAEXXZ mFunc = (_SetStompingDmgDropMoney_PJZAKO__AAEXXZ)(GameModule + 0x4d02b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetStompDmgDropMoneyTime(class PJZAKO* const this) [?ResetStompDmgDropMoneyTime@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetStompDmgDropMoneyTime_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetStompDmgDropMoneyTime()
	{
		_ResetStompDmgDropMoneyTime_PJZAKO__AAEXXZ mFunc = (_ResetStompDmgDropMoneyTime_PJZAKO__AAEXXZ)(GameModule + 0x4d03d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetPiyoTick(class PJZAKO* const this, int32_t arg2) [?SetPiyoTick@PJZAKO@@AAEXH@Z]
	typedef void(__thiscall* _SetPiyoTick_PJZAKO__AAEXH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	void SetPiyoTick(int32_t arg2)
	{
		_SetPiyoTick_PJZAKO__AAEXH_Z mFunc = (_SetPiyoTick_PJZAKO__AAEXH_Z)(GameModule + 0x4d03f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsNoStateChangeDamage(class PJZAKO* const this) [?IsNoStateChangeDamage@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _IsNoStateChangeDamage_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsNoStateChangeDamage()
	{
		_IsNoStateChangeDamage_PJZAKO__EAE_NXZ mFunc = (_IsNoStateChangeDamage_PJZAKO__EAE_NXZ)(GameModule + 0x4d0460);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsAccumDmgAttackTiming(class PJZAKO* const this) [?IsAccumDmgAttackTiming@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _IsAccumDmgAttackTiming_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsAccumDmgAttackTiming()
	{
		_IsAccumDmgAttackTiming_PJZAKO__EAE_NXZ mFunc = (_IsAccumDmgAttackTiming_PJZAKO__EAE_NXZ)(GameModule + 0x4d04a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetMovSpd(class PJZAKO* const this, float arg2) [?mSetMovSpd@PJZAKO@@UAEXM@Z]
	typedef void(__thiscall* _mSetMovSpd_PJZAKO__UAEXM_Z)(class PJZAKO* const thisPtr, float arg2);
	void mSetMovSpd(float arg2)
	{
		_mSetMovSpd_PJZAKO__UAEXM_Z mFunc = (_mSetMovSpd_PJZAKO__UAEXM_Z)(GameModule + 0x4d04c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::AddPos(class PJZAKO* const this, struct Vec& arg2) [?AddPos@PJZAKO@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _AddPos_PJZAKO__QAEXABUVec___Z)(class PJZAKO* const thisPtr, struct Vec& arg2);
	void AddPos(struct Vec& arg2)
	{
		_AddPos_PJZAKO__QAEXABUVec___Z mFunc = (_AddPos_PJZAKO__QAEXABUVec___Z)(GameModule + 0x4d04e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsAttackHomingTiming(class PJZAKO* const this) [?IsAttackHomingTiming@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsAttackHomingTiming_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsAttackHomingTiming()
	{
		_IsAttackHomingTiming_PJZAKO__UAE_NXZ mFunc = (_IsAttackHomingTiming_PJZAKO__UAE_NXZ)(GameModule + 0x4d0520);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::DeathOutOfCameraRequestProc(class PJZAKO* const this) [?DeathOutOfCameraRequestProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _DeathOutOfCameraRequestProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void DeathOutOfCameraRequestProc()
	{
		_DeathOutOfCameraRequestProc_PJZAKO__AAEXXZ mFunc = (_DeathOutOfCameraRequestProc_PJZAKO__AAEXXZ)(GameModule + 0x4d0530);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetCmnObjAttackPopMotion(class PJZAKO* const this) [?GetCmnObjAttackPopMotion@PJZAKO@@UAEHXZ]
	typedef int32_t(__thiscall* _GetCmnObjAttackPopMotion_PJZAKO__UAEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetCmnObjAttackPopMotion()
	{
		_GetCmnObjAttackPopMotion_PJZAKO__UAEHXZ mFunc = (_GetCmnObjAttackPopMotion_PJZAKO__UAEHXZ)(GameModule + 0x4d05b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::CheckValidWorkingStateMachine(class PJZAKO* const this) [?CheckValidWorkingStateMachine@PJZAKO@@QAEXXZ]
	typedef void(__thiscall* _CheckValidWorkingStateMachine_PJZAKO__QAEXXZ)(class PJZAKO* const thisPtr);
	void CheckValidWorkingStateMachine()
	{
		_CheckValidWorkingStateMachine_PJZAKO__QAEXXZ mFunc = (_CheckValidWorkingStateMachine_PJZAKO__QAEXXZ)(GameModule + 0x4d05c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::AttackAnnouncekEffectProc(class PJZAKO* const this) [?AttackAnnouncekEffectProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _AttackAnnouncekEffectProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void AttackAnnouncekEffectProc()
	{
		_AttackAnnouncekEffectProc_PJZAKO__AAEXXZ mFunc = (_AttackAnnouncekEffectProc_PJZAKO__AAEXXZ)(GameModule + 0x4d05d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsScareState(class PJZAKO* const this) [?IsScareState@PJZAKO@@QBE_NXZ]
	typedef uint8_t(__thiscall* _IsScareState_PJZAKO__QBE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsScareState()
	{
		_IsScareState_PJZAKO__QBE_NXZ mFunc = (_IsScareState_PJZAKO__QBE_NXZ)(GameModule + 0x4d06d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetAiAtk(class PJZAKO* const this, int32_t arg2, int32_t arg3) [?mSetAiAtk@PJZAKO@@EAEXHH@Z]
	typedef void(__thiscall* _mSetAiAtk_PJZAKO__EAEXHH_Z)(class PJZAKO* const thisPtr, int32_t arg2, int32_t arg3);
	void mSetAiAtk(int32_t arg2, int32_t arg3)
	{
		_mSetAiAtk_PJZAKO__EAEXHH_Z mFunc = (_mSetAiAtk_PJZAKO__EAEXHH_Z)(GameModule + 0x4d06f0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t const __convention("thiscall") PJZAKO::GetMotionFrame(class PJZAKO* const this) [?GetMotionFrame@PJZAKO@@QBE?BHXZ]
	typedef int32_t const(__thiscall* _GetMotionFrame_PJZAKO__QBEBHXZ)(class PJZAKO* const thisPtr);
	int32_t GetMotionFrame()
	{
		_GetMotionFrame_PJZAKO__QBEBHXZ mFunc = (_GetMotionFrame_PJZAKO__QBEBHXZ)(GameModule + 0x4d07a0);
		return mFunc(this);
	}
	// [Function] int32_t const __convention("thiscall") PJZAKO::GetMotionTick(class PJZAKO* const this) [?GetMotionTick@PJZAKO@@QBE?BHXZ]
	typedef int32_t const(__thiscall* _GetMotionTick_PJZAKO__QBEBHXZ)(class PJZAKO* const thisPtr);
	int32_t GetMotionTick()
	{
		_GetMotionTick_PJZAKO__QBEBHXZ mFunc = (_GetMotionTick_PJZAKO__QBEBHXZ)(GameModule + 0x4d07c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetVisible(class PJZAKO* const this, uint8_t arg2) [?mSetVisible@PJZAKO@@UAEX_N@Z]
	typedef void(__thiscall* _mSetVisible_PJZAKO__UAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void mSetVisible(uint8_t arg2)
	{
		_mSetVisible_PJZAKO__UAEX_N_Z mFunc = (_mSetVisible_PJZAKO__UAEX_N_Z)(GameModule + 0x4d07d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::isHopeInterestMe(class PJZAKO* const this) [?isHopeInterestMe@PJZAKO@@EBE_NXZ]
	typedef uint8_t(__thiscall* _isHopeInterestMe_PJZAKO__EBE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t isHopeInterestMe()
	{
		_isHopeInterestMe_PJZAKO__EBE_NXZ mFunc = (_isHopeInterestMe_PJZAKO__EBE_NXZ)(GameModule + 0x4d0800);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetSubMotionSpd(class PJZAKO* const this, float arg2) [?mSetSubMotionSpd@PJZAKO@@UAEXM@Z]
	typedef void(__thiscall* _mSetSubMotionSpd_PJZAKO__UAEXM_Z)(class PJZAKO* const thisPtr, float arg2);
	void mSetSubMotionSpd(float arg2)
	{
		_mSetSubMotionSpd_PJZAKO__UAEXM_Z mFunc = (_mSetSubMotionSpd_PJZAKO__UAEXM_Z)(GameModule + 0x4d0840);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetWakeUpReactMotionNo(class PJZAKO* const this, int32_t arg2) [?GetWakeUpReactMotionNo@PJZAKO@@UAEHH@Z]
	typedef int32_t(__thiscall* _GetWakeUpReactMotionNo_PJZAKO__UAEHH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	int32_t GetWakeUpReactMotionNo(int32_t arg2)
	{
		_GetWakeUpReactMotionNo_PJZAKO__UAEHH_Z mFunc = (_GetWakeUpReactMotionNo_PJZAKO__UAEHH_Z)(GameModule + 0x4d0870);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameBeforeCancel(class PJZAKO* const this) [?IsFrameBeforeCancel@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameBeforeCancel_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameBeforeCancel()
	{
		_IsFrameBeforeCancel_PJZAKO__QAE_NXZ mFunc = (_IsFrameBeforeCancel_PJZAKO__QAE_NXZ)(GameModule + 0x4d08c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameBeforeEnd(class PJZAKO* const this) [?IsFrameBeforeEnd@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameBeforeEnd_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameBeforeEnd()
	{
		_IsFrameBeforeEnd_PJZAKO__QAE_NXZ mFunc = (_IsFrameBeforeEnd_PJZAKO__QAE_NXZ)(GameModule + 0x4d0910);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameBeforeHit(class PJZAKO* const this) [?IsFrameBeforeHit@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameBeforeHit_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameBeforeHit()
	{
		_IsFrameBeforeHit_PJZAKO__QAE_NXZ mFunc = (_IsFrameBeforeHit_PJZAKO__QAE_NXZ)(GameModule + 0x4d0960);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameBeforeTsuba(class PJZAKO* const this) [?IsFrameBeforeTsuba@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameBeforeTsuba_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameBeforeTsuba()
	{
		_IsFrameBeforeTsuba_PJZAKO__QAE_NXZ mFunc = (_IsFrameBeforeTsuba_PJZAKO__QAE_NXZ)(GameModule + 0x4d09b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameCancel(class PJZAKO* const this) [?IsFrameCancel@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameCancel_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameCancel()
	{
		_IsFrameCancel_PJZAKO__QAE_NXZ mFunc = (_IsFrameCancel_PJZAKO__QAE_NXZ)(GameModule + 0x4d0a00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameEnd(class PJZAKO* const this) [?IsFrameEnd@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameEnd_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameEnd()
	{
		_IsFrameEnd_PJZAKO__QAE_NXZ mFunc = (_IsFrameEnd_PJZAKO__QAE_NXZ)(GameModule + 0x4d0a50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameHit(class PJZAKO* const this) [?IsFrameHit@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameHit_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameHit()
	{
		_IsFrameHit_PJZAKO__QAE_NXZ mFunc = (_IsFrameHit_PJZAKO__QAE_NXZ)(GameModule + 0x4d0aa0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameTsuba(class PJZAKO* const this) [?IsFrameTsuba@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameTsuba_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameTsuba()
	{
		_IsFrameTsuba_PJZAKO__QAE_NXZ mFunc = (_IsFrameTsuba_PJZAKO__QAE_NXZ)(GameModule + 0x4d0af0);
		return mFunc(this);
	}
	// [Function] void PJZAKO::PlayNoPileOneShotSE(struct Vec& arg1, int32_t arg2) [?PlayNoPileOneShotSE@PJZAKO@@CAXABUVec@@H@Z]
	typedef void(__fastcall* _PlayNoPileOneShotSE_PJZAKO__CAXABUVec__H_Z)(struct Vec& arg1, int32_t arg2);
	static void PlayNoPileOneShotSE(struct Vec& arg1, int32_t arg2)
	{
		_PlayNoPileOneShotSE_PJZAKO__CAXABUVec__H_Z mFunc = (_PlayNoPileOneShotSE_PJZAKO__CAXABUVec__H_Z)(GameModule + 0x4d0b40);
		return mFunc(arg1, arg2);
	}
	// [Function] int32_t PJZAKO::ZakoNoPileSeCounterProcess() [?ZakoNoPileSeCounterProcess@PJZAKO@@CAXXZ]
	typedef int32_t(__fastcall* _ZakoNoPileSeCounterProcess_PJZAKO__CAXXZ)();
	static int32_t ZakoNoPileSeCounterProcess()
	{
		_ZakoNoPileSeCounterProcess_PJZAKO__CAXXZ mFunc = (_ZakoNoPileSeCounterProcess_PJZAKO__CAXXZ)(GameModule + 0x4d0b80);
		return mFunc();
	}
	// [Function] void __convention("thiscall") PJZAKO::TimeShareUpdateProc(class PJZAKO* const this) [?TimeShareUpdateProc@PJZAKO@@QAEXXZ]
	typedef void(__thiscall* _TimeShareUpdateProc_PJZAKO__QAEXXZ)(class PJZAKO* const thisPtr);
	void TimeShareUpdateProc()
	{
		_TimeShareUpdateProc_PJZAKO__QAEXXZ mFunc = (_TimeShareUpdateProc_PJZAKO__QAEXXZ)(GameModule + 0x4d0b90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::VoiceProc(class PJZAKO* const this) [?VoiceProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _VoiceProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void VoiceProc()
	{
		_VoiceProc_PJZAKO__AAEXXZ mFunc = (_VoiceProc_PJZAKO__AAEXXZ)(GameModule + 0x4d10d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mCallItemDrop(class PJZAKO* const this) [?mCallItemDrop@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _mCallItemDrop_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void mCallItemDrop()
	{
		_mCallItemDrop_PJZAKO__AAEXXZ mFunc = (_mCallItemDrop_PJZAKO__AAEXXZ)(GameModule + 0x4d1140);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsWatchPc(class PJZAKO* const this) [?IsWatchPc@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsWatchPc_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsWatchPc()
	{
		_IsWatchPc_PJZAKO__UAE_NXZ mFunc = (_IsWatchPc_PJZAKO__UAE_NXZ)(GameModule + 0x4d13c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetGuard(class PJZAKO* const this, int32_t arg2) [?SetGuard@PJZAKO@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _SetGuard_PJZAKO__QAE_NH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	uint8_t SetGuard(int32_t arg2)
	{
		_SetGuard_PJZAKO__QAE_NH_Z mFunc = (_SetGuard_PJZAKO__QAE_NH_Z)(GameModule + 0x4d13d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsThereWall(class PJZAKO* const this, enum eMoveDir arg2, float arg3, struct Vec* arg4) [?IsThereWall@PJZAKO@@QAE_NW4eMoveDir@@MPAUVec@@@Z]
	typedef uint8_t(__thiscall* _IsThereWall_PJZAKO__QAE_NW4eMoveDir__MPAUVec___Z)(class PJZAKO* const thisPtr, enum eMoveDir arg2, float arg3, struct Vec* arg4);
	uint8_t IsThereWall(/* enum eMoveDir */ uint32_t arg2, float arg3, struct Vec* arg4)
	{
		_IsThereWall_PJZAKO__QAE_NW4eMoveDir__MPAUVec___Z mFunc = (_IsThereWall_PJZAKO__QAE_NW4eMoveDir__MPAUVec___Z)(GameModule + 0x4d14c0);
		return mFunc(this, (enum eMoveDir)arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") PJZAKO::EnterDieVanish(class PJZAKO* const this) [?EnterDieVanish@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _EnterDieVanish_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void EnterDieVanish()
	{
		_EnterDieVanish_PJZAKO__AAEXXZ mFunc = (_EnterDieVanish_PJZAKO__AAEXXZ)(GameModule + 0x4d1660);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mLoseSightProc(class PJZAKO* const this) [?mLoseSightProc@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _mLoseSightProc_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mLoseSightProc()
	{
		_mLoseSightProc_PJZAKO__AAE_NXZ mFunc = (_mLoseSightProc_PJZAKO__AAE_NXZ)(GameModule + 0x4d1670);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mTermLoseSight(class PJZAKO* const this) [?mTermLoseSight@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _mTermLoseSight_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mTermLoseSight()
	{
		_mTermLoseSight_PJZAKO__AAE_NXZ mFunc = (_mTermLoseSight_PJZAKO__AAE_NXZ)(GameModule + 0x4d16c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCreateLoseSight(class PJZAKO* const this) [?mCreateLoseSight@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCreateLoseSight_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mCreateLoseSight()
	{
		_mCreateLoseSight_PJZAKO__UAE_NXZ mFunc = (_mCreateLoseSight_PJZAKO__UAE_NXZ)(GameModule + 0x4d1750);
		return mFunc(this);
	}
	// [Function] class TGan** __convention("thiscall") PJZAKO::mppGetGan(class PJZAKO* const this, int32_t arg2) [?mppGetGan@PJZAKO@@UAEPAPAVTGan@@H@Z]
	typedef class TGan**(__thiscall* _mppGetGan_PJZAKO__UAEPAPAVTGan__H_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
	void mppGetGan(int32_t arg2)
	{
		_mppGetGan_PJZAKO__UAEPAPAVTGan__H_Z mFunc = (_mppGetGan_PJZAKO__UAEPAPAVTGan__H_Z)(GameModule + 0x4d1850);
		mFunc(this, arg2);
	}
	// [Function] class TGan* __convention("thiscall") PJZAKO::mpGetGan(class PJZAKO* const this, int32_t arg2) [?mpGetGan@PJZAKO@@UBEPAVTGan@@H@Z]
	typedef class TGan*(__thiscall* _mpGetGan_PJZAKO__UBEPAVTGan__H_Z_2)(class PJZAKO* const thisPtr, int32_t arg2);
	class TGan* mpGetGan_2(int32_t arg2)
	{
		_mpGetGan_PJZAKO__UBEPAVTGan__H_Z_2 mFunc = (_mpGetGan_PJZAKO__UBEPAVTGan__H_Z_2)(GameModule + 0x4d18a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCheckBreakDead(class PJZAKO* const this, int32_t arg2) [?mCheckBreakDead@PJZAKO@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mCheckBreakDead_PJZAKO__QAE_NH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	uint8_t mCheckBreakDead(int32_t arg2)
	{
		_mCheckBreakDead_PJZAKO__QAE_NH_Z mFunc = (_mCheckBreakDead_PJZAKO__QAE_NH_Z)(GameModule + 0x4d18f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::GoToPointProc(class PJZAKO* const this, struct Vec* arg2) [?GoToPointProc@PJZAKO@@AAE_NPAUVec@@@Z]
	typedef uint8_t(__thiscall* _GoToPointProc_PJZAKO__AAE_NPAUVec___Z)(class PJZAKO* const thisPtr, struct Vec* arg2);
	uint8_t GoToPointProc(struct Vec* arg2)
	{
		_GoToPointProc_PJZAKO__AAE_NPAUVec___Z mFunc = (_GoToPointProc_PJZAKO__AAE_NPAUVec___Z)(GameModule + 0x4d1930);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::CheckWayPointMoveStopping(class PJZAKO* const this) [?CheckWayPointMoveStopping@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _CheckWayPointMoveStopping_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void CheckWayPointMoveStopping()
	{
		_CheckWayPointMoveStopping_PJZAKO__AAEXXZ mFunc = (_CheckWayPointMoveStopping_PJZAKO__AAEXXZ)(GameModule + 0x4d1ab0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::WayPointProc(class PJZAKO* const this) [?WayPointProc@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _WayPointProc_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t WayPointProc()
	{
		_WayPointProc_PJZAKO__AAE_NXZ mFunc = (_WayPointProc_PJZAKO__AAE_NXZ)(GameModule + 0x4d1af0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetWayPoint(class PJZAKO* const this, struct Vec* arg2, int32_t arg3) [?SetWayPoint@PJZAKO@@QAE_NPAUVec@@H@Z]
	typedef uint8_t(__thiscall* _SetWayPoint_PJZAKO__QAE_NPAUVec__H_Z)(class PJZAKO* const thisPtr, struct Vec* arg2, int32_t arg3);
	uint8_t SetWayPoint(struct Vec* arg2, int32_t arg3)
	{
		_SetWayPoint_PJZAKO__QAE_NPAUVec__H_Z mFunc = (_SetWayPoint_PJZAKO__QAE_NPAUVec__H_Z)(GameModule + 0x4d1ca0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] char const* __convention("thiscall") PJZAKO::getCurMotionName(class PJZAKO* const this) [?getCurMotionName@PJZAKO@@EBEPBDXZ]
	typedef char const*(__thiscall* _getCurMotionName_PJZAKO__EBEPBDXZ)(class PJZAKO* const thisPtr);
	std::string getCurMotionName()
	{
		_getCurMotionName_PJZAKO__EBEPBDXZ mFunc = (_getCurMotionName_PJZAKO__EBEPBDXZ)(GameModule + 0x4d1e20);
		char const* OutResult = mFunc(this);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mPlayMotion(class PJZAKO* const this, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6) [?mPlayMotion@PJZAKO@@UAE_NH_NH0M@Z]
	typedef uint8_t(__thiscall* _mPlayMotion_PJZAKO__UAE_NH_NH0M_Z)(class PJZAKO* const thisPtr, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6);
	uint8_t mPlayMotion(int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6)
	{
		_mPlayMotion_PJZAKO__UAE_NH_NH0M_Z mFunc = (_mPlayMotion_PJZAKO__UAE_NH_NH0M_Z)(GameModule + 0x4d1e70);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsMotionToMotionBlendState(class PJZAKO* const this) [?IsMotionToMotionBlendState@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsMotionToMotionBlendState_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsMotionToMotionBlendState()
	{
		_IsMotionToMotionBlendState_PJZAKO__QAE_NXZ mFunc = (_IsMotionToMotionBlendState_PJZAKO__QAE_NXZ)(GameModule + 0x4d1ef0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetPiyori(class PJZAKO* const this, uint8_t arg2) [?SetPiyori@PJZAKO@@AAE_N_N@Z]
	typedef uint8_t(__thiscall* _SetPiyori_PJZAKO__AAE_N_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	uint8_t SetPiyori(uint8_t arg2)
	{
		_SetPiyori_PJZAKO__AAE_N_N_Z mFunc = (_SetPiyori_PJZAKO__AAE_N_N_Z)(GameModule + 0x4d1f10);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetEvacuate(class PJZAKO* const this, enum eEvacuateDir arg2) [?SetEvacuate@PJZAKO@@UAE_NW4eEvacuateDir@@@Z]
	typedef uint8_t(__thiscall* _SetEvacuate_PJZAKO__UAE_NW4eEvacuateDir___Z)(class PJZAKO* const thisPtr, enum eEvacuateDir arg2);
	uint8_t SetEvacuate(/* enum eEvacuateDir */ uint32_t arg2)
	{
		_SetEvacuate_PJZAKO__UAE_NW4eEvacuateDir___Z mFunc = (_SetEvacuate_PJZAKO__UAE_NW4eEvacuateDir___Z)(GameModule + 0x4d2010);
		return mFunc(this, (enum eEvacuateDir)arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsAvailableEvacuateType(class PJZAKO* const this, enum eEvacuateDir arg2) [?IsAvailableEvacuateType@PJZAKO@@QAE_NW4eEvacuateDir@@@Z]
	typedef uint8_t(__thiscall* _IsAvailableEvacuateType_PJZAKO__QAE_NW4eEvacuateDir___Z)(class PJZAKO* const thisPtr, enum eEvacuateDir arg2);
	uint8_t IsAvailableEvacuateType(/* enum eEvacuateDir */ uint32_t arg2)
	{
		_IsAvailableEvacuateType_PJZAKO__QAE_NW4eEvacuateDir___Z mFunc = (_IsAvailableEvacuateType_PJZAKO__QAE_NW4eEvacuateDir___Z)(GameModule + 0x4d2120);
		return mFunc(this, (enum eEvacuateDir)arg2);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetBoneCmnMotIdx(class PJZAKO* const this, int32_t arg2) [?GetBoneCmnMotIdx@PJZAKO@@MBEHH@Z]
	typedef int32_t(__thiscall* _GetBoneCmnMotIdx_PJZAKO__MBEHH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	int32_t GetBoneCmnMotIdx(int32_t arg2)
	{
		_GetBoneCmnMotIdx_PJZAKO__MBEHH_Z mFunc = (_GetBoneCmnMotIdx_PJZAKO__MBEHH_Z)(GameModule + 0x4d2170);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetStatStepInAttack(class PJZAKO* const this) [?SetStatStepInAttack@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _SetStatStepInAttack_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetStatStepInAttack()
	{
		_SetStatStepInAttack_PJZAKO__QAE_NXZ mFunc = (_SetStatStepInAttack_PJZAKO__QAE_NXZ)(GameModule + 0x4d21b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetStat_CharSpAtk(class PJZAKO* const this) [?SetStat_CharSpAtk@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _SetStat_CharSpAtk_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetStat_CharSpAtk()
	{
		_SetStat_CharSpAtk_PJZAKO__EAE_NXZ mFunc = (_SetStat_CharSpAtk_PJZAKO__EAE_NXZ)(GameModule + 0x4d2230);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetFuzzyOptionalAttackStat(class PJZAKO* const this, enum eAtkType arg2) [?SetFuzzyOptionalAttackStat@PJZAKO@@EAE_NW4eAtkType@@@Z]
	typedef uint8_t(__thiscall* _SetFuzzyOptionalAttackStat_PJZAKO__EAE_NW4eAtkType___Z)(class PJZAKO* const thisPtr, enum eAtkType arg2);
	uint8_t SetFuzzyOptionalAttackStat(/* enum eAtkType */ uint32_t arg2)
	{
		_SetFuzzyOptionalAttackStat_PJZAKO__EAE_NW4eAtkType___Z mFunc = (_SetFuzzyOptionalAttackStat_PJZAKO__EAE_NW4eAtkType___Z)(GameModule + 0x4d2240);
		return mFunc(this, (enum eAtkType)arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetTobiDoguAttackStat(class PJZAKO* const this) [?SetTobiDoguAttackStat@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _SetTobiDoguAttackStat_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetTobiDoguAttackStat()
	{
		_SetTobiDoguAttackStat_PJZAKO__EAE_NXZ mFunc = (_SetTobiDoguAttackStat_PJZAKO__EAE_NXZ)(GameModule + 0x4d2390);
		return mFunc(this);
	}
	// [Function] struct Vec __convention("thiscall") PJZAKO::GetIkakuShagekiTgtPos(class PJZAKO* const this) [?GetIkakuShagekiTgtPos@PJZAKO@@IAE?AUVec@@XZ]
	typedef struct Vec(__thiscall* _GetIkakuShagekiTgtPos_PJZAKO__IAEAUVec__XZ)(class PJZAKO* const thisPtr);
	struct Vec GetIkakuShagekiTgtPos()
	{
		_GetIkakuShagekiTgtPos_PJZAKO__IAEAUVec__XZ mFunc = (_GetIkakuShagekiTgtPos_PJZAKO__IAEAUVec__XZ)(GameModule + 0x4d23a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::CheckGunMuzzleInWall(class PJZAKO* const this, struct Vec& arg2) [?CheckGunMuzzleInWall@PJZAKO@@IAE_NABUVec@@@Z]
	typedef uint8_t(__thiscall* _CheckGunMuzzleInWall_PJZAKO__IAE_NABUVec___Z)(class PJZAKO* const thisPtr, struct Vec& arg2);
	uint8_t CheckGunMuzzleInWall(struct Vec& arg2)
	{
		_CheckGunMuzzleInWall_PJZAKO__IAE_NABUVec___Z mFunc = (_CheckGunMuzzleInWall_PJZAKO__IAE_NABUVec___Z)(GameModule + 0x4d2540);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsIkakuShageki(class PJZAKO* const this) [?IsIkakuShageki@PJZAKO@@IAE_NXZ]
	typedef uint8_t(__thiscall* _IsIkakuShageki_PJZAKO__IAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsIkakuShageki()
	{
		_IsIkakuShageki_PJZAKO__IAE_NXZ mFunc = (_IsIkakuShageki_PJZAKO__IAE_NXZ)(GameModule + 0x4d2590);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsForbiddenAttackCondition(class PJZAKO* const this) [?IsForbiddenAttackCondition@PJZAKO@@IAE_NXZ]
	typedef uint8_t(__thiscall* _IsForbiddenAttackCondition_PJZAKO__IAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsForbiddenAttackCondition()
	{
		_IsForbiddenAttackCondition_PJZAKO__IAE_NXZ mFunc = (_IsForbiddenAttackCondition_PJZAKO__IAE_NXZ)(GameModule + 0x4d2630);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetStat_PathFindToPC(class PJZAKO* const this) [?SetStat_PathFindToPC@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _SetStat_PathFindToPC_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetStat_PathFindToPC()
	{
		_SetStat_PathFindToPC_PJZAKO__AAE_NXZ mFunc = (_SetStat_PathFindToPC_PJZAKO__AAE_NXZ)(GameModule + 0x4d2660);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetStat_Close(class PJZAKO* const this) [?SetStat_Close@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _SetStat_Close_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetStat_Close()
	{
		_SetStat_Close_PJZAKO__AAE_NXZ mFunc = (_SetStat_Close_PJZAKO__AAE_NXZ)(GameModule + 0x4d26f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetStat_Pressure(class PJZAKO* const this) [?SetStat_Pressure@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _SetStat_Pressure_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetStat_Pressure()
	{
		_SetStat_Pressure_PJZAKO__AAE_NXZ mFunc = (_SetStat_Pressure_PJZAKO__AAE_NXZ)(GameModule + 0x4d2770);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetExtendBackStepDist(class PJZAKO* const this, float arg2) [?SetExtendBackStepDist@PJZAKO@@IAEXM@Z]
	typedef void(__thiscall* _SetExtendBackStepDist_PJZAKO__IAEXM_Z)(class PJZAKO* const thisPtr, float arg2);
	void SetExtendBackStepDist(float arg2)
	{
		_SetExtendBackStepDist_PJZAKO__IAEXM_Z mFunc = (_SetExtendBackStepDist_PJZAKO__IAEXM_Z)(GameModule + 0x4d27e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetStat_GetBehind(class PJZAKO* const this) [?SetStat_GetBehind@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _SetStat_GetBehind_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetStat_GetBehind()
	{
		_SetStat_GetBehind_PJZAKO__AAE_NXZ mFunc = (_SetStat_GetBehind_PJZAKO__AAE_NXZ)(GameModule + 0x4d28a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mAttackHitPlaySE3D(class PJZAKO* const this, enum PJZAKO::ZakoSeType arg2) [?mAttackHitPlaySE3D@PJZAKO@@EAEXW4ZakoSeType@1@@Z]
	typedef void(__thiscall* _mAttackHitPlaySE3D_PJZAKO__EAEXW4ZakoSeType_1__Z)(class PJZAKO* const thisPtr, enum PJZAKO::ZakoSeType arg2);
	void mAttackHitPlaySE3D(/* enum PJZAKO::ZakoSeType */ uint32_t arg2)
	{
		_mAttackHitPlaySE3D_PJZAKO__EAEXW4ZakoSeType_1__Z mFunc = (_mAttackHitPlaySE3D_PJZAKO__EAEXW4ZakoSeType_1__Z)(GameModule + 0x4d2960);
		return mFunc(this, (enum PJZAKO::ZakoSeType)arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::PlayGuardSE3D(class PJZAKO* const this) [?PlayGuardSE3D@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _PlayGuardSE3D_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void PlayGuardSE3D()
	{
		_PlayGuardSE3D_PJZAKO__AAEXXZ mFunc = (_PlayGuardSE3D_PJZAKO__AAEXXZ)(GameModule + 0x4d2a30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mAttackHitRestore(class PJZAKO* const this, enum PJZAKO::ZakoSeType arg2) [?mAttackHitRestore@PJZAKO@@IAEXW4ZakoSeType@1@@Z]
	typedef void(__thiscall* _mAttackHitRestore_PJZAKO__IAEXW4ZakoSeType_1__Z)(class PJZAKO* const thisPtr, enum PJZAKO::ZakoSeType arg2);
	void mAttackHitRestore(/* enum PJZAKO::ZakoSeType */ uint32_t arg2)
	{
		_mAttackHitRestore_PJZAKO__IAEXW4ZakoSeType_1__Z mFunc = (_mAttackHitRestore_PJZAKO__IAEXW4ZakoSeType_1__Z)(GameModule + 0x4d2ad0);
		return mFunc(this, (enum PJZAKO::ZakoSeType)arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetRotY(class PJZAKO* const this, float arg2, uint8_t arg3) [?SetRotY@PJZAKO@@IAEXM_N@Z]
	typedef void(__thiscall* _SetRotY_PJZAKO__IAEXM_N_Z)(class PJZAKO* const thisPtr, float arg2, uint8_t arg3);
	void SetRotY(float arg2, uint8_t arg3)
	{
		_SetRotY_PJZAKO__IAEXM_N_Z mFunc = (_SetRotY_PJZAKO__IAEXM_N_Z)(GameModule + 0x4d2ae0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] float __convention("thiscall") PJZAKO::mGetAttackParam(class PJZAKO* const this, int32_t arg2, int32_t arg3) [?mGetAttackParam@PJZAKO@@IAEMHH@Z]
	typedef float(__thiscall* _mGetAttackParam_PJZAKO__IAEMHH_Z)(class PJZAKO* const thisPtr, int32_t arg2, int32_t arg3);
	float mGetAttackParam(int32_t arg2, int32_t arg3)
	{
		_mGetAttackParam_PJZAKO__IAEMHH_Z mFunc = (_mGetAttackParam_PJZAKO__IAEMHH_Z)(GameModule + 0x4d2b10);
		return mFunc(this, arg2, arg3);
	}
	// [Function] float __convention("thiscall") PJZAKO::mGetAttackParamEx(class PJZAKO* const this, int32_t arg2, int32_t arg3) [?mGetAttackParamEx@PJZAKO@@MAEMHH@Z]
	typedef float(__thiscall* _mGetAttackParamEx_PJZAKO__MAEMHH_Z)(class PJZAKO* const thisPtr, int32_t arg2, int32_t arg3);
	float mGetAttackParamEx(int32_t arg2, int32_t arg3)
	{
		_mGetAttackParamEx_PJZAKO__MAEMHH_Z mFunc = (_mGetAttackParamEx_PJZAKO__MAEMHH_Z)(GameModule + 0x4d2b70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::mDieCallback(class PJZAKO* const this, int32_t arg2) [?mDieCallback@PJZAKO@@AAEXH@Z]
	typedef void(__thiscall* _mDieCallback_PJZAKO__AAEXH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	void mDieCallback(int32_t arg2)
	{
		_mDieCallback_PJZAKO__AAEXH_Z mFunc = (_mDieCallback_PJZAKO__AAEXH_Z)(GameModule + 0x4d2b90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsTigerBitedDyingMotion(class PJZAKO* const this) [?IsTigerBitedDyingMotion@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsTigerBitedDyingMotion_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsTigerBitedDyingMotion()
	{
		_IsTigerBitedDyingMotion_PJZAKO__AAE_NXZ mFunc = (_IsTigerBitedDyingMotion_PJZAKO__AAE_NXZ)(GameModule + 0x4d2ba0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsBombDeadNode(class PJZAKO* const this, class TGmfNode* arg2) [?IsBombDeadNode@PJZAKO@@AAE_NPAVTGmfNode@@@Z]
	typedef uint8_t(__thiscall* _IsBombDeadNode_PJZAKO__AAE_NPAVTGmfNode___Z)(class PJZAKO* const thisPtr, class TGmfNode* arg2);
	uint8_t IsBombDeadNode(class TGmfNode* arg2)
	{
		_IsBombDeadNode_PJZAKO__AAE_NPAVTGmfNode___Z mFunc = (_IsBombDeadNode_PJZAKO__AAE_NPAVTGmfNode___Z)(GameModule + 0x4d2bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SearchNoBombDeadNodeAndSetInVisible_Reflex(class PJZAKO* const this, class TGmfNode* arg2) [?SearchNoBombDeadNodeAndSetInVisible_Reflex@PJZAKO@@AAEXPAVTGmfNode@@@Z]
	typedef void(__thiscall* _SearchNoBombDeadNodeAndSetInVisible_Reflex_PJZAKO__AAEXPAVTGmfNode___Z)(class PJZAKO* const thisPtr, class TGmfNode* arg2);
	void SearchNoBombDeadNodeAndSetInVisible_Reflex(class TGmfNode* arg2)
	{
		_SearchNoBombDeadNodeAndSetInVisible_Reflex_PJZAKO__AAEXPAVTGmfNode___Z mFunc = (_SearchNoBombDeadNodeAndSetInVisible_Reflex_PJZAKO__AAEXPAVTGmfNode___Z)(GameModule + 0x4d2c80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SearchNoBombDeadNodeAndSetInVisible(class PJZAKO* const this, class TGmf* arg2) [?SearchNoBombDeadNodeAndSetInVisible@PJZAKO@@AAEXPAVTGmf@@@Z]
	typedef void(__thiscall* _SearchNoBombDeadNodeAndSetInVisible_PJZAKO__AAEXPAVTGmf___Z)(class PJZAKO* const thisPtr, class TGmf* arg2);
	void SearchNoBombDeadNodeAndSetInVisible(class TGmf* arg2)
	{
		_SearchNoBombDeadNodeAndSetInVisible_PJZAKO__AAEXPAVTGmf___Z mFunc = (_SearchNoBombDeadNodeAndSetInVisible_PJZAKO__AAEXPAVTGmf___Z)(GameModule + 0x4d2d60);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mRequestSmokeDead(class PJZAKO* const this, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6) [?mRequestSmokeDead@PJZAKO@@AAE_NHHHHH@Z]
	typedef uint8_t(__thiscall* _mRequestSmokeDead_PJZAKO__AAE_NHHHHH_Z)(class PJZAKO* const thisPtr, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6);
	uint8_t mRequestSmokeDead(int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
	{
		_mRequestSmokeDead_PJZAKO__AAE_NHHHHH_Z mFunc = (_mRequestSmokeDead_PJZAKO__AAE_NHHHHH_Z)(GameModule + 0x4d2d80);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mZakoDieOut(class PJZAKO* const this) [?mZakoDieOut@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _mZakoDieOut_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mZakoDieOut()
	{
		_mZakoDieOut_PJZAKO__EAE_NXZ mFunc = (_mZakoDieOut_PJZAKO__EAE_NXZ)(GameModule + 0x4d3440);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::mGetBodyTouchFloorTick(class PJZAKO* const this, int32_t arg2) [?mGetBodyTouchFloorTick@PJZAKO@@EAEHH@Z]
	typedef int32_t(__thiscall* _mGetBodyTouchFloorTick_PJZAKO__EAEHH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	int32_t mGetBodyTouchFloorTick(int32_t arg2)
	{
		_mGetBodyTouchFloorTick_PJZAKO__EAEHH_Z mFunc = (_mGetBodyTouchFloorTick_PJZAKO__EAEHH_Z)(GameModule + 0x4d34c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::EffectProc(class PJZAKO* const this) [?EffectProc@PJZAKO@@MAEXXZ]
	typedef void(__thiscall* _EffectProc_PJZAKO__MAEXXZ)(class PJZAKO* const thisPtr);
	void EffectProc()
	{
		_EffectProc_PJZAKO__MAEXXZ mFunc = (_EffectProc_PJZAKO__MAEXXZ)(GameModule + 0x4d3560);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsContinueComboAttack(class PJZAKO* const this) [?IsContinueComboAttack@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _IsContinueComboAttack_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsContinueComboAttack()
	{
		_IsContinueComboAttack_PJZAKO__EAE_NXZ mFunc = (_IsContinueComboAttack_PJZAKO__EAE_NXZ)(GameModule + 0x4d3910);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsContinueEvacuate(class PJZAKO* const this) [?IsContinueEvacuate@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsContinueEvacuate_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsContinueEvacuate()
	{
		_IsContinueEvacuate_PJZAKO__QAE_NXZ mFunc = (_IsContinueEvacuate_PJZAKO__QAE_NXZ)(GameModule + 0x4d3960);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsEvacuateMotionFrame(class PJZAKO* const this, enum e_ZkMotTimingType arg2) [?IsEvacuateMotionFrame@PJZAKO@@MAE_NW4e_ZkMotTimingType@@@Z]
	typedef uint8_t(__thiscall* _IsEvacuateMotionFrame_PJZAKO__MAE_NW4e_ZkMotTimingType___Z)(class PJZAKO* const thisPtr, enum e_ZkMotTimingType arg2);
	uint8_t IsEvacuateMotionFrame(/* enum e_ZkMotTimingType */ uint32_t arg2)
	{
		_IsEvacuateMotionFrame_PJZAKO__MAE_NW4e_ZkMotTimingType___Z mFunc = (_IsEvacuateMotionFrame_PJZAKO__MAE_NW4e_ZkMotTimingType___Z)(GameModule + 0x4d39a0);
		return mFunc(this, (enum e_ZkMotTimingType)arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsInvinsibleTimingPopIdleState(class PJZAKO* const this) [?IsInvinsibleTimingPopIdleState@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsInvinsibleTimingPopIdleState_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsInvinsibleTimingPopIdleState()
	{
		_IsInvinsibleTimingPopIdleState_PJZAKO__QAE_NXZ mFunc = (_IsInvinsibleTimingPopIdleState_PJZAKO__QAE_NXZ)(GameModule + 0x4d39b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsPcSlashTame(class PJZAKO* const this) [?IsPcSlashTame@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcSlashTame_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsPcSlashTame()
	{
		_IsPcSlashTame_PJZAKO__AAE_NXZ mFunc = (_IsPcSlashTame_PJZAKO__AAE_NXZ)(GameModule + 0x4d3a10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsPcEmmergencyEvacuation(class PJZAKO* const this) [?IsPcEmmergencyEvacuation@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcEmmergencyEvacuation_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsPcEmmergencyEvacuation()
	{
		_IsPcEmmergencyEvacuation_PJZAKO__AAE_NXZ mFunc = (_IsPcEmmergencyEvacuation_PJZAKO__AAE_NXZ)(GameModule + 0x4d3b90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsPcBoldAttackFollowThrough(class PJZAKO* const this) [?IsPcBoldAttackFollowThrough@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcBoldAttackFollowThrough_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsPcBoldAttackFollowThrough()
	{
		_IsPcBoldAttackFollowThrough_PJZAKO__AAE_NXZ mFunc = (_IsPcBoldAttackFollowThrough_PJZAKO__AAE_NXZ)(GameModule + 0x4d3c00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsKettou(class PJZAKO* const this) [?IsKettou@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsKettou_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsKettou()
	{
		_IsKettou_PJZAKO__QAE_NXZ mFunc = (_IsKettou_PJZAKO__QAE_NXZ)(GameModule + 0x4d3c20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsWatchMe(class PJZAKO* const this) [?IsWatchMe@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsWatchMe_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsWatchMe()
	{
		_IsWatchMe_PJZAKO__QAE_NXZ mFunc = (_IsWatchMe_PJZAKO__QAE_NXZ)(GameModule + 0x4d3c70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsLockOnMe(class PJZAKO* const this) [?IsLockOnMe@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsLockOnMe_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsLockOnMe()
	{
		_IsLockOnMe_PJZAKO__QAE_NXZ mFunc = (_IsLockOnMe_PJZAKO__QAE_NXZ)(GameModule + 0x4d3ca0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetKesson(class PJZAKO* const this) [?SetKesson@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _SetKesson_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetKesson()
	{
		_SetKesson_PJZAKO__AAE_NXZ mFunc = (_SetKesson_PJZAKO__AAE_NXZ)(GameModule + 0x4d3cc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::TestKesson(class PJZAKO* const this, int32_t arg2) [?TestKesson@PJZAKO@@AAEXH@Z]
	typedef void(__thiscall* _TestKesson_PJZAKO__AAEXH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	void TestKesson(int32_t arg2)
	{
		_TestKesson_PJZAKO__AAEXH_Z mFunc = (_TestKesson_PJZAKO__AAEXH_Z)(GameModule + 0x4d45f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsParticleDead(class PJZAKO* const this) [?IsParticleDead@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsParticleDead_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsParticleDead()
	{
		_IsParticleDead_PJZAKO__AAE_NXZ mFunc = (_IsParticleDead_PJZAKO__AAE_NXZ)(GameModule + 0x4d4660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetDamageReactionBeforeFinishAttack(class PJZAKO* const this) [?SetDamageReactionBeforeFinishAttack@PJZAKO@@UAEXXZ]
	typedef void(__thiscall* _SetDamageReactionBeforeFinishAttack_PJZAKO__UAEXXZ)(class PJZAKO* const thisPtr);
	void SetDamageReactionBeforeFinishAttack()
	{
		_SetDamageReactionBeforeFinishAttack_PJZAKO__UAEXXZ mFunc = (_SetDamageReactionBeforeFinishAttack_PJZAKO__UAEXXZ)(GameModule + 0x4d4670);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCheckCanThrow(class PJZAKO* const this) [?mCheckCanThrow@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanThrow_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mCheckCanThrow()
	{
		_mCheckCanThrow_PJZAKO__UAE_NXZ mFunc = (_mCheckCanThrow_PJZAKO__UAE_NXZ)(GameModule + 0x4d46e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCheckCanCatch(class PJZAKO* const this) [?mCheckCanCatch@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckCanCatch_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mCheckCanCatch()
	{
		_mCheckCanCatch_PJZAKO__UAE_NXZ mFunc = (_mCheckCanCatch_PJZAKO__UAE_NXZ)(GameModule + 0x4d4730);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mGetTsubazeriaiPos(class PJZAKO* const this, struct Vec* arg2) [?mGetTsubazeriaiPos@PJZAKO@@UAEXPAUVec@@@Z]
	typedef void(__thiscall* _mGetTsubazeriaiPos_PJZAKO__UAEXPAUVec___Z)(class PJZAKO* const thisPtr, struct Vec* arg2);
	void mGetTsubazeriaiPos(struct Vec* arg2)
	{
		_mGetTsubazeriaiPos_PJZAKO__UAEXPAUVec___Z mFunc = (_mGetTsubazeriaiPos_PJZAKO__UAEXPAUVec___Z)(GameModule + 0x4d4740);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::mLoseTsubazeriai(class PJZAKO* const this) [?mLoseTsubazeriai@PJZAKO@@UAEXXZ]
	typedef void(__thiscall* _mLoseTsubazeriai_PJZAKO__UAEXXZ)(class PJZAKO* const thisPtr);
	void mLoseTsubazeriai()
	{
		_mLoseTsubazeriai_PJZAKO__UAEXXZ mFunc = (_mLoseTsubazeriai_PJZAKO__UAEXXZ)(GameModule + 0x4d47c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mWinTsubazeriai(class PJZAKO* const this) [?mWinTsubazeriai@PJZAKO@@UAEXXZ]
	typedef void(__thiscall* _mWinTsubazeriai_PJZAKO__UAEXXZ)(class PJZAKO* const thisPtr);
	void mWinTsubazeriai()
	{
		_mWinTsubazeriai_PJZAKO__UAEXXZ mFunc = (_mWinTsubazeriai_PJZAKO__UAEXXZ)(GameModule + 0x4d4840);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mPlayMotTsubaszeriai(class PJZAKO* const this) [?mPlayMotTsubaszeriai@PJZAKO@@UAEXXZ]
	typedef void(__thiscall* _mPlayMotTsubaszeriai_PJZAKO__UAEXXZ)(class PJZAKO* const thisPtr);
	void mPlayMotTsubaszeriai()
	{
		_mPlayMotTsubaszeriai_PJZAKO__UAEXXZ mFunc = (_mPlayMotTsubaszeriai_PJZAKO__UAEXXZ)(GameModule + 0x4d4870);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCheckTsubazeriai(class PJZAKO* const this) [?mCheckTsubazeriai@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckTsubazeriai_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mCheckTsubazeriai()
	{
		_mCheckTsubazeriai_PJZAKO__UAE_NXZ mFunc = (_mCheckTsubazeriai_PJZAKO__UAE_NXZ)(GameModule + 0x4d4a60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCheckIntoTsubazeriai(class PJZAKO* const this) [?mCheckIntoTsubazeriai@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckIntoTsubazeriai_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mCheckIntoTsubazeriai()
	{
		_mCheckIntoTsubazeriai_PJZAKO__UAE_NXZ mFunc = (_mCheckIntoTsubazeriai_PJZAKO__UAE_NXZ)(GameModule + 0x4d4ab0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::CreateAtkPcEffect(class PJZAKO* const this) [?CreateAtkPcEffect@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _CreateAtkPcEffect_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void CreateAtkPcEffect()
	{
		_CreateAtkPcEffect_PJZAKO__AAEXXZ mFunc = (_CreateAtkPcEffect_PJZAKO__AAEXXZ)(GameModule + 0x4d4b60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mAttackProc(class PJZAKO* const this) [?mAttackProc@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _mAttackProc_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mAttackProc()
	{
		_mAttackProc_PJZAKO__EAE_NXZ mFunc = (_mAttackProc_PJZAKO__EAE_NXZ)(GameModule + 0x4d4d00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsAtkObj(class PJZAKO* const this, class mHRChara* arg2) [?IsAtkObj@PJZAKO@@EAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _IsAtkObj_PJZAKO__EAE_NPAVmHRChara___Z)(class PJZAKO* const thisPtr, class mHRChara* arg2);
	uint8_t IsAtkObj(class mHRChara* arg2)
	{
		_IsAtkObj_PJZAKO__EAE_NPAVmHRChara___Z mFunc = (_IsAtkObj_PJZAKO__EAE_NPAVmHRChara___Z)(GameModule + 0x4d51b0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::mGetAtkNo(class PJZAKO* const this, int32_t arg2) [?mGetAtkNo@PJZAKO@@EBEHH@Z]
	typedef int32_t(__thiscall* _mGetAtkNo_PJZAKO__EBEHH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	int32_t mGetAtkNo(int32_t arg2)
	{
		_mGetAtkNo_PJZAKO__EBEHH_Z mFunc = (_mGetAtkNo_PJZAKO__EBEHH_Z)(GameModule + 0x4d51e0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::mGetAtkNo(class PJZAKO* const this, int32_t arg2) [?mGetAtkNo@PJZAKO@@EAEHH@Z]
	typedef int32_t(__thiscall* _mGetAtkNo_PJZAKO__EAEHH_Z_2)(class PJZAKO* const thisPtr, int32_t arg2);
	int32_t mGetAtkNo_2(int32_t arg2)
	{
		_mGetAtkNo_PJZAKO__EAEHH_Z_2 mFunc = (_mGetAtkNo_PJZAKO__EAEHH_Z_2)(GameModule + 0x4d5200);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCheckCanHit(class PJZAKO* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mCheckCanHit@PJZAKO@@UAE_NH_N0@Z]
	typedef uint8_t(__thiscall* _mCheckCanHit_PJZAKO__UAE_NH_N0_Z)(class PJZAKO* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
	uint8_t mCheckCanHit(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		_mCheckCanHit_PJZAKO__UAE_NH_N0_Z mFunc = (_mCheckCanHit_PJZAKO__UAE_NH_N0_Z)(GameModule + 0x4d5210);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsGuardMot(class PJZAKO* const this, int32_t arg2) [?IsGuardMot@PJZAKO@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _IsGuardMot_PJZAKO__QAE_NH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	uint8_t IsGuardMot(int32_t arg2)
	{
		_IsGuardMot_PJZAKO__QAE_NH_Z mFunc = (_IsGuardMot_PJZAKO__QAE_NH_Z)(GameModule + 0x4d5470);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mCheckAttack(class PJZAKO* const this) [?mCheckAttack@PJZAKO@@UBE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAttack_PJZAKO__UBE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mCheckAttack()
	{
		_mCheckAttack_PJZAKO__UBE_NXZ mFunc = (_mCheckAttack_PJZAKO__UBE_NXZ)(GameModule + 0x4d54f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_FightAttack(class PJZAKO* const this, int32_t const arg2, int32_t arg3) [?mSetDamage_FightAttack@PJZAKO@@AAEXHH@Z]
	typedef void(__thiscall* _mSetDamage_FightAttack_PJZAKO__AAEXHH_Z)(class PJZAKO* const thisPtr, int32_t const arg2, int32_t arg3);
	void mSetDamage_FightAttack(int32_t const arg2, int32_t arg3)
	{
		_mSetDamage_FightAttack_PJZAKO__AAEXHH_Z mFunc = (_mSetDamage_FightAttack_PJZAKO__AAEXHH_Z)(GameModule + 0x4d5510);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_Stomping(class PJZAKO* const this) [?mSetDamage_Stomping@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _mSetDamage_Stomping_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void mSetDamage_Stomping()
	{
		_mSetDamage_Stomping_PJZAKO__AAEXXZ mFunc = (_mSetDamage_Stomping_PJZAKO__AAEXXZ)(GameModule + 0x4d5740);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_GuardHajikare(class PJZAKO* const this) [?mSetDamage_GuardHajikare@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _mSetDamage_GuardHajikare_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void mSetDamage_GuardHajikare()
	{
		_mSetDamage_GuardHajikare_PJZAKO__AAEXXZ mFunc = (_mSetDamage_GuardHajikare_PJZAKO__AAEXXZ)(GameModule + 0x4d5900);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_WakeUp(class PJZAKO* const this, int32_t arg2) [?mSetDamage_WakeUp@PJZAKO@@AAEXH@Z]
	typedef void(__thiscall* _mSetDamage_WakeUp_PJZAKO__AAEXH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	void mSetDamage_WakeUp(int32_t arg2)
	{
		_mSetDamage_WakeUp_PJZAKO__AAEXH_Z mFunc = (_mSetDamage_WakeUp_PJZAKO__AAEXH_Z)(GameModule + 0x4d59d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_Through(class PJZAKO* const this, int32_t arg2) [?mSetDamage_Through@PJZAKO@@AAEXH@Z]
	typedef void(__thiscall* _mSetDamage_Through_PJZAKO__AAEXH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	void mSetDamage_Through(int32_t arg2)
	{
		_mSetDamage_Through_PJZAKO__AAEXH_Z mFunc = (_mSetDamage_Through_PJZAKO__AAEXH_Z)(GameModule + 0x4d5ab0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsSetDamageFromPcWakeUp(class PJZAKO* const this) [?IsSetDamageFromPcWakeUp@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsSetDamageFromPcWakeUp_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsSetDamageFromPcWakeUp()
	{
		_IsSetDamageFromPcWakeUp_PJZAKO__AAE_NXZ mFunc = (_IsSetDamageFromPcWakeUp_PJZAKO__AAE_NXZ)(GameModule + 0x4d5b30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsSetDamageFromPcThroughAttack(class PJZAKO* const this, class mHRChara* arg2) [?IsSetDamageFromPcThroughAttack@PJZAKO@@AAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _IsSetDamageFromPcThroughAttack_PJZAKO__AAE_NPAVmHRChara___Z)(class PJZAKO* const thisPtr, class mHRChara* arg2);
	uint8_t IsSetDamageFromPcThroughAttack(class mHRChara* arg2)
	{
		_IsSetDamageFromPcThroughAttack_PJZAKO__AAE_NPAVmHRChara___Z mFunc = (_IsSetDamageFromPcThroughAttack_PJZAKO__AAE_NPAVmHRChara___Z)(GameModule + 0x4d5b50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_Guard(class PJZAKO* const this, int32_t arg2) [?mSetDamage_Guard@PJZAKO@@AAEXH@Z]
	typedef void(__thiscall* _mSetDamage_Guard_PJZAKO__AAEXH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	void mSetDamage_Guard(int32_t arg2)
	{
		_mSetDamage_Guard_PJZAKO__AAEXH_Z mFunc = (_mSetDamage_Guard_PJZAKO__AAEXH_Z)(GameModule + 0x4d5b90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::AttractFriendMyDead(class PJZAKO* const this) [?AttractFriendMyDead@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _AttractFriendMyDead_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void AttractFriendMyDead()
	{
		_AttractFriendMyDead_PJZAKO__AAEXXZ mFunc = (_AttractFriendMyDead_PJZAKO__AAEXXZ)(GameModule + 0x4d5cd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::CheckPiyoDurationAndSetStatPiyoriDamage(class PJZAKO* const this) [?CheckPiyoDurationAndSetStatPiyoriDamage@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _CheckPiyoDurationAndSetStatPiyoriDamage_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t CheckPiyoDurationAndSetStatPiyoriDamage()
	{
		_CheckPiyoDurationAndSetStatPiyoriDamage_PJZAKO__AAE_NXZ mFunc = (_CheckPiyoDurationAndSetStatPiyoriDamage_PJZAKO__AAE_NXZ)(GameModule + 0x4d5de0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetExceptionDeadDamage(class PJZAKO* const this) [?SetExceptionDeadDamage@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _SetExceptionDeadDamage_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void SetExceptionDeadDamage()
	{
		_SetExceptionDeadDamage_PJZAKO__AAEXXZ mFunc = (_SetExceptionDeadDamage_PJZAKO__AAEXXZ)(GameModule + 0x4d5eb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_Dead(class PJZAKO* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4) [?mSetDamage_Dead@PJZAKO@@AAEXHHPBVmHRChara@@@Z]
	typedef void(__thiscall* _mSetDamage_Dead_PJZAKO__AAEXHHPBVmHRChara___Z)(class PJZAKO* const thisPtr, int32_t const arg2, int32_t const arg3, class mHRChara* arg4);
	void mSetDamage_Dead(int32_t const arg2, int32_t const arg3, class mHRChara* arg4)
	{
		_mSetDamage_Dead_PJZAKO__AAEXHHPBVmHRChara___Z mFunc = (_mSetDamage_Dead_PJZAKO__AAEXHHPBVmHRChara___Z)(GameModule + 0x4d5fd0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_CutDamage(class PJZAKO* const this, class mHRChara* arg2, int32_t arg3) [?mSetDamage_CutDamage@PJZAKO@@AAEXPAVmHRChara@@H@Z]
	typedef void(__thiscall* _mSetDamage_CutDamage_PJZAKO__AAEXPAVmHRChara__H_Z)(class PJZAKO* const thisPtr, class mHRChara* arg2, int32_t arg3);
	void mSetDamage_CutDamage(class mHRChara* arg2, int32_t arg3)
	{
		_mSetDamage_CutDamage_PJZAKO__AAEXPAVmHRChara__H_Z mFunc = (_mSetDamage_CutDamage_PJZAKO__AAEXPAVmHRChara__H_Z)(GameModule + 0x4d63f0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_NoStateChangeDamage(class PJZAKO* const this, class mHRChara* arg2) [?mSetDamage_NoStateChangeDamage@PJZAKO@@AAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _mSetDamage_NoStateChangeDamage_PJZAKO__AAEXPAVmHRChara___Z)(class PJZAKO* const thisPtr, class mHRChara* arg2);
	void mSetDamage_NoStateChangeDamage(class mHRChara* arg2)
	{
		_mSetDamage_NoStateChangeDamage_PJZAKO__AAEXPAVmHRChara___Z mFunc = (_mSetDamage_NoStateChangeDamage_PJZAKO__AAEXPAVmHRChara___Z)(GameModule + 0x4d6510);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_DamageCounterProc(class PJZAKO* const this, int32_t* arg2, class mHRChara* arg3) [?mSetDamage_DamageCounterProc@PJZAKO@@AAEXPAHPAVmHRChara@@@Z]
	typedef void(__thiscall* _mSetDamage_DamageCounterProc_PJZAKO__AAEXPAHPAVmHRChara___Z)(class PJZAKO* const thisPtr, int32_t* arg2, class mHRChara* arg3);
	void mSetDamage_DamageCounterProc(int32_t* arg2, class mHRChara* arg3)
	{
		_mSetDamage_DamageCounterProc_PJZAKO__AAEXPAHPAVmHRChara___Z mFunc = (_mSetDamage_DamageCounterProc_PJZAKO__AAEXPAHPAVmHRChara___Z)(GameModule + 0x4d65a0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_InitDamageReaction(class PJZAKO* const this, class mHRChara* arg2, int32_t const arg3) [?mSetDamage_InitDamageReaction@PJZAKO@@AAEXPBVmHRChara@@H@Z]
	typedef void(__thiscall* _mSetDamage_InitDamageReaction_PJZAKO__AAEXPBVmHRChara__H_Z)(class PJZAKO* const thisPtr, class mHRChara* arg2, int32_t const arg3);
	void mSetDamage_InitDamageReaction(class mHRChara* arg2, int32_t const arg3)
	{
		_mSetDamage_InitDamageReaction_PJZAKO__AAEXPBVmHRChara__H_Z mFunc = (_mSetDamage_InitDamageReaction_PJZAKO__AAEXPBVmHRChara__H_Z)(GameModule + 0x4d6720);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_ExceptionDamageProc(class PJZAKO* const this, int32_t const arg2) [?mSetDamage_ExceptionDamageProc@PJZAKO@@AAEXH@Z]
	typedef void(__thiscall* _mSetDamage_ExceptionDamageProc_PJZAKO__AAEXH_Z)(class PJZAKO* const thisPtr, int32_t const arg2);
	void mSetDamage_ExceptionDamageProc(int32_t const arg2)
	{
		_mSetDamage_ExceptionDamageProc_PJZAKO__AAEXH_Z mFunc = (_mSetDamage_ExceptionDamageProc_PJZAKO__AAEXH_Z)(GameModule + 0x4d6760);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_Initialize(class PJZAKO* const this, class mHRChara* arg2, int32_t const arg3) [?mSetDamage_Initialize@PJZAKO@@AAEXPBVmHRChara@@H@Z]
	typedef void(__thiscall* _mSetDamage_Initialize_PJZAKO__AAEXPBVmHRChara__H_Z)(class PJZAKO* const thisPtr, class mHRChara* arg2, int32_t const arg3);
	void mSetDamage_Initialize(class mHRChara* arg2, int32_t const arg3)
	{
		_mSetDamage_Initialize_PJZAKO__AAEXPBVmHRChara__H_Z mFunc = (_mSetDamage_Initialize_PJZAKO__AAEXPBVmHRChara__H_Z)(GameModule + 0x4d6780);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mSetDamage(class PJZAKO* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJZAKO@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJZAKO__UAE_NMHHHMHMMPAVmHRChara___Z)(class PJZAKO* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_PJZAKO__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_PJZAKO__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x4d67f0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] void __convention("thiscall") PJZAKO::CheckSetDmgFuncGarbageInData(class PJZAKO* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?CheckSetDmgFuncGarbageInData@PJZAKO@@AAEXMHHHMHMMPAVmHRChara@@@Z]
	typedef void(__thiscall* _CheckSetDmgFuncGarbageInData_PJZAKO__AAEXMHHHMHMMPAVmHRChara___Z)(class PJZAKO* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	void CheckSetDmgFuncGarbageInData(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_CheckSetDmgFuncGarbageInData_PJZAKO__AAEXMHHHMHMMPAVmHRChara___Z mFunc = (_CheckSetDmgFuncGarbageInData_PJZAKO__AAEXMHHHMHMMPAVmHRChara___Z)(GameModule + 0x4d75d0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] void __convention("thiscall") PJZAKO::CheckValidWayPointArray(class PJZAKO* const this) [?CheckValidWayPointArray@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _CheckValidWayPointArray_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void CheckValidWayPointArray()
	{
		_CheckValidWayPointArray_PJZAKO__AAEXXZ mFunc = (_CheckValidWayPointArray_PJZAKO__AAEXXZ)(GameModule + 0x4d75e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsWallCrashDmgMot(class PJZAKO* const this) [?IsWallCrashDmgMot@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsWallCrashDmgMot_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsWallCrashDmgMot()
	{
		_IsWallCrashDmgMot_PJZAKO__AAE_NXZ mFunc = (_IsWallCrashDmgMot_PJZAKO__AAE_NXZ)(GameModule + 0x4d75f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsKessonDmgMot(class PJZAKO* const this, int32_t arg2) [?IsKessonDmgMot@PJZAKO@@AAE_NH@Z]
	typedef uint8_t(__thiscall* _IsKessonDmgMot_PJZAKO__AAE_NH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	uint8_t IsKessonDmgMot(int32_t arg2)
	{
		_IsKessonDmgMot_PJZAKO__AAE_NH_Z mFunc = (_IsKessonDmgMot_PJZAKO__AAE_NH_Z)(GameModule + 0x4d7600);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsDeadlyDamage(class PJZAKO* const this, int32_t const arg2) [?IsDeadlyDamage@PJZAKO@@AAE_NH@Z]
	typedef uint8_t(__thiscall* _IsDeadlyDamage_PJZAKO__AAE_NH_Z)(class PJZAKO* const thisPtr, int32_t const arg2);
	uint8_t IsDeadlyDamage(int32_t const arg2)
	{
		_IsDeadlyDamage_PJZAKO__AAE_NH_Z mFunc = (_IsDeadlyDamage_PJZAKO__AAE_NH_Z)(GameModule + 0x4d7620);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::JumpNowMotTGPPos(class PJZAKO* const this) [?JumpNowMotTGPPos@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _JumpNowMotTGPPos_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void JumpNowMotTGPPos()
	{
		_JumpNowMotTGPPos_PJZAKO__AAEXXZ mFunc = (_JumpNowMotTGPPos_PJZAKO__AAEXXZ)(GameModule + 0x4d7690);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::ConvertGrdMot(class PJZAKO* const this, int32_t arg2, int32_t arg3) [?ConvertGrdMot@PJZAKO@@AAEHHH@Z]
	typedef int32_t(__thiscall* _ConvertGrdMot_PJZAKO__AAEHHH_Z)(class PJZAKO* const thisPtr, int32_t arg2, int32_t arg3);
	int32_t ConvertGrdMot(int32_t arg2, int32_t arg3)
	{
		_ConvertGrdMot_PJZAKO__AAEHHH_Z mFunc = (_ConvertGrdMot_PJZAKO__AAEHHH_Z)(GameModule + 0x4d7800);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::ConvertDmgMot(class PJZAKO* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4) [?ConvertDmgMot@PJZAKO@@EAEHHHPAVmHRChara@@@Z]
	typedef int32_t(__thiscall* _ConvertDmgMot_PJZAKO__EAEHHHPAVmHRChara___Z)(class PJZAKO* const thisPtr, int32_t const arg2, int32_t const arg3, class mHRChara* arg4);
	int32_t ConvertDmgMot(int32_t const arg2, int32_t const arg3, class mHRChara* arg4)
	{
		_ConvertDmgMot_PJZAKO__EAEHHHPAVmHRChara___Z mFunc = (_ConvertDmgMot_PJZAKO__EAEHHHPAVmHRChara___Z)(GameModule + 0x4d7850);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::ConvertInAtkKindBit(class PJZAKO* const this, int32_t arg2) [?ConvertInAtkKindBit@PJZAKO@@AAEHH@Z]
	typedef int32_t(__thiscall* _ConvertInAtkKindBit_PJZAKO__AAEHH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	int32_t ConvertInAtkKindBit(int32_t arg2)
	{
		_ConvertInAtkKindBit_PJZAKO__AAEHH_Z mFunc = (_ConvertInAtkKindBit_PJZAKO__AAEHH_Z)(GameModule + 0x4d7a20);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsEnableEvacuate(class PJZAKO* const this) [?IsEnableEvacuate@PJZAKO@@MAE_NXZ]
	typedef uint8_t(__thiscall* _IsEnableEvacuate_PJZAKO__MAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsEnableEvacuate()
	{
		_IsEnableEvacuate_PJZAKO__MAE_NXZ mFunc = (_IsEnableEvacuate_PJZAKO__MAE_NXZ)(GameModule + 0x4d7a90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsEnableCrashWall(class PJZAKO* const this) [?IsEnableCrashWall@PJZAKO@@MAE_NXZ]
	typedef uint8_t(__thiscall* _IsEnableCrashWall_PJZAKO__MAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsEnableCrashWall()
	{
		_IsEnableCrashWall_PJZAKO__MAE_NXZ mFunc = (_IsEnableCrashWall_PJZAKO__MAE_NXZ)(GameModule + 0x4d7be0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsEnableGuard(class PJZAKO* const this) [?IsEnableGuard@PJZAKO@@EBE_NXZ]
	typedef uint8_t(__thiscall* _IsEnableGuard_PJZAKO__EBE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsEnableGuard()
	{
		_IsEnableGuard_PJZAKO__EBE_NXZ mFunc = (_IsEnableGuard_PJZAKO__EBE_NXZ)(GameModule + 0x4d7c60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsEnableGuardByGrdCnt(class PJZAKO* const this) [?IsEnableGuardByGrdCnt@PJZAKO@@ABE_NXZ]
	typedef uint8_t(__thiscall* _IsEnableGuardByGrdCnt_PJZAKO__ABE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsEnableGuardByGrdCnt()
	{
		_IsEnableGuardByGrdCnt_PJZAKO__ABE_NXZ mFunc = (_IsEnableGuardByGrdCnt_PJZAKO__ABE_NXZ)(GameModule + 0x4d7da0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsPcDagekiAttack(class PJZAKO* const this) [?IsPcDagekiAttack@PJZAKO@@EBE_NXZ]
	typedef uint8_t(__thiscall* _IsPcDagekiAttack_PJZAKO__EBE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsPcDagekiAttack()
	{
		_IsPcDagekiAttack_PJZAKO__EBE_NXZ mFunc = (_IsPcDagekiAttack_PJZAKO__EBE_NXZ)(GameModule + 0x4d7dc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsPcStompingAttack(class PJZAKO* const this, int32_t const arg2) [?IsPcStompingAttack@PJZAKO@@EAE_NH@Z]
	typedef uint8_t(__thiscall* _IsPcStompingAttack_PJZAKO__EAE_NH_Z)(class PJZAKO* const thisPtr, int32_t const arg2);
	uint8_t IsPcStompingAttack(int32_t const arg2)
	{
		_IsPcStompingAttack_PJZAKO__EAE_NH_Z mFunc = (_IsPcStompingAttack_PJZAKO__EAE_NH_Z)(GameModule + 0x4d7e20);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsGuardHajikareDamage(class PJZAKO* const this, int32_t const arg2, uint8_t arg3) [?IsGuardHajikareDamage@PJZAKO@@ABE_NH_N@Z]
	typedef uint8_t(__thiscall* _IsGuardHajikareDamage_PJZAKO__ABE_NH_N_Z)(class PJZAKO* const thisPtr, int32_t const arg2, uint8_t arg3);
	uint8_t IsGuardHajikareDamage(int32_t const arg2, uint8_t arg3)
	{
		_IsGuardHajikareDamage_PJZAKO__ABE_NH_N_Z mFunc = (_IsGuardHajikareDamage_PJZAKO__ABE_NH_N_Z)(GameModule + 0x4d7e30);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsGetBehindTypeZako(class PJZAKO* const this) [?IsGetBehindTypeZako@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsGetBehindTypeZako_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsGetBehindTypeZako()
	{
		_IsGetBehindTypeZako_PJZAKO__QAE_NXZ mFunc = (_IsGetBehindTypeZako_PJZAKO__QAE_NXZ)(GameModule + 0x4d7ee0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsNoGuardTypeZako(class PJZAKO* const this) [?IsNoGuardTypeZako@PJZAKO@@QBE_NXZ]
	typedef uint8_t(__thiscall* _IsNoGuardTypeZako_PJZAKO__QBE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsNoGuardTypeZako()
	{
		_IsNoGuardTypeZako_PJZAKO__QBE_NXZ mFunc = (_IsNoGuardTypeZako_PJZAKO__QBE_NXZ)(GameModule + 0x4d7ef0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsEnableDownAttackTypeZako(class PJZAKO* const this) [?IsEnableDownAttackTypeZako@PJZAKO@@QBE_NXZ]
	typedef uint8_t(__thiscall* _IsEnableDownAttackTypeZako_PJZAKO__QBE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsEnableDownAttackTypeZako()
	{
		_IsEnableDownAttackTypeZako_PJZAKO__QBE_NXZ mFunc = (_IsEnableDownAttackTypeZako_PJZAKO__QBE_NXZ)(GameModule + 0x4d7f30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrontPc(class PJZAKO* const this) [?IsFrontPc@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrontPc_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrontPc()
	{
		_IsFrontPc_PJZAKO__QAE_NXZ mFunc = (_IsFrontPc_PJZAKO__QAE_NXZ)(GameModule + 0x4d7f50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsBehindPc(class PJZAKO* const this) [?IsBehindPc@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsBehindPc_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsBehindPc()
	{
		_IsBehindPc_PJZAKO__QAE_NXZ mFunc = (_IsBehindPc_PJZAKO__QAE_NXZ)(GameModule + 0x4d7f70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsAttackState(class PJZAKO* const this) [?IsAttackState@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsAttackState_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsAttackState()
	{
		_IsAttackState_PJZAKO__UAE_NXZ mFunc = (_IsAttackState_PJZAKO__UAE_NXZ)(GameModule + 0x4d7f90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsThinkCntZero(class PJZAKO* const this) [?IsThinkCntZero@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsThinkCntZero_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsThinkCntZero()
	{
		_IsThinkCntZero_PJZAKO__QAE_NXZ mFunc = (_IsThinkCntZero_PJZAKO__QAE_NXZ)(GameModule + 0x4d7fb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFuzzyThinkCntZero(class PJZAKO* const this) [?IsFuzzyThinkCntZero@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFuzzyThinkCntZero_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFuzzyThinkCntZero()
	{
		_IsFuzzyThinkCntZero_PJZAKO__QAE_NXZ mFunc = (_IsFuzzyThinkCntZero_PJZAKO__QAE_NXZ)(GameModule + 0x4d7fc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetChangeStateLimitTick(class PJZAKO* const this) [?ResetChangeStateLimitTick@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetChangeStateLimitTick_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetChangeStateLimitTick()
	{
		_ResetChangeStateLimitTick_PJZAKO__AAEXXZ mFunc = (_ResetChangeStateLimitTick_PJZAKO__AAEXXZ)(GameModule + 0x4d7ff0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsFrameRun(class PJZAKO* const this) [?IsFrameRun@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsFrameRun_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsFrameRun()
	{
		_IsFrameRun_PJZAKO__QAE_NXZ mFunc = (_IsFrameRun_PJZAKO__QAE_NXZ)(GameModule + 0x4d8000);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetRotation(class PJZAKO* const this, int32_t, float arg3) [?SetRotation@PJZAKO@@QAE_NUVec@@M@Z]
	typedef uint8_t(__thiscall* _SetRotation_PJZAKO__QAE_NUVec__M_Z)(class PJZAKO* const thisPtr, uint32_t arg2, float arg3);
	uint8_t SetRotation(uint32_t arg2, float arg3)
	{
		_SetRotation_PJZAKO__QAE_NUVec__M_Z mFunc = (_SetRotation_PJZAKO__QAE_NUVec__M_Z)(GameModule + 0x4d8010);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetRotatePc(class PJZAKO* const this, float arg2) [?SetRotatePc@PJZAKO@@QAEXM@Z]
	typedef void(__thiscall* _SetRotatePc_PJZAKO__QAEXM_Z)(class PJZAKO* const thisPtr, float arg2);
	void SetRotatePc(float arg2)
	{
		_SetRotatePc_PJZAKO__QAEXM_Z mFunc = (_SetRotatePc_PJZAKO__QAEXM_Z)(GameModule + 0x4d8240);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetChanceAttackCounter(class PJZAKO* const this) [?SetChanceAttackCounter@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _SetChanceAttackCounter_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void SetChanceAttackCounter()
	{
		_SetChanceAttackCounter_PJZAKO__AAEXXZ mFunc = (_SetChanceAttackCounter_PJZAKO__AAEXXZ)(GameModule + 0x4d8280);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetCondition(class PJZAKO* const this, enum enCharaCondition arg2) [?mSetCondition@PJZAKO@@UAEXW4enCharaCondition@@@Z]
	typedef void(__thiscall* _mSetCondition_PJZAKO__UAEXW4enCharaCondition___Z)(class PJZAKO* const thisPtr, enum enCharaCondition arg2);
	void mSetCondition(/* enum enCharaCondition */ uint32_t arg2)
	{
		_mSetCondition_PJZAKO__UAEXW4enCharaCondition___Z mFunc = (_mSetCondition_PJZAKO__UAEXW4enCharaCondition___Z)(GameModule + 0x4d82c0);
		return mFunc(this, (enum enCharaCondition)arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SubEvacuateCnt(class PJZAKO* const this) [?SubEvacuateCnt@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _SubEvacuateCnt_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void SubEvacuateCnt()
	{
		_SubEvacuateCnt_PJZAKO__AAEXXZ mFunc = (_SubEvacuateCnt_PJZAKO__AAEXXZ)(GameModule + 0x4d82d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetEvacuateCnt(class PJZAKO* const this) [?ResetEvacuateCnt@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetEvacuateCnt_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetEvacuateCnt()
	{
		_ResetEvacuateCnt_PJZAKO__AAEXXZ mFunc = (_ResetEvacuateCnt_PJZAKO__AAEXXZ)(GameModule + 0x4d8300);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetDagekiCounterCnt(class PJZAKO* const this) [?ResetDagekiCounterCnt@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetDagekiCounterCnt_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetDagekiCounterCnt()
	{
		_ResetDagekiCounterCnt_PJZAKO__AAEXXZ mFunc = (_ResetDagekiCounterCnt_PJZAKO__AAEXXZ)(GameModule + 0x4d8370);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetPiyoriDurCnt(class PJZAKO* const this) [?ResetPiyoriDurCnt@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetPiyoriDurCnt_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetPiyoriDurCnt()
	{
		_ResetPiyoriDurCnt_PJZAKO__AAEXXZ mFunc = (_ResetPiyoriDurCnt_PJZAKO__AAEXXZ)(GameModule + 0x4d83b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetFuttobiDurCnt(class PJZAKO* const this) [?ResetFuttobiDurCnt@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetFuttobiDurCnt_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetFuttobiDurCnt()
	{
		_ResetFuttobiDurCnt_PJZAKO__AAEXXZ mFunc = (_ResetFuttobiDurCnt_PJZAKO__AAEXXZ)(GameModule + 0x4d83f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetAttackCnt(class PJZAKO* const this) [?ResetAttackCnt@PJZAKO@@QAEXXZ]
	typedef void(__thiscall* _ResetAttackCnt_PJZAKO__QAEXXZ)(class PJZAKO* const thisPtr);
	void ResetAttackCnt()
	{
		_ResetAttackCnt_PJZAKO__QAEXXZ mFunc = (_ResetAttackCnt_PJZAKO__QAEXXZ)(GameModule + 0x4d8430);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetTateTimingAttack(class PJZAKO* const this) [?SetTateTimingAttack@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _SetTateTimingAttack_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetTateTimingAttack()
	{
		_SetTateTimingAttack_PJZAKO__EAE_NXZ mFunc = (_SetTateTimingAttack_PJZAKO__EAE_NXZ)(GameModule + 0x4d84e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetPressureCnt(class PJZAKO* const this) [?ResetPressureCnt@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetPressureCnt_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetPressureCnt()
	{
		_ResetPressureCnt_PJZAKO__AAEXXZ mFunc = (_ResetPressureCnt_PJZAKO__AAEXXZ)(GameModule + 0x4d8610);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetGuardStiff(class PJZAKO* const this) [?ResetGuardStiff@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetGuardStiff_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetGuardStiff()
	{
		_ResetGuardStiff_PJZAKO__AAEXXZ mFunc = (_ResetGuardStiff_PJZAKO__AAEXXZ)(GameModule + 0x4d8660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ResetGuardCnt(class PJZAKO* const this) [?ResetGuardCnt@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ResetGuardCnt_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ResetGuardCnt()
	{
		_ResetGuardCnt_PJZAKO__AAEXXZ mFunc = (_ResetGuardCnt_PJZAKO__AAEXXZ)(GameModule + 0x4d86b0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetComboAtkMotID(class PJZAKO* const this, int32_t arg2) [?GetComboAtkMotID@PJZAKO@@IAEHH@Z]
	typedef int32_t(__thiscall* _GetComboAtkMotID_PJZAKO__IAEHH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	int32_t GetComboAtkMotID(int32_t arg2)
	{
		_GetComboAtkMotID_PJZAKO__IAEHH_Z mFunc = (_GetComboAtkMotID_PJZAKO__IAEHH_Z)(GameModule + 0x4d8730);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetComboAtkTable_HereAttack(class PJZAKO* const this) [?SetComboAtkTable_HereAttack@PJZAKO@@MAE_NXZ]
	typedef uint8_t(__thiscall* _SetComboAtkTable_HereAttack_PJZAKO__MAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t SetComboAtkTable_HereAttack()
	{
		_SetComboAtkTable_HereAttack_PJZAKO__MAE_NXZ mFunc = (_SetComboAtkTable_HereAttack_PJZAKO__MAE_NXZ)(GameModule + 0x4d8750);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetGetOffCarFlag(class PJZAKO* const this, uint8_t arg2) [?SetGetOffCarFlag@PJZAKO@@QAEX_N@Z]
	typedef void(__thiscall* _SetGetOffCarFlag_PJZAKO__QAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void SetGetOffCarFlag(uint8_t arg2)
	{
		_SetGetOffCarFlag_PJZAKO__QAEX_N_Z mFunc = (_SetGetOffCarFlag_PJZAKO__QAEX_N_Z)(GameModule + 0x4d87e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsDefensive(class PJZAKO* const this) [?IsDefensive@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsDefensive_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsDefensive()
	{
		_IsDefensive_PJZAKO__QAE_NXZ mFunc = (_IsDefensive_PJZAKO__QAE_NXZ)(GameModule + 0x4d87f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsOffensive(class PJZAKO* const this) [?IsOffensive@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsOffensive_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsOffensive()
	{
		_IsOffensive_PJZAKO__QAE_NXZ mFunc = (_IsOffensive_PJZAKO__QAE_NXZ)(GameModule + 0x4d8800);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::DebugRender(class PJZAKO* const this) [?DebugRender@PJZAKO@@UAEXXZ]
	typedef void(__thiscall* _DebugRender_PJZAKO__UAEXXZ)(class PJZAKO* const thisPtr);
	void DebugRender()
	{
		_DebugRender_PJZAKO__UAEXXZ mFunc = (_DebugRender_PJZAKO__UAEXXZ)(GameModule + 0x4d8810);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::DBG_Render_PathFind(class PJZAKO* const this) [?DBG_Render_PathFind@PJZAKO@@QAEXXZ]
	typedef void(__thiscall* _DBG_Render_PathFind_PJZAKO__QAEXXZ)(class PJZAKO* const thisPtr);
	void DBG_Render_PathFind()
	{
		_DBG_Render_PathFind_PJZAKO__QAEXXZ mFunc = (_DBG_Render_PathFind_PJZAKO__QAEXXZ)(GameModule + 0x4d9420);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mPostRenderProc(class PJZAKO* const this) [?mPostRenderProc@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostRenderProc_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mPostRenderProc()
	{
		_mPostRenderProc_PJZAKO__UAE_NXZ mFunc = (_mPostRenderProc_PJZAKO__UAE_NXZ)(GameModule + 0x4d9520);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mRenderProc(class PJZAKO* const this) [?mRenderProc@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mRenderProc_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mRenderProc()
	{
		_mRenderProc_PJZAKO__UAE_NXZ mFunc = (_mRenderProc_PJZAKO__UAE_NXZ)(GameModule + 0x4d9540);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetEvacuateReactFrame(class PJZAKO* const this) [?GetEvacuateReactFrame@PJZAKO@@AAEHXZ]
	typedef int32_t(__thiscall* _GetEvacuateReactFrame_PJZAKO__AAEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetEvacuateReactFrame()
	{
		_GetEvacuateReactFrame_PJZAKO__AAEHXZ mFunc = (_GetEvacuateReactFrame_PJZAKO__AAEHXZ)(GameModule + 0x4d9570);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsPcAttackRangeAndAngle(class PJZAKO* const this) [?IsPcAttackRangeAndAngle@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcAttackRangeAndAngle_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsPcAttackRangeAndAngle()
	{
		_IsPcAttackRangeAndAngle_PJZAKO__QAE_NXZ mFunc = (_IsPcAttackRangeAndAngle_PJZAKO__QAE_NXZ)(GameModule + 0x4d9580);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") PJZAKO::GetMaaiDist(class PJZAKO* const this, enum eZkMaai arg2) [?GetMaaiDist@PJZAKO@@QAEMW4eZkMaai@@@Z]
	typedef float(__thiscall* _GetMaaiDist_PJZAKO__QAEMW4eZkMaai___Z)(class PJZAKO* const thisPtr, enum eZkMaai arg2);
	float GetMaaiDist(/* enum eZkMaai */ uint32_t arg2)
	{
		_GetMaaiDist_PJZAKO__QAEMW4eZkMaai___Z mFunc = (_GetMaaiDist_PJZAKO__QAEMW4eZkMaai___Z)(GameModule + 0x4d95b0);
		return mFunc(this, (enum eZkMaai)arg2);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetDownContinueFrm(class PJZAKO* const this) [?GetDownContinueFrm@PJZAKO@@QAEHXZ]
	typedef int32_t(__thiscall* _GetDownContinueFrm_PJZAKO__QAEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetDownContinueFrm()
	{
		_GetDownContinueFrm_PJZAKO__QAEHXZ mFunc = (_GetDownContinueFrm_PJZAKO__QAEHXZ)(GameModule + 0x4d9770);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::CheckInvalidChangeState(class PJZAKO* const this, enum eZkStat arg2, int32_t arg3) [?CheckInvalidChangeState@PJZAKO@@QAEXW4eZkStat@@H@Z]
	typedef void(__thiscall* _CheckInvalidChangeState_PJZAKO__QAEXW4eZkStat__H_Z)(class PJZAKO* const thisPtr, enum eZkStat arg2, int32_t arg3);
	void CheckInvalidChangeState(/* enum eZkStat */ uint32_t arg2, int32_t arg3)
	{
		_CheckInvalidChangeState_PJZAKO__QAEXW4eZkStat__H_Z mFunc = (_CheckInvalidChangeState_PJZAKO__QAEXW4eZkStat__H_Z)(GameModule + 0x4d9840);
		return mFunc(this, (enum eZkStat)arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::StatusUpdate(class PJZAKO* const this) [?StatusUpdate@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _StatusUpdate_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void StatusUpdate()
	{
		_StatusUpdate_PJZAKO__AAEXXZ mFunc = (_StatusUpdate_PJZAKO__AAEXXZ)(GameModule + 0x4d9850);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::UpdateZakoState(class PJZAKO* const this) [?UpdateZakoState@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _UpdateZakoState_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void UpdateZakoState()
	{
		_UpdateZakoState_PJZAKO__AAEXXZ mFunc = (_UpdateZakoState_PJZAKO__AAEXXZ)(GameModule + 0x4d9a00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::UpdateLookIK(class PJZAKO* const this) [?UpdateLookIK@PJZAKO@@MAEXXZ]
	typedef void(__thiscall* _UpdateLookIK_PJZAKO__MAEXXZ)(class PJZAKO* const thisPtr);
	void UpdateLookIK()
	{
		_UpdateLookIK_PJZAKO__MAEXXZ mFunc = (_UpdateLookIK_PJZAKO__MAEXXZ)(GameModule + 0x4d9ed0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::UpdatePcState(class PJZAKO* const this) [?UpdatePcState@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _UpdatePcState_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void UpdatePcState()
	{
		_UpdatePcState_PJZAKO__AAEXXZ mFunc = (_UpdatePcState_PJZAKO__AAEXXZ)(GameModule + 0x4d9fe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::UpdateAtkColl(class PJZAKO* const this) [?UpdateAtkColl@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _UpdateAtkColl_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void UpdateAtkColl()
	{
		_UpdateAtkColl_PJZAKO__AAEXXZ mFunc = (_UpdateAtkColl_PJZAKO__AAEXXZ)(GameModule + 0x4da190);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::DebugModeProc(class PJZAKO* const this) [?DebugModeProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _DebugModeProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void DebugModeProc()
	{
		_DebugModeProc_PJZAKO__AAEXXZ mFunc = (_DebugModeProc_PJZAKO__AAEXXZ)(GameModule + 0x4da310);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ApplyDP(class PJZAKO* const this) [?ApplyDP@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ApplyDP_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ApplyDP()
	{
		_ApplyDP_PJZAKO__AAEXXZ mFunc = (_ApplyDP_PJZAKO__AAEXXZ)(GameModule + 0x4da320);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::MoveProc(class PJZAKO* const this, enum eControlMove arg2, float arg3) [?MoveProc@PJZAKO@@AAEXW4eControlMove@@M@Z]
	typedef void(__thiscall* _MoveProc_PJZAKO__AAEXW4eControlMove__M_Z)(class PJZAKO* const thisPtr, enum eControlMove arg2, float arg3);
	void MoveProc(/* enum eControlMove */ uint32_t arg2, float arg3)
	{
		_MoveProc_PJZAKO__AAEXW4eControlMove__M_Z mFunc = (_MoveProc_PJZAKO__AAEXW4eControlMove__M_Z)(GameModule + 0x4da330);
		return mFunc(this, (enum eControlMove)arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::ExitUnderControl(class PJZAKO* const this) [?ExitUnderControl@PJZAKO@@EAEXXZ]
	typedef void(__thiscall* _ExitUnderControl_PJZAKO__EAEXXZ)(class PJZAKO* const thisPtr);
	void ExitUnderControl()
	{
		_ExitUnderControl_PJZAKO__EAEXXZ mFunc = (_ExitUnderControl_PJZAKO__EAEXXZ)(GameModule + 0x4da640);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::EnterUnderControl(class PJZAKO* const this) [?EnterUnderControl@PJZAKO@@EAEXXZ]
	typedef void(__thiscall* _EnterUnderControl_PJZAKO__EAEXXZ)(class PJZAKO* const thisPtr);
	void EnterUnderControl()
	{
		_EnterUnderControl_PJZAKO__EAEXXZ mFunc = (_EnterUnderControl_PJZAKO__EAEXXZ)(GameModule + 0x4da690);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::UnderControllAttack_A(class PJZAKO* const this) [?UnderControllAttack_A@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _UnderControllAttack_A_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t UnderControllAttack_A()
	{
		_UnderControllAttack_A_PJZAKO__EAE_NXZ mFunc = (_UnderControllAttack_A_PJZAKO__EAE_NXZ)(GameModule + 0x4da700);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::UnderControllComboAttack(class PJZAKO* const this) [?UnderControllComboAttack@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _UnderControllComboAttack_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t UnderControllComboAttack()
	{
		_UnderControllComboAttack_PJZAKO__EAE_NXZ mFunc = (_UnderControllComboAttack_PJZAKO__EAE_NXZ)(GameModule + 0x4da710);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ControlZakoProc(class PJZAKO* const this) [?ControlZakoProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ControlZakoProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ControlZakoProc()
	{
		_ControlZakoProc_PJZAKO__AAEXXZ mFunc = (_ControlZakoProc_PJZAKO__AAEXXZ)(GameModule + 0x4da720);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ComboAttack(class PJZAKO* const this) [?ComboAttack@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ComboAttack_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ComboAttack()
	{
		_ComboAttack_PJZAKO__AAEXXZ mFunc = (_ComboAttack_PJZAKO__AAEXXZ)(GameModule + 0x4da730);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::TestProc(class PJZAKO* const this) [?TestProc@PJZAKO@@EAEXXZ]
	typedef void(__thiscall* _TestProc_PJZAKO__EAEXXZ)(class PJZAKO* const thisPtr);
	void TestProc()
	{
		_TestProc_PJZAKO__EAEXXZ mFunc = (_TestProc_PJZAKO__EAEXXZ)(GameModule + 0x4da7d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::AIProc(class PJZAKO* const this) [?AIProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _AIProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void AIProc()
	{
		_AIProc_PJZAKO__AAEXXZ mFunc = (_AIProc_PJZAKO__AAEXXZ)(GameModule + 0x4da7e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::FightSpiritStatProc(class PJZAKO* const this) [?FightSpiritStatProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _FightSpiritStatProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void FightSpiritStatProc()
	{
		_FightSpiritStatProc_PJZAKO__AAEXXZ mFunc = (_FightSpiritStatProc_PJZAKO__AAEXXZ)(GameModule + 0x4da810);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::PreAIProc(class PJZAKO* const this) [?PreAIProc@PJZAKO@@AAE_NXZ]
	typedef uint8_t(__thiscall* _PreAIProc_PJZAKO__AAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t PreAIProc()
	{
		_PreAIProc_PJZAKO__AAE_NXZ mFunc = (_PreAIProc_PJZAKO__AAE_NXZ)(GameModule + 0x4da8c0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetFrame(class PJZAKO* const this, int32_t const arg2, enum PJZAKO::eFrameType arg3) [?GetFrame@PJZAKO@@ABEHHW4eFrameType@1@@Z]
	typedef int32_t(__thiscall* _GetFrame_PJZAKO__ABEHHW4eFrameType_1__Z)(class PJZAKO* const thisPtr, int32_t const arg2, enum PJZAKO::eFrameType arg3);
	int32_t GetFrame(int32_t const arg2, /* enum PJZAKO::eFrameType */ uint32_t arg3)
	{
		_GetFrame_PJZAKO__ABEHHW4eFrameType_1__Z mFunc = (_GetFrame_PJZAKO__ABEHHW4eFrameType_1__Z)(GameModule + 0x4da8e0);
		return mFunc(this, arg2, (enum PJZAKO::eFrameType)arg3);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::GetPerformIllMotionNo(class PJZAKO* const this) [?GetPerformIllMotionNo@PJZAKO@@EBEHXZ]
	typedef int32_t(__thiscall* _GetPerformIllMotionNo_PJZAKO__EBEHXZ)(class PJZAKO* const thisPtr);
	int32_t GetPerformIllMotionNo()
	{
		_GetPerformIllMotionNo_PJZAKO__EBEHXZ mFunc = (_GetPerformIllMotionNo_PJZAKO__EBEHXZ)(GameModule + 0x4dadb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::PhysicDeadModelRender(class PJZAKO* const this) [?PhysicDeadModelRender@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _PhysicDeadModelRender_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void PhysicDeadModelRender()
	{
		_PhysicDeadModelRender_PJZAKO__AAEXXZ mFunc = (_PhysicDeadModelRender_PJZAKO__AAEXXZ)(GameModule + 0x4dae30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::PhysicDeadModelProcess(class PJZAKO* const this) [?PhysicDeadModelProcess@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _PhysicDeadModelProcess_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void PhysicDeadModelProcess()
	{
		_PhysicDeadModelProcess_PJZAKO__AAEXXZ mFunc = (_PhysicDeadModelProcess_PJZAKO__AAEXXZ)(GameModule + 0x4dae50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::PhysicDeadModelTerminate(class PJZAKO* const this) [?PhysicDeadModelTerminate@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _PhysicDeadModelTerminate_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void PhysicDeadModelTerminate()
	{
		_PhysicDeadModelTerminate_PJZAKO__AAEXXZ mFunc = (_PhysicDeadModelTerminate_PJZAKO__AAEXXZ)(GameModule + 0x4db120);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::PhysicDeadModelCreate(class PJZAKO* const this) [?PhysicDeadModelCreate@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _PhysicDeadModelCreate_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void PhysicDeadModelCreate()
	{
		_PhysicDeadModelCreate_PJZAKO__AAEXXZ mFunc = (_PhysicDeadModelCreate_PJZAKO__AAEXXZ)(GameModule + 0x4db140);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mPostFrameCommonProc2(class PJZAKO* const this) [?mPostFrameCommonProc2@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameCommonProc2_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mPostFrameCommonProc2()
	{
		_mPostFrameCommonProc2_PJZAKO__UAE_NXZ mFunc = (_mPostFrameCommonProc2_PJZAKO__UAE_NXZ)(GameModule + 0x4db380);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mRequestBloodSplash(class PJZAKO* const this, char* inNodeName, int32_t inRagTick) [?mRequestBloodSplash@PJZAKO@@MAE_NPADH@Z]
	typedef uint8_t(__thiscall* _mRequestBloodSplash_PJZAKO__MAE_NPADH_Z)(class PJZAKO* const thisPtr, char* inNodeName, int32_t inRagTick);
	uint8_t mRequestBloodSplash(std::string inNodeName, int32_t inRagTick)
	{
		std::vector<char> inNodeName_c_str(inNodeName.c_str(), + inNodeName.c_str() + inNodeName.size() + 1);
		_mRequestBloodSplash_PJZAKO__MAE_NPADH_Z mFunc = (_mRequestBloodSplash_PJZAKO__MAE_NPADH_Z)(GameModule + 0x4db510);
		return mFunc(this, &inNodeName_c_str[0], inRagTick);
	}
	// [Function] void __convention("thiscall") PJZAKO::DeadEffectProc(class PJZAKO* const this) [?DeadEffectProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _DeadEffectProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void DeadEffectProc()
	{
		_DeadEffectProc_PJZAKO__AAEXXZ mFunc = (_DeadEffectProc_PJZAKO__AAEXXZ)(GameModule + 0x4db610);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::CallDamageScriptCallBack(class PJZAKO* const this, int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4) [?CallDamageScriptCallBack@PJZAKO@@AAEXH_NW4eDmgCallBackDmgType@@@Z]
	typedef void(__thiscall* _CallDamageScriptCallBack_PJZAKO__AAEXH_NW4eDmgCallBackDmgType___Z)(class PJZAKO* const thisPtr, int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4);
	void CallDamageScriptCallBack(int32_t arg2, uint8_t arg3, /* enum eDmgCallBackDmgType */ uint32_t arg4)
	{
		_CallDamageScriptCallBack_PJZAKO__AAEXH_NW4eDmgCallBackDmgType___Z mFunc = (_CallDamageScriptCallBack_PJZAKO__AAEXH_NW4eDmgCallBackDmgType___Z)(GameModule + 0x4db6b0);
		return mFunc(this, arg2, arg3, (enum eDmgCallBackDmgType)arg4);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mPostFrameProc(class PJZAKO* const this) [?mPostFrameProc@PJZAKO@@EAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameProc_PJZAKO__EAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mPostFrameProc()
	{
		_mPostFrameProc_PJZAKO__EAE_NXZ mFunc = (_mPostFrameProc_PJZAKO__EAE_NXZ)(GameModule + 0x4db700);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mFrameProc(class PJZAKO* const this) [?mFrameProc@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mFrameProc_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mFrameProc()
	{
		_mFrameProc_PJZAKO__UAE_NXZ mFunc = (_mFrameProc_PJZAKO__UAE_NXZ)(GameModule + 0x4db960);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::AvoidFriendProc(class PJZAKO* const this) [?AvoidFriendProc@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _AvoidFriendProc_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void AvoidFriendProc()
	{
		_AvoidFriendProc_PJZAKO__AAEXXZ mFunc = (_AvoidFriendProc_PJZAKO__AAEXXZ)(GameModule + 0x4dbf10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ClearUpperPow(class PJZAKO* const this) [?ClearUpperPow@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _ClearUpperPow_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void ClearUpperPow()
	{
		_ClearUpperPow_PJZAKO__AAEXXZ mFunc = (_ClearUpperPow_PJZAKO__AAEXXZ)(GameModule + 0x4dc240);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::InitWepEffect(class PJZAKO* const this) [?InitWepEffect@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _InitWepEffect_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void InitWepEffect()
	{
		_InitWepEffect_PJZAKO__AAEXXZ mFunc = (_InitWepEffect_PJZAKO__AAEXXZ)(GameModule + 0x4dc260);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::InitWeapon(class PJZAKO* const this) [?InitWeapon@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _InitWeapon_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void InitWeapon()
	{
		_InitWeapon_PJZAKO__AAEXXZ mFunc = (_InitWeapon_PJZAKO__AAEXXZ)(GameModule + 0x4dc310);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::InitMotion(class PJZAKO* const this) [?InitMotion@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _InitMotion_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void InitMotion()
	{
		_InitMotion_PJZAKO__AAEXXZ mFunc = (_InitMotion_PJZAKO__AAEXXZ)(GameModule + 0x4dc4d0);
		return mFunc(this);
	}
	// [Function] char const* __convention("thiscall") PJZAKO::GetVariationTextureName(class PJZAKO* const this, int32_t arg2, int32_t arg3) [?GetVariationTextureName@PJZAKO@@AAEPBDHH@Z]
	typedef char const*(__thiscall* _GetVariationTextureName_PJZAKO__AAEPBDHH_Z)(class PJZAKO* const thisPtr, int32_t arg2, int32_t arg3);
	std::string GetVariationTextureName(int32_t arg2, int32_t arg3)
	{
		_GetVariationTextureName_PJZAKO__AAEPBDHH_Z mFunc = (_GetVariationTextureName_PJZAKO__AAEPBDHH_Z)(GameModule + 0x4dca60);
		char const* OutResult = mFunc(this, arg2, arg3);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] void __convention("thiscall") PJZAKO::InitModel(class PJZAKO* const this) [?InitModel@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _InitModel_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void InitModel()
	{
		_InitModel_PJZAKO__AAEXXZ mFunc = (_InitModel_PJZAKO__AAEXXZ)(GameModule + 0x4dca80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mInit(class PJZAKO* const this) [?mInit@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mInit_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mInit()
	{
		_mInit_PJZAKO__UAE_NXZ mFunc = (_mInit_PJZAKO__UAE_NXZ)(GameModule + 0x4dcbf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::InitExZako(class PJZAKO* const this) [?InitExZako@PJZAKO@@AAEXXZ]
	typedef void(__thiscall* _InitExZako_PJZAKO__AAEXXZ)(class PJZAKO* const thisPtr);
	void InitExZako()
	{
		_InitExZako_PJZAKO__AAEXXZ mFunc = (_InitExZako_PJZAKO__AAEXXZ)(GameModule + 0x4dccd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::InitStateMachine(class PJZAKO* const this) [?InitStateMachine@PJZAKO@@MAEXXZ]
	typedef void(__thiscall* _InitStateMachine_PJZAKO__MAEXXZ)(class PJZAKO* const thisPtr);
	void InitStateMachine()
	{
		_InitStateMachine_PJZAKO__MAEXXZ mFunc = (_InitStateMachine_PJZAKO__MAEXXZ)(GameModule + 0x4dcfa0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetStateIdx(class PJZAKO* const this, int32_t const arg2, class PJState* arg3) [?SetStateIdx@PJZAKO@@IAEXHPAVPJState@@@Z]
	typedef void(__thiscall* _SetStateIdx_PJZAKO__IAEXHPAVPJState___Z)(class PJZAKO* const thisPtr, int32_t const arg2, class PJState* arg3);
	void SetStateIdx(int32_t const arg2, class PJState* arg3)
	{
		_SetStateIdx_PJZAKO__IAEXHPAVPJState___Z mFunc = (_SetStateIdx_PJZAKO__IAEXHPAVPJState___Z)(GameModule + 0x4dd750);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mTerm(class PJZAKO* const this) [?mTerm@PJZAKO@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mTerm_PJZAKO__UAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t mTerm()
	{
		_mTerm_PJZAKO__UAE_NXZ mFunc = (_mTerm_PJZAKO__UAE_NXZ)(GameModule + 0x4dd770);
		return mFunc(this);
	}
	// [Function] int32_t __fastcall PJZAKO::StaticProc(class mHRBattle* arg1) [?StaticProc@PJZAKO@@CAXXZ]
	typedef int32_t(__fastcall* _StaticProc_PJZAKO__CAXXZ)(class mHRBattle* arg1);
	static int32_t StaticProc(class mHRBattle* arg1)
	{
		_StaticProc_PJZAKO__CAXXZ mFunc = (_StaticProc_PJZAKO__CAXXZ)(GameModule + 0x4de320);
		return mFunc(arg1);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsEnableForceChangeState(class PJZAKO* const this) [?IsEnableForceChangeState@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsEnableForceChangeState_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsEnableForceChangeState()
	{
		_IsEnableForceChangeState_PJZAKO__QAE_NXZ mFunc = (_IsEnableForceChangeState_PJZAKO__QAE_NXZ)(GameModule + 0x4de3b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsSafetyChangeStateTiming(class PJZAKO* const this) [?IsSafetyChangeStateTiming@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsSafetyChangeStateTiming_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsSafetyChangeStateTiming()
	{
		_IsSafetyChangeStateTiming_PJZAKO__QAE_NXZ mFunc = (_IsSafetyChangeStateTiming_PJZAKO__QAE_NXZ)(GameModule + 0x4de400);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::ChangeState(class PJZAKO* const this, enum eZkStat arg2, int32_t arg3) [?ChangeState@PJZAKO@@QAEXW4eZkStat@@H@Z]
	typedef void(__thiscall* _ChangeState_PJZAKO__QAEXW4eZkStat__H_Z)(class PJZAKO* const thisPtr, enum eZkStat arg2, int32_t arg3);
	void ChangeState(/* enum eZkStat */ uint32_t arg2, int32_t arg3)
	{
		_ChangeState_PJZAKO__QAEXW4eZkStat__H_Z mFunc = (_ChangeState_PJZAKO__QAEXW4eZkStat__H_Z)(GameModule + 0x4de440);
		return mFunc(this, (enum eZkStat)arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsPopIdleState(class PJZAKO* const this) [?IsPopIdleState@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsPopIdleState_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsPopIdleState()
	{
		_IsPopIdleState_PJZAKO__QAE_NXZ mFunc = (_IsPopIdleState_PJZAKO__QAE_NXZ)(GameModule + 0x4de4a0);
		return mFunc(this);
	}
	// [Function] void PJZAKO::SetRequestPopedZakoDeathOutOfCameraByNpcID(int32_t const arg1) [?SetRequestPopedZakoDeathOutOfCameraByNpcID@PJZAKO@@SAXH@Z]
	typedef void(__fastcall* _SetRequestPopedZakoDeathOutOfCameraByNpcID_PJZAKO__SAXH_Z)(int32_t const arg1);
	static void SetRequestPopedZakoDeathOutOfCameraByNpcID(int32_t const arg1)
	{
		_SetRequestPopedZakoDeathOutOfCameraByNpcID_PJZAKO__SAXH_Z mFunc = (_SetRequestPopedZakoDeathOutOfCameraByNpcID_PJZAKO__SAXH_Z)(GameModule + 0x4de500);
		return mFunc(arg1);
	}
	// [Function] void __convention("thiscall") PJZAKO::PlayVoice(class PJZAKO* const this, enum PJZAKO::eVoiceType arg2, bool bForce) [?PlayVoice@PJZAKO@@QAEXW4eVoiceType@1@_N@Z]
	typedef void(__thiscall* _PlayVoice_PJZAKO__QAEXW4eVoiceType_1__N_Z)(class PJZAKO* const thisPtr, enum PJZAKO::eVoiceType arg2, bool bForce);
	void PlayVoice(/* enum PJZAKO::eVoiceType */ uint32_t arg2, bool bForce)
	{
		_PlayVoice_PJZAKO__QAEXW4eVoiceType_1__N_Z mFunc = (_PlayVoice_PJZAKO__QAEXW4eVoiceType_1__N_Z)(GameModule + 0x4de530);
		return mFunc(this, (enum PJZAKO::eVoiceType)arg2, bForce);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsDownMotion(class PJZAKO* const this) [?IsDownMotion@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsDownMotion_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsDownMotion()
	{
		_IsDownMotion_PJZAKO__QAE_NXZ mFunc = (_IsDownMotion_PJZAKO__QAE_NXZ)(GameModule + 0x4de5c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsUchiagerareDmgMot(class PJZAKO* const this) [?IsUchiagerareDmgMot@PJZAKO@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsUchiagerareDmgMot_PJZAKO__QAE_NXZ)(class PJZAKO* const thisPtr);
	uint8_t IsUchiagerareDmgMot()
	{
		_IsUchiagerareDmgMot_PJZAKO__QAE_NXZ mFunc = (_IsUchiagerareDmgMot_PJZAKO__QAE_NXZ)(GameModule + 0x4de5e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsThrowDmgMot(class PJZAKO* const this, int32_t arg2) [?IsThrowDmgMot@PJZAKO@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _IsThrowDmgMot_PJZAKO__QAE_NH_Z)(class PJZAKO* const thisPtr, int32_t arg2);
	uint8_t IsThrowDmgMot(int32_t arg2)
	{
		_IsThrowDmgMot_PJZAKO__QAE_NH_Z mFunc = (_IsThrowDmgMot_PJZAKO__QAE_NH_Z)(GameModule + 0x4de610);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::InitPop(class PJZAKO* const this) [?InitPop@PJZAKO@@QAEXXZ]
	typedef void(__thiscall* _InitPop_PJZAKO__QAEXXZ)(class PJZAKO* const thisPtr);
	void InitPop()
	{
		_InitPop_PJZAKO__QAEXXZ mFunc = (_InitPop_PJZAKO__QAEXXZ)(GameModule + 0x4de790);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::RegistSyncAppearStgCmnObj(class PJZAKO* const this, class commonObj* arg2) [?RegistSyncAppearStgCmnObj@PJZAKO@@QAE_NPAVcommonObj@@@Z]
	typedef uint8_t(__thiscall* _RegistSyncAppearStgCmnObj_PJZAKO__QAE_NPAVcommonObj___Z)(class PJZAKO* const thisPtr, class commonObj* arg2);
	uint8_t RegistSyncAppearStgCmnObj(class commonObj* arg2)
	{
		_RegistSyncAppearStgCmnObj_PJZAKO__QAE_NPAVcommonObj___Z mFunc = (_RegistSyncAppearStgCmnObj_PJZAKO__QAE_NPAVcommonObj___Z)(GameModule + 0x4dea80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::SetStat_WayPoint(class PJZAKO* const this, struct Vec& arg2) [?SetStat_WayPoint@PJZAKO@@QAE_NABUVec@@@Z]
	typedef uint8_t(__thiscall* _SetStat_WayPoint_PJZAKO__QAE_NABUVec___Z)(class PJZAKO* const thisPtr, struct Vec& arg2);
	uint8_t SetStat_WayPoint(struct Vec& arg2)
	{
		_SetStat_WayPoint_PJZAKO__QAE_NABUVec___Z mFunc = (_SetStat_WayPoint_PJZAKO__QAE_NABUVec___Z)(GameModule + 0x4deaa0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::ClearWayPoint(class PJZAKO* const this) [?ClearWayPoint@PJZAKO@@QAEXXZ]
	typedef void(__thiscall* _ClearWayPoint_PJZAKO__QAEXXZ)(class PJZAKO* const thisPtr);
	void ClearWayPoint()
	{
		_ClearWayPoint_PJZAKO__QAEXXZ mFunc = (_ClearWayPoint_PJZAKO__QAEXXZ)(GameModule + 0x4deb30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKO::AddWayPoint(class PJZAKO* const this, struct Vec& arg2) [?AddWayPoint@PJZAKO@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _AddWayPoint_PJZAKO__QAEXABUVec___Z)(class PJZAKO* const thisPtr, struct Vec& arg2);
	void AddWayPoint(struct Vec& arg2)
	{
		_AddWayPoint_PJZAKO__QAEXABUVec___Z mFunc = (_AddWayPoint_PJZAKO__QAEXABUVec___Z)(GameModule + 0x4deb70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::AddRequestBreakPopCmnObj(class PJZAKO* const this, class commonObj* arg2) [?AddRequestBreakPopCmnObj@PJZAKO@@QAEXPAVcommonObj@@@Z]
	typedef void(__thiscall* _AddRequestBreakPopCmnObj_PJZAKO__QAEXPAVcommonObj___Z)(class PJZAKO* const thisPtr, class commonObj* arg2);
	void AddRequestBreakPopCmnObj(class commonObj* arg2)
	{
		_AddRequestBreakPopCmnObj_PJZAKO__QAEXPAVcommonObj___Z mFunc = (_AddRequestBreakPopCmnObj_PJZAKO__QAEXPAVcommonObj___Z)(GameModule + 0x4debd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::SetBreakPopCmnObjStartFlag(class PJZAKO* const this, uint8_t arg2) [?SetBreakPopCmnObjStartFlag@PJZAKO@@QAEX_N@Z]
	typedef void(__thiscall* _SetBreakPopCmnObjStartFlag_PJZAKO__QAEX_N_Z)(class PJZAKO* const thisPtr, uint8_t arg2);
	void SetBreakPopCmnObjStartFlag(uint8_t arg2)
	{
		_SetBreakPopCmnObjStartFlag_PJZAKO__QAEX_N_Z mFunc = (_SetBreakPopCmnObjStartFlag_PJZAKO__QAEX_N_Z)(GameModule + 0x4dec50);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZAKO [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZAKO& InObject)
	{
		m_BoneScale = InObject.m_BoneScale;
		m_SetDamageInfo = InObject.m_SetDamageInfo;
		m_ZakoInfo = InObject.m_ZakoInfo;
		m_MotionInfo = InObject.m_MotionInfo;
		m_TojoInfo = InObject.m_TojoInfo;
		m_PcInfo = InObject.m_PcInfo;
		m_DmgInfo = InObject.m_DmgInfo;
		m_AiInfo = InObject.m_AiInfo;
		m_Counter = InObject.m_Counter;
		m_CheckCanHitPrevCnt = InObject.m_CheckCanHitPrevCnt;
		m_AddKillNumWaitCounter = InObject.m_AddKillNumWaitCounter;
		m_boAddedKillNum = InObject.m_boAddedKillNum;
		m_boMoveTurretFlag = InObject.m_boMoveTurretFlag;
		m_boWayPointMoveAfterPop = InObject.m_boWayPointMoveAfterPop;
		m_pStateMachine = InObject.m_pStateMachine;
		m_eNowStateIdx = InObject.m_eNowStateIdx;
		m_ePrevStateIdx = InObject.m_ePrevStateIdx;
		m_eScareType = InObject.m_eScareType;
		mTargetDirec = InObject.mTargetDirec;
		mNowDirecY = InObject.mNowDirecY;
		mDeadModelType = InObject.mDeadModelType;
		m_EfDanmen = InObject.m_EfDanmen;
		m_pCutMark = InObject.m_pCutMark;
		mpEfQuestion = InObject.mpEfQuestion;
		m_pMotMng = InObject.m_pMotMng;
		m_WayPointArry = InObject.m_WayPointArry;
		m_iWayPoint = InObject.m_iWayPoint;
		m_pPathPlanner = InObject.m_pPathPlanner;
		m_boUseObstacleSensor = InObject.m_boUseObstacleSensor;
		m_boDisableInterestIK = InObject.m_boDisableInterestIK;
		m_boBerserkAtk = InObject.m_boBerserkAtk;
		m_boRequestDeathOutOfCamera = InObject.m_boRequestDeathOutOfCamera;
		m_boFirstBombDeadFxPlay = InObject.m_boFirstBombDeadFxPlay;
		m_JumpOffTojoLandingPos = InObject.m_JumpOffTojoLandingPos;
		m_boFixTurret = InObject.m_boFixTurret;
		m_eSdnAtkPopDir = InObject.m_eSdnAtkPopDir;
		m_pDP = InObject.m_pDP;
		m_pObsSens = InObject.m_pObsSens;
		m_Atk2PcHitAfterCnt = InObject.m_Atk2PcHitAfterCnt;
		m_boPcDownLaugh = InObject.m_boPcDownLaugh;
		m_pBulletManager = InObject.m_pBulletManager;
		m_boPhysicDeadProc = InObject.m_boPhysicDeadProc;
		m_bIsHeadPhysicsEnd = InObject.m_bIsHeadPhysicsEnd;
		m_pPhysicDeadGmf = InObject.m_pPhysicDeadGmf;
		m_boTodomeDead = InObject.m_boTodomeDead;
		m_boDeadEffectReq = InObject.m_boDeadEffectReq;
		m_DeadEffectCountCown = InObject.m_DeadEffectCountCown;
		m_ParticleDeadZakoTerminateWaitTick = InObject.m_ParticleDeadZakoTerminateWaitTick;
		m_pBnFxDmgDat = InObject.m_pBnFxDmgDat;
		m_boTimeShareUpdate = InObject.m_boTimeShareUpdate;
		m_eTimeShareStat = InObject.m_eTimeShareStat;
		m_CollInfo = InObject.m_CollInfo;
		m_Tex = InObject.m_Tex;
		m_ChangeStateLimitTick = InObject.m_ChangeStateLimitTick;
		m_fRotSpd = InObject.m_fRotSpd;
		m_BreakPopCmnObjPtrList = InObject.m_BreakPopCmnObjPtrList;
		m_pSyncPopCmnObj = InObject.m_pSyncPopCmnObj;
		m_boCalledNoGuardEfOnce = InObject.m_boCalledNoGuardEfOnce;
		m_OutOfCameraIkakuShootTime = InObject.m_OutOfCameraIkakuShootTime;
		m_State_Damage = InObject.m_State_Damage;
		m_State_CloseForAtk = InObject.m_State_CloseForAtk;
		m_State_AwayAfterAtk = InObject.m_State_AwayAfterAtk;
		m_State_ComboAttack = InObject.m_State_ComboAttack;
		m_State_StepInAttack = InObject.m_State_StepInAttack;
		m_State_Defence = InObject.m_State_Defence;
		m_State_Evacuate = InObject.m_State_Evacuate;
		m_State_RandomMove = InObject.m_State_RandomMove;
		m_State_ThroughDamage = InObject.m_State_ThroughDamage;
		m_State_DownDamage = InObject.m_State_DownDamage;
		m_State_Pressure = InObject.m_State_Pressure;
		m_State_WayPointMove = InObject.m_State_WayPointMove;
		m_State_Run = InObject.m_State_Run;
		m_State_Kosinukasi = InObject.m_State_Kosinukasi;
		m_State_Yotunbai = InObject.m_State_Yotunbai;
		m_State_Stand = InObject.m_State_Stand;
		m_StatePerformIll = InObject.m_StatePerformIll;
		m_ReleaseWaitIdle = InObject.m_ReleaseWaitIdle;
		m_State_Tojo_RunAndTurnPc = InObject.m_State_Tojo_RunAndTurnPc;
		m_State_Tojo_AgainstWall = InObject.m_State_Tojo_AgainstWall;
		m_State_Tojo_LookAround = InObject.m_State_Tojo_LookAround;
		m_State_Tojo_Stand = InObject.m_State_Tojo_Stand;
		m_State_Tojo_Bench = InObject.m_State_Tojo_Bench;
		m_State_Tojo_Sit = InObject.m_State_Tojo_Sit;
		m_State_Tojo_Car = InObject.m_State_Tojo_Car;
		m_State_Tojo_JumpOff = InObject.m_State_Tojo_JumpOff;
		m_State_Tojo_BreakCmnObj = InObject.m_State_Tojo_BreakCmnObj;
		m_State_Tojo_AeroBike = InObject.m_State_Tojo_AeroBike;
		m_State_Tojo_RoomRunner = InObject.m_State_Tojo_RoomRunner;
		m_State_LeadPcWayPointMove = InObject.m_State_LeadPcWayPointMove;
		m_State_FixTurret = InObject.m_State_FixTurret;
		m_State_WayPointMoveAfterPop = InObject.m_State_WayPointMoveAfterPop;
		m_State_DownAttack = InObject.m_State_DownAttack;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZAKO, mHRChara>("PJZAKO")
			.addFunction("__tostring", &PJZAKO::ToString)
			.addFunction("GetPtrAddr", &PJZAKO::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StatePtrArr", &PJZAKO::m_StatePtrArr)
			.addProperty("m_BoneScale", &PJZAKO::m_BoneScale)
			.addProperty("m_SetDamageInfo", &PJZAKO::m_SetDamageInfo)
			.addProperty("m_ZakoInfo", &PJZAKO::m_ZakoInfo)
			.addProperty("m_MotionInfo", &PJZAKO::m_MotionInfo)
			.addProperty("m_TojoInfo", &PJZAKO::m_TojoInfo)
			.addProperty("m_PcInfo", &PJZAKO::m_PcInfo)
			.addProperty("m_DmgInfo", &PJZAKO::m_DmgInfo)
			.addProperty("m_AiInfo", &PJZAKO::m_AiInfo)
			.addProperty("m_Counter", &PJZAKO::m_Counter)
			.addProperty("m_CheckCanHitPrevCnt", &PJZAKO::m_CheckCanHitPrevCnt)
			.addProperty("m_AddKillNumWaitCounter", &PJZAKO::m_AddKillNumWaitCounter)
			.addProperty("m_boAddedKillNum", &PJZAKO::m_boAddedKillNum)
			.addProperty("m_boMoveTurretFlag", &PJZAKO::m_boMoveTurretFlag)
			.addProperty("m_boWayPointMoveAfterPop", &PJZAKO::m_boWayPointMoveAfterPop)
			.addProperty("m_pStateMachine", &PJZAKO::m_pStateMachine)
			.addProperty("m_eNowStateIdx", &PJZAKO::m_eNowStateIdx)
			.addProperty("m_ePrevStateIdx", &PJZAKO::m_ePrevStateIdx)
			.addProperty("m_eScareType", &PJZAKO::m_eScareType)
			.addProperty("mTargetDirec", &PJZAKO::mTargetDirec)
			.addProperty("mNowDirecY", &PJZAKO::mNowDirecY)
			.addProperty("mDeadModelType", &PJZAKO::mDeadModelType)
			.addProperty("m_EfDanmen", &PJZAKO::m_EfDanmen)
			.addProperty("m_pCutMark", &PJZAKO::m_pCutMark)
			.addProperty("mpEfQuestion", &PJZAKO::mpEfQuestion)
			.addProperty("m_pMotMng", &PJZAKO::m_pMotMng)
			.addProperty("m_WayPointArry", &PJZAKO::m_WayPointArry)
			.addProperty("m_iWayPoint", &PJZAKO::m_iWayPoint)
			.addProperty("m_pPathPlanner", &PJZAKO::m_pPathPlanner)
			.addProperty("m_boUseObstacleSensor", &PJZAKO::m_boUseObstacleSensor)
			.addProperty("m_boDisableInterestIK", &PJZAKO::m_boDisableInterestIK)
			.addProperty("m_boBerserkAtk", &PJZAKO::m_boBerserkAtk)
			.addProperty("m_boRequestDeathOutOfCamera", &PJZAKO::m_boRequestDeathOutOfCamera)
			.addProperty("m_boFirstBombDeadFxPlay", &PJZAKO::m_boFirstBombDeadFxPlay)
			.addProperty("m_JumpOffTojoLandingPos", &PJZAKO::m_JumpOffTojoLandingPos)
			.addProperty("m_boFixTurret", &PJZAKO::m_boFixTurret)
			.addProperty("m_eSdnAtkPopDir", &PJZAKO::m_eSdnAtkPopDir)
			.addProperty("m_pDP", &PJZAKO::m_pDP)
			.addProperty("m_pObsSens", &PJZAKO::m_pObsSens)
			.addProperty("m_Atk2PcHitAfterCnt", &PJZAKO::m_Atk2PcHitAfterCnt)
			.addProperty("m_boPcDownLaugh", &PJZAKO::m_boPcDownLaugh)
			.addProperty("m_pBulletManager", &PJZAKO::m_pBulletManager)
			.addProperty("m_boPhysicDeadProc", &PJZAKO::m_boPhysicDeadProc)
			.addProperty("m_bIsHeadPhysicsEnd", &PJZAKO::m_bIsHeadPhysicsEnd)
			.addProperty("m_pPhysicDeadGmf", &PJZAKO::m_pPhysicDeadGmf)
			.addProperty("m_boTodomeDead", &PJZAKO::m_boTodomeDead)
			.addProperty("m_boDeadEffectReq", &PJZAKO::m_boDeadEffectReq)
			.addProperty("m_DeadEffectCountCown", &PJZAKO::m_DeadEffectCountCown)
			.addProperty("m_ParticleDeadZakoTerminateWaitTick", &PJZAKO::m_ParticleDeadZakoTerminateWaitTick)
			.addProperty("m_pBnFxDmgDat", &PJZAKO::m_pBnFxDmgDat)
			.addProperty("m_boTimeShareUpdate", &PJZAKO::m_boTimeShareUpdate)
			.addProperty("m_eTimeShareStat", &PJZAKO::m_eTimeShareStat)
			.addProperty("m_CollInfo", &PJZAKO::m_CollInfo)
			.addProperty("m_Tex", &PJZAKO::m_Tex)
			.addProperty("m_ChangeStateLimitTick", &PJZAKO::m_ChangeStateLimitTick)
			.addProperty("m_fRotSpd", &PJZAKO::m_fRotSpd)
			.addProperty("m_BreakPopCmnObjPtrList", &PJZAKO::m_BreakPopCmnObjPtrList)
			.addProperty("m_pSyncPopCmnObj", &PJZAKO::m_pSyncPopCmnObj)
			.addProperty("m_boCalledNoGuardEfOnce", &PJZAKO::m_boCalledNoGuardEfOnce)
			.addProperty("m_OutOfCameraIkakuShootTime", &PJZAKO::m_OutOfCameraIkakuShootTime)
			.addProperty("m_State_Damage", &PJZAKO::m_State_Damage)
			.addProperty("m_State_CloseForAtk", &PJZAKO::m_State_CloseForAtk)
			.addProperty("m_State_AwayAfterAtk", &PJZAKO::m_State_AwayAfterAtk)
			.addProperty("m_State_ComboAttack", &PJZAKO::m_State_ComboAttack)
			.addProperty("m_State_StepInAttack", &PJZAKO::m_State_StepInAttack)
			.addProperty("m_State_Defence", &PJZAKO::m_State_Defence)
			.addProperty("m_State_Evacuate", &PJZAKO::m_State_Evacuate)
			.addProperty("m_State_RandomMove", &PJZAKO::m_State_RandomMove)
			.addProperty("m_State_ThroughDamage", &PJZAKO::m_State_ThroughDamage)
			.addProperty("m_State_DownDamage", &PJZAKO::m_State_DownDamage)
			.addProperty("m_State_Pressure", &PJZAKO::m_State_Pressure)
			.addProperty("m_State_WayPointMove", &PJZAKO::m_State_WayPointMove)
			.addProperty("m_State_Run", &PJZAKO::m_State_Run)
			.addProperty("m_State_Kosinukasi", &PJZAKO::m_State_Kosinukasi)
			.addProperty("m_State_Yotunbai", &PJZAKO::m_State_Yotunbai)
			.addProperty("m_State_Stand", &PJZAKO::m_State_Stand)
			.addProperty("m_StatePerformIll", &PJZAKO::m_StatePerformIll)
			.addProperty("m_ReleaseWaitIdle", &PJZAKO::m_ReleaseWaitIdle)
			.addProperty("m_State_Tojo_RunAndTurnPc", &PJZAKO::m_State_Tojo_RunAndTurnPc)
			.addProperty("m_State_Tojo_AgainstWall", &PJZAKO::m_State_Tojo_AgainstWall)
			.addProperty("m_State_Tojo_LookAround", &PJZAKO::m_State_Tojo_LookAround)
			.addProperty("m_State_Tojo_Stand", &PJZAKO::m_State_Tojo_Stand)
			.addProperty("m_State_Tojo_Bench", &PJZAKO::m_State_Tojo_Bench)
			.addProperty("m_State_Tojo_Sit", &PJZAKO::m_State_Tojo_Sit)
			.addProperty("m_State_Tojo_Car", &PJZAKO::m_State_Tojo_Car)
			.addProperty("m_State_Tojo_JumpOff", &PJZAKO::m_State_Tojo_JumpOff)
			.addProperty("m_State_Tojo_BreakCmnObj", &PJZAKO::m_State_Tojo_BreakCmnObj)
			.addProperty("m_State_Tojo_AeroBike", &PJZAKO::m_State_Tojo_AeroBike)
			.addProperty("m_State_Tojo_RoomRunner", &PJZAKO::m_State_Tojo_RoomRunner)
			.addProperty("m_State_LeadPcWayPointMove", &PJZAKO::m_State_LeadPcWayPointMove)
			.addProperty("m_State_FixTurret", &PJZAKO::m_State_FixTurret)
			.addProperty("m_State_WayPointMoveAfterPop", &PJZAKO::m_State_WayPointMoveAfterPop)
			.addProperty("m_State_DownAttack", &PJZAKO::m_State_DownAttack)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetJumpOffTojoLandingPos", &PJZAKO::SetJumpOffTojoLandingPos)
			.addFunction("SetWaitReleaseIdleStateFlag", &PJZAKO::SetWaitReleaseIdleStateFlag)
			.addFunction("SetMoveTurretFlag", &PJZAKO::SetMoveTurretFlag)
			.addFunction("GetMoveTurretFlag", &PJZAKO::GetMoveTurretFlag)
			.addFunction("SetWayPointMoveAfterPopFlag", &PJZAKO::SetWayPointMoveAfterPopFlag)
			.addFunction("GetWayPointMoveAfterPopFlag", &PJZAKO::GetWayPointMoveAfterPopFlag)
			.addFunction("SetSyncPopCmnObjPtr", &PJZAKO::SetSyncPopCmnObjPtr)
			.addFunction("SetDeadEffectDelayCnt", &PJZAKO::SetDeadEffectDelayCnt)
			.addFunction("GetDownDir", &PJZAKO::GetDownDir)
			.addFunction("GetBoneScale", &PJZAKO::GetBoneScale)
			.addFunction("GetPcInfoPtr", &PJZAKO::GetPcInfoPtr)
			.addFunction("GetAiInfoPtr", &PJZAKO::GetAiInfoPtr)
			.addFunction("SetFightLine", &PJZAKO::SetFightLine)
			.addFunction("GetFightLine", &PJZAKO::GetFightLine)
			.addFunction("RequestDeadOutOfCamera", &PJZAKO::RequestDeadOutOfCamera)
			.addFunction("GetNowStateIdx", &PJZAKO::GetNowStateIdx)
			.addFunction("SetCutAiFlag", &PJZAKO::SetCutAiFlag)
			.addFunction("GetCutAiFlag", &PJZAKO::GetCutAiFlag)
			.addFunction("GetMotMngPtr", &PJZAKO::GetMotMngPtr)
			.addFunction("GetZakoInfoPtr", &PJZAKO::GetZakoInfoPtr)
			.addFunction("GetBoneMotMax", &PJZAKO::GetBoneMotMax)
			.addFunction("GetBackDist", &PJZAKO::GetBackDist)
			.addFunction("mpGetGan", &PJZAKO::mpGetGan)
			.addFunction("GetPcDist", &PJZAKO::GetPcDist)
			.addFunction("GetStepInAtkMotIdx", &PJZAKO::GetStepInAtkMotIdx)
			.addFunction("SetScareType", &PJZAKO::SetScareType)
			.addFunction("GetGetOffCarFlag", &PJZAKO::GetGetOffCarFlag)
			.addFunction("GetDownAtkMot", &PJZAKO::GetDownAtkMot)
			.addFunction("mCheckGuard", &PJZAKO::mCheckGuard)
			.addFunction("FireBullet", &PJZAKO::FireBullet)
			.addFunction("GetStatePtr", &PJZAKO::GetStatePtr)
			.addFunction("GetReactRatio", &PJZAKO::GetReactRatio)
			// Can't export & pointer 'enum eZkCarSheet&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetRideCarSheet", &PJZAKO::SetRideCarSheet)
			.addFunction("ZeroMove", &PJZAKO::ZeroMove)
			.addFunction("GetFixTurretFlag", &PJZAKO::GetFixTurretFlag)
			.addFunction("SetUseObstacleSensor", &PJZAKO::SetUseObstacleSensor)
			.addFunction("SetDisableInterestIK", &PJZAKO::SetDisableInterestIK)
			.addFunction("GetJumpOffTojoLandingPos", &PJZAKO::GetJumpOffTojoLandingPos)
			.addFunction("GetTojoInfoPtr", &PJZAKO::GetTojoInfoPtr)
			.addFunction("GetDmgInfoPtr", &PJZAKO::GetDmgInfoPtr)
			.addFunction("GetRideCarSheet", &PJZAKO::GetRideCarSheet)
			.addFunction("GetPcSideFromMe", &PJZAKO::GetPcSideFromMe)
			.addFunction("GetLeftDist", &PJZAKO::GetLeftDist)
			.addFunction("GetRightDist", &PJZAKO::GetRightDist)
			.addFunction("GetPrevStateIdx", &PJZAKO::GetPrevStateIdx)
			.addFunction("GetScareType", &PJZAKO::GetScareType)
			.addFunction("GetWaitReleaseIdleStateFlag", &PJZAKO::GetWaitReleaseIdleStateFlag)
			.addFunction("GetBreakPopCmnObjStartFlag", &PJZAKO::GetBreakPopCmnObjStartFlag)
			.addFunction("SetThinkCntReady", &PJZAKO::SetThinkCntReady)
			.addFunction("IsWayPointMoveStopping", &PJZAKO::IsWayPointMoveStopping)
			.addFunction("GetPiyoTick", &PJZAKO::GetPiyoTick)
			.addFunction("SetRotateSpeed", &PJZAKO::SetRotateSpeed)
			.addFunction("SetStompingDmgDropMoney", &PJZAKO::SetStompingDmgDropMoney)
			.addFunction("ResetStompDmgDropMoneyTime", &PJZAKO::ResetStompDmgDropMoneyTime)
			.addFunction("SetPiyoTick", &PJZAKO::SetPiyoTick)
			.addFunction("IsNoStateChangeDamage", &PJZAKO::IsNoStateChangeDamage)
			.addFunction("IsAccumDmgAttackTiming", &PJZAKO::IsAccumDmgAttackTiming)
			.addFunction("mSetMovSpd", &PJZAKO::mSetMovSpd)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("AddPos", &PJZAKO::AddPos)
			.addFunction("IsAttackHomingTiming", &PJZAKO::IsAttackHomingTiming)
			.addFunction("DeathOutOfCameraRequestProc", &PJZAKO::DeathOutOfCameraRequestProc)
			.addFunction("GetCmnObjAttackPopMotion", &PJZAKO::GetCmnObjAttackPopMotion)
			.addFunction("CheckValidWorkingStateMachine", &PJZAKO::CheckValidWorkingStateMachine)
			.addFunction("AttackAnnouncekEffectProc", &PJZAKO::AttackAnnouncekEffectProc)
			.addFunction("IsScareState", &PJZAKO::IsScareState)
			.addFunction("mSetAiAtk", &PJZAKO::mSetAiAtk)
			.addFunction("GetMotionFrame", &PJZAKO::GetMotionFrame)
			.addFunction("GetMotionTick", &PJZAKO::GetMotionTick)
			.addFunction("mSetVisible", &PJZAKO::mSetVisible)
			.addFunction("isHopeInterestMe", &PJZAKO::isHopeInterestMe)
			.addFunction("mSetSubMotionSpd", &PJZAKO::mSetSubMotionSpd)
			.addFunction("GetWakeUpReactMotionNo", &PJZAKO::GetWakeUpReactMotionNo)
			.addFunction("IsFrameBeforeCancel", &PJZAKO::IsFrameBeforeCancel)
			.addFunction("IsFrameBeforeEnd", &PJZAKO::IsFrameBeforeEnd)
			.addFunction("IsFrameBeforeHit", &PJZAKO::IsFrameBeforeHit)
			.addFunction("IsFrameBeforeTsuba", &PJZAKO::IsFrameBeforeTsuba)
			.addFunction("IsFrameCancel", &PJZAKO::IsFrameCancel)
			.addFunction("IsFrameEnd", &PJZAKO::IsFrameEnd)
			.addFunction("IsFrameHit", &PJZAKO::IsFrameHit)
			.addFunction("IsFrameTsuba", &PJZAKO::IsFrameTsuba)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("PlayNoPileOneShotSE", &PJZAKO::PlayNoPileOneShotSE)
			.addStaticFunction("ZakoNoPileSeCounterProcess", &PJZAKO::ZakoNoPileSeCounterProcess)
			.addFunction("TimeShareUpdateProc", &PJZAKO::TimeShareUpdateProc)
			.addFunction("VoiceProc", &PJZAKO::VoiceProc)
			.addFunction("mCallItemDrop", &PJZAKO::mCallItemDrop)
			.addFunction("IsWatchPc", &PJZAKO::IsWatchPc)
			.addFunction("SetGuard", &PJZAKO::SetGuard)
			.addFunction("IsThereWall", &PJZAKO::IsThereWall)
			.addFunction("EnterDieVanish", &PJZAKO::EnterDieVanish)
			.addFunction("mLoseSightProc", &PJZAKO::mLoseSightProc)
			.addFunction("mTermLoseSight", &PJZAKO::mTermLoseSight)
			.addFunction("mCreateLoseSight", &PJZAKO::mCreateLoseSight)
			.addFunction("mppGetGan", &PJZAKO::mppGetGan)
			.addFunction("mpGetGan_2", &PJZAKO::mpGetGan_2)
			.addFunction("mCheckBreakDead", &PJZAKO::mCheckBreakDead)
			.addFunction("GoToPointProc", &PJZAKO::GoToPointProc)
			.addFunction("CheckWayPointMoveStopping", &PJZAKO::CheckWayPointMoveStopping)
			.addFunction("WayPointProc", &PJZAKO::WayPointProc)
			.addFunction("SetWayPoint", &PJZAKO::SetWayPoint)
			.addFunction("getCurMotionName", &PJZAKO::getCurMotionName)
			.addFunction("mPlayMotion", &PJZAKO::mPlayMotion)
			.addFunction("IsMotionToMotionBlendState", &PJZAKO::IsMotionToMotionBlendState)
			.addFunction("SetPiyori", &PJZAKO::SetPiyori)
			.addFunction("SetEvacuate", &PJZAKO::SetEvacuate)
			.addFunction("IsAvailableEvacuateType", &PJZAKO::IsAvailableEvacuateType)
			.addFunction("GetBoneCmnMotIdx", &PJZAKO::GetBoneCmnMotIdx)
			.addFunction("SetStatStepInAttack", &PJZAKO::SetStatStepInAttack)
			.addFunction("SetStat_CharSpAtk", &PJZAKO::SetStat_CharSpAtk)
			.addFunction("SetFuzzyOptionalAttackStat", &PJZAKO::SetFuzzyOptionalAttackStat)
			.addFunction("SetTobiDoguAttackStat", &PJZAKO::SetTobiDoguAttackStat)
			.addFunction("GetIkakuShagekiTgtPos", &PJZAKO::GetIkakuShagekiTgtPos)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("CheckGunMuzzleInWall", &PJZAKO::CheckGunMuzzleInWall)
			.addFunction("IsIkakuShageki", &PJZAKO::IsIkakuShageki)
			.addFunction("IsForbiddenAttackCondition", &PJZAKO::IsForbiddenAttackCondition)
			.addFunction("SetStat_PathFindToPC", &PJZAKO::SetStat_PathFindToPC)
			.addFunction("SetStat_Close", &PJZAKO::SetStat_Close)
			.addFunction("SetStat_Pressure", &PJZAKO::SetStat_Pressure)
			.addFunction("SetExtendBackStepDist", &PJZAKO::SetExtendBackStepDist)
			.addFunction("SetStat_GetBehind", &PJZAKO::SetStat_GetBehind)
			.addFunction("mAttackHitPlaySE3D", &PJZAKO::mAttackHitPlaySE3D)
			.addFunction("PlayGuardSE3D", &PJZAKO::PlayGuardSE3D)
			.addFunction("mAttackHitRestore", &PJZAKO::mAttackHitRestore)
			.addFunction("SetRotY", &PJZAKO::SetRotY)
			.addFunction("mGetAttackParam", &PJZAKO::mGetAttackParam)
			.addFunction("mGetAttackParamEx", &PJZAKO::mGetAttackParamEx)
			.addFunction("mDieCallback", &PJZAKO::mDieCallback)
			.addFunction("IsTigerBitedDyingMotion", &PJZAKO::IsTigerBitedDyingMotion)
			.addFunction("IsBombDeadNode", &PJZAKO::IsBombDeadNode)
			.addFunction("SearchNoBombDeadNodeAndSetInVisible_Reflex", &PJZAKO::SearchNoBombDeadNodeAndSetInVisible_Reflex)
			.addFunction("SearchNoBombDeadNodeAndSetInVisible", &PJZAKO::SearchNoBombDeadNodeAndSetInVisible)
			.addFunction("mRequestSmokeDead", &PJZAKO::mRequestSmokeDead)
			.addFunction("mZakoDieOut", &PJZAKO::mZakoDieOut)
			.addFunction("mGetBodyTouchFloorTick", &PJZAKO::mGetBodyTouchFloorTick)
			.addFunction("EffectProc", &PJZAKO::EffectProc)
			.addFunction("IsContinueComboAttack", &PJZAKO::IsContinueComboAttack)
			.addFunction("IsContinueEvacuate", &PJZAKO::IsContinueEvacuate)
			.addFunction("IsEvacuateMotionFrame", &PJZAKO::IsEvacuateMotionFrame)
			.addFunction("IsInvinsibleTimingPopIdleState", &PJZAKO::IsInvinsibleTimingPopIdleState)
			.addFunction("IsPcSlashTame", &PJZAKO::IsPcSlashTame)
			.addFunction("IsPcEmmergencyEvacuation", &PJZAKO::IsPcEmmergencyEvacuation)
			.addFunction("IsPcBoldAttackFollowThrough", &PJZAKO::IsPcBoldAttackFollowThrough)
			.addFunction("IsKettou", &PJZAKO::IsKettou)
			.addFunction("IsWatchMe", &PJZAKO::IsWatchMe)
			.addFunction("IsLockOnMe", &PJZAKO::IsLockOnMe)
			.addFunction("SetKesson", &PJZAKO::SetKesson)
			.addFunction("TestKesson", &PJZAKO::TestKesson)
			.addFunction("IsParticleDead", &PJZAKO::IsParticleDead)
			.addFunction("SetDamageReactionBeforeFinishAttack", &PJZAKO::SetDamageReactionBeforeFinishAttack)
			.addFunction("mCheckCanThrow", &PJZAKO::mCheckCanThrow)
			.addFunction("mCheckCanCatch", &PJZAKO::mCheckCanCatch)
			.addFunction("mGetTsubazeriaiPos", &PJZAKO::mGetTsubazeriaiPos)
			.addFunction("mLoseTsubazeriai", &PJZAKO::mLoseTsubazeriai)
			.addFunction("mWinTsubazeriai", &PJZAKO::mWinTsubazeriai)
			.addFunction("mPlayMotTsubaszeriai", &PJZAKO::mPlayMotTsubaszeriai)
			.addFunction("mCheckTsubazeriai", &PJZAKO::mCheckTsubazeriai)
			.addFunction("mCheckIntoTsubazeriai", &PJZAKO::mCheckIntoTsubazeriai)
			.addFunction("CreateAtkPcEffect", &PJZAKO::CreateAtkPcEffect)
			.addFunction("mAttackProc", &PJZAKO::mAttackProc)
			.addFunction("IsAtkObj", &PJZAKO::IsAtkObj)
			.addFunction("mGetAtkNo", &PJZAKO::mGetAtkNo)
			.addFunction("mGetAtkNo_2", &PJZAKO::mGetAtkNo_2)
			.addFunction("mCheckCanHit", &PJZAKO::mCheckCanHit)
			.addFunction("IsGuardMot", &PJZAKO::IsGuardMot)
			.addFunction("mCheckAttack", &PJZAKO::mCheckAttack)
			.addFunction("mSetDamage_FightAttack", &PJZAKO::mSetDamage_FightAttack)
			.addFunction("mSetDamage_Stomping", &PJZAKO::mSetDamage_Stomping)
			.addFunction("mSetDamage_GuardHajikare", &PJZAKO::mSetDamage_GuardHajikare)
			.addFunction("mSetDamage_WakeUp", &PJZAKO::mSetDamage_WakeUp)
			.addFunction("mSetDamage_Through", &PJZAKO::mSetDamage_Through)
			.addFunction("IsSetDamageFromPcWakeUp", &PJZAKO::IsSetDamageFromPcWakeUp)
			.addFunction("IsSetDamageFromPcThroughAttack", &PJZAKO::IsSetDamageFromPcThroughAttack)
			.addFunction("mSetDamage_Guard", &PJZAKO::mSetDamage_Guard)
			.addFunction("AttractFriendMyDead", &PJZAKO::AttractFriendMyDead)
			.addFunction("CheckPiyoDurationAndSetStatPiyoriDamage", &PJZAKO::CheckPiyoDurationAndSetStatPiyoriDamage)
			.addFunction("SetExceptionDeadDamage", &PJZAKO::SetExceptionDeadDamage)
			.addFunction("mSetDamage_Dead", &PJZAKO::mSetDamage_Dead)
			.addFunction("mSetDamage_CutDamage", &PJZAKO::mSetDamage_CutDamage)
			.addFunction("mSetDamage_NoStateChangeDamage", &PJZAKO::mSetDamage_NoStateChangeDamage)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetDamage_DamageCounterProc", &PJZAKO::mSetDamage_DamageCounterProc)
			.addFunction("mSetDamage_InitDamageReaction", &PJZAKO::mSetDamage_InitDamageReaction)
			.addFunction("mSetDamage_ExceptionDamageProc", &PJZAKO::mSetDamage_ExceptionDamageProc)
			.addFunction("mSetDamage_Initialize", &PJZAKO::mSetDamage_Initialize)
			.addFunction("mSetDamage", &PJZAKO::mSetDamage)
			.addFunction("CheckSetDmgFuncGarbageInData", &PJZAKO::CheckSetDmgFuncGarbageInData)
			.addFunction("CheckValidWayPointArray", &PJZAKO::CheckValidWayPointArray)
			.addFunction("IsWallCrashDmgMot", &PJZAKO::IsWallCrashDmgMot)
			.addFunction("IsKessonDmgMot", &PJZAKO::IsKessonDmgMot)
			.addFunction("IsDeadlyDamage", &PJZAKO::IsDeadlyDamage)
			.addFunction("JumpNowMotTGPPos", &PJZAKO::JumpNowMotTGPPos)
			.addFunction("ConvertGrdMot", &PJZAKO::ConvertGrdMot)
			.addFunction("ConvertDmgMot", &PJZAKO::ConvertDmgMot)
			.addFunction("ConvertInAtkKindBit", &PJZAKO::ConvertInAtkKindBit)
			.addFunction("IsEnableEvacuate", &PJZAKO::IsEnableEvacuate)
			.addFunction("IsEnableCrashWall", &PJZAKO::IsEnableCrashWall)
			.addFunction("IsEnableGuard", &PJZAKO::IsEnableGuard)
			.addFunction("IsEnableGuardByGrdCnt", &PJZAKO::IsEnableGuardByGrdCnt)
			.addFunction("IsPcDagekiAttack", &PJZAKO::IsPcDagekiAttack)
			.addFunction("IsPcStompingAttack", &PJZAKO::IsPcStompingAttack)
			.addFunction("IsGuardHajikareDamage", &PJZAKO::IsGuardHajikareDamage)
			.addFunction("IsGetBehindTypeZako", &PJZAKO::IsGetBehindTypeZako)
			.addFunction("IsNoGuardTypeZako", &PJZAKO::IsNoGuardTypeZako)
			.addFunction("IsEnableDownAttackTypeZako", &PJZAKO::IsEnableDownAttackTypeZako)
			.addFunction("IsFrontPc", &PJZAKO::IsFrontPc)
			.addFunction("IsBehindPc", &PJZAKO::IsBehindPc)
			.addFunction("IsAttackState", &PJZAKO::IsAttackState)
			.addFunction("IsThinkCntZero", &PJZAKO::IsThinkCntZero)
			.addFunction("IsFuzzyThinkCntZero", &PJZAKO::IsFuzzyThinkCntZero)
			.addFunction("ResetChangeStateLimitTick", &PJZAKO::ResetChangeStateLimitTick)
			.addFunction("IsFrameRun", &PJZAKO::IsFrameRun)
			.addFunction("SetRotation", &PJZAKO::SetRotation)
			.addFunction("SetRotatePc", &PJZAKO::SetRotatePc)
			.addFunction("SetChanceAttackCounter", &PJZAKO::SetChanceAttackCounter)
			.addFunction("mSetCondition", &PJZAKO::mSetCondition)
			.addFunction("SubEvacuateCnt", &PJZAKO::SubEvacuateCnt)
			.addFunction("ResetEvacuateCnt", &PJZAKO::ResetEvacuateCnt)
			.addFunction("ResetDagekiCounterCnt", &PJZAKO::ResetDagekiCounterCnt)
			.addFunction("ResetPiyoriDurCnt", &PJZAKO::ResetPiyoriDurCnt)
			.addFunction("ResetFuttobiDurCnt", &PJZAKO::ResetFuttobiDurCnt)
			.addFunction("ResetAttackCnt", &PJZAKO::ResetAttackCnt)
			.addFunction("SetTateTimingAttack", &PJZAKO::SetTateTimingAttack)
			.addFunction("ResetPressureCnt", &PJZAKO::ResetPressureCnt)
			.addFunction("ResetGuardStiff", &PJZAKO::ResetGuardStiff)
			.addFunction("ResetGuardCnt", &PJZAKO::ResetGuardCnt)
			.addFunction("GetComboAtkMotID", &PJZAKO::GetComboAtkMotID)
			.addFunction("SetComboAtkTable_HereAttack", &PJZAKO::SetComboAtkTable_HereAttack)
			.addFunction("SetGetOffCarFlag", &PJZAKO::SetGetOffCarFlag)
			.addFunction("IsDefensive", &PJZAKO::IsDefensive)
			.addFunction("IsOffensive", &PJZAKO::IsOffensive)
			.addFunction("DebugRender", &PJZAKO::DebugRender)
			.addFunction("DBG_Render_PathFind", &PJZAKO::DBG_Render_PathFind)
			.addFunction("mPostRenderProc", &PJZAKO::mPostRenderProc)
			.addFunction("mRenderProc", &PJZAKO::mRenderProc)
			.addFunction("GetEvacuateReactFrame", &PJZAKO::GetEvacuateReactFrame)
			.addFunction("IsPcAttackRangeAndAngle", &PJZAKO::IsPcAttackRangeAndAngle)
			.addFunction("GetMaaiDist", &PJZAKO::GetMaaiDist)
			.addFunction("GetDownContinueFrm", &PJZAKO::GetDownContinueFrm)
			.addFunction("CheckInvalidChangeState", &PJZAKO::CheckInvalidChangeState)
			.addFunction("StatusUpdate", &PJZAKO::StatusUpdate)
			.addFunction("UpdateZakoState", &PJZAKO::UpdateZakoState)
			.addFunction("UpdateLookIK", &PJZAKO::UpdateLookIK)
			.addFunction("UpdatePcState", &PJZAKO::UpdatePcState)
			.addFunction("UpdateAtkColl", &PJZAKO::UpdateAtkColl)
			.addFunction("DebugModeProc", &PJZAKO::DebugModeProc)
			.addFunction("ApplyDP", &PJZAKO::ApplyDP)
			.addFunction("MoveProc", &PJZAKO::MoveProc)
			.addFunction("ExitUnderControl", &PJZAKO::ExitUnderControl)
			.addFunction("EnterUnderControl", &PJZAKO::EnterUnderControl)
			.addFunction("UnderControllAttack_A", &PJZAKO::UnderControllAttack_A)
			.addFunction("UnderControllComboAttack", &PJZAKO::UnderControllComboAttack)
			.addFunction("ControlZakoProc", &PJZAKO::ControlZakoProc)
			.addFunction("ComboAttack", &PJZAKO::ComboAttack)
			.addFunction("TestProc", &PJZAKO::TestProc)
			.addFunction("AIProc", &PJZAKO::AIProc)
			.addFunction("FightSpiritStatProc", &PJZAKO::FightSpiritStatProc)
			.addFunction("PreAIProc", &PJZAKO::PreAIProc)
			.addFunction("GetFrame", &PJZAKO::GetFrame)
			.addFunction("GetPerformIllMotionNo", &PJZAKO::GetPerformIllMotionNo)
			.addFunction("PhysicDeadModelRender", &PJZAKO::PhysicDeadModelRender)
			.addFunction("PhysicDeadModelProcess", &PJZAKO::PhysicDeadModelProcess)
			.addFunction("PhysicDeadModelTerminate", &PJZAKO::PhysicDeadModelTerminate)
			.addFunction("PhysicDeadModelCreate", &PJZAKO::PhysicDeadModelCreate)
			.addFunction("mPostFrameCommonProc2", &PJZAKO::mPostFrameCommonProc2)
			.addFunction("mRequestBloodSplash", &PJZAKO::mRequestBloodSplash)
			.addFunction("DeadEffectProc", &PJZAKO::DeadEffectProc)
			.addFunction("CallDamageScriptCallBack", &PJZAKO::CallDamageScriptCallBack)
			.addFunction("mPostFrameProc", &PJZAKO::mPostFrameProc)
			.addFunction("mFrameProc", &PJZAKO::mFrameProc)
			.addFunction("AvoidFriendProc", &PJZAKO::AvoidFriendProc)
			.addFunction("ClearUpperPow", &PJZAKO::ClearUpperPow)
			.addFunction("InitWepEffect", &PJZAKO::InitWepEffect)
			.addFunction("InitWeapon", &PJZAKO::InitWeapon)
			.addFunction("InitMotion", &PJZAKO::InitMotion)
			.addFunction("GetVariationTextureName", &PJZAKO::GetVariationTextureName)
			.addFunction("InitModel", &PJZAKO::InitModel)
			.addFunction("mInit", &PJZAKO::mInit)
			.addFunction("InitExZako", &PJZAKO::InitExZako)
			.addFunction("InitStateMachine", &PJZAKO::InitStateMachine)
			.addFunction("SetStateIdx", &PJZAKO::SetStateIdx)
			.addFunction("mTerm", &PJZAKO::mTerm)
			.addStaticFunction("StaticProc", &PJZAKO::StaticProc)
			.addFunction("IsEnableForceChangeState", &PJZAKO::IsEnableForceChangeState)
			.addFunction("IsSafetyChangeStateTiming", &PJZAKO::IsSafetyChangeStateTiming)
			.addFunction("ChangeState", &PJZAKO::ChangeState)
			.addFunction("IsPopIdleState", &PJZAKO::IsPopIdleState)
			.addStaticFunction("SetRequestPopedZakoDeathOutOfCameraByNpcID", &PJZAKO::SetRequestPopedZakoDeathOutOfCameraByNpcID)
			.addFunction("PlayVoice", &PJZAKO::PlayVoice)
			.addFunction("IsDownMotion", &PJZAKO::IsDownMotion)
			.addFunction("IsUchiagerareDmgMot", &PJZAKO::IsUchiagerareDmgMot)
			.addFunction("IsThrowDmgMot", &PJZAKO::IsThrowDmgMot)
			.addFunction("InitPop", &PJZAKO::InitPop)
			.addFunction("RegistSyncAppearStgCmnObj", &PJZAKO::RegistSyncAppearStgCmnObj)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetStat_WayPoint", &PJZAKO::SetStat_WayPoint)
			.addFunction("ClearWayPoint", &PJZAKO::ClearWayPoint)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("AddWayPoint", &PJZAKO::AddWayPoint)
			.addFunction("AddRequestBreakPopCmnObj", &PJZAKO::AddRequestBreakPopCmnObj)
			.addFunction("SetBreakPopCmnObjStartFlag", &PJZAKO::SetBreakPopCmnObjStartFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKO::m_StatePtrArr) == 240, "expected PJZAKO::m_StatePtrArr to be size 240");
static_assert(sizeof(PJZAKO::m_BoneScale) == 4, "expected PJZAKO::m_BoneScale to be size 4");
static_assert(sizeof(PJZAKO::m_SetDamageInfo) == 4, "expected PJZAKO::m_SetDamageInfo to be size 4");
static_assert(sizeof(PJZAKO::m_ZakoInfo) == 148, "expected PJZAKO::m_ZakoInfo to be size 148");
static_assert(sizeof(PJZAKO::m_MotionInfo) == 16, "expected PJZAKO::m_MotionInfo to be size 16");
static_assert(sizeof(PJZAKO::m_TojoInfo) == 20, "expected PJZAKO::m_TojoInfo to be size 20");
static_assert(sizeof(PJZAKO::m_PcInfo) == 64, "expected PJZAKO::m_PcInfo to be size 64");
static_assert(sizeof(PJZAKO::m_DmgInfo) == 68, "expected PJZAKO::m_DmgInfo to be size 68");
static_assert(sizeof(PJZAKO::m_AiInfo) == 76, "expected PJZAKO::m_AiInfo to be size 76");
static_assert(sizeof(PJZAKO::m_Counter) == 4, "expected PJZAKO::m_Counter to be size 4");
static_assert(sizeof(PJZAKO::m_CheckCanHitPrevCnt) == 4, "expected PJZAKO::m_CheckCanHitPrevCnt to be size 4");
static_assert(sizeof(PJZAKO::m_AddKillNumWaitCounter) == 4, "expected PJZAKO::m_AddKillNumWaitCounter to be size 4");
static_assert(sizeof(PJZAKO::m_boAddedKillNum) == 1, "expected PJZAKO::m_boAddedKillNum to be size 1");
static_assert(sizeof(PJZAKO::m_boMoveTurretFlag) == 1, "expected PJZAKO::m_boMoveTurretFlag to be size 1");
static_assert(sizeof(PJZAKO::m_boWayPointMoveAfterPop) == 1, "expected PJZAKO::m_boWayPointMoveAfterPop to be size 1");
static_assert(sizeof(PJZAKO::m_pStateMachine) == 4, "expected PJZAKO::m_pStateMachine to be size 4");
static_assert(sizeof(PJZAKO::m_eNowStateIdx) == 4, "expected PJZAKO::m_eNowStateIdx to be size 4");
static_assert(sizeof(PJZAKO::m_ePrevStateIdx) == 4, "expected PJZAKO::m_ePrevStateIdx to be size 4");
static_assert(sizeof(PJZAKO::m_eScareType) == 4, "expected PJZAKO::m_eScareType to be size 4");
static_assert(sizeof(PJZAKO::mTargetDirec) == 4, "expected PJZAKO::mTargetDirec to be size 4");
static_assert(sizeof(PJZAKO::mNowDirecY) == 4, "expected PJZAKO::mNowDirecY to be size 4");
static_assert(sizeof(PJZAKO::mDeadModelType) == 4, "expected PJZAKO::mDeadModelType to be size 4");
static_assert(sizeof(PJZAKO::m_EfDanmen) == 12, "expected PJZAKO::m_EfDanmen to be size 12");
static_assert(sizeof(PJZAKO::m_pCutMark) == 4, "expected PJZAKO::m_pCutMark to be size 4");
static_assert(sizeof(PJZAKO::mpEfQuestion) == 4, "expected PJZAKO::mpEfQuestion to be size 4");
static_assert(sizeof(PJZAKO::m_pMotMng) == 4, "expected PJZAKO::m_pMotMng to be size 4");
static_assert(sizeof(PJZAKO::m_WayPointArry) == 20, "expected PJZAKO::m_WayPointArry to be size 20");
static_assert(sizeof(PJZAKO::m_iWayPoint) == 4, "expected PJZAKO::m_iWayPoint to be size 4");
static_assert(sizeof(PJZAKO::m_pPathPlanner) == 4, "expected PJZAKO::m_pPathPlanner to be size 4");
static_assert(sizeof(PJZAKO::m_boUseObstacleSensor) == 1, "expected PJZAKO::m_boUseObstacleSensor to be size 1");
static_assert(sizeof(PJZAKO::m_boDisableInterestIK) == 1, "expected PJZAKO::m_boDisableInterestIK to be size 1");
static_assert(sizeof(PJZAKO::m_boBerserkAtk) == 1, "expected PJZAKO::m_boBerserkAtk to be size 1");
static_assert(sizeof(PJZAKO::m_boRequestDeathOutOfCamera) == 1, "expected PJZAKO::m_boRequestDeathOutOfCamera to be size 1");
static_assert(sizeof(PJZAKO::m_boFirstBombDeadFxPlay) == 1, "expected PJZAKO::m_boFirstBombDeadFxPlay to be size 1");
static_assert(sizeof(PJZAKO::m_JumpOffTojoLandingPos) == 12, "expected PJZAKO::m_JumpOffTojoLandingPos to be size 12");
static_assert(sizeof(PJZAKO::m_boFixTurret) == 1, "expected PJZAKO::m_boFixTurret to be size 1");
static_assert(sizeof(PJZAKO::m_eSdnAtkPopDir) == 4, "expected PJZAKO::m_eSdnAtkPopDir to be size 4");
static_assert(sizeof(PJZAKO::m_pDP) == 4, "expected PJZAKO::m_pDP to be size 4");
static_assert(sizeof(PJZAKO::m_pObsSens) == 4, "expected PJZAKO::m_pObsSens to be size 4");
static_assert(sizeof(PJZAKO::m_Atk2PcHitAfterCnt) == 4, "expected PJZAKO::m_Atk2PcHitAfterCnt to be size 4");
static_assert(sizeof(PJZAKO::m_boPcDownLaugh) == 1, "expected PJZAKO::m_boPcDownLaugh to be size 1");
static_assert(sizeof(PJZAKO::m_pBulletManager) == 4, "expected PJZAKO::m_pBulletManager to be size 4");
static_assert(sizeof(PJZAKO::m_boPhysicDeadProc) == 1, "expected PJZAKO::m_boPhysicDeadProc to be size 1");
static_assert(sizeof(PJZAKO::m_bIsHeadPhysicsEnd) == 1, "expected PJZAKO::m_bIsHeadPhysicsEnd to be size 1");
static_assert(sizeof(PJZAKO::m_pPhysicDeadGmf) == 4, "expected PJZAKO::m_pPhysicDeadGmf to be size 4");
static_assert(sizeof(PJZAKO::m_boTodomeDead) == 1, "expected PJZAKO::m_boTodomeDead to be size 1");
static_assert(sizeof(PJZAKO::m_boDeadEffectReq) == 1, "expected PJZAKO::m_boDeadEffectReq to be size 1");
static_assert(sizeof(PJZAKO::m_DeadEffectCountCown) == 4, "expected PJZAKO::m_DeadEffectCountCown to be size 4");
static_assert(sizeof(PJZAKO::m_ParticleDeadZakoTerminateWaitTick) == 4, "expected PJZAKO::m_ParticleDeadZakoTerminateWaitTick to be size 4");
static_assert(sizeof(PJZAKO::m_pBnFxDmgDat) == 4, "expected PJZAKO::m_pBnFxDmgDat to be size 4");
static_assert(sizeof(PJZAKO::m_boTimeShareUpdate) == 1, "expected PJZAKO::m_boTimeShareUpdate to be size 1");
static_assert(sizeof(PJZAKO::m_eTimeShareStat) == 4, "expected PJZAKO::m_eTimeShareStat to be size 4");
static_assert(sizeof(PJZAKO::m_CollInfo) == 12, "expected PJZAKO::m_CollInfo to be size 12");
static_assert(sizeof(PJZAKO::m_Tex) == 40, "expected PJZAKO::m_Tex to be size 40");
static_assert(sizeof(PJZAKO::m_ChangeStateLimitTick) == 4, "expected PJZAKO::m_ChangeStateLimitTick to be size 4");
static_assert(sizeof(PJZAKO::m_fRotSpd) == 4, "expected PJZAKO::m_fRotSpd to be size 4");
static_assert(sizeof(PJZAKO::m_BreakPopCmnObjPtrList) == 12, "expected PJZAKO::m_BreakPopCmnObjPtrList to be size 12");
static_assert(sizeof(PJZAKO::m_pSyncPopCmnObj) == 4, "expected PJZAKO::m_pSyncPopCmnObj to be size 4");
static_assert(sizeof(PJZAKO::m_boCalledNoGuardEfOnce) == 1, "expected PJZAKO::m_boCalledNoGuardEfOnce to be size 1");
static_assert(sizeof(PJZAKO::m_OutOfCameraIkakuShootTime) == 4, "expected PJZAKO::m_OutOfCameraIkakuShootTime to be size 4");
static_assert(sizeof(PJZAKO::m_State_Damage) == 12, "expected PJZAKO::m_State_Damage to be size 12");
static_assert(sizeof(PJZAKO::m_State_CloseForAtk) == 4, "expected PJZAKO::m_State_CloseForAtk to be size 4");
static_assert(sizeof(PJZAKO::m_State_AwayAfterAtk) == 4, "expected PJZAKO::m_State_AwayAfterAtk to be size 4");
static_assert(sizeof(PJZAKO::m_State_ComboAttack) == 12, "expected PJZAKO::m_State_ComboAttack to be size 12");
static_assert(sizeof(PJZAKO::m_State_StepInAttack) == 4, "expected PJZAKO::m_State_StepInAttack to be size 4");
static_assert(sizeof(PJZAKO::m_State_Defence) == 8, "expected PJZAKO::m_State_Defence to be size 8");
static_assert(sizeof(PJZAKO::m_State_Evacuate) == 8, "expected PJZAKO::m_State_Evacuate to be size 8");
static_assert(sizeof(PJZAKO::m_State_RandomMove) == 8, "expected PJZAKO::m_State_RandomMove to be size 8");
static_assert(sizeof(PJZAKO::m_State_ThroughDamage) == 8, "expected PJZAKO::m_State_ThroughDamage to be size 8");
static_assert(sizeof(PJZAKO::m_State_DownDamage) == 4, "expected PJZAKO::m_State_DownDamage to be size 4");
static_assert(sizeof(PJZAKO::m_State_Pressure) == 12, "expected PJZAKO::m_State_Pressure to be size 12");
static_assert(sizeof(PJZAKO::m_State_WayPointMove) == 8, "expected PJZAKO::m_State_WayPointMove to be size 8");
static_assert(sizeof(PJZAKO::m_State_Run) == 8, "expected PJZAKO::m_State_Run to be size 8");
static_assert(sizeof(PJZAKO::m_State_Kosinukasi) == 8, "expected PJZAKO::m_State_Kosinukasi to be size 8");
static_assert(sizeof(PJZAKO::m_State_Yotunbai) == 8, "expected PJZAKO::m_State_Yotunbai to be size 8");
static_assert(sizeof(PJZAKO::m_State_Stand) == 8, "expected PJZAKO::m_State_Stand to be size 8");
static_assert(sizeof(PJZAKO::m_StatePerformIll) == 8, "expected PJZAKO::m_StatePerformIll to be size 8");
static_assert(sizeof(PJZAKO::m_ReleaseWaitIdle) == 4, "expected PJZAKO::m_ReleaseWaitIdle to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_RunAndTurnPc) == 4, "expected PJZAKO::m_State_Tojo_RunAndTurnPc to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_AgainstWall) == 4, "expected PJZAKO::m_State_Tojo_AgainstWall to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_LookAround) == 4, "expected PJZAKO::m_State_Tojo_LookAround to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Stand) == 4, "expected PJZAKO::m_State_Tojo_Stand to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Bench) == 4, "expected PJZAKO::m_State_Tojo_Bench to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Sit) == 4, "expected PJZAKO::m_State_Tojo_Sit to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Car) == 8, "expected PJZAKO::m_State_Tojo_Car to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_JumpOff) == 8, "expected PJZAKO::m_State_Tojo_JumpOff to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_BreakCmnObj) == 12, "expected PJZAKO::m_State_Tojo_BreakCmnObj to be size 12");
static_assert(sizeof(PJZAKO::m_State_Tojo_AeroBike) == 8, "expected PJZAKO::m_State_Tojo_AeroBike to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_RoomRunner) == 8, "expected PJZAKO::m_State_Tojo_RoomRunner to be size 8");
static_assert(sizeof(PJZAKO::m_State_LeadPcWayPointMove) == 4, "expected PJZAKO::m_State_LeadPcWayPointMove to be size 4");
static_assert(sizeof(PJZAKO::m_State_FixTurret) == 4, "expected PJZAKO::m_State_FixTurret to be size 4");
static_assert(sizeof(PJZAKO::m_State_WayPointMoveAfterPop) == 4, "expected PJZAKO::m_State_WayPointMoveAfterPop to be size 4");
static_assert(sizeof(PJZAKO::m_State_DownAttack) == 8, "expected PJZAKO::m_State_DownAttack to be size 8");
static_assert(sizeof(PJZAKO) == 0x9e4, "expected PJZAKO to be size 0x9e4");

// [Structure] class WGcl
class WGcl : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <int32_t mState, offset 0x10>
	int32_t mState = 0;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag = 0;

	// <struct WGclSpec* mpSpec, offset 0x18>
	struct WGclSpec* mpSpec = nullptr;

	// <class ghmGcColl* mpEntryColl, offset 0x1c>
	class ghmGcColl* mpEntryColl = nullptr;

	// <class WGclNode* mpTopNode, offset 0x20>
	class WGclNode* mpTopNode = nullptr;

	// <struct Vec mRootPosition, offset 0x24>
	struct Vec mRootPosition;

	// <struct Vec mRootRotation, offset 0x30>
	struct Vec mRootRotation;

	// <float mRootMatrix[0x3][0x4], offset 0x3c>
	float mRootMatrix[3][4];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class WGcl [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGcl& InObject)
	{
		mState = InObject.mState;
		mFlag = InObject.mFlag;
		mpSpec = InObject.mpSpec;
		mpEntryColl = InObject.mpEntryColl;
		mpTopNode = InObject.mpTopNode;
		mRootPosition = InObject.mRootPosition;
		mRootRotation = InObject.mRootRotation;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<WGcl, ghmListObj>("WGcl")
			.addFunction("__tostring", &WGcl::ToString)
			.addFunction("GetPtrAddr", &WGcl::GetPtrAddr)
			.addProperty("mState", &WGcl::mState)
			.addProperty("mFlag", &WGcl::mFlag)
			.addProperty("mpSpec", &WGcl::mpSpec)
			.addProperty("mpEntryColl", &WGcl::mpEntryColl)
			.addProperty("mpTopNode", &WGcl::mpTopNode)
			.addProperty("mRootPosition", &WGcl::mRootPosition)
			.addProperty("mRootRotation", &WGcl::mRootRotation)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mRootMatrix", &WGcl::mRootMatrix)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGcl::mState) == 4, "expected WGcl::mState to be size 4");
static_assert(sizeof(WGcl::mFlag) == 4, "expected WGcl::mFlag to be size 4");
static_assert(sizeof(WGcl::mpSpec) == 4, "expected WGcl::mpSpec to be size 4");
static_assert(sizeof(WGcl::mpEntryColl) == 4, "expected WGcl::mpEntryColl to be size 4");
static_assert(sizeof(WGcl::mpTopNode) == 4, "expected WGcl::mpTopNode to be size 4");
static_assert(sizeof(WGcl::mRootPosition) == 12, "expected WGcl::mRootPosition to be size 12");
static_assert(sizeof(WGcl::mRootRotation) == 12, "expected WGcl::mRootRotation to be size 12");
static_assert(sizeof(WGcl::mRootMatrix) == 48, "expected WGcl::mRootMatrix to be size 48");
static_assert(sizeof(WGcl) == 0x6c, "expected WGcl to be size 0x6c");

// [Structure] class commonObj
class commonObj : public mHRChara
{
public:
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <uint8_t mCallMotionProcFlag, offset 0x580>
	uint8_t mCallMotionProcFlag = 0;

	// <Unidentified data segment, offset 0x581>
private:
	char _UnidentifiedData_1409[3];

public:
	// <class WGcl mGcl, offset 0x584>
	class WGcl mGcl;

	// <uint8_t m_bIsGclExist, offset 0x5f0>
	uint8_t m_bIsGclExist = 0;

	// <uint8_t m_bIsUseGcl, offset 0x5f1>
	uint8_t m_bIsUseGcl = 0;

	// <uint8_t m_bActFadeInOut, offset 0x5f2>
	uint8_t m_bActFadeInOut = 0;

	// <uint8_t m_bIsNotRequestDelete, offset 0x5f3>
	uint8_t m_bIsNotRequestDelete = 0;

	// <class CTimeRatioInterpolate m_inFadeInOutAlpha, offset 0x5f4>
	class CTimeRatioInterpolate m_inFadeInOutAlpha;

	// <uint8_t m_bActVisibleFade, offset 0x600>
	uint8_t m_bActVisibleFade = 0;

	// <Unidentified data segment, offset 0x601>
private:
	char _UnidentifiedData_1537[3];

public:
	// <float m_FadeDist, offset 0x604>
	float m_FadeDist = 0;

	// <int32_t m_eRigidMaterialID, offset 0x608>
	int32_t m_eRigidMaterialID = 0;

	// <uint8_t m_bActDeleteByDestroy, offset 0x60c>
	uint8_t m_bActDeleteByDestroy = 0;

	// <uint8_t m_bIsNeedSetupMatrix, offset 0x60d>
	uint8_t m_bIsNeedSetupMatrix = 0;

	// <Unidentified data segment, offset 0x60e>
private:
	char _UnidentifiedData_1550[2];

public:
	// <float m_fDestroyTimer, offset 0x610>
	float m_fDestroyTimer = 0;

	// <uint8_t m_bIsDestroyMotLoop, offset 0x614>
	uint8_t m_bIsDestroyMotLoop = 0;

	// <uint8_t m_bIsMiniDemoDamage, offset 0x615>
	uint8_t m_bIsMiniDemoDamage = 0;

	// <Unidentified data segment, offset 0x616>
private:
	char _UnidentifiedData_1558[2];

public:
	// <float m_fDamagePower, offset 0x618>
	float m_fDamagePower = 0;

	// <float m_fDamageYaw, offset 0x61c>
	float m_fDamageYaw = 0;

	// <float m_fDamagePitch, offset 0x620>
	float m_fDamagePitch = 0;

	// <uint8_t m_bIsSpreadBreak, offset 0x624>
	uint8_t m_bIsSpreadBreak = 0;

	// <Unidentified data segment, offset 0x625>
private:
	char _UnidentifiedData_1573[3];

public:
	// <struct Vec m_inSpreadBreakSrcPosiOfst, offset 0x628>
	struct Vec m_inSpreadBreakSrcPosiOfst;

	// <uint8_t m_bIsSetGroundColPlane, offset 0x634>
	uint8_t m_bIsSetGroundColPlane = 0;

	// <Unidentified data segment, offset 0x635>
private:
	char _UnidentifiedData_1589[3];

public:
	// <class ghmPlane m_inGroundColPlane, offset 0x638>
	class ghmPlane m_inGroundColPlane;

	// <uint8_t mbDistEraseDisable, offset 0x648>
	uint8_t mbDistEraseDisable = 0;

	// <Unidentified data segment, offset 0x649>
private:
	char _UnidentifiedData_1609[3];

public:
	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") commonObj::mSetDamage(class commonObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@commonObj@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_commonObj__UAE_NMHHHMHMMPAVmHRChara___Z)(class commonObj* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_commonObj__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_commonObj__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x3f1e50);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") commonObj::mSetDamage(class commonObj* const this, float InDmg, int32_t InDmgMot, int32_t InGrdMot, int32_t InAtkMot, float InNockBackDst, int32_t InAtkKind, float InAtkRotY, float InTamePow, class mHRChara* Attacker, float RotX) [?mSetDamage@commonObj@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	typedef uint8_t(__thiscall* _mSetDamage_commonObj__UAE_NMHHHMHMMPAVmHRChara__M_Z_2)(class commonObj* const thisPtr, float InDmg, int32_t InDmgMot, int32_t InGrdMot, int32_t InAtkMot, float InNockBackDst, int32_t InAtkKind, float InAtkRotY, float InTamePow, class mHRChara* Attacker, float RotX);
	uint8_t mSetDamage_2(float InDmg, int32_t InDmgMot, int32_t InGrdMot, int32_t InAtkMot, float InNockBackDst, int32_t InAtkKind, float InAtkRotY, float InTamePow, class mHRChara* Attacker, float RotX)
	{
		_mSetDamage_commonObj__UAE_NMHHHMHMMPAVmHRChara__M_Z_2 mFunc = (_mSetDamage_commonObj__UAE_NMHHHMHMMPAVmHRChara__M_Z_2)(GameModule + 0x3f1eb0);
		return mFunc(this, InDmg, InDmgMot, InGrdMot, InAtkMot, InNockBackDst, InAtkKind, InAtkRotY, InTamePow, Attacker, RotX);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class commonObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(commonObj& InObject)
	{
		mCallMotionProcFlag = InObject.mCallMotionProcFlag;
		mGcl = InObject.mGcl;
		m_bIsGclExist = InObject.m_bIsGclExist;
		m_bIsUseGcl = InObject.m_bIsUseGcl;
		m_bActFadeInOut = InObject.m_bActFadeInOut;
		m_bIsNotRequestDelete = InObject.m_bIsNotRequestDelete;
		m_inFadeInOutAlpha = InObject.m_inFadeInOutAlpha;
		m_bActVisibleFade = InObject.m_bActVisibleFade;
		m_FadeDist = InObject.m_FadeDist;
		m_eRigidMaterialID = InObject.m_eRigidMaterialID;
		m_bActDeleteByDestroy = InObject.m_bActDeleteByDestroy;
		m_bIsNeedSetupMatrix = InObject.m_bIsNeedSetupMatrix;
		m_fDestroyTimer = InObject.m_fDestroyTimer;
		m_bIsDestroyMotLoop = InObject.m_bIsDestroyMotLoop;
		m_bIsMiniDemoDamage = InObject.m_bIsMiniDemoDamage;
		m_fDamagePower = InObject.m_fDamagePower;
		m_fDamageYaw = InObject.m_fDamageYaw;
		m_fDamagePitch = InObject.m_fDamagePitch;
		m_bIsSpreadBreak = InObject.m_bIsSpreadBreak;
		m_inSpreadBreakSrcPosiOfst = InObject.m_inSpreadBreakSrcPosiOfst;
		m_bIsSetGroundColPlane = InObject.m_bIsSetGroundColPlane;
		m_inGroundColPlane = InObject.m_inGroundColPlane;
		mbDistEraseDisable = InObject.mbDistEraseDisable;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<commonObj, mHRChara>("commonObj")
			.addFunction("__tostring", &commonObj::ToString)
			.addFunction("GetPtrAddr", &commonObj::GetPtrAddr)
			.addProperty("mCallMotionProcFlag", &commonObj::mCallMotionProcFlag)
			.addProperty("mGcl", &commonObj::mGcl)
			.addProperty("m_bIsGclExist", &commonObj::m_bIsGclExist)
			.addProperty("m_bIsUseGcl", &commonObj::m_bIsUseGcl)
			.addProperty("m_bActFadeInOut", &commonObj::m_bActFadeInOut)
			.addProperty("m_bIsNotRequestDelete", &commonObj::m_bIsNotRequestDelete)
			.addProperty("m_inFadeInOutAlpha", &commonObj::m_inFadeInOutAlpha)
			.addProperty("m_bActVisibleFade", &commonObj::m_bActVisibleFade)
			.addProperty("m_FadeDist", &commonObj::m_FadeDist)
			.addProperty("m_eRigidMaterialID", &commonObj::m_eRigidMaterialID)
			.addProperty("m_bActDeleteByDestroy", &commonObj::m_bActDeleteByDestroy)
			.addProperty("m_bIsNeedSetupMatrix", &commonObj::m_bIsNeedSetupMatrix)
			.addProperty("m_fDestroyTimer", &commonObj::m_fDestroyTimer)
			.addProperty("m_bIsDestroyMotLoop", &commonObj::m_bIsDestroyMotLoop)
			.addProperty("m_bIsMiniDemoDamage", &commonObj::m_bIsMiniDemoDamage)
			.addProperty("m_fDamagePower", &commonObj::m_fDamagePower)
			.addProperty("m_fDamageYaw", &commonObj::m_fDamageYaw)
			.addProperty("m_fDamagePitch", &commonObj::m_fDamagePitch)
			.addProperty("m_bIsSpreadBreak", &commonObj::m_bIsSpreadBreak)
			.addProperty("m_inSpreadBreakSrcPosiOfst", &commonObj::m_inSpreadBreakSrcPosiOfst)
			.addProperty("m_bIsSetGroundColPlane", &commonObj::m_bIsSetGroundColPlane)
			.addProperty("m_inGroundColPlane", &commonObj::m_inGroundColPlane)
			.addProperty("mbDistEraseDisable", &commonObj::mbDistEraseDisable)
			.addFunction("mSetDamage", &commonObj::mSetDamage)
			.addFunction("mSetDamage_2", &commonObj::mSetDamage_2)
		.endClass();
	}
#endif
};
static_assert(sizeof(commonObj::mCallMotionProcFlag) == 1, "expected commonObj::mCallMotionProcFlag to be size 1");
static_assert(sizeof(commonObj::mGcl) == 108, "expected commonObj::mGcl to be size 108");
static_assert(sizeof(commonObj::m_bIsGclExist) == 1, "expected commonObj::m_bIsGclExist to be size 1");
static_assert(sizeof(commonObj::m_bIsUseGcl) == 1, "expected commonObj::m_bIsUseGcl to be size 1");
static_assert(sizeof(commonObj::m_bActFadeInOut) == 1, "expected commonObj::m_bActFadeInOut to be size 1");
static_assert(sizeof(commonObj::m_bIsNotRequestDelete) == 1, "expected commonObj::m_bIsNotRequestDelete to be size 1");
static_assert(sizeof(commonObj::m_inFadeInOutAlpha) == 12, "expected commonObj::m_inFadeInOutAlpha to be size 12");
static_assert(sizeof(commonObj::m_bActVisibleFade) == 1, "expected commonObj::m_bActVisibleFade to be size 1");
static_assert(sizeof(commonObj::m_FadeDist) == 4, "expected commonObj::m_FadeDist to be size 4");
static_assert(sizeof(commonObj::m_eRigidMaterialID) == 4, "expected commonObj::m_eRigidMaterialID to be size 4");
static_assert(sizeof(commonObj::m_bActDeleteByDestroy) == 1, "expected commonObj::m_bActDeleteByDestroy to be size 1");
static_assert(sizeof(commonObj::m_bIsNeedSetupMatrix) == 1, "expected commonObj::m_bIsNeedSetupMatrix to be size 1");
static_assert(sizeof(commonObj::m_fDestroyTimer) == 4, "expected commonObj::m_fDestroyTimer to be size 4");
static_assert(sizeof(commonObj::m_bIsDestroyMotLoop) == 1, "expected commonObj::m_bIsDestroyMotLoop to be size 1");
static_assert(sizeof(commonObj::m_bIsMiniDemoDamage) == 1, "expected commonObj::m_bIsMiniDemoDamage to be size 1");
static_assert(sizeof(commonObj::m_fDamagePower) == 4, "expected commonObj::m_fDamagePower to be size 4");
static_assert(sizeof(commonObj::m_fDamageYaw) == 4, "expected commonObj::m_fDamageYaw to be size 4");
static_assert(sizeof(commonObj::m_fDamagePitch) == 4, "expected commonObj::m_fDamagePitch to be size 4");
static_assert(sizeof(commonObj::m_bIsSpreadBreak) == 1, "expected commonObj::m_bIsSpreadBreak to be size 1");
static_assert(sizeof(commonObj::m_inSpreadBreakSrcPosiOfst) == 12, "expected commonObj::m_inSpreadBreakSrcPosiOfst to be size 12");
static_assert(sizeof(commonObj::m_bIsSetGroundColPlane) == 1, "expected commonObj::m_bIsSetGroundColPlane to be size 1");
static_assert(sizeof(commonObj::m_inGroundColPlane) == 16, "expected commonObj::m_inGroundColPlane to be size 16");
static_assert(sizeof(commonObj::mbDistEraseDisable) == 1, "expected commonObj::mbDistEraseDisable to be size 1");
static_assert(sizeof(commonObj) == 0x64c, "expected commonObj to be size 0x64c");

// [Structure] struct WGclSpec
struct WGclSpec
{
public:
	/// Struct member variables

	// <uint32_t mID, offset 0x0>
	uint32_t mID = 0;

	// <uint32_t mVersion, offset 0x4>
	uint32_t mVersion = 0;

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag = 0;

	// <uint16_t mNodeCount, offset 0xc>
	uint16_t mNodeCount = 0;

	// <uint16_t mMaterialCount, offset 0xe>
	uint16_t mMaterialCount = 0;

	// <struct WGclNodeSpec* mpTopNode, offset 0x10>
	struct WGclNodeSpec* mpTopNode = nullptr;

	// <struct WGclMaterialSpec* mpTopMaterial, offset 0x14>
	struct WGclMaterialSpec* mpTopMaterial = nullptr;

	// <uint32_t mConvVersion, offset 0x18>
	uint32_t mConvVersion = 0;

	// <uint32_t mPad[0x5], offset 0x1c>
	uint32_t mPad[5];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGclSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGclSpec& InObject)
	{
		mID = InObject.mID;
		mVersion = InObject.mVersion;
		mFlag = InObject.mFlag;
		mNodeCount = InObject.mNodeCount;
		mMaterialCount = InObject.mMaterialCount;
		mpTopNode = InObject.mpTopNode;
		mpTopMaterial = InObject.mpTopMaterial;
		mConvVersion = InObject.mConvVersion;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclSpec>("WGclSpec")
			.addFunction("__tostring", &WGclSpec::ToString)
			.addFunction("GetPtrAddr", &WGclSpec::GetPtrAddr)
			.addProperty("mID", &WGclSpec::mID)
			.addProperty("mVersion", &WGclSpec::mVersion)
			.addProperty("mFlag", &WGclSpec::mFlag)
			.addProperty("mNodeCount", &WGclSpec::mNodeCount)
			.addProperty("mMaterialCount", &WGclSpec::mMaterialCount)
			.addProperty("mpTopNode", &WGclSpec::mpTopNode)
			.addProperty("mpTopMaterial", &WGclSpec::mpTopMaterial)
			.addProperty("mConvVersion", &WGclSpec::mConvVersion)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclSpec::mID) == 4, "expected WGclSpec::mID to be size 4");
static_assert(sizeof(WGclSpec::mVersion) == 4, "expected WGclSpec::mVersion to be size 4");
static_assert(sizeof(WGclSpec::mFlag) == 4, "expected WGclSpec::mFlag to be size 4");
static_assert(sizeof(WGclSpec::mNodeCount) == 2, "expected WGclSpec::mNodeCount to be size 2");
static_assert(sizeof(WGclSpec::mMaterialCount) == 2, "expected WGclSpec::mMaterialCount to be size 2");
static_assert(sizeof(WGclSpec::mpTopNode) == 4, "expected WGclSpec::mpTopNode to be size 4");
static_assert(sizeof(WGclSpec::mpTopMaterial) == 4, "expected WGclSpec::mpTopMaterial to be size 4");
static_assert(sizeof(WGclSpec::mConvVersion) == 4, "expected WGclSpec::mConvVersion to be size 4");
static_assert(sizeof(WGclSpec::mPad) == 20, "expected WGclSpec::mPad to be size 20");
static_assert(sizeof(WGclSpec) == 0x30, "expected WGclSpec to be size 0x30");

// [Structure] struct WGclNodeSpec
struct WGclNodeSpec
{
public:
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag = 0;

	// <uint32_t mType, offset 0xc>
	uint32_t mType = 0;

	// <WGclNodeSpec* mpParent, offset 0x10>
	WGclNodeSpec* mpParent = nullptr;

	// <WGclNodeSpec* mpChild, offset 0x14>
	WGclNodeSpec* mpChild = nullptr;

	// <WGclNodeSpec* mpPrev, offset 0x18>
	WGclNodeSpec* mpPrev = nullptr;

	// <WGclNodeSpec* mpNext, offset 0x1c>
	WGclNodeSpec* mpNext = nullptr;

	// <struct Vec mPosition, offset 0x20>
	struct Vec mPosition;

	// <struct Vec mRotation, offset 0x2c>
	struct Vec mRotation;

	// <struct WGclNodeShapeMeshSpec* mpMesh, offset 0x38>
	struct WGclNodeShapeMeshSpec* mpMesh = nullptr;

	// <uint32_t mPad[0x5], offset 0x3c>
	uint32_t mPad[5];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGclNodeSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGclNodeSpec& InObject)
	{
		mFlag = InObject.mFlag;
		mType = InObject.mType;
		mpParent = InObject.mpParent;
		mpChild = InObject.mpChild;
		mpPrev = InObject.mpPrev;
		mpNext = InObject.mpNext;
		mPosition = InObject.mPosition;
		mRotation = InObject.mRotation;
		mpMesh = InObject.mpMesh;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeSpec>("WGclNodeSpec")
			.addFunction("__tostring", &WGclNodeSpec::ToString)
			.addFunction("GetPtrAddr", &WGclNodeSpec::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclNodeSpec::mIDStr)
			.addProperty("mFlag", &WGclNodeSpec::mFlag)
			.addProperty("mType", &WGclNodeSpec::mType)
			.addProperty("mpParent", &WGclNodeSpec::mpParent)
			.addProperty("mpChild", &WGclNodeSpec::mpChild)
			.addProperty("mpPrev", &WGclNodeSpec::mpPrev)
			.addProperty("mpNext", &WGclNodeSpec::mpNext)
			.addProperty("mPosition", &WGclNodeSpec::mPosition)
			.addProperty("mRotation", &WGclNodeSpec::mRotation)
			.addProperty("mpMesh", &WGclNodeSpec::mpMesh)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclNodeSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeSpec::mIDStr) == 8, "expected WGclNodeSpec::mIDStr to be size 8");
static_assert(sizeof(WGclNodeSpec::mFlag) == 4, "expected WGclNodeSpec::mFlag to be size 4");
static_assert(sizeof(WGclNodeSpec::mType) == 4, "expected WGclNodeSpec::mType to be size 4");
static_assert(sizeof(WGclNodeSpec::mpParent) == 4, "expected WGclNodeSpec::mpParent to be size 4");
static_assert(sizeof(WGclNodeSpec::mpChild) == 4, "expected WGclNodeSpec::mpChild to be size 4");
static_assert(sizeof(WGclNodeSpec::mpPrev) == 4, "expected WGclNodeSpec::mpPrev to be size 4");
static_assert(sizeof(WGclNodeSpec::mpNext) == 4, "expected WGclNodeSpec::mpNext to be size 4");
static_assert(sizeof(WGclNodeSpec::mPosition) == 12, "expected WGclNodeSpec::mPosition to be size 12");
static_assert(sizeof(WGclNodeSpec::mRotation) == 12, "expected WGclNodeSpec::mRotation to be size 12");
static_assert(sizeof(WGclNodeSpec::mpMesh) == 4, "expected WGclNodeSpec::mpMesh to be size 4");
static_assert(sizeof(WGclNodeSpec::mPad) == 20, "expected WGclNodeSpec::mPad to be size 20");
static_assert(sizeof(WGclNodeSpec) == 0x50, "expected WGclNodeSpec to be size 0x50");

// [Structure] struct WGclNodeShapeMeshSpec
struct WGclNodeShapeMeshSpec
{
public:
	/// Struct member variables

	// <struct WGclNodeShapeMeshBspNodeSpec* mpBspTree, offset 0x0>
	struct WGclNodeShapeMeshBspNodeSpec* mpBspTree = nullptr;

	// <struct WGclNodeShapeTriangleSpec* mpTriangles, offset 0x4>
	struct WGclNodeShapeTriangleSpec* mpTriangles = nullptr;

	// <int32_t mNodeCount, offset 0x8>
	int32_t mNodeCount = 0;

	// <int32_t mTriangleCount, offset 0xc>
	int32_t mTriangleCount = 0;

	// <struct Vec mBoundingBoxCenter, offset 0x10>
	struct Vec mBoundingBoxCenter;

	// <struct Vec mBoundingBoxExtent, offset 0x1c>
	struct Vec mBoundingBoxExtent;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGclNodeShapeMeshSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGclNodeShapeMeshSpec& InObject)
	{
		mpBspTree = InObject.mpBspTree;
		mpTriangles = InObject.mpTriangles;
		mNodeCount = InObject.mNodeCount;
		mTriangleCount = InObject.mTriangleCount;
		mBoundingBoxCenter = InObject.mBoundingBoxCenter;
		mBoundingBoxExtent = InObject.mBoundingBoxExtent;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeMeshSpec>("WGclNodeShapeMeshSpec")
			.addFunction("__tostring", &WGclNodeShapeMeshSpec::ToString)
			.addFunction("GetPtrAddr", &WGclNodeShapeMeshSpec::GetPtrAddr)
			.addProperty("mpBspTree", &WGclNodeShapeMeshSpec::mpBspTree)
			.addProperty("mpTriangles", &WGclNodeShapeMeshSpec::mpTriangles)
			.addProperty("mNodeCount", &WGclNodeShapeMeshSpec::mNodeCount)
			.addProperty("mTriangleCount", &WGclNodeShapeMeshSpec::mTriangleCount)
			.addProperty("mBoundingBoxCenter", &WGclNodeShapeMeshSpec::mBoundingBoxCenter)
			.addProperty("mBoundingBoxExtent", &WGclNodeShapeMeshSpec::mBoundingBoxExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeShapeMeshSpec::mpBspTree) == 4, "expected WGclNodeShapeMeshSpec::mpBspTree to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mpTriangles) == 4, "expected WGclNodeShapeMeshSpec::mpTriangles to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mNodeCount) == 4, "expected WGclNodeShapeMeshSpec::mNodeCount to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mTriangleCount) == 4, "expected WGclNodeShapeMeshSpec::mTriangleCount to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mBoundingBoxCenter) == 12, "expected WGclNodeShapeMeshSpec::mBoundingBoxCenter to be size 12");
static_assert(sizeof(WGclNodeShapeMeshSpec::mBoundingBoxExtent) == 12, "expected WGclNodeShapeMeshSpec::mBoundingBoxExtent to be size 12");
static_assert(sizeof(WGclNodeShapeMeshSpec) == 0x28, "expected WGclNodeShapeMeshSpec to be size 0x28");

// [Structure] struct WGclNodeShapeMeshBspNodeSpec
struct WGclNodeShapeMeshBspNodeSpec
{
public:
	/// Struct member variables

	// <WGclNodeShapeMeshBspNodeSpec* mpFront, offset 0x0>
	WGclNodeShapeMeshBspNodeSpec* mpFront = nullptr;

	// <WGclNodeShapeMeshBspNodeSpec* mpBack, offset 0x4>
	WGclNodeShapeMeshBspNodeSpec* mpBack = nullptr;

	// <struct WGclNodeShapeTriangleSpec* mpTriangle, offset 0x8>
	struct WGclNodeShapeTriangleSpec* mpTriangle = nullptr;

	// <uint16_t mTriangleCount, offset 0xc>
	uint16_t mTriangleCount = 0;

	// <uint16_t mFlag, offset 0xe>
	uint16_t mFlag = 0;

	// <struct Vec mNormal, offset 0x10>
	struct Vec mNormal;

	// <float mDist, offset 0x1c>
	float mDist = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGclNodeShapeMeshBspNodeSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGclNodeShapeMeshBspNodeSpec& InObject)
	{
		mpFront = InObject.mpFront;
		mpBack = InObject.mpBack;
		mpTriangle = InObject.mpTriangle;
		mTriangleCount = InObject.mTriangleCount;
		mFlag = InObject.mFlag;
		mNormal = InObject.mNormal;
		mDist = InObject.mDist;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeMeshBspNodeSpec>("WGclNodeShapeMeshBspNodeSpec")
			.addFunction("__tostring", &WGclNodeShapeMeshBspNodeSpec::ToString)
			.addFunction("GetPtrAddr", &WGclNodeShapeMeshBspNodeSpec::GetPtrAddr)
			.addProperty("mpFront", &WGclNodeShapeMeshBspNodeSpec::mpFront)
			.addProperty("mpBack", &WGclNodeShapeMeshBspNodeSpec::mpBack)
			.addProperty("mpTriangle", &WGclNodeShapeMeshBspNodeSpec::mpTriangle)
			.addProperty("mTriangleCount", &WGclNodeShapeMeshBspNodeSpec::mTriangleCount)
			.addProperty("mFlag", &WGclNodeShapeMeshBspNodeSpec::mFlag)
			.addProperty("mNormal", &WGclNodeShapeMeshBspNodeSpec::mNormal)
			.addProperty("mDist", &WGclNodeShapeMeshBspNodeSpec::mDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpFront) == 4, "expected WGclNodeShapeMeshBspNodeSpec::mpFront to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpBack) == 4, "expected WGclNodeShapeMeshBspNodeSpec::mpBack to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpTriangle) == 4, "expected WGclNodeShapeMeshBspNodeSpec::mpTriangle to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mTriangleCount) == 2, "expected WGclNodeShapeMeshBspNodeSpec::mTriangleCount to be size 2");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mFlag) == 2, "expected WGclNodeShapeMeshBspNodeSpec::mFlag to be size 2");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mNormal) == 12, "expected WGclNodeShapeMeshBspNodeSpec::mNormal to be size 12");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mDist) == 4, "expected WGclNodeShapeMeshBspNodeSpec::mDist to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec) == 0x20, "expected WGclNodeShapeMeshBspNodeSpec to be size 0x20");

// [Structure] struct WGclNodeShapeTriangleSpec
struct WGclNodeShapeTriangleSpec
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[48];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct WGclNodeShapeTriangleSpec [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGclNodeShapeTriangleSpec& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeTriangleSpec>("WGclNodeShapeTriangleSpec")
			.addFunction("__tostring", &WGclNodeShapeTriangleSpec::ToString)
			.addFunction("GetPtrAddr", &WGclNodeShapeTriangleSpec::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeShapeTriangleSpec) == 0x30, "expected WGclNodeShapeTriangleSpec to be size 0x30");

// [Structure] class ghmGcColl
class ghmGcColl
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class ghmGcOctTree mOctTree, offset 0x4>
	class ghmGcOctTree mOctTree;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcColl [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcColl& InObject)
	{
		mOctTree = InObject.mOctTree;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcColl>("ghmGcColl")
			.addFunction("__tostring", &ghmGcColl::ToString)
			.addFunction("GetPtrAddr", &ghmGcColl::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcColl::field_0)
			.addProperty("mOctTree", &ghmGcColl::mOctTree)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcColl::field_0) == 4, "expected ghmGcColl::field_0 to be size 4");
static_assert(sizeof(ghmGcColl::mOctTree) == 12, "expected ghmGcColl::mOctTree to be size 12");
static_assert(sizeof(ghmGcColl) == 0x10, "expected ghmGcColl to be size 0x10");

// [Structure] class WGclNode
class WGclNode
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <Unidentified data segment, offset 0x4>
private:
	char _UnidentifiedData_4[4];

public:
	// <char mIDStr[0x8], offset 0x8>
	char mIDStr[8];

	// <class WGcl* mpContainer, offset 0x10>
	class WGcl* mpContainer = nullptr;

	// <struct WGclNodeSpec* mpSpec, offset 0x14>
	struct WGclNodeSpec* mpSpec = nullptr;

	// <class ghmGcCollObj* mpCollObj, offset 0x18>
	class ghmGcCollObj* mpCollObj = nullptr;

	// <WGclNode* mpParent, offset 0x1c>
	WGclNode* mpParent = nullptr;

	// <WGclNode* mpChild, offset 0x20>
	WGclNode* mpChild = nullptr;

	// <WGclNode* mpNext, offset 0x24>
	WGclNode* mpNext = nullptr;

	// <WGclNode* mpPrev, offset 0x28>
	WGclNode* mpPrev = nullptr;

	// <struct Vec mPosition, offset 0x2c>
	struct Vec mPosition;

	// <struct Vec mRotation, offset 0x38>
	struct Vec mRotation;

	// <float mLocalWorldMatrix[0x3][0x4], offset 0x44>
	float mLocalWorldMatrix[3][4];

	// <float mWorldLocalMatrix[0x3][0x4], offset 0x74>
	float mWorldLocalMatrix[3][4];

	// <uint32_t mFlag, offset 0xa4>
	uint32_t mFlag = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class WGclNode [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGclNode& InObject)
	{
		mpContainer = InObject.mpContainer;
		mpSpec = InObject.mpSpec;
		mpCollObj = InObject.mpCollObj;
		mpParent = InObject.mpParent;
		mpChild = InObject.mpChild;
		mpNext = InObject.mpNext;
		mpPrev = InObject.mpPrev;
		mPosition = InObject.mPosition;
		mRotation = InObject.mRotation;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNode>("WGclNode")
			.addFunction("__tostring", &WGclNode::ToString)
			.addFunction("GetPtrAddr", &WGclNode::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &WGclNode::field_0)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclNode::mIDStr)
			.addProperty("mpContainer", &WGclNode::mpContainer)
			.addProperty("mpSpec", &WGclNode::mpSpec)
			.addProperty("mpCollObj", &WGclNode::mpCollObj)
			.addProperty("mpParent", &WGclNode::mpParent)
			.addProperty("mpChild", &WGclNode::mpChild)
			.addProperty("mpNext", &WGclNode::mpNext)
			.addProperty("mpPrev", &WGclNode::mpPrev)
			.addProperty("mPosition", &WGclNode::mPosition)
			.addProperty("mRotation", &WGclNode::mRotation)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mLocalWorldMatrix", &WGclNode::mLocalWorldMatrix)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mWorldLocalMatrix", &WGclNode::mWorldLocalMatrix)
			.addProperty("mFlag", &WGclNode::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNode::field_0) == 4, "expected WGclNode::field_0 to be size 4");
static_assert(sizeof(WGclNode::mIDStr) == 8, "expected WGclNode::mIDStr to be size 8");
static_assert(sizeof(WGclNode::mpContainer) == 4, "expected WGclNode::mpContainer to be size 4");
static_assert(sizeof(WGclNode::mpSpec) == 4, "expected WGclNode::mpSpec to be size 4");
static_assert(sizeof(WGclNode::mpCollObj) == 4, "expected WGclNode::mpCollObj to be size 4");
static_assert(sizeof(WGclNode::mpParent) == 4, "expected WGclNode::mpParent to be size 4");
static_assert(sizeof(WGclNode::mpChild) == 4, "expected WGclNode::mpChild to be size 4");
static_assert(sizeof(WGclNode::mpNext) == 4, "expected WGclNode::mpNext to be size 4");
static_assert(sizeof(WGclNode::mpPrev) == 4, "expected WGclNode::mpPrev to be size 4");
static_assert(sizeof(WGclNode::mPosition) == 12, "expected WGclNode::mPosition to be size 12");
static_assert(sizeof(WGclNode::mRotation) == 12, "expected WGclNode::mRotation to be size 12");
static_assert(sizeof(WGclNode::mLocalWorldMatrix) == 48, "expected WGclNode::mLocalWorldMatrix to be size 48");
static_assert(sizeof(WGclNode::mWorldLocalMatrix) == 48, "expected WGclNode::mWorldLocalMatrix to be size 48");
static_assert(sizeof(WGclNode::mFlag) == 4, "expected WGclNode::mFlag to be size 4");
static_assert(sizeof(WGclNode) == 0xa8, "expected WGclNode to be size 0xa8");

// [Structure] class PJStateMachine
class PJStateMachine
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class PJZAKO* m_pOwner, offset 0x4>
	class PJZAKO* m_pOwner = nullptr;

	// <class PJState* m_pCurrentState, offset 0x8>
	class PJState* m_pCurrentState = nullptr;

	// <class PJState* m_pPreviousState, offset 0xc>
	class PJState* m_pPreviousState = nullptr;

	// <class PJState* m_pGlobalState, offset 0x10>
	class PJState* m_pGlobalState = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJStateMachine [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJStateMachine& InObject)
	{
		m_pOwner = InObject.m_pOwner;
		m_pCurrentState = InObject.m_pCurrentState;
		m_pPreviousState = InObject.m_pPreviousState;
		m_pGlobalState = InObject.m_pGlobalState;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJStateMachine>("PJStateMachine")
			.addFunction("__tostring", &PJStateMachine::ToString)
			.addFunction("GetPtrAddr", &PJStateMachine::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &PJStateMachine::field_0)
			.addProperty("m_pOwner", &PJStateMachine::m_pOwner)
			.addProperty("m_pCurrentState", &PJStateMachine::m_pCurrentState)
			.addProperty("m_pPreviousState", &PJStateMachine::m_pPreviousState)
			.addProperty("m_pGlobalState", &PJStateMachine::m_pGlobalState)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJStateMachine::field_0) == 4, "expected PJStateMachine::field_0 to be size 4");
static_assert(sizeof(PJStateMachine::m_pOwner) == 4, "expected PJStateMachine::m_pOwner to be size 4");
static_assert(sizeof(PJStateMachine::m_pCurrentState) == 4, "expected PJStateMachine::m_pCurrentState to be size 4");
static_assert(sizeof(PJStateMachine::m_pPreviousState) == 4, "expected PJStateMachine::m_pPreviousState to be size 4");
static_assert(sizeof(PJStateMachine::m_pGlobalState) == 4, "expected PJStateMachine::m_pGlobalState to be size 4");
static_assert(sizeof(PJStateMachine) == 0x14, "expected PJStateMachine to be size 0x14");

// [Structure] class EffectDanmenFlash
class EffectDanmenFlash
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[604];

public:
	/// 1 Functions

	// [Function] class EffectDanmenFlash* EffectDanmenFlash::Create(class TGmf* arg1, struct Vec& arg2, enum eEfDmgLevel& arg3, uint32_t arg4, class PJZAKO* arg5) [?Create@EffectDanmenFlash@@SAPAV1@PAVTGmf@@ABUVec@@ABW4eEfDmgLevel@@IPAVPJZAKO@@@Z]
	typedef class EffectDanmenFlash*(__fastcall* _Create_EffectDanmenFlash__SAPAV1_PAVTGmf__ABUVec__ABW4eEfDmgLevel__IPAVPJZAKO___Z)(class TGmf* arg1, struct Vec& arg2, enum eEfDmgLevel& arg3, uint32_t arg4, class PJZAKO* arg5);
	static class EffectDanmenFlash* Create(class TGmf* arg1, struct Vec& arg2, /* enum eEfDmgLevel& */ uint32_t arg3, uint32_t arg4, class PJZAKO* arg5)
	{
		_Create_EffectDanmenFlash__SAPAV1_PAVTGmf__ABUVec__ABW4eEfDmgLevel__IPAVPJZAKO___Z mFunc = (_Create_EffectDanmenFlash__SAPAV1_PAVTGmf__ABUVec__ABW4eEfDmgLevel__IPAVPJZAKO___Z)(GameModule + 0x5d2760);
		return mFunc(arg1, arg2, (enum eEfDmgLevel&)arg3, arg4, arg5);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectDanmenFlash [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectDanmenFlash& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectDanmenFlash>("EffectDanmenFlash")
			.addFunction("__tostring", &EffectDanmenFlash::ToString)
			.addFunction("GetPtrAddr", &EffectDanmenFlash::GetPtrAddr)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectDanmenFlash::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectDanmenFlash) == 0x25c, "expected EffectDanmenFlash to be size 0x25c");

// [Structure] class EffectCutMark
class EffectCutMark
{
public:
	// enum EffectCutMark::eCutMarkType
	enum eCutMarkType : uint32_t
	{
		// <eCutMarkType_UNKNOWN = 0xffffffffffffffff>
		eCutMarkType_UNKNOWN = UINT32_MAX,

		// <eCutMarkType_Beam = 0x0>
		eCutMarkType_Beam = 0,

		// <eCutMarkType_Sword = 0x1>
		eCutMarkType_Sword = 1,

		// <eCutMarkType_NUM = 0x2>
		eCutMarkType_NUM = 2

	};

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[21812];

public:
	/// 1 Functions

	// [Function] class EffectCutMark* EffectCutMark::Create(class TGmf* arg1, class mHRChara* arg2, struct Vec* arg3, uint32_t const arg4, enum eEfDmgLevel& arg5, enum EffectCutMark::eCutMarkType& arg6, float const arg7) [?Create@EffectCutMark@@SAPAV1@PAVTGmf@@PAVmHRChara@@PBUVec@@IABW4eEfDmgLevel@@ABW4eCutMarkType@1@M@Z]
	typedef class EffectCutMark*(__fastcall* _Create_EffectCutMark__SAPAV1_PAVTGmf__PAVmHRChara__PBUVec__IABW4eEfDmgLevel__ABW4eCutMarkType_1_M_Z)(class TGmf* arg1, class mHRChara* arg2, struct Vec* arg3, uint32_t const arg4, enum eEfDmgLevel& arg5, enum EffectCutMark::eCutMarkType& arg6, float const arg7);
	static class EffectCutMark* Create(class TGmf* arg1, class mHRChara* arg2, struct Vec* arg3, uint32_t const arg4, /* enum eEfDmgLevel& */ uint32_t arg5, /* enum EffectCutMark::eCutMarkType& */ uint32_t arg6, float const arg7)
	{
		_Create_EffectCutMark__SAPAV1_PAVTGmf__PAVmHRChara__PBUVec__IABW4eEfDmgLevel__ABW4eCutMarkType_1_M_Z mFunc = (_Create_EffectCutMark__SAPAV1_PAVTGmf__PAVmHRChara__PBUVec__IABW4eEfDmgLevel__ABW4eCutMarkType_1_M_Z)(GameModule + 0x56f2c0);
		return mFunc(arg1, arg2, arg3, arg4, (enum eEfDmgLevel&)arg5, (enum EffectCutMark::eCutMarkType&)arg6, arg7);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectCutMark [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectCutMark& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectCutMark>("EffectCutMark")
			.addFunction("__tostring", &EffectCutMark::ToString)
			.addFunction("GetPtrAddr", &EffectCutMark::GetPtrAddr)
			// Can't export & pointer 'enum eEfDmgLevel&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectCutMark::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectCutMark) == 0x5534, "expected EffectCutMark to be size 0x5534");

// [Structure] class EffectQuestion
class EffectQuestion : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag = 0;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData_81[3];

public:
	// <class rPrimUnific m_StarUni, offset 0x54>
	class rPrimUnific m_StarUni;

	// <class rQuad m_Star, offset 0x74>
	class rQuad m_Star;

	// <struct tagGHMR_TEX m_StarTex, offset 0x120>
	struct tagGHMR_TEX m_StarTex;

	// <struct Vec m_Pos, offset 0x148>
	struct Vec m_Pos;

	// <float m_Speed, offset 0x154>
	float m_Speed = 0;

	// <float m_Up, offset 0x158>
	float m_Up = 0;

	// <float m_Add, offset 0x15c>
	float m_Add = 0;

	// <float m_TimeCount, offset 0x160>
	float m_TimeCount = 0;

	// <int32_t m_TimeFrame, offset 0x164>
	int32_t m_TimeFrame = 0;

	// <float m_TimeRate, offset 0x168>
	float m_TimeRate = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectQuestion [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectQuestion& InObject)
	{
		m_Flag = InObject.m_Flag;
		m_StarUni = InObject.m_StarUni;
		m_Star = InObject.m_Star;
		m_StarTex = InObject.m_StarTex;
		m_Pos = InObject.m_Pos;
		m_Speed = InObject.m_Speed;
		m_Up = InObject.m_Up;
		m_Add = InObject.m_Add;
		m_TimeCount = InObject.m_TimeCount;
		m_TimeFrame = InObject.m_TimeFrame;
		m_TimeRate = InObject.m_TimeRate;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectQuestion, HrTask>("EffectQuestion")
			.addFunction("__tostring", &EffectQuestion::ToString)
			.addFunction("GetPtrAddr", &EffectQuestion::GetPtrAddr)
			.addProperty("m_Flag", &EffectQuestion::m_Flag)
			.addProperty("m_StarUni", &EffectQuestion::m_StarUni)
			.addProperty("m_Star", &EffectQuestion::m_Star)
			.addProperty("m_StarTex", &EffectQuestion::m_StarTex)
			.addProperty("m_Pos", &EffectQuestion::m_Pos)
			.addProperty("m_Speed", &EffectQuestion::m_Speed)
			.addProperty("m_Up", &EffectQuestion::m_Up)
			.addProperty("m_Add", &EffectQuestion::m_Add)
			.addProperty("m_TimeCount", &EffectQuestion::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectQuestion::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectQuestion::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectQuestion::m_Flag) == 1, "expected EffectQuestion::m_Flag to be size 1");
static_assert(sizeof(EffectQuestion::m_StarUni) == 32, "expected EffectQuestion::m_StarUni to be size 32");
static_assert(sizeof(EffectQuestion::m_Star) == 172, "expected EffectQuestion::m_Star to be size 172");
static_assert(sizeof(EffectQuestion::m_StarTex) == 40, "expected EffectQuestion::m_StarTex to be size 40");
static_assert(sizeof(EffectQuestion::m_Pos) == 12, "expected EffectQuestion::m_Pos to be size 12");
static_assert(sizeof(EffectQuestion::m_Speed) == 4, "expected EffectQuestion::m_Speed to be size 4");
static_assert(sizeof(EffectQuestion::m_Up) == 4, "expected EffectQuestion::m_Up to be size 4");
static_assert(sizeof(EffectQuestion::m_Add) == 4, "expected EffectQuestion::m_Add to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeCount) == 4, "expected EffectQuestion::m_TimeCount to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeFrame) == 4, "expected EffectQuestion::m_TimeFrame to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeRate) == 4, "expected EffectQuestion::m_TimeRate to be size 4");
static_assert(sizeof(EffectQuestion) == 0x16c, "expected EffectQuestion to be size 0x16c");

// [Structure] class PJZakoMotMng
class PJZakoMotMng
{
public:
	// enum PJZakoMotMng::MotMode
	enum MotMode : uint32_t
	{
		// <MotMode_Init = 0x0>
		MotMode_Init = 0,

		// <MotMode_Walk = 0x1>
		MotMode_Walk = 1,

		// <MotMode_Run = 0x2>
		MotMode_Run = 2,

		// <MotMode_Evacuate = 0x3>
		MotMode_Evacuate = 3,

		// <MotMode_Attack = 0x4>
		MotMode_Attack = 4,

		// <MotMode_Damage = 0x5>
		MotMode_Damage = 5,

		// <MotMode_Guard = 0x6>
		MotMode_Guard = 6,

		// <MotMode_Debug = 0x7>
		MotMode_Debug = 7,

		// <MotMode_Misc = 0x8>
		MotMode_Misc = 8,

		// <MotMode_NUM = 0x9>
		MotMode_NUM = 9

	};

	/// Struct member variables

	// <struct Vec m_MoveVec, offset 0x0>
	struct Vec m_MoveVec;

	// <float m_fCharRotY, offset 0xc>
	float m_fCharRotY = 0;

	// <float m_fMoveSpd, offset 0x10>
	float m_fMoveSpd = 0;

	// <float m_fMotSpd, offset 0x14>
	float m_fMotSpd = 0;

	// <enum PJZakoMotMng::MotMode m_MotMode, offset 0x18>
	enum PJZakoMotMng::MotMode m_MotMode;

	// <class PJZAKO* m_pOwnerChar, offset 0x1c>
	class PJZAKO* m_pOwnerChar = nullptr;

	// <enum eMoveDir m_MoveDir, offset 0x20>
	enum eMoveDir m_MoveDir;

	/// 1 Functions

	// [Function] void __convention("thiscall") PJZakoMotMng::SetOwnerPtr(class PJZakoMotMng* const this, class PJZAKO* arg2) [?SetOwnerPtr@PJZakoMotMng@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _SetOwnerPtr_PJZakoMotMng__QAEXPAVPJZAKO___Z)(class PJZakoMotMng* const thisPtr, class PJZAKO* arg2);
	void SetOwnerPtr(class PJZAKO* arg2)
	{
		_SetOwnerPtr_PJZakoMotMng__QAEXPAVPJZAKO___Z mFunc = (_SetOwnerPtr_PJZakoMotMng__QAEXPAVPJZAKO___Z)(GameModule + 0xbc210);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZakoMotMng [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZakoMotMng& InObject)
	{
		m_MoveVec = InObject.m_MoveVec;
		m_fCharRotY = InObject.m_fCharRotY;
		m_fMoveSpd = InObject.m_fMoveSpd;
		m_fMotSpd = InObject.m_fMotSpd;
		m_MotMode = InObject.m_MotMode;
		m_pOwnerChar = InObject.m_pOwnerChar;
		m_MoveDir = InObject.m_MoveDir;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJZakoMotMng>("PJZakoMotMng")
			.addFunction("__tostring", &PJZakoMotMng::ToString)
			.addFunction("GetPtrAddr", &PJZakoMotMng::GetPtrAddr)
			.addProperty("m_MoveVec", &PJZakoMotMng::m_MoveVec)
			.addProperty("m_fCharRotY", &PJZakoMotMng::m_fCharRotY)
			.addProperty("m_fMoveSpd", &PJZakoMotMng::m_fMoveSpd)
			.addProperty("m_fMotSpd", &PJZakoMotMng::m_fMotSpd)
			.addProperty("m_MotMode", &PJZakoMotMng::m_MotMode)
			.addProperty("m_pOwnerChar", &PJZakoMotMng::m_pOwnerChar)
			.addProperty("m_MoveDir", &PJZakoMotMng::m_MoveDir)
			.addFunction("SetOwnerPtr", &PJZakoMotMng::SetOwnerPtr)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoMotMng::m_MoveVec) == 12, "expected PJZakoMotMng::m_MoveVec to be size 12");
static_assert(sizeof(PJZakoMotMng::m_fCharRotY) == 4, "expected PJZakoMotMng::m_fCharRotY to be size 4");
static_assert(sizeof(PJZakoMotMng::m_fMoveSpd) == 4, "expected PJZakoMotMng::m_fMoveSpd to be size 4");
static_assert(sizeof(PJZakoMotMng::m_fMotSpd) == 4, "expected PJZakoMotMng::m_fMotSpd to be size 4");
static_assert(sizeof(PJZakoMotMng::m_MotMode) == 4, "expected PJZakoMotMng::m_MotMode to be size 4");
static_assert(sizeof(PJZakoMotMng::m_pOwnerChar) == 4, "expected PJZakoMotMng::m_pOwnerChar to be size 4");
static_assert(sizeof(PJZakoMotMng::m_MoveDir) == 4, "expected PJZakoMotMng::m_MoveDir to be size 4");
static_assert(sizeof(PJZakoMotMng) == 0x24, "expected PJZakoMotMng to be size 0x24");

// [Structure] class PathPlanner
class PathPlanner
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[1220];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PathPlanner [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PathPlanner& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PathPlanner>("PathPlanner")
			.addFunction("__tostring", &PathPlanner::ToString)
			.addFunction("GetPtrAddr", &PathPlanner::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(PathPlanner) == 0x4c4, "expected PathPlanner to be size 0x4c4");

// [Structure] class FkDynamicParam
class FkDynamicParam
{
public:
	// [Structure] struct FkDynamicParam::DynamicParam
	struct DynamicParam
	{
	public:
		/// Struct member variables

		// <char* strParamName, offset 0x0>
		char* strParamName = nullptr;

		// <float fParam, offset 0x4>
		float fParam = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct FkDynamicParam::DynamicParam [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(FkDynamicParam::DynamicParam& InObject)
		{
			strParamName = InObject.strParamName;
			fParam = InObject.fParam;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<DynamicParam>("FkDynamicParam_DynamicParam")
				.addFunction("__tostring", &FkDynamicParam::DynamicParam::ToString)
				.addFunction("GetPtrAddr", &FkDynamicParam::DynamicParam::GetPtrAddr)
				// char* type not supported in LuaBridge
				//.addProperty("strParamName", &FkDynamicParam::DynamicParam::strParamName)
				.addProperty("fParam", &FkDynamicParam::DynamicParam::fParam)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkDynamicParam::DynamicParam::strParamName) == 4, "expected FkDynamicParam::DynamicParam::strParamName to be size 4");
	static_assert(sizeof(FkDynamicParam::DynamicParam::fParam) == 4, "expected FkDynamicParam::DynamicParam::fParam to be size 4");
	static_assert(sizeof(FkDynamicParam::DynamicParam) == 0x8, "expected FkDynamicParam::DynamicParam to be size 0x8");

	// enum FkDynamicParam::DP_STAT
	enum DP_STAT : uint32_t
	{
		// <eDP_STAT_INIT = 0xffffffffffffffff>
		eDP_STAT_INIT = UINT32_MAX,

		// <eDP_STAT_STANDBY = 0x0>
		eDP_STAT_STANDBY = 0

	};

	/// Struct member variables

	// <class FkStlVector<FkDynamicParam::DynamicParam> m_DP, offset 0x0>
	class FkStlVector<FkDynamicParam::DynamicParam> m_DP;

	// <char m_StrFilePath[0x104], offset 0x14>
	char m_StrFilePath[260];

	// <int32_t m_nParam, offset 0x118>
	int32_t m_nParam = 0;

	// <enum FkDynamicParam::DP_STAT m_Stat, offset 0x11c>
	enum FkDynamicParam::DP_STAT m_Stat;

	// <char* m_pReadBuffer, offset 0x120>
	char* m_pReadBuffer = nullptr;

	// <char* m_pReadHead, offset 0x124>
	char* m_pReadHead = nullptr;

	// <uint32_t m_BufferSize, offset 0x128>
	uint32_t m_BufferSize = 0;

	// <uint32_t m_HeadSize, offset 0x12c>
	uint32_t m_HeadSize = 0;

	// <uint8_t m_boEOF, offset 0x130>
	uint8_t m_boEOF = 0;

	// <Unidentified data segment, offset 0x131>
private:
	char _UnidentifiedData_305[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class FkDynamicParam [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkDynamicParam& InObject)
	{
		m_DP = InObject.m_DP;
		m_nParam = InObject.m_nParam;
		m_Stat = InObject.m_Stat;
		m_pReadBuffer = InObject.m_pReadBuffer;
		m_pReadHead = InObject.m_pReadHead;
		m_BufferSize = InObject.m_BufferSize;
		m_HeadSize = InObject.m_HeadSize;
		m_boEOF = InObject.m_boEOF;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkDynamicParam>("FkDynamicParam")
			.addFunction("__tostring", &FkDynamicParam::ToString)
			.addFunction("GetPtrAddr", &FkDynamicParam::GetPtrAddr)
			.addProperty("m_DP", &FkDynamicParam::m_DP)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StrFilePath", &FkDynamicParam::m_StrFilePath)
			.addProperty("m_nParam", &FkDynamicParam::m_nParam)
			.addProperty("m_Stat", &FkDynamicParam::m_Stat)
			// char* type not supported in LuaBridge
			//.addProperty("m_pReadBuffer", &FkDynamicParam::m_pReadBuffer)
			// char* type not supported in LuaBridge
			//.addProperty("m_pReadHead", &FkDynamicParam::m_pReadHead)
			.addProperty("m_BufferSize", &FkDynamicParam::m_BufferSize)
			.addProperty("m_HeadSize", &FkDynamicParam::m_HeadSize)
			.addProperty("m_boEOF", &FkDynamicParam::m_boEOF)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkDynamicParam::m_DP) == 20, "expected FkDynamicParam::m_DP to be size 20");
static_assert(sizeof(FkDynamicParam::m_StrFilePath) == 260, "expected FkDynamicParam::m_StrFilePath to be size 260");
static_assert(sizeof(FkDynamicParam::m_nParam) == 4, "expected FkDynamicParam::m_nParam to be size 4");
static_assert(sizeof(FkDynamicParam::m_Stat) == 4, "expected FkDynamicParam::m_Stat to be size 4");
static_assert(sizeof(FkDynamicParam::m_pReadBuffer) == 4, "expected FkDynamicParam::m_pReadBuffer to be size 4");
static_assert(sizeof(FkDynamicParam::m_pReadHead) == 4, "expected FkDynamicParam::m_pReadHead to be size 4");
static_assert(sizeof(FkDynamicParam::m_BufferSize) == 4, "expected FkDynamicParam::m_BufferSize to be size 4");
static_assert(sizeof(FkDynamicParam::m_HeadSize) == 4, "expected FkDynamicParam::m_HeadSize to be size 4");
static_assert(sizeof(FkDynamicParam::m_boEOF) == 1, "expected FkDynamicParam::m_boEOF to be size 1");
static_assert(sizeof(FkDynamicParam) == 0x134, "expected FkDynamicParam to be size 0x134");

// [Structure] class FkObstacleSensor
class FkObstacleSensor
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[52];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class FkObstacleSensor [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkObstacleSensor& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkObstacleSensor>("FkObstacleSensor")
			.addFunction("__tostring", &FkObstacleSensor::ToString)
			.addFunction("GetPtrAddr", &FkObstacleSensor::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkObstacleSensor) == 0x34, "expected FkObstacleSensor to be size 0x34");

// [Structure] class FkBulletManager
class FkBulletManager
{
public:
	// [Structure] struct FkBulletManager::stEfBullet
	struct stEfBullet
	{
	public:
		/// Struct member variables

		// <uint8_t fireFlag, offset 0x0>
		uint8_t fireFlag = 0;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData_1[3];

	public:
		// <class HrTask* pTask, offset 0x4>
		class HrTask* pTask = nullptr;

		// <struct tagHRTASKCHECK taskCheckBullet, offset 0x8>
		struct tagHRTASKCHECK taskCheckBullet;

		// <class EffectFkTobiDoguBase* pTobiDoguBase, offset 0x10>
		class EffectFkTobiDoguBase* pTobiDoguBase = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct FkBulletManager::stEfBullet [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(FkBulletManager::stEfBullet& InObject)
		{
			fireFlag = InObject.fireFlag;
			pTask = InObject.pTask;
			taskCheckBullet = InObject.taskCheckBullet;
			pTobiDoguBase = InObject.pTobiDoguBase;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<stEfBullet>("FkBulletManager_stEfBullet")
				.addFunction("__tostring", &FkBulletManager::stEfBullet::ToString)
				.addFunction("GetPtrAddr", &FkBulletManager::stEfBullet::GetPtrAddr)
				.addProperty("fireFlag", &FkBulletManager::stEfBullet::fireFlag)
				.addProperty("pTask", &FkBulletManager::stEfBullet::pTask)
				.addProperty("taskCheckBullet", &FkBulletManager::stEfBullet::taskCheckBullet)
				.addProperty("pTobiDoguBase", &FkBulletManager::stEfBullet::pTobiDoguBase)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBulletManager::stEfBullet::fireFlag) == 1, "expected FkBulletManager::stEfBullet::fireFlag to be size 1");
	static_assert(sizeof(FkBulletManager::stEfBullet::pTask) == 4, "expected FkBulletManager::stEfBullet::pTask to be size 4");
	static_assert(sizeof(FkBulletManager::stEfBullet::taskCheckBullet) == 8, "expected FkBulletManager::stEfBullet::taskCheckBullet to be size 8");
	static_assert(sizeof(FkBulletManager::stEfBullet::pTobiDoguBase) == 4, "expected FkBulletManager::stEfBullet::pTobiDoguBase to be size 4");
	static_assert(sizeof(FkBulletManager::stEfBullet) == 0x14, "expected FkBulletManager::stEfBullet to be size 0x14");

	// [Structure] struct FkBulletManager::DmgInfo
	struct DmgInfo
	{
	public:
		/// Struct member variables

		// <float fDmg, offset 0x0>
		float fDmg = 0;

		// <float fKnockBack, offset 0x4>
		float fKnockBack = 0;

		// <int32_t AtkKind, offset 0x8>
		int32_t AtkKind = 0;

		// <float fSubBatteryRatio, offset 0xc>
		float fSubBatteryRatio = 0;

		// <uint8_t boDownAtk, offset 0x10>
		uint8_t boDownAtk = 0;

		// <Unidentified data segment, offset 0x11>
	private:
		char _UnidentifiedData_17[3];

	public:
		// <class mHRChara* pOwner, offset 0x14>
		class mHRChara* pOwner = nullptr;

		// <int32_t CharaHitSeID, offset 0x18>
		int32_t CharaHitSeID = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct FkBulletManager::DmgInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(FkBulletManager::DmgInfo& InObject)
		{
			fDmg = InObject.fDmg;
			fKnockBack = InObject.fKnockBack;
			AtkKind = InObject.AtkKind;
			fSubBatteryRatio = InObject.fSubBatteryRatio;
			boDownAtk = InObject.boDownAtk;
			pOwner = InObject.pOwner;
			CharaHitSeID = InObject.CharaHitSeID;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<DmgInfo>("FkBulletManager_DmgInfo")
				.addFunction("__tostring", &FkBulletManager::DmgInfo::ToString)
				.addFunction("GetPtrAddr", &FkBulletManager::DmgInfo::GetPtrAddr)
				.addProperty("fDmg", &FkBulletManager::DmgInfo::fDmg)
				.addProperty("fKnockBack", &FkBulletManager::DmgInfo::fKnockBack)
				.addProperty("AtkKind", &FkBulletManager::DmgInfo::AtkKind)
				.addProperty("fSubBatteryRatio", &FkBulletManager::DmgInfo::fSubBatteryRatio)
				.addProperty("boDownAtk", &FkBulletManager::DmgInfo::boDownAtk)
				.addProperty("pOwner", &FkBulletManager::DmgInfo::pOwner)
				.addProperty("CharaHitSeID", &FkBulletManager::DmgInfo::CharaHitSeID)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBulletManager::DmgInfo::fDmg) == 4, "expected FkBulletManager::DmgInfo::fDmg to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::fKnockBack) == 4, "expected FkBulletManager::DmgInfo::fKnockBack to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::AtkKind) == 4, "expected FkBulletManager::DmgInfo::AtkKind to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::fSubBatteryRatio) == 4, "expected FkBulletManager::DmgInfo::fSubBatteryRatio to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::boDownAtk) == 1, "expected FkBulletManager::DmgInfo::boDownAtk to be size 1");
	static_assert(sizeof(FkBulletManager::DmgInfo::pOwner) == 4, "expected FkBulletManager::DmgInfo::pOwner to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::CharaHitSeID) == 4, "expected FkBulletManager::DmgInfo::CharaHitSeID to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo) == 0x1c, "expected FkBulletManager::DmgInfo to be size 0x1c");

	/// Struct member variables

	// <class FkStlVector<FkBulletManager::stEfBullet> mEfBulletArr, offset 0x0>
	class FkStlVector<FkBulletManager::stEfBullet> mEfBulletArr;

	// <int32_t m_nBulletMax, offset 0x14>
	int32_t m_nBulletMax = 0;

	// <struct FkBulletManager::DmgInfo m_DmgInfo, offset 0x18>
	struct FkBulletManager::DmgInfo m_DmgInfo;

	/// 1 Functions

	// [Function] void __convention("thiscall") FkBulletManager::AddManageBullet(class FkBulletManager* const this, class HrTask* arg2, class EffectFkTobiDoguBase* arg3, class mHRChara* arg4, float arg5, float arg6, int32_t arg7, float arg8, uint8_t arg9, int32_t arg10) [?AddManageBullet@FkBulletManager@@QAEXPAVHrTask@@PAVEffectFkTobiDoguBase@@PAVmHRChara@@MMHM_NH@Z]
	typedef void(__thiscall* _AddManageBullet_FkBulletManager__QAEXPAVHrTask__PAVEffectFkTobiDoguBase__PAVmHRChara__MMHM_NH_Z)(class FkBulletManager* const thisPtr, class HrTask* arg2, class EffectFkTobiDoguBase* arg3, class mHRChara* arg4, float arg5, float arg6, int32_t arg7, float arg8, uint8_t arg9, int32_t arg10);
	void AddManageBullet(class HrTask* arg2, class EffectFkTobiDoguBase* arg3, class mHRChara* arg4, float arg5, float arg6, int32_t arg7, float arg8, uint8_t arg9, int32_t arg10)
	{
		_AddManageBullet_FkBulletManager__QAEXPAVHrTask__PAVEffectFkTobiDoguBase__PAVmHRChara__MMHM_NH_Z mFunc = (_AddManageBullet_FkBulletManager__QAEXPAVHrTask__PAVEffectFkTobiDoguBase__PAVmHRChara__MMHM_NH_Z)(GameModule + 0x5d03f0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class FkBulletManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkBulletManager& InObject)
	{
		mEfBulletArr = InObject.mEfBulletArr;
		m_nBulletMax = InObject.m_nBulletMax;
		m_DmgInfo = InObject.m_DmgInfo;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkBulletManager>("FkBulletManager")
			.addFunction("__tostring", &FkBulletManager::ToString)
			.addFunction("GetPtrAddr", &FkBulletManager::GetPtrAddr)
			.addProperty("mEfBulletArr", &FkBulletManager::mEfBulletArr)
			.addProperty("m_nBulletMax", &FkBulletManager::m_nBulletMax)
			.addProperty("m_DmgInfo", &FkBulletManager::m_DmgInfo)
			.addFunction("AddManageBullet", &FkBulletManager::AddManageBullet)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkBulletManager::mEfBulletArr) == 20, "expected FkBulletManager::mEfBulletArr to be size 20");
static_assert(sizeof(FkBulletManager::m_nBulletMax) == 4, "expected FkBulletManager::m_nBulletMax to be size 4");
static_assert(sizeof(FkBulletManager::m_DmgInfo) == 28, "expected FkBulletManager::m_DmgInfo to be size 28");
static_assert(sizeof(FkBulletManager) == 0x34, "expected FkBulletManager to be size 0x34");

// [Structure] class EffectFkTobiDoguBase
class EffectFkTobiDoguBase
{
public:
	// [Structure] struct EffectFkTobiDoguBase::strHitCheck
	struct strHitCheck
	{
	public:
		/// Struct member variables

		// <float fTgtRadius, offset 0x0>
		float fTgtRadius = 0;

		// <struct Vec* pTgtPos, offset 0x4>
		struct Vec* pTgtPos = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectFkTobiDoguBase::strHitCheck [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectFkTobiDoguBase::strHitCheck& InObject)
		{
			fTgtRadius = InObject.fTgtRadius;
			pTgtPos = InObject.pTgtPos;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<strHitCheck>("EffectFkTobiDoguBase_strHitCheck")
				.addFunction("__tostring", &EffectFkTobiDoguBase::strHitCheck::ToString)
				.addFunction("GetPtrAddr", &EffectFkTobiDoguBase::strHitCheck::GetPtrAddr)
				.addProperty("fTgtRadius", &EffectFkTobiDoguBase::strHitCheck::fTgtRadius)
				.addProperty("pTgtPos", &EffectFkTobiDoguBase::strHitCheck::pTgtPos)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFkTobiDoguBase::strHitCheck::fTgtRadius) == 4, "expected EffectFkTobiDoguBase::strHitCheck::fTgtRadius to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::strHitCheck::pTgtPos) == 4, "expected EffectFkTobiDoguBase::strHitCheck::pTgtPos to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::strHitCheck) == 0x8, "expected EffectFkTobiDoguBase::strHitCheck to be size 0x8");

	// enum EffectFkTobiDoguBase::eHitObjType
	enum eHitObjType : uint32_t
	{
		// <eHitObjType_Unknown = 0xffffffffffffffff>
		eHitObjType_Unknown = UINT32_MAX,

		// <eHitObjType_Stage = 0x0>
		eHitObjType_Stage = 0,

		// <eHitObjType_Char = 0x1>
		eHitObjType_Char = 1

	};

	// [Structure] struct EffectFkTobiDoguBase::HitObjInfo
	struct HitObjInfo
	{
	public:
		/// Struct member variables

		// <uint8_t boHit, offset 0x0>
		uint8_t boHit = 0;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData_1[3];

	public:
		// <enum EffectFkTobiDoguBase::eHitObjType eHitObjType, offset 0x4>
		enum eHitObjType eHitObjType;

		// <struct Vec HitPos, offset 0x8>
		struct Vec HitPos;

		// <float fSqDistFromLaunch, offset 0x14>
		float fSqDistFromLaunch = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectFkTobiDoguBase::HitObjInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectFkTobiDoguBase::HitObjInfo& InObject)
		{
			boHit = InObject.boHit;
			eHitObjType = InObject.eHitObjType;
			HitPos = InObject.HitPos;
			fSqDistFromLaunch = InObject.fSqDistFromLaunch;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<HitObjInfo>("EffectFkTobiDoguBase_HitObjInfo")
				.addFunction("__tostring", &EffectFkTobiDoguBase::HitObjInfo::ToString)
				.addFunction("GetPtrAddr", &EffectFkTobiDoguBase::HitObjInfo::GetPtrAddr)
				.addProperty("boHit", &EffectFkTobiDoguBase::HitObjInfo::boHit)
				.addProperty("eHitObjType", &EffectFkTobiDoguBase::HitObjInfo::eHitObjType)
				.addProperty("HitPos", &EffectFkTobiDoguBase::HitObjInfo::HitPos)
				.addProperty("fSqDistFromLaunch", &EffectFkTobiDoguBase::HitObjInfo::fSqDistFromLaunch)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::boHit) == 1, "expected EffectFkTobiDoguBase::HitObjInfo::boHit to be size 1");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::eHitObjType) == 4, "expected EffectFkTobiDoguBase::HitObjInfo::eHitObjType to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::HitPos) == 12, "expected EffectFkTobiDoguBase::HitObjInfo::HitPos to be size 12");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::fSqDistFromLaunch) == 4, "expected EffectFkTobiDoguBase::HitObjInfo::fSqDistFromLaunch to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo) == 0x18, "expected EffectFkTobiDoguBase::HitObjInfo to be size 0x18");

	/// Struct member variables

	// <void* (* field_0)[0x3], offset 0x0>
	void* (* field_0)[0x3];

	// <uint8_t m_Flag, offset 0x4>
	uint8_t m_Flag = 0;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	// <float m_TimeCount, offset 0x8>
	float m_TimeCount = 0;

	// <float m_TimeRate, offset 0xc>
	float m_TimeRate = 0;

	// <uint32_t m_Counter, offset 0x10>
	uint32_t m_Counter = 0;

	// <int32_t m_PcDmgMotNo, offset 0x14>
	int32_t m_PcDmgMotNo = 0;

	// <int32_t m_PcGrdMotNo, offset 0x18>
	int32_t m_PcGrdMotNo = 0;

	// <float m_Damage, offset 0x1c>
	float m_Damage = 0;

	// <float m_RotY, offset 0x20>
	float m_RotY = 0;

	// <struct Vec m_TgtPos, offset 0x24>
	struct Vec m_TgtPos;

	// <float m_Speed, offset 0x30>
	float m_Speed = 0;

	// <float m_BackBlow, offset 0x34>
	float m_BackBlow = 0;

	// <uint8_t m_Reverse, offset 0x38>
	uint8_t m_Reverse = 0;

	// <uint8_t m_bHitExp, offset 0x39>
	uint8_t m_bHitExp = 0;

	// <uint8_t m_boDeleteRequest, offset 0x3a>
	uint8_t m_boDeleteRequest = 0;

	// <Unidentified data segment, offset 0x3b>
private:
	char _UnidentifiedData_59[1];

public:
	// <struct Vec m_LancPos, offset 0x3c>
	struct Vec m_LancPos;

	// <struct Vec m_Pos, offset 0x48>
	struct Vec m_Pos;

	// <struct Vec m_MoveVec, offset 0x54>
	struct Vec m_MoveVec;

	// <struct Vec m_BeforePos, offset 0x60>
	struct Vec m_BeforePos;

	// <struct Vec m_MoveDir, offset 0x6c>
	struct Vec m_MoveDir;

	// <class EffectGunTrack* m_pGunTrack, offset 0x78>
	class EffectGunTrack* m_pGunTrack = nullptr;

	// <struct tagHRTASKCHECK m_TrackCheck, offset 0x7c>
	struct tagHRTASKCHECK m_TrackCheck;

	// <struct Vec m_DbgColSegA, offset 0x84>
	struct Vec m_DbgColSegA;

	// <struct Vec m_DbgColSegB, offset 0x90>
	struct Vec m_DbgColSegB;

	// <int32_t mStgHitSeID, offset 0x9c>
	int32_t mStgHitSeID = 0;

	// <struct EffectFkTobiDoguBase::strHitCheck m_HitCheckInfo, offset 0xa0>
	struct EffectFkTobiDoguBase::strHitCheck m_HitCheckInfo;

	// <class WGcl* m_pGcl, offset 0xa8>
	class WGcl* m_pGcl = nullptr;

	// <struct EffectFkTobiDoguBase::HitObjInfo m_HitInfo, offset 0xac>
	struct EffectFkTobiDoguBase::HitObjInfo m_HitInfo;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectFkTobiDoguBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectFkTobiDoguBase& InObject)
	{
		m_Flag = InObject.m_Flag;
		m_TimeCount = InObject.m_TimeCount;
		m_TimeRate = InObject.m_TimeRate;
		m_Counter = InObject.m_Counter;
		m_PcDmgMotNo = InObject.m_PcDmgMotNo;
		m_PcGrdMotNo = InObject.m_PcGrdMotNo;
		m_Damage = InObject.m_Damage;
		m_RotY = InObject.m_RotY;
		m_TgtPos = InObject.m_TgtPos;
		m_Speed = InObject.m_Speed;
		m_BackBlow = InObject.m_BackBlow;
		m_Reverse = InObject.m_Reverse;
		m_bHitExp = InObject.m_bHitExp;
		m_boDeleteRequest = InObject.m_boDeleteRequest;
		m_LancPos = InObject.m_LancPos;
		m_Pos = InObject.m_Pos;
		m_MoveVec = InObject.m_MoveVec;
		m_BeforePos = InObject.m_BeforePos;
		m_MoveDir = InObject.m_MoveDir;
		m_pGunTrack = InObject.m_pGunTrack;
		m_TrackCheck = InObject.m_TrackCheck;
		m_DbgColSegA = InObject.m_DbgColSegA;
		m_DbgColSegB = InObject.m_DbgColSegB;
		mStgHitSeID = InObject.mStgHitSeID;
		m_HitCheckInfo = InObject.m_HitCheckInfo;
		m_pGcl = InObject.m_pGcl;
		m_HitInfo = InObject.m_HitInfo;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectFkTobiDoguBase>("EffectFkTobiDoguBase")
			.addFunction("__tostring", &EffectFkTobiDoguBase::ToString)
			.addFunction("GetPtrAddr", &EffectFkTobiDoguBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &EffectFkTobiDoguBase::field_0)
			.addProperty("m_Flag", &EffectFkTobiDoguBase::m_Flag)
			.addProperty("m_TimeCount", &EffectFkTobiDoguBase::m_TimeCount)
			.addProperty("m_TimeRate", &EffectFkTobiDoguBase::m_TimeRate)
			.addProperty("m_Counter", &EffectFkTobiDoguBase::m_Counter)
			.addProperty("m_PcDmgMotNo", &EffectFkTobiDoguBase::m_PcDmgMotNo)
			.addProperty("m_PcGrdMotNo", &EffectFkTobiDoguBase::m_PcGrdMotNo)
			.addProperty("m_Damage", &EffectFkTobiDoguBase::m_Damage)
			.addProperty("m_RotY", &EffectFkTobiDoguBase::m_RotY)
			.addProperty("m_TgtPos", &EffectFkTobiDoguBase::m_TgtPos)
			.addProperty("m_Speed", &EffectFkTobiDoguBase::m_Speed)
			.addProperty("m_BackBlow", &EffectFkTobiDoguBase::m_BackBlow)
			.addProperty("m_Reverse", &EffectFkTobiDoguBase::m_Reverse)
			.addProperty("m_bHitExp", &EffectFkTobiDoguBase::m_bHitExp)
			.addProperty("m_boDeleteRequest", &EffectFkTobiDoguBase::m_boDeleteRequest)
			.addProperty("m_LancPos", &EffectFkTobiDoguBase::m_LancPos)
			.addProperty("m_Pos", &EffectFkTobiDoguBase::m_Pos)
			.addProperty("m_MoveVec", &EffectFkTobiDoguBase::m_MoveVec)
			.addProperty("m_BeforePos", &EffectFkTobiDoguBase::m_BeforePos)
			.addProperty("m_MoveDir", &EffectFkTobiDoguBase::m_MoveDir)
			.addProperty("m_pGunTrack", &EffectFkTobiDoguBase::m_pGunTrack)
			.addProperty("m_TrackCheck", &EffectFkTobiDoguBase::m_TrackCheck)
			.addProperty("m_DbgColSegA", &EffectFkTobiDoguBase::m_DbgColSegA)
			.addProperty("m_DbgColSegB", &EffectFkTobiDoguBase::m_DbgColSegB)
			.addProperty("mStgHitSeID", &EffectFkTobiDoguBase::mStgHitSeID)
			.addProperty("m_HitCheckInfo", &EffectFkTobiDoguBase::m_HitCheckInfo)
			.addProperty("m_pGcl", &EffectFkTobiDoguBase::m_pGcl)
			.addProperty("m_HitInfo", &EffectFkTobiDoguBase::m_HitInfo)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectFkTobiDoguBase::field_0) == 4, "expected EffectFkTobiDoguBase::field_0 to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Flag) == 1, "expected EffectFkTobiDoguBase::m_Flag to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_TimeCount) == 4, "expected EffectFkTobiDoguBase::m_TimeCount to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TimeRate) == 4, "expected EffectFkTobiDoguBase::m_TimeRate to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Counter) == 4, "expected EffectFkTobiDoguBase::m_Counter to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_PcDmgMotNo) == 4, "expected EffectFkTobiDoguBase::m_PcDmgMotNo to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_PcGrdMotNo) == 4, "expected EffectFkTobiDoguBase::m_PcGrdMotNo to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Damage) == 4, "expected EffectFkTobiDoguBase::m_Damage to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_RotY) == 4, "expected EffectFkTobiDoguBase::m_RotY to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TgtPos) == 12, "expected EffectFkTobiDoguBase::m_TgtPos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_Speed) == 4, "expected EffectFkTobiDoguBase::m_Speed to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_BackBlow) == 4, "expected EffectFkTobiDoguBase::m_BackBlow to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Reverse) == 1, "expected EffectFkTobiDoguBase::m_Reverse to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_bHitExp) == 1, "expected EffectFkTobiDoguBase::m_bHitExp to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_boDeleteRequest) == 1, "expected EffectFkTobiDoguBase::m_boDeleteRequest to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_LancPos) == 12, "expected EffectFkTobiDoguBase::m_LancPos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_Pos) == 12, "expected EffectFkTobiDoguBase::m_Pos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_MoveVec) == 12, "expected EffectFkTobiDoguBase::m_MoveVec to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_BeforePos) == 12, "expected EffectFkTobiDoguBase::m_BeforePos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_MoveDir) == 12, "expected EffectFkTobiDoguBase::m_MoveDir to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_pGunTrack) == 4, "expected EffectFkTobiDoguBase::m_pGunTrack to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TrackCheck) == 8, "expected EffectFkTobiDoguBase::m_TrackCheck to be size 8");
static_assert(sizeof(EffectFkTobiDoguBase::m_DbgColSegA) == 12, "expected EffectFkTobiDoguBase::m_DbgColSegA to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_DbgColSegB) == 12, "expected EffectFkTobiDoguBase::m_DbgColSegB to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::mStgHitSeID) == 4, "expected EffectFkTobiDoguBase::mStgHitSeID to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_HitCheckInfo) == 8, "expected EffectFkTobiDoguBase::m_HitCheckInfo to be size 8");
static_assert(sizeof(EffectFkTobiDoguBase::m_pGcl) == 4, "expected EffectFkTobiDoguBase::m_pGcl to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_HitInfo) == 24, "expected EffectFkTobiDoguBase::m_HitInfo to be size 24");
static_assert(sizeof(EffectFkTobiDoguBase) == 0xc4, "expected EffectFkTobiDoguBase to be size 0xc4");

// [Structure] class rQuadEx
class rQuadEx
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[220];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rQuadEx [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rQuadEx& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rQuadEx>("rQuadEx")
			.addFunction("__tostring", &rQuadEx::ToString)
			.addFunction("GetPtrAddr", &rQuadEx::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(rQuadEx) == 0xdc, "expected rQuadEx to be size 0xdc");

// [Structure] class BoneStreamObj
class BoneStreamObj
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[220];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class BoneStreamObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(BoneStreamObj& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<BoneStreamObj>("BoneStreamObj")
			.addFunction("__tostring", &BoneStreamObj::ToString)
			.addFunction("GetPtrAddr", &BoneStreamObj::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(BoneStreamObj) == 0xdc, "expected BoneStreamObj to be size 0xdc");

// [Structure] class EffectGunTrack
class EffectGunTrack : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag = 0;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData_81[3];

public:
	// <class rPrimUnific m_SmokeUni, offset 0x54>
	class rPrimUnific m_SmokeUni;

	// <class rQuadEx* m_pWidth, offset 0x74>
	class rQuadEx* m_pWidth = nullptr;

	// <class rQuadEx* m_pHeight, offset 0x78>
	class rQuadEx* m_pHeight = nullptr;

	// <class rPrimUnific m_LightUni, offset 0x7c>
	class rPrimUnific m_LightUni;

	// <class rQuadEx m_LightWidth, offset 0x9c>
	class rQuadEx m_LightWidth;

	// <class rQuadEx m_LightHeight, offset 0x178>
	class rQuadEx m_LightHeight;

	// <struct Vec* m_pSlashPoint, offset 0x254>
	struct Vec* m_pSlashPoint = nullptr;

	// <uint32_t m_PointAddCount, offset 0x258>
	uint32_t m_PointAddCount = 0;

	// <uint32_t m_MaxPoint, offset 0x25c>
	uint32_t m_MaxPoint = 0;

	// <uint32_t m_PolyMax, offset 0x260>
	uint32_t m_PolyMax = 0;

	// <uint32_t m_DeleteCount, offset 0x264>
	uint32_t m_DeleteCount = 0;

	// <float m_RotY, offset 0x268>
	float m_RotY = 0;

	// <float m_Scale, offset 0x26c>
	float m_Scale = 0;

	// <float m_Anime, offset 0x270>
	float m_Anime = 0;

	// <float* m_RandU, offset 0x274>
	float* m_RandU = nullptr;

	// <float m_OnePiece, offset 0x278>
	float m_OnePiece = 0;

	// <float m_TimeCount, offset 0x27c>
	float m_TimeCount = 0;

	// <int32_t m_TimeFrame, offset 0x280>
	int32_t m_TimeFrame = 0;

	// <float m_TimeRate, offset 0x284>
	float m_TimeRate = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectGunTrack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectGunTrack& InObject)
	{
		m_Flag = InObject.m_Flag;
		m_SmokeUni = InObject.m_SmokeUni;
		m_pWidth = InObject.m_pWidth;
		m_pHeight = InObject.m_pHeight;
		m_LightUni = InObject.m_LightUni;
		m_LightWidth = InObject.m_LightWidth;
		m_LightHeight = InObject.m_LightHeight;
		m_pSlashPoint = InObject.m_pSlashPoint;
		m_PointAddCount = InObject.m_PointAddCount;
		m_MaxPoint = InObject.m_MaxPoint;
		m_PolyMax = InObject.m_PolyMax;
		m_DeleteCount = InObject.m_DeleteCount;
		m_RotY = InObject.m_RotY;
		m_Scale = InObject.m_Scale;
		m_Anime = InObject.m_Anime;
		m_RandU = InObject.m_RandU;
		m_OnePiece = InObject.m_OnePiece;
		m_TimeCount = InObject.m_TimeCount;
		m_TimeFrame = InObject.m_TimeFrame;
		m_TimeRate = InObject.m_TimeRate;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectGunTrack, HrTask>("EffectGunTrack")
			.addFunction("__tostring", &EffectGunTrack::ToString)
			.addFunction("GetPtrAddr", &EffectGunTrack::GetPtrAddr)
			.addProperty("m_Flag", &EffectGunTrack::m_Flag)
			.addProperty("m_SmokeUni", &EffectGunTrack::m_SmokeUni)
			.addProperty("m_pWidth", &EffectGunTrack::m_pWidth)
			.addProperty("m_pHeight", &EffectGunTrack::m_pHeight)
			.addProperty("m_LightUni", &EffectGunTrack::m_LightUni)
			.addProperty("m_LightWidth", &EffectGunTrack::m_LightWidth)
			.addProperty("m_LightHeight", &EffectGunTrack::m_LightHeight)
			.addProperty("m_pSlashPoint", &EffectGunTrack::m_pSlashPoint)
			.addProperty("m_PointAddCount", &EffectGunTrack::m_PointAddCount)
			.addProperty("m_MaxPoint", &EffectGunTrack::m_MaxPoint)
			.addProperty("m_PolyMax", &EffectGunTrack::m_PolyMax)
			.addProperty("m_DeleteCount", &EffectGunTrack::m_DeleteCount)
			.addProperty("m_RotY", &EffectGunTrack::m_RotY)
			.addProperty("m_Scale", &EffectGunTrack::m_Scale)
			.addProperty("m_Anime", &EffectGunTrack::m_Anime)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_RandU", &EffectGunTrack::m_RandU)
			.addProperty("m_OnePiece", &EffectGunTrack::m_OnePiece)
			.addProperty("m_TimeCount", &EffectGunTrack::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectGunTrack::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectGunTrack::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectGunTrack::m_Flag) == 1, "expected EffectGunTrack::m_Flag to be size 1");
static_assert(sizeof(EffectGunTrack::m_SmokeUni) == 32, "expected EffectGunTrack::m_SmokeUni to be size 32");
static_assert(sizeof(EffectGunTrack::m_pWidth) == 4, "expected EffectGunTrack::m_pWidth to be size 4");
static_assert(sizeof(EffectGunTrack::m_pHeight) == 4, "expected EffectGunTrack::m_pHeight to be size 4");
static_assert(sizeof(EffectGunTrack::m_LightUni) == 32, "expected EffectGunTrack::m_LightUni to be size 32");
static_assert(sizeof(EffectGunTrack::m_LightWidth) == 220, "expected EffectGunTrack::m_LightWidth to be size 220");
static_assert(sizeof(EffectGunTrack::m_LightHeight) == 220, "expected EffectGunTrack::m_LightHeight to be size 220");
static_assert(sizeof(EffectGunTrack::m_pSlashPoint) == 4, "expected EffectGunTrack::m_pSlashPoint to be size 4");
static_assert(sizeof(EffectGunTrack::m_PointAddCount) == 4, "expected EffectGunTrack::m_PointAddCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_MaxPoint) == 4, "expected EffectGunTrack::m_MaxPoint to be size 4");
static_assert(sizeof(EffectGunTrack::m_PolyMax) == 4, "expected EffectGunTrack::m_PolyMax to be size 4");
static_assert(sizeof(EffectGunTrack::m_DeleteCount) == 4, "expected EffectGunTrack::m_DeleteCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_RotY) == 4, "expected EffectGunTrack::m_RotY to be size 4");
static_assert(sizeof(EffectGunTrack::m_Scale) == 4, "expected EffectGunTrack::m_Scale to be size 4");
static_assert(sizeof(EffectGunTrack::m_Anime) == 4, "expected EffectGunTrack::m_Anime to be size 4");
static_assert(sizeof(EffectGunTrack::m_RandU) == 4, "expected EffectGunTrack::m_RandU to be size 4");
static_assert(sizeof(EffectGunTrack::m_OnePiece) == 4, "expected EffectGunTrack::m_OnePiece to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeCount) == 4, "expected EffectGunTrack::m_TimeCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeFrame) == 4, "expected EffectGunTrack::m_TimeFrame to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeRate) == 4, "expected EffectGunTrack::m_TimeRate to be size 4");
static_assert(sizeof(EffectGunTrack) == 0x288, "expected EffectGunTrack to be size 0x288");

// [Structure] class mot::CBoneEffectDamageData
namespace mot
{
	class CBoneEffectDamageData
	{
	public:
		// enum mot::CBoneEffectDamageData::EAttackType
		enum EAttackType : uint32_t
		{
			// <ATTACK_TYPE_NONE = 0x0>
			ATTACK_TYPE_NONE = 0,

			// <ATTACK_TYPE_STRAIGHT = 0x1>
			ATTACK_TYPE_STRAIGHT = 1,

			// <ATTACK_TYPE_LEFT_STRAIGHT = 0x2>
			ATTACK_TYPE_LEFT_STRAIGHT = 2,

			// <ATTACK_TYPE_RIGHT_STRAIGHT = 0x3>
			ATTACK_TYPE_RIGHT_STRAIGHT = 3,

			// <ATTACK_TYPE_LEFT_HOOK = 0x4>
			ATTACK_TYPE_LEFT_HOOK = 4,

			// <ATTACK_TYPE_RIGHT_HOOK = 0x5>
			ATTACK_TYPE_RIGHT_HOOK = 5,

			// <ATTACK_TYPE_UPPER = 0x6>
			ATTACK_TYPE_UPPER = 6,

			// <ATTACK_TYPE_LEFT_UPPER = 0x7>
			ATTACK_TYPE_LEFT_UPPER = 7,

			// <ATTACK_TYPE_RIGHT_UPPER = 0x8>
			ATTACK_TYPE_RIGHT_UPPER = 8,

			// <ATTACK_TYPE_CHOP = 0x9>
			ATTACK_TYPE_CHOP = 9,

			// <ATTACK_TYPE_LEFT_CHOP = 0xa>
			ATTACK_TYPE_LEFT_CHOP = 10,

			// <ATTACK_TYPE_RIGHT_CHOP = 0xb>
			ATTACK_TYPE_RIGHT_CHOP = 11

		};

		// enum mot::CBoneEffectDamageData::EAttackPart
		enum EAttackPart : uint32_t
		{
			// <ATTACK_PART_FACE = 0x0>
			ATTACK_PART_FACE = 0,

			// <ATTACK_PART_BODY = 0x1>
			ATTACK_PART_BODY = 1,

			// <ATTACK_PART_FOOT = 0x2>
			ATTACK_PART_FOOT = 2

		};

		/// Struct member variables

		// <uint8_t m_bIsHit, offset 0x0>
		uint8_t m_bIsHit = 0;

		// <uint8_t m_bIsSuccessDefense, offset 0x1>
		uint8_t m_bIsSuccessDefense = 0;

		// <uint8_t m_bIsKeepMyAttack, offset 0x2>
		uint8_t m_bIsKeepMyAttack = 0;

		// <Unidentified data segment, offset 0x3>
	private:
		char _UnidentifiedData_3[1];

	public:
		// <class mHRChara* m_pAttackChara, offset 0x4>
		class mHRChara* m_pAttackChara = nullptr;

		// <enum mot::CBoneEffectDamageData::EAttackType m_eAttackType, offset 0x8>
		enum CBoneEffectDamageData::EAttackType m_eAttackType;

		// <enum mot::CBoneEffectDamageData::EAttackPart m_eAttackPart, offset 0xc>
		enum CBoneEffectDamageData::EAttackPart m_eAttackPart;

		/// 1 Functions

		// [Function] void __convention("thiscall") mot::CBoneEffectDamageData::setup(class mot::CBoneEffectDamageData* const this, class mHRChara* arg2) [?setup@CBoneEffectDamageData@mot@@QAEXPBVmHRChara@@@Z]
		typedef void(__thiscall* _setup_CBoneEffectDamageData_mot__QAEXPBVmHRChara___Z)(class mot::CBoneEffectDamageData* const thisPtr, class mHRChara* arg2);
		void setup(class mHRChara* arg2)
		{
			_setup_CBoneEffectDamageData_mot__QAEXPBVmHRChara___Z mFunc = (_setup_CBoneEffectDamageData_mot__QAEXPBVmHRChara___Z)(GameModule + 0xabfa0);
			return mFunc(this, arg2);
		}
		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::CBoneEffectDamageData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::CBoneEffectDamageData& InObject)
		{
			m_bIsHit = InObject.m_bIsHit;
			m_bIsSuccessDefense = InObject.m_bIsSuccessDefense;
			m_bIsKeepMyAttack = InObject.m_bIsKeepMyAttack;
			m_pAttackChara = InObject.m_pAttackChara;
			m_eAttackType = InObject.m_eAttackType;
			m_eAttackPart = InObject.m_eAttackPart;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CBoneEffectDamageData>("mot_CBoneEffectDamageData")
				.addFunction("__tostring", &mot::CBoneEffectDamageData::ToString)
				.addFunction("GetPtrAddr", &mot::CBoneEffectDamageData::GetPtrAddr)
				.addProperty("m_bIsHit", &mot::CBoneEffectDamageData::m_bIsHit)
				.addProperty("m_bIsSuccessDefense", &mot::CBoneEffectDamageData::m_bIsSuccessDefense)
				.addProperty("m_bIsKeepMyAttack", &mot::CBoneEffectDamageData::m_bIsKeepMyAttack)
				.addProperty("m_pAttackChara", &mot::CBoneEffectDamageData::m_pAttackChara)
				.addProperty("m_eAttackType", &mot::CBoneEffectDamageData::m_eAttackType)
				.addProperty("m_eAttackPart", &mot::CBoneEffectDamageData::m_eAttackPart)
				.addFunction("setup", &mot::CBoneEffectDamageData::setup)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsHit) == 1, "expected mot::CBoneEffectDamageData::m_bIsHit to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsSuccessDefense) == 1, "expected mot::CBoneEffectDamageData::m_bIsSuccessDefense to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsKeepMyAttack) == 1, "expected mot::CBoneEffectDamageData::m_bIsKeepMyAttack to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_pAttackChara) == 4, "expected mot::CBoneEffectDamageData::m_pAttackChara to be size 4");
static_assert(sizeof(mot::CBoneEffectDamageData::m_eAttackType) == 4, "expected mot::CBoneEffectDamageData::m_eAttackType to be size 4");
static_assert(sizeof(mot::CBoneEffectDamageData::m_eAttackPart) == 4, "expected mot::CBoneEffectDamageData::m_eAttackPart to be size 4");
static_assert(sizeof(mot::CBoneEffectDamageData) == 0x10, "expected mot::CBoneEffectDamageData to be size 0x10");

// enum eWaitType
enum eWaitType : uint32_t
{
	// <eWaitType_RunClose = 0x0>
	eWaitType_RunClose = 0,

	// <eWaitType_GetBehind = 0x1>
	eWaitType_GetBehind = 1,

	// <eWaitType_Num = 0x2>
	eWaitType_Num = 2

};

// [Structure] class PJTateshi
class PJTateshi
{
public:
	// [Structure] struct PJTateshi::HagaDmgInfo
	struct HagaDmgInfo
	{
	public:
		/// Struct member variables

		// <uint8_t boReq, offset 0x0>
		uint8_t boReq = 0;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData_1[3];

	public:
		// <float fDmg, offset 0x4>
		float fDmg = 0;

		// <int32_t DmgDir, offset 0x8>
		int32_t DmgDir = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct PJTateshi::HagaDmgInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(PJTateshi::HagaDmgInfo& InObject)
		{
			boReq = InObject.boReq;
			fDmg = InObject.fDmg;
			DmgDir = InObject.DmgDir;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<HagaDmgInfo>("PJTateshi_HagaDmgInfo")
				.addFunction("__tostring", &PJTateshi::HagaDmgInfo::ToString)
				.addFunction("GetPtrAddr", &PJTateshi::HagaDmgInfo::GetPtrAddr)
				.addProperty("boReq", &PJTateshi::HagaDmgInfo::boReq)
				.addProperty("fDmg", &PJTateshi::HagaDmgInfo::fDmg)
				.addProperty("DmgDir", &PJTateshi::HagaDmgInfo::DmgDir)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJTateshi::HagaDmgInfo::boReq) == 1, "expected PJTateshi::HagaDmgInfo::boReq to be size 1");
	static_assert(sizeof(PJTateshi::HagaDmgInfo::fDmg) == 4, "expected PJTateshi::HagaDmgInfo::fDmg to be size 4");
	static_assert(sizeof(PJTateshi::HagaDmgInfo::DmgDir) == 4, "expected PJTateshi::HagaDmgInfo::DmgDir to be size 4");
	static_assert(sizeof(PJTateshi::HagaDmgInfo) == 0xc, "expected PJTateshi::HagaDmgInfo to be size 0xc");

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[160];

public:
	// <class FkStlList<PJZAKO *> ZakoList, offset 0xa0>
	class FkStlList<PJZAKO *> ZakoList;

	// <Unidentified data segment, offset 0xac>
private:
	char _UnidentifiedData_172[320];

public:
	/// 49 Functions

	// [Function] class PJTateshi* PJTateshi::GetInstance() [?GetInstance@PJTateshi@@SAPAV1@XZ]
	typedef class PJTateshi*(__fastcall* _GetInstance_PJTateshi__SAPAV1_XZ)();
	static class PJTateshi* GetInstance()
	{
		_GetInstance_PJTateshi__SAPAV1_XZ mFunc = (_GetInstance_PJTateshi__SAPAV1_XZ)(GameModule + 0xa23c0);
		return mFunc();
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsPcHagaijime(class PJTateshi* const this) [?IsPcHagaijime@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcHagaijime_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsPcHagaijime()
	{
		_IsPcHagaijime_PJTateshi__QAE_NXZ mFunc = (_IsPcHagaijime_PJTateshi__QAE_NXZ)(GameModule + 0xa23d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::GetPcReleaseFromHagaijimeMotionFlag(class PJTateshi* const this) [?GetPcReleaseFromHagaijimeMotionFlag@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _GetPcReleaseFromHagaijimeMotionFlag_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t GetPcReleaseFromHagaijimeMotionFlag()
	{
		_GetPcReleaseFromHagaijimeMotionFlag_PJTateshi__QAE_NXZ mFunc = (_GetPcReleaseFromHagaijimeMotionFlag_PJTateshi__QAE_NXZ)(GameModule + 0xaabf0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJTateshi::GetBattleEnmNum(class PJTateshi* const this) [?GetBattleEnmNum@PJTateshi@@QAEHXZ]
	typedef int32_t(__thiscall* _GetBattleEnmNum_PJTateshi__QAEHXZ)(class PJTateshi* const thisPtr);
	int32_t GetBattleEnmNum()
	{
		_GetBattleEnmNum_PJTateshi__QAEHXZ mFunc = (_GetBattleEnmNum_PJTateshi__QAEHXZ)(GameModule + 0xb96d0);
		return mFunc(this);
	}
	// [Function] class PJZAKO* __convention("thiscall") PJTateshi::GetLastPcAttackZakoPtr(class PJTateshi* const this) [?GetLastPcAttackZakoPtr@PJTateshi@@QAEPAVPJZAKO@@XZ]
	typedef class PJZAKO*(__thiscall* _GetLastPcAttackZakoPtr_PJTateshi__QAEPAVPJZAKO__XZ)(class PJTateshi* const thisPtr);
	class PJZAKO* GetLastPcAttackZakoPtr()
	{
		_GetLastPcAttackZakoPtr_PJTateshi__QAEPAVPJZAKO__XZ mFunc = (_GetLastPcAttackZakoPtr_PJTateshi__QAEPAVPJZAKO__XZ)(GameModule + 0xbc250);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::SetLastPcAttackZakoPtr(class PJTateshi* const this, class PJZAKO* arg2) [?SetLastPcAttackZakoPtr@PJTateshi@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _SetLastPcAttackZakoPtr_PJTateshi__QAEXPAVPJZAKO___Z)(class PJTateshi* const thisPtr, class PJZAKO* arg2);
	void SetLastPcAttackZakoPtr(class PJZAKO* arg2)
	{
		_SetLastPcAttackZakoPtr_PJTateshi__QAEXPAVPJZAKO___Z mFunc = (_SetLastPcAttackZakoPtr_PJTateshi__QAEXPAVPJZAKO___Z)(GameModule + 0xbc260);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJTateshi::DeleteFromZakoList(class PJTateshi* const this, class PJZAKO* Zako) [?DeleteFromZakoList@PJTateshi@@AAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _DeleteFromZakoList_PJTateshi__AAEXPAVPJZAKO___Z)(class PJTateshi* const thisPtr, class PJZAKO* Zako);
	void DeleteFromZakoList(class PJZAKO* Zako)
	{
		_DeleteFromZakoList_PJTateshi__AAEXPAVPJZAKO___Z mFunc = (_DeleteFromZakoList_PJTateshi__AAEXPAVPJZAKO___Z)(GameModule + 0xbc270);
		return mFunc(this, Zako);
	}
	// [Function] void __convention("thiscall") PJTateshi::SetPcReleaseFromHagaijimeMotionFlag(class PJTateshi* const this, uint8_t arg2) [?SetPcReleaseFromHagaijimeMotionFlag@PJTateshi@@QAEX_N@Z]
	typedef void(__thiscall* _SetPcReleaseFromHagaijimeMotionFlag_PJTateshi__QAEX_N_Z)(class PJTateshi* const thisPtr, uint8_t arg2);
	void SetPcReleaseFromHagaijimeMotionFlag(uint8_t arg2)
	{
		_SetPcReleaseFromHagaijimeMotionFlag_PJTateshi__QAEX_N_Z mFunc = (_SetPcReleaseFromHagaijimeMotionFlag_PJTateshi__QAEX_N_Z)(GameModule + 0xc02f0);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") PJTateshi::GetCirclePcPointPos(class PJTateshi* const this, int32_t arg2) [?GetCirclePcPointPos@PJTateshi@@QAEABUVec@@H@Z]
	typedef struct Vec&(__thiscall* _GetCirclePcPointPos_PJTateshi__QAEABUVec__H_Z)(class PJTateshi* const thisPtr, int32_t arg2);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void GetCirclePcPointPos(int32_t arg2)
	{
		_GetCirclePcPointPos_PJTateshi__QAEABUVec__H_Z mFunc = (_GetCirclePcPointPos_PJTateshi__QAEABUVec__H_Z)(GameModule + 0xd8b50);
		mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJTateshi::ClearCirclePcPoint(class PJTateshi* const this, int32_t arg2) [?ClearCirclePcPoint@PJTateshi@@QAEXH@Z]
	typedef void(__thiscall* _ClearCirclePcPoint_PJTateshi__QAEXH_Z)(class PJTateshi* const thisPtr, int32_t arg2);
	void ClearCirclePcPoint(int32_t arg2)
	{
		_ClearCirclePcPoint_PJTateshi__QAEXH_Z mFunc = (_ClearCirclePcPoint_PJTateshi__QAEXH_Z)(GameModule + 0xd8b60);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsRevengeMissionOver(class PJTateshi* const this) [?IsRevengeMissionOver@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsRevengeMissionOver_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsRevengeMissionOver()
	{
		_IsRevengeMissionOver_PJTateshi__QAE_NXZ mFunc = (_IsRevengeMissionOver_PJTateshi__QAE_NXZ)(GameModule + 0x4b0820);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsNowRevengeMission(class PJTateshi* const this) [?IsNowRevengeMission@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsNowRevengeMission_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsNowRevengeMission()
	{
		_IsNowRevengeMission_PJTateshi__QAE_NXZ mFunc = (_IsNowRevengeMission_PJTateshi__QAE_NXZ)(GameModule + 0x4b0870);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::DebugRender(class PJTateshi* const this) [?DebugRender@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _DebugRender_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void DebugRender()
	{
		_DebugRender_PJTateshi__AAEXXZ mFunc = (_DebugRender_PJTateshi__AAEXXZ)(GameModule + 0x4b08a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::CheckPcPlayExtMotion(class PJTateshi* const this) [?CheckPcPlayExtMotion@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _CheckPcPlayExtMotion_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t CheckPcPlayExtMotion()
	{
		_CheckPcPlayExtMotion_PJTateshi__QAE_NXZ mFunc = (_CheckPcPlayExtMotion_PJTateshi__QAE_NXZ)(GameModule + 0x4b08b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::SubPcNowEquipBatteryRatio(class PJTateshi* const this, float const arg2) [?SubPcNowEquipBatteryRatio@PJTateshi@@QAEXM@Z]
	typedef void(__thiscall* _SubPcNowEquipBatteryRatio_PJTateshi__QAEXM_Z)(class PJTateshi* const thisPtr, float const arg2);
	void SubPcNowEquipBatteryRatio(float const arg2)
	{
		_SubPcNowEquipBatteryRatio_PJTateshi__QAEXM_Z mFunc = (_SubPcNowEquipBatteryRatio_PJTateshi__QAEXM_Z)(GameModule + 0x4b08d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJTateshi::RenderProcess(class PJTateshi* const this) [?RenderProcess@PJTateshi@@QAEXXZ]
	typedef void(__thiscall* _RenderProcess_PJTateshi__QAEXXZ)(class PJTateshi* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_PJTateshi__QAEXXZ mFunc = (_RenderProcess_PJTateshi__QAEXXZ)(GameModule + 0x4b0930);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") PJTateshi::CalcZakoBehindPcNum(class PJTateshi* const this) [?CalcZakoBehindPcNum@PJTateshi@@QAEIXZ]
	typedef uint32_t(__thiscall* _CalcZakoBehindPcNum_PJTateshi__QAEIXZ)(class PJTateshi* const thisPtr);
	uint32_t CalcZakoBehindPcNum()
	{
		_CalcZakoBehindPcNum_PJTateshi__QAEIXZ mFunc = (_CalcZakoBehindPcNum_PJTateshi__QAEIXZ)(GameModule + 0x4b0940);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsPcFuttobiOrDown(class PJTateshi* const this) [?IsPcFuttobiOrDown@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcFuttobiOrDown_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsPcFuttobiOrDown()
	{
		_IsPcFuttobiOrDown_PJTateshi__QAE_NXZ mFunc = (_IsPcFuttobiOrDown_PJTateshi__QAE_NXZ)(GameModule + 0x4b0980);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsPcAttackHitFrm(class PJTateshi* const this) [?IsPcAttackHitFrm@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcAttackHitFrm_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsPcAttackHitFrm()
	{
		_IsPcAttackHitFrm_PJTateshi__QAE_NXZ mFunc = (_IsPcAttackHitFrm_PJTateshi__QAE_NXZ)(GameModule + 0x4b0a10);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJTateshi::GetPcAttackFrm(class PJTateshi* const this) [?GetPcAttackFrm@PJTateshi@@QAEHXZ]
	typedef int32_t(__thiscall* _GetPcAttackFrm_PJTateshi__QAEHXZ)(class PJTateshi* const thisPtr);
	int32_t GetPcAttackFrm()
	{
		_GetPcAttackFrm_PJTateshi__QAEHXZ mFunc = (_GetPcAttackFrm_PJTateshi__QAEHXZ)(GameModule + 0x4b0a70);
		return mFunc(this);
	}
	// [Function] struct Vec* __convention("thiscall") PJTateshi::GetPcEscapeMoveVec(class PJTateshi* const this) [?GetPcEscapeMoveVec@PJTateshi@@QAEPAUVec@@XZ]
	typedef struct Vec*(__thiscall* _GetPcEscapeMoveVec_PJTateshi__QAEPAUVec__XZ)(class PJTateshi* const thisPtr);
	struct Vec* GetPcEscapeMoveVec()
	{
		_GetPcEscapeMoveVec_PJTateshi__QAEPAUVec__XZ mFunc = (_GetPcEscapeMoveVec_PJTateshi__QAEPAUVec__XZ)(GameModule + 0x4b0ac0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsEnablePcHagaijime(class PJTateshi* const this) [?IsEnablePcHagaijime@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsEnablePcHagaijime_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsEnablePcHagaijime()
	{
		_IsEnablePcHagaijime_PJTateshi__QAE_NXZ mFunc = (_IsEnablePcHagaijime_PJTateshi__QAE_NXZ)(GameModule + 0x4b0c30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsPcEscapeBeginFrame(class PJTateshi* const this) [?IsPcEscapeBeginFrame@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcEscapeBeginFrame_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsPcEscapeBeginFrame()
	{
		_IsPcEscapeBeginFrame_PJTateshi__QAE_NXZ mFunc = (_IsPcEscapeBeginFrame_PJTateshi__QAE_NXZ)(GameModule + 0x4b0cf0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsPcFollowThrough(class PJTateshi* const this) [?IsPcFollowThrough@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcFollowThrough_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsPcFollowThrough()
	{
		_IsPcFollowThrough_PJTateshi__QAE_NXZ mFunc = (_IsPcFollowThrough_PJTateshi__QAE_NXZ)(GameModule + 0x4b0d40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsPcAttacking(class PJTateshi* const this) [?IsPcAttacking@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsPcAttacking_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsPcAttacking()
	{
		_IsPcAttacking_PJTateshi__QAE_NXZ mFunc = (_IsPcAttacking_PJTateshi__QAE_NXZ)(GameModule + 0x4b0d60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsGroupFight(class PJTateshi* const this) [?IsGroupFight@PJTateshi@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsGroupFight_PJTateshi__QAE_NXZ)(class PJTateshi* const thisPtr);
	uint8_t IsGroupFight()
	{
		_IsGroupFight_PJTateshi__QAE_NXZ mFunc = (_IsGroupFight_PJTateshi__QAE_NXZ)(GameModule + 0x4b0d80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::UpdateZakoList(class PJTateshi* const this) [?UpdateZakoList@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _UpdateZakoList_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void UpdateZakoList()
	{
		_UpdateZakoList_PJTateshi__AAEXXZ mFunc = (_UpdateZakoList_PJTateshi__AAEXXZ)(GameModule + 0x4b0d90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::Update(class PJTateshi* const this) [?Update@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _Update_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void Update()
	{
		_Update_PJTateshi__AAEXXZ mFunc = (_Update_PJTateshi__AAEXXZ)(GameModule + 0x4b0e80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::WatchTraivisTigerTimingProc(class PJTateshi* const this) [?WatchTraivisTigerTimingProc@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _WatchTraivisTigerTimingProc_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void WatchTraivisTigerTimingProc()
	{
		_WatchTraivisTigerTimingProc_PJTateshi__AAEXXZ mFunc = (_WatchTraivisTigerTimingProc_PJTateshi__AAEXXZ)(GameModule + 0x4b1160);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::DebugProc(class PJTateshi* const this) [?DebugProc@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _DebugProc_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void DebugProc()
	{
		_DebugProc_PJTateshi__AAEXXZ mFunc = (_DebugProc_PJTateshi__AAEXXZ)(GameModule + 0x4b12b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::SetZakoAllFuttobiFromPc(class PJTateshi* const this, class mHRChara* arg2) [?SetZakoAllFuttobiFromPc@PJTateshi@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _SetZakoAllFuttobiFromPc_PJTateshi__QAEXPAVmHRChara___Z)(class PJTateshi* const thisPtr, class mHRChara* arg2);
	void SetZakoAllFuttobiFromPc(class mHRChara* arg2)
	{
		_SetZakoAllFuttobiFromPc_PJTateshi__QAEXPAVmHRChara___Z mFunc = (_SetZakoAllFuttobiFromPc_PJTateshi__QAEXPAVmHRChara___Z)(GameModule + 0x4b12c0);
		return mFunc(this, arg2);
	}
	// [Function] struct PJTateshi::HagaDmgInfo* __convention("thiscall") PJTateshi::GetHagaDmgInfo(class PJTateshi* const this) [?GetHagaDmgInfo@PJTateshi@@QAEPAUHagaDmgInfo@1@XZ]
	typedef struct PJTateshi::HagaDmgInfo*(__thiscall* _GetHagaDmgInfo_PJTateshi__QAEPAUHagaDmgInfo_1_XZ)(class PJTateshi* const thisPtr);
	struct PJTateshi::HagaDmgInfo* GetHagaDmgInfo()
	{
		_GetHagaDmgInfo_PJTateshi__QAEPAUHagaDmgInfo_1_XZ mFunc = (_GetHagaDmgInfo_PJTateshi__QAEPAUHagaDmgInfo_1_XZ)(GameModule + 0x4b1460);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::SetDamageReqHagaijimePC(class PJTateshi* const this, float arg2, int32_t arg3) [?SetDamageReqHagaijimePC@PJTateshi@@QAEXMH@Z]
	typedef void(__thiscall* _SetDamageReqHagaijimePC_PJTateshi__QAEXMH_Z)(class PJTateshi* const thisPtr, float arg2, int32_t arg3);
	void SetDamageReqHagaijimePC(float arg2, int32_t arg3)
	{
		_SetDamageReqHagaijimePC_PJTateshi__QAEXMH_Z mFunc = (_SetDamageReqHagaijimePC_PJTateshi__QAEXMH_Z)(GameModule + 0x4b1480);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJTateshi::SetPcHagaijimeFlag(class PJTateshi* const this, uint8_t arg2) [?SetPcHagaijimeFlag@PJTateshi@@QAEX_N@Z]
	typedef void(__thiscall* _SetPcHagaijimeFlag_PJTateshi__QAEX_N_Z)(class PJTateshi* const thisPtr, uint8_t arg2);
	void SetPcHagaijimeFlag(uint8_t arg2)
	{
		_SetPcHagaijimeFlag_PJTateshi__QAEX_N_Z mFunc = (_SetPcHagaijimeFlag_PJTateshi__QAEX_N_Z)(GameModule + 0x4b14c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::RegistHagaijimeZako(class PJTateshi* const this, class PJZAKO* arg2) [?RegistHagaijimeZako@PJTateshi@@QAE_NPAVPJZAKO@@@Z]
	typedef uint8_t(__thiscall* _RegistHagaijimeZako_PJTateshi__QAE_NPAVPJZAKO___Z)(class PJTateshi* const thisPtr, class PJZAKO* arg2);
	uint8_t RegistHagaijimeZako(class PJZAKO* arg2)
	{
		_RegistHagaijimeZako_PJTateshi__QAE_NPAVPJZAKO___Z mFunc = (_RegistHagaijimeZako_PJTateshi__QAE_NPAVPJZAKO___Z)(GameModule + 0x4b14e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJTateshi::CheckPcFrontZako(class PJTateshi* const this) [?CheckPcFrontZako@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _CheckPcFrontZako_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void CheckPcFrontZako()
	{
		_CheckPcFrontZako_PJTateshi__AAEXXZ mFunc = (_CheckPcFrontZako_PJTateshi__AAEXXZ)(GameModule + 0x4b1510);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::SelectDebugDrawZakoProc(class PJTateshi* const this) [?SelectDebugDrawZakoProc@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _SelectDebugDrawZakoProc_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void SelectDebugDrawZakoProc()
	{
		_SelectDebugDrawZakoProc_PJTateshi__AAEXXZ mFunc = (_SelectDebugDrawZakoProc_PJTateshi__AAEXXZ)(GameModule + 0x4b1560);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::CalcStatNum(class PJTateshi* const this) [?CalcStatNum@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _CalcStatNum_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void CalcStatNum()
	{
		_CalcStatNum_PJTateshi__AAEXXZ mFunc = (_CalcStatNum_PJTateshi__AAEXXZ)(GameModule + 0x4b1570);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJTateshi::GetZakoNumInStat(class PJTateshi* const this, enum eZkStat arg2) [?GetZakoNumInStat@PJTateshi@@QAEHW4eZkStat@@@Z]
	typedef int32_t(__thiscall* _GetZakoNumInStat_PJTateshi__QAEHW4eZkStat___Z)(class PJTateshi* const thisPtr, enum eZkStat arg2);
	int32_t GetZakoNumInStat(/* enum eZkStat */ uint32_t arg2)
	{
		_GetZakoNumInStat_PJTateshi__QAEHW4eZkStat___Z mFunc = (_GetZakoNumInStat_PJTateshi__QAEHW4eZkStat___Z)(GameModule + 0x4b15c0);
		return mFunc(this, (enum eZkStat)arg2);
	}
	// [Function] void __convention("thiscall") PJTateshi::RecastFightLine(class PJTateshi* const this, class PJZAKO* arg2) [?RecastFightLine@PJTateshi@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _RecastFightLine_PJTateshi__QAEXPAVPJZAKO___Z)(class PJTateshi* const thisPtr, class PJZAKO* arg2);
	void RecastFightLine(class PJZAKO* arg2)
	{
		_RecastFightLine_PJTateshi__QAEXPAVPJZAKO___Z mFunc = (_RecastFightLine_PJTateshi__QAEXPAVPJZAKO___Z)(GameModule + 0x4b1620);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJTateshi::FightLineProc(class PJTateshi* const this) [?FightLineProc@PJTateshi@@AAEXXZ]
	typedef void(__thiscall* _FightLineProc_PJTateshi__AAEXXZ)(class PJTateshi* const thisPtr);
	void FightLineProc()
	{
		_FightLineProc_PJTateshi__AAEXXZ mFunc = (_FightLineProc_PJTateshi__AAEXXZ)(GameModule + 0x4b1890);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::UpdateCirclePcPoints(class PJTateshi* const this) [?UpdateCirclePcPoints@PJTateshi@@QAEXXZ]
	typedef void(__thiscall* _UpdateCirclePcPoints_PJTateshi__QAEXXZ)(class PJTateshi* const thisPtr);
	void UpdateCirclePcPoints()
	{
		_UpdateCirclePcPoints_PJTateshi__QAEXXZ mFunc = (_UpdateCirclePcPoints_PJTateshi__QAEXXZ)(GameModule + 0x4b18b0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJTateshi::GetCirclePcPointHnd(class PJTateshi* const this, struct Vec& arg2, float const arg3) [?GetCirclePcPointHnd@PJTateshi@@QAEHABUVec@@M@Z]
	typedef int32_t(__thiscall* _GetCirclePcPointHnd_PJTateshi__QAEHABUVec__M_Z)(class PJTateshi* const thisPtr, struct Vec& arg2, float const arg3);
	int32_t GetCirclePcPointHnd(struct Vec& arg2, float const arg3)
	{
		_GetCirclePcPointHnd_PJTateshi__QAEHABUVec__M_Z mFunc = (_GetCirclePcPointHnd_PJTateshi__QAEHABUVec__M_Z)(GameModule + 0x4b19a0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") PJTateshi::IsWaitStandby(class PJTateshi* const this, enum eWaitType arg2) [?IsWaitStandby@PJTateshi@@QAE_NW4eWaitType@@@Z]
	typedef uint8_t(__thiscall* _IsWaitStandby_PJTateshi__QAE_NW4eWaitType___Z)(class PJTateshi* const thisPtr, enum eWaitType arg2);
	uint8_t IsWaitStandby(/* enum eWaitType */ uint32_t arg2)
	{
		_IsWaitStandby_PJTateshi__QAE_NW4eWaitType___Z mFunc = (_IsWaitStandby_PJTateshi__QAE_NW4eWaitType___Z)(GameModule + 0x4b1c60);
		return mFunc(this, (enum eWaitType)arg2);
	}
	// [Function] void __convention("thiscall") PJTateshi::FrameProcess(class PJTateshi* const this) [?FrameProcess@PJTateshi@@QAEXXZ]
	typedef void(__thiscall* _FrameProcess_PJTateshi__QAEXXZ)(class PJTateshi* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_PJTateshi__QAEXXZ mFunc = (_FrameProcess_PJTateshi__QAEXXZ)(GameModule + 0x4b1ce0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::Initialize(class PJTateshi* const this) [?Initialize@PJTateshi@@QAEXXZ]
	typedef void(__thiscall* _Initialize_PJTateshi__QAEXXZ)(class PJTateshi* const thisPtr);
	void Initialize()
	{
		_Initialize_PJTateshi__QAEXXZ mFunc = (_Initialize_PJTateshi__QAEXXZ)(GameModule + 0x4b1db0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::SetDemoDamage2PC(class PJTateshi* const this, float const arg2, class mHRChara* arg3) [?SetDemoDamage2PC@PJTateshi@@QAEXMPAVmHRChara@@@Z]
	typedef void(__thiscall* _SetDemoDamage2PC_PJTateshi__QAEXMPAVmHRChara___Z)(class PJTateshi* const thisPtr, float const arg2, class mHRChara* arg3);
	void SetDemoDamage2PC(float const arg2, class mHRChara* arg3)
	{
		_SetDemoDamage2PC_PJTateshi__QAEXMPAVmHRChara___Z mFunc = (_SetDemoDamage2PC_PJTateshi__QAEXMPAVmHRChara___Z)(GameModule + 0x4b1ea0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJTateshi::SetNowAllPopZakoPerformIll(class PJTateshi* const this) [?SetNowAllPopZakoPerformIll@PJTateshi@@QAEXXZ]
	typedef void(__thiscall* _SetNowAllPopZakoPerformIll_PJTateshi__QAEXXZ)(class PJTateshi* const thisPtr);
	void SetNowAllPopZakoPerformIll()
	{
		_SetNowAllPopZakoPerformIll_PJTateshi__QAEXXZ mFunc = (_SetNowAllPopZakoPerformIll_PJTateshi__QAEXXZ)(GameModule + 0x4b1f10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJTateshi::RequestDeathOutOfCameraAllFightingZako(class PJTateshi* const this) [?RequestDeathOutOfCameraAllFightingZako@PJTateshi@@QAEXXZ]
	typedef void(__thiscall* _RequestDeathOutOfCameraAllFightingZako_PJTateshi__QAEXXZ)(class PJTateshi* const thisPtr);
	void RequestDeathOutOfCameraAllFightingZako()
	{
		_RequestDeathOutOfCameraAllFightingZako_PJTateshi__QAEXXZ mFunc = (_RequestDeathOutOfCameraAllFightingZako_PJTateshi__QAEXXZ)(GameModule + 0x4b1f90);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJTateshi [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJTateshi& InObject)
	{
		ZakoList = InObject.ZakoList;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJTateshi>("PJTateshi")
			.addFunction("__tostring", &PJTateshi::ToString)
			.addFunction("GetPtrAddr", &PJTateshi::GetPtrAddr)
			.addProperty("ZakoList", &PJTateshi::ZakoList)
			.addStaticFunction("GetInstance", &PJTateshi::GetInstance)
			.addFunction("IsPcHagaijime", &PJTateshi::IsPcHagaijime)
			.addFunction("GetPcReleaseFromHagaijimeMotionFlag", &PJTateshi::GetPcReleaseFromHagaijimeMotionFlag)
			.addFunction("GetBattleEnmNum", &PJTateshi::GetBattleEnmNum)
			.addFunction("GetLastPcAttackZakoPtr", &PJTateshi::GetLastPcAttackZakoPtr)
			.addFunction("SetLastPcAttackZakoPtr", &PJTateshi::SetLastPcAttackZakoPtr)
			.addFunction("DeleteFromZakoList", &PJTateshi::DeleteFromZakoList)
			.addFunction("SetPcReleaseFromHagaijimeMotionFlag", &PJTateshi::SetPcReleaseFromHagaijimeMotionFlag)
			.addFunction("GetCirclePcPointPos", &PJTateshi::GetCirclePcPointPos)
			.addFunction("ClearCirclePcPoint", &PJTateshi::ClearCirclePcPoint)
			.addFunction("IsRevengeMissionOver", &PJTateshi::IsRevengeMissionOver)
			.addFunction("IsNowRevengeMission", &PJTateshi::IsNowRevengeMission)
			.addFunction("DebugRender", &PJTateshi::DebugRender)
			.addFunction("CheckPcPlayExtMotion", &PJTateshi::CheckPcPlayExtMotion)
			.addFunction("SubPcNowEquipBatteryRatio", &PJTateshi::SubPcNowEquipBatteryRatio)
			.addFunction("RenderProcess", &PJTateshi::RenderProcess)
			.addFunction("CalcZakoBehindPcNum", &PJTateshi::CalcZakoBehindPcNum)
			.addFunction("IsPcFuttobiOrDown", &PJTateshi::IsPcFuttobiOrDown)
			.addFunction("IsPcAttackHitFrm", &PJTateshi::IsPcAttackHitFrm)
			.addFunction("GetPcAttackFrm", &PJTateshi::GetPcAttackFrm)
			.addFunction("GetPcEscapeMoveVec", &PJTateshi::GetPcEscapeMoveVec)
			.addFunction("IsEnablePcHagaijime", &PJTateshi::IsEnablePcHagaijime)
			.addFunction("IsPcEscapeBeginFrame", &PJTateshi::IsPcEscapeBeginFrame)
			.addFunction("IsPcFollowThrough", &PJTateshi::IsPcFollowThrough)
			.addFunction("IsPcAttacking", &PJTateshi::IsPcAttacking)
			.addFunction("IsGroupFight", &PJTateshi::IsGroupFight)
			.addFunction("UpdateZakoList", &PJTateshi::UpdateZakoList)
			.addFunction("Update", &PJTateshi::Update)
			.addFunction("WatchTraivisTigerTimingProc", &PJTateshi::WatchTraivisTigerTimingProc)
			.addFunction("DebugProc", &PJTateshi::DebugProc)
			.addFunction("SetZakoAllFuttobiFromPc", &PJTateshi::SetZakoAllFuttobiFromPc)
			.addFunction("GetHagaDmgInfo", &PJTateshi::GetHagaDmgInfo)
			.addFunction("SetDamageReqHagaijimePC", &PJTateshi::SetDamageReqHagaijimePC)
			.addFunction("SetPcHagaijimeFlag", &PJTateshi::SetPcHagaijimeFlag)
			.addFunction("RegistHagaijimeZako", &PJTateshi::RegistHagaijimeZako)
			.addFunction("CheckPcFrontZako", &PJTateshi::CheckPcFrontZako)
			.addFunction("SelectDebugDrawZakoProc", &PJTateshi::SelectDebugDrawZakoProc)
			.addFunction("CalcStatNum", &PJTateshi::CalcStatNum)
			.addFunction("GetZakoNumInStat", &PJTateshi::GetZakoNumInStat)
			.addFunction("RecastFightLine", &PJTateshi::RecastFightLine)
			.addFunction("FightLineProc", &PJTateshi::FightLineProc)
			.addFunction("UpdateCirclePcPoints", &PJTateshi::UpdateCirclePcPoints)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("GetCirclePcPointHnd", &PJTateshi::GetCirclePcPointHnd)
			.addFunction("IsWaitStandby", &PJTateshi::IsWaitStandby)
			.addFunction("FrameProcess", &PJTateshi::FrameProcess)
			.addFunction("Initialize", &PJTateshi::Initialize)
			.addFunction("SetDemoDamage2PC", &PJTateshi::SetDemoDamage2PC)
			.addFunction("SetNowAllPopZakoPerformIll", &PJTateshi::SetNowAllPopZakoPerformIll)
			.addFunction("RequestDeathOutOfCameraAllFightingZako", &PJTateshi::RequestDeathOutOfCameraAllFightingZako)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJTateshi::ZakoList) == 12, "expected PJTateshi::ZakoList to be size 12");
static_assert(sizeof(PJTateshi) == 0x1ec, "expected PJTateshi to be size 0x1ec");

// [Structure] class HrCamera
class HrCamera
{
public:
	// [Structure] class HrCamera::CMotion
	class CMotion
	{
	public:
		/// Struct member variables

		// <class TGanPlay* m_pGanPlay, offset 0x0>
		class TGanPlay* m_pGanPlay = nullptr;

		// <class TGanPlayNode* m_pGanPlayNode, offset 0x4>
		class TGanPlayNode* m_pGanPlayNode = nullptr;

		// <float m_fPlayRate, offset 0x8>
		float m_fPlayRate = 0;

		// <float m_inWorldMat[0x3][0x4], offset 0xc>
		float m_inWorldMat[3][4];

		// <float m_fRoll, offset 0x3c>
		float m_fRoll = 0;

		// <uint8_t m_bIsRollValid, offset 0x40>
		uint8_t m_bIsRollValid = 0;

		// <uint8_t m_bIsPause, offset 0x41>
		uint8_t m_bIsPause = 0;

		// <uint8_t m_bIsCheckCol, offset 0x42>
		uint8_t m_bIsCheckCol = 0;

		// <Unidentified data segment, offset 0x43>
	private:
		char _UnidentifiedData_67[1];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class HrCamera::CMotion [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(HrCamera::CMotion& InObject)
		{
			m_pGanPlay = InObject.m_pGanPlay;
			m_pGanPlayNode = InObject.m_pGanPlayNode;
			m_fPlayRate = InObject.m_fPlayRate;
			m_fRoll = InObject.m_fRoll;
			m_bIsRollValid = InObject.m_bIsRollValid;
			m_bIsPause = InObject.m_bIsPause;
			m_bIsCheckCol = InObject.m_bIsCheckCol;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CMotion>("HrCamera_CMotion")
				.addFunction("__tostring", &HrCamera::CMotion::ToString)
				.addFunction("GetPtrAddr", &HrCamera::CMotion::GetPtrAddr)
				.addProperty("m_pGanPlay", &HrCamera::CMotion::m_pGanPlay)
				.addProperty("m_pGanPlayNode", &HrCamera::CMotion::m_pGanPlayNode)
				.addProperty("m_fPlayRate", &HrCamera::CMotion::m_fPlayRate)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_inWorldMat", &HrCamera::CMotion::m_inWorldMat)
				.addProperty("m_fRoll", &HrCamera::CMotion::m_fRoll)
				.addProperty("m_bIsRollValid", &HrCamera::CMotion::m_bIsRollValid)
				.addProperty("m_bIsPause", &HrCamera::CMotion::m_bIsPause)
				.addProperty("m_bIsCheckCol", &HrCamera::CMotion::m_bIsCheckCol)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrCamera::CMotion::m_pGanPlay) == 4, "expected HrCamera::CMotion::m_pGanPlay to be size 4");
	static_assert(sizeof(HrCamera::CMotion::m_pGanPlayNode) == 4, "expected HrCamera::CMotion::m_pGanPlayNode to be size 4");
	static_assert(sizeof(HrCamera::CMotion::m_fPlayRate) == 4, "expected HrCamera::CMotion::m_fPlayRate to be size 4");
	static_assert(sizeof(HrCamera::CMotion::m_inWorldMat) == 48, "expected HrCamera::CMotion::m_inWorldMat to be size 48");
	static_assert(sizeof(HrCamera::CMotion::m_fRoll) == 4, "expected HrCamera::CMotion::m_fRoll to be size 4");
	static_assert(sizeof(HrCamera::CMotion::m_bIsRollValid) == 1, "expected HrCamera::CMotion::m_bIsRollValid to be size 1");
	static_assert(sizeof(HrCamera::CMotion::m_bIsPause) == 1, "expected HrCamera::CMotion::m_bIsPause to be size 1");
	static_assert(sizeof(HrCamera::CMotion::m_bIsCheckCol) == 1, "expected HrCamera::CMotion::m_bIsCheckCol to be size 1");
	static_assert(sizeof(HrCamera::CMotion) == 0x44, "expected HrCamera::CMotion to be size 0x44");

	// [Structure] struct HrCamera::MOVE2
	struct MOVE2
	{
	public:
		/// Struct member variables

		// <struct Vec PcPos, offset 0x0>
		struct Vec PcPos;

		// <float PcAngle, offset 0xc>
		float PcAngle = 0;

		// <float CamAngle, offset 0x10>
		float CamAngle = 0;

		// <float CamTargLength, offset 0x14>
		float CamTargLength = 0;

		// <float CamYAngleRate, offset 0x18>
		float CamYAngleRate = 0;

		// <struct Vec AbsCamPos, offset 0x1c>
		struct Vec AbsCamPos;

		// <struct Vec AbsTargPos, offset 0x28>
		struct Vec AbsTargPos;

		// <float PcLookRate, offset 0x34>
		float PcLookRate = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct HrCamera::MOVE2 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(HrCamera::MOVE2& InObject)
		{
			PcPos = InObject.PcPos;
			PcAngle = InObject.PcAngle;
			CamAngle = InObject.CamAngle;
			CamTargLength = InObject.CamTargLength;
			CamYAngleRate = InObject.CamYAngleRate;
			AbsCamPos = InObject.AbsCamPos;
			AbsTargPos = InObject.AbsTargPos;
			PcLookRate = InObject.PcLookRate;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MOVE2>("HrCamera_MOVE2")
				.addFunction("__tostring", &HrCamera::MOVE2::ToString)
				.addFunction("GetPtrAddr", &HrCamera::MOVE2::GetPtrAddr)
				.addProperty("PcPos", &HrCamera::MOVE2::PcPos)
				.addProperty("PcAngle", &HrCamera::MOVE2::PcAngle)
				.addProperty("CamAngle", &HrCamera::MOVE2::CamAngle)
				.addProperty("CamTargLength", &HrCamera::MOVE2::CamTargLength)
				.addProperty("CamYAngleRate", &HrCamera::MOVE2::CamYAngleRate)
				.addProperty("AbsCamPos", &HrCamera::MOVE2::AbsCamPos)
				.addProperty("AbsTargPos", &HrCamera::MOVE2::AbsTargPos)
				.addProperty("PcLookRate", &HrCamera::MOVE2::PcLookRate)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrCamera::MOVE2::PcPos) == 12, "expected HrCamera::MOVE2::PcPos to be size 12");
	static_assert(sizeof(HrCamera::MOVE2::PcAngle) == 4, "expected HrCamera::MOVE2::PcAngle to be size 4");
	static_assert(sizeof(HrCamera::MOVE2::CamAngle) == 4, "expected HrCamera::MOVE2::CamAngle to be size 4");
	static_assert(sizeof(HrCamera::MOVE2::CamTargLength) == 4, "expected HrCamera::MOVE2::CamTargLength to be size 4");
	static_assert(sizeof(HrCamera::MOVE2::CamYAngleRate) == 4, "expected HrCamera::MOVE2::CamYAngleRate to be size 4");
	static_assert(sizeof(HrCamera::MOVE2::AbsCamPos) == 12, "expected HrCamera::MOVE2::AbsCamPos to be size 12");
	static_assert(sizeof(HrCamera::MOVE2::AbsTargPos) == 12, "expected HrCamera::MOVE2::AbsTargPos to be size 12");
	static_assert(sizeof(HrCamera::MOVE2::PcLookRate) == 4, "expected HrCamera::MOVE2::PcLookRate to be size 4");
	static_assert(sizeof(HrCamera::MOVE2) == 0x38, "expected HrCamera::MOVE2 to be size 0x38");

	// [Structure] struct HrCamera::MAIN
	struct MAIN
	{
	public:
		// [Structure] struct HrCamera::MAIN::NORMAL
		struct NORMAL
		{
		public:
			/// Struct member variables

			// <struct Vec CPos, offset 0x0>
			struct Vec CPos;

			// <struct Vec TPos, offset 0xc>
			struct Vec TPos;

			// <uint8_t ValidFov, offset 0x18>
			uint8_t ValidFov = 0;

			// <Unidentified data segment, offset 0x19>
		private:
			char _UnidentifiedData_25[3];

		public:
			// <float Fov, offset 0x1c>
			float Fov = 0;

			/// 0 Functions

			/// Meta

			std::string ToString() const { std::stringstream stream; stream << "struct HrCamera::MAIN::NORMAL [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
			int GetPtrAddr() const { return (int)this; }
			void CopyFrom(HrCamera::MAIN::NORMAL& InObject)
			{
				CPos = InObject.CPos;
				TPos = InObject.TPos;
				ValidFov = InObject.ValidFov;
				Fov = InObject.Fov;
			}
#ifdef WITH_LUA
			static void BindLua(luabridge::Namespace& NS)
			{
				NS = NS.beginClass<NORMAL>("HrCamera_MAIN_NORMAL")
					.addFunction("__tostring", &HrCamera::MAIN::NORMAL::ToString)
					.addFunction("GetPtrAddr", &HrCamera::MAIN::NORMAL::GetPtrAddr)
					.addProperty("CPos", &HrCamera::MAIN::NORMAL::CPos)
					.addProperty("TPos", &HrCamera::MAIN::NORMAL::TPos)
					.addProperty("ValidFov", &HrCamera::MAIN::NORMAL::ValidFov)
					.addProperty("Fov", &HrCamera::MAIN::NORMAL::Fov)
				.endClass();
			}
#endif
		};
		static_assert(sizeof(HrCamera::MAIN::NORMAL::CPos) == 12, "expected HrCamera::MAIN::NORMAL::CPos to be size 12");
		static_assert(sizeof(HrCamera::MAIN::NORMAL::TPos) == 12, "expected HrCamera::MAIN::NORMAL::TPos to be size 12");
		static_assert(sizeof(HrCamera::MAIN::NORMAL::ValidFov) == 1, "expected HrCamera::MAIN::NORMAL::ValidFov to be size 1");
		static_assert(sizeof(HrCamera::MAIN::NORMAL::Fov) == 4, "expected HrCamera::MAIN::NORMAL::Fov to be size 4");
		static_assert(sizeof(HrCamera::MAIN::NORMAL) == 0x20, "expected HrCamera::MAIN::NORMAL to be size 0x20");

		// [Structure] struct HrCamera::MAIN::FREE
		struct FREE
		{
		public:
			/// Struct member variables

			// <struct Vec C_T_Pos, offset 0x0>
			struct Vec C_T_Pos;

			// <float T_VDir, offset 0xc>
			float T_VDir = 0;

			// <float VDir, offset 0x10>
			float VDir = 0;

			// <float T_YDir, offset 0x14>
			float T_YDir = 0;

			// <float YDir, offset 0x18>
			float YDir = 0;

			/// 0 Functions

			/// Meta

			std::string ToString() const { std::stringstream stream; stream << "struct HrCamera::MAIN::FREE [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
			int GetPtrAddr() const { return (int)this; }
			void CopyFrom(HrCamera::MAIN::FREE& InObject)
			{
				C_T_Pos = InObject.C_T_Pos;
				T_VDir = InObject.T_VDir;
				VDir = InObject.VDir;
				T_YDir = InObject.T_YDir;
				YDir = InObject.YDir;
			}
#ifdef WITH_LUA
			static void BindLua(luabridge::Namespace& NS)
			{
				NS = NS.beginClass<FREE>("HrCamera_MAIN_FREE")
					.addFunction("__tostring", &HrCamera::MAIN::FREE::ToString)
					.addFunction("GetPtrAddr", &HrCamera::MAIN::FREE::GetPtrAddr)
					.addProperty("C_T_Pos", &HrCamera::MAIN::FREE::C_T_Pos)
					.addProperty("T_VDir", &HrCamera::MAIN::FREE::T_VDir)
					.addProperty("VDir", &HrCamera::MAIN::FREE::VDir)
					.addProperty("T_YDir", &HrCamera::MAIN::FREE::T_YDir)
					.addProperty("YDir", &HrCamera::MAIN::FREE::YDir)
				.endClass();
			}
#endif
		};
		static_assert(sizeof(HrCamera::MAIN::FREE::C_T_Pos) == 12, "expected HrCamera::MAIN::FREE::C_T_Pos to be size 12");
		static_assert(sizeof(HrCamera::MAIN::FREE::T_VDir) == 4, "expected HrCamera::MAIN::FREE::T_VDir to be size 4");
		static_assert(sizeof(HrCamera::MAIN::FREE::VDir) == 4, "expected HrCamera::MAIN::FREE::VDir to be size 4");
		static_assert(sizeof(HrCamera::MAIN::FREE::T_YDir) == 4, "expected HrCamera::MAIN::FREE::T_YDir to be size 4");
		static_assert(sizeof(HrCamera::MAIN::FREE::YDir) == 4, "expected HrCamera::MAIN::FREE::YDir to be size 4");
		static_assert(sizeof(HrCamera::MAIN::FREE) == 0x1c, "expected HrCamera::MAIN::FREE to be size 0x1c");

		// [Structure] struct HrCamera::MAIN::MOVE
		struct MOVE
		{
		public:
			/// Struct member variables

			// <struct Vec P_Pos, offset 0x0>
			struct Vec P_Pos;

			// <uint8_t P_PosValid, offset 0xc>
			uint8_t P_PosValid = 0;

			// <uint8_t CollValid, offset 0xd>
			uint8_t CollValid = 0;

			// <Unidentified data segment, offset 0xe>
		private:
			char _UnidentifiedData_14[2];

		public:
			// <struct Vec T_Pos, offset 0x10>
			struct Vec T_Pos;

			// <float T_PosAddY, offset 0x1c>
			float T_PosAddY = 0;

			// <struct Vec T_Dir, offset 0x20>
			struct Vec T_Dir;

			// <float T_RotY, offset 0x2c>
			float T_RotY = 0;

			// <struct Vec Now_T_Dir, offset 0x30>
			struct Vec Now_T_Dir;

			// <float C_T_Angle, offset 0x3c>
			float C_T_Angle = 0;

			// <float C_T_Len, offset 0x40>
			float C_T_Len = 0;

			// <float C_T_Now_Len, offset 0x44>
			float C_T_Now_Len = 0;

			/// 0 Functions

			/// Meta

			std::string ToString() const { std::stringstream stream; stream << "struct HrCamera::MAIN::MOVE [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
			int GetPtrAddr() const { return (int)this; }
			void CopyFrom(HrCamera::MAIN::MOVE& InObject)
			{
				P_Pos = InObject.P_Pos;
				P_PosValid = InObject.P_PosValid;
				CollValid = InObject.CollValid;
				T_Pos = InObject.T_Pos;
				T_PosAddY = InObject.T_PosAddY;
				T_Dir = InObject.T_Dir;
				T_RotY = InObject.T_RotY;
				Now_T_Dir = InObject.Now_T_Dir;
				C_T_Angle = InObject.C_T_Angle;
				C_T_Len = InObject.C_T_Len;
				C_T_Now_Len = InObject.C_T_Now_Len;
			}
#ifdef WITH_LUA
			static void BindLua(luabridge::Namespace& NS)
			{
				NS = NS.beginClass<MOVE>("HrCamera_MAIN_MOVE")
					.addFunction("__tostring", &HrCamera::MAIN::MOVE::ToString)
					.addFunction("GetPtrAddr", &HrCamera::MAIN::MOVE::GetPtrAddr)
					.addProperty("P_Pos", &HrCamera::MAIN::MOVE::P_Pos)
					.addProperty("P_PosValid", &HrCamera::MAIN::MOVE::P_PosValid)
					.addProperty("CollValid", &HrCamera::MAIN::MOVE::CollValid)
					.addProperty("T_Pos", &HrCamera::MAIN::MOVE::T_Pos)
					.addProperty("T_PosAddY", &HrCamera::MAIN::MOVE::T_PosAddY)
					.addProperty("T_Dir", &HrCamera::MAIN::MOVE::T_Dir)
					.addProperty("T_RotY", &HrCamera::MAIN::MOVE::T_RotY)
					.addProperty("Now_T_Dir", &HrCamera::MAIN::MOVE::Now_T_Dir)
					.addProperty("C_T_Angle", &HrCamera::MAIN::MOVE::C_T_Angle)
					.addProperty("C_T_Len", &HrCamera::MAIN::MOVE::C_T_Len)
					.addProperty("C_T_Now_Len", &HrCamera::MAIN::MOVE::C_T_Now_Len)
				.endClass();
			}
#endif
		};
		static_assert(sizeof(HrCamera::MAIN::MOVE::P_Pos) == 12, "expected HrCamera::MAIN::MOVE::P_Pos to be size 12");
		static_assert(sizeof(HrCamera::MAIN::MOVE::P_PosValid) == 1, "expected HrCamera::MAIN::MOVE::P_PosValid to be size 1");
		static_assert(sizeof(HrCamera::MAIN::MOVE::CollValid) == 1, "expected HrCamera::MAIN::MOVE::CollValid to be size 1");
		static_assert(sizeof(HrCamera::MAIN::MOVE::T_Pos) == 12, "expected HrCamera::MAIN::MOVE::T_Pos to be size 12");
		static_assert(sizeof(HrCamera::MAIN::MOVE::T_PosAddY) == 4, "expected HrCamera::MAIN::MOVE::T_PosAddY to be size 4");
		static_assert(sizeof(HrCamera::MAIN::MOVE::T_Dir) == 12, "expected HrCamera::MAIN::MOVE::T_Dir to be size 12");
		static_assert(sizeof(HrCamera::MAIN::MOVE::T_RotY) == 4, "expected HrCamera::MAIN::MOVE::T_RotY to be size 4");
		static_assert(sizeof(HrCamera::MAIN::MOVE::Now_T_Dir) == 12, "expected HrCamera::MAIN::MOVE::Now_T_Dir to be size 12");
		static_assert(sizeof(HrCamera::MAIN::MOVE::C_T_Angle) == 4, "expected HrCamera::MAIN::MOVE::C_T_Angle to be size 4");
		static_assert(sizeof(HrCamera::MAIN::MOVE::C_T_Len) == 4, "expected HrCamera::MAIN::MOVE::C_T_Len to be size 4");
		static_assert(sizeof(HrCamera::MAIN::MOVE::C_T_Now_Len) == 4, "expected HrCamera::MAIN::MOVE::C_T_Now_Len to be size 4");
		static_assert(sizeof(HrCamera::MAIN::MOVE) == 0x48, "expected HrCamera::MAIN::MOVE to be size 0x48");

		/// Struct member variables

		// <enum HRCAMERA_MODE Mode, offset 0x0>
		enum HRCAMERA_MODE Mode;

		// <struct HrCamera::MOVE2 mov2, offset 0x4>
		struct MOVE2 mov2;

		// <struct HrCamera::MAIN::NORMAL nrm, offset 0x3c>
		struct MAIN::NORMAL nrm;

		// <struct HrCamera::MAIN::FREE free, offset 0x5c>
		struct MAIN::FREE free;

		// <struct HrCamera::MAIN::MOVE mov, offset 0x78>
		struct MAIN::MOVE mov;

		// <uint8_t Always, offset 0xc0>
		uint8_t Always = 0;

		// <Unidentified data segment, offset 0xc1>
	private:
		char _UnidentifiedData_193[3];

	public:
		// <int32_t FrameCounter, offset 0xc4>
		int32_t FrameCounter = 0;

		// <class ghmGcCollObjSphere* pCollSphereObj, offset 0xc8>
		class ghmGcCollObjSphere* pCollSphereObj = nullptr;

		// <uint8_t IsHrAppCollAddObj, offset 0xcc>
		uint8_t IsHrAppCollAddObj = 0;

		// <Unidentified data segment, offset 0xcd>
	private:
		char _UnidentifiedData_205[3];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct HrCamera::MAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(HrCamera::MAIN& InObject)
		{
			Mode = InObject.Mode;
			mov2 = InObject.mov2;
			nrm = InObject.nrm;
			free = InObject.free;
			mov = InObject.mov;
			Always = InObject.Always;
			FrameCounter = InObject.FrameCounter;
			pCollSphereObj = InObject.pCollSphereObj;
			IsHrAppCollAddObj = InObject.IsHrAppCollAddObj;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MAIN>("HrCamera_MAIN")
				.addFunction("__tostring", &HrCamera::MAIN::ToString)
				.addFunction("GetPtrAddr", &HrCamera::MAIN::GetPtrAddr)
				.addProperty("Mode", &HrCamera::MAIN::Mode)
				.addProperty("mov2", &HrCamera::MAIN::mov2)
				.addProperty("nrm", &HrCamera::MAIN::nrm)
				.addProperty("free", &HrCamera::MAIN::free)
				.addProperty("mov", &HrCamera::MAIN::mov)
				.addProperty("Always", &HrCamera::MAIN::Always)
				.addProperty("FrameCounter", &HrCamera::MAIN::FrameCounter)
				.addProperty("pCollSphereObj", &HrCamera::MAIN::pCollSphereObj)
				.addProperty("IsHrAppCollAddObj", &HrCamera::MAIN::IsHrAppCollAddObj)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrCamera::MAIN::Mode) == 4, "expected HrCamera::MAIN::Mode to be size 4");
	static_assert(sizeof(HrCamera::MAIN::mov2) == 56, "expected HrCamera::MAIN::mov2 to be size 56");
	static_assert(sizeof(HrCamera::MAIN::nrm) == 32, "expected HrCamera::MAIN::nrm to be size 32");
	static_assert(sizeof(HrCamera::MAIN::free) == 28, "expected HrCamera::MAIN::free to be size 28");
	static_assert(sizeof(HrCamera::MAIN::mov) == 72, "expected HrCamera::MAIN::mov to be size 72");
	static_assert(sizeof(HrCamera::MAIN::Always) == 1, "expected HrCamera::MAIN::Always to be size 1");
	static_assert(sizeof(HrCamera::MAIN::FrameCounter) == 4, "expected HrCamera::MAIN::FrameCounter to be size 4");
	static_assert(sizeof(HrCamera::MAIN::pCollSphereObj) == 4, "expected HrCamera::MAIN::pCollSphereObj to be size 4");
	static_assert(sizeof(HrCamera::MAIN::IsHrAppCollAddObj) == 1, "expected HrCamera::MAIN::IsHrAppCollAddObj to be size 1");
	static_assert(sizeof(HrCamera::MAIN) == 0xd0, "expected HrCamera::MAIN to be size 0xd0");

	/// Struct member variables

	// <struct Vec m_inPosi, offset 0x0>
	struct Vec m_inPosi;

	// <struct Vec m_inLookAtPosi, offset 0xc>
	struct Vec m_inLookAtPosi;

	// <struct Vec m_inUpVec, offset 0x18>
	struct Vec m_inUpVec;

	// <float m_fViewAngleDeg, offset 0x24>
	float m_fViewAngleDeg = 0;

	// <enum HRCAMERA_MODE m_ePreMode, offset 0x28>
	enum HRCAMERA_MODE m_ePreMode;

	// <float m_fResetYaw, offset 0x2c>
	float m_fResetYaw = 0;

	// <float m_fTeppeiModeViewAngleDeg, offset 0x30>
	float m_fTeppeiModeViewAngleDeg = 0;

	// <uint8_t m_bSetUpVec, offset 0x34>
	uint8_t m_bSetUpVec = 0;

	// <Unidentified data segment, offset 0x35>
private:
	char _UnidentifiedData_53[3];

public:
	// <class HrCamera::CMotion m_inMotion, offset 0x38>
	class HrCamera::CMotion m_inMotion;

	// <uint8_t m_ModeChangeDisEnable, offset 0x7c>
	uint8_t m_ModeChangeDisEnable = 0;

	// <uint8_t m_bVisible, offset 0x7d>
	uint8_t m_bVisible = 0;

	// <Unidentified data segment, offset 0x7e>
private:
	char _UnidentifiedData_126[2];

public:
	// <struct HrCamera::MAIN m, offset 0x80>
	struct HrCamera::MAIN m;

	// <struct RailCameraHead* mpRailData, offset 0x150>
	struct RailCameraHead* mpRailData = nullptr;

	// <struct Vec mRailOldPos, offset 0x154>
	struct Vec mRailOldPos;

	// <struct Vec mTargetOriginal, offset 0x160>
	struct Vec mTargetOriginal;

	// <struct Vec mRailTarget, offset 0x16c>
	struct Vec mRailTarget;

	// <struct Vec mRailTargetPos, offset 0x178>
	struct Vec mRailTargetPos;

	// <uint32_t mActivePathIdx, offset 0x184>
	uint32_t mActivePathIdx = 0;

	// <int32_t mActivePosIdx, offset 0x188>
	int32_t mActivePosIdx = 0;

	// <int32_t mActiveLinkIdx, offset 0x18c>
	int32_t mActiveLinkIdx = 0;

	// <uint32_t mBefPosIdx, offset 0x190>
	uint32_t mBefPosIdx = 0;

	// <uint32_t mBefPathIdx, offset 0x194>
	uint32_t mBefPathIdx = 0;

	// <uint8_t mbLineChange, offset 0x198>
	uint8_t mbLineChange = 0;

	// <Unidentified data segment, offset 0x199>
private:
	char _UnidentifiedData_409[3];

public:
	// <float mLineChangeRate, offset 0x19c>
	float mLineChangeRate = 0;

	// <float mLineChangeSpeed, offset 0x1a0>
	float mLineChangeSpeed = 0;

	// <struct Vec mBefChangePos, offset 0x1a4>
	struct Vec mBefChangePos;

	// <struct Vec mBefLineVec, offset 0x1b0>
	struct Vec mBefLineVec;

	// <struct Vec mOldLineVec, offset 0x1bc>
	struct Vec mOldLineVec;

	// <float mSearchDist, offset 0x1c8>
	float mSearchDist = 0;

	// <float mTargetAdjust, offset 0x1cc>
	float mTargetAdjust = 0;

	// <float mOldTargetAdjust, offset 0x1d0>
	float mOldTargetAdjust = 0;

	// <float mPosAdjust, offset 0x1d4>
	float mPosAdjust = 0;

	// <float mBefPosAdust, offset 0x1d8>
	float mBefPosAdust = 0;

	// <float mOldPosAdust, offset 0x1dc>
	float mOldPosAdust = 0;

	// <float mPosAdustBase, offset 0x1e0>
	float mPosAdustBase = 0;

	// <float mRailTargetInterval, offset 0x1e4>
	float mRailTargetInterval = 0;

	// <float mRailPosInterval, offset 0x1e8>
	float mRailPosInterval = 0;

	// <uint8_t mbSetRailTargetInit, offset 0x1ec>
	uint8_t mbSetRailTargetInit = 0;

	// <uint8_t mbSetRailPosInit, offset 0x1ed>
	uint8_t mbSetRailPosInit = 0;

	// <uint8_t mbChangeInterpolate, offset 0x1ee>
	uint8_t mbChangeInterpolate = 0;

	// <Unidentified data segment, offset 0x1ef>
private:
	char _UnidentifiedData_495[1];

public:
	// <float mTrackTarget, offset 0x1f0>
	float mTrackTarget = 0;

	// <float mTrackLength, offset 0x1f4>
	float mTrackLength = 0;

	// <float mBefTrackLength, offset 0x1f8>
	float mBefTrackLength = 0;

	// <float mNPCAdjustDist, offset 0x1fc>
	float mNPCAdjustDist = 0;

	// <float mNPCAdjustValue, offset 0x200>
	float mNPCAdjustValue = 0;

	// <float mNPCAdjustSpeed, offset 0x204>
	float mNPCAdjustSpeed = 0;

	// <struct Vec mNPCAdustVec, offset 0x208>
	struct Vec mNPCAdustVec;

	// <float mNPCAjustDist, offset 0x214>
	float mNPCAjustDist = 0;

	// <uint8_t mNoTeppeiMode, offset 0x218>
	uint8_t mNoTeppeiMode = 0;

	// <uint8_t mAspectChangeDisEnable, offset 0x219>
	uint8_t mAspectChangeDisEnable = 0;

	// <Unidentified data segment, offset 0x21a>
private:
	char _UnidentifiedData_538[2];

public:
	/// 70 Functions

	// [Function] uint8_t __convention("thiscall") HrCamera::MOTION_IsPlay(class HrCamera* const this) [?MOTION_IsPlay@HrCamera@@QBE_NXZ]
	typedef uint8_t(__thiscall* _MOTION_IsPlay_HrCamera__QBE_NXZ)(class HrCamera* const thisPtr);
	uint8_t MOTION_IsPlay()
	{
		_MOTION_IsPlay_HrCamera__QBE_NXZ mFunc = (_MOTION_IsPlay_HrCamera__QBE_NXZ)(GameModule + 0xa2ed0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::MOTION_SetLoop(class HrCamera* const this, uint8_t const arg2) [?MOTION_SetLoop@HrCamera@@QAEX_N@Z]
	typedef void(__thiscall* _MOTION_SetLoop_HrCamera__QAEX_N_Z)(class HrCamera* const thisPtr, uint8_t const arg2);
	void MOTION_SetLoop(uint8_t const arg2)
	{
		_MOTION_SetLoop_HrCamera__QAEX_N_Z mFunc = (_MOTION_SetLoop_HrCamera__QAEX_N_Z)(GameModule + 0xa3110);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOTION_SetEnableCollision(class HrCamera* const this, uint8_t const arg2) [?MOTION_SetEnableCollision@HrCamera@@QAEX_N@Z]
	typedef void(__thiscall* _MOTION_SetEnableCollision_HrCamera__QAEX_N_Z)(class HrCamera* const thisPtr, uint8_t const arg2);
	void MOTION_SetEnableCollision(uint8_t const arg2)
	{
		_MOTION_SetEnableCollision_HrCamera__QAEX_N_Z mFunc = (_MOTION_SetEnableCollision_HrCamera__QAEX_N_Z)(GameModule + 0xa3130);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::SetVisible(class HrCamera* const this, uint8_t arg2) [?SetVisible@HrCamera@@QAEX_N@Z]
	typedef void(__thiscall* _SetVisible_HrCamera__QAEX_N_Z)(class HrCamera* const thisPtr, uint8_t arg2);
	void SetVisible(uint8_t arg2)
	{
		_SetVisible_HrCamera__QAEX_N_Z mFunc = (_SetVisible_HrCamera__QAEX_N_Z)(GameModule + 0xa3140);
		return mFunc(this, arg2);
	}
	// [Function] enum HRCAMERA_MODE __convention("thiscall") HrCamera::GetMode(class HrCamera* const this) [?GetMode@HrCamera@@QBE?AW4HRCAMERA_MODE@@XZ]
	typedef enum HRCAMERA_MODE(__thiscall* _GetMode_HrCamera__QBEAW4HRCAMERA_MODE__XZ)(class HrCamera* const thisPtr);
	/* enum HRCAMERA_MODE */ uint32_t GetMode()
	{
		_GetMode_HrCamera__QBEAW4HRCAMERA_MODE__XZ mFunc = (_GetMode_HrCamera__QBEAW4HRCAMERA_MODE__XZ)(GameModule + 0xa3270);
		return (uint32_t)mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::setTeppeiModeViewAngleDegree(class HrCamera* const this, float const arg2) [?setTeppeiModeViewAngleDegree@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _setTeppeiModeViewAngleDegree_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float const arg2);
	void setTeppeiModeViewAngleDegree(float const arg2)
	{
		_setTeppeiModeViewAngleDegree_HrCamera__QAEXM_Z mFunc = (_setTeppeiModeViewAngleDegree_HrCamera__QAEXM_Z)(GameModule + 0xa5bf0);
		return mFunc(this, arg2);
	}
	// [Function] enum HRCAMERA_MODE __convention("thiscall") HrCamera::GetPreMode(class HrCamera* const this) [?GetPreMode@HrCamera@@QBE?AW4HRCAMERA_MODE@@XZ]
	typedef enum HRCAMERA_MODE(__thiscall* _GetPreMode_HrCamera__QBEAW4HRCAMERA_MODE__XZ)(class HrCamera* const thisPtr);
	/* enum HRCAMERA_MODE */ uint32_t GetPreMode()
	{
		_GetPreMode_HrCamera__QBEAW4HRCAMERA_MODE__XZ mFunc = (_GetPreMode_HrCamera__QBEAW4HRCAMERA_MODE__XZ)(GameModule + 0xa5c30);
		return (uint32_t)mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") HrCamera::getPosition(class HrCamera* const this) [?getPosition@HrCamera@@QBEABUVec@@XZ]
	typedef struct Vec&(__thiscall* _getPosition_HrCamera__QBEABUVec__XZ)(class HrCamera* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void getPosition()
	{
		_getPosition_HrCamera__QBEABUVec__XZ mFunc = (_getPosition_HrCamera__QBEABUVec__XZ)(GameModule + 0xa5c40);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::MOTION_Stop(class HrCamera* const this) [?MOTION_Stop@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _MOTION_Stop_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void MOTION_Stop()
	{
		_MOTION_Stop_HrCamera__QAEXXZ mFunc = (_MOTION_Stop_HrCamera__QAEXXZ)(GameModule + 0xa9b30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::MOTION_DePause(class HrCamera* const this) [?MOTION_DePause@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _MOTION_DePause_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void MOTION_DePause()
	{
		_MOTION_DePause_HrCamera__QAEXXZ mFunc = (_MOTION_DePause_HrCamera__QAEXXZ)(GameModule + 0xa9b60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::MOTION_Pause(class HrCamera* const this) [?MOTION_Pause@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _MOTION_Pause_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void MOTION_Pause()
	{
		_MOTION_Pause_HrCamera__QAEXXZ mFunc = (_MOTION_Pause_HrCamera__QAEXXZ)(GameModule + 0xa9b70);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrCamera::MOTION_GetTick(class HrCamera* const this) [?MOTION_GetTick@HrCamera@@QBEMXZ]
	typedef float(__thiscall* _MOTION_GetTick_HrCamera__QBEMXZ)(class HrCamera* const thisPtr);
	float MOTION_GetTick()
	{
		_MOTION_GetTick_HrCamera__QBEMXZ mFunc = (_MOTION_GetTick_HrCamera__QBEMXZ)(GameModule + 0xa9ba0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrCamera::MOTION_GetTotalTick(class HrCamera* const this) [?MOTION_GetTotalTick@HrCamera@@QBEMXZ]
	typedef float(__thiscall* _MOTION_GetTotalTick_HrCamera__QBEMXZ)(class HrCamera* const thisPtr);
	float MOTION_GetTotalTick()
	{
		_MOTION_GetTotalTick_HrCamera__QBEMXZ mFunc = (_MOTION_GetTotalTick_HrCamera__QBEMXZ)(GameModule + 0xac780);
		return mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") HrCamera::getLookAtPosition(class HrCamera* const this) [?getLookAtPosition@HrCamera@@QBEABUVec@@XZ]
	typedef struct Vec&(__thiscall* _getLookAtPosition_HrCamera__QBEABUVec__XZ)(class HrCamera* const thisPtr);
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void getLookAtPosition()
	{
		_getLookAtPosition_HrCamera__QBEABUVec__XZ mFunc = (_getLookAtPosition_HrCamera__QBEABUVec__XZ)(GameModule + 0xaf940);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::MOTION_SetPlayRate(class HrCamera* const this, float const arg2) [?MOTION_SetPlayRate@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOTION_SetPlayRate_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float const arg2);
	void MOTION_SetPlayRate(float const arg2)
	{
		_MOTION_SetPlayRate_HrCamera__QAEXM_Z mFunc = (_MOTION_SetPlayRate_HrCamera__QAEXM_Z)(GameModule + 0xb0500);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::AdjustStageColl(class HrCamera* const this, struct Vec* arg2, struct Vec* arg3) [?AdjustStageColl@HrCamera@@AAE_NPAUVec@@0@Z]
	typedef uint8_t(__thiscall* _AdjustStageColl_HrCamera__AAE_NPAUVec__0_Z)(class HrCamera* const thisPtr, struct Vec* arg2, struct Vec* arg3);
	uint8_t AdjustStageColl(struct Vec* arg2, struct Vec* arg3)
	{
		_AdjustStageColl_HrCamera__AAE_NPAUVec__0_Z mFunc = (_AdjustStageColl_HrCamera__AAE_NPAUVec__0_Z)(GameModule + 0x44b260);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrCamera::Render(class HrCamera* const this) [?Render@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _Render_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void Render()
	{
		_Render_HrCamera__QAEXXZ mFunc = (_Render_HrCamera__QAEXXZ)(GameModule + 0x44b640);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::RailProc(class HrCamera* const this) [?RailProc@HrCamera@@AAEXXZ]
	typedef void(__thiscall* _RailProc_HrCamera__AAEXXZ)(class HrCamera* const thisPtr);
	void RailProc()
	{
		_RailProc_HrCamera__AAEXXZ mFunc = (_RailProc_HrCamera__AAEXXZ)(GameModule + 0x44b650);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrCamera::MOVE_SetTargetDirection(class HrCamera* const this) [?MOVE_SetTargetDirection@HrCamera@@QAEMXZ]
	typedef float(__thiscall* _MOVE_SetTargetDirection_HrCamera__QAEMXZ)(class HrCamera* const thisPtr);
	float MOVE_SetTargetDirection()
	{
		_MOVE_SetTargetDirection_HrCamera__QAEMXZ mFunc = (_MOVE_SetTargetDirection_HrCamera__QAEMXZ)(GameModule + 0x44c4b0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrCamera::MOVE_GetTargetPositionAddY(class HrCamera* const this) [?MOVE_GetTargetPositionAddY@HrCamera@@QAEMXZ]
	typedef float(__thiscall* _MOVE_GetTargetPositionAddY_HrCamera__QAEMXZ)(class HrCamera* const thisPtr);
	float MOVE_GetTargetPositionAddY()
	{
		_MOVE_GetTargetPositionAddY_HrCamera__QAEMXZ mFunc = (_MOVE_GetTargetPositionAddY_HrCamera__QAEMXZ)(GameModule + 0x44c4c0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrCamera::MOVE_GetCamera_Target_Angle(class HrCamera* const this) [?MOVE_GetCamera_Target_Angle@HrCamera@@QAEMXZ]
	typedef float(__thiscall* _MOVE_GetCamera_Target_Angle_HrCamera__QAEMXZ)(class HrCamera* const thisPtr);
	float MOVE_GetCamera_Target_Angle()
	{
		_MOVE_GetCamera_Target_Angle_HrCamera__QAEMXZ mFunc = (_MOVE_GetCamera_Target_Angle_HrCamera__QAEMXZ)(GameModule + 0x44c4d0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrCamera::MOVE_GetCamera_Target_Length(class HrCamera* const this) [?MOVE_GetCamera_Target_Length@HrCamera@@QAEMXZ]
	typedef float(__thiscall* _MOVE_GetCamera_Target_Length_HrCamera__QAEMXZ)(class HrCamera* const thisPtr);
	float MOVE_GetCamera_Target_Length()
	{
		_MOVE_GetCamera_Target_Length_HrCamera__QAEMXZ mFunc = (_MOVE_GetCamera_Target_Length_HrCamera__QAEMXZ)(GameModule + 0x44c4e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE_SetEnableCollision(class HrCamera* const this, uint8_t arg2) [?MOVE_SetEnableCollision@HrCamera@@QAEX_N@Z]
	typedef void(__thiscall* _MOVE_SetEnableCollision_HrCamera__QAEX_N_Z)(class HrCamera* const thisPtr, uint8_t arg2);
	void MOVE_SetEnableCollision(uint8_t arg2)
	{
		_MOVE_SetEnableCollision_HrCamera__QAEX_N_Z mFunc = (_MOVE_SetEnableCollision_HrCamera__QAEX_N_Z)(GameModule + 0x44c4f0);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") HrCamera::NORMAL_GetFov(class HrCamera* const this) [?NORMAL_GetFov@HrCamera@@QAEMXZ]
	typedef float(__thiscall* _NORMAL_GetFov_HrCamera__QAEMXZ)(class HrCamera* const thisPtr);
	float NORMAL_GetFov()
	{
		_NORMAL_GetFov_HrCamera__QAEMXZ mFunc = (_NORMAL_GetFov_HrCamera__QAEMXZ)(GameModule + 0x44c500);
		return mFunc(this);
	}
	// [Function] struct Vec __convention("thiscall") HrCamera::NORMAL_GetTargetPosition(class HrCamera* const this) [?NORMAL_GetTargetPosition@HrCamera@@QAE?AUVec@@XZ]
	typedef struct Vec(__thiscall* _NORMAL_GetTargetPosition_HrCamera__QAEAUVec__XZ)(class HrCamera* const thisPtr);
	struct Vec NORMAL_GetTargetPosition()
	{
		_NORMAL_GetTargetPosition_HrCamera__QAEAUVec__XZ mFunc = (_NORMAL_GetTargetPosition_HrCamera__QAEAUVec__XZ)(GameModule + 0x44c510);
		return mFunc(this);
	}
	// [Function] struct Vec __convention("thiscall") HrCamera::NORMAL_GetCameraPosition(class HrCamera* const this) [?NORMAL_GetCameraPosition@HrCamera@@QAE?AUVec@@XZ]
	typedef struct Vec(__thiscall* _NORMAL_GetCameraPosition_HrCamera__QAEAUVec__XZ)(class HrCamera* const thisPtr);
	struct Vec NORMAL_GetCameraPosition()
	{
		_NORMAL_GetCameraPosition_HrCamera__QAEAUVec__XZ mFunc = (_NORMAL_GetCameraPosition_HrCamera__QAEAUVec__XZ)(GameModule + 0x44c530);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::NORMAL_SetUpVector(class HrCamera* const this, struct Vec* arg2) [?NORMAL_SetUpVector@HrCamera@@QAEXPBUVec@@@Z]
	typedef void(__thiscall* _NORMAL_SetUpVector_HrCamera__QAEXPBUVec___Z)(class HrCamera* const thisPtr, struct Vec* arg2);
	void NORMAL_SetUpVector(struct Vec* arg2)
	{
		_NORMAL_SetUpVector_HrCamera__QAEXPBUVec___Z mFunc = (_NORMAL_SetUpVector_HrCamera__QAEXPBUVec___Z)(GameModule + 0x44c550);
		return mFunc(this, arg2);
	}
	// [Function] struct HrCamera::MOVE2* __convention("thiscall") HrCamera::MOVE2_GetParam(class HrCamera* const this) [?MOVE2_GetParam@HrCamera@@QAEPBUMOVE2@1@XZ]
	typedef struct HrCamera::MOVE2*(__thiscall* _MOVE2_GetParam_HrCamera__QAEPBUMOVE2_1_XZ)(class HrCamera* const thisPtr);
	struct HrCamera::MOVE2* MOVE2_GetParam()
	{
		_MOVE2_GetParam_HrCamera__QAEPBUMOVE2_1_XZ mFunc = (_MOVE2_GetParam_HrCamera__QAEPBUMOVE2_1_XZ)(GameModule + 0x44c570);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE2_SetPlayerLookRate(class HrCamera* const this, float arg2) [?MOVE2_SetPlayerLookRate@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOVE2_SetPlayerLookRate_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float arg2);
	void MOVE2_SetPlayerLookRate(float arg2)
	{
		_MOVE2_SetPlayerLookRate_HrCamera__QAEXM_Z mFunc = (_MOVE2_SetPlayerLookRate_HrCamera__QAEXM_Z)(GameModule + 0x44c580);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE2_SetCameraYAngleRate(class HrCamera* const this, float arg2) [?MOVE2_SetCameraYAngleRate@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOVE2_SetCameraYAngleRate_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float arg2);
	void MOVE2_SetCameraYAngleRate(float arg2)
	{
		_MOVE2_SetCameraYAngleRate_HrCamera__QAEXM_Z mFunc = (_MOVE2_SetCameraYAngleRate_HrCamera__QAEXM_Z)(GameModule + 0x44c590);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE2_SetPlayerAngle(class HrCamera* const this, float arg2) [?MOVE2_SetPlayerAngle@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOVE2_SetPlayerAngle_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float arg2);
	void MOVE2_SetPlayerAngle(float arg2)
	{
		_MOVE2_SetPlayerAngle_HrCamera__QAEXM_Z mFunc = (_MOVE2_SetPlayerAngle_HrCamera__QAEXM_Z)(GameModule + 0x44c5c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::FREE_LinearSkip(class HrCamera* const this) [?FREE_LinearSkip@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _FREE_LinearSkip_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void FREE_LinearSkip()
	{
		_FREE_LinearSkip_HrCamera__QAEXXZ mFunc = (_FREE_LinearSkip_HrCamera__QAEXXZ)(GameModule + 0x44c5e0);
		return mFunc(this);
	}
	// [Function] class TGanPlayNode* __convention("thiscall") HrCamera::MOTION_searchBestCamera(class HrCamera* const this) [?MOTION_searchBestCamera@HrCamera@@AAEPAVTGanPlayNode@@XZ]
	typedef class TGanPlayNode*(__thiscall* _MOTION_searchBestCamera_HrCamera__AAEPAVTGanPlayNode__XZ)(class HrCamera* const thisPtr);
	class TGanPlayNode* MOTION_searchBestCamera()
	{
		_MOTION_searchBestCamera_HrCamera__AAEPAVTGanPlayNode__XZ mFunc = (_MOTION_searchBestCamera_HrCamera__AAEPAVTGanPlayNode__XZ)(GameModule + 0x44c630);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrCamera::MOTION_GetTickRate(class HrCamera* const this) [?MOTION_GetTickRate@HrCamera@@QBEMXZ]
	typedef float(__thiscall* _MOTION_GetTickRate_HrCamera__QBEMXZ)(class HrCamera* const thisPtr);
	float MOTION_GetTickRate()
	{
		_MOTION_GetTickRate_HrCamera__QBEMXZ mFunc = (_MOTION_GetTickRate_HrCamera__QBEMXZ)(GameModule + 0x44cce0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::SetupMatrix(class HrCamera* const this) [?SetupMatrix@HrCamera@@AAEXXZ]
	typedef void(__thiscall* _SetupMatrix_HrCamera__AAEXXZ)(class HrCamera* const thisPtr);
	void SetupMatrix()
	{
		_SetupMatrix_HrCamera__AAEXXZ mFunc = (_SetupMatrix_HrCamera__AAEXXZ)(GameModule + 0x44cd20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::updateUpVector(class HrCamera* const this) [?updateUpVector@HrCamera@@AAEXXZ]
	typedef void(__thiscall* _updateUpVector_HrCamera__AAEXXZ)(class HrCamera* const thisPtr);
	void updateUpVector()
	{
		_updateUpVector_HrCamera__AAEXXZ mFunc = (_updateUpVector_HrCamera__AAEXXZ)(GameModule + 0x44cdf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::updatePositionByCollision(class HrCamera* const this) [?updatePositionByCollision@HrCamera@@AAEXXZ]
	typedef void(__thiscall* _updatePositionByCollision_HrCamera__AAEXXZ)(class HrCamera* const thisPtr);
	void updatePositionByCollision()
	{
		_updatePositionByCollision_HrCamera__AAEXXZ mFunc = (_updatePositionByCollision_HrCamera__AAEXXZ)(GameModule + 0x44cfe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::AddCollObj(class HrCamera* const this) [?AddCollObj@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _AddCollObj_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void AddCollObj()
	{
		_AddCollObj_HrCamera__QAEXXZ mFunc = (_AddCollObj_HrCamera__QAEXXZ)(GameModule + 0x44d670);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::DeleteCollObj(class HrCamera* const this) [?DeleteCollObj@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _DeleteCollObj_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void DeleteCollObj()
	{
		_DeleteCollObj_HrCamera__QAEXXZ mFunc = (_DeleteCollObj_HrCamera__QAEXXZ)(GameModule + 0x44d730);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::SetTarget(class HrCamera* const this, struct Vec& arg2) [?SetTarget@HrCamera@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _SetTarget_HrCamera__QAEXABUVec___Z)(class HrCamera* const thisPtr, struct Vec& arg2);
	void SetTarget(struct Vec& arg2)
	{
		_SetTarget_HrCamera__QAEXABUVec___Z mFunc = (_SetTarget_HrCamera__QAEXABUVec___Z)(GameModule + 0x44d790);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::SetRailPathTarget(class HrCamera* const this, struct Vec& arg2) [?SetRailPathTarget@HrCamera@@QAEXABUVec@@@Z]
	typedef void(__thiscall* _SetRailPathTarget_HrCamera__QAEXABUVec___Z)(class HrCamera* const thisPtr, struct Vec& arg2);
	void SetRailPathTarget(struct Vec& arg2)
	{
		_SetRailPathTarget_HrCamera__QAEXABUVec___Z mFunc = (_SetRailPathTarget_HrCamera__QAEXABUVec___Z)(GameModule + 0x44d8f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::CheckChangeRail(class HrCamera* const this, struct Vec& arg2) [?CheckChangeRail@HrCamera@@QAE_NABUVec@@@Z]
	typedef uint8_t(__thiscall* _CheckChangeRail_HrCamera__QAE_NABUVec___Z)(class HrCamera* const thisPtr, struct Vec& arg2);
	uint8_t CheckChangeRail(struct Vec& arg2)
	{
		_CheckChangeRail_HrCamera__QAE_NABUVec___Z mFunc = (_CheckChangeRail_HrCamera__QAE_NABUVec___Z)(GameModule + 0x44da40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE_SetPlayerPosition(class HrCamera* const this, uint8_t arg2, struct Vec* arg3) [?MOVE_SetPlayerPosition@HrCamera@@QAEX_NPAUVec@@@Z]
	typedef void(__thiscall* _MOVE_SetPlayerPosition_HrCamera__QAEX_NPAUVec___Z)(class HrCamera* const thisPtr, uint8_t arg2, struct Vec* arg3);
	void MOVE_SetPlayerPosition(uint8_t arg2, struct Vec* arg3)
	{
		_MOVE_SetPlayerPosition_HrCamera__QAEX_NPAUVec___Z mFunc = (_MOVE_SetPlayerPosition_HrCamera__QAEX_NPAUVec___Z)(GameModule + 0x44dbe0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE_SetTargetPosition(class HrCamera* const this, struct Vec* arg2) [?MOVE_SetTargetPosition@HrCamera@@QAEXPAUVec@@@Z]
	typedef void(__thiscall* _MOVE_SetTargetPosition_HrCamera__QAEXPAUVec___Z)(class HrCamera* const thisPtr, struct Vec* arg2);
	void MOVE_SetTargetPosition(struct Vec* arg2)
	{
		_MOVE_SetTargetPosition_HrCamera__QAEXPAUVec___Z mFunc = (_MOVE_SetTargetPosition_HrCamera__QAEXPAUVec___Z)(GameModule + 0x44dc10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE_SetTargetDirection(class HrCamera* const this, float arg2) [?MOVE_SetTargetDirection@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOVE_SetTargetDirection_HrCamera__QAEXM_Z_2)(class HrCamera* const thisPtr, float arg2);
	void MOVE_SetTargetDirection_2(float arg2)
	{
		_MOVE_SetTargetDirection_HrCamera__QAEXM_Z_2 mFunc = (_MOVE_SetTargetDirection_HrCamera__QAEXM_Z_2)(GameModule + 0x44dc30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE_SetTargetPositionAddY(class HrCamera* const this, float arg2) [?MOVE_SetTargetPositionAddY@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOVE_SetTargetPositionAddY_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float arg2);
	void MOVE_SetTargetPositionAddY(float arg2)
	{
		_MOVE_SetTargetPositionAddY_HrCamera__QAEXM_Z mFunc = (_MOVE_SetTargetPositionAddY_HrCamera__QAEXM_Z)(GameModule + 0x44dcd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE_SetCamera_Target_Length(class HrCamera* const this, float arg2) [?MOVE_SetCamera_Target_Length@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOVE_SetCamera_Target_Length_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float arg2);
	void MOVE_SetCamera_Target_Length(float arg2)
	{
		_MOVE_SetCamera_Target_Length_HrCamera__QAEXM_Z mFunc = (_MOVE_SetCamera_Target_Length_HrCamera__QAEXM_Z)(GameModule + 0x44dce0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE_SetCamera_Target_Angle(class HrCamera* const this, float arg2) [?MOVE_SetCamera_Target_Angle@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOVE_SetCamera_Target_Angle_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float arg2);
	void MOVE_SetCamera_Target_Angle(float arg2)
	{
		_MOVE_SetCamera_Target_Angle_HrCamera__QAEXM_Z mFunc = (_MOVE_SetCamera_Target_Angle_HrCamera__QAEXM_Z)(GameModule + 0x44dcf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE_LinearSkip(class HrCamera* const this) [?MOVE_LinearSkip@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _MOVE_LinearSkip_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void MOVE_LinearSkip()
	{
		_MOVE_LinearSkip_HrCamera__QAEXXZ mFunc = (_MOVE_LinearSkip_HrCamera__QAEXXZ)(GameModule + 0x44dd00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE2_SetCameraAngle(class HrCamera* const this, float arg2) [?MOVE2_SetCameraAngle@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOVE2_SetCameraAngle_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float arg2);
	void MOVE2_SetCameraAngle(float arg2)
	{
		_MOVE2_SetCameraAngle_HrCamera__QAEXM_Z mFunc = (_MOVE2_SetCameraAngle_HrCamera__QAEXM_Z)(GameModule + 0x44dd30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::ChangeMode(class HrCamera* const this, enum HRCAMERA_MODE arg2, uint8_t arg3) [?ChangeMode@HrCamera@@QAE_NW4HRCAMERA_MODE@@_N@Z]
	typedef uint8_t(__thiscall* _ChangeMode_HrCamera__QAE_NW4HRCAMERA_MODE___N_Z)(class HrCamera* const thisPtr, enum HRCAMERA_MODE arg2, uint8_t arg3);
	uint8_t ChangeMode(/* enum HRCAMERA_MODE */ uint32_t arg2, uint8_t arg3)
	{
		_ChangeMode_HrCamera__QAE_NW4HRCAMERA_MODE___N_Z mFunc = (_ChangeMode_HrCamera__QAE_NW4HRCAMERA_MODE___N_Z)(GameModule + 0x44dd50);
		return mFunc(this, (enum HRCAMERA_MODE)arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrCamera::FREE_SetVDirection(class HrCamera* const this, float const arg2, uint8_t const arg3) [?FREE_SetVDirection@HrCamera@@QAEXM_N@Z]
	typedef void(__thiscall* _FREE_SetVDirection_HrCamera__QAEXM_N_Z)(class HrCamera* const thisPtr, float const arg2, uint8_t const arg3);
	void FREE_SetVDirection(float const arg2, uint8_t const arg3)
	{
		_FREE_SetVDirection_HrCamera__QAEXM_N_Z mFunc = (_FREE_SetVDirection_HrCamera__QAEXM_N_Z)(GameModule + 0x44dec0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrCamera::FREE_SetYDirection(class HrCamera* const this, float const arg2, uint8_t const arg3) [?FREE_SetYDirection@HrCamera@@QAEXM_N@Z]
	typedef void(__thiscall* _FREE_SetYDirection_HrCamera__QAEXM_N_Z)(class HrCamera* const thisPtr, float const arg2, uint8_t const arg3);
	void FREE_SetYDirection(float const arg2, uint8_t const arg3)
	{
		_FREE_SetYDirection_HrCamera__QAEXM_N_Z mFunc = (_FREE_SetYDirection_HrCamera__QAEXM_N_Z)(GameModule + 0x44dee0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrCamera::FREE_SetPosition(class HrCamera* const this, struct Vec* arg2, uint8_t const arg3) [?FREE_SetPosition@HrCamera@@QAEXPBUVec@@_N@Z]
	typedef void(__thiscall* _FREE_SetPosition_HrCamera__QAEXPBUVec___N_Z)(class HrCamera* const thisPtr, struct Vec* arg2, uint8_t const arg3);
	void FREE_SetPosition(struct Vec* arg2, uint8_t const arg3)
	{
		_FREE_SetPosition_HrCamera__QAEXPBUVec___N_Z mFunc = (_FREE_SetPosition_HrCamera__QAEXPBUVec___N_Z)(GameModule + 0x44df00);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrCamera::NORMAL_SetCameraPosition(class HrCamera* const this, struct Vec* arg2) [?NORMAL_SetCameraPosition@HrCamera@@QAEXPBUVec@@@Z]
	typedef void(__thiscall* _NORMAL_SetCameraPosition_HrCamera__QAEXPBUVec___Z)(class HrCamera* const thisPtr, struct Vec* arg2);
	void NORMAL_SetCameraPosition(struct Vec* arg2)
	{
		_NORMAL_SetCameraPosition_HrCamera__QAEXPBUVec___Z mFunc = (_NORMAL_SetCameraPosition_HrCamera__QAEXPBUVec___Z)(GameModule + 0x44df20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::NORMAL_SetTargetPosition(class HrCamera* const this, struct Vec* arg2) [?NORMAL_SetTargetPosition@HrCamera@@QAEXPBUVec@@@Z]
	typedef void(__thiscall* _NORMAL_SetTargetPosition_HrCamera__QAEXPBUVec___Z)(class HrCamera* const thisPtr, struct Vec* arg2);
	void NORMAL_SetTargetPosition(struct Vec* arg2)
	{
		_NORMAL_SetTargetPosition_HrCamera__QAEXPBUVec___Z mFunc = (_NORMAL_SetTargetPosition_HrCamera__QAEXPBUVec___Z)(GameModule + 0x44df40);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") HrCamera::GetDirectionY(class HrCamera* const this) [?GetDirectionY@HrCamera@@QBEMXZ]
	typedef float(__thiscall* _GetDirectionY_HrCamera__QBEMXZ)(class HrCamera* const thisPtr);
	float GetDirectionY()
	{
		_GetDirectionY_HrCamera__QBEMXZ mFunc = (_GetDirectionY_HrCamera__QBEMXZ)(GameModule + 0x44df60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::MOTION_SetParam(class HrCamera* const this, class TGan* arg2, char const* arg3, uint8_t const arg4, float const arg5, uint8_t arg6) [?MOTION_SetParam@HrCamera@@QAE_NPAVTGan@@PBD_NM_N@Z]
	typedef uint8_t(__thiscall* _MOTION_SetParam_HrCamera__QAE_NPAVTGan__PBD_NM_N_Z)(class HrCamera* const thisPtr, class TGan* arg2, char const* arg3, uint8_t const arg4, float const arg5, uint8_t arg6);
	uint8_t MOTION_SetParam(class TGan* arg2, std::string arg3, uint8_t const arg4, float const arg5, uint8_t arg6)
	{
		char const* arg3_c_str = arg3.c_str();
		_MOTION_SetParam_HrCamera__QAE_NPAVTGan__PBD_NM_N_Z mFunc = (_MOTION_SetParam_HrCamera__QAE_NPAVTGan__PBD_NM_N_Z)(GameModule + 0x44df90);
		return mFunc(this, arg2, arg3_c_str, arg4, arg5, arg6);
	}
	// [Function] void __convention("thiscall") HrCamera::MOTION_SetTranslate(class HrCamera* const this, struct Vec* arg2) [?MOTION_SetTranslate@HrCamera@@QAEXPBUVec@@@Z]
	typedef void(__thiscall* _MOTION_SetTranslate_HrCamera__QAEXPBUVec___Z)(class HrCamera* const thisPtr, struct Vec* arg2);
	void MOTION_SetTranslate(struct Vec* arg2)
	{
		_MOTION_SetTranslate_HrCamera__QAEXPBUVec___Z mFunc = (_MOTION_SetTranslate_HrCamera__QAEXPBUVec___Z)(GameModule + 0x44e060);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOTION_SetRotateY(class HrCamera* const this, float const arg2) [?MOTION_SetRotateY@HrCamera@@QAEXM@Z]
	typedef void(__thiscall* _MOTION_SetRotateY_HrCamera__QAEXM_Z)(class HrCamera* const thisPtr, float const arg2);
	void MOTION_SetRotateY(float const arg2)
	{
		_MOTION_SetRotateY_HrCamera__QAEXM_Z mFunc = (_MOTION_SetRotateY_HrCamera__QAEXM_Z)(GameModule + 0x44e090);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE2_SetPlayerPosition(class HrCamera* const this, struct Vec* arg2) [?MOVE2_SetPlayerPosition@HrCamera@@QAEXPAUVec@@@Z]
	typedef void(__thiscall* _MOVE2_SetPlayerPosition_HrCamera__QAEXPAUVec___Z)(class HrCamera* const thisPtr, struct Vec* arg2);
	void MOVE2_SetPlayerPosition(struct Vec* arg2)
	{
		_MOVE2_SetPlayerPosition_HrCamera__QAEXPAUVec___Z mFunc = (_MOVE2_SetPlayerPosition_HrCamera__QAEXPAUVec___Z)(GameModule + 0x44e100);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrCamera::MOVE2_LinearSkip(class HrCamera* const this) [?MOVE2_LinearSkip@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _MOVE2_LinearSkip_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void MOVE2_LinearSkip()
	{
		_MOVE2_LinearSkip_HrCamera__QAEXXZ mFunc = (_MOVE2_LinearSkip_HrCamera__QAEXXZ)(GameModule + 0x44e160);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") HrCamera::GetDirectionOir(class HrCamera* const this) [?GetDirectionOir@HrCamera@@QBEMXZ]
	typedef float(__thiscall* _GetDirectionOir_HrCamera__QBEMXZ)(class HrCamera* const thisPtr);
	float GetDirectionOir()
	{
		_GetDirectionOir_HrCamera__QBEMXZ mFunc = (_GetDirectionOir_HrCamera__QBEMXZ)(GameModule + 0x44e190);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrCamera::NORMAL_SetFov(class HrCamera* const this, uint8_t arg2, float arg3) [?NORMAL_SetFov@HrCamera@@QAEX_NM@Z]
	typedef void(__thiscall* _NORMAL_SetFov_HrCamera__QAEX_NM_Z)(class HrCamera* const thisPtr, uint8_t arg2, float arg3);
	void NORMAL_SetFov(uint8_t arg2, float arg3)
	{
		_NORMAL_SetFov_HrCamera__QAEX_NM_Z mFunc = (_NORMAL_SetFov_HrCamera__QAEX_NM_Z)(GameModule + 0x44e2e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrCamera::FrameProcess(class HrCamera* const this) [?FrameProcess@HrCamera@@QAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrCamera__QAEXXZ)(class HrCamera* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrCamera__QAEXXZ mFunc = (_FrameProcess_HrCamera__QAEXXZ)(GameModule + 0x44e300);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::SetNoChangeMode(class HrCamera* const this, uint8_t arg2) [?SetNoChangeMode@HrCamera@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _SetNoChangeMode_HrCamera__QAE_N_N_Z)(class HrCamera* const thisPtr, uint8_t arg2);
	uint8_t SetNoChangeMode(uint8_t arg2)
	{
		_SetNoChangeMode_HrCamera__QAE_N_N_Z mFunc = (_SetNoChangeMode_HrCamera__QAE_N_N_Z)(GameModule + 0x44ef20);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::SetNoTeppeiMode(class HrCamera* const this, uint8_t arg2) [?SetNoTeppeiMode@HrCamera@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _SetNoTeppeiMode_HrCamera__QAE_N_N_Z)(class HrCamera* const thisPtr, uint8_t arg2);
	uint8_t SetNoTeppeiMode(uint8_t arg2)
	{
		_SetNoTeppeiMode_HrCamera__QAE_N_N_Z mFunc = (_SetNoTeppeiMode_HrCamera__QAE_N_N_Z)(GameModule + 0x44ef40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::SetNoAspectChange(class HrCamera* const this, uint8_t arg2) [?SetNoAspectChange@HrCamera@@QAE_N_N@Z]
	typedef uint8_t(__thiscall* _SetNoAspectChange_HrCamera__QAE_N_N_Z)(class HrCamera* const thisPtr, uint8_t arg2);
	uint8_t SetNoAspectChange(uint8_t arg2)
	{
		_SetNoAspectChange_HrCamera__QAE_N_N_Z mFunc = (_SetNoAspectChange_HrCamera__QAE_N_N_Z)(GameModule + 0x44ef60);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::ClearRailData(class HrCamera* const this) [?ClearRailData@HrCamera@@QAE_NXZ]
	typedef uint8_t(__thiscall* _ClearRailData_HrCamera__QAE_NXZ)(class HrCamera* const thisPtr);
	uint8_t ClearRailData()
	{
		_ClearRailData_HrCamera__QAE_NXZ mFunc = (_ClearRailData_HrCamera__QAE_NXZ)(GameModule + 0x44ef80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrCamera::SetRailData(class HrCamera* const this, void* arg2) [?SetRailData@HrCamera@@QAE_NPAX@Z]
	typedef uint8_t(__thiscall* _SetRailData_HrCamera__QAE_NPAX_Z)(class HrCamera* const thisPtr, void* arg2);
	uint8_t SetRailData(void* arg2)
	{
		_SetRailData_HrCamera__QAE_NPAX_Z mFunc = (_SetRailData_HrCamera__QAE_NPAX_Z)(GameModule + 0x44efc0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrCamera [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrCamera& InObject)
	{
		m_inPosi = InObject.m_inPosi;
		m_inLookAtPosi = InObject.m_inLookAtPosi;
		m_inUpVec = InObject.m_inUpVec;
		m_fViewAngleDeg = InObject.m_fViewAngleDeg;
		m_ePreMode = InObject.m_ePreMode;
		m_fResetYaw = InObject.m_fResetYaw;
		m_fTeppeiModeViewAngleDeg = InObject.m_fTeppeiModeViewAngleDeg;
		m_bSetUpVec = InObject.m_bSetUpVec;
		m_inMotion = InObject.m_inMotion;
		m_ModeChangeDisEnable = InObject.m_ModeChangeDisEnable;
		m_bVisible = InObject.m_bVisible;
		m = InObject.m;
		mpRailData = InObject.mpRailData;
		mRailOldPos = InObject.mRailOldPos;
		mTargetOriginal = InObject.mTargetOriginal;
		mRailTarget = InObject.mRailTarget;
		mRailTargetPos = InObject.mRailTargetPos;
		mActivePathIdx = InObject.mActivePathIdx;
		mActivePosIdx = InObject.mActivePosIdx;
		mActiveLinkIdx = InObject.mActiveLinkIdx;
		mBefPosIdx = InObject.mBefPosIdx;
		mBefPathIdx = InObject.mBefPathIdx;
		mbLineChange = InObject.mbLineChange;
		mLineChangeRate = InObject.mLineChangeRate;
		mLineChangeSpeed = InObject.mLineChangeSpeed;
		mBefChangePos = InObject.mBefChangePos;
		mBefLineVec = InObject.mBefLineVec;
		mOldLineVec = InObject.mOldLineVec;
		mSearchDist = InObject.mSearchDist;
		mTargetAdjust = InObject.mTargetAdjust;
		mOldTargetAdjust = InObject.mOldTargetAdjust;
		mPosAdjust = InObject.mPosAdjust;
		mBefPosAdust = InObject.mBefPosAdust;
		mOldPosAdust = InObject.mOldPosAdust;
		mPosAdustBase = InObject.mPosAdustBase;
		mRailTargetInterval = InObject.mRailTargetInterval;
		mRailPosInterval = InObject.mRailPosInterval;
		mbSetRailTargetInit = InObject.mbSetRailTargetInit;
		mbSetRailPosInit = InObject.mbSetRailPosInit;
		mbChangeInterpolate = InObject.mbChangeInterpolate;
		mTrackTarget = InObject.mTrackTarget;
		mTrackLength = InObject.mTrackLength;
		mBefTrackLength = InObject.mBefTrackLength;
		mNPCAdjustDist = InObject.mNPCAdjustDist;
		mNPCAdjustValue = InObject.mNPCAdjustValue;
		mNPCAdjustSpeed = InObject.mNPCAdjustSpeed;
		mNPCAdustVec = InObject.mNPCAdustVec;
		mNPCAjustDist = InObject.mNPCAjustDist;
		mNoTeppeiMode = InObject.mNoTeppeiMode;
		mAspectChangeDisEnable = InObject.mAspectChangeDisEnable;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrCamera>("HrCamera")
			.addFunction("__tostring", &HrCamera::ToString)
			.addFunction("GetPtrAddr", &HrCamera::GetPtrAddr)
			.addProperty("m_inPosi", &HrCamera::m_inPosi)
			.addProperty("m_inLookAtPosi", &HrCamera::m_inLookAtPosi)
			.addProperty("m_inUpVec", &HrCamera::m_inUpVec)
			.addProperty("m_fViewAngleDeg", &HrCamera::m_fViewAngleDeg)
			.addProperty("m_ePreMode", &HrCamera::m_ePreMode)
			.addProperty("m_fResetYaw", &HrCamera::m_fResetYaw)
			.addProperty("m_fTeppeiModeViewAngleDeg", &HrCamera::m_fTeppeiModeViewAngleDeg)
			.addProperty("m_bSetUpVec", &HrCamera::m_bSetUpVec)
			.addProperty("m_inMotion", &HrCamera::m_inMotion)
			.addProperty("m_ModeChangeDisEnable", &HrCamera::m_ModeChangeDisEnable)
			.addProperty("m_bVisible", &HrCamera::m_bVisible)
			.addProperty("m", &HrCamera::m)
			.addProperty("mpRailData", &HrCamera::mpRailData)
			.addProperty("mRailOldPos", &HrCamera::mRailOldPos)
			.addProperty("mTargetOriginal", &HrCamera::mTargetOriginal)
			.addProperty("mRailTarget", &HrCamera::mRailTarget)
			.addProperty("mRailTargetPos", &HrCamera::mRailTargetPos)
			.addProperty("mActivePathIdx", &HrCamera::mActivePathIdx)
			.addProperty("mActivePosIdx", &HrCamera::mActivePosIdx)
			.addProperty("mActiveLinkIdx", &HrCamera::mActiveLinkIdx)
			.addProperty("mBefPosIdx", &HrCamera::mBefPosIdx)
			.addProperty("mBefPathIdx", &HrCamera::mBefPathIdx)
			.addProperty("mbLineChange", &HrCamera::mbLineChange)
			.addProperty("mLineChangeRate", &HrCamera::mLineChangeRate)
			.addProperty("mLineChangeSpeed", &HrCamera::mLineChangeSpeed)
			.addProperty("mBefChangePos", &HrCamera::mBefChangePos)
			.addProperty("mBefLineVec", &HrCamera::mBefLineVec)
			.addProperty("mOldLineVec", &HrCamera::mOldLineVec)
			.addProperty("mSearchDist", &HrCamera::mSearchDist)
			.addProperty("mTargetAdjust", &HrCamera::mTargetAdjust)
			.addProperty("mOldTargetAdjust", &HrCamera::mOldTargetAdjust)
			.addProperty("mPosAdjust", &HrCamera::mPosAdjust)
			.addProperty("mBefPosAdust", &HrCamera::mBefPosAdust)
			.addProperty("mOldPosAdust", &HrCamera::mOldPosAdust)
			.addProperty("mPosAdustBase", &HrCamera::mPosAdustBase)
			.addProperty("mRailTargetInterval", &HrCamera::mRailTargetInterval)
			.addProperty("mRailPosInterval", &HrCamera::mRailPosInterval)
			.addProperty("mbSetRailTargetInit", &HrCamera::mbSetRailTargetInit)
			.addProperty("mbSetRailPosInit", &HrCamera::mbSetRailPosInit)
			.addProperty("mbChangeInterpolate", &HrCamera::mbChangeInterpolate)
			.addProperty("mTrackTarget", &HrCamera::mTrackTarget)
			.addProperty("mTrackLength", &HrCamera::mTrackLength)
			.addProperty("mBefTrackLength", &HrCamera::mBefTrackLength)
			.addProperty("mNPCAdjustDist", &HrCamera::mNPCAdjustDist)
			.addProperty("mNPCAdjustValue", &HrCamera::mNPCAdjustValue)
			.addProperty("mNPCAdjustSpeed", &HrCamera::mNPCAdjustSpeed)
			.addProperty("mNPCAdustVec", &HrCamera::mNPCAdustVec)
			.addProperty("mNPCAjustDist", &HrCamera::mNPCAjustDist)
			.addProperty("mNoTeppeiMode", &HrCamera::mNoTeppeiMode)
			.addProperty("mAspectChangeDisEnable", &HrCamera::mAspectChangeDisEnable)
			.addFunction("MOTION_IsPlay", &HrCamera::MOTION_IsPlay)
			.addFunction("MOTION_SetLoop", &HrCamera::MOTION_SetLoop)
			.addFunction("MOTION_SetEnableCollision", &HrCamera::MOTION_SetEnableCollision)
			.addFunction("SetVisible", &HrCamera::SetVisible)
			.addFunction("GetMode", &HrCamera::GetMode)
			.addFunction("setTeppeiModeViewAngleDegree", &HrCamera::setTeppeiModeViewAngleDegree)
			.addFunction("GetPreMode", &HrCamera::GetPreMode)
			.addFunction("getPosition", &HrCamera::getPosition)
			.addFunction("MOTION_Stop", &HrCamera::MOTION_Stop)
			.addFunction("MOTION_DePause", &HrCamera::MOTION_DePause)
			.addFunction("MOTION_Pause", &HrCamera::MOTION_Pause)
			.addFunction("MOTION_GetTick", &HrCamera::MOTION_GetTick)
			.addFunction("MOTION_GetTotalTick", &HrCamera::MOTION_GetTotalTick)
			.addFunction("getLookAtPosition", &HrCamera::getLookAtPosition)
			.addFunction("MOTION_SetPlayRate", &HrCamera::MOTION_SetPlayRate)
			.addFunction("AdjustStageColl", &HrCamera::AdjustStageColl)
			.addFunction("Render", &HrCamera::Render)
			.addFunction("RailProc", &HrCamera::RailProc)
			.addFunction("MOVE_SetTargetDirection", &HrCamera::MOVE_SetTargetDirection)
			.addFunction("MOVE_GetTargetPositionAddY", &HrCamera::MOVE_GetTargetPositionAddY)
			.addFunction("MOVE_GetCamera_Target_Angle", &HrCamera::MOVE_GetCamera_Target_Angle)
			.addFunction("MOVE_GetCamera_Target_Length", &HrCamera::MOVE_GetCamera_Target_Length)
			.addFunction("MOVE_SetEnableCollision", &HrCamera::MOVE_SetEnableCollision)
			.addFunction("NORMAL_GetFov", &HrCamera::NORMAL_GetFov)
			.addFunction("NORMAL_GetTargetPosition", &HrCamera::NORMAL_GetTargetPosition)
			.addFunction("NORMAL_GetCameraPosition", &HrCamera::NORMAL_GetCameraPosition)
			.addFunction("NORMAL_SetUpVector", &HrCamera::NORMAL_SetUpVector)
			.addFunction("MOVE2_GetParam", &HrCamera::MOVE2_GetParam)
			.addFunction("MOVE2_SetPlayerLookRate", &HrCamera::MOVE2_SetPlayerLookRate)
			.addFunction("MOVE2_SetCameraYAngleRate", &HrCamera::MOVE2_SetCameraYAngleRate)
			.addFunction("MOVE2_SetPlayerAngle", &HrCamera::MOVE2_SetPlayerAngle)
			.addFunction("FREE_LinearSkip", &HrCamera::FREE_LinearSkip)
			.addFunction("MOTION_searchBestCamera", &HrCamera::MOTION_searchBestCamera)
			.addFunction("MOTION_GetTickRate", &HrCamera::MOTION_GetTickRate)
			.addFunction("SetupMatrix", &HrCamera::SetupMatrix)
			.addFunction("updateUpVector", &HrCamera::updateUpVector)
			.addFunction("updatePositionByCollision", &HrCamera::updatePositionByCollision)
			.addFunction("AddCollObj", &HrCamera::AddCollObj)
			.addFunction("DeleteCollObj", &HrCamera::DeleteCollObj)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetTarget", &HrCamera::SetTarget)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetRailPathTarget", &HrCamera::SetRailPathTarget)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("CheckChangeRail", &HrCamera::CheckChangeRail)
			.addFunction("MOVE_SetPlayerPosition", &HrCamera::MOVE_SetPlayerPosition)
			.addFunction("MOVE_SetTargetPosition", &HrCamera::MOVE_SetTargetPosition)
			.addFunction("MOVE_SetTargetDirection_2", &HrCamera::MOVE_SetTargetDirection_2)
			.addFunction("MOVE_SetTargetPositionAddY", &HrCamera::MOVE_SetTargetPositionAddY)
			.addFunction("MOVE_SetCamera_Target_Length", &HrCamera::MOVE_SetCamera_Target_Length)
			.addFunction("MOVE_SetCamera_Target_Angle", &HrCamera::MOVE_SetCamera_Target_Angle)
			.addFunction("MOVE_LinearSkip", &HrCamera::MOVE_LinearSkip)
			.addFunction("MOVE2_SetCameraAngle", &HrCamera::MOVE2_SetCameraAngle)
			.addFunction("ChangeMode", &HrCamera::ChangeMode)
			.addFunction("FREE_SetVDirection", &HrCamera::FREE_SetVDirection)
			.addFunction("FREE_SetYDirection", &HrCamera::FREE_SetYDirection)
			.addFunction("FREE_SetPosition", &HrCamera::FREE_SetPosition)
			.addFunction("NORMAL_SetCameraPosition", &HrCamera::NORMAL_SetCameraPosition)
			.addFunction("NORMAL_SetTargetPosition", &HrCamera::NORMAL_SetTargetPosition)
			.addFunction("GetDirectionY", &HrCamera::GetDirectionY)
			.addFunction("MOTION_SetParam", &HrCamera::MOTION_SetParam)
			.addFunction("MOTION_SetTranslate", &HrCamera::MOTION_SetTranslate)
			.addFunction("MOTION_SetRotateY", &HrCamera::MOTION_SetRotateY)
			.addFunction("MOVE2_SetPlayerPosition", &HrCamera::MOVE2_SetPlayerPosition)
			.addFunction("MOVE2_LinearSkip", &HrCamera::MOVE2_LinearSkip)
			.addFunction("GetDirectionOir", &HrCamera::GetDirectionOir)
			.addFunction("NORMAL_SetFov", &HrCamera::NORMAL_SetFov)
			.addFunction("FrameProcess", &HrCamera::FrameProcess)
			.addFunction("SetNoChangeMode", &HrCamera::SetNoChangeMode)
			.addFunction("SetNoTeppeiMode", &HrCamera::SetNoTeppeiMode)
			.addFunction("SetNoAspectChange", &HrCamera::SetNoAspectChange)
			.addFunction("ClearRailData", &HrCamera::ClearRailData)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetRailData", &HrCamera::SetRailData)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrCamera::m_inPosi) == 12, "expected HrCamera::m_inPosi to be size 12");
static_assert(sizeof(HrCamera::m_inLookAtPosi) == 12, "expected HrCamera::m_inLookAtPosi to be size 12");
static_assert(sizeof(HrCamera::m_inUpVec) == 12, "expected HrCamera::m_inUpVec to be size 12");
static_assert(sizeof(HrCamera::m_fViewAngleDeg) == 4, "expected HrCamera::m_fViewAngleDeg to be size 4");
static_assert(sizeof(HrCamera::m_ePreMode) == 4, "expected HrCamera::m_ePreMode to be size 4");
static_assert(sizeof(HrCamera::m_fResetYaw) == 4, "expected HrCamera::m_fResetYaw to be size 4");
static_assert(sizeof(HrCamera::m_fTeppeiModeViewAngleDeg) == 4, "expected HrCamera::m_fTeppeiModeViewAngleDeg to be size 4");
static_assert(sizeof(HrCamera::m_bSetUpVec) == 1, "expected HrCamera::m_bSetUpVec to be size 1");
static_assert(sizeof(HrCamera::m_inMotion) == 68, "expected HrCamera::m_inMotion to be size 68");
static_assert(sizeof(HrCamera::m_ModeChangeDisEnable) == 1, "expected HrCamera::m_ModeChangeDisEnable to be size 1");
static_assert(sizeof(HrCamera::m_bVisible) == 1, "expected HrCamera::m_bVisible to be size 1");
static_assert(sizeof(HrCamera::m) == 208, "expected HrCamera::m to be size 208");
static_assert(sizeof(HrCamera::mpRailData) == 4, "expected HrCamera::mpRailData to be size 4");
static_assert(sizeof(HrCamera::mRailOldPos) == 12, "expected HrCamera::mRailOldPos to be size 12");
static_assert(sizeof(HrCamera::mTargetOriginal) == 12, "expected HrCamera::mTargetOriginal to be size 12");
static_assert(sizeof(HrCamera::mRailTarget) == 12, "expected HrCamera::mRailTarget to be size 12");
static_assert(sizeof(HrCamera::mRailTargetPos) == 12, "expected HrCamera::mRailTargetPos to be size 12");
static_assert(sizeof(HrCamera::mActivePathIdx) == 4, "expected HrCamera::mActivePathIdx to be size 4");
static_assert(sizeof(HrCamera::mActivePosIdx) == 4, "expected HrCamera::mActivePosIdx to be size 4");
static_assert(sizeof(HrCamera::mActiveLinkIdx) == 4, "expected HrCamera::mActiveLinkIdx to be size 4");
static_assert(sizeof(HrCamera::mBefPosIdx) == 4, "expected HrCamera::mBefPosIdx to be size 4");
static_assert(sizeof(HrCamera::mBefPathIdx) == 4, "expected HrCamera::mBefPathIdx to be size 4");
static_assert(sizeof(HrCamera::mbLineChange) == 1, "expected HrCamera::mbLineChange to be size 1");
static_assert(sizeof(HrCamera::mLineChangeRate) == 4, "expected HrCamera::mLineChangeRate to be size 4");
static_assert(sizeof(HrCamera::mLineChangeSpeed) == 4, "expected HrCamera::mLineChangeSpeed to be size 4");
static_assert(sizeof(HrCamera::mBefChangePos) == 12, "expected HrCamera::mBefChangePos to be size 12");
static_assert(sizeof(HrCamera::mBefLineVec) == 12, "expected HrCamera::mBefLineVec to be size 12");
static_assert(sizeof(HrCamera::mOldLineVec) == 12, "expected HrCamera::mOldLineVec to be size 12");
static_assert(sizeof(HrCamera::mSearchDist) == 4, "expected HrCamera::mSearchDist to be size 4");
static_assert(sizeof(HrCamera::mTargetAdjust) == 4, "expected HrCamera::mTargetAdjust to be size 4");
static_assert(sizeof(HrCamera::mOldTargetAdjust) == 4, "expected HrCamera::mOldTargetAdjust to be size 4");
static_assert(sizeof(HrCamera::mPosAdjust) == 4, "expected HrCamera::mPosAdjust to be size 4");
static_assert(sizeof(HrCamera::mBefPosAdust) == 4, "expected HrCamera::mBefPosAdust to be size 4");
static_assert(sizeof(HrCamera::mOldPosAdust) == 4, "expected HrCamera::mOldPosAdust to be size 4");
static_assert(sizeof(HrCamera::mPosAdustBase) == 4, "expected HrCamera::mPosAdustBase to be size 4");
static_assert(sizeof(HrCamera::mRailTargetInterval) == 4, "expected HrCamera::mRailTargetInterval to be size 4");
static_assert(sizeof(HrCamera::mRailPosInterval) == 4, "expected HrCamera::mRailPosInterval to be size 4");
static_assert(sizeof(HrCamera::mbSetRailTargetInit) == 1, "expected HrCamera::mbSetRailTargetInit to be size 1");
static_assert(sizeof(HrCamera::mbSetRailPosInit) == 1, "expected HrCamera::mbSetRailPosInit to be size 1");
static_assert(sizeof(HrCamera::mbChangeInterpolate) == 1, "expected HrCamera::mbChangeInterpolate to be size 1");
static_assert(sizeof(HrCamera::mTrackTarget) == 4, "expected HrCamera::mTrackTarget to be size 4");
static_assert(sizeof(HrCamera::mTrackLength) == 4, "expected HrCamera::mTrackLength to be size 4");
static_assert(sizeof(HrCamera::mBefTrackLength) == 4, "expected HrCamera::mBefTrackLength to be size 4");
static_assert(sizeof(HrCamera::mNPCAdjustDist) == 4, "expected HrCamera::mNPCAdjustDist to be size 4");
static_assert(sizeof(HrCamera::mNPCAdjustValue) == 4, "expected HrCamera::mNPCAdjustValue to be size 4");
static_assert(sizeof(HrCamera::mNPCAdjustSpeed) == 4, "expected HrCamera::mNPCAdjustSpeed to be size 4");
static_assert(sizeof(HrCamera::mNPCAdustVec) == 12, "expected HrCamera::mNPCAdustVec to be size 12");
static_assert(sizeof(HrCamera::mNPCAjustDist) == 4, "expected HrCamera::mNPCAjustDist to be size 4");
static_assert(sizeof(HrCamera::mNoTeppeiMode) == 1, "expected HrCamera::mNoTeppeiMode to be size 1");
static_assert(sizeof(HrCamera::mAspectChangeDisEnable) == 1, "expected HrCamera::mAspectChangeDisEnable to be size 1");
static_assert(sizeof(HrCamera) == 0x21c, "expected HrCamera to be size 0x21c");

// [Structure] class ghmSphere
class ghmSphere
{
public:
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <float mRadius, offset 0xc>
	float mRadius = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmSphere [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmSphere& InObject)
	{
		mCenter = InObject.mCenter;
		mRadius = InObject.mRadius;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmSphere>("ghmSphere")
			.addFunction("__tostring", &ghmSphere::ToString)
			.addFunction("GetPtrAddr", &ghmSphere::GetPtrAddr)
			.addProperty("mCenter", &ghmSphere::mCenter)
			.addProperty("mRadius", &ghmSphere::mRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmSphere::mCenter) == 12, "expected ghmSphere::mCenter to be size 12");
static_assert(sizeof(ghmSphere::mRadius) == 4, "expected ghmSphere::mRadius to be size 4");
static_assert(sizeof(ghmSphere) == 0x10, "expected ghmSphere to be size 0x10");

// [Structure] class ghmGcCollObjSphere
class ghmGcCollObjSphere : public ghmGcCollObj
{
public:
	/// Struct member variables

	// <class ghmGcCollObj field_0, offset 0x0>
	// class ghmGcCollObj Super;

	// <class ghmSphere mShape, offset 0x40>
	class ghmSphere mShape;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcCollObjSphere [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcCollObjSphere& InObject)
	{
		mShape = InObject.mShape;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmGcCollObjSphere, ghmGcCollObj>("ghmGcCollObjSphere")
			.addFunction("__tostring", &ghmGcCollObjSphere::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObjSphere::GetPtrAddr)
			.addProperty("mShape", &ghmGcCollObjSphere::mShape)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjSphere::mShape) == 16, "expected ghmGcCollObjSphere::mShape to be size 16");
static_assert(sizeof(ghmGcCollObjSphere) == 0x50, "expected ghmGcCollObjSphere to be size 0x50");

// [Structure] struct RailCameraHead
struct RailCameraHead
{
public:
	/// Struct member variables

	// <uint32_t ID, offset 0x0>
	uint32_t ID = 0;

	// <uint32_t Version, offset 0x4>
	uint32_t Version = 0;

	// <uint32_t PathNum, offset 0x8>
	uint32_t PathNum = 0;

	// <uint32_t LinkNum, offset 0xc>
	uint32_t LinkNum = 0;

	// <struct RailPath* pPathAry, offset 0x10>
	struct RailPath* pPathAry = nullptr;

	// <struct RailLink* pLinkAry, offset 0x14>
	struct RailLink* pLinkAry = nullptr;

	// <uint32_t BitFlag, offset 0x18>
	uint32_t BitFlag = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct RailCameraHead [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(RailCameraHead& InObject)
	{
		ID = InObject.ID;
		Version = InObject.Version;
		PathNum = InObject.PathNum;
		LinkNum = InObject.LinkNum;
		pPathAry = InObject.pPathAry;
		pLinkAry = InObject.pLinkAry;
		BitFlag = InObject.BitFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<RailCameraHead>("RailCameraHead")
			.addFunction("__tostring", &RailCameraHead::ToString)
			.addFunction("GetPtrAddr", &RailCameraHead::GetPtrAddr)
			.addProperty("ID", &RailCameraHead::ID)
			.addProperty("Version", &RailCameraHead::Version)
			.addProperty("PathNum", &RailCameraHead::PathNum)
			.addProperty("LinkNum", &RailCameraHead::LinkNum)
			.addProperty("pPathAry", &RailCameraHead::pPathAry)
			.addProperty("pLinkAry", &RailCameraHead::pLinkAry)
			.addProperty("BitFlag", &RailCameraHead::BitFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(RailCameraHead::ID) == 4, "expected RailCameraHead::ID to be size 4");
static_assert(sizeof(RailCameraHead::Version) == 4, "expected RailCameraHead::Version to be size 4");
static_assert(sizeof(RailCameraHead::PathNum) == 4, "expected RailCameraHead::PathNum to be size 4");
static_assert(sizeof(RailCameraHead::LinkNum) == 4, "expected RailCameraHead::LinkNum to be size 4");
static_assert(sizeof(RailCameraHead::pPathAry) == 4, "expected RailCameraHead::pPathAry to be size 4");
static_assert(sizeof(RailCameraHead::pLinkAry) == 4, "expected RailCameraHead::pLinkAry to be size 4");
static_assert(sizeof(RailCameraHead::BitFlag) == 4, "expected RailCameraHead::BitFlag to be size 4");
static_assert(sizeof(RailCameraHead) == 0x1c, "expected RailCameraHead to be size 0x1c");

// [Structure] struct RailPath
struct RailPath
{
public:
	/// Struct member variables

	// <char Name[0x8], offset 0x0>
	char Name[8];

	// <uint32_t PosNum, offset 0x8>
	uint32_t PosNum = 0;

	// <struct Vec* pPosAry, offset 0xc>
	struct Vec* pPosAry = nullptr;

	// <float AddTarget, offset 0x10>
	float AddTarget = 0;

	// <float AddPos, offset 0x14>
	float AddPos = 0;

	// <float TrackTargetLength, offset 0x18>
	float TrackTargetLength = 0;

	// <float SearchNPCLength, offset 0x1c>
	float SearchNPCLength = 0;

	// <float NPCAdustDist, offset 0x20>
	float NPCAdustDist = 0;

	// <float TargetFreeInterval, offset 0x24>
	float TargetFreeInterval = 0;

	// <float PosFreeIntreval, offset 0x28>
	float PosFreeIntreval = 0;

	// <float InterpolateSpeed, offset 0x2c>
	float InterpolateSpeed = 0;

	// <float Pad[0x4], offset 0x30>
	float Pad[4];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct RailPath [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(RailPath& InObject)
	{
		PosNum = InObject.PosNum;
		pPosAry = InObject.pPosAry;
		AddTarget = InObject.AddTarget;
		AddPos = InObject.AddPos;
		TrackTargetLength = InObject.TrackTargetLength;
		SearchNPCLength = InObject.SearchNPCLength;
		NPCAdustDist = InObject.NPCAdustDist;
		TargetFreeInterval = InObject.TargetFreeInterval;
		PosFreeIntreval = InObject.PosFreeIntreval;
		InterpolateSpeed = InObject.InterpolateSpeed;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<RailPath>("RailPath")
			.addFunction("__tostring", &RailPath::ToString)
			.addFunction("GetPtrAddr", &RailPath::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("Name", &RailPath::Name)
			.addProperty("PosNum", &RailPath::PosNum)
			.addProperty("pPosAry", &RailPath::pPosAry)
			.addProperty("AddTarget", &RailPath::AddTarget)
			.addProperty("AddPos", &RailPath::AddPos)
			.addProperty("TrackTargetLength", &RailPath::TrackTargetLength)
			.addProperty("SearchNPCLength", &RailPath::SearchNPCLength)
			.addProperty("NPCAdustDist", &RailPath::NPCAdustDist)
			.addProperty("TargetFreeInterval", &RailPath::TargetFreeInterval)
			.addProperty("PosFreeIntreval", &RailPath::PosFreeIntreval)
			.addProperty("InterpolateSpeed", &RailPath::InterpolateSpeed)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("Pad", &RailPath::Pad)
		.endClass();
	}
#endif
};
static_assert(sizeof(RailPath::Name) == 8, "expected RailPath::Name to be size 8");
static_assert(sizeof(RailPath::PosNum) == 4, "expected RailPath::PosNum to be size 4");
static_assert(sizeof(RailPath::pPosAry) == 4, "expected RailPath::pPosAry to be size 4");
static_assert(sizeof(RailPath::AddTarget) == 4, "expected RailPath::AddTarget to be size 4");
static_assert(sizeof(RailPath::AddPos) == 4, "expected RailPath::AddPos to be size 4");
static_assert(sizeof(RailPath::TrackTargetLength) == 4, "expected RailPath::TrackTargetLength to be size 4");
static_assert(sizeof(RailPath::SearchNPCLength) == 4, "expected RailPath::SearchNPCLength to be size 4");
static_assert(sizeof(RailPath::NPCAdustDist) == 4, "expected RailPath::NPCAdustDist to be size 4");
static_assert(sizeof(RailPath::TargetFreeInterval) == 4, "expected RailPath::TargetFreeInterval to be size 4");
static_assert(sizeof(RailPath::PosFreeIntreval) == 4, "expected RailPath::PosFreeIntreval to be size 4");
static_assert(sizeof(RailPath::InterpolateSpeed) == 4, "expected RailPath::InterpolateSpeed to be size 4");
static_assert(sizeof(RailPath::Pad) == 16, "expected RailPath::Pad to be size 16");
static_assert(sizeof(RailPath) == 0x40, "expected RailPath to be size 0x40");

// [Structure] struct RailLink
struct RailLink
{
public:
	/// Struct member variables

	// <char Name[0x8], offset 0x0>
	char Name[8];

	// <int32_t bInterpolate, offset 0x8>
	int32_t bInterpolate = 0;

	// <uint32_t PathIndexNum, offset 0xc>
	uint32_t PathIndexNum = 0;

	// <uint32_t* pPathIndex, offset 0x10>
	uint32_t* pPathIndex = nullptr;

	// <uint32_t TriangleNum, offset 0x14>
	uint32_t TriangleNum = 0;

	// <struct RailTriangle* pTriangleAry, offset 0x18>
	struct RailTriangle* pTriangleAry = nullptr;

	// <float Pad[0x5], offset 0x1c>
	float Pad[5];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct RailLink [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(RailLink& InObject)
	{
		bInterpolate = InObject.bInterpolate;
		PathIndexNum = InObject.PathIndexNum;
		pPathIndex = InObject.pPathIndex;
		TriangleNum = InObject.TriangleNum;
		pTriangleAry = InObject.pTriangleAry;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<RailLink>("RailLink")
			.addFunction("__tostring", &RailLink::ToString)
			.addFunction("GetPtrAddr", &RailLink::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("Name", &RailLink::Name)
			.addProperty("bInterpolate", &RailLink::bInterpolate)
			.addProperty("PathIndexNum", &RailLink::PathIndexNum)
			// native pointer type (uint32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("pPathIndex", &RailLink::pPathIndex)
			.addProperty("TriangleNum", &RailLink::TriangleNum)
			.addProperty("pTriangleAry", &RailLink::pTriangleAry)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("Pad", &RailLink::Pad)
		.endClass();
	}
#endif
};
static_assert(sizeof(RailLink::Name) == 8, "expected RailLink::Name to be size 8");
static_assert(sizeof(RailLink::bInterpolate) == 4, "expected RailLink::bInterpolate to be size 4");
static_assert(sizeof(RailLink::PathIndexNum) == 4, "expected RailLink::PathIndexNum to be size 4");
static_assert(sizeof(RailLink::pPathIndex) == 4, "expected RailLink::pPathIndex to be size 4");
static_assert(sizeof(RailLink::TriangleNum) == 4, "expected RailLink::TriangleNum to be size 4");
static_assert(sizeof(RailLink::pTriangleAry) == 4, "expected RailLink::pTriangleAry to be size 4");
static_assert(sizeof(RailLink::Pad) == 20, "expected RailLink::Pad to be size 20");
static_assert(sizeof(RailLink) == 0x30, "expected RailLink to be size 0x30");

// [Structure] struct RailTriangle
struct RailTriangle
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[36];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct RailTriangle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(RailTriangle& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<RailTriangle>("RailTriangle")
			.addFunction("__tostring", &RailTriangle::ToString)
			.addFunction("GetPtrAddr", &RailTriangle::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(RailTriangle) == 0x24, "expected RailTriangle to be size 0x24");

// Unsupported operator
//void* __convention("thiscall") mHRBattle::`scalar deleting destructor'(class mHRBattle* const this, uint32_t arg2)
// [Structure] class CustomColliderObj
class CustomColliderObj : public commonObj
{
public:
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class ghmGcCollObjCapsule* capsuleCollider, offset 0x64c>
	class ghmGcCollObjCapsule* capsuleCollider = nullptr;

	/// 3 Functions

	// [Function] uint8_t __convention("thiscall") CustomColliderObj::mSetDamage(class CustomColliderObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11) [?mSetDamage@CustomColliderObj@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	typedef uint8_t(__thiscall* _mSetDamage_CustomColliderObj__UAE_NMHHHMHMMPAVmHRChara__M_Z)(class CustomColliderObj* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)
	{
		_mSetDamage_CustomColliderObj__UAE_NMHHHMHMMPAVmHRChara__M_Z mFunc = (_mSetDamage_CustomColliderObj__UAE_NMHHHMHMMPAVmHRChara__M_Z)(GameModule + 0xa57d0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] uint8_t __convention("thiscall") CustomColliderObj::mSetDamage(class CustomColliderObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@CustomColliderObj@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_CustomColliderObj__UAE_NMHHHMHMMPAVmHRChara___Z_2)(class CustomColliderObj* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage_2(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_CustomColliderObj__UAE_NMHHHMHMMPAVmHRChara___Z_2 mFunc = (_mSetDamage_CustomColliderObj__UAE_NMHHHMHMMPAVmHRChara___Z_2)(GameModule + 0xa57e0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") CustomColliderObj::mHitCheck(class CustomColliderObj* const this, class mHRChara* arg2) [?mHitCheck@CustomColliderObj@@UAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mHitCheck_CustomColliderObj__UAE_NPAVmHRChara___Z)(class CustomColliderObj* const thisPtr, class mHRChara* arg2);
	uint8_t mHitCheck(class mHRChara* arg2)
	{
		_mHitCheck_CustomColliderObj__UAE_NPAVmHRChara___Z mFunc = (_mHitCheck_CustomColliderObj__UAE_NPAVmHRChara___Z)(GameModule + 0x5596a0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CustomColliderObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CustomColliderObj& InObject)
	{
		capsuleCollider = InObject.capsuleCollider;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CustomColliderObj, commonObj>("CustomColliderObj")
			.addFunction("__tostring", &CustomColliderObj::ToString)
			.addFunction("GetPtrAddr", &CustomColliderObj::GetPtrAddr)
			.addProperty("capsuleCollider", &CustomColliderObj::capsuleCollider)
			.addFunction("mSetDamage", &CustomColliderObj::mSetDamage)
			.addFunction("mSetDamage_2", &CustomColliderObj::mSetDamage_2)
			.addFunction("mHitCheck", &CustomColliderObj::mHitCheck)
		.endClass();
	}
#endif
};
static_assert(sizeof(CustomColliderObj::capsuleCollider) == 4, "expected CustomColliderObj::capsuleCollider to be size 4");
static_assert(sizeof(CustomColliderObj) == 0x650, "expected CustomColliderObj to be size 0x650");

// [Structure] struct KPADEXStatus
struct KPADEXStatus
{
public:
	// [Structure] struct KPADEXStatus::<unnamed-type-fs>
	struct unnamed_type_fs
	{
	public:
		/// Struct member variables

		// <struct Vec2 stick, offset 0x0>
		struct Vec2 stick;

		// <struct Vec acc, offset 0x8>
		struct Vec acc;

		// <float acc_value, offset 0x14>
		float acc_value = 0;

		// <float acc_speed, offset 0x18>
		float acc_speed = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct KPADEXStatus::unnamed_type_fs [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(KPADEXStatus::unnamed_type_fs& InObject)
		{
			stick = InObject.stick;
			acc = InObject.acc;
			acc_value = InObject.acc_value;
			acc_speed = InObject.acc_speed;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<unnamed_type_fs>("KPADEXStatus_unnamed_type_fs")
				.addFunction("__tostring", &KPADEXStatus::unnamed_type_fs::ToString)
				.addFunction("GetPtrAddr", &KPADEXStatus::unnamed_type_fs::GetPtrAddr)
				.addProperty("stick", &KPADEXStatus::unnamed_type_fs::stick)
				.addProperty("acc", &KPADEXStatus::unnamed_type_fs::acc)
				.addProperty("acc_value", &KPADEXStatus::unnamed_type_fs::acc_value)
				.addProperty("acc_speed", &KPADEXStatus::unnamed_type_fs::acc_speed)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(KPADEXStatus::unnamed_type_fs::stick) == 8, "expected KPADEXStatus::unnamed_type_fs::stick to be size 8");
	static_assert(sizeof(KPADEXStatus::unnamed_type_fs::acc) == 12, "expected KPADEXStatus::unnamed_type_fs::acc to be size 12");
	static_assert(sizeof(KPADEXStatus::unnamed_type_fs::acc_value) == 4, "expected KPADEXStatus::unnamed_type_fs::acc_value to be size 4");
	static_assert(sizeof(KPADEXStatus::unnamed_type_fs::acc_speed) == 4, "expected KPADEXStatus::unnamed_type_fs::acc_speed to be size 4");
	static_assert(sizeof(KPADEXStatus::unnamed_type_fs) == 0x1c, "expected KPADEXStatus::unnamed_type_fs to be size 0x1c");

	// [Structure] struct KPADEXStatus::<unnamed-type-cl>
	struct unnamed_type_cl
	{
	public:
		/// Struct member variables

		// <uint32_t hold, offset 0x0>
		uint32_t hold = 0;

		// <uint32_t trig, offset 0x4>
		uint32_t trig = 0;

		// <uint32_t release, offset 0x8>
		uint32_t release = 0;

		// <struct Vec2 lstick, offset 0xc>
		struct Vec2 lstick;

		// <struct Vec2 rstick, offset 0x14>
		struct Vec2 rstick;

		// <float ltrigger, offset 0x1c>
		float ltrigger = 0;

		// <float rtrigger, offset 0x20>
		float rtrigger = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct KPADEXStatus::unnamed_type_cl [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(KPADEXStatus::unnamed_type_cl& InObject)
		{
			hold = InObject.hold;
			trig = InObject.trig;
			release = InObject.release;
			lstick = InObject.lstick;
			rstick = InObject.rstick;
			ltrigger = InObject.ltrigger;
			rtrigger = InObject.rtrigger;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<unnamed_type_cl>("KPADEXStatus_unnamed_type_cl")
				.addFunction("__tostring", &KPADEXStatus::unnamed_type_cl::ToString)
				.addFunction("GetPtrAddr", &KPADEXStatus::unnamed_type_cl::GetPtrAddr)
				.addProperty("hold", &KPADEXStatus::unnamed_type_cl::hold)
				.addProperty("trig", &KPADEXStatus::unnamed_type_cl::trig)
				.addProperty("release", &KPADEXStatus::unnamed_type_cl::release)
				.addProperty("lstick", &KPADEXStatus::unnamed_type_cl::lstick)
				.addProperty("rstick", &KPADEXStatus::unnamed_type_cl::rstick)
				.addProperty("ltrigger", &KPADEXStatus::unnamed_type_cl::ltrigger)
				.addProperty("rtrigger", &KPADEXStatus::unnamed_type_cl::rtrigger)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(KPADEXStatus::unnamed_type_cl::hold) == 4, "expected KPADEXStatus::unnamed_type_cl::hold to be size 4");
	static_assert(sizeof(KPADEXStatus::unnamed_type_cl::trig) == 4, "expected KPADEXStatus::unnamed_type_cl::trig to be size 4");
	static_assert(sizeof(KPADEXStatus::unnamed_type_cl::release) == 4, "expected KPADEXStatus::unnamed_type_cl::release to be size 4");
	static_assert(sizeof(KPADEXStatus::unnamed_type_cl::lstick) == 8, "expected KPADEXStatus::unnamed_type_cl::lstick to be size 8");
	static_assert(sizeof(KPADEXStatus::unnamed_type_cl::rstick) == 8, "expected KPADEXStatus::unnamed_type_cl::rstick to be size 8");
	static_assert(sizeof(KPADEXStatus::unnamed_type_cl::ltrigger) == 4, "expected KPADEXStatus::unnamed_type_cl::ltrigger to be size 4");
	static_assert(sizeof(KPADEXStatus::unnamed_type_cl::rtrigger) == 4, "expected KPADEXStatus::unnamed_type_cl::rtrigger to be size 4");
	static_assert(sizeof(KPADEXStatus::unnamed_type_cl) == 0x24, "expected KPADEXStatus::unnamed_type_cl to be size 0x24");

	/// Struct member variables

	// <struct KPADEXStatus::<unnamed-type-fs> fs, offset 0x0>
	struct KPADEXStatus::unnamed_type_fs fs;

	// <struct KPADEXStatus::<unnamed-type-cl> cl, offset 0x1c>
	struct KPADEXStatus::unnamed_type_cl cl;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct KPADEXStatus [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(KPADEXStatus& InObject)
	{
		fs = InObject.fs;
		cl = InObject.cl;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<KPADEXStatus>("KPADEXStatus")
			.addFunction("__tostring", &KPADEXStatus::ToString)
			.addFunction("GetPtrAddr", &KPADEXStatus::GetPtrAddr)
			.addProperty("fs", &KPADEXStatus::fs)
			.addProperty("cl", &KPADEXStatus::cl)
		.endClass();
	}
#endif
};
static_assert(sizeof(KPADEXStatus::fs) == 28, "expected KPADEXStatus::fs to be size 28");
static_assert(sizeof(KPADEXStatus::cl) == 36, "expected KPADEXStatus::cl to be size 36");
static_assert(sizeof(KPADEXStatus) == 0x40, "expected KPADEXStatus to be size 0x40");

// [Structure] struct KPADStatus
struct KPADStatus
{
public:
	/// Struct member variables

	// <uint32_t hold, offset 0x0>
	uint32_t hold = 0;

	// <uint32_t trig, offset 0x4>
	uint32_t trig = 0;

	// <uint32_t release, offset 0x8>
	uint32_t release = 0;

	// <struct Vec acc, offset 0xc>
	struct Vec acc;

	// <float acc_value, offset 0x18>
	float acc_value = 0;

	// <float acc_speed, offset 0x1c>
	float acc_speed = 0;

	// <uint8_t dev_type, offset 0x20>
	uint8_t dev_type = 0;

	// <char wpad_err, offset 0x21>
	char wpad_err;

	// <char dpd_valid_fg, offset 0x22>
	char dpd_valid_fg;

	// <uint8_t data_format, offset 0x23>
	uint8_t data_format = 0;

	// <struct KPADEXStatus ex_status, offset 0x24>
	struct KPADEXStatus ex_status;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct KPADStatus [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(KPADStatus& InObject)
	{
		hold = InObject.hold;
		trig = InObject.trig;
		release = InObject.release;
		acc = InObject.acc;
		acc_value = InObject.acc_value;
		acc_speed = InObject.acc_speed;
		dev_type = InObject.dev_type;
		wpad_err = InObject.wpad_err;
		dpd_valid_fg = InObject.dpd_valid_fg;
		data_format = InObject.data_format;
		ex_status = InObject.ex_status;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<KPADStatus>("KPADStatus")
			.addFunction("__tostring", &KPADStatus::ToString)
			.addFunction("GetPtrAddr", &KPADStatus::GetPtrAddr)
			.addProperty("hold", &KPADStatus::hold)
			.addProperty("trig", &KPADStatus::trig)
			.addProperty("release", &KPADStatus::release)
			.addProperty("acc", &KPADStatus::acc)
			.addProperty("acc_value", &KPADStatus::acc_value)
			.addProperty("acc_speed", &KPADStatus::acc_speed)
			.addProperty("dev_type", &KPADStatus::dev_type)
			.addProperty("wpad_err", &KPADStatus::wpad_err)
			.addProperty("dpd_valid_fg", &KPADStatus::dpd_valid_fg)
			.addProperty("data_format", &KPADStatus::data_format)
			.addProperty("ex_status", &KPADStatus::ex_status)
		.endClass();
	}
#endif
};
static_assert(sizeof(KPADStatus::hold) == 4, "expected KPADStatus::hold to be size 4");
static_assert(sizeof(KPADStatus::trig) == 4, "expected KPADStatus::trig to be size 4");
static_assert(sizeof(KPADStatus::release) == 4, "expected KPADStatus::release to be size 4");
static_assert(sizeof(KPADStatus::acc) == 12, "expected KPADStatus::acc to be size 12");
static_assert(sizeof(KPADStatus::acc_value) == 4, "expected KPADStatus::acc_value to be size 4");
static_assert(sizeof(KPADStatus::acc_speed) == 4, "expected KPADStatus::acc_speed to be size 4");
static_assert(sizeof(KPADStatus::dev_type) == 1, "expected KPADStatus::dev_type to be size 1");
static_assert(sizeof(KPADStatus::wpad_err) == 1, "expected KPADStatus::wpad_err to be size 1");
static_assert(sizeof(KPADStatus::dpd_valid_fg) == 1, "expected KPADStatus::dpd_valid_fg to be size 1");
static_assert(sizeof(KPADStatus::data_format) == 1, "expected KPADStatus::data_format to be size 1");
static_assert(sizeof(KPADStatus::ex_status) == 64, "expected KPADStatus::ex_status to be size 64");
static_assert(sizeof(KPADStatus) == 0x64, "expected KPADStatus to be size 0x64");

// enum enAccDir
enum enAccDir : uint32_t
{
	// <eAccDirUp = 0x0>
	eAccDirUp = 0,

	// <eAccDirDown = 0x1>
	eAccDirDown = 1,

	// <eAccDirLeft = 0x2>
	eAccDirLeft = 2,

	// <eAccDirRight = 0x3>
	eAccDirRight = 3,

	// <eAccDirFront = 0x4>
	eAccDirFront = 4,

	// <eAccDirBack = 0x5>
	eAccDirBack = 5,

	// <eAccDirMax = 0x6>
	eAccDirMax = 6

};

// enum enSlope
enum enSlope : uint32_t
{
	// <eSlopeUp = 0x0>
	eSlopeUp = 0,

	// <eSlopeUDMid = 0x1>
	eSlopeUDMid = 1,

	// <eSlopeDown = 0x2>
	eSlopeDown = 2,

	// <eSlopeLeft = 0x3>
	eSlopeLeft = 3,

	// <eSlopeLRMid = 0x4>
	eSlopeLRMid = 4,

	// <eSlopeRight = 0x5>
	eSlopeRight = 5,

	// <eSlopeMax = 0x6>
	eSlopeMax = 6

};

// enum enControllerKind
enum enControllerKind : uint32_t
{
	// <eControllerNunchack = 0x0>
	eControllerNunchack = 0,

	// <eControllerRemocon = 0x1>
	eControllerRemocon = 1,

	// <eControllerMax = 0x2>
	eControllerMax = 2

};

// [Structure] class mHRPad
/// <summary>
/// Gamepad (controller). Handles inputs, rumble, etc.
/// </summary>
class mHRPad
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[1152];

public:
	/// 34 Functions

	// [Function] enum enShakeDir __convention("thiscall") mHRPad::mGetShakeDirL(class mHRPad* const this) [?mGetShakeDirL@mHRPad@@QAE?AW4enShakeDir@@XZ]
	typedef enum enShakeDir(__thiscall* _mGetShakeDirL_mHRPad__QAEAW4enShakeDir__XZ)(class mHRPad* const thisPtr);
	/* enum enShakeDir */ uint32_t mGetShakeDirL()
	{
		_mGetShakeDirL_mHRPad__QAEAW4enShakeDir__XZ mFunc = (_mGetShakeDirL_mHRPad__QAEAW4enShakeDir__XZ)(GameModule + 0xa8ef0);
		return (uint32_t)mFunc(this);
	}
	// [Function] enum enShakeDir __convention("thiscall") mHRPad::mGetShakeDirR(class mHRPad* const this) [?mGetShakeDirR@mHRPad@@QAE?AW4enShakeDir@@XZ]
	typedef enum enShakeDir(__thiscall* _mGetShakeDirR_mHRPad__QAEAW4enShakeDir__XZ)(class mHRPad* const thisPtr);
	/* enum enShakeDir */ uint32_t mGetShakeDirR()
	{
		_mGetShakeDirR_mHRPad__QAEAW4enShakeDir__XZ mFunc = (_mGetShakeDirR_mHRPad__QAEAW4enShakeDir__XZ)(GameModule + 0xa8f00);
		return (uint32_t)mFunc(this);
	}
	// [Function] enum enShakeDir __convention("thiscall") mHRPad::GetLastShakeDirL(class mHRPad* const this) [?GetLastShakeDirL@mHRPad@@QAE?AW4enShakeDir@@XZ]
	typedef enum enShakeDir(__thiscall* _GetLastShakeDirL_mHRPad__QAEAW4enShakeDir__XZ)(class mHRPad* const thisPtr);
	/* enum enShakeDir */ uint32_t GetLastShakeDirL()
	{
		_GetLastShakeDirL_mHRPad__QAEAW4enShakeDir__XZ mFunc = (_GetLastShakeDirL_mHRPad__QAEAW4enShakeDir__XZ)(GameModule + 0xa9e40);
		return (uint32_t)mFunc(this);
	}
	// [Function] enum enShakeDir __convention("thiscall") mHRPad::GetLastShakeDirR(class mHRPad* const this) [?GetLastShakeDirR@mHRPad@@QAE?AW4enShakeDir@@XZ]
	typedef enum enShakeDir(__thiscall* _GetLastShakeDirR_mHRPad__QAEAW4enShakeDir__XZ)(class mHRPad* const thisPtr);
	/* enum enShakeDir */ uint32_t GetLastShakeDirR()
	{
		_GetLastShakeDirR_mHRPad__QAEAW4enShakeDir__XZ mFunc = (_GetLastShakeDirR_mHRPad__QAEAW4enShakeDir__XZ)(GameModule + 0xa9e50);
		return (uint32_t)mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPad::mClearShortPushTick(class mHRPad* const this, int32_t arg2) [?mClearShortPushTick@mHRPad@@QAEXH@Z]
	typedef void(__thiscall* _mClearShortPushTick_mHRPad__QAEXH_Z)(class mHRPad* const thisPtr, int32_t arg2);
	void mClearShortPushTick(int32_t arg2)
	{
		_mClearShortPushTick_mHRPad__QAEXH_Z mFunc = (_mClearShortPushTick_mHRPad__QAEXH_Z)(GameModule + 0xa9e60);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPad::mGetPushTick(class mHRPad* const this, int32_t arg2) [?mGetPushTick@mHRPad@@QAEHH@Z]
	typedef int32_t(__thiscall* _mGetPushTick_mHRPad__QAEHH_Z)(class mHRPad* const thisPtr, int32_t arg2);
	int32_t mGetPushTick(int32_t arg2)
	{
		_mGetPushTick_mHRPad__QAEHH_Z mFunc = (_mGetPushTick_mHRPad__QAEHH_Z)(GameModule + 0xa9e80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPad::mClearPushTick(class mHRPad* const this, int32_t arg2) [?mClearPushTick@mHRPad@@QAEXH@Z]
	typedef void(__thiscall* _mClearPushTick_mHRPad__QAEXH_Z)(class mHRPad* const thisPtr, int32_t arg2);
	void mClearPushTick(int32_t arg2)
	{
		_mClearPushTick_mHRPad__QAEXH_Z mFunc = (_mClearPushTick_mHRPad__QAEXH_Z)(GameModule + 0xa9ea0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPad::mGetHalfStick(class mHRPad* const this) [?mGetHalfStick@mHRPad@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetHalfStick_mHRPad__QAE_NXZ)(class mHRPad* const thisPtr);
	uint8_t mGetHalfStick()
	{
		_mGetHalfStick_mHRPad__QAE_NXZ mFunc = (_mGetHalfStick_mHRPad__QAE_NXZ)(GameModule + 0xa9ec0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPad::mGetFullfStick(class mHRPad* const this) [?mGetFullfStick@mHRPad@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetFullfStick_mHRPad__QAE_NXZ)(class mHRPad* const thisPtr);
	uint8_t mGetFullfStick()
	{
		_mGetFullfStick_mHRPad__QAE_NXZ mFunc = (_mGetFullfStick_mHRPad__QAE_NXZ)(GameModule + 0xa9ed0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPad::mResetGachaNum(class mHRPad* const this, int32_t arg2) [?mResetGachaNum@mHRPad@@QAEXH@Z]
	typedef void(__thiscall* _mResetGachaNum_mHRPad__QAEXH_Z)(class mHRPad* const thisPtr, int32_t arg2);
	void mResetGachaNum(int32_t arg2)
	{
		_mResetGachaNum_mHRPad__QAEXH_Z mFunc = (_mResetGachaNum_mHRPad__QAEXH_Z)(GameModule + 0xc02a0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPad::mGetGahaNum(class mHRPad* const this) [?mGetGahaNum@mHRPad@@QAEHXZ]
	typedef int32_t(__thiscall* _mGetGahaNum_mHRPad__QAEHXZ)(class mHRPad* const thisPtr);
	int32_t mGetGahaNum()
	{
		_mGetGahaNum_mHRPad__QAEHXZ mFunc = (_mGetGahaNum_mHRPad__QAEHXZ)(GameModule + 0xc02d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPad::mGetShortPush(class mHRPad* const this, int32_t arg2) [?mGetShortPush@mHRPad@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _mGetShortPush_mHRPad__QAE_NH_Z)(class mHRPad* const thisPtr, int32_t arg2);
	uint8_t mGetShortPush(int32_t arg2)
	{
		_mGetShortPush_mHRPad__QAE_NH_Z mFunc = (_mGetShortPush_mHRPad__QAE_NH_Z)(GameModule + 0xcdb40);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPad::mGetShortPushTick(class mHRPad* const this, int32_t arg2) [?mGetShortPushTick@mHRPad@@QAEHH@Z]
	typedef int32_t(__thiscall* _mGetShortPushTick_mHRPad__QAEHH_Z)(class mHRPad* const thisPtr, int32_t arg2);
	int32_t mGetShortPushTick(int32_t arg2)
	{
		_mGetShortPushTick_mHRPad__QAEHH_Z mFunc = (_mGetShortPushTick_mHRPad__QAEHH_Z)(GameModule + 0xcdb60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPad::mCallRambleWSmall(class mHRPad* const this) [?mCallRambleWSmall@mHRPad@@QAEXXZ]
	typedef void(__thiscall* _mCallRambleWSmall_mHRPad__QAEXXZ)(class mHRPad* const thisPtr);
	void mCallRambleWSmall()
	{
		_mCallRambleWSmall_mHRPad__QAEXXZ mFunc = (_mCallRambleWSmall_mHRPad__QAEXXZ)(GameModule + 0x4f5980);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPad::mInitRotRimo(class mHRPad* const this, uint8_t arg2) [?mInitRotRimo@mHRPad@@AAEX_N@Z]
	typedef void(__thiscall* _mInitRotRimo_mHRPad__AAEX_N_Z)(class mHRPad* const thisPtr, uint8_t arg2);
	void mInitRotRimo(uint8_t arg2)
	{
		_mInitRotRimo_mHRPad__AAEX_N_Z mFunc = (_mInitRotRimo_mHRPad__AAEX_N_Z)(GameModule + 0x4f59c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPad::mPadRotCoProc(class mHRPad* const this, struct stRotDat* arg2, uint8_t arg3) [?mPadRotCoProc@mHRPad@@AAE_NPAUstRotDat@@_N@Z]
	typedef uint8_t(__thiscall* _mPadRotCoProc_mHRPad__AAE_NPAUstRotDat___N_Z)(class mHRPad* const thisPtr, struct stRotDat* arg2, uint8_t arg3);
	uint8_t mPadRotCoProc(struct stRotDat* arg2, uint8_t arg3)
	{
		_mPadRotCoProc_mHRPad__AAE_NPAUstRotDat___N_Z mFunc = (_mPadRotCoProc_mHRPad__AAE_NPAUstRotDat___N_Z)(GameModule + 0x4f5a20);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPad::mPadRotProc(class mHRPad* const this, struct stRotDat* arg2, uint8_t arg3) [?mPadRotProc@mHRPad@@AAEXPAUstRotDat@@_N@Z]
	typedef void(__thiscall* _mPadRotProc_mHRPad__AAEXPAUstRotDat___N_Z)(class mHRPad* const thisPtr, struct stRotDat* arg2, uint8_t arg3);
	void mPadRotProc(struct stRotDat* arg2, uint8_t arg3)
	{
		_mPadRotProc_mHRPad__AAEXPAUstRotDat___N_Z mFunc = (_mPadRotProc_mHRPad__AAEXPAUstRotDat___N_Z)(GameModule + 0x4f5bc0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPad::mGetInputLeftStick(class mHRPad* const this) [?mGetInputLeftStick@mHRPad@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetInputLeftStick_mHRPad__QAE_NXZ)(class mHRPad* const thisPtr);
	uint8_t mGetInputLeftStick()
	{
		_mGetInputLeftStick_mHRPad__QAE_NXZ mFunc = (_mGetInputLeftStick_mHRPad__QAE_NXZ)(GameModule + 0x4f5f30);
		return mFunc(this);
	}
	// [Function] enum enShakeDir __convention("thiscall") mHRPad::mCheckShake(class mHRPad* const this, enum enControllerKind arg2) [?mCheckShake@mHRPad@@AAE?AW4enShakeDir@@W4enControllerKind@@@Z]
	typedef enum enShakeDir(__thiscall* _mCheckShake_mHRPad__AAEAW4enShakeDir__W4enControllerKind___Z)(class mHRPad* const thisPtr, enum enControllerKind arg2);
	/* enum enShakeDir */ uint32_t mCheckShake(/* enum enControllerKind */ uint32_t arg2)
	{
		_mCheckShake_mHRPad__AAEAW4enShakeDir__W4enControllerKind___Z mFunc = (_mCheckShake_mHRPad__AAEAW4enShakeDir__W4enControllerKind___Z)(GameModule + 0x4f5f90);
		return (uint32_t)mFunc(this, (enum enControllerKind)arg2);
	}
	// [Function] enum enSlope __convention("thiscall") mHRPad::mGetRemoConSlope(class mHRPad* const this) [?mGetRemoConSlope@mHRPad@@QAE?AW4enSlope@@XZ]
	typedef enum enSlope(__thiscall* _mGetRemoConSlope_mHRPad__QAEAW4enSlope__XZ)(class mHRPad* const thisPtr);
	/* enum enSlope */ uint32_t mGetRemoConSlope()
	{
		_mGetRemoConSlope_mHRPad__QAEAW4enSlope__XZ mFunc = (_mGetRemoConSlope_mHRPad__QAEAW4enSlope__XZ)(GameModule + 0x4f6380);
		return (uint32_t)mFunc(this);
	}
	// [Function] enum enAccDir __convention("thiscall") mHRPad::mGetHighestAcc(class mHRPad* const this) [?mGetHighestAcc@mHRPad@@QAE?AW4enAccDir@@XZ]
	typedef enum enAccDir(__thiscall* _mGetHighestAcc_mHRPad__QAEAW4enAccDir__XZ)(class mHRPad* const thisPtr);
	/* enum enAccDir */ uint32_t mGetHighestAcc()
	{
		_mGetHighestAcc_mHRPad__QAEAW4enAccDir__XZ mFunc = (_mGetHighestAcc_mHRPad__QAEAW4enAccDir__XZ)(GameModule + 0x4f63c0);
		return (uint32_t)mFunc(this);
	}
	// [Function] struct Vec2* __convention("thiscall") mHRPad::mGetPadPointPosPtr(class mHRPad* const this) [?mGetPadPointPosPtr@mHRPad@@QAEPAUVec2@@XZ]
	typedef struct Vec2*(__thiscall* _mGetPadPointPosPtr_mHRPad__QAEPAUVec2__XZ)(class mHRPad* const thisPtr);
	struct Vec2* mGetPadPointPosPtr()
	{
		_mGetPadPointPosPtr_mHRPad__QAEPAUVec2__XZ mFunc = (_mGetPadPointPosPtr_mHRPad__QAEPAUVec2__XZ)(GameModule + 0x4f6440);
		return mFunc(this);
	}
	// [Function] struct KPADStatus* __convention("thiscall") mHRPad::mGetPadStatusPtr(class mHRPad* const this, uint32_t arg2) [?mGetPadStatusPtr@mHRPad@@QAEPAUKPADStatus@@I@Z]
	typedef struct KPADStatus*(__thiscall* _mGetPadStatusPtr_mHRPad__QAEPAUKPADStatus__I_Z)(class mHRPad* const thisPtr, uint32_t arg2);
	struct KPADStatus* mGetPadStatusPtr(uint32_t arg2)
	{
		_mGetPadStatusPtr_mHRPad__QAEPAUKPADStatus__I_Z mFunc = (_mGetPadStatusPtr_mHRPad__QAEPAUKPADStatus__I_Z)(GameModule + 0x4f6450);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPad::mCallRambleBig(class mHRPad* const this) [?mCallRambleBig@mHRPad@@QAEXXZ]
	typedef void(__thiscall* _mCallRambleBig_mHRPad__QAEXXZ)(class mHRPad* const thisPtr);
	void mCallRambleBig()
	{
		_mCallRambleBig_mHRPad__QAEXXZ mFunc = (_mCallRambleBig_mHRPad__QAEXXZ)(GameModule + 0x4f6460);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPad::mCallRambleLittle(class mHRPad* const this) [?mCallRambleLittle@mHRPad@@QAEXXZ]
	typedef void(__thiscall* _mCallRambleLittle_mHRPad__QAEXXZ)(class mHRPad* const thisPtr);
	void mCallRambleLittle()
	{
		_mCallRambleLittle_mHRPad__QAEXXZ mFunc = (_mCallRambleLittle_mHRPad__QAEXXZ)(GameModule + 0x4f64c0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPad::mGetTotalAccZ(class mHRPad* const this, enum enControllerKind arg2) [?mGetTotalAccZ@mHRPad@@QAEMW4enControllerKind@@@Z]
	typedef float(__thiscall* _mGetTotalAccZ_mHRPad__QAEMW4enControllerKind___Z)(class mHRPad* const thisPtr, enum enControllerKind arg2);
	float mGetTotalAccZ(/* enum enControllerKind */ uint32_t arg2)
	{
		_mGetTotalAccZ_mHRPad__QAEMW4enControllerKind___Z mFunc = (_mGetTotalAccZ_mHRPad__QAEMW4enControllerKind___Z)(GameModule + 0x4f6500);
		return mFunc(this, (enum enControllerKind)arg2);
	}
	// [Function] void __convention("thiscall") mHRPad::mCallRambleSmall(class mHRPad* const this) [?mCallRambleSmall@mHRPad@@QAEXXZ]
	typedef void(__thiscall* _mCallRambleSmall_mHRPad__QAEXXZ)(class mHRPad* const thisPtr);
	void mCallRambleSmall()
	{
		_mCallRambleSmall_mHRPad__QAEXXZ mFunc = (_mCallRambleSmall_mHRPad__QAEXXZ)(GameModule + 0x4f6520);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPad::mClearShakeHis(class mHRPad* const this) [?mClearShakeHis@mHRPad@@QAEXXZ]
	typedef void(__thiscall* _mClearShakeHis_mHRPad__QAEXXZ)(class mHRPad* const thisPtr);
	void mClearShakeHis()
	{
		_mClearShakeHis_mHRPad__QAEXXZ mFunc = (_mClearShakeHis_mHRPad__QAEXXZ)(GameModule + 0x4f6580);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPad::mGetShakeDir(class mHRPad* const this, enum enShakeDir arg2, enum enControllerKind arg3, uint8_t arg4, float arg5, uint8_t arg6) [?mGetShakeDir@mHRPad@@QAE_NW4enShakeDir@@W4enControllerKind@@_NM2@Z]
	typedef uint8_t(__thiscall* _mGetShakeDir_mHRPad__QAE_NW4enShakeDir__W4enControllerKind___NM2_Z)(class mHRPad* const thisPtr, enum enShakeDir arg2, enum enControllerKind arg3, uint8_t arg4, float arg5, uint8_t arg6);
	uint8_t mGetShakeDir(/* enum enShakeDir */ uint32_t arg2, /* enum enControllerKind */ uint32_t arg3, uint8_t arg4, float arg5, uint8_t arg6)
	{
		_mGetShakeDir_mHRPad__QAE_NW4enShakeDir__W4enControllerKind___NM2_Z mFunc = (_mGetShakeDir_mHRPad__QAE_NW4enShakeDir__W4enControllerKind___NM2_Z)(GameModule + 0x4f65f0);
		return mFunc(this, (enum enShakeDir)arg2, (enum enControllerKind)arg3, arg4, arg5, arg6);
	}
	// [Function] char __convention("thiscall") mHRPad::mGetNunRotCnt(class mHRPad* const this, uint8_t arg2) [?mGetNunRotCnt@mHRPad@@QAEC_N@Z]
	typedef char(__thiscall* _mGetNunRotCnt_mHRPad__QAEC_N_Z)(class mHRPad* const thisPtr, uint8_t arg2);
	char mGetNunRotCnt(uint8_t arg2)
	{
		_mGetNunRotCnt_mHRPad__QAEC_N_Z mFunc = (_mGetNunRotCnt_mHRPad__QAEC_N_Z)(GameModule + 0x4f67b0);
		return mFunc(this, arg2);
	}
	// [Function] char __convention("thiscall") mHRPad::mGetRemRotCnt(class mHRPad* const this, uint8_t arg2) [?mGetRemRotCnt@mHRPad@@QAEC_N@Z]
	typedef char(__thiscall* _mGetRemRotCnt_mHRPad__QAEC_N_Z)(class mHRPad* const thisPtr, uint8_t arg2);
	char mGetRemRotCnt(uint8_t arg2)
	{
		_mGetRemRotCnt_mHRPad__QAEC_N_Z mFunc = (_mGetRemRotCnt_mHRPad__QAEC_N_Z)(GameModule + 0x4f67d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPad::mInit(class mHRPad* const this) [?mInit@mHRPad@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mInit_mHRPad__QAE_NXZ)(class mHRPad* const thisPtr);
	uint8_t mInit()
	{
		_mInit_mHRPad__QAE_NXZ mFunc = (_mInit_mHRPad__QAE_NXZ)(GameModule + 0x4f6840);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPad::mTerm(class mHRPad* const this) [?mTerm@mHRPad@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mTerm_mHRPad__QAE_NXZ)(class mHRPad* const thisPtr);
	uint8_t mTerm()
	{
		_mTerm_mHRPad__QAE_NXZ mFunc = (_mTerm_mHRPad__QAE_NXZ)(GameModule + 0x4f6990);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPad::mFrameProc(class mHRPad* const this) [?mFrameProc@mHRPad@@QAEXXZ]
	typedef void(__thiscall* _mFrameProc_mHRPad__QAEXXZ)(class mHRPad* const thisPtr);
	void mFrameProc()
	{
		_mFrameProc_mHRPad__QAEXXZ mFunc = (_mFrameProc_mHRPad__QAEXXZ)(GameModule + 0x4f69e0);
		return mFunc(this);
	}
	/// Meta

	Vec2 GetLStick() { return mGetPadStatusPtr(0)->ex_status.cl.lstick; }
	Vec2 GetRStick() { return mGetPadStatusPtr(0)->ex_status.cl.rstick; }
	bool IsPressingButton(uint32_t InButton) { return (mGetPadStatusPtr(0)->hold & InButton) != 0; }
	bool IsPressingX() { return IsPressingButton(1 << 9); }
	bool IsPressingRB() { return IsPressingButton(1 << 14); }
	std::string ToString() const { std::stringstream stream; stream << "class mHRPad [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(mHRPad& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRPad>("mHRPad")
			.addFunction("__tostring", &mHRPad::ToString)
			.addFunction("GetPtrAddr", &mHRPad::GetPtrAddr)
			.addFunction("mGetShakeDirL", &mHRPad::mGetShakeDirL)
			.addFunction("mGetShakeDirR", &mHRPad::mGetShakeDirR)
			.addFunction("GetLastShakeDirL", &mHRPad::GetLastShakeDirL)
			.addFunction("GetLastShakeDirR", &mHRPad::GetLastShakeDirR)
			.addFunction("mClearShortPushTick", &mHRPad::mClearShortPushTick)
			.addFunction("mGetPushTick", &mHRPad::mGetPushTick)
			.addFunction("mClearPushTick", &mHRPad::mClearPushTick)
			.addFunction("mGetHalfStick", &mHRPad::mGetHalfStick)
			.addFunction("mGetFullfStick", &mHRPad::mGetFullfStick)
			.addFunction("mResetGachaNum", &mHRPad::mResetGachaNum)
			.addFunction("mGetGahaNum", &mHRPad::mGetGahaNum)
			.addFunction("mGetShortPush", &mHRPad::mGetShortPush)
			.addFunction("mGetShortPushTick", &mHRPad::mGetShortPushTick)
			.addFunction("mCallRambleWSmall", &mHRPad::mCallRambleWSmall)
			.addFunction("mInitRotRimo", &mHRPad::mInitRotRimo)
			.addFunction("mPadRotCoProc", &mHRPad::mPadRotCoProc)
			.addFunction("mPadRotProc", &mHRPad::mPadRotProc)
			.addFunction("mGetInputLeftStick", &mHRPad::mGetInputLeftStick)
			.addFunction("mCheckShake", &mHRPad::mCheckShake)
			.addFunction("mGetRemoConSlope", &mHRPad::mGetRemoConSlope)
			.addFunction("mGetHighestAcc", &mHRPad::mGetHighestAcc)
			.addFunction("mGetPadPointPosPtr", &mHRPad::mGetPadPointPosPtr)
			.addFunction("mGetPadStatusPtr", &mHRPad::mGetPadStatusPtr)
			.addFunction("mCallRambleBig", &mHRPad::mCallRambleBig)
			.addFunction("mCallRambleLittle", &mHRPad::mCallRambleLittle)
			.addFunction("mGetTotalAccZ", &mHRPad::mGetTotalAccZ)
			.addFunction("mCallRambleSmall", &mHRPad::mCallRambleSmall)
			.addFunction("mClearShakeHis", &mHRPad::mClearShakeHis)
			.addFunction("mGetShakeDir", &mHRPad::mGetShakeDir)
			.addFunction("mGetNunRotCnt", &mHRPad::mGetNunRotCnt)
			.addFunction("mGetRemRotCnt", &mHRPad::mGetRemRotCnt)
			.addFunction("mInit", &mHRPad::mInit)
			.addFunction("mTerm", &mHRPad::mTerm)
			.addFunction("mFrameProc", &mHRPad::mFrameProc)
			.addFunction("GetLStick", &mHRPad::GetLStick)
			.addFunction("GetRStick", &mHRPad::GetRStick)
			.addFunction("IsPressingButton", &mHRPad::IsPressingButton)
			.addFunction("IsPressingX", &mHRPad::IsPressingX)
			.addFunction("IsPressingRB", &mHRPad::IsPressingRB)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRPad) == 0x480, "expected mHRPad to be size 0x480");

// Unsupported operator
//void* __convention("thiscall") mHRPad::`scalar deleting destructor'(class mHRPad* const this, uint32_t arg2)
// Unsupported operator
//void __convention("thiscall") <lambda_13f4bc9bb35e6841b02e837fc4e2d08e>::operator()(class mHRBattle::mReleaseAllNpc::__l12::<lambda_13f4bc9bb35e6841b02e837fc4e2d08e>* const this, void* arg2)
// Unsupported operator
//void (*)(void*) __convention("thiscall") <lambda_13f4bc9bb35e6841b02e837fc4e2d08e>::operator void (__cdecl*)(void *)(class mHRBattle::mReleaseAllNpc::__l12::<lambda_13f4bc9bb35e6841b02e837fc4e2d08e>* const this)
// [Structure] class CSpringInterpolate3D
class CSpringInterpolate3D
{
public:
	/// Struct member variables

	// <float m_fSpringCoe, offset 0x0>
	float m_fSpringCoe = 0;

	// <float m_fMaxVel, offset 0x4>
	float m_fMaxVel = 0;

	// <float m_fMinVel, offset 0x8>
	float m_fMinVel = 0;

	// <uint8_t m_bIsRadiInterp, offset 0xc>
	uint8_t m_bIsRadiInterp = 0;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData_13[3];

public:
	// <float m_fEpsilon, offset 0x10>
	float m_fEpsilon = 0;

	// <float m_fW, offset 0x14>
	float m_fW = 0;

	// <Unidentified data segment, offset 0x18>
private:
	char _UnidentifiedData_24[8];

public:
	// <class tiVector m_inValue, offset 0x20>
	class tiVector m_inValue;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CSpringInterpolate3D [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CSpringInterpolate3D& InObject)
	{
		m_fSpringCoe = InObject.m_fSpringCoe;
		m_fMaxVel = InObject.m_fMaxVel;
		m_fMinVel = InObject.m_fMinVel;
		m_bIsRadiInterp = InObject.m_bIsRadiInterp;
		m_fEpsilon = InObject.m_fEpsilon;
		m_fW = InObject.m_fW;
		m_inValue = InObject.m_inValue;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CSpringInterpolate3D>("CSpringInterpolate3D")
			.addFunction("__tostring", &CSpringInterpolate3D::ToString)
			.addFunction("GetPtrAddr", &CSpringInterpolate3D::GetPtrAddr)
			.addProperty("m_fSpringCoe", &CSpringInterpolate3D::m_fSpringCoe)
			.addProperty("m_fMaxVel", &CSpringInterpolate3D::m_fMaxVel)
			.addProperty("m_fMinVel", &CSpringInterpolate3D::m_fMinVel)
			.addProperty("m_bIsRadiInterp", &CSpringInterpolate3D::m_bIsRadiInterp)
			.addProperty("m_fEpsilon", &CSpringInterpolate3D::m_fEpsilon)
			.addProperty("m_fW", &CSpringInterpolate3D::m_fW)
			.addProperty("m_inValue", &CSpringInterpolate3D::m_inValue)
		.endClass();
	}
#endif
};
static_assert(sizeof(CSpringInterpolate3D::m_fSpringCoe) == 4, "expected CSpringInterpolate3D::m_fSpringCoe to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fMaxVel) == 4, "expected CSpringInterpolate3D::m_fMaxVel to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fMinVel) == 4, "expected CSpringInterpolate3D::m_fMinVel to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_bIsRadiInterp) == 1, "expected CSpringInterpolate3D::m_bIsRadiInterp to be size 1");
static_assert(sizeof(CSpringInterpolate3D::m_fEpsilon) == 4, "expected CSpringInterpolate3D::m_fEpsilon to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fW) == 4, "expected CSpringInterpolate3D::m_fW to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_inValue) == 16, "expected CSpringInterpolate3D::m_inValue to be size 16");
static_assert(sizeof(CSpringInterpolate3D) == 0x30, "expected CSpringInterpolate3D to be size 0x30");

// [Structure] class CDoubleSpringInterpolate3D
class CDoubleSpringInterpolate3D
{
public:
	/// Struct member variables

	// <class CSpringInterpolate3D m_inHopeInterp, offset 0x0>
	class CSpringInterpolate3D m_inHopeInterp;

	// <class CSpringInterpolate3D m_inCurInterp, offset 0x30>
	class CSpringInterpolate3D m_inCurInterp;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CDoubleSpringInterpolate3D [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CDoubleSpringInterpolate3D& InObject)
	{
		m_inHopeInterp = InObject.m_inHopeInterp;
		m_inCurInterp = InObject.m_inCurInterp;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CDoubleSpringInterpolate3D>("CDoubleSpringInterpolate3D")
			.addFunction("__tostring", &CDoubleSpringInterpolate3D::ToString)
			.addFunction("GetPtrAddr", &CDoubleSpringInterpolate3D::GetPtrAddr)
			.addProperty("m_inHopeInterp", &CDoubleSpringInterpolate3D::m_inHopeInterp)
			.addProperty("m_inCurInterp", &CDoubleSpringInterpolate3D::m_inCurInterp)
		.endClass();
	}
#endif
};
static_assert(sizeof(CDoubleSpringInterpolate3D::m_inHopeInterp) == 48, "expected CDoubleSpringInterpolate3D::m_inHopeInterp to be size 48");
static_assert(sizeof(CDoubleSpringInterpolate3D::m_inCurInterp) == 48, "expected CDoubleSpringInterpolate3D::m_inCurInterp to be size 48");
static_assert(sizeof(CDoubleSpringInterpolate3D) == 0x60, "expected CDoubleSpringInterpolate3D to be size 0x60");

// [Structure] class CGameDataLink
class CGameDataLink
{
public:
	/// Struct member variables

	// <class CGameData* m_pData, offset 0x0>
	class CGameData* m_pData = nullptr;

	// <int32_t m_nDataIndex, offset 0x4>
	int32_t m_nDataIndex = 0;

	// <class CGameDataManager* m_pDataManager, offset 0x8>
	class CGameDataManager* m_pDataManager = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CGameDataLink [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CGameDataLink& InObject)
	{
		m_pData = InObject.m_pData;
		m_nDataIndex = InObject.m_nDataIndex;
		m_pDataManager = InObject.m_pDataManager;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameDataLink>("CGameDataLink")
			.addFunction("__tostring", &CGameDataLink::ToString)
			.addFunction("GetPtrAddr", &CGameDataLink::GetPtrAddr)
			.addProperty("m_pData", &CGameDataLink::m_pData)
			.addProperty("m_nDataIndex", &CGameDataLink::m_nDataIndex)
			.addProperty("m_pDataManager", &CGameDataLink::m_pDataManager)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameDataLink::m_pData) == 4, "expected CGameDataLink::m_pData to be size 4");
static_assert(sizeof(CGameDataLink::m_nDataIndex) == 4, "expected CGameDataLink::m_nDataIndex to be size 4");
static_assert(sizeof(CGameDataLink::m_pDataManager) == 4, "expected CGameDataLink::m_pDataManager to be size 4");
static_assert(sizeof(CGameDataLink) == 0xc, "expected CGameDataLink to be size 0xc");

// [Structure] class mot::CBoneEffectManager
namespace mot
{
	class CBoneEffectManager
	{
	public:
		/// Struct member variables

		// <class CGameDataLink m_inDataLink, offset 0x0>
		class CGameDataLink m_inDataLink;

		// <class CStlVector<mot::IBoneEffect *> m_apBoneEffect, offset 0xc>
		class std::vector<IBoneEffect *> m_apBoneEffect;

		// <class mot::CIKManager* m_pIK, offset 0x18>
		class CIKManager* m_pIK = nullptr;

		// <class mot::CYuremonoManager* m_pYuremono, offset 0x1c>
		class CYuremonoManager* m_pYuremono = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::CBoneEffectManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::CBoneEffectManager& InObject)
		{
			m_inDataLink = InObject.m_inDataLink;
			m_apBoneEffect = InObject.m_apBoneEffect;
			m_pIK = InObject.m_pIK;
			m_pYuremono = InObject.m_pYuremono;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CBoneEffectManager>("mot_CBoneEffectManager")
				.addFunction("__tostring", &mot::CBoneEffectManager::ToString)
				.addFunction("GetPtrAddr", &mot::CBoneEffectManager::GetPtrAddr)
				.addProperty("m_inDataLink", &mot::CBoneEffectManager::m_inDataLink)
				.addProperty("m_apBoneEffect", &mot::CBoneEffectManager::m_apBoneEffect)
				.addProperty("m_pIK", &mot::CBoneEffectManager::m_pIK)
				.addProperty("m_pYuremono", &mot::CBoneEffectManager::m_pYuremono)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CBoneEffectManager::m_inDataLink) == 12, "expected mot::CBoneEffectManager::m_inDataLink to be size 12");
static_assert(sizeof(mot::CBoneEffectManager::m_apBoneEffect) == 12, "expected mot::CBoneEffectManager::m_apBoneEffect to be size 12");
static_assert(sizeof(mot::CBoneEffectManager::m_pIK) == 4, "expected mot::CBoneEffectManager::m_pIK to be size 4");
static_assert(sizeof(mot::CBoneEffectManager::m_pYuremono) == 4, "expected mot::CBoneEffectManager::m_pYuremono to be size 4");
static_assert(sizeof(mot::CBoneEffectManager) == 0x20, "expected mot::CBoneEffectManager to be size 0x20");

// [Structure] class mot::CBoneEffectPJ
namespace mot
{
	class CBoneEffectPJ : public mot::IBoneEffectPJ
	{
	public:
		/// Struct member variables

		// <class mot::IBoneEffectPJ field_0, offset 0x0>
		// class IBoneEffectPJ Super;

		// <class mot::CBoneEffectManager m_inManager, offset 0x4>
		class CBoneEffectManager m_inManager;

		// <uint8_t m_bIsYuremonoExist, offset 0x24>
		uint8_t m_bIsYuremonoExist = 0;

		// <uint8_t m_bActedWarp, offset 0x25>
		uint8_t m_bActedWarp = 0;

		// <Unidentified data segment, offset 0x26>
	private:
		char _UnidentifiedData_38[10];

	public:
		// <class tiMatrix m_inPreWorldMat, offset 0x30>
		class tiMatrix m_inPreWorldMat;

		// <class mot::CBoneEffectDamageData m_inDamageData, offset 0x70>
		class CBoneEffectDamageData m_inDamageData;

		// <class mot::CBoneEffectDamageData m_inPreDamageData, offset 0x80>
		class CBoneEffectDamageData m_inPreDamageData;

		// <uint8_t m_bIsAttackSideLeft, offset 0x90>
		uint8_t m_bIsAttackSideLeft = 0;

		// <uint8_t m_bIsAttackDirSide, offset 0x91>
		uint8_t m_bIsAttackDirSide = 0;

		// <uint8_t m_bIsNeedMoveInterp, offset 0x92>
		uint8_t m_bIsNeedMoveInterp = 0;

		// <Unidentified data segment, offset 0x93>
	private:
		char _UnidentifiedData_147[13];

	public:
		// <class CDoubleSpringInterpolate3D m_inInterpMove, offset 0xa0>
		class CDoubleSpringInterpolate3D m_inInterpMove;

		/// 1 Functions

		// [Function] enum mot::CBoneEffectDamageData::EAttackType __convention("thiscall") mot::CBoneEffectPJ::getAttackType(class mot::CBoneEffectPJ* const this, class mHRChara* arg2) [?getAttackType@CBoneEffectPJ@mot@@QAE?AW4EAttackType@CBoneEffectDamageData@2@PBVmHRChara@@@Z]
		typedef enum mot::CBoneEffectDamageData::EAttackType(__thiscall* _getAttackType_CBoneEffectPJ_mot__QAEAW4EAttackType_CBoneEffectDamageData_2_PBVmHRChara___Z)(class mot::CBoneEffectPJ* const thisPtr, class mHRChara* arg2);
		/* enum mot::CBoneEffectDamageData::EAttackType */ uint32_t getAttackType(class mHRChara* arg2)
		{
			_getAttackType_CBoneEffectPJ_mot__QAEAW4EAttackType_CBoneEffectDamageData_2_PBVmHRChara___Z mFunc = (_getAttackType_CBoneEffectPJ_mot__QAEAW4EAttackType_CBoneEffectDamageData_2_PBVmHRChara___Z)(GameModule + 0xa77c0);
			return (uint32_t)mFunc(this, arg2);
		}
		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::CBoneEffectPJ [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::CBoneEffectPJ& InObject)
		{
			m_inManager = InObject.m_inManager;
			m_bIsYuremonoExist = InObject.m_bIsYuremonoExist;
			m_bActedWarp = InObject.m_bActedWarp;
			m_inPreWorldMat = InObject.m_inPreWorldMat;
			m_inDamageData = InObject.m_inDamageData;
			m_inPreDamageData = InObject.m_inPreDamageData;
			m_bIsAttackSideLeft = InObject.m_bIsAttackSideLeft;
			m_bIsAttackDirSide = InObject.m_bIsAttackDirSide;
			m_bIsNeedMoveInterp = InObject.m_bIsNeedMoveInterp;
			m_inInterpMove = InObject.m_inInterpMove;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.deriveClass<CBoneEffectPJ, mot::IBoneEffectPJ>("mot_CBoneEffectPJ")
				.addFunction("__tostring", &mot::CBoneEffectPJ::ToString)
				.addFunction("GetPtrAddr", &mot::CBoneEffectPJ::GetPtrAddr)
				.addProperty("m_inManager", &mot::CBoneEffectPJ::m_inManager)
				.addProperty("m_bIsYuremonoExist", &mot::CBoneEffectPJ::m_bIsYuremonoExist)
				.addProperty("m_bActedWarp", &mot::CBoneEffectPJ::m_bActedWarp)
				.addProperty("m_inPreWorldMat", &mot::CBoneEffectPJ::m_inPreWorldMat)
				.addProperty("m_inDamageData", &mot::CBoneEffectPJ::m_inDamageData)
				.addProperty("m_inPreDamageData", &mot::CBoneEffectPJ::m_inPreDamageData)
				.addProperty("m_bIsAttackSideLeft", &mot::CBoneEffectPJ::m_bIsAttackSideLeft)
				.addProperty("m_bIsAttackDirSide", &mot::CBoneEffectPJ::m_bIsAttackDirSide)
				.addProperty("m_bIsNeedMoveInterp", &mot::CBoneEffectPJ::m_bIsNeedMoveInterp)
				.addProperty("m_inInterpMove", &mot::CBoneEffectPJ::m_inInterpMove)
				.addFunction("getAttackType", &mot::CBoneEffectPJ::getAttackType)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CBoneEffectPJ::m_inManager) == 32, "expected mot::CBoneEffectPJ::m_inManager to be size 32");
static_assert(sizeof(mot::CBoneEffectPJ::m_bIsYuremonoExist) == 1, "expected mot::CBoneEffectPJ::m_bIsYuremonoExist to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_bActedWarp) == 1, "expected mot::CBoneEffectPJ::m_bActedWarp to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_inPreWorldMat) == 64, "expected mot::CBoneEffectPJ::m_inPreWorldMat to be size 64");
static_assert(sizeof(mot::CBoneEffectPJ::m_inDamageData) == 16, "expected mot::CBoneEffectPJ::m_inDamageData to be size 16");
static_assert(sizeof(mot::CBoneEffectPJ::m_inPreDamageData) == 16, "expected mot::CBoneEffectPJ::m_inPreDamageData to be size 16");
static_assert(sizeof(mot::CBoneEffectPJ::m_bIsAttackSideLeft) == 1, "expected mot::CBoneEffectPJ::m_bIsAttackSideLeft to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_bIsAttackDirSide) == 1, "expected mot::CBoneEffectPJ::m_bIsAttackDirSide to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_bIsNeedMoveInterp) == 1, "expected mot::CBoneEffectPJ::m_bIsNeedMoveInterp to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_inInterpMove) == 96, "expected mot::CBoneEffectPJ::m_inInterpMove to be size 96");
static_assert(sizeof(mot::CBoneEffectPJ) == 0x100, "expected mot::CBoneEffectPJ to be size 0x100");

// [Structure] class CGameData
class CGameData
{
public:
	/// Struct member variables

	// <int32_t m_nID, offset 0x0>
	int32_t m_nID = 0;

	// <int32_t m_nRefCounter, offset 0x4>
	int32_t m_nRefCounter = 0;

	// <class CPackFileDataElement* m_pData, offset 0x8>
	class CPackFileDataElement* m_pData = nullptr;

	// <int32_t m_nDataClassSize, offset 0xc>
	int32_t m_nDataClassSize = 0;

	// <int32_t m_nTotalDataClass, offset 0x10>
	int32_t m_nTotalDataClass = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CGameData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CGameData& InObject)
	{
		m_nID = InObject.m_nID;
		m_nRefCounter = InObject.m_nRefCounter;
		m_pData = InObject.m_pData;
		m_nDataClassSize = InObject.m_nDataClassSize;
		m_nTotalDataClass = InObject.m_nTotalDataClass;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameData>("CGameData")
			.addFunction("__tostring", &CGameData::ToString)
			.addFunction("GetPtrAddr", &CGameData::GetPtrAddr)
			.addProperty("m_nID", &CGameData::m_nID)
			.addProperty("m_nRefCounter", &CGameData::m_nRefCounter)
			.addProperty("m_pData", &CGameData::m_pData)
			.addProperty("m_nDataClassSize", &CGameData::m_nDataClassSize)
			.addProperty("m_nTotalDataClass", &CGameData::m_nTotalDataClass)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameData::m_nID) == 4, "expected CGameData::m_nID to be size 4");
static_assert(sizeof(CGameData::m_nRefCounter) == 4, "expected CGameData::m_nRefCounter to be size 4");
static_assert(sizeof(CGameData::m_pData) == 4, "expected CGameData::m_pData to be size 4");
static_assert(sizeof(CGameData::m_nDataClassSize) == 4, "expected CGameData::m_nDataClassSize to be size 4");
static_assert(sizeof(CGameData::m_nTotalDataClass) == 4, "expected CGameData::m_nTotalDataClass to be size 4");
static_assert(sizeof(CGameData) == 0x14, "expected CGameData to be size 0x14");

// [Structure] class CPackFileDataElement
class CPackFileDataElement
{
public:
	/// Struct member variables

	// <char const* m_sName, offset 0x0>
	char const* m_sName = nullptr;

	// <uint32_t m_nSize, offset 0x4>
	uint32_t m_nSize = 0;

	// <void const* m_pContent, offset 0x8>
	void const* m_pContent = nullptr;

	// <uint8_t m_endianSwapped, offset 0xc>
	uint8_t m_endianSwapped = 0;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData_13[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CPackFileDataElement [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CPackFileDataElement& InObject)
	{
		m_sName = InObject.m_sName;
		m_nSize = InObject.m_nSize;
		m_pContent = InObject.m_pContent;
		m_endianSwapped = InObject.m_endianSwapped;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CPackFileDataElement>("CPackFileDataElement")
			.addFunction("__tostring", &CPackFileDataElement::ToString)
			.addFunction("GetPtrAddr", &CPackFileDataElement::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sName", &CPackFileDataElement::m_sName)
			.addProperty("m_nSize", &CPackFileDataElement::m_nSize)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_pContent", &CPackFileDataElement::m_pContent)
			.addProperty("m_endianSwapped", &CPackFileDataElement::m_endianSwapped)
		.endClass();
	}
#endif
};
static_assert(sizeof(CPackFileDataElement::m_sName) == 4, "expected CPackFileDataElement::m_sName to be size 4");
static_assert(sizeof(CPackFileDataElement::m_nSize) == 4, "expected CPackFileDataElement::m_nSize to be size 4");
static_assert(sizeof(CPackFileDataElement::m_pContent) == 4, "expected CPackFileDataElement::m_pContent to be size 4");
static_assert(sizeof(CPackFileDataElement::m_endianSwapped) == 1, "expected CPackFileDataElement::m_endianSwapped to be size 1");
static_assert(sizeof(CPackFileDataElement) == 0x10, "expected CPackFileDataElement to be size 0x10");

// [Structure] class CFileData
class CFileData
{
public:
	/// Struct member variables

	// <int32_t m_nSize, offset 0x0>
	int32_t m_nSize = 0;

	// <void* m_pData, offset 0x4>
	void* m_pData = nullptr;

	// <class CStlVector<unsigned char> m_abyData, offset 0x8>
	class std::vector<unsigned char> m_abyData;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CFileData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CFileData& InObject)
	{
		m_nSize = InObject.m_nSize;
		m_pData = InObject.m_pData;
		m_abyData = InObject.m_abyData;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CFileData>("CFileData")
			.addFunction("__tostring", &CFileData::ToString)
			.addFunction("GetPtrAddr", &CFileData::GetPtrAddr)
			.addProperty("m_nSize", &CFileData::m_nSize)
			// void type not supported in LuaBridge
			//.addProperty("m_pData", &CFileData::m_pData)
			.addProperty("m_abyData", &CFileData::m_abyData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CFileData::m_nSize) == 4, "expected CFileData::m_nSize to be size 4");
static_assert(sizeof(CFileData::m_pData) == 4, "expected CFileData::m_pData to be size 4");
static_assert(sizeof(CFileData::m_abyData) == 12, "expected CFileData::m_abyData to be size 12");
static_assert(sizeof(CFileData) == 0x14, "expected CFileData to be size 0x14");

// [Structure] class CPackFileData
class CPackFileData
{
public:
	/// Struct member variables

	// <class CFileData m_inPackData, offset 0x0>
	class CFileData m_inPackData;

	// <class CStlVector<CPackFileDataElement> m_ainElement, offset 0x14>
	class std::vector<CPackFileDataElement> m_ainElement;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CPackFileData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CPackFileData& InObject)
	{
		m_inPackData = InObject.m_inPackData;
		m_ainElement = InObject.m_ainElement;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CPackFileData>("CPackFileData")
			.addFunction("__tostring", &CPackFileData::ToString)
			.addFunction("GetPtrAddr", &CPackFileData::GetPtrAddr)
			.addProperty("m_inPackData", &CPackFileData::m_inPackData)
			.addProperty("m_ainElement", &CPackFileData::m_ainElement)
		.endClass();
	}
#endif
};
static_assert(sizeof(CPackFileData::m_inPackData) == 20, "expected CPackFileData::m_inPackData to be size 20");
static_assert(sizeof(CPackFileData::m_ainElement) == 12, "expected CPackFileData::m_ainElement to be size 12");
static_assert(sizeof(CPackFileData) == 0x20, "expected CPackFileData to be size 0x20");

// [Structure] class CGameDataManager
class CGameDataManager
{
public:
	/// Struct member variables

	// <class CPackFileData m_inGDPackData, offset 0x0>
	class CPackFileData m_inGDPackData;

	// <class CStlVector<CGameData> m_ainData, offset 0x20>
	class std::vector<CGameData> m_ainData;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CGameDataManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CGameDataManager& InObject)
	{
		m_inGDPackData = InObject.m_inGDPackData;
		m_ainData = InObject.m_ainData;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameDataManager>("CGameDataManager")
			.addFunction("__tostring", &CGameDataManager::ToString)
			.addFunction("GetPtrAddr", &CGameDataManager::GetPtrAddr)
			.addProperty("m_inGDPackData", &CGameDataManager::m_inGDPackData)
			.addProperty("m_ainData", &CGameDataManager::m_ainData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameDataManager::m_inGDPackData) == 32, "expected CGameDataManager::m_inGDPackData to be size 32");
static_assert(sizeof(CGameDataManager::m_ainData) == 12, "expected CGameDataManager::m_ainData to be size 12");
static_assert(sizeof(CGameDataManager) == 0x2c, "expected CGameDataManager to be size 0x2c");

// [Structure] class mot::IBoneEffect
namespace mot
{
	class IBoneEffect
	{
	public:
		/// Struct member variables

		// <void* (* field_0)[0xa], offset 0x0>
		void* (* field_0)[0xa];

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::IBoneEffect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::IBoneEffect& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<IBoneEffect>("mot_IBoneEffect")
				.addFunction("__tostring", &mot::IBoneEffect::ToString)
				.addFunction("GetPtrAddr", &mot::IBoneEffect::GetPtrAddr)
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &mot::IBoneEffect::field_0)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffect::field_0) == 4, "expected mot::IBoneEffect::field_0 to be size 4");
static_assert(sizeof(mot::IBoneEffect) == 0x4, "expected mot::IBoneEffect to be size 0x4");

// [Structure] class mot::CIKManager
namespace mot
{
	class CIKManager
	{
	public:
		/// Struct member variables

		// <class mot::CBoneEffectManager* m_pBoneEffectManager, offset 0x0>
		class CBoneEffectManager* m_pBoneEffectManager = nullptr;

		// <class CGameDataLink m_inDamagePartDataLink, offset 0x4>
		class CGameDataLink m_inDamagePartDataLink;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::CIKManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::CIKManager& InObject)
		{
			m_pBoneEffectManager = InObject.m_pBoneEffectManager;
			m_inDamagePartDataLink = InObject.m_inDamagePartDataLink;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CIKManager>("mot_CIKManager")
				.addFunction("__tostring", &mot::CIKManager::ToString)
				.addFunction("GetPtrAddr", &mot::CIKManager::GetPtrAddr)
				.addProperty("m_pBoneEffectManager", &mot::CIKManager::m_pBoneEffectManager)
				.addProperty("m_inDamagePartDataLink", &mot::CIKManager::m_inDamagePartDataLink)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CIKManager::m_pBoneEffectManager) == 4, "expected mot::CIKManager::m_pBoneEffectManager to be size 4");
static_assert(sizeof(mot::CIKManager::m_inDamagePartDataLink) == 12, "expected mot::CIKManager::m_inDamagePartDataLink to be size 12");
static_assert(sizeof(mot::CIKManager) == 0x10, "expected mot::CIKManager to be size 0x10");

// [Structure] class mot::CYuremonoManager
namespace mot
{
	class CYuremonoManager
	{
	public:
		/// Struct member variables

		// <class mot::CBoneEffectManager* m_pBoneEffectManager, offset 0x0>
		class CBoneEffectManager* m_pBoneEffectManager = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class mot::CYuremonoManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(mot::CYuremonoManager& InObject)
		{
			m_pBoneEffectManager = InObject.m_pBoneEffectManager;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CYuremonoManager>("mot_CYuremonoManager")
				.addFunction("__tostring", &mot::CYuremonoManager::ToString)
				.addFunction("GetPtrAddr", &mot::CYuremonoManager::GetPtrAddr)
				.addProperty("m_pBoneEffectManager", &mot::CYuremonoManager::m_pBoneEffectManager)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CYuremonoManager::m_pBoneEffectManager) == 4, "expected mot::CYuremonoManager::m_pBoneEffectManager to be size 4");
static_assert(sizeof(mot::CYuremonoManager) == 0x4, "expected mot::CYuremonoManager to be size 0x4");

// [Structure] class CLensFlare
class CLensFlare
{
public:
	// [Structure] class CLensFlare::CFlare
	class CFlare
	{
	public:
		/// Struct member variables

		// <struct tagGHMR_TEX m_inTexture, offset 0x0>
		struct tagGHMR_TEX m_inTexture;

		// <float m_fSize, offset 0x28>
		float m_fSize = 0;

		// <float m_fPosiRatio, offset 0x2c>
		float m_fPosiRatio = 0;

		// <uint8_t m_byRed, offset 0x30>
		uint8_t m_byRed = 0;

		// <uint8_t m_byGreen, offset 0x31>
		uint8_t m_byGreen = 0;

		// <uint8_t m_byBlue, offset 0x32>
		uint8_t m_byBlue = 0;

		// <Unidentified data segment, offset 0x33>
	private:
		char _UnidentifiedData_51[1];

	public:
		/// 1 Functions

		// [Function] void __convention("thiscall") CLensFlare::CFlare::createTexture(class CLensFlare::CFlare* const this, char const* arg2, class ghmResGroup* arg3) [?createTexture@CFlare@CLensFlare@@QAEXPBDPAVghmResGroup@@@Z]
		typedef void(__thiscall* _createTexture_CFlare_CLensFlare__QAEXPBDPAVghmResGroup___Z)(class CLensFlare::CFlare* const thisPtr, char const* arg2, class ghmResGroup* arg3);
		void createTexture(std::string arg2, class ghmResGroup* arg3)
		{
			char const* arg2_c_str = arg2.c_str();
			_createTexture_CFlare_CLensFlare__QAEXPBDPAVghmResGroup___Z mFunc = (_createTexture_CFlare_CLensFlare__QAEXPBDPAVghmResGroup___Z)(GameModule + 0xaea00);
			return mFunc(this, arg2_c_str, arg3);
		}
		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class CLensFlare::CFlare [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(CLensFlare::CFlare& InObject)
		{
			m_inTexture = InObject.m_inTexture;
			m_fSize = InObject.m_fSize;
			m_fPosiRatio = InObject.m_fPosiRatio;
			m_byRed = InObject.m_byRed;
			m_byGreen = InObject.m_byGreen;
			m_byBlue = InObject.m_byBlue;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CFlare>("CLensFlare_CFlare")
				.addFunction("__tostring", &CLensFlare::CFlare::ToString)
				.addFunction("GetPtrAddr", &CLensFlare::CFlare::GetPtrAddr)
				.addProperty("m_inTexture", &CLensFlare::CFlare::m_inTexture)
				.addProperty("m_fSize", &CLensFlare::CFlare::m_fSize)
				.addProperty("m_fPosiRatio", &CLensFlare::CFlare::m_fPosiRatio)
				.addProperty("m_byRed", &CLensFlare::CFlare::m_byRed)
				.addProperty("m_byGreen", &CLensFlare::CFlare::m_byGreen)
				.addProperty("m_byBlue", &CLensFlare::CFlare::m_byBlue)
				.addFunction("createTexture", &CLensFlare::CFlare::createTexture)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(CLensFlare::CFlare::m_inTexture) == 40, "expected CLensFlare::CFlare::m_inTexture to be size 40");
	static_assert(sizeof(CLensFlare::CFlare::m_fSize) == 4, "expected CLensFlare::CFlare::m_fSize to be size 4");
	static_assert(sizeof(CLensFlare::CFlare::m_fPosiRatio) == 4, "expected CLensFlare::CFlare::m_fPosiRatio to be size 4");
	static_assert(sizeof(CLensFlare::CFlare::m_byRed) == 1, "expected CLensFlare::CFlare::m_byRed to be size 1");
	static_assert(sizeof(CLensFlare::CFlare::m_byGreen) == 1, "expected CLensFlare::CFlare::m_byGreen to be size 1");
	static_assert(sizeof(CLensFlare::CFlare::m_byBlue) == 1, "expected CLensFlare::CFlare::m_byBlue to be size 1");
	static_assert(sizeof(CLensFlare::CFlare) == 0x34, "expected CLensFlare::CFlare to be size 0x34");

	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[156];

public:
	/// 1 Functions

	// [Function] void __convention("thiscall") CLensFlare::init(class CLensFlare* const this, int32_t const arg2, class ghmResGroup* arg3) [?init@CLensFlare@@QAEXHPAVghmResGroup@@@Z]
	typedef void(__thiscall* _init_CLensFlare__QAEXHPAVghmResGroup___Z)(class CLensFlare* const thisPtr, int32_t const arg2, class ghmResGroup* arg3);
	void init(int32_t const arg2, class ghmResGroup* arg3)
	{
		_init_CLensFlare__QAEXHPAVghmResGroup___Z mFunc = (_init_CLensFlare__QAEXHPAVghmResGroup___Z)(GameModule + 0x465650);
		return mFunc(this, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CLensFlare [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CLensFlare& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CLensFlare>("CLensFlare")
			.addFunction("__tostring", &CLensFlare::ToString)
			.addFunction("GetPtrAddr", &CLensFlare::GetPtrAddr)
			.addFunction("init", &CLensFlare::init)
		.endClass();
	}
#endif
};
static_assert(sizeof(CLensFlare) == 0x9c, "expected CLensFlare to be size 0x9c");

// [Structure] class HrKeyEvent
class HrKeyEvent
{
public:
	/// Struct member variables

	// <class ghmListObj* mpTopObj, offset 0x0>
	class ghmListObj* mpTopObj = nullptr;

	// <class TGan* mpDemoMotion, offset 0x4>
	class TGan* mpDemoMotion = nullptr;

	// <struct WGanNodeSpec* mpKeyEventNode, offset 0x8>
	struct WGanNodeSpec* mpKeyEventNode = nullptr;

	// <class TGanPlay* mpGanPlay, offset 0xc>
	class TGanPlay* mpGanPlay = nullptr;

	// <uint8_t mbPause, offset 0x10>
	uint8_t mbPause = 0;

	// <uint8_t mbDemo, offset 0x11>
	uint8_t mbDemo = 0;

	// <uint8_t mbSlashInput, offset 0x12>
	uint8_t mbSlashInput = 0;

	// <uint8_t mbSlashSkip, offset 0x13>
	uint8_t mbSlashSkip = 0;

	// <int32_t mSlashKind, offset 0x14>
	int32_t mSlashKind = 0;

	// <int32_t mSlashLSE, offset 0x18>
	int32_t mSlashLSE = 0;

	// <int32_t mSlashHSE, offset 0x1c>
	int32_t mSlashHSE = 0;

	// <int32_t mSlashTick, offset 0x20>
	int32_t mSlashTick = 0;

	// <uint8_t mbTitleCreate, offset 0x24>
	uint8_t mbTitleCreate = 0;

	// <uint8_t mbDifSelectCreate, offset 0x25>
	uint8_t mbDifSelectCreate = 0;

	// <uint8_t mbEndRollCreate, offset 0x26>
	uint8_t mbEndRollCreate = 0;

	// <Unidentified data segment, offset 0x27>
private:
	char _UnidentifiedData_39[1];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrKeyEvent [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrKeyEvent& InObject)
	{
		mpTopObj = InObject.mpTopObj;
		mpDemoMotion = InObject.mpDemoMotion;
		mpKeyEventNode = InObject.mpKeyEventNode;
		mpGanPlay = InObject.mpGanPlay;
		mbPause = InObject.mbPause;
		mbDemo = InObject.mbDemo;
		mbSlashInput = InObject.mbSlashInput;
		mbSlashSkip = InObject.mbSlashSkip;
		mSlashKind = InObject.mSlashKind;
		mSlashLSE = InObject.mSlashLSE;
		mSlashHSE = InObject.mSlashHSE;
		mSlashTick = InObject.mSlashTick;
		mbTitleCreate = InObject.mbTitleCreate;
		mbDifSelectCreate = InObject.mbDifSelectCreate;
		mbEndRollCreate = InObject.mbEndRollCreate;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrKeyEvent>("HrKeyEvent")
			.addFunction("__tostring", &HrKeyEvent::ToString)
			.addFunction("GetPtrAddr", &HrKeyEvent::GetPtrAddr)
			.addProperty("mpTopObj", &HrKeyEvent::mpTopObj)
			.addProperty("mpDemoMotion", &HrKeyEvent::mpDemoMotion)
			.addProperty("mpKeyEventNode", &HrKeyEvent::mpKeyEventNode)
			.addProperty("mpGanPlay", &HrKeyEvent::mpGanPlay)
			.addProperty("mbPause", &HrKeyEvent::mbPause)
			.addProperty("mbDemo", &HrKeyEvent::mbDemo)
			.addProperty("mbSlashInput", &HrKeyEvent::mbSlashInput)
			.addProperty("mbSlashSkip", &HrKeyEvent::mbSlashSkip)
			.addProperty("mSlashKind", &HrKeyEvent::mSlashKind)
			.addProperty("mSlashLSE", &HrKeyEvent::mSlashLSE)
			.addProperty("mSlashHSE", &HrKeyEvent::mSlashHSE)
			.addProperty("mSlashTick", &HrKeyEvent::mSlashTick)
			.addProperty("mbTitleCreate", &HrKeyEvent::mbTitleCreate)
			.addProperty("mbDifSelectCreate", &HrKeyEvent::mbDifSelectCreate)
			.addProperty("mbEndRollCreate", &HrKeyEvent::mbEndRollCreate)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrKeyEvent::mpTopObj) == 4, "expected HrKeyEvent::mpTopObj to be size 4");
static_assert(sizeof(HrKeyEvent::mpDemoMotion) == 4, "expected HrKeyEvent::mpDemoMotion to be size 4");
static_assert(sizeof(HrKeyEvent::mpKeyEventNode) == 4, "expected HrKeyEvent::mpKeyEventNode to be size 4");
static_assert(sizeof(HrKeyEvent::mpGanPlay) == 4, "expected HrKeyEvent::mpGanPlay to be size 4");
static_assert(sizeof(HrKeyEvent::mbPause) == 1, "expected HrKeyEvent::mbPause to be size 1");
static_assert(sizeof(HrKeyEvent::mbDemo) == 1, "expected HrKeyEvent::mbDemo to be size 1");
static_assert(sizeof(HrKeyEvent::mbSlashInput) == 1, "expected HrKeyEvent::mbSlashInput to be size 1");
static_assert(sizeof(HrKeyEvent::mbSlashSkip) == 1, "expected HrKeyEvent::mbSlashSkip to be size 1");
static_assert(sizeof(HrKeyEvent::mSlashKind) == 4, "expected HrKeyEvent::mSlashKind to be size 4");
static_assert(sizeof(HrKeyEvent::mSlashLSE) == 4, "expected HrKeyEvent::mSlashLSE to be size 4");
static_assert(sizeof(HrKeyEvent::mSlashHSE) == 4, "expected HrKeyEvent::mSlashHSE to be size 4");
static_assert(sizeof(HrKeyEvent::mSlashTick) == 4, "expected HrKeyEvent::mSlashTick to be size 4");
static_assert(sizeof(HrKeyEvent::mbTitleCreate) == 1, "expected HrKeyEvent::mbTitleCreate to be size 1");
static_assert(sizeof(HrKeyEvent::mbDifSelectCreate) == 1, "expected HrKeyEvent::mbDifSelectCreate to be size 1");
static_assert(sizeof(HrKeyEvent::mbEndRollCreate) == 1, "expected HrKeyEvent::mbEndRollCreate to be size 1");
static_assert(sizeof(HrKeyEvent) == 0x28, "expected HrKeyEvent to be size 0x28");

// [Structure] class HrSkip
class HrSkip
{
public:
	/// Struct member variables

	// <int32_t mSkipStep, offset 0x0>
	int32_t mSkipStep = 0;

	// <int32_t mSkipCount, offset 0x4>
	int32_t mSkipCount = 0;

	// <int32_t mDrawStatus, offset 0x8>
	int32_t mDrawStatus = 0;

	// <int32_t mAlpha, offset 0xc>
	int32_t mAlpha = 0;

	// <uint8_t mDisable, offset 0x10>
	uint8_t mDisable = 0;

	// <uint8_t mbActive, offset 0x11>
	uint8_t mbActive = 0;

	// <Unidentified data segment, offset 0x12>
private:
	char _UnidentifiedData_18[2];

public:
	// <struct tagGHMR_TEX mTex, offset 0x14>
	struct tagGHMR_TEX mTex;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrSkip [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrSkip& InObject)
	{
		mSkipStep = InObject.mSkipStep;
		mSkipCount = InObject.mSkipCount;
		mDrawStatus = InObject.mDrawStatus;
		mAlpha = InObject.mAlpha;
		mDisable = InObject.mDisable;
		mbActive = InObject.mbActive;
		mTex = InObject.mTex;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrSkip>("HrSkip")
			.addFunction("__tostring", &HrSkip::ToString)
			.addFunction("GetPtrAddr", &HrSkip::GetPtrAddr)
			.addProperty("mSkipStep", &HrSkip::mSkipStep)
			.addProperty("mSkipCount", &HrSkip::mSkipCount)
			.addProperty("mDrawStatus", &HrSkip::mDrawStatus)
			.addProperty("mAlpha", &HrSkip::mAlpha)
			.addProperty("mDisable", &HrSkip::mDisable)
			.addProperty("mbActive", &HrSkip::mbActive)
			.addProperty("mTex", &HrSkip::mTex)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrSkip::mSkipStep) == 4, "expected HrSkip::mSkipStep to be size 4");
static_assert(sizeof(HrSkip::mSkipCount) == 4, "expected HrSkip::mSkipCount to be size 4");
static_assert(sizeof(HrSkip::mDrawStatus) == 4, "expected HrSkip::mDrawStatus to be size 4");
static_assert(sizeof(HrSkip::mAlpha) == 4, "expected HrSkip::mAlpha to be size 4");
static_assert(sizeof(HrSkip::mDisable) == 1, "expected HrSkip::mDisable to be size 1");
static_assert(sizeof(HrSkip::mbActive) == 1, "expected HrSkip::mbActive to be size 1");
static_assert(sizeof(HrSkip::mTex) == 40, "expected HrSkip::mTex to be size 40");
static_assert(sizeof(HrSkip) == 0x3c, "expected HrSkip to be size 0x3c");

// [Structure] class HrMiniDemo
class HrMiniDemo
{
public:
	// enum HrMiniDemo::HRMINIDEMO_STS
	enum HRMINIDEMO_STS : uint32_t
	{
		// <HRMINIDEMO_INIT = 0x0>
		HRMINIDEMO_INIT = 0,

		// <HRMINIDEMO_SETUP = 0x1>
		HRMINIDEMO_SETUP = 1,

		// <HRMINIDEMO_DOING = 0x2>
		HRMINIDEMO_DOING = 2,

		// <HRMINIDEMO_PAUSE = 0x3>
		HRMINIDEMO_PAUSE = 3,

		// <HRMINIDEMO_ENDPAUSE_FADE = 0x4>
		HRMINIDEMO_ENDPAUSE_FADE = 4,

		// <HRMINIDEMO_ENDPAUSE = 0x5>
		HRMINIDEMO_ENDPAUSE = 5,

		// <HRMINIDEMO_ENDPAUSE_DOING = 0x6>
		HRMINIDEMO_ENDPAUSE_DOING = 6,

		// <HRMINIDEMO_ENDPAUSE_STAGE_CHANGE = 0x7>
		HRMINIDEMO_ENDPAUSE_STAGE_CHANGE = 7,

		// <HRMINIDEMO_IDLE = 0x8>
		HRMINIDEMO_IDLE = 8,

		// <HRMINIDEMO_RELEASE = 0x9>
		HRMINIDEMO_RELEASE = 9,

		// <HRMINIDEMO_FADEOUT = 0xa>
		HRMINIDEMO_FADEOUT = 10,

		// <HRMINIDEMO_MAX = 0xb>
		HRMINIDEMO_MAX = 11

	};

	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <enum HrMiniDemo::HRMINIDEMO_STS mStatus, offset 0x4>
	enum HrMiniDemo::HRMINIDEMO_STS mStatus;

	// <int32_t mDemoNum, offset 0x8>
	int32_t mDemoNum = 0;

	// <int32_t mSndNo, offset 0xc>
	int32_t mSndNo = 0;

	// <uint8_t mAbsolute, offset 0x10>
	uint8_t mAbsolute = 0;

	// <Unidentified data segment, offset 0x11>
private:
	char _UnidentifiedData_17[3];

public:
	// <class ghmGcFile mFileptr, offset 0x14>
	class ghmGcFile mFileptr;

	// <class ghmResGroup* mpRsl, offset 0xd0>
	class ghmResGroup* mpRsl = nullptr;

	// <class TGan* mpGan, offset 0xd4>
	class TGan* mpGan = nullptr;

	// <int32_t mPauseStep, offset 0xd8>
	int32_t mPauseStep = 0;

	// <class HrSkip mSkip, offset 0xdc>
	class HrSkip mSkip;

	// <int32_t mPauseStart, offset 0x118>
	int32_t mPauseStart = 0;

	// <uint8_t mEndPause, offset 0x11c>
	uint8_t mEndPause = 0;

	// <uint8_t mPause, offset 0x11d>
	uint8_t mPause = 0;

	// <uint8_t mEndPauseFade, offset 0x11e>
	uint8_t mEndPauseFade = 0;

	// <uint8_t mOutFadeNoCamReset, offset 0x11f>
	uint8_t mOutFadeNoCamReset = 0;

	// <uint8_t mTrvTarget, offset 0x120>
	uint8_t mTrvTarget = 0;

	// <uint8_t mTrvOperate, offset 0x121>
	uint8_t mTrvOperate = 0;

	// <uint8_t mEndPosition, offset 0x122>
	uint8_t mEndPosition = 0;

	// <uint8_t mEndRotation, offset 0x123>
	uint8_t mEndRotation = 0;

	// <int32_t mExitTrvOperateOff, offset 0x124>
	int32_t mExitTrvOperateOff = 0;

	// <struct Vec mPosTrvTarget, offset 0x128>
	struct Vec mPosTrvTarget;

	// <struct Vec mEndPos, offset 0x134>
	struct Vec mEndPos;

	// <struct Vec mEndRot, offset 0x140>
	struct Vec mEndRot;

	// <int32_t mOutFadeType, offset 0x14c>
	int32_t mOutFadeType = 0;

	// <uint8_t mFade, offset 0x150>
	uint8_t mFade = 0;

	// <char mStageName[0x10], offset 0x151>
	char mStageName[16];

	// <char mDemoName[0x10], offset 0x161>
	char mDemoName[16];

	// <uint8_t mStageChange, offset 0x171>
	uint8_t mStageChange = 0;

	// <uint8_t minBossLoading, offset 0x172>
	uint8_t minBossLoading = 0;

	// <Unidentified data segment, offset 0x173>
private:
	char _UnidentifiedData_371[1];

public:
	// <int32_t mArg, offset 0x174>
	int32_t mArg = 0;

	// <int32_t mArg1, offset 0x178>
	int32_t mArg1 = 0;

	// <int32_t mArg2, offset 0x17c>
	int32_t mArg2 = 0;

	// <int32_t minBossWait, offset 0x180>
	int32_t minBossWait = 0;

	// <uint8_t mDemoPlayToResult, offset 0x184>
	uint8_t mDemoPlayToResult = 0;

	// <uint8_t mCameraStay, offset 0x185>
	uint8_t mCameraStay = 0;

	// <Unidentified data segment, offset 0x186>
private:
	char _UnidentifiedData_390[2];

public:
	// <float mStartTick, offset 0x188>
	float mStartTick = 0;

	// <float mShadowHeight, offset 0x18c>
	float mShadowHeight = 0;

	// <int32_t mFadeCount, offset 0x190>
	int32_t mFadeCount = 0;

	// <uint8_t mFirstCap, offset 0x194>
	uint8_t mFirstCap = 0;

	// <uint8_t mTrvFreez, offset 0x195>
	uint8_t mTrvFreez = 0;

	// <uint8_t mTrvDelaySetPos, offset 0x196>
	uint8_t mTrvDelaySetPos = 0;

	// <uint8_t mTrvDelaySetRot, offset 0x197>
	uint8_t mTrvDelaySetRot = 0;

	// <struct Vec mTrvDelayPos, offset 0x198>
	struct Vec mTrvDelayPos;

	// <struct Vec mTrvDelayRot, offset 0x1a4>
	struct Vec mTrvDelayRot;

	// <class HrOverLap* mpOverLap, offset 0x1b0>
	class HrOverLap* mpOverLap = nullptr;

	// <uint8_t mOverLapOff, offset 0x1b4>
	uint8_t mOverLapOff = 0;

	// <uint8_t mDebugDisp, offset 0x1b5>
	uint8_t mDebugDisp = 0;

	// <Unidentified data segment, offset 0x1b6>
private:
	char _UnidentifiedData_438[2];

public:
	// <float mCamChangeRate, offset 0x1b8>
	float mCamChangeRate = 0;

	// <uint32_t mContinuNum, offset 0x1bc>
	uint32_t mContinuNum = 0;

	// <uint32_t mContinuCnt, offset 0x1c0>
	uint32_t mContinuCnt = 0;

	// <class HrMiniDemoSound* mpSoundObj[0x3], offset 0x1c4>
	class HrMiniDemoSound* mpSoundObj[3];

	// <struct Vec mPcBeforePos, offset 0x1d0>
	struct Vec mPcBeforePos;

	// <uint8_t mbLoop, offset 0x1dc>
	uint8_t mbLoop = 0;

	// <Unidentified data segment, offset 0x1dd>
private:
	char _UnidentifiedData_477[3];

public:
	// <float mRate, offset 0x1e0>
	float mRate = 0;

	// <float mSlowRate, offset 0x1e4>
	float mSlowRate = 0;

	// <int32_t mSkipFrames, offset 0x1e8>
	int32_t mSkipFrames = 0;

	// <uint8_t mbPcOperate, offset 0x1ec>
	uint8_t mbPcOperate = 0;

	// <uint8_t mbCameraValid, offset 0x1ed>
	uint8_t mbCameraValid = 0;

	// <uint8_t mbAdjustDirec, offset 0x1ee>
	uint8_t mbAdjustDirec = 0;

	// <uint8_t mbCamExist, offset 0x1ef>
	uint8_t mbCamExist = 0;

	// <struct Vec mAdjustDirec, offset 0x1f0>
	struct Vec mAdjustDirec;

	// <class HrKeyEvent mKeyEvent, offset 0x1fc>
	class HrKeyEvent mKeyEvent;

	// <uint8_t mNoOverLapEnd, offset 0x224>
	uint8_t mNoOverLapEnd = 0;

	// <Unidentified data segment, offset 0x225>
private:
	char _UnidentifiedData_549[3];

public:
	// <int32_t mSafePosNum, offset 0x228>
	int32_t mSafePosNum = 0;

	// <struct Vec mSafePos, offset 0x22c>
	struct Vec mSafePos;

	// <struct Vec mSafeRot, offset 0x238>
	struct Vec mSafeRot;

	// <enum HRCAMERA_MODE mReturnCamMode, offset 0x244>
	enum HRCAMERA_MODE mReturnCamMode;

	/// 1 Functions

	// [Function] class ghmResGroup* HrMiniDemo::GetResLink() [?GetResLink@HrMiniDemo@@SAPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__fastcall* _GetResLink_HrMiniDemo__SAPAVghmResGroup__XZ)();
	static class ghmResGroup* GetResLink()
	{
		_GetResLink_HrMiniDemo__SAPAVghmResGroup__XZ mFunc = (_GetResLink_HrMiniDemo__SAPAVghmResGroup__XZ)(GameModule + 0xa97e0);
		return mFunc();
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMiniDemo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMiniDemo& InObject)
	{
		mStatus = InObject.mStatus;
		mDemoNum = InObject.mDemoNum;
		mSndNo = InObject.mSndNo;
		mAbsolute = InObject.mAbsolute;
		mFileptr = InObject.mFileptr;
		mpRsl = InObject.mpRsl;
		mpGan = InObject.mpGan;
		mPauseStep = InObject.mPauseStep;
		mSkip = InObject.mSkip;
		mPauseStart = InObject.mPauseStart;
		mEndPause = InObject.mEndPause;
		mPause = InObject.mPause;
		mEndPauseFade = InObject.mEndPauseFade;
		mOutFadeNoCamReset = InObject.mOutFadeNoCamReset;
		mTrvTarget = InObject.mTrvTarget;
		mTrvOperate = InObject.mTrvOperate;
		mEndPosition = InObject.mEndPosition;
		mEndRotation = InObject.mEndRotation;
		mExitTrvOperateOff = InObject.mExitTrvOperateOff;
		mPosTrvTarget = InObject.mPosTrvTarget;
		mEndPos = InObject.mEndPos;
		mEndRot = InObject.mEndRot;
		mOutFadeType = InObject.mOutFadeType;
		mFade = InObject.mFade;
		mStageChange = InObject.mStageChange;
		minBossLoading = InObject.minBossLoading;
		mArg = InObject.mArg;
		mArg1 = InObject.mArg1;
		mArg2 = InObject.mArg2;
		minBossWait = InObject.minBossWait;
		mDemoPlayToResult = InObject.mDemoPlayToResult;
		mCameraStay = InObject.mCameraStay;
		mStartTick = InObject.mStartTick;
		mShadowHeight = InObject.mShadowHeight;
		mFadeCount = InObject.mFadeCount;
		mFirstCap = InObject.mFirstCap;
		mTrvFreez = InObject.mTrvFreez;
		mTrvDelaySetPos = InObject.mTrvDelaySetPos;
		mTrvDelaySetRot = InObject.mTrvDelaySetRot;
		mTrvDelayPos = InObject.mTrvDelayPos;
		mTrvDelayRot = InObject.mTrvDelayRot;
		mpOverLap = InObject.mpOverLap;
		mOverLapOff = InObject.mOverLapOff;
		mDebugDisp = InObject.mDebugDisp;
		mCamChangeRate = InObject.mCamChangeRate;
		mContinuNum = InObject.mContinuNum;
		mContinuCnt = InObject.mContinuCnt;
		mPcBeforePos = InObject.mPcBeforePos;
		mbLoop = InObject.mbLoop;
		mRate = InObject.mRate;
		mSlowRate = InObject.mSlowRate;
		mSkipFrames = InObject.mSkipFrames;
		mbPcOperate = InObject.mbPcOperate;
		mbCameraValid = InObject.mbCameraValid;
		mbAdjustDirec = InObject.mbAdjustDirec;
		mbCamExist = InObject.mbCamExist;
		mAdjustDirec = InObject.mAdjustDirec;
		mKeyEvent = InObject.mKeyEvent;
		mNoOverLapEnd = InObject.mNoOverLapEnd;
		mSafePosNum = InObject.mSafePosNum;
		mSafePos = InObject.mSafePos;
		mSafeRot = InObject.mSafeRot;
		mReturnCamMode = InObject.mReturnCamMode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrMiniDemo>("HrMiniDemo")
			.addFunction("__tostring", &HrMiniDemo::ToString)
			.addFunction("GetPtrAddr", &HrMiniDemo::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &HrMiniDemo::field_0)
			.addProperty("mStatus", &HrMiniDemo::mStatus)
			.addProperty("mDemoNum", &HrMiniDemo::mDemoNum)
			.addProperty("mSndNo", &HrMiniDemo::mSndNo)
			.addProperty("mAbsolute", &HrMiniDemo::mAbsolute)
			.addProperty("mFileptr", &HrMiniDemo::mFileptr)
			.addProperty("mpRsl", &HrMiniDemo::mpRsl)
			.addProperty("mpGan", &HrMiniDemo::mpGan)
			.addProperty("mPauseStep", &HrMiniDemo::mPauseStep)
			.addProperty("mSkip", &HrMiniDemo::mSkip)
			.addProperty("mPauseStart", &HrMiniDemo::mPauseStart)
			.addProperty("mEndPause", &HrMiniDemo::mEndPause)
			.addProperty("mPause", &HrMiniDemo::mPause)
			.addProperty("mEndPauseFade", &HrMiniDemo::mEndPauseFade)
			.addProperty("mOutFadeNoCamReset", &HrMiniDemo::mOutFadeNoCamReset)
			.addProperty("mTrvTarget", &HrMiniDemo::mTrvTarget)
			.addProperty("mTrvOperate", &HrMiniDemo::mTrvOperate)
			.addProperty("mEndPosition", &HrMiniDemo::mEndPosition)
			.addProperty("mEndRotation", &HrMiniDemo::mEndRotation)
			.addProperty("mExitTrvOperateOff", &HrMiniDemo::mExitTrvOperateOff)
			.addProperty("mPosTrvTarget", &HrMiniDemo::mPosTrvTarget)
			.addProperty("mEndPos", &HrMiniDemo::mEndPos)
			.addProperty("mEndRot", &HrMiniDemo::mEndRot)
			.addProperty("mOutFadeType", &HrMiniDemo::mOutFadeType)
			.addProperty("mFade", &HrMiniDemo::mFade)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mStageName", &HrMiniDemo::mStageName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mDemoName", &HrMiniDemo::mDemoName)
			.addProperty("mStageChange", &HrMiniDemo::mStageChange)
			.addProperty("minBossLoading", &HrMiniDemo::minBossLoading)
			.addProperty("mArg", &HrMiniDemo::mArg)
			.addProperty("mArg1", &HrMiniDemo::mArg1)
			.addProperty("mArg2", &HrMiniDemo::mArg2)
			.addProperty("minBossWait", &HrMiniDemo::minBossWait)
			.addProperty("mDemoPlayToResult", &HrMiniDemo::mDemoPlayToResult)
			.addProperty("mCameraStay", &HrMiniDemo::mCameraStay)
			.addProperty("mStartTick", &HrMiniDemo::mStartTick)
			.addProperty("mShadowHeight", &HrMiniDemo::mShadowHeight)
			.addProperty("mFadeCount", &HrMiniDemo::mFadeCount)
			.addProperty("mFirstCap", &HrMiniDemo::mFirstCap)
			.addProperty("mTrvFreez", &HrMiniDemo::mTrvFreez)
			.addProperty("mTrvDelaySetPos", &HrMiniDemo::mTrvDelaySetPos)
			.addProperty("mTrvDelaySetRot", &HrMiniDemo::mTrvDelaySetRot)
			.addProperty("mTrvDelayPos", &HrMiniDemo::mTrvDelayPos)
			.addProperty("mTrvDelayRot", &HrMiniDemo::mTrvDelayRot)
			.addProperty("mpOverLap", &HrMiniDemo::mpOverLap)
			.addProperty("mOverLapOff", &HrMiniDemo::mOverLapOff)
			.addProperty("mDebugDisp", &HrMiniDemo::mDebugDisp)
			.addProperty("mCamChangeRate", &HrMiniDemo::mCamChangeRate)
			.addProperty("mContinuNum", &HrMiniDemo::mContinuNum)
			.addProperty("mContinuCnt", &HrMiniDemo::mContinuCnt)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpSoundObj", &HrMiniDemo::mpSoundObj)
			.addProperty("mPcBeforePos", &HrMiniDemo::mPcBeforePos)
			.addProperty("mbLoop", &HrMiniDemo::mbLoop)
			.addProperty("mRate", &HrMiniDemo::mRate)
			.addProperty("mSlowRate", &HrMiniDemo::mSlowRate)
			.addProperty("mSkipFrames", &HrMiniDemo::mSkipFrames)
			.addProperty("mbPcOperate", &HrMiniDemo::mbPcOperate)
			.addProperty("mbCameraValid", &HrMiniDemo::mbCameraValid)
			.addProperty("mbAdjustDirec", &HrMiniDemo::mbAdjustDirec)
			.addProperty("mbCamExist", &HrMiniDemo::mbCamExist)
			.addProperty("mAdjustDirec", &HrMiniDemo::mAdjustDirec)
			.addProperty("mKeyEvent", &HrMiniDemo::mKeyEvent)
			.addProperty("mNoOverLapEnd", &HrMiniDemo::mNoOverLapEnd)
			.addProperty("mSafePosNum", &HrMiniDemo::mSafePosNum)
			.addProperty("mSafePos", &HrMiniDemo::mSafePos)
			.addProperty("mSafeRot", &HrMiniDemo::mSafeRot)
			.addProperty("mReturnCamMode", &HrMiniDemo::mReturnCamMode)
			.addStaticFunction("GetResLink", &HrMiniDemo::GetResLink)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemo::field_0) == 4, "expected HrMiniDemo::field_0 to be size 4");
static_assert(sizeof(HrMiniDemo::mStatus) == 4, "expected HrMiniDemo::mStatus to be size 4");
static_assert(sizeof(HrMiniDemo::mDemoNum) == 4, "expected HrMiniDemo::mDemoNum to be size 4");
static_assert(sizeof(HrMiniDemo::mSndNo) == 4, "expected HrMiniDemo::mSndNo to be size 4");
static_assert(sizeof(HrMiniDemo::mAbsolute) == 1, "expected HrMiniDemo::mAbsolute to be size 1");
static_assert(sizeof(HrMiniDemo::mFileptr) == 188, "expected HrMiniDemo::mFileptr to be size 188");
static_assert(sizeof(HrMiniDemo::mpRsl) == 4, "expected HrMiniDemo::mpRsl to be size 4");
static_assert(sizeof(HrMiniDemo::mpGan) == 4, "expected HrMiniDemo::mpGan to be size 4");
static_assert(sizeof(HrMiniDemo::mPauseStep) == 4, "expected HrMiniDemo::mPauseStep to be size 4");
static_assert(sizeof(HrMiniDemo::mSkip) == 60, "expected HrMiniDemo::mSkip to be size 60");
static_assert(sizeof(HrMiniDemo::mPauseStart) == 4, "expected HrMiniDemo::mPauseStart to be size 4");
static_assert(sizeof(HrMiniDemo::mEndPause) == 1, "expected HrMiniDemo::mEndPause to be size 1");
static_assert(sizeof(HrMiniDemo::mPause) == 1, "expected HrMiniDemo::mPause to be size 1");
static_assert(sizeof(HrMiniDemo::mEndPauseFade) == 1, "expected HrMiniDemo::mEndPauseFade to be size 1");
static_assert(sizeof(HrMiniDemo::mOutFadeNoCamReset) == 1, "expected HrMiniDemo::mOutFadeNoCamReset to be size 1");
static_assert(sizeof(HrMiniDemo::mTrvTarget) == 1, "expected HrMiniDemo::mTrvTarget to be size 1");
static_assert(sizeof(HrMiniDemo::mTrvOperate) == 1, "expected HrMiniDemo::mTrvOperate to be size 1");
static_assert(sizeof(HrMiniDemo::mEndPosition) == 1, "expected HrMiniDemo::mEndPosition to be size 1");
static_assert(sizeof(HrMiniDemo::mEndRotation) == 1, "expected HrMiniDemo::mEndRotation to be size 1");
static_assert(sizeof(HrMiniDemo::mExitTrvOperateOff) == 4, "expected HrMiniDemo::mExitTrvOperateOff to be size 4");
static_assert(sizeof(HrMiniDemo::mPosTrvTarget) == 12, "expected HrMiniDemo::mPosTrvTarget to be size 12");
static_assert(sizeof(HrMiniDemo::mEndPos) == 12, "expected HrMiniDemo::mEndPos to be size 12");
static_assert(sizeof(HrMiniDemo::mEndRot) == 12, "expected HrMiniDemo::mEndRot to be size 12");
static_assert(sizeof(HrMiniDemo::mOutFadeType) == 4, "expected HrMiniDemo::mOutFadeType to be size 4");
static_assert(sizeof(HrMiniDemo::mFade) == 1, "expected HrMiniDemo::mFade to be size 1");
static_assert(sizeof(HrMiniDemo::mStageName) == 16, "expected HrMiniDemo::mStageName to be size 16");
static_assert(sizeof(HrMiniDemo::mDemoName) == 16, "expected HrMiniDemo::mDemoName to be size 16");
static_assert(sizeof(HrMiniDemo::mStageChange) == 1, "expected HrMiniDemo::mStageChange to be size 1");
static_assert(sizeof(HrMiniDemo::minBossLoading) == 1, "expected HrMiniDemo::minBossLoading to be size 1");
static_assert(sizeof(HrMiniDemo::mArg) == 4, "expected HrMiniDemo::mArg to be size 4");
static_assert(sizeof(HrMiniDemo::mArg1) == 4, "expected HrMiniDemo::mArg1 to be size 4");
static_assert(sizeof(HrMiniDemo::mArg2) == 4, "expected HrMiniDemo::mArg2 to be size 4");
static_assert(sizeof(HrMiniDemo::minBossWait) == 4, "expected HrMiniDemo::minBossWait to be size 4");
static_assert(sizeof(HrMiniDemo::mDemoPlayToResult) == 1, "expected HrMiniDemo::mDemoPlayToResult to be size 1");
static_assert(sizeof(HrMiniDemo::mCameraStay) == 1, "expected HrMiniDemo::mCameraStay to be size 1");
static_assert(sizeof(HrMiniDemo::mStartTick) == 4, "expected HrMiniDemo::mStartTick to be size 4");
static_assert(sizeof(HrMiniDemo::mShadowHeight) == 4, "expected HrMiniDemo::mShadowHeight to be size 4");
static_assert(sizeof(HrMiniDemo::mFadeCount) == 4, "expected HrMiniDemo::mFadeCount to be size 4");
static_assert(sizeof(HrMiniDemo::mFirstCap) == 1, "expected HrMiniDemo::mFirstCap to be size 1");
static_assert(sizeof(HrMiniDemo::mTrvFreez) == 1, "expected HrMiniDemo::mTrvFreez to be size 1");
static_assert(sizeof(HrMiniDemo::mTrvDelaySetPos) == 1, "expected HrMiniDemo::mTrvDelaySetPos to be size 1");
static_assert(sizeof(HrMiniDemo::mTrvDelaySetRot) == 1, "expected HrMiniDemo::mTrvDelaySetRot to be size 1");
static_assert(sizeof(HrMiniDemo::mTrvDelayPos) == 12, "expected HrMiniDemo::mTrvDelayPos to be size 12");
static_assert(sizeof(HrMiniDemo::mTrvDelayRot) == 12, "expected HrMiniDemo::mTrvDelayRot to be size 12");
static_assert(sizeof(HrMiniDemo::mpOverLap) == 4, "expected HrMiniDemo::mpOverLap to be size 4");
static_assert(sizeof(HrMiniDemo::mOverLapOff) == 1, "expected HrMiniDemo::mOverLapOff to be size 1");
static_assert(sizeof(HrMiniDemo::mDebugDisp) == 1, "expected HrMiniDemo::mDebugDisp to be size 1");
static_assert(sizeof(HrMiniDemo::mCamChangeRate) == 4, "expected HrMiniDemo::mCamChangeRate to be size 4");
static_assert(sizeof(HrMiniDemo::mContinuNum) == 4, "expected HrMiniDemo::mContinuNum to be size 4");
static_assert(sizeof(HrMiniDemo::mContinuCnt) == 4, "expected HrMiniDemo::mContinuCnt to be size 4");
static_assert(sizeof(HrMiniDemo::mpSoundObj) == 12, "expected HrMiniDemo::mpSoundObj to be size 12");
static_assert(sizeof(HrMiniDemo::mPcBeforePos) == 12, "expected HrMiniDemo::mPcBeforePos to be size 12");
static_assert(sizeof(HrMiniDemo::mbLoop) == 1, "expected HrMiniDemo::mbLoop to be size 1");
static_assert(sizeof(HrMiniDemo::mRate) == 4, "expected HrMiniDemo::mRate to be size 4");
static_assert(sizeof(HrMiniDemo::mSlowRate) == 4, "expected HrMiniDemo::mSlowRate to be size 4");
static_assert(sizeof(HrMiniDemo::mSkipFrames) == 4, "expected HrMiniDemo::mSkipFrames to be size 4");
static_assert(sizeof(HrMiniDemo::mbPcOperate) == 1, "expected HrMiniDemo::mbPcOperate to be size 1");
static_assert(sizeof(HrMiniDemo::mbCameraValid) == 1, "expected HrMiniDemo::mbCameraValid to be size 1");
static_assert(sizeof(HrMiniDemo::mbAdjustDirec) == 1, "expected HrMiniDemo::mbAdjustDirec to be size 1");
static_assert(sizeof(HrMiniDemo::mbCamExist) == 1, "expected HrMiniDemo::mbCamExist to be size 1");
static_assert(sizeof(HrMiniDemo::mAdjustDirec) == 12, "expected HrMiniDemo::mAdjustDirec to be size 12");
static_assert(sizeof(HrMiniDemo::mKeyEvent) == 40, "expected HrMiniDemo::mKeyEvent to be size 40");
static_assert(sizeof(HrMiniDemo::mNoOverLapEnd) == 1, "expected HrMiniDemo::mNoOverLapEnd to be size 1");
static_assert(sizeof(HrMiniDemo::mSafePosNum) == 4, "expected HrMiniDemo::mSafePosNum to be size 4");
static_assert(sizeof(HrMiniDemo::mSafePos) == 12, "expected HrMiniDemo::mSafePos to be size 12");
static_assert(sizeof(HrMiniDemo::mSafeRot) == 12, "expected HrMiniDemo::mSafeRot to be size 12");
static_assert(sizeof(HrMiniDemo::mReturnCamMode) == 4, "expected HrMiniDemo::mReturnCamMode to be size 4");
static_assert(sizeof(HrMiniDemo) == 0x248, "expected HrMiniDemo to be size 0x248");

// [Structure] class HrMiniDemoObj
class HrMiniDemoObj : public ghmListObj
{
public:
	// enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID
	enum HRMINIDEMOOBJ_KIND_ID : uint32_t
	{
		// <MDEMO_KIND_TRV = 0x0>
		MDEMO_KIND_TRV = 0,

		// <MDEMO_KIND_MODEL = 0x1>
		MDEMO_KIND_MODEL = 1,

		// <MDEMO_KIND_CAMERA = 0x2>
		MDEMO_KIND_CAMERA = 2,

		// <MDEMO_KIND_SOUND = 0x3>
		MDEMO_KIND_SOUND = 3,

		// <MDEMO_KIND_EFFECT = 0x4>
		MDEMO_KIND_EFFECT = 4,

		// <MDEMO_KIND_MESSAGE = 0x5>
		MDEMO_KIND_MESSAGE = 5,

		// <MDEMO_KIND_BIKE = 0x6>
		MDEMO_KIND_BIKE = 6,

		// <MDEMO_KIND_MAX = 0x7>
		MDEMO_KIND_MAX = 7

	};

	// enum HrMiniDemoObj::MDEMO_OBJ_STS
	enum MDEMO_OBJ_STS : uint32_t
	{
		// <MDEMO_OBJ_INIT = 0x0>
		MDEMO_OBJ_INIT = 0,

		// <MDEMO_OBJ_IDLE = 0x1>
		MDEMO_OBJ_IDLE = 1,

		// <MDEMO_OBJ_PLAY = 0x2>
		MDEMO_OBJ_PLAY = 2,

		// <MDEMO_OBJ_FIN = 0x3>
		MDEMO_OBJ_FIN = 3,

		// <MDEMO_OBJ_PAUSE = 0x4>
		MDEMO_OBJ_PAUSE = 4,

		// <MDEMO_OBJ_EXIT = 0x5>
		MDEMO_OBJ_EXIT = 5,

		// <MDEMO_OBJ_MAX = 0x6>
		MDEMO_OBJ_MAX = 6

	};

	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID mKind, offset 0x10>
	enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID mKind;

	// <class TGan* mpGan, offset 0x14>
	class TGan* mpGan = nullptr;

	// <float mStartTick, offset 0x18>
	float mStartTick = 0;

	// <enum HrMiniDemoObj::MDEMO_OBJ_STS mStatus, offset 0x1c>
	enum HrMiniDemoObj::MDEMO_OBJ_STS mStatus;

	// <uint8_t mPause, offset 0x20>
	uint8_t mPause = 0;

	// <uint8_t mEndPause, offset 0x21>
	uint8_t mEndPause = 0;

	// <uint8_t mEndPauseDo, offset 0x22>
	uint8_t mEndPauseDo = 0;

	// <Unidentified data segment, offset 0x23>
private:
	char _UnidentifiedData_35[5];

public:
	// <uint64_t mName, offset 0x28>
	uint64_t mName;

	// <char mNameStr[0x10], offset 0x30>
	char mNameStr[16];

	// <uint8_t mSHeightflg, offset 0x40>
	uint8_t mSHeightflg = 0;

	// <Unidentified data segment, offset 0x41>
private:
	char _UnidentifiedData_65[3];

public:
	// <float mSHeight, offset 0x44>
	float mSHeight = 0;

	// <uint8_t mbDrawMirror, offset 0x48>
	uint8_t mbDrawMirror = 0;

	// <uint8_t mbShadowDraw, offset 0x49>
	uint8_t mbShadowDraw = 0;

	// <Unidentified data segment, offset 0x4a>
private:
	char _UnidentifiedData_74[6];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMiniDemoObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMiniDemoObj& InObject)
	{
		mKind = InObject.mKind;
		mpGan = InObject.mpGan;
		mStartTick = InObject.mStartTick;
		mStatus = InObject.mStatus;
		mPause = InObject.mPause;
		mEndPause = InObject.mEndPause;
		mEndPauseDo = InObject.mEndPauseDo;
		mName = InObject.mName;
		mSHeightflg = InObject.mSHeightflg;
		mSHeight = InObject.mSHeight;
		mbDrawMirror = InObject.mbDrawMirror;
		mbShadowDraw = InObject.mbShadowDraw;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMiniDemoObj, ghmListObj>("HrMiniDemoObj")
			.addFunction("__tostring", &HrMiniDemoObj::ToString)
			.addFunction("GetPtrAddr", &HrMiniDemoObj::GetPtrAddr)
			.addProperty("mKind", &HrMiniDemoObj::mKind)
			.addProperty("mpGan", &HrMiniDemoObj::mpGan)
			.addProperty("mStartTick", &HrMiniDemoObj::mStartTick)
			.addProperty("mStatus", &HrMiniDemoObj::mStatus)
			.addProperty("mPause", &HrMiniDemoObj::mPause)
			.addProperty("mEndPause", &HrMiniDemoObj::mEndPause)
			.addProperty("mEndPauseDo", &HrMiniDemoObj::mEndPauseDo)
			.addProperty("mName", &HrMiniDemoObj::mName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mNameStr", &HrMiniDemoObj::mNameStr)
			.addProperty("mSHeightflg", &HrMiniDemoObj::mSHeightflg)
			.addProperty("mSHeight", &HrMiniDemoObj::mSHeight)
			.addProperty("mbDrawMirror", &HrMiniDemoObj::mbDrawMirror)
			.addProperty("mbShadowDraw", &HrMiniDemoObj::mbShadowDraw)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemoObj::mKind) == 4, "expected HrMiniDemoObj::mKind to be size 4");
static_assert(sizeof(HrMiniDemoObj::mpGan) == 4, "expected HrMiniDemoObj::mpGan to be size 4");
static_assert(sizeof(HrMiniDemoObj::mStartTick) == 4, "expected HrMiniDemoObj::mStartTick to be size 4");
static_assert(sizeof(HrMiniDemoObj::mStatus) == 4, "expected HrMiniDemoObj::mStatus to be size 4");
static_assert(sizeof(HrMiniDemoObj::mPause) == 1, "expected HrMiniDemoObj::mPause to be size 1");
static_assert(sizeof(HrMiniDemoObj::mEndPause) == 1, "expected HrMiniDemoObj::mEndPause to be size 1");
static_assert(sizeof(HrMiniDemoObj::mEndPauseDo) == 1, "expected HrMiniDemoObj::mEndPauseDo to be size 1");
static_assert(sizeof(HrMiniDemoObj::mName) == 8, "expected HrMiniDemoObj::mName to be size 8");
static_assert(sizeof(HrMiniDemoObj::mNameStr) == 16, "expected HrMiniDemoObj::mNameStr to be size 16");
static_assert(sizeof(HrMiniDemoObj::mSHeightflg) == 1, "expected HrMiniDemoObj::mSHeightflg to be size 1");
static_assert(sizeof(HrMiniDemoObj::mSHeight) == 4, "expected HrMiniDemoObj::mSHeight to be size 4");
static_assert(sizeof(HrMiniDemoObj::mbDrawMirror) == 1, "expected HrMiniDemoObj::mbDrawMirror to be size 1");
static_assert(sizeof(HrMiniDemoObj::mbShadowDraw) == 1, "expected HrMiniDemoObj::mbShadowDraw to be size 1");
static_assert(sizeof(HrMiniDemoObj) == 0x50, "expected HrMiniDemoObj to be size 0x50");

// [Structure] class HrMiniDemoSound
class HrMiniDemoSound : public HrMiniDemoObj
{
public:
	/// Struct member variables

	// <class HrMiniDemoObj field_0, offset 0x0>
	// class HrMiniDemoObj Super;

	// <int32_t mSndNo, offset 0x50>
	int32_t mSndNo = 0;

	// <int32_t mSndHndl, offset 0x54>
	int32_t mSndHndl = 0;

	// <uint8_t mIsPlay, offset 0x58>
	uint8_t mIsPlay = 0;

	// <uint8_t mStartPause, offset 0x59>
	uint8_t mStartPause = 0;

	// <Unidentified data segment, offset 0x5a>
private:
	char _UnidentifiedData_90[2];

public:
	// <uint32_t mContinuIdx, offset 0x5c>
	uint32_t mContinuIdx = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMiniDemoSound [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMiniDemoSound& InObject)
	{
		mSndNo = InObject.mSndNo;
		mSndHndl = InObject.mSndHndl;
		mIsPlay = InObject.mIsPlay;
		mStartPause = InObject.mStartPause;
		mContinuIdx = InObject.mContinuIdx;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMiniDemoSound, HrMiniDemoObj>("HrMiniDemoSound")
			.addFunction("__tostring", &HrMiniDemoSound::ToString)
			.addFunction("GetPtrAddr", &HrMiniDemoSound::GetPtrAddr)
			.addProperty("mSndNo", &HrMiniDemoSound::mSndNo)
			.addProperty("mSndHndl", &HrMiniDemoSound::mSndHndl)
			.addProperty("mIsPlay", &HrMiniDemoSound::mIsPlay)
			.addProperty("mStartPause", &HrMiniDemoSound::mStartPause)
			.addProperty("mContinuIdx", &HrMiniDemoSound::mContinuIdx)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemoSound::mSndNo) == 4, "expected HrMiniDemoSound::mSndNo to be size 4");
static_assert(sizeof(HrMiniDemoSound::mSndHndl) == 4, "expected HrMiniDemoSound::mSndHndl to be size 4");
static_assert(sizeof(HrMiniDemoSound::mIsPlay) == 1, "expected HrMiniDemoSound::mIsPlay to be size 1");
static_assert(sizeof(HrMiniDemoSound::mStartPause) == 1, "expected HrMiniDemoSound::mStartPause to be size 1");
static_assert(sizeof(HrMiniDemoSound::mContinuIdx) == 4, "expected HrMiniDemoSound::mContinuIdx to be size 4");
static_assert(sizeof(HrMiniDemoSound) == 0x60, "expected HrMiniDemoSound to be size 0x60");

// Unsupported constructor
//void __convention("thiscall") HrStageDraw::MAIN::MAIN(struct HrStageDraw::MAIN* const this)
// Unsupported destructor
//void __convention("thiscall") HrStageDraw::MAIN::~MAIN(struct HrStageDraw::MAIN* const this)
// [Structure] class mHRLockOnList
class mHRLockOnList : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class mHRChara* mpChara, offset 0x10>
	class mHRChara* mpChara = nullptr;

	/// 5 Functions

	// [Function] class mHRChara* __convention("thiscall") mHRLockOnList::mGetCharaPtr(class mHRLockOnList* const this) [?mGetCharaPtr@mHRLockOnList@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mGetCharaPtr_mHRLockOnList__QAEPAVmHRChara__XZ)(class mHRLockOnList* const thisPtr);
	class mHRChara* mGetCharaPtr()
	{
		_mGetCharaPtr_mHRLockOnList__QAEPAVmHRChara__XZ mFunc = (_mGetCharaPtr_mHRLockOnList__QAEPAVmHRChara__XZ)(GameModule + 0xaab80);
		return mFunc(this);
	}
	// [Function] uint8_t mHRLockOnList::mCheckEntry(class mHRChara* arg1) [?mCheckEntry@mHRLockOnList@@SA_NPAVmHRChara@@@Z]
	typedef uint8_t(__fastcall* _mCheckEntry_mHRLockOnList__SA_NPAVmHRChara___Z)(class mHRChara* arg1);
	static uint8_t mCheckEntry(class mHRChara* arg1)
	{
		_mCheckEntry_mHRLockOnList__SA_NPAVmHRChara___Z mFunc = (_mCheckEntry_mHRLockOnList__SA_NPAVmHRChara___Z)(GameModule + 0x567850);
		return mFunc(arg1);
	}
	// [Function] void mHRLockOnList::mAddList(class mHRChara* arg1) [?mAddList@mHRLockOnList@@SAXPAVmHRChara@@@Z]
	typedef void(__fastcall* _mAddList_mHRLockOnList__SAXPAVmHRChara___Z)(class mHRChara* arg1);
	static void mAddList(class mHRChara* arg1)
	{
		_mAddList_mHRLockOnList__SAXPAVmHRChara___Z mFunc = (_mAddList_mHRLockOnList__SAXPAVmHRChara___Z)(GameModule + 0x567880);
		return mFunc(arg1);
	}
	// [Function] void mHRLockOnList::mDelList(class mHRChara* arg1) [?mDelList@mHRLockOnList@@SAXPAVmHRChara@@@Z]
	typedef void(__fastcall* _mDelList_mHRLockOnList__SAXPAVmHRChara___Z)(class mHRChara* arg1);
	static void mDelList(class mHRChara* arg1)
	{
		_mDelList_mHRLockOnList__SAXPAVmHRChara___Z mFunc = (_mDelList_mHRLockOnList__SAXPAVmHRChara___Z)(GameModule + 0x567910);
		return mFunc(arg1);
	}
	// [Function] class mHRLockOnList* mHRLockOnList::mGetNextTatget(class mHRChara* arg1) [?mGetNextTatget@mHRLockOnList@@SAPAV1@PAVmHRChara@@@Z]
	typedef class mHRLockOnList*(__fastcall* _mGetNextTatget_mHRLockOnList__SAPAV1_PAVmHRChara___Z)(class mHRChara* arg1);
	static class mHRLockOnList* mGetNextTatget(class mHRChara* arg1)
	{
		_mGetNextTatget_mHRLockOnList__SAPAV1_PAVmHRChara___Z mFunc = (_mGetNextTatget_mHRLockOnList__SAPAV1_PAVmHRChara___Z)(GameModule + 0x567940);
		return mFunc(arg1);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class mHRLockOnList [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(mHRLockOnList& InObject)
	{
		mpChara = InObject.mpChara;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<mHRLockOnList, ghmListObj>("mHRLockOnList")
			.addFunction("__tostring", &mHRLockOnList::ToString)
			.addFunction("GetPtrAddr", &mHRLockOnList::GetPtrAddr)
			.addProperty("mpChara", &mHRLockOnList::mpChara)
			.addFunction("mGetCharaPtr", &mHRLockOnList::mGetCharaPtr)
			.addStaticFunction("mCheckEntry", &mHRLockOnList::mCheckEntry)
			.addStaticFunction("mAddList", &mHRLockOnList::mAddList)
			.addStaticFunction("mDelList", &mHRLockOnList::mDelList)
			.addStaticFunction("mGetNextTatget", &mHRLockOnList::mGetNextTatget)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRLockOnList::mpChara) == 4, "expected mHRLockOnList::mpChara to be size 4");
static_assert(sizeof(mHRLockOnList) == 0x14, "expected mHRLockOnList to be size 0x14");

// [Structure] class pcSNB
class pcSNB : public mHRPc
{
public:
	/// Struct member variables

	// <class mHRPc Super, offset 0x0>
	// class mHRPc Super;

	// <Unidentified data segment, offset 0x1fb0>
private:
	char _UnidentifiedData_8112[140];

public:
	/// 23 Functions

	// [Function] void __convention("thiscall") pcSNB::mSetFireSonicSowrd(class pcSNB* const this, uint8_t arg2) [?mSetFireSonicSowrd@pcSNB@@QAEX_N@Z]
	typedef void(__thiscall* _mSetFireSonicSowrd_pcSNB__QAEX_N_Z)(class pcSNB* const thisPtr, uint8_t arg2);
	void mSetFireSonicSowrd(uint8_t arg2)
	{
		_mSetFireSonicSowrd_pcSNB__QAEX_N_Z mFunc = (_mSetFireSonicSowrd_pcSNB__QAEX_N_Z)(GameModule + 0xaacc0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mGetFireSonicSowrd(class pcSNB* const this) [?mGetFireSonicSowrd@pcSNB@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mGetFireSonicSowrd_pcSNB__QAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mGetFireSonicSowrd()
	{
		_mGetFireSonicSowrd_pcSNB__QAE_NXZ mFunc = (_mGetFireSonicSowrd_pcSNB__QAE_NXZ)(GameModule + 0xbfcc0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") pcSNB::mGetRotInterpolateDefault(class pcSNB* const this) [?mGetRotInterpolateDefault@pcSNB@@UAEMXZ]
	typedef float(__thiscall* _mGetRotInterpolateDefault_pcSNB__UAEMXZ)(class pcSNB* const thisPtr);
	float mGetRotInterpolateDefault()
	{
		_mGetRotInterpolateDefault_pcSNB__UAEMXZ mFunc = (_mGetRotInterpolateDefault_pcSNB__UAEMXZ)(GameModule + 0xbfcd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mMoveNextAttackNpcPos(class pcSNB* const this) [?mMoveNextAttackNpcPos@pcSNB@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mMoveNextAttackNpcPos_pcSNB__QAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mMoveNextAttackNpcPos()
	{
		_mMoveNextAttackNpcPos_pcSNB__QAE_NXZ mFunc = (_mMoveNextAttackNpcPos_pcSNB__QAE_NXZ)(GameModule + 0x4f7780);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mCheckEmptyWorkSonicSword(class pcSNB* const this) [?mCheckEmptyWorkSonicSword@pcSNB@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckEmptyWorkSonicSword_pcSNB__QAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mCheckEmptyWorkSonicSword()
	{
		_mCheckEmptyWorkSonicSword_pcSNB__QAE_NXZ mFunc = (_mCheckEmptyWorkSonicSword_pcSNB__QAE_NXZ)(GameModule + 0x4f7940);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcSNB::mCreateSonicSword(class pcSNB* const this, uint8_t arg2) [?mCreateSonicSword@pcSNB@@QAEX_N@Z]
	typedef void(__thiscall* _mCreateSonicSword_pcSNB__QAEX_N_Z)(class pcSNB* const thisPtr, uint8_t arg2);
	void mCreateSonicSword(uint8_t arg2)
	{
		_mCreateSonicSword_pcSNB__QAEX_N_Z mFunc = (_mCreateSonicSword_pcSNB__QAEX_N_Z)(GameModule + 0x4f7960);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcSNB::mEffectProc(class pcSNB* const this) [?mEffectProc@pcSNB@@UAEXXZ]
	typedef void(__thiscall* _mEffectProc_pcSNB__UAEXXZ)(class pcSNB* const thisPtr);
	void mEffectProc()
	{
		_mEffectProc_pcSNB__UAEXXZ mFunc = (_mEffectProc_pcSNB__UAEXXZ)(GameModule + 0x4f7ab0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mCheckLanding(class pcSNB* const this, float arg2) [?mCheckLanding@pcSNB@@QAE_NM@Z]
	typedef uint8_t(__thiscall* _mCheckLanding_pcSNB__QAE_NM_Z)(class pcSNB* const thisPtr, float arg2);
	uint8_t mCheckLanding(float arg2)
	{
		_mCheckLanding_pcSNB__QAE_NM_Z mFunc = (_mCheckLanding_pcSNB__QAE_NM_Z)(GameModule + 0x4f8040);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcSNB::mForceLanding(class pcSNB* const this) [?mForceLanding@pcSNB@@UAEXXZ]
	typedef void(__thiscall* _mForceLanding_pcSNB__UAEXXZ)(class pcSNB* const thisPtr);
	void mForceLanding()
	{
		_mForceLanding_pcSNB__UAEXXZ mFunc = (_mForceLanding_pcSNB__UAEXXZ)(GameModule + 0x4f80b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mCheckJumpAttack(class pcSNB* const this) [?mCheckJumpAttack@pcSNB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckJumpAttack_pcSNB__UAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mCheckJumpAttack()
	{
		_mCheckJumpAttack_pcSNB__UAE_NXZ mFunc = (_mCheckJumpAttack_pcSNB__UAE_NXZ)(GameModule + 0x4f82c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mCheckJump(class pcSNB* const this) [?mCheckJump@pcSNB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckJump_pcSNB__UAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mCheckJump()
	{
		_mCheckJump_pcSNB__UAE_NXZ mFunc = (_mCheckJump_pcSNB__UAE_NXZ)(GameModule + 0x4f8300);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mJumpProc(class pcSNB* const this) [?mJumpProc@pcSNB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mJumpProc_pcSNB__UAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mJumpProc()
	{
		_mJumpProc_pcSNB__UAE_NXZ mFunc = (_mJumpProc_pcSNB__UAE_NXZ)(GameModule + 0x4f8350);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcSNB::mStartJumpProc(class pcSNB* const this, int32_t arg2) [?mStartJumpProc@pcSNB@@QAEXH@Z]
	typedef void(__thiscall* _mStartJumpProc_pcSNB__QAEXH_Z)(class pcSNB* const thisPtr, int32_t arg2);
	void mStartJumpProc(int32_t arg2)
	{
		_mStartJumpProc_pcSNB__QAEXH_Z mFunc = (_mStartJumpProc_pcSNB__QAEXH_Z)(GameModule + 0x4f8bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcSNB::mJumpAttackHitProc(class pcSNB* const this) [?mJumpAttackHitProc@pcSNB@@QAEXXZ]
	typedef void(__thiscall* _mJumpAttackHitProc_pcSNB__QAEXXZ)(class pcSNB* const thisPtr);
	void mJumpAttackHitProc()
	{
		_mJumpAttackHitProc_pcSNB__QAEXXZ mFunc = (_mJumpAttackHitProc_pcSNB__QAEXXZ)(GameModule + 0x4f8c00);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") pcSNB::mGetSerchNearJumpAttackTarget(class pcSNB* const this) [?mGetSerchNearJumpAttackTarget@pcSNB@@QAEPAVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _mGetSerchNearJumpAttackTarget_pcSNB__QAEPAVmHRChara__XZ)(class pcSNB* const thisPtr);
	class mHRChara* mGetSerchNearJumpAttackTarget()
	{
		_mGetSerchNearJumpAttackTarget_pcSNB__QAEPAVmHRChara__XZ mFunc = (_mGetSerchNearJumpAttackTarget_pcSNB__QAEPAVmHRChara__XZ)(GameModule + 0x4f8fc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcSNB::mJumpAttack(class pcSNB* const this, float arg2, int32_t arg3) [?mJumpAttack@pcSNB@@QAEXMH@Z]
	typedef void(__thiscall* _mJumpAttack_pcSNB__QAEXMH_Z)(class pcSNB* const thisPtr, float arg2, int32_t arg3);
	void mJumpAttack(float arg2, int32_t arg3)
	{
		_mJumpAttack_pcSNB__QAEXMH_Z mFunc = (_mJumpAttack_pcSNB__QAEXMH_Z)(GameModule + 0x4f90e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mCheckAttack(class pcSNB* const this) [?mCheckAttack@pcSNB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAttack_pcSNB__UAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mCheckAttack()
	{
		_mCheckAttack_pcSNB__UAE_NXZ mFunc = (_mCheckAttack_pcSNB__UAE_NXZ)(GameModule + 0x4f9490);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcSNB::mSetNoutou(class pcSNB* const this, uint8_t arg2) [?mSetNoutou@pcSNB@@UAEX_N@Z]
	typedef void(__thiscall* _mSetNoutou_pcSNB__UAEX_N_Z)(class pcSNB* const thisPtr, uint8_t arg2);
	void mSetNoutou(uint8_t arg2)
	{
		_mSetNoutou_pcSNB__UAEX_N_Z mFunc = (_mSetNoutou_pcSNB__UAEX_N_Z)(GameModule + 0x4f9520);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcSNB::mSetBattou(class pcSNB* const this, uint8_t arg2) [?mSetBattou@pcSNB@@UAEX_N@Z]
	typedef void(__thiscall* _mSetBattou_pcSNB__UAEX_N_Z)(class pcSNB* const thisPtr, uint8_t arg2);
	void mSetBattou(uint8_t arg2)
	{
		_mSetBattou_pcSNB__UAEX_N_Z mFunc = (_mSetBattou_pcSNB__UAEX_N_Z)(GameModule + 0x4f9650);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mRenderProc(class pcSNB* const this) [?mRenderProc@pcSNB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mRenderProc_pcSNB__UAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mRenderProc()
	{
		_mRenderProc_pcSNB__UAE_NXZ mFunc = (_mRenderProc_pcSNB__UAE_NXZ)(GameModule + 0x4f97a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcSNB::mCheckExistSonicSowrd(class pcSNB* const this) [?mCheckExistSonicSowrd@pcSNB@@QAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckExistSonicSowrd_pcSNB__QAE_NXZ)(class pcSNB* const thisPtr);
	uint8_t mCheckExistSonicSowrd()
	{
		_mCheckExistSonicSowrd_pcSNB__QAE_NXZ mFunc = (_mCheckExistSonicSowrd_pcSNB__QAE_NXZ)(GameModule + 0x4f9930);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcSNB::mCallFloorJump(class pcSNB* const this) [?mCallFloorJump@pcSNB@@QAEXXZ]
	typedef void(__thiscall* _mCallFloorJump_pcSNB__QAEXXZ)(class pcSNB* const thisPtr);
	void mCallFloorJump()
	{
		_mCallFloorJump_pcSNB__QAEXXZ mFunc = (_mCallFloorJump_pcSNB__QAEXXZ)(GameModule + 0x4f9950);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcSNB::mSetVisibleEffectChargeMax(class pcSNB* const this, uint8_t arg2) [?mSetVisibleEffectChargeMax@pcSNB@@QAEX_N@Z]
	typedef void(__thiscall* _mSetVisibleEffectChargeMax_pcSNB__QAEX_N_Z)(class pcSNB* const thisPtr, uint8_t arg2);
	void mSetVisibleEffectChargeMax(uint8_t arg2)
	{
		_mSetVisibleEffectChargeMax_pcSNB__QAEX_N_Z mFunc = (_mSetVisibleEffectChargeMax_pcSNB__QAEX_N_Z)(GameModule + 0x4f9a60);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class pcSNB [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(pcSNB& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<pcSNB, mHRPc>("pcSNB")
			.addFunction("__tostring", &pcSNB::ToString)
			.addFunction("GetPtrAddr", &pcSNB::GetPtrAddr)
			.addFunction("mSetFireSonicSowrd", &pcSNB::mSetFireSonicSowrd)
			.addFunction("mGetFireSonicSowrd", &pcSNB::mGetFireSonicSowrd)
			.addFunction("mGetRotInterpolateDefault", &pcSNB::mGetRotInterpolateDefault)
			.addFunction("mMoveNextAttackNpcPos", &pcSNB::mMoveNextAttackNpcPos)
			.addFunction("mCheckEmptyWorkSonicSword", &pcSNB::mCheckEmptyWorkSonicSword)
			.addFunction("mCreateSonicSword", &pcSNB::mCreateSonicSword)
			.addFunction("mEffectProc", &pcSNB::mEffectProc)
			.addFunction("mCheckLanding", &pcSNB::mCheckLanding)
			.addFunction("mForceLanding", &pcSNB::mForceLanding)
			.addFunction("mCheckJumpAttack", &pcSNB::mCheckJumpAttack)
			.addFunction("mCheckJump", &pcSNB::mCheckJump)
			.addFunction("mJumpProc", &pcSNB::mJumpProc)
			.addFunction("mStartJumpProc", &pcSNB::mStartJumpProc)
			.addFunction("mJumpAttackHitProc", &pcSNB::mJumpAttackHitProc)
			.addFunction("mGetSerchNearJumpAttackTarget", &pcSNB::mGetSerchNearJumpAttackTarget)
			.addFunction("mJumpAttack", &pcSNB::mJumpAttack)
			.addFunction("mCheckAttack", &pcSNB::mCheckAttack)
			.addFunction("mSetNoutou", &pcSNB::mSetNoutou)
			.addFunction("mSetBattou", &pcSNB::mSetBattou)
			.addFunction("mRenderProc", &pcSNB::mRenderProc)
			.addFunction("mCheckExistSonicSowrd", &pcSNB::mCheckExistSonicSowrd)
			.addFunction("mCallFloorJump", &pcSNB::mCallFloorJump)
			.addFunction("mSetVisibleEffectChargeMax", &pcSNB::mSetVisibleEffectChargeMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(pcSNB) == 0x203c, "expected pcSNB to be size 0x203c");

// [Structure] class pcHEN
class pcHEN : public mHRPc
{
public:
	/// Struct member variables

	// <class mHRPc Super, offset 0x0>
	// class mHRPc Super;

	// <Unidentified data segment, offset 0x1fb0>
private:
	char _UnidentifiedData_8112[156];

public:
	/// 12 Functions

	// [Function] void __convention("thiscall") pcHEN::mClearRapidDashNum(class pcHEN* const this) [?mClearRapidDashNum@pcHEN@@QAEXXZ]
	typedef void(__thiscall* _mClearRapidDashNum_pcHEN__QAEXXZ)(class pcHEN* const thisPtr);
	void mClearRapidDashNum()
	{
		_mClearRapidDashNum_pcHEN__QAEXXZ mFunc = (_mClearRapidDashNum_pcHEN__QAEXXZ)(GameModule + 0xaacd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcHEN::mSetFirePlasma1st(class pcHEN* const this, uint8_t arg2) [?mSetFirePlasma1st@pcHEN@@QAEX_N@Z]
	typedef void(__thiscall* _mSetFirePlasma1st_pcHEN__QAEX_N_Z)(class pcHEN* const thisPtr, uint8_t arg2);
	void mSetFirePlasma1st(uint8_t arg2)
	{
		_mSetFirePlasma1st_pcHEN__QAEX_N_Z mFunc = (_mSetFirePlasma1st_pcHEN__QAEX_N_Z)(GameModule + 0xaace0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcHEN::mSetFirePlasma2nd(class pcHEN* const this, uint8_t arg2) [?mSetFirePlasma2nd@pcHEN@@QAEX_N@Z]
	typedef void(__thiscall* _mSetFirePlasma2nd_pcHEN__QAEX_N_Z)(class pcHEN* const thisPtr, uint8_t arg2);
	void mSetFirePlasma2nd(uint8_t arg2)
	{
		_mSetFirePlasma2nd_pcHEN__QAEX_N_Z mFunc = (_mSetFirePlasma2nd_pcHEN__QAEX_N_Z)(GameModule + 0xaacf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcHEN::mSetPlasmaTargetAndFire(class pcHEN* const this) [?mSetPlasmaTargetAndFire@pcHEN@@QAEXXZ]
	typedef void(__thiscall* _mSetPlasmaTargetAndFire_pcHEN__QAEXXZ)(class pcHEN* const thisPtr);
	void mSetPlasmaTargetAndFire()
	{
		_mSetPlasmaTargetAndFire_pcHEN__QAEXXZ mFunc = (_mSetPlasmaTargetAndFire_pcHEN__QAEXXZ)(GameModule + 0x4f9c40);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcHEN::mEffectProc(class pcHEN* const this) [?mEffectProc@pcHEN@@UAEXXZ]
	typedef void(__thiscall* _mEffectProc_pcHEN__UAEXXZ)(class pcHEN* const thisPtr);
	void mEffectProc()
	{
		_mEffectProc_pcHEN__UAEXXZ mFunc = (_mEffectProc_pcHEN__UAEXXZ)(GameModule + 0x4f9f10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcHEN::mDashProc(class pcHEN* const this) [?mDashProc@pcHEN@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mDashProc_pcHEN__UAE_NXZ)(class pcHEN* const thisPtr);
	uint8_t mDashProc()
	{
		_mDashProc_pcHEN__UAE_NXZ mFunc = (_mDashProc_pcHEN__UAE_NXZ)(GameModule + 0x4fa2b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcHEN::mDashStartProc(class pcHEN* const this) [?mDashStartProc@pcHEN@@UAEXXZ]
	typedef void(__thiscall* _mDashStartProc_pcHEN__UAEXXZ)(class pcHEN* const thisPtr);
	void mDashStartProc()
	{
		_mDashStartProc_pcHEN__UAEXXZ mFunc = (_mDashStartProc_pcHEN__UAEXXZ)(GameModule + 0x4fa340);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcHEN::mCheckAttack(class pcHEN* const this) [?mCheckAttack@pcHEN@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAttack_pcHEN__UAE_NXZ)(class pcHEN* const thisPtr);
	uint8_t mCheckAttack()
	{
		_mCheckAttack_pcHEN__UAE_NXZ mFunc = (_mCheckAttack_pcHEN__UAE_NXZ)(GameModule + 0x4fa600);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcHEN::mSetNoutou(class pcHEN* const this, uint8_t arg2) [?mSetNoutou@pcHEN@@UAEX_N@Z]
	typedef void(__thiscall* _mSetNoutou_pcHEN__UAEX_N_Z)(class pcHEN* const thisPtr, uint8_t arg2);
	void mSetNoutou(uint8_t arg2)
	{
		_mSetNoutou_pcHEN__UAEX_N_Z mFunc = (_mSetNoutou_pcHEN__UAEX_N_Z)(GameModule + 0x4fa670);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcHEN::mSetBattou(class pcHEN* const this, uint8_t arg2) [?mSetBattou@pcHEN@@UAEX_N@Z]
	typedef void(__thiscall* _mSetBattou_pcHEN__UAEX_N_Z)(class pcHEN* const thisPtr, uint8_t arg2);
	void mSetBattou(uint8_t arg2)
	{
		_mSetBattou_pcHEN__UAEX_N_Z mFunc = (_mSetBattou_pcHEN__UAEX_N_Z)(GameModule + 0x4fa770);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcHEN::mBreakPlasma(class pcHEN* const this) [?mBreakPlasma@pcHEN@@QAEXXZ]
	typedef void(__thiscall* _mBreakPlasma_pcHEN__QAEXXZ)(class pcHEN* const thisPtr);
	void mBreakPlasma()
	{
		_mBreakPlasma_pcHEN__QAEXXZ mFunc = (_mBreakPlasma_pcHEN__QAEXXZ)(GameModule + 0x4fa8f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcHEN::mCreatePlasma(class pcHEN* const this, float arg2, int32_t arg3) [?mCreatePlasma@pcHEN@@QAEXMH@Z]
	typedef void(__thiscall* _mCreatePlasma_pcHEN__QAEXMH_Z)(class pcHEN* const thisPtr, float arg2, int32_t arg3);
	void mCreatePlasma(float arg2, int32_t arg3)
	{
		_mCreatePlasma_pcHEN__QAEXMH_Z mFunc = (_mCreatePlasma_pcHEN__QAEXMH_Z)(GameModule + 0x4fa9f0);
		return mFunc(this, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class pcHEN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(pcHEN& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<pcHEN, mHRPc>("pcHEN")
			.addFunction("__tostring", &pcHEN::ToString)
			.addFunction("GetPtrAddr", &pcHEN::GetPtrAddr)
			.addFunction("mClearRapidDashNum", &pcHEN::mClearRapidDashNum)
			.addFunction("mSetFirePlasma1st", &pcHEN::mSetFirePlasma1st)
			.addFunction("mSetFirePlasma2nd", &pcHEN::mSetFirePlasma2nd)
			.addFunction("mSetPlasmaTargetAndFire", &pcHEN::mSetPlasmaTargetAndFire)
			.addFunction("mEffectProc", &pcHEN::mEffectProc)
			.addFunction("mDashProc", &pcHEN::mDashProc)
			.addFunction("mDashStartProc", &pcHEN::mDashStartProc)
			.addFunction("mCheckAttack", &pcHEN::mCheckAttack)
			.addFunction("mSetNoutou", &pcHEN::mSetNoutou)
			.addFunction("mSetBattou", &pcHEN::mSetBattou)
			.addFunction("mBreakPlasma", &pcHEN::mBreakPlasma)
			.addFunction("mCreatePlasma", &pcHEN::mCreatePlasma)
		.endClass();
	}
#endif
};
static_assert(sizeof(pcHEN) == 0x204c, "expected pcHEN to be size 0x204c");

// Unsupported operator
//void* __convention("thiscall") mHRPc::`vector deleting destructor'(class mHRPc* const this, uint32_t arg2)
// Unsupported operator
//void __convention("thiscall") <lambda_2620a86d76e2132a2f45f183e9cb1e92>::operator()(class mHRPc::mTerm::__l2::<lambda_2620a86d76e2132a2f45f183e9cb1e92>* const this, void* arg2)
// Unsupported operator
//void (*)(void*) __convention("thiscall") <lambda_2620a86d76e2132a2f45f183e9cb1e92>::operator void (__cdecl*)(void *)(class mHRPc::mTerm::__l2::<lambda_2620a86d76e2132a2f45f183e9cb1e92>* const this)
// Unsupported operator
//void __convention("thiscall") <lambda_fd1a3423e64afe1ddc65f7a0b0333815>::operator()(class mHRPc::mEquipProc::__l87::<lambda_fd1a3423e64afe1ddc65f7a0b0333815>* const this, void* arg2)
// Unsupported operator
//void (*)(void*) __convention("thiscall") <lambda_fd1a3423e64afe1ddc65f7a0b0333815>::operator void (__cdecl*)(void *)(class mHRPc::mEquipProc::__l87::<lambda_fd1a3423e64afe1ddc65f7a0b0333815>* const this)
// [Structure] class EffectEnemyDamage
class EffectEnemyDamage : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pChara, offset 0x50>
	class mHRChara* m_pChara = nullptr;

	// <class TGmf* m_pGmf, offset 0x54>
	class TGmf* m_pGmf = nullptr;

	// <int32_t m_nUpSpeed, offset 0x58>
	int32_t m_nUpSpeed = 0;

	// <uint32_t m_nColorMin, offset 0x5c>
	uint32_t m_nColorMin = 0;

	// <int32_t m_nBright, offset 0x60>
	int32_t m_nBright = 0;

	/// 1 Functions

	// [Function] class EffectEnemyDamage* EffectEnemyDamage::Create(class mHRChara* arg1, class TGmf* arg2, int32_t arg3, uint32_t const arg4) [?Create@EffectEnemyDamage@@SAPAV1@PAVmHRChara@@PAVTGmf@@HI@Z]
	typedef class EffectEnemyDamage*(__fastcall* _Create_EffectEnemyDamage__SAPAV1_PAVmHRChara__PAVTGmf__HI_Z)(class mHRChara* arg1, class TGmf* arg2, int32_t arg3, uint32_t const arg4);
	static class EffectEnemyDamage* Create(class mHRChara* arg1, class TGmf* arg2, int32_t arg3, uint32_t const arg4)
	{
		_Create_EffectEnemyDamage__SAPAV1_PAVmHRChara__PAVTGmf__HI_Z mFunc = (_Create_EffectEnemyDamage__SAPAV1_PAVmHRChara__PAVTGmf__HI_Z)(GameModule + 0x585710);
		return mFunc(arg1, arg2, arg3, arg4);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectEnemyDamage [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectEnemyDamage& InObject)
	{
		m_pChara = InObject.m_pChara;
		m_pGmf = InObject.m_pGmf;
		m_nUpSpeed = InObject.m_nUpSpeed;
		m_nColorMin = InObject.m_nColorMin;
		m_nBright = InObject.m_nBright;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectEnemyDamage, HrTask>("EffectEnemyDamage")
			.addFunction("__tostring", &EffectEnemyDamage::ToString)
			.addFunction("GetPtrAddr", &EffectEnemyDamage::GetPtrAddr)
			.addProperty("m_pChara", &EffectEnemyDamage::m_pChara)
			.addProperty("m_pGmf", &EffectEnemyDamage::m_pGmf)
			.addProperty("m_nUpSpeed", &EffectEnemyDamage::m_nUpSpeed)
			.addProperty("m_nColorMin", &EffectEnemyDamage::m_nColorMin)
			.addProperty("m_nBright", &EffectEnemyDamage::m_nBright)
			.addStaticFunction("Create", &EffectEnemyDamage::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectEnemyDamage::m_pChara) == 4, "expected EffectEnemyDamage::m_pChara to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_pGmf) == 4, "expected EffectEnemyDamage::m_pGmf to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nUpSpeed) == 4, "expected EffectEnemyDamage::m_nUpSpeed to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nColorMin) == 4, "expected EffectEnemyDamage::m_nColorMin to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nBright) == 4, "expected EffectEnemyDamage::m_nBright to be size 4");
static_assert(sizeof(EffectEnemyDamage) == 0x64, "expected EffectEnemyDamage to be size 0x64");

// Unsupported constructor
//void __convention("thiscall") HrCamera::CMotion::CMotion(class HrCamera::CMotion* const this)
// Unsupported operator
//uint32_t __convention("thiscall") <lambda_e7c594fcacbc0356b640f1b5f3a1a59f>::operator()(class HrMap::RenderProcess::__l2::<lambda_e7c594fcacbc0356b640f1b5f3a1a59f>* const this, float arg2)
// Unsupported constructor
//void __convention("thiscall") rSkyMapMenu::rSkyMapMenu(class rSkyMapMenu* const this)
// Unsupported operator
//void* __convention("thiscall") rSkyMap::`vector deleting destructor'(class rSkyMap* const this, uint32_t arg2)
// Unsupported function
//class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> std::bind<void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>(void (__convention("thiscall")*&& arg1)(class rSkyMapMenu* const this, int32_t), class rSkyMapMenu*&& arg2, int32_t& arg3)
// Unsupported function
//void __convention("thiscall") std::function<void __cdecl(void)>::function<void __cdecl(void)><std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>,void>(class std::function<void __cdecl(void)>* const this, class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> arg2)
// Unsupported constructor
//void __convention("thiscall") std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>* const this, void (__convention("thiscall")*&& arg2)(class rSkyMapMenu* const this, int32_t), class rSkyMapMenu*&& arg3, int32_t& arg4)
// Unsupported function
//void (__convention("thiscall")*&&)(class rSkyMapMenu* const this, int32_t) std::forward<void (__thiscall rSkyMapMenu::*)(int)>(void (__convention("thiscall")*& arg1)(class rSkyMapMenu* const this, int32_t))
// Unsupported function
//class rSkyMapMenu*&& std::forward<class rSkyMapMenu*>(class rSkyMapMenu*& arg1)
// Unsupported function
//class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>&& std::move<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported function
//void __convention("thiscall") std::_Func_class<void>::_Reset<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> >(class std::_Func_class<void>* const this, class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>&& arg2)
// Unsupported function
//uint8_t std::_Test_callable<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> >(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported function
//class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>&& std::forward<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> >(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported function
//class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>* std::addressof<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> const >(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported constructor
//void __convention("thiscall") std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>* const this, class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>&& arg2)
// Unsupported constructor
//void __convention("thiscall") std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>* const this, class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg2)
// Unsupported function
//uint8_t std::_Test_callable<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> >(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1, struct std::integral_constant<bool,0> arg2)
// Unsupported function
//void std::_Invoker_ret<void,1>::_Call<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported function
//class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& std::forward<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> const &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported function
//class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& std::forward<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported function
//void std::invoke<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported function
//void __convention("thiscall") std::_Tuple_val<rSkyMapMenu *>::_Tuple_val<rSkyMapMenu *><rSkyMapMenu *>(struct std::_Tuple_val<rSkyMapMenu *>* const this, class rSkyMapMenu*&& arg2)
// Unsupported function
//void std::_Invoker_functor::_Call<std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &> &>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>& arg1)
// Unsupported function
//void __convention("thiscall") std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>::operator()<>(class std::_Binder<std::_Unforced,void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu *,int &>* const this)
// Unsupported function
//void std::_Invoker_ret<std::_Unforced,0>::_Call<void (__thiscall rSkyMapMenu::*&)(int),rSkyMapMenu * &,int &>(void (__convention("thiscall")*& arg1)(class rSkyMapMenu* const this, int32_t), class rSkyMapMenu*& arg2, int32_t& arg3)
// Unsupported function
//void (__convention("thiscall")*&)(class rSkyMapMenu* const this, int32_t) std::forward<void (__thiscall rSkyMapMenu::*&)(int)>(void (__convention("thiscall")*& arg1)(class rSkyMapMenu* const this, int32_t))
// Unsupported function
//class rSkyMapMenu*& std::forward<class rSkyMapMenu*&>(class rSkyMapMenu*& arg1)
// Unsupported function
//void std::invoke<void (__thiscall rSkyMapMenu::*&)(int),rSkyMapMenu * &,int &>(void (__convention("thiscall")*& arg1)(class rSkyMapMenu* const this, int32_t), class rSkyMapMenu*& arg2, int32_t& arg3)
// Unsupported function
//void std::_Invoker_pmf_pointer::_Call<void (__thiscall rSkyMapMenu::*)(int),rSkyMapMenu * &,int &>(void (__convention("thiscall")* arg1)(class rSkyMapMenu* const this, int32_t), class rSkyMapMenu*& arg2, int32_t& arg3)
// Unsupported destructor
//void __convention("thiscall") HrMap::~HrMap(class HrMap* const this)
// [Structure] struct stThrowInfo
struct stThrowInfo
{
public:
	/// Struct member variables

	// <float targetRotation, offset 0x0>
	float targetRotation = 0;

	// <struct Vec basePosition, offset 0x4>
	struct Vec basePosition;

	// <struct Vec targetPosition, offset 0x10>
	struct Vec targetPosition;

	// <struct Vec addMovPosition, offset 0x1c>
	struct Vec addMovPosition;

	// <struct Vec addPcMovPosition, offset 0x28>
	struct Vec addPcMovPosition;

	// <int32_t slowMotionNo, offset 0x34>
	int32_t slowMotionNo = 0;

	// <int32_t slowTick, offset 0x38>
	int32_t slowTick = 0;

	// <uint8_t setThrowDamage, offset 0x3c>
	uint8_t setThrowDamage = 0;

	// <Unidentified data segment, offset 0x3d>
private:
	char _UnidentifiedData_61[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stThrowInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stThrowInfo& InObject)
	{
		targetRotation = InObject.targetRotation;
		basePosition = InObject.basePosition;
		targetPosition = InObject.targetPosition;
		addMovPosition = InObject.addMovPosition;
		addPcMovPosition = InObject.addPcMovPosition;
		slowMotionNo = InObject.slowMotionNo;
		slowTick = InObject.slowTick;
		setThrowDamage = InObject.setThrowDamage;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stThrowInfo>("stThrowInfo")
			.addFunction("__tostring", &stThrowInfo::ToString)
			.addFunction("GetPtrAddr", &stThrowInfo::GetPtrAddr)
			.addProperty("targetRotation", &stThrowInfo::targetRotation)
			.addProperty("basePosition", &stThrowInfo::basePosition)
			.addProperty("targetPosition", &stThrowInfo::targetPosition)
			.addProperty("addMovPosition", &stThrowInfo::addMovPosition)
			.addProperty("addPcMovPosition", &stThrowInfo::addPcMovPosition)
			.addProperty("slowMotionNo", &stThrowInfo::slowMotionNo)
			.addProperty("slowTick", &stThrowInfo::slowTick)
			.addProperty("setThrowDamage", &stThrowInfo::setThrowDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(stThrowInfo::targetRotation) == 4, "expected stThrowInfo::targetRotation to be size 4");
static_assert(sizeof(stThrowInfo::basePosition) == 12, "expected stThrowInfo::basePosition to be size 12");
static_assert(sizeof(stThrowInfo::targetPosition) == 12, "expected stThrowInfo::targetPosition to be size 12");
static_assert(sizeof(stThrowInfo::addMovPosition) == 12, "expected stThrowInfo::addMovPosition to be size 12");
static_assert(sizeof(stThrowInfo::addPcMovPosition) == 12, "expected stThrowInfo::addPcMovPosition to be size 12");
static_assert(sizeof(stThrowInfo::slowMotionNo) == 4, "expected stThrowInfo::slowMotionNo to be size 4");
static_assert(sizeof(stThrowInfo::slowTick) == 4, "expected stThrowInfo::slowTick to be size 4");
static_assert(sizeof(stThrowInfo::setThrowDamage) == 1, "expected stThrowInfo::setThrowDamage to be size 1");
static_assert(sizeof(stThrowInfo) == 0x40, "expected stThrowInfo to be size 0x40");

// Unsupported operator
//void* __convention("thiscall") mHRChara::`vector deleting destructor'(class mHRChara* const this, uint32_t arg2)
// [Structure] class HrMessage
/// <summary>
/// Related to the top banner UI messages.
/// </summary>
class HrMessage : public ghmListObj
{
public:
	// enum HrMessage::MESS_STATUS_ID
	enum MESS_STATUS_ID : uint32_t
	{
		// <MESS_STS_IDLE = 0x0>
		MESS_STS_IDLE = 0,

		// <MESS_STS_DISP = 0x1>
		MESS_STS_DISP = 1,

		// <MESS_STS_PAUSE = 0x2>
		MESS_STS_PAUSE = 2,

		// <MESS_STS_END = 0x3>
		MESS_STS_END = 3,

		// <MESS_STS_MAX = 0x4>
		MESS_STS_MAX = 4

	};

	/// Struct member variables

	// <class ghmListObj Super, offset 0x0>
	// class ghmListObj Super;

	// <class ghmListObj m_Anchor, offset 0x10>
	class ghmListObj m_Anchor;

	// <uint32_t m_Handle, offset 0x20>
	uint32_t m_Handle = 0;

	// <enum HrMessage::MESS_STATUS_ID m_Status, offset 0x24>
	enum HrMessage::MESS_STATUS_ID m_Status;

	// <class ghmGcFont* mp_Font, offset 0x28>
	class ghmGcFont* mp_Font = nullptr;

	// <class ghmGcFont* m_pFont, offset 0x2c>
	class ghmGcFont* m_pFont = nullptr;

	// <class WGdl* mp_Gdl, offset 0x30>
	class WGdl* mp_Gdl = nullptr;

	// <uint32_t m_NowTick, offset 0x34>
	uint32_t m_NowTick = 0;

	// <struct GdlDialog* m_pCurrentDialog, offset 0x38>
	struct GdlDialog* m_pCurrentDialog = nullptr;

	/// 63 Functions

	// [Function] class ghmGcFont* __convention("thiscall") HrMessage::_GetFont(class HrMessage* const this) [?_GetFont@HrMessage@@IAEPAVghmGcFont@@XZ]
	typedef class ghmGcFont*(__thiscall* __GetFont_HrMessage__IAEPAVghmGcFont__XZ)(class HrMessage* const thisPtr);
	class ghmGcFont* _GetFont()
	{
		__GetFont_HrMessage__IAEPAVghmGcFont__XZ mFunc = (__GetFont_HrMessage__IAEPAVghmGcFont__XZ)(GameModule + 0xb36a0);
		return mFunc(this);
	}
	// [Function] enum HrMessage::MESS_STATUS_ID __convention("thiscall") HrMessage::_GetStatus(class HrMessage* const this) [?_GetStatus@HrMessage@@IAE?AW4MESS_STATUS_ID@1@XZ]
	typedef enum HrMessage::MESS_STATUS_ID(__thiscall* __GetStatus_HrMessage__IAEAW4MESS_STATUS_ID_1_XZ)(class HrMessage* const thisPtr);
	/* enum HrMessage::MESS_STATUS_ID */ uint32_t _GetStatus()
	{
		__GetStatus_HrMessage__IAEAW4MESS_STATUS_ID_1_XZ mFunc = (__GetStatus_HrMessage__IAEAW4MESS_STATUS_ID_1_XZ)(GameModule + 0xb3710);
		return (uint32_t)mFunc(this);
	}
	// [Function] class HrMessage* __convention("thiscall") HrMessage::GetNext(class HrMessage* const this) [?GetNext@HrMessage@@QAEPAV1@XZ]
	typedef class HrMessage*(__thiscall* _GetNext_HrMessage__QAEPAV1_XZ)(class HrMessage* const thisPtr);
	class HrMessage* GetNext()
	{
		_GetNext_HrMessage__QAEPAV1_XZ mFunc = (_GetNext_HrMessage__QAEPAV1_XZ)(GameModule + 0xb3720);
		return mFunc(this);
	}
	// [Function] class WGdl* __convention("thiscall") HrMessage::_GetGdl(class HrMessage* const this) [?_GetGdl@HrMessage@@IAEPAVWGdl@@XZ]
	typedef class WGdl*(__thiscall* __GetGdl_HrMessage__IAEPAVWGdl__XZ)(class HrMessage* const thisPtr);
	class WGdl* _GetGdl()
	{
		__GetGdl_HrMessage__IAEPAVWGdl__XZ mFunc = (__GetGdl_HrMessage__IAEPAVWGdl__XZ)(GameModule + 0xb3730);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") HrMessage::GetHandle(class HrMessage* const this) [?GetHandle@HrMessage@@QAEIXZ]
	typedef uint32_t(__thiscall* _GetHandle_HrMessage__QAEIXZ)(class HrMessage* const thisPtr);
	uint32_t GetHandle()
	{
		_GetHandle_HrMessage__QAEIXZ mFunc = (_GetHandle_HrMessage__QAEIXZ)(GameModule + 0xb3740);
		return mFunc(this);
	}
	// [Function] void HrMessage::StartMessage(uint32_t arg1, int32_t arg2, uint32_t arg3, uint8_t arg4) [?StartMessage@HrMessage@@SAXIHI_N@Z]
	typedef void(__fastcall* _StartMessage_HrMessage__SAXIHI_N_Z)(uint32_t arg1, int32_t arg2, uint32_t arg3, uint8_t arg4);
	static void StartMessage(uint32_t arg1, int32_t arg2, uint32_t arg3, uint8_t arg4)
	{
		_StartMessage_HrMessage__SAXIHI_N_Z mFunc = (_StartMessage_HrMessage__SAXIHI_N_Z)(GameModule + 0x4896f0);
		return mFunc(arg1, arg2, arg3, arg4);
	}
	// [Function] void HrMessage::RenderProcess(void* arg1) [?RenderProcess@HrMessage@@SAXPAX@Z]
	typedef void(__fastcall* _RenderProcess_HrMessage__SAXPAX_Z)(void* arg1);
	static void RenderProcess(void* arg1)
	{
		_RenderProcess_HrMessage__SAXPAX_Z mFunc = (_RenderProcess_HrMessage__SAXPAX_Z)(GameModule + 0x489810);
		return mFunc(arg1);
	}
	// [Function] void __convention("thiscall") HrMessage::Render(class HrMessage* const this) [?Render@HrMessage@@IAEXXZ]
	typedef void(__thiscall* _Render_HrMessage__IAEXXZ)(class HrMessage* const thisPtr);
	void Render()
	{
		_Render_HrMessage__IAEXXZ mFunc = (_Render_HrMessage__IAEXXZ)(GameModule + 0x489860);
		return mFunc(this);
	}
	// [Function] struct GdlDialog* __convention("thiscall") HrMessage::GetDialog(class HrMessage* const this) [?GetDialog@HrMessage@@QAEPAUGdlDialog@@XZ]
	typedef struct GdlDialog*(__thiscall* _GetDialog_HrMessage__QAEPAUGdlDialog__XZ)(class HrMessage* const thisPtr);
	struct GdlDialog* GetDialog()
	{
		_GetDialog_HrMessage__QAEPAUGdlDialog__XZ mFunc = (_GetDialog_HrMessage__QAEPAUGdlDialog__XZ)(GameModule + 0x489890);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMessage::Frame(class HrMessage* const this) [?Frame@HrMessage@@IAEXXZ]
	typedef void(__thiscall* _Frame_HrMessage__IAEXXZ)(class HrMessage* const thisPtr);
	void Frame()
	{
		_Frame_HrMessage__IAEXXZ mFunc = (_Frame_HrMessage__IAEXXZ)(GameModule + 0x4898a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMessage::DispLine_RenderProcess(class HrMessage* const this) [?DispLine_RenderProcess@HrMessage@@IAEXXZ]
	typedef void(__thiscall* _DispLine_RenderProcess_HrMessage__IAEXXZ)(class HrMessage* const thisPtr);
	void DispLine_RenderProcess()
	{
		_DispLine_RenderProcess_HrMessage__IAEXXZ mFunc = (_DispLine_RenderProcess_HrMessage__IAEXXZ)(GameModule + 0x4899c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::DispLine_FrameProcess(class HrMessage* const this) [?DispLine_FrameProcess@HrMessage@@IAE_NXZ]
	typedef uint8_t(__thiscall* _DispLine_FrameProcess_HrMessage__IAE_NXZ)(class HrMessage* const thisPtr);
	uint8_t DispLine_FrameProcess()
	{
		_DispLine_FrameProcess_HrMessage__IAE_NXZ mFunc = (_DispLine_FrameProcess_HrMessage__IAE_NXZ)(GameModule + 0x4899e0);
		return mFunc(this);
	}
	// [Function] void HrMessage::GetStrLengthW(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6) [?GetStrLengthW@HrMessage@@SAXIPBDHHAAM1@Z]
	typedef void(__fastcall* _GetStrLengthW_HrMessage__SAXIPBDHHAAM1_Z)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6);
	static void GetStrLengthW(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetStrLengthW_HrMessage__SAXIPBDHHAAM1_Z mFunc = (_GetStrLengthW_HrMessage__SAXIPBDHHAAM1_Z)(GameModule + 0x489a60);
		return mFunc(arg1, arg2_c_str, arg3, arg4, arg5, arg6);
	}
	// [Function] void HrMessage::GetStrLengthW(uint32_t arg1, int16_t const* arg2, float& arg3, float& arg4) [?GetStrLengthW@HrMessage@@SAXIPB_SAAM1@Z]
	typedef void(__fastcall* _GetStrLengthW_HrMessage__SAXIPB_SAAM1_Z_2)(uint32_t arg1, int16_t const* arg2, float& arg3, float& arg4);
	static void GetStrLengthW_2(uint32_t arg1, int16_t const* arg2, float& arg3, float& arg4)
	{
		_GetStrLengthW_HrMessage__SAXIPB_SAAM1_Z_2 mFunc = (_GetStrLengthW_HrMessage__SAXIPB_SAAM1_Z_2)(GameModule + 0x489b20);
		return mFunc(arg1, arg2, arg3, arg4);
	}
	// [Function] void HrMessage::GetStrLengthW(uint32_t _hnd, int32_t idx, int32_t Line, int32_t Sentence, float& _len, float& _dot) [?GetStrLengthW@HrMessage@@SAXIHHHAAM0@Z]
	typedef void(__fastcall* _GetStrLengthW_HrMessage__SAXIHHHAAM0_Z_3)(uint32_t _hnd, int32_t idx, int32_t Line, int32_t Sentence, float& _len, float& _dot);
	static void GetStrLengthW_3(uint32_t _hnd, int32_t idx, int32_t Line, int32_t Sentence, float& _len, float& _dot)
	{
		_GetStrLengthW_HrMessage__SAXIHHHAAM0_Z_3 mFunc = (_GetStrLengthW_HrMessage__SAXIHHHAAM0_Z_3)(GameModule + 0x489bb0);
		return mFunc(_hnd, idx, Line, Sentence, _len, _dot);
	}
	// [Function] void HrMessage::GetStrLength(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6) [?GetStrLength@HrMessage@@SAXIPBDHHAAM1@Z]
	typedef void(__fastcall* _GetStrLength_HrMessage__SAXIPBDHHAAM1_Z)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6);
	static void GetStrLength(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetStrLength_HrMessage__SAXIPBDHHAAM1_Z mFunc = (_GetStrLength_HrMessage__SAXIPBDHHAAM1_Z)(GameModule + 0x489c60);
		return mFunc(arg1, arg2_c_str, arg3, arg4, arg5, arg6);
	}
	// [Function] void HrMessage::GetStrLength(uint32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6) [?GetStrLength@HrMessage@@SAXIHHHAAM0@Z]
	typedef void(__fastcall* _GetStrLength_HrMessage__SAXIHHHAAM0_Z_2)(uint32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6);
	static void GetStrLength_2(uint32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6)
	{
		_GetStrLength_HrMessage__SAXIHHHAAM0_Z_2 mFunc = (_GetStrLength_HrMessage__SAXIHHHAAM0_Z_2)(GameModule + 0x489da0);
		return mFunc(arg1, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] void HrMessage::GetTick(uint32_t arg1, char const* arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5) [?GetTick@HrMessage@@SAXIPBDHAAI1@Z]
	typedef void(__fastcall* _GetTick_HrMessage__SAXIPBDHAAI1_Z)(uint32_t arg1, char const* arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5);
	static void GetTick(uint32_t arg1, std::string arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetTick_HrMessage__SAXIPBDHAAI1_Z mFunc = (_GetTick_HrMessage__SAXIPBDHAAI1_Z)(GameModule + 0x489e90);
		return mFunc(arg1, arg2_c_str, arg3, arg4, arg5);
	}
	// [Function] void HrMessage::GetTick(uint32_t arg1, int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5) [?GetTick@HrMessage@@SAXIHHAAI0@Z]
	typedef void(__fastcall* _GetTick_HrMessage__SAXIHHAAI0_Z_2)(uint32_t arg1, int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5);
	static void GetTick_2(uint32_t arg1, int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5)
	{
		_GetTick_HrMessage__SAXIHHAAI0_Z_2 mFunc = (_GetTick_HrMessage__SAXIHHAAI0_Z_2)(GameModule + 0x489f00);
		return mFunc(arg1, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") HrMessage::_GetTick(class HrMessage* const this, int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5) [?_GetTick@HrMessage@@IAEXHHAAI0@Z]
	typedef void(__thiscall* __GetTick_HrMessage__IAEXHHAAI0_Z)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5);
	void _GetTick(int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5)
	{
		__GetTick_HrMessage__IAEXHHAAI0_Z mFunc = (__GetTick_HrMessage__IAEXHHAAI0_Z)(GameModule + 0x489f50);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void HrMessage::SetFontFuti(uint32_t arg1, int32_t arg2, struct GXColor arg3) [?SetFontFuti@HrMessage@@SAXIHUGXColor@@@Z]
	typedef void(__fastcall* _SetFontFuti_HrMessage__SAXIHUGXColor___Z)(uint32_t arg1, int32_t arg2, struct GXColor arg3);
	static void SetFontFuti(uint32_t arg1, int32_t arg2, struct GXColor arg3)
	{
		_SetFontFuti_HrMessage__SAXIHUGXColor___Z mFunc = (_SetFontFuti_HrMessage__SAXIHUGXColor___Z)(GameModule + 0x489fd0);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrMessage::_SetFontFuti(class HrMessage* const this, int32_t arg2, struct GXColor arg3) [?_SetFontFuti@HrMessage@@IAEXHUGXColor@@@Z]
	typedef void(__thiscall* __SetFontFuti_HrMessage__IAEXHUGXColor___Z)(class HrMessage* const thisPtr, int32_t arg2, struct GXColor arg3);
	void _SetFontFuti(int32_t arg2, struct GXColor arg3)
	{
		__SetFontFuti_HrMessage__IAEXHUGXColor___Z mFunc = (__SetFontFuti_HrMessage__IAEXHUGXColor___Z)(GameModule + 0x48a020);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void HrMessage::SetFontEx(uint32_t arg1, float arg2) [?SetFontEx@HrMessage@@SAXIM@Z]
	typedef void(__fastcall* _SetFontEx_HrMessage__SAXIM_Z)(uint32_t arg1, float arg2);
	static void SetFontEx(uint32_t arg1, float arg2)
	{
		_SetFontEx_HrMessage__SAXIM_Z mFunc = (_SetFontEx_HrMessage__SAXIM_Z)(GameModule + 0x48a040);
		return mFunc(arg1, arg2);
	}
	// [Function] void __convention("thiscall") HrMessage::_SetFontEx(class HrMessage* const this, float arg2) [?_SetFontEx@HrMessage@@IAEXM@Z]
	typedef void(__thiscall* __SetFontEx_HrMessage__IAEXM_Z)(class HrMessage* const thisPtr, float arg2);
	void _SetFontEx(float arg2)
	{
		__SetFontEx_HrMessage__IAEXM_Z mFunc = (__SetFontEx_HrMessage__IAEXM_Z)(GameModule + 0x48a080);
		return mFunc(this, arg2);
	}
	// [Function] wchar_t const* HrMessage::GetStringsW(uint32_t Handle, char const* arg2, int32_t arg3, int32_t arg4) [?GetStringsW@HrMessage@@SAPB_SIPBDHH@Z]
	typedef wchar_t const*(__fastcall* _GetStringsW_HrMessage__SAPB_SIPBDHH_Z)(uint32_t Handle, char const* arg2, int32_t arg3, int32_t arg4);
	static std::string GetStringsW(uint32_t Handle, std::string arg2, int32_t arg3, int32_t arg4)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetStringsW_HrMessage__SAPB_SIPBDHH_Z mFunc = (_GetStringsW_HrMessage__SAPB_SIPBDHH_Z)(GameModule + 0x48a0a0);
		wchar_t const* OutResult = mFunc(Handle, arg2_c_str, arg3, arg4);
		if (OutResult == nullptr) return std::string();
		std::wstring result_wstr(OutResult);
		std::string result_str(result_wstr.length(), 0);
		std::transform(result_wstr.begin(), result_wstr.end(), result_str.begin(), [](wchar_t c) { return (char)c; });
		return result_str;
	}
	// [Function] wchar_t const* HrMessage::GetStringsW(uint32_t Handle, int32_t idx, int32_t Line, int32_t Sentence) [?GetStringsW@HrMessage@@SAPB_SIHHH@Z]
	typedef wchar_t const*(__fastcall* _GetStringsW_HrMessage__SAPB_SIHHH_Z_2)(uint32_t Handle, int32_t idx, int32_t Line, int32_t Sentence);
	static std::string GetStringsW_2(uint32_t Handle, int32_t idx, int32_t Line, int32_t Sentence)
	{
		_GetStringsW_HrMessage__SAPB_SIHHH_Z_2 mFunc = (_GetStringsW_HrMessage__SAPB_SIHHH_Z_2)(GameModule + 0x48a0f0);
		wchar_t const* OutResult = mFunc(Handle, idx, Line, Sentence);
		if (OutResult == nullptr) return std::string();
		std::wstring result_wstr(OutResult);
		std::string result_str(result_wstr.length(), 0);
		std::transform(result_wstr.begin(), result_wstr.end(), result_str.begin(), [](wchar_t c) { return (char)c; });
		return result_str;
	}
	// [Function] char const* HrMessage::GetStrings(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4) [?GetStrings@HrMessage@@SAPBDIPBDHH@Z]
	typedef char const*(__fastcall* _GetStrings_HrMessage__SAPBDIPBDHH_Z)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4);
	static std::string GetStrings(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetStrings_HrMessage__SAPBDIPBDHH_Z mFunc = (_GetStrings_HrMessage__SAPBDIPBDHH_Z)(GameModule + 0x48a120);
		char const* OutResult = mFunc(arg1, arg2_c_str, arg3, arg4);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] char const* HrMessage::GetStrings(uint32_t Handle, int32_t idx, int32_t Line, int32_t Sentence) [?GetStrings@HrMessage@@SAPBDIHHH@Z]
	typedef char const*(__fastcall* _GetStrings_HrMessage__SAPBDIHHH_Z_2)(uint32_t Handle, int32_t idx, int32_t Line, int32_t Sentence);
	static std::string GetStrings_2(uint32_t Handle, int32_t idx, int32_t Line, int32_t Sentence)
	{
		_GetStrings_HrMessage__SAPBDIHHH_Z_2 mFunc = (_GetStrings_HrMessage__SAPBDIHHH_Z_2)(GameModule + 0x48a170);
		char const* OutResult = mFunc(Handle, idx, Line, Sentence);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] wchar_t const* __convention("thiscall") HrMessage::_GetStringsW(class HrMessage* const this, int32_t idx, int32_t Line, int32_t Sentence) [?_GetStringsW@HrMessage@@IAEPB_SHHH@Z]
	typedef wchar_t const*(__thiscall* __GetStringsW_HrMessage__IAEPB_SHHH_Z)(class HrMessage* const thisPtr, int32_t idx, int32_t Line, int32_t Sentence);
	std::string _GetStringsW(int32_t idx, int32_t Line, int32_t Sentence)
	{
		__GetStringsW_HrMessage__IAEPB_SHHH_Z mFunc = (__GetStringsW_HrMessage__IAEPB_SHHH_Z)(GameModule + 0x48a1a0);
		wchar_t const* OutResult = mFunc(this, idx, Line, Sentence);
		if (OutResult == nullptr) return std::string();
		std::wstring result_wstr(OutResult);
		std::string result_str(result_wstr.length(), 0);
		std::transform(result_wstr.begin(), result_wstr.end(), result_str.begin(), [](wchar_t c) { return (char)c; });
		return result_str;
	}
	// [Function] char const* __convention("thiscall") HrMessage::_GetStrings(class HrMessage* const this, int32_t idx, int32_t Line, int32_t Sentence) [?_GetStrings@HrMessage@@IAEPBDHHH@Z]
	typedef char const*(__thiscall* __GetStrings_HrMessage__IAEPBDHHH_Z)(class HrMessage* const thisPtr, int32_t idx, int32_t Line, int32_t Sentence);
	std::string _GetStrings(int32_t idx, int32_t Line, int32_t Sentence)
	{
		__GetStrings_HrMessage__IAEPBDHHH_Z mFunc = (__GetStrings_HrMessage__IAEPBDHHH_Z)(GameModule + 0x48a210);
		char const* OutResult = mFunc(this, idx, Line, Sentence);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] float HrMessage::DispMessage(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10) [?DispMessage@HrMessage@@SAMIPBDHHMMUGXColor@@HH_N@Z]
	typedef float(__fastcall* _DispMessage_HrMessage__SAMIPBDHHMMUGXColor__HH_N_Z)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10);
	static float DispMessage(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10)
	{
		char const* arg2_c_str = arg2.c_str();
		_DispMessage_HrMessage__SAMIPBDHHMMUGXColor__HH_N_Z mFunc = (_DispMessage_HrMessage__SAMIPBDHHMMUGXColor__HH_N_Z)(GameModule + 0x48a280);
		return mFunc(arg1, arg2_c_str, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] float HrMessage::DispMessage(uint32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10) [?DispMessage@HrMessage@@SAMIHHHMMUGXColor@@HH_N@Z]
	typedef float(__fastcall* _DispMessage_HrMessage__SAMIHHHMMUGXColor__HH_N_Z_2)(uint32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10);
	static float DispMessage_2(uint32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10)
	{
		_DispMessage_HrMessage__SAMIHHHMMUGXColor__HH_N_Z_2 mFunc = (_DispMessage_HrMessage__SAMIHHHMMUGXColor__HH_N_Z_2)(GameModule + 0x48a300);
		return mFunc(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] class ghmGcFont* HrMessage::GetFont(uint32_t arg1) [?GetFont@HrMessage@@SAPAVghmGcFont@@I@Z]
	typedef class ghmGcFont*(__fastcall* _GetFont_HrMessage__SAPAVghmGcFont__I_Z)(uint32_t arg1);
	static class ghmGcFont* GetFont(uint32_t arg1)
	{
		_GetFont_HrMessage__SAPAVghmGcFont__I_Z mFunc = (_GetFont_HrMessage__SAPAVghmGcFont__I_Z)(GameModule + 0x48a360);
		return mFunc(arg1);
	}
	// [Function] class WGdl* HrMessage::GetGdl(uint32_t arg1) [?GetGdl@HrMessage@@SAPAVWGdl@@I@Z]
	typedef class WGdl*(__fastcall* _GetGdl_HrMessage__SAPAVWGdl__I_Z)(uint32_t arg1);
	static class WGdl* GetGdl(uint32_t arg1)
	{
		_GetGdl_HrMessage__SAPAVWGdl__I_Z mFunc = (_GetGdl_HrMessage__SAPAVWGdl__I_Z)(GameModule + 0x48a390);
		return mFunc(arg1);
	}
	// [Function] int32_t HrMessage::GetSentenceNum(uint32_t arg1, char const* arg2, int32_t arg3) [?GetSentenceNum@HrMessage@@SAHIPBDH@Z]
	typedef int32_t(__fastcall* _GetSentenceNum_HrMessage__SAHIPBDH_Z)(uint32_t arg1, char const* arg2, int32_t arg3);
	static int32_t GetSentenceNum(uint32_t arg1, std::string arg2, int32_t arg3)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetSentenceNum_HrMessage__SAHIPBDH_Z mFunc = (_GetSentenceNum_HrMessage__SAHIPBDH_Z)(GameModule + 0x48a3c0);
		return mFunc(arg1, arg2_c_str, arg3);
	}
	// [Function] int32_t HrMessage::GetSentenceNum(uint32_t arg1, int32_t arg2, int32_t arg3) [?GetSentenceNum@HrMessage@@SAHIHH@Z]
	typedef int32_t(__fastcall* _GetSentenceNum_HrMessage__SAHIHH_Z_2)(uint32_t arg1, int32_t arg2, int32_t arg3);
	static int32_t GetSentenceNum_2(uint32_t arg1, int32_t arg2, int32_t arg3)
	{
		_GetSentenceNum_HrMessage__SAHIHH_Z_2 mFunc = (_GetSentenceNum_HrMessage__SAHIHH_Z_2)(GameModule + 0x48a420);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] int32_t HrMessage::GetLineNum(uint32_t arg1, char const* arg2) [?GetLineNum@HrMessage@@SAHIPBD@Z]
	typedef int32_t(__fastcall* _GetLineNum_HrMessage__SAHIPBD_Z)(uint32_t arg1, char const* arg2);
	static int32_t GetLineNum(uint32_t arg1, std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetLineNum_HrMessage__SAHIPBD_Z mFunc = (_GetLineNum_HrMessage__SAHIPBD_Z)(GameModule + 0x48a450);
		return mFunc(arg1, arg2_c_str);
	}
	// [Function] int32_t HrMessage::GetLineNum(uint32_t arg1, int32_t arg2) [?GetLineNum@HrMessage@@SAHIH@Z]
	typedef int32_t(__fastcall* _GetLineNum_HrMessage__SAHIH_Z_2)(uint32_t arg1, int32_t arg2);
	static int32_t GetLineNum_2(uint32_t arg1, int32_t arg2)
	{
		_GetLineNum_HrMessage__SAHIH_Z_2 mFunc = (_GetLineNum_HrMessage__SAHIH_Z_2)(GameModule + 0x48a4c0);
		return mFunc(arg1, arg2);
	}
	// [Function] int32_t __convention("thiscall") HrMessage::_GetSentenceNum(class HrMessage* const this, int32_t arg2, int32_t arg3) [?_GetSentenceNum@HrMessage@@IAEHHH@Z]
	typedef int32_t(__thiscall* __GetSentenceNum_HrMessage__IAEHHH_Z)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3);
	int32_t _GetSentenceNum(int32_t arg2, int32_t arg3)
	{
		__GetSentenceNum_HrMessage__IAEHHH_Z mFunc = (__GetSentenceNum_HrMessage__IAEHHH_Z)(GameModule + 0x48a510);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") HrMessage::_GetLineNum(class HrMessage* const this, int32_t arg2) [?_GetLineNum@HrMessage@@IAEHH@Z]
	typedef int32_t(__thiscall* __GetLineNum_HrMessage__IAEHH_Z)(class HrMessage* const thisPtr, int32_t arg2);
	int32_t _GetLineNum(int32_t arg2)
	{
		__GetLineNum_HrMessage__IAEHH_Z mFunc = (__GetLineNum_HrMessage__IAEHH_Z)(GameModule + 0x48a570);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::_DispChar(class HrMessage* const this, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, float arg7, struct GXColor arg8, uint8_t arg9) [?_DispChar@HrMessage@@IAE_NHHHHMMUGXColor@@_N@Z]
	typedef uint8_t(__thiscall* __DispChar_HrMessage__IAE_NHHHHMMUGXColor___N_Z)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, float arg7, struct GXColor arg8, uint8_t arg9);
	uint8_t _DispChar(int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, float arg7, struct GXColor arg8, uint8_t arg9)
	{
		__DispChar_HrMessage__IAE_NHHHHMMUGXColor___N_Z mFunc = (__DispChar_HrMessage__IAE_NHHHHMMUGXColor___N_Z)(GameModule + 0x48a5b0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
	}
	// [Function] float __convention("thiscall") HrMessage::_DispMessage(class HrMessage* const this, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10) [?_DispMessage@HrMessage@@IAEMHHHMMUGXColor@@HH_N@Z]
	typedef float(__thiscall* __DispMessage_HrMessage__IAEMHHHMMUGXColor__HH_N_Z)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10);
	float _DispMessage(int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10)
	{
		__DispMessage_HrMessage__IAEMHHHMMUGXColor__HH_N_Z mFunc = (__DispMessage_HrMessage__IAEMHHHMMUGXColor__HH_N_Z)(GameModule + 0x48a6a0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] void __convention("thiscall") HrMessage::_Stop(class HrMessage* const this) [?_Stop@HrMessage@@IAEXXZ]
	typedef void(__thiscall* __Stop_HrMessage__IAEXXZ)(class HrMessage* const thisPtr);
	void _Stop()
	{
		__Stop_HrMessage__IAEXXZ mFunc = (__Stop_HrMessage__IAEXXZ)(GameModule + 0x48aa70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::SetMessage(class HrMessage* const this, char const* arg2, uint32_t arg3, uint8_t arg4) [?SetMessage@HrMessage@@QAE_NPBDI_N@Z]
	typedef uint8_t(__thiscall* _SetMessage_HrMessage__QAE_NPBDI_N_Z)(class HrMessage* const thisPtr, char const* arg2, uint32_t arg3, uint8_t arg4);
	uint8_t SetMessage(std::string arg2, uint32_t arg3, uint8_t arg4)
	{
		char const* arg2_c_str = arg2.c_str();
		_SetMessage_HrMessage__QAE_NPBDI_N_Z mFunc = (_SetMessage_HrMessage__QAE_NPBDI_N_Z)(GameModule + 0x48aaa0);
		return mFunc(this, arg2_c_str, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::SetMessage(class HrMessage* const this, int32_t DialogIndex, uint32_t arg3, uint8_t arg4) [?SetMessage@HrMessage@@QAE_NHI_N@Z]
	typedef uint8_t(__thiscall* _SetMessage_HrMessage__QAE_NHI_N_Z_2)(class HrMessage* const thisPtr, int32_t DialogIndex, uint32_t arg3, uint8_t arg4);
	uint8_t SetMessage_2(int32_t DialogIndex, uint32_t arg3, uint8_t arg4)
	{
		_SetMessage_HrMessage__QAE_NHI_N_Z_2 mFunc = (_SetMessage_HrMessage__QAE_NHI_N_Z_2)(GameModule + 0x48ac00);
		return mFunc(this, DialogIndex, arg3, arg4);
	}
	// [Function] void __convention("thiscall") HrMessage::_DePause(class HrMessage* const this) [?_DePause@HrMessage@@IAEXXZ]
	typedef void(__thiscall* __DePause_HrMessage__IAEXXZ)(class HrMessage* const thisPtr);
	void _DePause()
	{
		__DePause_HrMessage__IAEXXZ mFunc = (__DePause_HrMessage__IAEXXZ)(GameModule + 0x48ad10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMessage::_Pause(class HrMessage* const this) [?_Pause@HrMessage@@IAEXXZ]
	typedef void(__thiscall* __Pause_HrMessage__IAEXXZ)(class HrMessage* const thisPtr);
	void _Pause()
	{
		__Pause_HrMessage__IAEXXZ mFunc = (__Pause_HrMessage__IAEXXZ)(GameModule + 0x48ad20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::SetFont(class HrMessage* const this, class ghmGcFont* arg2) [?SetFont@HrMessage@@QAE_NPAVghmGcFont@@@Z]
	typedef uint8_t(__thiscall* _SetFont_HrMessage__QAE_NPAVghmGcFont___Z)(class HrMessage* const thisPtr, class ghmGcFont* arg2);
	uint8_t SetFont(class ghmGcFont* arg2)
	{
		_SetFont_HrMessage__QAE_NPAVghmGcFont___Z mFunc = (_SetFont_HrMessage__QAE_NPAVghmGcFont___Z)(GameModule + 0x48ad30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrMessage::_SetPlayTick(class HrMessage* const this, float arg2) [?_SetPlayTick@HrMessage@@IAEXM@Z]
	typedef void(__thiscall* __SetPlayTick_HrMessage__IAEXM_Z)(class HrMessage* const thisPtr, float arg2);
	void _SetPlayTick(float arg2)
	{
		__SetPlayTick_HrMessage__IAEXM_Z mFunc = (__SetPlayTick_HrMessage__IAEXM_Z)(GameModule + 0x48ad80);
		return mFunc(this, arg2);
	}
	// [Function] int32_t HrMessage::GetDialogoNum(uint32_t arg1) [?GetDialogoNum@HrMessage@@SAHI@Z]
	typedef int32_t(__fastcall* _GetDialogoNum_HrMessage__SAHI_Z)(uint32_t arg1);
	static int32_t GetDialogoNum(uint32_t arg1)
	{
		_GetDialogoNum_HrMessage__SAHI_Z mFunc = (_GetDialogoNum_HrMessage__SAHI_Z)(GameModule + 0x48ad90);
		return mFunc(arg1);
	}
	// [Function] uint8_t HrMessage::IsMessage() [?IsMessage@HrMessage@@SA_NXZ]
	typedef uint8_t(__fastcall* _IsMessage_HrMessage__SA_NXZ)();
	static uint8_t IsMessage()
	{
		_IsMessage_HrMessage__SA_NXZ mFunc = (_IsMessage_HrMessage__SA_NXZ)(GameModule + 0x48b0c0);
		return mFunc();
	}
	// [Function] void HrMessage::SetPlayTick(float arg1) [?SetPlayTick@HrMessage@@SAXM@Z]
	typedef void(__fastcall* _SetPlayTick_HrMessage__SAXM_Z)(float arg1);
	static void SetPlayTick(float arg1)
	{
		_SetPlayTick_HrMessage__SAXM_Z mFunc = (_SetPlayTick_HrMessage__SAXM_Z)(GameModule + 0x48b0f0);
		return mFunc(arg1);
	}
	// [Function] void HrMessage::Pause(uint32_t arg1) [?Pause@HrMessage@@SAXI@Z]
	typedef void(__fastcall* _Pause_HrMessage__SAXI_Z)(uint32_t arg1);
	static void Pause(uint32_t arg1)
	{
		_Pause_HrMessage__SAXI_Z mFunc = (_Pause_HrMessage__SAXI_Z)(GameModule + 0x48b110);
		return mFunc(arg1);
	}
	// [Function] void HrMessage::DePause(uint32_t arg1) [?DePause@HrMessage@@SAXI@Z]
	typedef void(__fastcall* _DePause_HrMessage__SAXI_Z)(uint32_t arg1);
	static void DePause(uint32_t arg1)
	{
		_DePause_HrMessage__SAXI_Z mFunc = (_DePause_HrMessage__SAXI_Z)(GameModule + 0x48b140);
		return mFunc(arg1);
	}
	// [Function] uint8_t HrMessage::IsMessageEnd(uint32_t arg1) [?IsMessageEnd@HrMessage@@SA_NI@Z]
	typedef uint8_t(__fastcall* _IsMessageEnd_HrMessage__SA_NI_Z)(uint32_t arg1);
	static uint8_t IsMessageEnd(uint32_t arg1)
	{
		_IsMessageEnd_HrMessage__SA_NI_Z mFunc = (_IsMessageEnd_HrMessage__SA_NI_Z)(GameModule + 0x48b170);
		return mFunc(arg1);
	}
	// [Function] uint32_t HrMessage::Create(void* arg1) [?Create@HrMessage@@SAIPAX@Z]
	typedef uint32_t(__fastcall* _Create_HrMessage__SAIPAX_Z)(void* arg1);
	static uint32_t Create(void* arg1)
	{
		_Create_HrMessage__SAIPAX_Z mFunc = (_Create_HrMessage__SAIPAX_Z)(GameModule + 0x48b1b0);
		return mFunc(arg1);
	}
	// [Function] class HrMessage* HrMessage::GetObjectA(uint32_t arg1) [?GetObjectA@HrMessage@@SAPAV1@I@Z]
	typedef class HrMessage*(__fastcall* _GetObjectA_HrMessage__SAPAV1_I_Z)(uint32_t arg1);
	static class HrMessage* GetObjectA(uint32_t arg1)
	{
		_GetObjectA_HrMessage__SAPAV1_I_Z mFunc = (_GetObjectA_HrMessage__SAPAV1_I_Z)(GameModule + 0x48b220);
		return mFunc(arg1);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::SetFont(class HrMessage* const this, void* arg2) [?SetFont@HrMessage@@QAE_NPAX@Z]
	typedef uint8_t(__thiscall* _SetFont_HrMessage__QAE_NPAX_Z_2)(class HrMessage* const thisPtr, void* arg2);
	uint8_t SetFont_2(void* arg2)
	{
		_SetFont_HrMessage__QAE_NPAX_Z_2 mFunc = (_SetFont_HrMessage__QAE_NPAX_Z_2)(GameModule + 0x48b240);
		return mFunc(this, arg2);
	}
	// [Function] void HrMessage::StartMessage(uint32_t arg1, char const* arg2, uint32_t arg3, uint8_t arg4) [?StartMessage@HrMessage@@SAXIPBDI_N@Z]
	typedef void(__fastcall* _StartMessage_HrMessage__SAXIPBDI_N_Z_2)(uint32_t arg1, char const* arg2, uint32_t arg3, uint8_t arg4);
	static void StartMessage_2(uint32_t arg1, std::string arg2, uint32_t arg3, uint8_t arg4)
	{
		char const* arg2_c_str = arg2.c_str();
		_StartMessage_HrMessage__SAXIPBDI_N_Z_2 mFunc = (_StartMessage_HrMessage__SAXIPBDI_N_Z_2)(GameModule + 0x48b2a0);
		return mFunc(arg1, arg2_c_str, arg3, arg4);
	}
	// [Function] void HrMessage::Stop(uint32_t arg1) [?Stop@HrMessage@@SAXI@Z]
	typedef void(__fastcall* _Stop_HrMessage__SAXI_Z)(uint32_t arg1);
	static void Stop(uint32_t arg1)
	{
		_Stop_HrMessage__SAXI_Z mFunc = (_Stop_HrMessage__SAXI_Z)(GameModule + 0x48b2d0);
		return mFunc(arg1);
	}
	// [Function] void HrMessage::Delete(uint32_t arg1) [?Delete@HrMessage@@SAXI@Z]
	typedef void(__fastcall* _Delete_HrMessage__SAXI_Z)(uint32_t arg1);
	static void Delete(uint32_t arg1)
	{
		_Delete_HrMessage__SAXI_Z mFunc = (_Delete_HrMessage__SAXI_Z)(GameModule + 0x48b310);
		return mFunc(arg1);
	}
	// [Function] class ghmResGroup* HrMessage::GetLangageGroup(class ghmResGroup* pRsl) [?GetLangageGroup@HrMessage@@SAPAVghmResGroup@@PAV2@@Z]
	typedef class ghmResGroup*(__fastcall* _GetLangageGroup_HrMessage__SAPAVghmResGroup__PAV2__Z)(class ghmResGroup* pRsl);
	static class ghmResGroup* GetLangageGroup(class ghmResGroup* pRsl)
	{
		_GetLangageGroup_HrMessage__SAPAVghmResGroup__PAV2__Z mFunc = (_GetLangageGroup_HrMessage__SAPAVghmResGroup__PAV2__Z)(GameModule + 0x48b490);
		return mFunc(pRsl);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMessage [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMessage& InObject)
	{
		m_Anchor = InObject.m_Anchor;
		m_Handle = InObject.m_Handle;
		m_Status = InObject.m_Status;
		mp_Font = InObject.mp_Font;
		m_pFont = InObject.m_pFont;
		mp_Gdl = InObject.mp_Gdl;
		m_NowTick = InObject.m_NowTick;
		m_pCurrentDialog = InObject.m_pCurrentDialog;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMessage, ghmListObj>("HrMessage")
			.addFunction("__tostring", &HrMessage::ToString)
			.addFunction("GetPtrAddr", &HrMessage::GetPtrAddr)
			.addProperty("m_Anchor", &HrMessage::m_Anchor)
			.addProperty("m_Handle", &HrMessage::m_Handle)
			.addProperty("m_Status", &HrMessage::m_Status)
			.addProperty("mp_Font", &HrMessage::mp_Font)
			.addProperty("m_pFont", &HrMessage::m_pFont)
			.addProperty("mp_Gdl", &HrMessage::mp_Gdl)
			.addProperty("m_NowTick", &HrMessage::m_NowTick)
			.addProperty("m_pCurrentDialog", &HrMessage::m_pCurrentDialog)
			.addFunction("_GetFont", &HrMessage::_GetFont)
			.addFunction("_GetStatus", &HrMessage::_GetStatus)
			.addFunction("GetNext", &HrMessage::GetNext)
			.addFunction("_GetGdl", &HrMessage::_GetGdl)
			.addFunction("GetHandle", &HrMessage::GetHandle)
			.addStaticFunction("StartMessage", &HrMessage::StartMessage)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("RenderProcess", &HrMessage::RenderProcess)
			.addFunction("Render", &HrMessage::Render)
			.addFunction("GetDialog", &HrMessage::GetDialog)
			.addFunction("Frame", &HrMessage::Frame)
			.addFunction("DispLine_RenderProcess", &HrMessage::DispLine_RenderProcess)
			.addFunction("DispLine_FrameProcess", &HrMessage::DispLine_FrameProcess)
			// Can't export pointer to native type 'float&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStrLengthW", &HrMessage::GetStrLengthW)
			// Can't export pointer to native type 'int16_t const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStrLengthW_2", &HrMessage::GetStrLengthW_2)
			// Can't export pointer to native type 'float&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStrLengthW_3", &HrMessage::GetStrLengthW_3)
			// Can't export pointer to native type 'float&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStrLength", &HrMessage::GetStrLength)
			// Can't export pointer to native type 'float&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStrLength_2", &HrMessage::GetStrLength_2)
			// Can't export pointer to native type 'uint32_t&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetTick", &HrMessage::GetTick)
			// Can't export pointer to native type 'uint32_t&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetTick_2", &HrMessage::GetTick_2)
			// Can't export pointer to native type 'uint32_t&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("_GetTick", &HrMessage::_GetTick)
			.addStaticFunction("SetFontFuti", &HrMessage::SetFontFuti)
			.addFunction("_SetFontFuti", &HrMessage::_SetFontFuti)
			.addStaticFunction("SetFontEx", &HrMessage::SetFontEx)
			.addFunction("_SetFontEx", &HrMessage::_SetFontEx)
			.addStaticFunction("GetStringsW", &HrMessage::GetStringsW)
			.addStaticFunction("GetStringsW_2", &HrMessage::GetStringsW_2)
			.addStaticFunction("GetStrings", &HrMessage::GetStrings)
			.addStaticFunction("GetStrings_2", &HrMessage::GetStrings_2)
			.addFunction("_GetStringsW", &HrMessage::_GetStringsW)
			.addFunction("_GetStrings", &HrMessage::_GetStrings)
			.addStaticFunction("DispMessage", &HrMessage::DispMessage)
			.addStaticFunction("DispMessage_2", &HrMessage::DispMessage_2)
			.addStaticFunction("GetFont", &HrMessage::GetFont)
			.addStaticFunction("GetGdl", &HrMessage::GetGdl)
			.addStaticFunction("GetSentenceNum", &HrMessage::GetSentenceNum)
			.addStaticFunction("GetSentenceNum_2", &HrMessage::GetSentenceNum_2)
			.addStaticFunction("GetLineNum", &HrMessage::GetLineNum)
			.addStaticFunction("GetLineNum_2", &HrMessage::GetLineNum_2)
			.addFunction("_GetSentenceNum", &HrMessage::_GetSentenceNum)
			.addFunction("_GetLineNum", &HrMessage::_GetLineNum)
			.addFunction("_DispChar", &HrMessage::_DispChar)
			.addFunction("_DispMessage", &HrMessage::_DispMessage)
			.addFunction("_Stop", &HrMessage::_Stop)
			.addFunction("SetMessage", &HrMessage::SetMessage)
			.addFunction("SetMessage_2", &HrMessage::SetMessage_2)
			.addFunction("_DePause", &HrMessage::_DePause)
			.addFunction("_Pause", &HrMessage::_Pause)
			.addFunction("SetFont", &HrMessage::SetFont)
			.addFunction("_SetPlayTick", &HrMessage::_SetPlayTick)
			.addStaticFunction("GetDialogoNum", &HrMessage::GetDialogoNum)
			.addStaticFunction("IsMessage", &HrMessage::IsMessage)
			.addStaticFunction("SetPlayTick", &HrMessage::SetPlayTick)
			.addStaticFunction("Pause", &HrMessage::Pause)
			.addStaticFunction("DePause", &HrMessage::DePause)
			.addStaticFunction("IsMessageEnd", &HrMessage::IsMessageEnd)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &HrMessage::Create)
			.addStaticFunction("GetObjectA", &HrMessage::GetObjectA)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetFont_2", &HrMessage::SetFont_2)
			.addStaticFunction("StartMessage_2", &HrMessage::StartMessage_2)
			.addStaticFunction("Stop", &HrMessage::Stop)
			.addStaticFunction("Delete", &HrMessage::Delete)
			// Can't export delegate 'void (*)(void*)' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("FrameProcess", &HrMessage::FrameProcess)
			.addStaticFunction("GetLangageGroup", &HrMessage::GetLangageGroup)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMessage::m_Anchor) == 16, "expected HrMessage::m_Anchor to be size 16");
static_assert(sizeof(HrMessage::m_Handle) == 4, "expected HrMessage::m_Handle to be size 4");
static_assert(sizeof(HrMessage::m_Status) == 4, "expected HrMessage::m_Status to be size 4");
static_assert(sizeof(HrMessage::mp_Font) == 4, "expected HrMessage::mp_Font to be size 4");
static_assert(sizeof(HrMessage::m_pFont) == 4, "expected HrMessage::m_pFont to be size 4");
static_assert(sizeof(HrMessage::mp_Gdl) == 4, "expected HrMessage::mp_Gdl to be size 4");
static_assert(sizeof(HrMessage::m_NowTick) == 4, "expected HrMessage::m_NowTick to be size 4");
static_assert(sizeof(HrMessage::m_pCurrentDialog) == 4, "expected HrMessage::m_pCurrentDialog to be size 4");
static_assert(sizeof(HrMessage) == 0x3c, "expected HrMessage to be size 0x3c");

// Unsupported operator
//void* __convention("thiscall") HrMessage::`vector deleting destructor'(class HrMessage* const this, uint32_t arg2)
// [Structure] class ghmGcFont
class ghmGcFont
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[104];

public:
	// <struct GXColor Color, offset 0x68>
	struct GXColor Color;

	// <Unidentified data segment, offset 0x6c>
private:
	char _UnidentifiedData_108[2504];

public:
	// <class ghmGcFont* FontPtr, offset 0xa34>
	class ghmGcFont* FontPtr = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmGcFont [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmGcFont& InObject)
	{
		Color = InObject.Color;
		FontPtr = InObject.FontPtr;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcFont>("ghmGcFont")
			.addFunction("__tostring", &ghmGcFont::ToString)
			.addFunction("GetPtrAddr", &ghmGcFont::GetPtrAddr)
			.addProperty("Color", &ghmGcFont::Color)
			.addProperty("FontPtr", &ghmGcFont::FontPtr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcFont::Color) == 4, "expected ghmGcFont::Color to be size 4");
static_assert(sizeof(ghmGcFont::FontPtr) == 4, "expected ghmGcFont::FontPtr to be size 4");
static_assert(sizeof(ghmGcFont) == 0xa38, "expected ghmGcFont to be size 0xa38");

// [Structure] struct GdlDialog
struct GdlDialog
{
public:
	/// Struct member variables

	// <char const* mpName, offset 0x0>
	char const* mpName = nullptr;

	// <uint16_t mLinesCount, offset 0x4>
	uint16_t mLinesCount = 0;

	// <uint16_t mPad0, offset 0x6>
	uint16_t mPad0 = 0;

	// <struct GdlLines** mppLinesPtrTable, offset 0x8>
	struct GdlLines** mppLinesPtrTable = nullptr;

	// <uint32_t mFlag, offset 0xc>
	uint32_t mFlag = 0;

	// <uint32_t mPad[0x4], offset 0x10>
	uint32_t mPad[4];

	/// 1 Functions

	// [Function] struct GdlLines* __convention("thiscall") GdlDialog::GetLines(struct GdlDialog* const this, int32_t arg2) [?GetLines@GdlDialog@@QAEPAUGdlLines@@H@Z]
	typedef struct GdlLines*(__thiscall* _GetLines_GdlDialog__QAEPAUGdlLines__H_Z)(struct GdlDialog* const thisPtr, int32_t arg2);
	struct GdlLines* GetLines(int32_t arg2)
	{
		_GetLines_GdlDialog__QAEPAUGdlLines__H_Z mFunc = (_GetLines_GdlDialog__QAEPAUGdlLines__H_Z)(GameModule + 0xb36e0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct GdlDialog (" << mLinesCount << " lines) [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GdlDialog& InObject)
	{
		mpName = InObject.mpName;
		mLinesCount = InObject.mLinesCount;
		mPad0 = InObject.mPad0;
		mppLinesPtrTable = InObject.mppLinesPtrTable;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GdlDialog>("GdlDialog")
			.addFunction("__tostring", &GdlDialog::ToString)
			.addFunction("GetPtrAddr", &GdlDialog::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpName", &GdlDialog::mpName)
			.addProperty("mLinesCount", &GdlDialog::mLinesCount)
			.addProperty("mPad0", &GdlDialog::mPad0)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppLinesPtrTable", &GdlDialog::mppLinesPtrTable)
			.addProperty("mFlag", &GdlDialog::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &GdlDialog::mPad)
			.addFunction("GetLines", &GdlDialog::GetLines)
		.endClass();
	}
#endif
};
static_assert(sizeof(GdlDialog::mpName) == 4, "expected GdlDialog::mpName to be size 4");
static_assert(sizeof(GdlDialog::mLinesCount) == 2, "expected GdlDialog::mLinesCount to be size 2");
static_assert(sizeof(GdlDialog::mPad0) == 2, "expected GdlDialog::mPad0 to be size 2");
static_assert(sizeof(GdlDialog::mppLinesPtrTable) == 4, "expected GdlDialog::mppLinesPtrTable to be size 4");
static_assert(sizeof(GdlDialog::mFlag) == 4, "expected GdlDialog::mFlag to be size 4");
static_assert(sizeof(GdlDialog::mPad) == 16, "expected GdlDialog::mPad to be size 16");
static_assert(sizeof(GdlDialog) == 0x20, "expected GdlDialog to be size 0x20");

// [Structure] struct GdlHeader
struct GdlHeader
{
public:
	/// Struct member variables

	// <uint32_t mID, offset 0x0>
	uint32_t mID = 0;

	// <uint32_t mVersion, offset 0x4>
	uint32_t mVersion = 0;

	// <uint16_t mDialogCount, offset 0x8>
	uint16_t mDialogCount = 0;

	// <uint16_t mStringCount, offset 0xa>
	uint16_t mStringCount = 0;

	// <uint32_t mDialogPtr, offset 0xc>
	uint32_t mDialogPtr = 0;

	// <struct GdlDialog** mppDialogPtrTable, offset 0x10>
	struct GdlDialog** mppDialogPtrTable = nullptr;

	// <uint32_t mStringPtr, offset 0x14>
	uint32_t mStringPtr = 0;

	// <char const** mppStringPtrTable, offset 0x18>
	char const** mppStringPtrTable = nullptr;

	// <uint32_t mFlag, offset 0x1c>
	uint32_t mFlag = 0;

	// <uint16_t mFacialAnimCount, offset 0x20>
	uint16_t mFacialAnimCount = 0;

	// <uint16_t mStringUcCount, offset 0x22>
	uint16_t mStringUcCount = 0;

	// <uint32_t mFacialAnimPtr, offset 0x24>
	uint32_t mFacialAnimPtr = 0;

	// <void** mppFacialAnimPtrTable, offset 0x28>
	void** mppFacialAnimPtrTable = nullptr;

	// <uint32_t mStringUcPtr, offset 0x2c>
	uint32_t mStringUcPtr = 0;

	// <int16_t const** mppStringUcPtrTable, offset 0x30>
	int16_t const** mppStringUcPtrTable = nullptr;

	// <uint32_t mPad[0x3], offset 0x34>
	uint32_t mPad[3];

	/// 0 Functions

	/// Meta

	struct GdlDialog* GetDialog(int32_t idx) { return (idx >= 0 && idx < mDialogCount) ? mppDialogPtrTable[idx] : nullptr; }
	std::string ToString() const { std::stringstream stream; stream << "struct GdlHeader (" << mDialogCount << " dialogues) [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GdlHeader& InObject)
	{
		mID = InObject.mID;
		mVersion = InObject.mVersion;
		mDialogCount = InObject.mDialogCount;
		mStringCount = InObject.mStringCount;
		mDialogPtr = InObject.mDialogPtr;
		mppDialogPtrTable = InObject.mppDialogPtrTable;
		mStringPtr = InObject.mStringPtr;
		mppStringPtrTable = InObject.mppStringPtrTable;
		mFlag = InObject.mFlag;
		mFacialAnimCount = InObject.mFacialAnimCount;
		mStringUcCount = InObject.mStringUcCount;
		mFacialAnimPtr = InObject.mFacialAnimPtr;
		mppFacialAnimPtrTable = InObject.mppFacialAnimPtrTable;
		mStringUcPtr = InObject.mStringUcPtr;
		mppStringUcPtrTable = InObject.mppStringUcPtrTable;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GdlHeader>("GdlHeader")
			.addFunction("__tostring", &GdlHeader::ToString)
			.addFunction("GetPtrAddr", &GdlHeader::GetPtrAddr)
			.addProperty("mID", &GdlHeader::mID)
			.addProperty("mVersion", &GdlHeader::mVersion)
			.addProperty("mDialogCount", &GdlHeader::mDialogCount)
			.addProperty("mStringCount", &GdlHeader::mStringCount)
			.addProperty("mDialogPtr", &GdlHeader::mDialogPtr)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppDialogPtrTable", &GdlHeader::mppDialogPtrTable)
			.addProperty("mStringPtr", &GdlHeader::mStringPtr)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppStringPtrTable", &GdlHeader::mppStringPtrTable)
			.addProperty("mFlag", &GdlHeader::mFlag)
			.addProperty("mFacialAnimCount", &GdlHeader::mFacialAnimCount)
			.addProperty("mStringUcCount", &GdlHeader::mStringUcCount)
			.addProperty("mFacialAnimPtr", &GdlHeader::mFacialAnimPtr)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppFacialAnimPtrTable", &GdlHeader::mppFacialAnimPtrTable)
			.addProperty("mStringUcPtr", &GdlHeader::mStringUcPtr)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppStringUcPtrTable", &GdlHeader::mppStringUcPtrTable)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &GdlHeader::mPad)
			.addFunction("GetDialog", &GdlHeader::GetDialog)
		.endClass();
	}
#endif
};
static_assert(sizeof(GdlHeader::mID) == 4, "expected GdlHeader::mID to be size 4");
static_assert(sizeof(GdlHeader::mVersion) == 4, "expected GdlHeader::mVersion to be size 4");
static_assert(sizeof(GdlHeader::mDialogCount) == 2, "expected GdlHeader::mDialogCount to be size 2");
static_assert(sizeof(GdlHeader::mStringCount) == 2, "expected GdlHeader::mStringCount to be size 2");
static_assert(sizeof(GdlHeader::mDialogPtr) == 4, "expected GdlHeader::mDialogPtr to be size 4");
static_assert(sizeof(GdlHeader::mppDialogPtrTable) == 4, "expected GdlHeader::mppDialogPtrTable to be size 4");
static_assert(sizeof(GdlHeader::mStringPtr) == 4, "expected GdlHeader::mStringPtr to be size 4");
static_assert(sizeof(GdlHeader::mppStringPtrTable) == 4, "expected GdlHeader::mppStringPtrTable to be size 4");
static_assert(sizeof(GdlHeader::mFlag) == 4, "expected GdlHeader::mFlag to be size 4");
static_assert(sizeof(GdlHeader::mFacialAnimCount) == 2, "expected GdlHeader::mFacialAnimCount to be size 2");
static_assert(sizeof(GdlHeader::mStringUcCount) == 2, "expected GdlHeader::mStringUcCount to be size 2");
static_assert(sizeof(GdlHeader::mFacialAnimPtr) == 4, "expected GdlHeader::mFacialAnimPtr to be size 4");
static_assert(sizeof(GdlHeader::mppFacialAnimPtrTable) == 4, "expected GdlHeader::mppFacialAnimPtrTable to be size 4");
static_assert(sizeof(GdlHeader::mStringUcPtr) == 4, "expected GdlHeader::mStringUcPtr to be size 4");
static_assert(sizeof(GdlHeader::mppStringUcPtrTable) == 4, "expected GdlHeader::mppStringUcPtrTable to be size 4");
static_assert(sizeof(GdlHeader::mPad) == 12, "expected GdlHeader::mPad to be size 12");
static_assert(sizeof(GdlHeader) == 0x40, "expected GdlHeader to be size 0x40");

// [Structure] class WGdl
class WGdl : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <int32_t mState, offset 0x10>
	int32_t mState = 0;

	// <int32_t mLoadState, offset 0x14>
	int32_t mLoadState = 0;

	// <uint32_t mFlag, offset 0x18>
	uint32_t mFlag = 0;

	// <uint8_t mEidian, offset 0x1c>
	uint8_t mEidian = 0;

	// <Unidentified data segment, offset 0x1d>
private:
	char _UnidentifiedData_29[3];

public:
	// <class ghmGcFile* pLoadFilePtr, offset 0x20>
	class ghmGcFile* pLoadFilePtr = nullptr;

	// <int32_t LoadFileID, offset 0x24>
	int32_t LoadFileID = 0;

	// <int32_t LoadID, offset 0x28>
	int32_t LoadID = 0;

	// <struct GdlHeader* mpData, offset 0x2c>
	struct GdlHeader* mpData = nullptr;

	// <uint32_t mTime, offset 0x30>
	uint32_t mTime = 0;

	// <int32_t mDialogID, offset 0x34>
	int32_t mDialogID = 0;

	// <struct GdlDialog* mpDialog, offset 0x38>
	struct GdlDialog* mpDialog = nullptr;

	// <int32_t mLinesID, offset 0x3c>
	int32_t mLinesID = 0;

	// <struct GdlLines* mpLines, offset 0x40>
	struct GdlLines* mpLines = nullptr;

	/// 31 Functions

	// [Function] class WGdl* WGdl::GetTop() [?GetTop@WGdl@@KAPAV1@XZ]
	typedef class WGdl*(__fastcall* _GetTop_WGdl__KAPAV1_XZ)();
	static class WGdl* GetTop()
	{
		_GetTop_WGdl__KAPAV1_XZ mFunc = (_GetTop_WGdl__KAPAV1_XZ)(GameModule + 0xebc90);
		return mFunc();
	}
	// [Function] class WGdl* __convention("thiscall") WGdl::GetNext(class WGdl* const this) [?GetNext@WGdl@@QAEPAV1@XZ]
	typedef class WGdl*(__thiscall* _GetNext_WGdl__QAEPAV1_XZ)(class WGdl* const thisPtr);
	class WGdl* GetNext()
	{
		_GetNext_WGdl__QAEPAV1_XZ mFunc = (_GetNext_WGdl__QAEPAV1_XZ)(GameModule + 0xebca0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") WGdl::GetStringUcCount(class WGdl* const this) [?GetStringUcCount@WGdl@@QAEHXZ]
	typedef int32_t(__thiscall* _GetStringUcCount_WGdl__QAEHXZ)(class WGdl* const thisPtr);
	int32_t GetStringUcCount()
	{
		_GetStringUcCount_WGdl__QAEHXZ mFunc = (_GetStringUcCount_WGdl__QAEHXZ)(GameModule + 0x6e4ef0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") WGdl::GetStringCount(class WGdl* const this) [?GetStringCount@WGdl@@QAEHXZ]
	typedef int32_t(__thiscall* _GetStringCount_WGdl__QAEHXZ)(class WGdl* const thisPtr);
	int32_t GetStringCount()
	{
		_GetStringCount_WGdl__QAEHXZ mFunc = (_GetStringCount_WGdl__QAEHXZ)(GameModule + 0x6e4f20);
		return mFunc(this);
	}
	// [Function] int16_t const* __convention("thiscall") WGdl::GetStringUc(class WGdl* const this, int32_t arg2, struct GdlHeader* arg3) [?GetStringUc@WGdl@@IAEPB_SHPAUGdlHeader@@@Z]
	typedef int16_t const*(__thiscall* _GetStringUc_WGdl__IAEPB_SHPAUGdlHeader___Z)(class WGdl* const thisPtr, int32_t arg2, struct GdlHeader* arg3);
	// Can't export pointer to native type 'int16_t const*' [TypeClass.PointerTypeClass] in LuaBridge
	void GetStringUc(int32_t arg2, struct GdlHeader* arg3)
	{
		_GetStringUc_WGdl__IAEPB_SHPAUGdlHeader___Z mFunc = (_GetStringUc_WGdl__IAEPB_SHPAUGdlHeader___Z)(GameModule + 0x6e4f40);
		mFunc(this, arg2, arg3);
	}
	// [Function] char const* __convention("thiscall") WGdl::GetString(class WGdl* const this, int32_t arg2, struct GdlHeader* arg3) [?GetString@WGdl@@IAEPBDHPAUGdlHeader@@@Z]
	typedef char const*(__thiscall* _GetString_WGdl__IAEPBDHPAUGdlHeader___Z)(class WGdl* const thisPtr, int32_t arg2, struct GdlHeader* arg3);
	std::string GetString(int32_t arg2, struct GdlHeader* arg3)
	{
		_GetString_WGdl__IAEPBDHPAUGdlHeader___Z mFunc = (_GetString_WGdl__IAEPBDHPAUGdlHeader___Z)(GameModule + 0x6e4f70);
		char const* OutResult = mFunc(this, arg2, arg3);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] wchar_t const* __convention("thiscall") WGdl::GetStringUc(class WGdl* const this, int32_t arg2) [?GetStringUc@WGdl@@QAEPB_SH@Z]
	typedef wchar_t const*(__thiscall* _GetStringUc_WGdl__QAEPB_SH_Z_2)(class WGdl* const thisPtr, int32_t arg2);
	std::string GetStringUc_2(int32_t arg2)
	{
		_GetStringUc_WGdl__QAEPB_SH_Z_2 mFunc = (_GetStringUc_WGdl__QAEPB_SH_Z_2)(GameModule + 0x6e4fa0);
		wchar_t const* OutResult = mFunc(this, arg2);
		if (OutResult == nullptr) return std::string();
		std::wstring result_wstr(OutResult);
		std::string result_str(result_wstr.length(), 0);
		std::transform(result_wstr.begin(), result_wstr.end(), result_str.begin(), [](wchar_t c) { return (char)c; });
		return result_str;
	}
	// [Function] char const* __convention("thiscall") WGdl::GetString(class WGdl* const this, int32_t arg2) [?GetString@WGdl@@QAEPBDH@Z]
	typedef char const*(__thiscall* _GetString_WGdl__QAEPBDH_Z_2)(class WGdl* const thisPtr, int32_t arg2);
	std::string GetString_2(int32_t arg2)
	{
		_GetString_WGdl__QAEPBDH_Z_2 mFunc = (_GetString_WGdl__QAEPBDH_Z_2)(GameModule + 0x6e4fe0);
		char const* OutResult = mFunc(this, arg2);
		if (OutResult == nullptr) return std::string();
		std::string result_str(OutResult);
		return result_str;
	}
	// [Function] struct GdlHeader* __convention("thiscall") WGdl::GetHeader(class WGdl* const this) [?GetHeader@WGdl@@QAEPAUGdlHeader@@XZ]
	typedef struct GdlHeader*(__thiscall* _GetHeader_WGdl__QAEPAUGdlHeader__XZ)(class WGdl* const thisPtr);
	struct GdlHeader* GetHeader()
	{
		_GetHeader_WGdl__QAEPAUGdlHeader__XZ mFunc = (_GetHeader_WGdl__QAEPAUGdlHeader__XZ)(GameModule + 0x6e5010);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") WGdl::PreProcess(class WGdl* const this) [?PreProcess@WGdl@@IAEHXZ]
	typedef int32_t(__thiscall* _PreProcess_WGdl__IAEHXZ)(class WGdl* const thisPtr);
	int32_t PreProcess()
	{
		_PreProcess_WGdl__IAEHXZ mFunc = (_PreProcess_WGdl__IAEHXZ)(GameModule + 0x6e5020);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") WGdl::PreProcess(class WGdl* const this, struct GdlDialog* arg2) [?PreProcess@WGdl@@IAEHPAUGdlDialog@@@Z]
	typedef int32_t(__thiscall* _PreProcess_WGdl__IAEHPAUGdlDialog___Z_2)(class WGdl* const thisPtr, struct GdlDialog* arg2);
	int32_t PreProcess_2(struct GdlDialog* arg2)
	{
		_PreProcess_WGdl__IAEHPAUGdlDialog___Z_2 mFunc = (_PreProcess_WGdl__IAEHPAUGdlDialog___Z_2)(GameModule + 0x6e5780);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") WGdl::PreProcess(class WGdl* const this, struct GdlLines* arg2) [?PreProcess@WGdl@@IAEHPAUGdlLines@@@Z]
	typedef int32_t(__thiscall* _PreProcess_WGdl__IAEHPAUGdlLines___Z_3)(class WGdl* const thisPtr, struct GdlLines* arg2);
	int32_t PreProcess_3(struct GdlLines* arg2)
	{
		_PreProcess_WGdl__IAEHPAUGdlLines___Z_3 mFunc = (_PreProcess_WGdl__IAEHPAUGdlLines___Z_3)(GameModule + 0x6e59e0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") WGdl::PreProcess(class WGdl* const this, struct GdlSentence* arg2) [?PreProcess@WGdl@@IAEHPAUGdlSentence@@@Z]
	typedef int32_t(__thiscall* _PreProcess_WGdl__IAEHPAUGdlSentence___Z_4)(class WGdl* const thisPtr, struct GdlSentence* arg2);
	int32_t PreProcess_4(struct GdlSentence* arg2)
	{
		_PreProcess_WGdl__IAEHPAUGdlSentence___Z_4 mFunc = (_PreProcess_WGdl__IAEHPAUGdlSentence___Z_4)(GameModule + 0x6e5ce0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::FrameProcess(class WGdl* const this) [?FrameProcess@WGdl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _FrameProcess_WGdl__QAE_NXZ)(class WGdl* const thisPtr);
	uint8_t FrameProcess()
	{
		_FrameProcess_WGdl__QAE_NXZ mFunc = (_FrameProcess_WGdl__QAE_NXZ)(GameModule + 0x6e5ec0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::FrameProcess(class WGdl* const this, struct GdlDialog* arg2) [?FrameProcess@WGdl@@IAE_NPAUGdlDialog@@@Z]
	typedef uint8_t(__thiscall* _FrameProcess_WGdl__IAE_NPAUGdlDialog___Z_2)(class WGdl* const thisPtr, struct GdlDialog* arg2);
	uint8_t FrameProcess_2(struct GdlDialog* arg2)
	{
		_FrameProcess_WGdl__IAE_NPAUGdlDialog___Z_2 mFunc = (_FrameProcess_WGdl__IAE_NPAUGdlDialog___Z_2)(GameModule + 0x6e6040);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t WGdl::FrameProcessAll() [?FrameProcessAll@WGdl@@SA_NXZ]
	typedef uint8_t(__fastcall* _FrameProcessAll_WGdl__SA_NXZ)();
	static uint8_t FrameProcessAll()
	{
		_FrameProcessAll_WGdl__SA_NXZ mFunc = (_FrameProcessAll_WGdl__SA_NXZ)(GameModule + 0x6e60c0);
		return mFunc();
	}
	// [Function] uint8_t __convention("thiscall") WGdl::IsRunning(class WGdl* const this) [?IsRunning@WGdl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _IsRunning_WGdl__QAE_NXZ)(class WGdl* const thisPtr);
	uint8_t IsRunning()
	{
		_IsRunning_WGdl__QAE_NXZ mFunc = (_IsRunning_WGdl__QAE_NXZ)(GameModule + 0x6e6240);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Stop(class WGdl* const this) [?Stop@WGdl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _Stop_WGdl__QAE_NXZ)(class WGdl* const thisPtr);
	uint8_t Stop()
	{
		_Stop_WGdl__QAE_NXZ mFunc = (_Stop_WGdl__QAE_NXZ)(GameModule + 0x6e6260);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Resume(class WGdl* const this) [?Resume@WGdl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _Resume_WGdl__QAE_NXZ)(class WGdl* const thisPtr);
	uint8_t Resume()
	{
		_Resume_WGdl__QAE_NXZ mFunc = (_Resume_WGdl__QAE_NXZ)(GameModule + 0x6e6280);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Pause(class WGdl* const this) [?Pause@WGdl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _Pause_WGdl__QAE_NXZ)(class WGdl* const thisPtr);
	uint8_t Pause()
	{
		_Pause_WGdl__QAE_NXZ mFunc = (_Pause_WGdl__QAE_NXZ)(GameModule + 0x6e6290);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Start(class WGdl* const this, int32_t arg2) [?Start@WGdl@@QAE_NH@Z]
	typedef uint8_t(__thiscall* _Start_WGdl__QAE_NH_Z)(class WGdl* const thisPtr, int32_t arg2);
	uint8_t Start(int32_t arg2)
	{
		_Start_WGdl__QAE_NH_Z mFunc = (_Start_WGdl__QAE_NH_Z)(GameModule + 0x6e62a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Start(class WGdl* const this, char const* arg2) [?Start@WGdl@@QAE_NPBD@Z]
	typedef uint8_t(__thiscall* _Start_WGdl__QAE_NPBD_Z_2)(class WGdl* const thisPtr, char const* arg2);
	uint8_t Start_2(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_Start_WGdl__QAE_NPBD_Z_2 mFunc = (_Start_WGdl__QAE_NPBD_Z_2)(GameModule + 0x6e62f0);
		return mFunc(this, arg2_c_str);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Release(class WGdl* const this) [?Release@WGdl@@QAE_NXZ]
	typedef uint8_t(__thiscall* _Release_WGdl__QAE_NXZ)(class WGdl* const thisPtr);
	uint8_t Release()
	{
		_Release_WGdl__QAE_NXZ mFunc = (_Release_WGdl__QAE_NXZ)(GameModule + 0x6e63b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Load(class WGdl* const this, class ghmGcFile* arg2, int32_t arg3) [?Load@WGdl@@QAE_NPAVghmGcFile@@H@Z]
	typedef uint8_t(__thiscall* _Load_WGdl__QAE_NPAVghmGcFile__H_Z)(class WGdl* const thisPtr, class ghmGcFile* arg2, int32_t arg3);
	uint8_t Load(class ghmGcFile* arg2, int32_t arg3)
	{
		_Load_WGdl__QAE_NPAVghmGcFile__H_Z mFunc = (_Load_WGdl__QAE_NPAVghmGcFile__H_Z)(GameModule + 0x6e63f0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Terminate(class WGdl* const this) [?Terminate@WGdl@@UAE_NXZ]
	typedef uint8_t(__thiscall* _Terminate_WGdl__UAE_NXZ)(class WGdl* const thisPtr);
	uint8_t Terminate()
	{
		_Terminate_WGdl__UAE_NXZ mFunc = (_Terminate_WGdl__UAE_NXZ)(GameModule + 0x6e6440);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Initialize(class WGdl* const this) [?Initialize@WGdl@@UAE_NXZ]
	typedef uint8_t(__thiscall* _Initialize_WGdl__UAE_NXZ)(class WGdl* const thisPtr);
	uint8_t Initialize()
	{
		_Initialize_WGdl__UAE_NXZ mFunc = (_Initialize_WGdl__UAE_NXZ)(GameModule + 0x6e6470);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") WGdl::Load(class WGdl* const this, void* arg2) [?Load@WGdl@@QAE_NPAX@Z]
	typedef uint8_t(__thiscall* _Load_WGdl__QAE_NPAX_Z_2)(class WGdl* const thisPtr, void* arg2);
	uint8_t Load_2(void* arg2)
	{
		_Load_WGdl__QAE_NPAX_Z_2 mFunc = (_Load_WGdl__QAE_NPAX_Z_2)(GameModule + 0x6e65c0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") WGdl::GetDialogCount(class WGdl* const this) [?GetDialogCount@WGdl@@QAEHXZ]
	typedef int32_t(__thiscall* _GetDialogCount_WGdl__QAEHXZ)(class WGdl* const thisPtr);
	int32_t GetDialogCount()
	{
		_GetDialogCount_WGdl__QAEHXZ mFunc = (_GetDialogCount_WGdl__QAEHXZ)(GameModule + 0x6e6630);
		return mFunc(this);
	}
	// [Function] struct GdlDialog* __convention("thiscall") WGdl::GetDialog(class WGdl* const this, int32_t arg2) [?GetDialog@WGdl@@QAEPAUGdlDialog@@H@Z]
	typedef struct GdlDialog*(__thiscall* _GetDialog_WGdl__QAEPAUGdlDialog__H_Z)(class WGdl* const thisPtr, int32_t arg2);
	struct GdlDialog* GetDialog(int32_t arg2)
	{
		_GetDialog_WGdl__QAEPAUGdlDialog__H_Z mFunc = (_GetDialog_WGdl__QAEPAUGdlDialog__H_Z)(GameModule + 0x6e6650);
		return mFunc(this, arg2);
	}
	// [Function] struct GdlDialog* __convention("thiscall") WGdl::GetDialog(class WGdl* const this, char const* arg2) [?GetDialog@WGdl@@QAEPAUGdlDialog@@PBD@Z]
	typedef struct GdlDialog*(__thiscall* _GetDialog_WGdl__QAEPAUGdlDialog__PBD_Z_2)(class WGdl* const thisPtr, char const* arg2);
	struct GdlDialog* GetDialog_2(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		_GetDialog_WGdl__QAEPAUGdlDialog__PBD_Z_2 mFunc = (_GetDialog_WGdl__QAEPAUGdlDialog__PBD_Z_2)(GameModule + 0x6e6680);
		return mFunc(this, arg2_c_str);
	}
	// [Function] int32_t __convention("thiscall") WGdl::GetDialogIndex(class WGdl* const this, char const* StringToFind) [?GetDialogIndex@WGdl@@QAEHPBD@Z]
	typedef int32_t(__thiscall* _GetDialogIndex_WGdl__QAEHPBD_Z)(class WGdl* const thisPtr, char const* StringToFind);
	int32_t GetDialogIndex(std::string StringToFind)
	{
		char const* StringToFind_c_str = StringToFind.c_str();
		_GetDialogIndex_WGdl__QAEHPBD_Z mFunc = (_GetDialogIndex_WGdl__QAEHPBD_Z)(GameModule + 0x6e6710);
		return mFunc(this, StringToFind_c_str);
	}
	/// Meta

	WGdl()
	{
	LoadFileID = -1;
	LoadID = -1;
	mDialogID = -1;
	mLinesID = -1;
	mLoadState = 2;
	mPriority = 256;
	mState = 1;
	}
	std::string ToString() const { std::stringstream stream; stream << "class WGdl (Header: " << (mpData ? mpData->ToString() : std::string("nullptr")) << ") [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(WGdl& InObject)
	{
		mState = InObject.mState;
		mLoadState = InObject.mLoadState;
		mFlag = InObject.mFlag;
		mEidian = InObject.mEidian;
		pLoadFilePtr = InObject.pLoadFilePtr;
		LoadFileID = InObject.LoadFileID;
		LoadID = InObject.LoadID;
		mpData = InObject.mpData;
		mTime = InObject.mTime;
		mDialogID = InObject.mDialogID;
		mpDialog = InObject.mpDialog;
		mLinesID = InObject.mLinesID;
		mpLines = InObject.mpLines;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<WGdl, ghmListObj>("WGdl")
			.addFunction("__tostring", &WGdl::ToString)
			.addFunction("GetPtrAddr", &WGdl::GetPtrAddr)
			.addProperty("mState", &WGdl::mState)
			.addProperty("mLoadState", &WGdl::mLoadState)
			.addProperty("mFlag", &WGdl::mFlag)
			.addProperty("mEidian", &WGdl::mEidian)
			.addProperty("pLoadFilePtr", &WGdl::pLoadFilePtr)
			.addProperty("LoadFileID", &WGdl::LoadFileID)
			.addProperty("LoadID", &WGdl::LoadID)
			.addProperty("mpData", &WGdl::mpData)
			.addProperty("mTime", &WGdl::mTime)
			.addProperty("mDialogID", &WGdl::mDialogID)
			.addProperty("mpDialog", &WGdl::mpDialog)
			.addProperty("mLinesID", &WGdl::mLinesID)
			.addProperty("mpLines", &WGdl::mpLines)
			.addStaticFunction("GetTop", &WGdl::GetTop)
			.addFunction("GetNext", &WGdl::GetNext)
			.addFunction("GetStringUcCount", &WGdl::GetStringUcCount)
			.addFunction("GetStringCount", &WGdl::GetStringCount)
			.addFunction("GetStringUc", &WGdl::GetStringUc)
			.addFunction("GetString", &WGdl::GetString)
			.addFunction("GetStringUc_2", &WGdl::GetStringUc_2)
			.addFunction("GetString_2", &WGdl::GetString_2)
			.addFunction("GetHeader", &WGdl::GetHeader)
			.addFunction("PreProcess", &WGdl::PreProcess)
			.addFunction("PreProcess_2", &WGdl::PreProcess_2)
			.addFunction("PreProcess_3", &WGdl::PreProcess_3)
			.addFunction("PreProcess_4", &WGdl::PreProcess_4)
			.addFunction("FrameProcess", &WGdl::FrameProcess)
			.addFunction("FrameProcess_2", &WGdl::FrameProcess_2)
			.addStaticFunction("FrameProcessAll", &WGdl::FrameProcessAll)
			.addFunction("IsRunning", &WGdl::IsRunning)
			.addFunction("Stop", &WGdl::Stop)
			.addFunction("Resume", &WGdl::Resume)
			.addFunction("Pause", &WGdl::Pause)
			.addFunction("Start", &WGdl::Start)
			.addFunction("Start_2", &WGdl::Start_2)
			.addFunction("Release", &WGdl::Release)
			.addFunction("Load", &WGdl::Load)
			.addFunction("Terminate", &WGdl::Terminate)
			.addFunction("Initialize", &WGdl::Initialize)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("Load_2", &WGdl::Load_2)
			.addFunction("GetDialogCount", &WGdl::GetDialogCount)
			.addFunction("GetDialog", &WGdl::GetDialog)
			.addFunction("GetDialog_2", &WGdl::GetDialog_2)
			.addFunction("GetDialogIndex", &WGdl::GetDialogIndex)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGdl::mState) == 4, "expected WGdl::mState to be size 4");
static_assert(sizeof(WGdl::mLoadState) == 4, "expected WGdl::mLoadState to be size 4");
static_assert(sizeof(WGdl::mFlag) == 4, "expected WGdl::mFlag to be size 4");
static_assert(sizeof(WGdl::mEidian) == 1, "expected WGdl::mEidian to be size 1");
static_assert(sizeof(WGdl::pLoadFilePtr) == 4, "expected WGdl::pLoadFilePtr to be size 4");
static_assert(sizeof(WGdl::LoadFileID) == 4, "expected WGdl::LoadFileID to be size 4");
static_assert(sizeof(WGdl::LoadID) == 4, "expected WGdl::LoadID to be size 4");
static_assert(sizeof(WGdl::mpData) == 4, "expected WGdl::mpData to be size 4");
static_assert(sizeof(WGdl::mTime) == 4, "expected WGdl::mTime to be size 4");
static_assert(sizeof(WGdl::mDialogID) == 4, "expected WGdl::mDialogID to be size 4");
static_assert(sizeof(WGdl::mpDialog) == 4, "expected WGdl::mpDialog to be size 4");
static_assert(sizeof(WGdl::mLinesID) == 4, "expected WGdl::mLinesID to be size 4");
static_assert(sizeof(WGdl::mpLines) == 4, "expected WGdl::mpLines to be size 4");
static_assert(sizeof(WGdl) == 0x44, "expected WGdl to be size 0x44");

// [Structure] struct GdlLines
struct GdlLines
{
public:
	/// Struct member variables

	// <int16_t mVoiceID, offset 0x0>
	int16_t mVoiceID = 0;

	// <uint16_t mSentenceCount, offset 0x2>
	uint16_t mSentenceCount = 0;

	// <struct GdlSentence** mppSentencePtrTable, offset 0x4>
	struct GdlSentence** mppSentencePtrTable = nullptr;

	// <uint32_t mStartTick, offset 0x8>
	uint32_t mStartTick = 0;

	// <uint32_t mWaitTick, offset 0xc>
	uint32_t mWaitTick = 0;

	// <uint32_t mFlag, offset 0x10>
	uint32_t mFlag = 0;

	// <char const* mpCharaName, offset 0x14>
	char const* mpCharaName = nullptr;

	// <void* mpFacialAnim, offset 0x18>
	void* mpFacialAnim = nullptr;

	// <uint32_t mPad[0x1], offset 0x1c>
	uint32_t mPad[1];

	/// 1 Functions

	// [Function] struct GdlSentence* __convention("thiscall") GdlLines::GetSentence(struct GdlLines* const this, int32_t arg2) [?GetSentence@GdlLines@@QAEPAUGdlSentence@@H@Z]
	typedef struct GdlSentence*(__thiscall* _GetSentence_GdlLines__QAEPAUGdlSentence__H_Z)(struct GdlLines* const thisPtr, int32_t arg2);
	struct GdlSentence* GetSentence(int32_t arg2)
	{
		_GetSentence_GdlLines__QAEPAUGdlSentence__H_Z mFunc = (_GetSentence_GdlLines__QAEPAUGdlSentence__H_Z)(GameModule + 0xb36b0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct GdlLines (" << mSentenceCount << " sentences) [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GdlLines& InObject)
	{
		mVoiceID = InObject.mVoiceID;
		mSentenceCount = InObject.mSentenceCount;
		mppSentencePtrTable = InObject.mppSentencePtrTable;
		mStartTick = InObject.mStartTick;
		mWaitTick = InObject.mWaitTick;
		mFlag = InObject.mFlag;
		mpCharaName = InObject.mpCharaName;
		mpFacialAnim = InObject.mpFacialAnim;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GdlLines>("GdlLines")
			.addFunction("__tostring", &GdlLines::ToString)
			.addFunction("GetPtrAddr", &GdlLines::GetPtrAddr)
			.addProperty("mVoiceID", &GdlLines::mVoiceID)
			.addProperty("mSentenceCount", &GdlLines::mSentenceCount)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppSentencePtrTable", &GdlLines::mppSentencePtrTable)
			.addProperty("mStartTick", &GdlLines::mStartTick)
			.addProperty("mWaitTick", &GdlLines::mWaitTick)
			.addProperty("mFlag", &GdlLines::mFlag)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpCharaName", &GdlLines::mpCharaName)
			// void type not supported in LuaBridge
			//.addProperty("mpFacialAnim", &GdlLines::mpFacialAnim)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &GdlLines::mPad)
			.addFunction("GetSentence", &GdlLines::GetSentence)
		.endClass();
	}
#endif
};
static_assert(sizeof(GdlLines::mVoiceID) == 2, "expected GdlLines::mVoiceID to be size 2");
static_assert(sizeof(GdlLines::mSentenceCount) == 2, "expected GdlLines::mSentenceCount to be size 2");
static_assert(sizeof(GdlLines::mppSentencePtrTable) == 4, "expected GdlLines::mppSentencePtrTable to be size 4");
static_assert(sizeof(GdlLines::mStartTick) == 4, "expected GdlLines::mStartTick to be size 4");
static_assert(sizeof(GdlLines::mWaitTick) == 4, "expected GdlLines::mWaitTick to be size 4");
static_assert(sizeof(GdlLines::mFlag) == 4, "expected GdlLines::mFlag to be size 4");
static_assert(sizeof(GdlLines::mpCharaName) == 4, "expected GdlLines::mpCharaName to be size 4");
static_assert(sizeof(GdlLines::mpFacialAnim) == 4, "expected GdlLines::mpFacialAnim to be size 4");
static_assert(sizeof(GdlLines::mPad) == 4, "expected GdlLines::mPad to be size 4");
static_assert(sizeof(GdlLines) == 0x20, "expected GdlLines to be size 0x20");

// [Structure] struct GdlSentence
struct GdlSentence
{
public:
	/// Struct member variables

	// <wchar_t const* mpLettersUc, offset 0x0>
	wchar_t const* mpLettersUc = nullptr;

	// <uint32_t mFlag, offset 0x4>
	uint32_t mFlag = 0;

	// <uint32_t mPad[0x2], offset 0x8>
	uint32_t mPad[2];

	/// 0 Functions

	/// Meta

	std::string GetLetters() const { if (mpLettersUc == nullptr) return std::string(); std::wstring result_wstr(mpLettersUc); std::string result_str(result_wstr.length(), 0); std::transform(result_wstr.begin(), result_wstr.end(), result_str.begin(), [](wchar_t c) { return (char)c; }); return result_str; }
	std::string ToString() const { std::stringstream stream; stream << "struct GdlSentence (" << GetLetters() << ") [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GdlSentence& InObject)
	{
		mpLettersUc = InObject.mpLettersUc;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GdlSentence>("GdlSentence")
			.addFunction("__tostring", &GdlSentence::ToString)
			.addFunction("GetPtrAddr", &GdlSentence::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpLettersUc", &GdlSentence::mpLettersUc)
			.addProperty("mFlag", &GdlSentence::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &GdlSentence::mPad)
			.addFunction("GetLetters", &GdlSentence::GetLetters)
		.endClass();
	}
#endif
};
static_assert(sizeof(GdlSentence::mpLettersUc) == 4, "expected GdlSentence::mpLettersUc to be size 4");
static_assert(sizeof(GdlSentence::mFlag) == 4, "expected GdlSentence::mFlag to be size 4");
static_assert(sizeof(GdlSentence::mPad) == 8, "expected GdlSentence::mPad to be size 8");
static_assert(sizeof(GdlSentence) == 0x10, "expected GdlSentence to be size 0x10");

// [Structure] class MessLines
class MessLines : public ghmListObj
{
public:
	// enum MessLines::MLINE_STATUS_ID
	enum MLINE_STATUS_ID : uint32_t
	{
		// <MLINE_STS_START = 0x0>
		MLINE_STS_START = 0,

		// <MLINE_STS_DISP = 0x1>
		MLINE_STS_DISP = 1,

		// <MLINE_STS_FADE_OUT = 0x2>
		MLINE_STS_FADE_OUT = 2,

		// <MLINE_STS_END = 0x3>
		MLINE_STS_END = 3,

		// <MLINE_STS_MAX = 0x4>
		MLINE_STS_MAX = 4

	};

	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <enum MessLines::MLINE_STATUS_ID m_Status, offset 0x10>
	enum MessLines::MLINE_STATUS_ID m_Status;

	// <struct GdlLines* m_pLine, offset 0x14>
	struct GdlLines* m_pLine = nullptr;

	// <int32_t m_Alpha, offset 0x18>
	int32_t m_Alpha = 0;

	// <struct GXColor m_Color, offset 0x1c>
	struct GXColor m_Color;

	// <class ghmGcFont* m_pFont, offset 0x20>
	class ghmGcFont* m_pFont = nullptr;

	/// 3 Functions

	// [Function] uint8_t __convention("thiscall") MessLines::RenderProcess(class MessLines* const this) [?RenderProcess@MessLines@@QAE_NXZ]
	typedef uint8_t(__thiscall* _RenderProcess_MessLines__QAE_NXZ)(class MessLines* const thisPtr);
	uint8_t RenderProcess()
	{
		_RenderProcess_MessLines__QAE_NXZ mFunc = (_RenderProcess_MessLines__QAE_NXZ)(GameModule + 0x489260);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") MessLines::FrameProcess(class MessLines* const this, uint32_t arg2) [?FrameProcess@MessLines@@QAEXI@Z]
	typedef void(__thiscall* _FrameProcess_MessLines__QAEXI_Z)(class MessLines* const thisPtr, uint32_t arg2);
	void FrameProcess(uint32_t arg2)
	{
		_FrameProcess_MessLines__QAEXI_Z mFunc = (_FrameProcess_MessLines__QAEXI_Z)(GameModule + 0x4895c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") MessLines::SetFont(class MessLines* const this, class ghmGcFont* arg2) [?SetFont@MessLines@@QAEXPAVghmGcFont@@@Z]
	typedef void(__thiscall* _SetFont_MessLines__QAEXPAVghmGcFont___Z)(class MessLines* const thisPtr, class ghmGcFont* arg2);
	void SetFont(class ghmGcFont* arg2)
	{
		_SetFont_MessLines__QAEXPAVghmGcFont___Z mFunc = (_SetFont_MessLines__QAEXPAVghmGcFont___Z)(GameModule + 0x489640);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class MessLines [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(MessLines& InObject)
	{
		m_Status = InObject.m_Status;
		m_pLine = InObject.m_pLine;
		m_Alpha = InObject.m_Alpha;
		m_Color = InObject.m_Color;
		m_pFont = InObject.m_pFont;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<MessLines, ghmListObj>("MessLines")
			.addFunction("__tostring", &MessLines::ToString)
			.addFunction("GetPtrAddr", &MessLines::GetPtrAddr)
			.addProperty("m_Status", &MessLines::m_Status)
			.addProperty("m_pLine", &MessLines::m_pLine)
			.addProperty("m_Alpha", &MessLines::m_Alpha)
			.addProperty("m_Color", &MessLines::m_Color)
			.addProperty("m_pFont", &MessLines::m_pFont)
			.addFunction("RenderProcess", &MessLines::RenderProcess)
			.addFunction("FrameProcess", &MessLines::FrameProcess)
			.addFunction("SetFont", &MessLines::SetFont)
		.endClass();
	}
#endif
};
static_assert(sizeof(MessLines::m_Status) == 4, "expected MessLines::m_Status to be size 4");
static_assert(sizeof(MessLines::m_pLine) == 4, "expected MessLines::m_pLine to be size 4");
static_assert(sizeof(MessLines::m_Alpha) == 4, "expected MessLines::m_Alpha to be size 4");
static_assert(sizeof(MessLines::m_Color) == 4, "expected MessLines::m_Color to be size 4");
static_assert(sizeof(MessLines::m_pFont) == 4, "expected MessLines::m_pFont to be size 4");
static_assert(sizeof(MessLines) == 0x24, "expected MessLines to be size 0x24");

// Unsupported operator
//void* __convention("thiscall") MessLines::`vector deleting destructor'(class MessLines* const this, uint32_t arg2)
// [Structure] class ACameraModeBase
class ACameraModeBase
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class CTimeRatioInterpolate m_inRatio, offset 0x4>
	class CTimeRatioInterpolate m_inRatio;

	// <uint8_t m_bIsInitRatioOne, offset 0x10>
	uint8_t m_bIsInitRatioOne = 0;

	// <Unidentified data segment, offset 0x11>
private:
	char _UnidentifiedData_17[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ACameraModeBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ACameraModeBase& InObject)
	{
		m_inRatio = InObject.m_inRatio;
		m_bIsInitRatioOne = InObject.m_bIsInitRatioOne;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ACameraModeBase>("ACameraModeBase")
			.addFunction("__tostring", &ACameraModeBase::ToString)
			.addFunction("GetPtrAddr", &ACameraModeBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ACameraModeBase::field_0)
			.addProperty("m_inRatio", &ACameraModeBase::m_inRatio)
			.addProperty("m_bIsInitRatioOne", &ACameraModeBase::m_bIsInitRatioOne)
		.endClass();
	}
#endif
};
static_assert(sizeof(ACameraModeBase::field_0) == 4, "expected ACameraModeBase::field_0 to be size 4");
static_assert(sizeof(ACameraModeBase::m_inRatio) == 12, "expected ACameraModeBase::m_inRatio to be size 12");
static_assert(sizeof(ACameraModeBase::m_bIsInitRatioOne) == 1, "expected ACameraModeBase::m_bIsInitRatioOne to be size 1");
static_assert(sizeof(ACameraModeBase) == 0x14, "expected ACameraModeBase to be size 0x14");

// [Structure] class CCameraModeLockOn
class CCameraModeLockOn : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <class CDoubleSpringInterpolate m_inYaw, offset 0x14>
	class CDoubleSpringInterpolate m_inYaw;

	// <class CDoubleSpringInterpolate m_inPitch, offset 0x44>
	class CDoubleSpringInterpolate m_inPitch;

	// <float m_fHopeYaw, offset 0x74>
	float m_fHopeYaw = 0;

	// <float m_fHopePitch, offset 0x78>
	float m_fHopePitch = 0;

	// <Unidentified data segment, offset 0x7c>
private:
	char _UnidentifiedData_124[4];

public:
	// <class tiVector m_inLockOnPosi, offset 0x80>
	class tiVector m_inLockOnPosi;

	// <float m_fLockOnDist, offset 0x90>
	float m_fLockOnDist = 0;

	// <float m_fEnemySiegeRatio, offset 0x94>
	float m_fEnemySiegeRatio = 0;

	// <uint8_t m_bIsChangeLockOnChara, offset 0x98>
	uint8_t m_bIsChangeLockOnChara = 0;

	// <Unidentified data segment, offset 0x99>
private:
	char _UnidentifiedData_153[3];

public:
	// <class mHRChara* m_pLockOnChara, offset 0x9c>
	class mHRChara* m_pLockOnChara = nullptr;

	// <uint8_t m_bStgHit, offset 0xa0>
	uint8_t m_bStgHit = 0;

	// <Unidentified data segment, offset 0xa1>
private:
	char _UnidentifiedData_161[15];

public:
	/// 1 Functions

	// [Function] class mHRChara* __convention("thiscall") CCameraModeLockOn::getLockOnCharacter(class CCameraModeLockOn* const this) [?getLockOnCharacter@CCameraModeLockOn@@QBEPBVmHRChara@@XZ]
	typedef class mHRChara*(__thiscall* _getLockOnCharacter_CCameraModeLockOn__QBEPBVmHRChara__XZ)(class CCameraModeLockOn* const thisPtr);
	class mHRChara* getLockOnCharacter()
	{
		_getLockOnCharacter_CCameraModeLockOn__QBEPBVmHRChara__XZ mFunc = (_getLockOnCharacter_CCameraModeLockOn__QBEPBVmHRChara__XZ)(GameModule + 0xb5050);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModeLockOn [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModeLockOn& InObject)
	{
		m_inYaw = InObject.m_inYaw;
		m_inPitch = InObject.m_inPitch;
		m_fHopeYaw = InObject.m_fHopeYaw;
		m_fHopePitch = InObject.m_fHopePitch;
		m_inLockOnPosi = InObject.m_inLockOnPosi;
		m_fLockOnDist = InObject.m_fLockOnDist;
		m_fEnemySiegeRatio = InObject.m_fEnemySiegeRatio;
		m_bIsChangeLockOnChara = InObject.m_bIsChangeLockOnChara;
		m_pLockOnChara = InObject.m_pLockOnChara;
		m_bStgHit = InObject.m_bStgHit;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeLockOn, ACameraModeBase>("CCameraModeLockOn")
			.addFunction("__tostring", &CCameraModeLockOn::ToString)
			.addFunction("GetPtrAddr", &CCameraModeLockOn::GetPtrAddr)
			.addProperty("m_inYaw", &CCameraModeLockOn::m_inYaw)
			.addProperty("m_inPitch", &CCameraModeLockOn::m_inPitch)
			.addProperty("m_fHopeYaw", &CCameraModeLockOn::m_fHopeYaw)
			.addProperty("m_fHopePitch", &CCameraModeLockOn::m_fHopePitch)
			.addProperty("m_inLockOnPosi", &CCameraModeLockOn::m_inLockOnPosi)
			.addProperty("m_fLockOnDist", &CCameraModeLockOn::m_fLockOnDist)
			.addProperty("m_fEnemySiegeRatio", &CCameraModeLockOn::m_fEnemySiegeRatio)
			.addProperty("m_bIsChangeLockOnChara", &CCameraModeLockOn::m_bIsChangeLockOnChara)
			.addProperty("m_pLockOnChara", &CCameraModeLockOn::m_pLockOnChara)
			.addProperty("m_bStgHit", &CCameraModeLockOn::m_bStgHit)
			.addFunction("getLockOnCharacter", &CCameraModeLockOn::getLockOnCharacter)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeLockOn::m_inYaw) == 48, "expected CCameraModeLockOn::m_inYaw to be size 48");
static_assert(sizeof(CCameraModeLockOn::m_inPitch) == 48, "expected CCameraModeLockOn::m_inPitch to be size 48");
static_assert(sizeof(CCameraModeLockOn::m_fHopeYaw) == 4, "expected CCameraModeLockOn::m_fHopeYaw to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_fHopePitch) == 4, "expected CCameraModeLockOn::m_fHopePitch to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_inLockOnPosi) == 16, "expected CCameraModeLockOn::m_inLockOnPosi to be size 16");
static_assert(sizeof(CCameraModeLockOn::m_fLockOnDist) == 4, "expected CCameraModeLockOn::m_fLockOnDist to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_fEnemySiegeRatio) == 4, "expected CCameraModeLockOn::m_fEnemySiegeRatio to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_bIsChangeLockOnChara) == 1, "expected CCameraModeLockOn::m_bIsChangeLockOnChara to be size 1");
static_assert(sizeof(CCameraModeLockOn::m_pLockOnChara) == 4, "expected CCameraModeLockOn::m_pLockOnChara to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_bStgHit) == 1, "expected CCameraModeLockOn::m_bStgHit to be size 1");
static_assert(sizeof(CCameraModeLockOn) == 0xb0, "expected CCameraModeLockOn to be size 0xb0");

// Can't export standard library
//int32_t __convention("thiscall") FkStlList<class PJZAKO*>::size(class FkStlList<PJZAKO *>* const this)
// Can't export standard library
//struct CONTAINER<PJZAKO *>* __convention("thiscall") FkStlList<class PJZAKO*>::begin(class FkStlList<PJZAKO *>* const this)
// Unsupported constructor
//void __convention("thiscall") FkStlList<class PJZAKO*>::FkStlList<class PJZAKO*>(class FkStlList<PJZAKO *>* const this)
// [Function] void __convention("thiscall") j_sub_4b97c0(class FkStlList<PJZAKO *>* const this) [j_sub_4b97c0]
typedef void(__thiscall* _j_sub_4b97c0)(class FkStlList<PJZAKO *>* const thisPtr);
void j_sub_4b97c0(class FkStlList<PJZAKO *>* const thisPtr)
{
	_j_sub_4b97c0 mFunc = (_j_sub_4b97c0)(GameModule + 0xb9720);
	return mFunc(thisPtr);
}
// Can't export standard library
//void __convention("thiscall") FkStlList<class PJZAKO*>::push_back(class FkStlList<PJZAKO *>* const this, class PJZAKO* const& arg2)
// Can't export standard library
//struct CONTAINER<PJZAKO *>* __convention("thiscall") FkStlList<class PJZAKO*>::GetSameValContainerPtr(class FkStlList<PJZAKO *>* const this, class PJZAKO* const& arg2)
// Can't export standard library
//void __convention("thiscall") FkStlList<class PJZAKO*>::DeleteAll(class FkStlList<PJZAKO *>* const this)
// Can't export standard library
//void __convention("thiscall") FkStlList<class PJZAKO*>::erase(class FkStlList<PJZAKO *>* const this, struct CONTAINER<PJZAKO *>* arg2)
// Can't export standard library
//struct CONTAINER<PJZAKO *>* __convention("thiscall") FkStlList<class PJZAKO*>::MakeContainer(class FkStlList<PJZAKO *>* const this, class PJZAKO* const& arg2)
// [Structure] class HrTalk
class HrTalk
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[484];

public:
	/// 19 Functions

	// [Function] uint8_t HrTalk::IsTalkDie() [?IsTalkDie@HrTalk@@SA_NXZ]
	typedef uint8_t(__fastcall* _IsTalkDie_HrTalk__SA_NXZ)();
	static uint8_t IsTalkDie()
	{
		_IsTalkDie_HrTalk__SA_NXZ mFunc = (_IsTalkDie_HrTalk__SA_NXZ)(GameModule + 0xe2cc0);
		return mFunc();
	}
	// [Function] class HrTask* HrTalk::TestCreate() [?TestCreate@HrTalk@@SAPAVHrTask@@XZ]
	typedef class HrTask*(__fastcall* _TestCreate_HrTalk__SAPAVHrTask__XZ)();
	static class HrTask* TestCreate()
	{
		_TestCreate_HrTalk__SAPAVHrTask__XZ mFunc = (_TestCreate_HrTalk__SAPAVHrTask__XZ)(GameModule + 0x4be740);
		return mFunc();
	}
	// [Function] int32_t HrTalk::NPC_Mess_Destroy() [?NPC_Mess_Destroy@HrTalk@@SAXXZ]
	typedef int32_t(__fastcall* _NPC_Mess_Destroy_HrTalk__SAXXZ)();
	static int32_t NPC_Mess_Destroy()
	{
		_NPC_Mess_Destroy_HrTalk__SAXXZ mFunc = (_NPC_Mess_Destroy_HrTalk__SAXXZ)(GameModule + 0x4be750);
		return mFunc();
	}
	// [Function] uint8_t HrTalk::CheckUnionTerminate() [?CheckUnionTerminate@HrTalk@@SA_NXZ]
	typedef uint8_t(__fastcall* _CheckUnionTerminate_HrTalk__SA_NXZ)();
	static uint8_t CheckUnionTerminate()
	{
		_CheckUnionTerminate_HrTalk__SA_NXZ mFunc = (_CheckUnionTerminate_HrTalk__SA_NXZ)(GameModule + 0x4be760);
		return mFunc();
	}
	// [Function] uint8_t HrTalk::UnionTerminate() [?UnionTerminate@HrTalk@@SA_NXZ]
	typedef uint8_t(__fastcall* _UnionTerminate_HrTalk__SA_NXZ)();
	static uint8_t UnionTerminate()
	{
		_UnionTerminate_HrTalk__SA_NXZ mFunc = (_UnionTerminate_HrTalk__SA_NXZ)(GameModule + 0x4be7c0);
		return mFunc();
	}
	// [Function] uint8_t HrTalk::CheckUnionInitialize() [?CheckUnionInitialize@HrTalk@@SA_NXZ]
	typedef uint8_t(__fastcall* _CheckUnionInitialize_HrTalk__SA_NXZ)();
	static uint8_t CheckUnionInitialize()
	{
		_CheckUnionInitialize_HrTalk__SA_NXZ mFunc = (_CheckUnionInitialize_HrTalk__SA_NXZ)(GameModule + 0x4be7f0);
		return mFunc();
	}
	// [Function] uint8_t HrTalk::UnionInitialize() [?UnionInitialize@HrTalk@@SA_NXZ]
	typedef uint8_t(__fastcall* _UnionInitialize_HrTalk__SA_NXZ)();
	static uint8_t UnionInitialize()
	{
		_UnionInitialize_HrTalk__SA_NXZ mFunc = (_UnionInitialize_HrTalk__SA_NXZ)(GameModule + 0x4be920);
		return mFunc();
	}
	// [Function] uint8_t HrTalk::Get_NPC_Motion_Flag() [?Get_NPC_Motion_Flag@HrTalk@@SA_NXZ]
	typedef uint8_t(__fastcall* _Get_NPC_Motion_Flag_HrTalk__SA_NXZ)();
	static uint8_t Get_NPC_Motion_Flag()
	{
		_Get_NPC_Motion_Flag_HrTalk__SA_NXZ mFunc = (_Get_NPC_Motion_Flag_HrTalk__SA_NXZ)(GameModule + 0x4be950);
		return mFunc();
	}
	// [Function] void HrTalk::Set_NPC_Motion_Flag(uint8_t arg1) [?Set_NPC_Motion_Flag@HrTalk@@SAX_N@Z]
	typedef void(__fastcall* _Set_NPC_Motion_Flag_HrTalk__SAX_N_Z)(uint8_t arg1);
	static void Set_NPC_Motion_Flag(uint8_t arg1)
	{
		_Set_NPC_Motion_Flag_HrTalk__SAX_N_Z mFunc = (_Set_NPC_Motion_Flag_HrTalk__SAX_N_Z)(GameModule + 0x4be970);
		return mFunc(arg1);
	}
	// [Function] int16_t HrTalk::GetKeyWait() [?GetKeyWait@HrTalk@@SAFXZ]
	typedef int16_t(__fastcall* _GetKeyWait_HrTalk__SAFXZ)();
	static int16_t GetKeyWait()
	{
		_GetKeyWait_HrTalk__SAFXZ mFunc = (_GetKeyWait_HrTalk__SAFXZ)(GameModule + 0x4be980);
		return mFunc();
	}
	// [Function] int16_t HrTalk::GetSelect(int16_t arg1) [?GetSelect@HrTalk@@SAFF@Z]
	typedef int16_t(__fastcall* _GetSelect_HrTalk__SAFF_Z)(int16_t arg1);
	static int16_t GetSelect(int16_t arg1)
	{
		_GetSelect_HrTalk__SAFF_Z mFunc = (_GetSelect_HrTalk__SAFF_Z)(GameModule + 0x4be9a0);
		return mFunc(arg1);
	}
	// [Function] int16_t HrTalk::GetChoice() [?GetChoice@HrTalk@@SAFXZ]
	typedef int16_t(__fastcall* _GetChoice_HrTalk__SAFXZ)();
	static int16_t GetChoice()
	{
		_GetChoice_HrTalk__SAFXZ mFunc = (_GetChoice_HrTalk__SAFXZ)(GameModule + 0x4be9c0);
		return mFunc();
	}
	// [Function] void __convention("thiscall") HrTalk::dLeaving(class HrTalk* const this) [?dLeaving@HrTalk@@AAEXXZ]
	typedef void(__thiscall* _dLeaving_HrTalk__AAEXXZ)(class HrTalk* const thisPtr);
	void dLeaving()
	{
		_dLeaving_HrTalk__AAEXXZ mFunc = (_dLeaving_HrTalk__AAEXXZ)(GameModule + 0x4be9d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrTalk::RenderProcess(class HrTalk* const this) [?RenderProcess@HrTalk@@MAEXXZ]
	typedef void(__thiscall* _RenderProcess_HrTalk__MAEXXZ)(class HrTalk* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_HrTalk__MAEXXZ mFunc = (_RenderProcess_HrTalk__MAEXXZ)(GameModule + 0x4bea00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrTalk::FrameProcess(class HrTalk* const this) [?FrameProcess@HrTalk@@MAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrTalk__MAEXXZ)(class HrTalk* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrTalk__MAEXXZ mFunc = (_FrameProcess_HrTalk__MAEXXZ)(GameModule + 0x4bea40);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrTalk::Terminate(class HrTalk* const this) [?Terminate@HrTalk@@MAEXXZ]
	typedef void(__thiscall* _Terminate_HrTalk__MAEXXZ)(class HrTalk* const thisPtr);
	void Terminate()
	{
		_Terminate_HrTalk__MAEXXZ mFunc = (_Terminate_HrTalk__MAEXXZ)(GameModule + 0x4beff0);
		return mFunc(this);
	}
	// [Function] class HrTalk* HrTalk::Create() [?Create@HrTalk@@SAPAV1@XZ]
	typedef class HrTalk*(__fastcall* _Create_HrTalk__SAPAV1_XZ)();
	static class HrTalk* Create()
	{
		_Create_HrTalk__SAPAV1_XZ mFunc = (_Create_HrTalk__SAPAV1_XZ)(GameModule + 0x4c0440);
		return mFunc();
	}
	// [Function] uint8_t __convention("thiscall") HrTalk::dAppear(class HrTalk* const this, char const* DialogString, class ghmResGroup* Resource, int32_t LanguageGroup) [?dAppear@HrTalk@@QAE_NPBDPAXH@Z]
	typedef uint8_t(__thiscall* _dAppear_HrTalk__QAE_NPBDPAXH_Z)(class HrTalk* const thisPtr, char const* DialogString, class ghmResGroup* Resource, int32_t LanguageGroup);
	uint8_t dAppear(std::string DialogString, class ghmResGroup* Resource, int32_t LanguageGroup)
	{
		char const* DialogString_c_str = DialogString.c_str();
		_dAppear_HrTalk__QAE_NPBDPAXH_Z mFunc = (_dAppear_HrTalk__QAE_NPBDPAXH_Z)(GameModule + 0x4c0570);
		return mFunc(this, DialogString_c_str, Resource, LanguageGroup);
	}
	// [Function] int16_t HrTalk::GetStat() [?GetStat@HrTalk@@SAFXZ]
	typedef int16_t(__fastcall* _GetStat_HrTalk__SAFXZ)();
	static int16_t GetStat()
	{
		_GetStat_HrTalk__SAFXZ mFunc = (_GetStat_HrTalk__SAFXZ)(GameModule + 0x4c0720);
		return mFunc();
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrTalk [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrTalk& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrTalk>("HrTalk")
			.addFunction("__tostring", &HrTalk::ToString)
			.addFunction("GetPtrAddr", &HrTalk::GetPtrAddr)
			.addStaticFunction("IsTalkDie", &HrTalk::IsTalkDie)
			.addStaticFunction("TestCreate", &HrTalk::TestCreate)
			.addStaticFunction("NPC_Mess_Destroy", &HrTalk::NPC_Mess_Destroy)
			.addStaticFunction("CheckUnionTerminate", &HrTalk::CheckUnionTerminate)
			.addStaticFunction("UnionTerminate", &HrTalk::UnionTerminate)
			.addStaticFunction("CheckUnionInitialize", &HrTalk::CheckUnionInitialize)
			.addStaticFunction("UnionInitialize", &HrTalk::UnionInitialize)
			.addStaticFunction("Get_NPC_Motion_Flag", &HrTalk::Get_NPC_Motion_Flag)
			.addStaticFunction("Set_NPC_Motion_Flag", &HrTalk::Set_NPC_Motion_Flag)
			.addStaticFunction("GetKeyWait", &HrTalk::GetKeyWait)
			.addStaticFunction("GetSelect", &HrTalk::GetSelect)
			.addStaticFunction("GetChoice", &HrTalk::GetChoice)
			.addFunction("dLeaving", &HrTalk::dLeaving)
			.addFunction("RenderProcess", &HrTalk::RenderProcess)
			.addFunction("FrameProcess", &HrTalk::FrameProcess)
			.addFunction("Terminate", &HrTalk::Terminate)
			.addStaticFunction("Create", &HrTalk::Create)
			.addFunction("dAppear", &HrTalk::dAppear)
			.addStaticFunction("GetStat", &HrTalk::GetStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrTalk) == 0x1e4, "expected HrTalk to be size 0x1e4");

// Unsupported constructor
//void __convention("thiscall") HrTalk::HrTalk(class HrTalk* const this)
// [Structure] class HrSysMessage
/// <summary>
/// Related to system messages.
/// </summary>
class HrSysMessage : public HrTask
{
public:
	// enum HrSysMessage::e_SYSMES_MODE
	enum e_SYSMES_MODE : uint32_t
	{
		// <e_SYSMES_MODE_NORMAL = 0x0>
		e_SYSMES_MODE_NORMAL = 0,

		// <e_SYSMES_MODE_MAPOPEN = 0x1>
		e_SYSMES_MODE_MAPOPEN = 1,

		// <e_SYSMES_MODE_MASK = 0x2>
		e_SYSMES_MODE_MASK = 2,

		// <e_SYSMES_MODE_POWERUP = 0x3>
		e_SYSMES_MODE_POWERUP = 3,

		// <e_SYSMES_MODE_PAYMONEY = 0x4>
		e_SYSMES_MODE_PAYMONEY = 4,

		// <e_SYSMES_MODE_FUSOKU_MONEY = 0x5>
		e_SYSMES_MODE_FUSOKU_MONEY = 5,

		// <e_SYSMES_MODE_TAMARI_MONEY = 0x6>
		e_SYSMES_MODE_TAMARI_MONEY = 6,

		// <e_SYSMES_MODE_FREEFIGHT = 0x7>
		e_SYSMES_MODE_FREEFIGHT = 7,

		// <e_SYSMES_MODE_NUM = 0x8>
		e_SYSMES_MODE_NUM = 8

	};

	/// Struct member variables

	// <class HrTask Super, offset 0x0>
	// class HrTask Super;

	// <uint32_t State, offset 0x50>
	uint32_t State = 0;

	// <Unidentified data segment, offset 0x54>
private:
	char _UnidentifiedData_84[4];

public:
	// <uint32_t SysMesMode, offset 0x58>
	uint32_t SysMesMode = 0;

	// <Unidentified data segment, offset 0x5c>
private:
	char _UnidentifiedData_92[76];

public:
	// <uint32_t MessageHandle, offset 0xa8>
	uint32_t MessageHandle = 0;

	// <Unidentified data segment, offset 0xac>
private:
	char _UnidentifiedData_172[29];

public:
	// <bool HasPlayer, offset 0xc9>
	bool HasPlayer;

	// <Unidentified data segment, offset 0xca>
private:
	char _UnidentifiedData_202[14];

public:
	// <struct SYSMsIcon* Icon, offset 0xd8>
	struct SYSMsIcon* Icon = nullptr;

	// <Unidentified data segment, offset 0xdc>
private:
	char _UnidentifiedData_220[388];

public:
	// <class ghmResGroup* ResGroup, offset 0x260>
	class ghmResGroup* ResGroup = nullptr;

	// <Unidentified data segment, offset 0x264>
private:
	char _UnidentifiedData_612[32];

public:
	/// 18 Functions

	// [Function] class HrTask* HrSysMessage::TestCreate() [?TestCreate@HrSysMessage@@SAPAVHrTask@@XZ]
	typedef class HrTask*(__fastcall* _TestCreate_HrSysMessage__SAPAVHrTask__XZ)();
	static class HrTask* TestCreate()
	{
		_TestCreate_HrSysMessage__SAPAVHrTask__XZ mFunc = (_TestCreate_HrSysMessage__SAPAVHrTask__XZ)(GameModule + 0x4c0740);
		return mFunc();
	}
	// [Function] uint8_t HrSysMessage::CheckUnionTerminate() [?CheckUnionTerminate@HrSysMessage@@KA_NXZ]
	typedef uint8_t(__fastcall* _CheckUnionTerminate_HrSysMessage__KA_NXZ)();
	static uint8_t CheckUnionTerminate()
	{
		_CheckUnionTerminate_HrSysMessage__KA_NXZ mFunc = (_CheckUnionTerminate_HrSysMessage__KA_NXZ)(GameModule + 0x4c0750);
		return mFunc();
	}
	// [Function] uint8_t HrSysMessage::UnionTerminate() [?UnionTerminate@HrSysMessage@@KA_NXZ]
	typedef uint8_t(__fastcall* _UnionTerminate_HrSysMessage__KA_NXZ)();
	static uint8_t UnionTerminate()
	{
		_UnionTerminate_HrSysMessage__KA_NXZ mFunc = (_UnionTerminate_HrSysMessage__KA_NXZ)(GameModule + 0x4c07d0);
		return mFunc();
	}
	// [Function] uint8_t HrSysMessage::CheckUnionInitialize() [?CheckUnionInitialize@HrSysMessage@@KA_NXZ]
	typedef uint8_t(__fastcall* _CheckUnionInitialize_HrSysMessage__KA_NXZ)();
	static uint8_t CheckUnionInitialize()
	{
		_CheckUnionInitialize_HrSysMessage__KA_NXZ mFunc = (_CheckUnionInitialize_HrSysMessage__KA_NXZ)(GameModule + 0x4c0800);
		return mFunc();
	}
	// [Function] uint8_t HrSysMessage::UnionInitialize() [?UnionInitialize@HrSysMessage@@KA_NXZ]
	typedef uint8_t(__fastcall* _UnionInitialize_HrSysMessage__KA_NXZ)();
	static uint8_t UnionInitialize()
	{
		_UnionInitialize_HrSysMessage__KA_NXZ mFunc = (_UnionInitialize_HrSysMessage__KA_NXZ)(GameModule + 0x4c0a80);
		return mFunc();
	}
	// [Function] int32_t HrSysMessage::Sys_Mess_Destroy() [?Sys_Mess_Destroy@HrSysMessage@@SAXXZ]
	typedef int32_t(__fastcall* _Sys_Mess_Destroy_HrSysMessage__SAXXZ)();
	static int32_t Sys_Mess_Destroy()
	{
		_Sys_Mess_Destroy_HrSysMessage__SAXXZ mFunc = (_Sys_Mess_Destroy_HrSysMessage__SAXXZ)(GameModule + 0x4c0ab0);
		return mFunc();
	}
	// [Function] void __convention("thiscall") HrSysMessage::Sys_DrawMessIcon(class HrSysMessage* const this, float arg2) [?Sys_DrawMessIcon@HrSysMessage@@AAEXM@Z]
	typedef void(__thiscall* _Sys_DrawMessIcon_HrSysMessage__AAEXM_Z)(class HrSysMessage* const thisPtr, float arg2);
	void Sys_DrawMessIcon(float arg2)
	{
		_Sys_DrawMessIcon_HrSysMessage__AAEXM_Z mFunc = (_Sys_DrawMessIcon_HrSysMessage__AAEXM_Z)(GameModule + 0x4c0ac0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrSysMessage::Sys_SetMessageIcon(class HrSysMessage* const this, int32_t arg2, int32_t arg3) [?Sys_SetMessageIcon@HrSysMessage@@AAEXHH@Z]
	typedef void(__thiscall* _Sys_SetMessageIcon_HrSysMessage__AAEXHH_Z)(class HrSysMessage* const thisPtr, int32_t arg2, int32_t arg3);
	void Sys_SetMessageIcon(int32_t arg2, int32_t arg3)
	{
		_Sys_SetMessageIcon_HrSysMessage__AAEXHH_Z mFunc = (_Sys_SetMessageIcon_HrSysMessage__AAEXHH_Z)(GameModule + 0x4c0ee0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrSysMessage::dLeaving(class HrSysMessage* const this) [?dLeaving@HrSysMessage@@AAEXXZ]
	typedef void(__thiscall* _dLeaving_HrSysMessage__AAEXXZ)(class HrSysMessage* const thisPtr);
	void dLeaving()
	{
		_dLeaving_HrSysMessage__AAEXXZ mFunc = (_dLeaving_HrSysMessage__AAEXXZ)(GameModule + 0x4c12f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrSysMessage::DrawShopOpenBack(class HrSysMessage* const this, float arg2, float arg3) [?DrawShopOpenBack@HrSysMessage@@IAEXMM@Z]
	typedef void(__thiscall* _DrawShopOpenBack_HrSysMessage__IAEXMM_Z)(class HrSysMessage* const thisPtr, float arg2, float arg3);
	void DrawShopOpenBack(float arg2, float arg3)
	{
		_DrawShopOpenBack_HrSysMessage__IAEXMM_Z mFunc = (_DrawShopOpenBack_HrSysMessage__IAEXMM_Z)(GameModule + 0x4c13e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrSysMessage::DrawNormalBack(class HrSysMessage* const this, float arg2) [?DrawNormalBack@HrSysMessage@@IAEXM@Z]
	typedef void(__thiscall* _DrawNormalBack_HrSysMessage__IAEXM_Z)(class HrSysMessage* const thisPtr, float arg2);
	void DrawNormalBack(float arg2)
	{
		_DrawNormalBack_HrSysMessage__IAEXM_Z mFunc = (_DrawNormalBack_HrSysMessage__IAEXM_Z)(GameModule + 0x4c16e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrSysMessage::RenderProcess(class HrSysMessage* const this) [?RenderProcess@HrSysMessage@@MAEXXZ]
	typedef void(__thiscall* _RenderProcess_HrSysMessage__MAEXXZ)(class HrSysMessage* const thisPtr);
	void RenderProcess()
	{
		_RenderProcess_HrSysMessage__MAEXXZ mFunc = (_RenderProcess_HrSysMessage__MAEXXZ)(GameModule + 0x4c1950);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrSysMessage::FrameProcess(class HrSysMessage* const this) [?FrameProcess@HrSysMessage@@MAEXXZ]
	typedef void(__thiscall* _FrameProcess_HrSysMessage__MAEXXZ)(class HrSysMessage* const thisPtr);
	void FrameProcess()
	{
		_FrameProcess_HrSysMessage__MAEXXZ mFunc = (_FrameProcess_HrSysMessage__MAEXXZ)(GameModule + 0x4c2050);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrSysMessage::Terminate(class HrSysMessage* const this) [?Terminate@HrSysMessage@@MAEXXZ]
	typedef void(__thiscall* _Terminate_HrSysMessage__MAEXXZ)(class HrSysMessage* const thisPtr);
	void Terminate()
	{
		_Terminate_HrSysMessage__MAEXXZ mFunc = (_Terminate_HrSysMessage__MAEXXZ)(GameModule + 0x4c25c0);
		return mFunc(this);
	}
	// [Function] class HrSysMessage* HrSysMessage::Create() [?Create@HrSysMessage@@SAPAV1@XZ]
	typedef class HrSysMessage*(__fastcall* _Create_HrSysMessage__SAPAV1_XZ)();
	static class HrSysMessage* Create()
	{
		_Create_HrSysMessage__SAPAV1_XZ mFunc = (_Create_HrSysMessage__SAPAV1_XZ)(GameModule + 0x4c2600);
		return mFunc();
	}
	// [Function] uint8_t __convention("thiscall") HrSysMessage::dAppear(class HrSysMessage* const this, char const* EventName, class ghmResGroup* resGroup, int32_t LanguageGroup, enum HrSysMessage::e_SYSMES_MODE InMode, bool bStop) [?dAppear@HrSysMessage@@QAE_NPBDPAXHW4e_SYSMES_MODE@1@_N@Z]
	typedef uint8_t(__thiscall* _dAppear_HrSysMessage__QAE_NPBDPAXHW4e_SYSMES_MODE_1__N_Z)(class HrSysMessage* const thisPtr, char const* EventName, class ghmResGroup* resGroup, int32_t LanguageGroup, enum HrSysMessage::e_SYSMES_MODE InMode, bool bStop);
	uint8_t dAppear(std::string EventName, class ghmResGroup* resGroup, int32_t LanguageGroup, /* enum HrSysMessage::e_SYSMES_MODE */ uint32_t InMode, bool bStop)
	{
		char const* EventName_c_str = EventName.c_str();
		_dAppear_HrSysMessage__QAE_NPBDPAXHW4e_SYSMES_MODE_1__N_Z mFunc = (_dAppear_HrSysMessage__QAE_NPBDPAXHW4e_SYSMES_MODE_1__N_Z)(GameModule + 0x4c2820);
		return mFunc(this, EventName_c_str, resGroup, LanguageGroup, (enum HrSysMessage::e_SYSMES_MODE)InMode, bStop);
	}
	// [Function] int16_t HrSysMessage::GetStat() [?GetStat@HrSysMessage@@SAFXZ]
	typedef int16_t(__fastcall* _GetStat_HrSysMessage__SAFXZ)();
	static int16_t GetStat()
	{
		_GetStat_HrSysMessage__SAFXZ mFunc = (_GetStat_HrSysMessage__SAFXZ)(GameModule + 0x4c2a00);
		return mFunc();
	}
	// [Function] int16_t HrSysMessage::GetChoice() [?GetChoice@HrSysMessage@@SAFXZ]
	typedef int16_t(__fastcall* _GetChoice_HrSysMessage__SAFXZ)();
	static int16_t GetChoice()
	{
		_GetChoice_HrSysMessage__SAFXZ mFunc = (_GetChoice_HrSysMessage__SAFXZ)(GameModule + 0x4c2a10);
		return mFunc();
	}
	/// Meta

	bool DoAppear(std::string arg2, int32_t arg4, enum HrSysMessage::e_SYSMES_MODE arg5, uint8_t arg6) { return dAppear(arg2, nullptr, arg4, arg5, arg6) != 0; }
	std::string ToString() const { std::stringstream stream; stream << "class HrSysMessage (MessageHandle: " << MessageHandle << ") [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrSysMessage& InObject)
	{
		State = InObject.State;
		SysMesMode = InObject.SysMesMode;
		MessageHandle = InObject.MessageHandle;
		HasPlayer = InObject.HasPlayer;
		Icon = InObject.Icon;
		ResGroup = InObject.ResGroup;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrSysMessage, HrTask>("HrSysMessage")
			.addFunction("__tostring", &HrSysMessage::ToString)
			.addFunction("GetPtrAddr", &HrSysMessage::GetPtrAddr)
			.addProperty("State", &HrSysMessage::State)
			.addProperty("SysMesMode", &HrSysMessage::SysMesMode)
			.addProperty("MessageHandle", &HrSysMessage::MessageHandle)
			.addProperty("HasPlayer", &HrSysMessage::HasPlayer)
			.addProperty("Icon", &HrSysMessage::Icon)
			.addProperty("ResGroup", &HrSysMessage::ResGroup)
			.addStaticFunction("TestCreate", &HrSysMessage::TestCreate)
			.addStaticFunction("CheckUnionTerminate", &HrSysMessage::CheckUnionTerminate)
			.addStaticFunction("UnionTerminate", &HrSysMessage::UnionTerminate)
			.addStaticFunction("CheckUnionInitialize", &HrSysMessage::CheckUnionInitialize)
			.addStaticFunction("UnionInitialize", &HrSysMessage::UnionInitialize)
			.addStaticFunction("Sys_Mess_Destroy", &HrSysMessage::Sys_Mess_Destroy)
			.addFunction("Sys_DrawMessIcon", &HrSysMessage::Sys_DrawMessIcon)
			.addFunction("Sys_SetMessageIcon", &HrSysMessage::Sys_SetMessageIcon)
			.addFunction("dLeaving", &HrSysMessage::dLeaving)
			.addFunction("DrawShopOpenBack", &HrSysMessage::DrawShopOpenBack)
			.addFunction("DrawNormalBack", &HrSysMessage::DrawNormalBack)
			.addFunction("RenderProcess", &HrSysMessage::RenderProcess)
			.addFunction("FrameProcess", &HrSysMessage::FrameProcess)
			.addFunction("Terminate", &HrSysMessage::Terminate)
			.addStaticFunction("Create", &HrSysMessage::Create)
			.addFunction("dAppear", &HrSysMessage::dAppear)
			.addStaticFunction("GetStat", &HrSysMessage::GetStat)
			.addStaticFunction("GetChoice", &HrSysMessage::GetChoice)
			.addFunction("DoAppear", &HrSysMessage::DoAppear)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrSysMessage::State) == 4, "expected HrSysMessage::State to be size 4");
static_assert(sizeof(HrSysMessage::SysMesMode) == 4, "expected HrSysMessage::SysMesMode to be size 4");
static_assert(sizeof(HrSysMessage::MessageHandle) == 4, "expected HrSysMessage::MessageHandle to be size 4");
static_assert(sizeof(HrSysMessage::HasPlayer) == 1, "expected HrSysMessage::HasPlayer to be size 1");
static_assert(sizeof(HrSysMessage::Icon) == 4, "expected HrSysMessage::Icon to be size 4");
static_assert(sizeof(HrSysMessage::ResGroup) == 4, "expected HrSysMessage::ResGroup to be size 4");
static_assert(sizeof(HrSysMessage) == 0x284, "expected HrSysMessage to be size 0x284");

// Unsupported constructor
//void __convention("thiscall") HrSysMessage::HrSysMessage(class HrSysMessage* const this)
// [Structure] struct GFONT_MEMBER
struct GFONT_MEMBER
{
public:
	/// Struct member variables

	// <float gPosX, offset 0x0>
	float gPosX = 0;

	// <float gPosY, offset 0x4>
	float gPosY = 0;

	// <float gRot, offset 0x8>
	float gRot = 0;

	// <uint32_t gDColor, offset 0xc>
	uint32_t gDColor = 0;

	// <float gSize, offset 0x10>
	float gSize = 0;

	// <uint8_t gDraw, offset 0x14>
	uint8_t gDraw = 0;

	// <Unidentified data segment, offset 0x15>
private:
	char _UnidentifiedData_21[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct GFONT_MEMBER [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GFONT_MEMBER& InObject)
	{
		gPosX = InObject.gPosX;
		gPosY = InObject.gPosY;
		gRot = InObject.gRot;
		gDColor = InObject.gDColor;
		gSize = InObject.gSize;
		gDraw = InObject.gDraw;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GFONT_MEMBER>("GFONT_MEMBER")
			.addFunction("__tostring", &GFONT_MEMBER::ToString)
			.addFunction("GetPtrAddr", &GFONT_MEMBER::GetPtrAddr)
			.addProperty("gPosX", &GFONT_MEMBER::gPosX)
			.addProperty("gPosY", &GFONT_MEMBER::gPosY)
			.addProperty("gRot", &GFONT_MEMBER::gRot)
			.addProperty("gDColor", &GFONT_MEMBER::gDColor)
			.addProperty("gSize", &GFONT_MEMBER::gSize)
			.addProperty("gDraw", &GFONT_MEMBER::gDraw)
		.endClass();
	}
#endif
};
static_assert(sizeof(GFONT_MEMBER::gPosX) == 4, "expected GFONT_MEMBER::gPosX to be size 4");
static_assert(sizeof(GFONT_MEMBER::gPosY) == 4, "expected GFONT_MEMBER::gPosY to be size 4");
static_assert(sizeof(GFONT_MEMBER::gRot) == 4, "expected GFONT_MEMBER::gRot to be size 4");
static_assert(sizeof(GFONT_MEMBER::gDColor) == 4, "expected GFONT_MEMBER::gDColor to be size 4");
static_assert(sizeof(GFONT_MEMBER::gSize) == 4, "expected GFONT_MEMBER::gSize to be size 4");
static_assert(sizeof(GFONT_MEMBER::gDraw) == 1, "expected GFONT_MEMBER::gDraw to be size 1");
static_assert(sizeof(GFONT_MEMBER) == 0x18, "expected GFONT_MEMBER to be size 0x18");

// [Structure] struct SYSMsIcon
struct SYSMsIcon
{
public:
	/// Struct member variables

	// <struct GFONT_MEMBER mMessIcon, offset 0x0>
	struct GFONT_MEMBER mMessIcon;

	// <int16_t mIconNum, offset 0x18>
	int16_t mIconNum = 0;

	// <Unidentified data segment, offset 0x1a>
private:
	char _UnidentifiedData_26[2];

public:
	// <int32_t mIconhand, offset 0x1c>
	int32_t mIconhand = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct SYSMsIcon [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SYSMsIcon& InObject)
	{
		mMessIcon = InObject.mMessIcon;
		mIconNum = InObject.mIconNum;
		mIconhand = InObject.mIconhand;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SYSMsIcon>("SYSMsIcon")
			.addFunction("__tostring", &SYSMsIcon::ToString)
			.addFunction("GetPtrAddr", &SYSMsIcon::GetPtrAddr)
			.addProperty("mMessIcon", &SYSMsIcon::mMessIcon)
			.addProperty("mIconNum", &SYSMsIcon::mIconNum)
			.addProperty("mIconhand", &SYSMsIcon::mIconhand)
		.endClass();
	}
#endif
};
static_assert(sizeof(SYSMsIcon::mMessIcon) == 24, "expected SYSMsIcon::mMessIcon to be size 24");
static_assert(sizeof(SYSMsIcon::mIconNum) == 2, "expected SYSMsIcon::mIconNum to be size 2");
static_assert(sizeof(SYSMsIcon::mIconhand) == 4, "expected SYSMsIcon::mIconhand to be size 4");
static_assert(sizeof(SYSMsIcon) == 0x20, "expected SYSMsIcon to be size 0x20");

// enum ITEM_DATA_TYPE
enum ITEM_DATA_TYPE : uint32_t
{
	// <ITEM_DATA_TYPE_ARMS = 0x0>
	ITEM_DATA_TYPE_ARMS = 0,

	// <ITEM_DATA_TYPE_SUNGLASS = 0x1>
	ITEM_DATA_TYPE_SUNGLASS = 1,

	// <ITEM_DATA_TYPE_JACKET = 0x2>
	ITEM_DATA_TYPE_JACKET = 2,

	// <ITEM_DATA_TYPE_SHOES = 0x3>
	ITEM_DATA_TYPE_SHOES = 3,

	// <ITEM_DATA_TYPE_PANTS = 0x4>
	ITEM_DATA_TYPE_PANTS = 4,

	// <ITEM_DATA_TYPE_BELT = 0x5>
	ITEM_DATA_TYPE_BELT = 5,

	// <ITEM_DATA_TYPE_WRISTBAND = 0x6>
	ITEM_DATA_TYPE_WRISTBAND = 6,

	// <ITEM_DATA_TYPE_T_SHIRT = 0x7>
	ITEM_DATA_TYPE_T_SHIRT = 7,

	// <ITEM_DATA_TYPE_VITAL = 0x8>
	ITEM_DATA_TYPE_VITAL = 8,

	// <ITEM_DATA_TYPE_BATTERY = 0x9>
	ITEM_DATA_TYPE_BATTERY = 9,

	// <ITEM_DATA_TYPE_TENSION = 0xa>
	ITEM_DATA_TYPE_TENSION = 10,

	// <ITEM_DATA_TYPE_VIDEO = 0xb>
	ITEM_DATA_TYPE_VIDEO = 11,

	// <ITEM_DATA_TYPE_SWORD_PARTS = 0xc>
	ITEM_DATA_TYPE_SWORD_PARTS = 12,

	// <ITEM_DATA_TYPE_COLLECTION_MOTEL = 0xd>
	ITEM_DATA_TYPE_COLLECTION_MOTEL = 13,

	// <ITEM_DATA_TYPE_COLLECTION_CARD = 0xe>
	ITEM_DATA_TYPE_COLLECTION_CARD = 14,

	// <ITEM_DATA_TYPE_MASK_CARD = 0xf>
	ITEM_DATA_TYPE_MASK_CARD = 15,

	// <ITEM_DATA_TYPE_ROVICOF_BALL = 0x10>
	ITEM_DATA_TYPE_ROVICOF_BALL = 16,

	// <ITEM_DATA_TYPE_HEART_PIECE = 0x11>
	ITEM_DATA_TYPE_HEART_PIECE = 17,

	// <ITEM_DATA_TYPE_TREASURE_BOX = 0x12>
	ITEM_DATA_TYPE_TREASURE_BOX = 18,

	// <ITEM_DATA_TYPE_MAGAZINE = 0x13>
	ITEM_DATA_TYPE_MAGAZINE = 19,

	// <ITEM_DATA_TYPE_PHOTOCAT = 0x14>
	ITEM_DATA_TYPE_PHOTOCAT = 20,

	// <ITEM_DATA_TYPE_PW = 0x15>
	ITEM_DATA_TYPE_PW = 21,

	// <ITEM_DATA_TYPE_SPECIAL_SKILL = 0x16>
	ITEM_DATA_TYPE_SPECIAL_SKILL = 22,

	// <ITEM_DATA_TYPE_TRAINING = 0x17>
	ITEM_DATA_TYPE_TRAINING = 23,

	// <ITEM_DATA_TYPE_MAX = 0x18>
	ITEM_DATA_TYPE_MAX = 24

};

// [Structure] class mHRItem
class mHRItem : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct Vec mPos, offset 0x10>
	struct Vec mPos;

	// <int32_t mKind, offset 0x1c>
	int32_t mKind = 0;

	// <enum ITEM_DATA_TYPE mItemDataType, offset 0x20>
	enum ITEM_DATA_TYPE mItemDataType;

	// <float mRotY, offset 0x24>
	float mRotY = 0;

	// <float mEffectScale, offset 0x28>
	float mEffectScale = 0;

	// <class TGmf* mpGmf, offset 0x2c>
	class TGmf* mpGmf = nullptr;

	// <class TGmf* mpGmfEf, offset 0x30>
	class TGmf* mpGmfEf = nullptr;

	// <uint8_t mVisible, offset 0x34>
	uint8_t mVisible = 0;

	// <Unidentified data segment, offset 0x35>
private:
	char _UnidentifiedData_53[3];

public:
	// <class WAnimF mScale, offset 0x38>
	class WAnimF mScale;

	// <int32_t mActiveWait, offset 0x58>
	int32_t mActiveWait = 0;

	// <float mMaai, offset 0x5c>
	float mMaai = 0;

	// <class WAnimF mRotSpeed, offset 0x60>
	class WAnimF mRotSpeed;

	// <uint8_t mPcHit, offset 0x80>
	uint8_t mPcHit = 0;

	// <Unidentified data segment, offset 0x81>
private:
	char _UnidentifiedData_129[3];

public:
	/// 11 Functions

	// [Function] class mHRItem* mHRItem::mGetTop() [?mGetTop@mHRItem@@SAPAV1@XZ]
	typedef class mHRItem*(__fastcall* _mGetTop_mHRItem__SAPAV1_XZ)();
	static class mHRItem* mGetTop()
	{
		_mGetTop_mHRItem__SAPAV1_XZ mFunc = (_mGetTop_mHRItem__SAPAV1_XZ)(GameModule + 0xba8c0);
		return mFunc();
	}
	// [Function] class mHRItem* __convention("thiscall") mHRItem::mGetNext(class mHRItem* const this) [?mGetNext@mHRItem@@QAEPAV1@XZ]
	typedef class mHRItem*(__thiscall* _mGetNext_mHRItem__QAEPAV1_XZ)(class mHRItem* const thisPtr);
	class mHRItem* mGetNext()
	{
		_mGetNext_mHRItem__QAEPAV1_XZ mFunc = (_mGetNext_mHRItem__QAEPAV1_XZ)(GameModule + 0xba8d0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRItem::mGetDrawDist(class mHRItem* const this) [?mGetDrawDist@mHRItem@@QAEMXZ]
	typedef float(__thiscall* _mGetDrawDist_mHRItem__QAEMXZ)(class mHRItem* const thisPtr);
	float mGetDrawDist()
	{
		_mGetDrawDist_mHRItem__QAEMXZ mFunc = (_mGetDrawDist_mHRItem__QAEMXZ)(GameModule + 0x4c6e00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRItem::mRenderProc(class mHRItem* const this) [?mRenderProc@mHRItem@@QAEXXZ]
	typedef void(__thiscall* _mRenderProc_mHRItem__QAEXXZ)(class mHRItem* const thisPtr);
	void mRenderProc()
	{
		_mRenderProc_mHRItem__QAEXXZ mFunc = (_mRenderProc_mHRItem__QAEXXZ)(GameModule + 0x4c6e10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRItem::mFrameProc(class mHRItem* const this) [?mFrameProc@mHRItem@@QAEXXZ]
	typedef void(__thiscall* _mFrameProc_mHRItem__QAEXXZ)(class mHRItem* const thisPtr);
	void mFrameProc()
	{
		_mFrameProc_mHRItem__QAEXXZ mFunc = (_mFrameProc_mHRItem__QAEXXZ)(GameModule + 0x4c6fe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRItem::mPcCantGetItem(class mHRItem* const this) [?mPcCantGetItem@mHRItem@@QAEXXZ]
	typedef void(__thiscall* _mPcCantGetItem_mHRItem__QAEXXZ)(class mHRItem* const thisPtr);
	void mPcCantGetItem()
	{
		_mPcCantGetItem_mHRItem__QAEXXZ mFunc = (_mPcCantGetItem_mHRItem__QAEXXZ)(GameModule + 0x4c7780);
		return mFunc(this);
	}
	// [Function] void* __convention("thiscall") mHRItem::mGetItemResource(class mHRItem* const this, char* arg2) [?mGetItemResource@mHRItem@@QAEPAXPAD@Z]
	typedef void*(__thiscall* _mGetItemResource_mHRItem__QAEPAXPAD_Z)(class mHRItem* const thisPtr, char* arg2);
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetItemResource(std::string arg2)
	{
		std::vector<char> arg2_c_str(arg2.c_str(), + arg2.c_str() + arg2.size() + 1);
		_mGetItemResource_mHRItem__QAEPAXPAD_Z mFunc = (_mGetItemResource_mHRItem__QAEPAXPAD_Z)(GameModule + 0x4c77c0);
		mFunc(this, &arg2_c_str[0]);
	}
	// [Function] int32_t mHRItem::mRenderProcAll(float arg1 @ edi) [?mRenderProcAll@mHRItem@@SAXXZ]
	typedef int32_t(__fastcall* _mRenderProcAll_mHRItem__SAXXZ)(float arg1);
	static int32_t mRenderProcAll(float arg1)
	{
		_mRenderProcAll_mHRItem__SAXXZ mFunc = (_mRenderProcAll_mHRItem__SAXXZ)(GameModule + 0x4c7960);
		return mFunc(arg1);
	}
	// [Function] void mHRItem::mFrameProcAll() [?mFrameProcAll@mHRItem@@SAXXZ]
	typedef void(__fastcall* _mFrameProcAll_mHRItem__SAXXZ)();
	static void mFrameProcAll()
	{
		_mFrameProcAll_mHRItem__SAXXZ mFunc = (_mFrameProcAll_mHRItem__SAXXZ)(GameModule + 0x4c7b70);
		return mFunc();
	}
	// [Function] void mHRItem::mSetVisible(uint8_t arg1) [?mSetVisible@mHRItem@@SAX_N@Z]
	typedef void(__fastcall* _mSetVisible_mHRItem__SAX_N_Z)(uint8_t arg1);
	static void mSetVisible(uint8_t arg1)
	{
		_mSetVisible_mHRItem__SAX_N_Z mFunc = (_mSetVisible_mHRItem__SAX_N_Z)(GameModule + 0x4c7b90);
		return mFunc(arg1);
	}
	// [Function] void mHRItem::mReleaseAll() [?mReleaseAll@mHRItem@@SAXXZ]
	typedef void(__fastcall* _mReleaseAll_mHRItem__SAXXZ)();
	static void mReleaseAll()
	{
		_mReleaseAll_mHRItem__SAXXZ mFunc = (_mReleaseAll_mHRItem__SAXXZ)(GameModule + 0x4c7bb0);
		return mFunc();
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class mHRItem [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(mHRItem& InObject)
	{
		mPos = InObject.mPos;
		mKind = InObject.mKind;
		mItemDataType = InObject.mItemDataType;
		mRotY = InObject.mRotY;
		mEffectScale = InObject.mEffectScale;
		mpGmf = InObject.mpGmf;
		mpGmfEf = InObject.mpGmfEf;
		mVisible = InObject.mVisible;
		mScale = InObject.mScale;
		mActiveWait = InObject.mActiveWait;
		mMaai = InObject.mMaai;
		mRotSpeed = InObject.mRotSpeed;
		mPcHit = InObject.mPcHit;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<mHRItem, ghmListObj>("mHRItem")
			.addFunction("__tostring", &mHRItem::ToString)
			.addFunction("GetPtrAddr", &mHRItem::GetPtrAddr)
			.addProperty("mPos", &mHRItem::mPos)
			.addProperty("mKind", &mHRItem::mKind)
			.addProperty("mItemDataType", &mHRItem::mItemDataType)
			.addProperty("mRotY", &mHRItem::mRotY)
			.addProperty("mEffectScale", &mHRItem::mEffectScale)
			.addProperty("mpGmf", &mHRItem::mpGmf)
			.addProperty("mpGmfEf", &mHRItem::mpGmfEf)
			.addProperty("mVisible", &mHRItem::mVisible)
			.addProperty("mScale", &mHRItem::mScale)
			.addProperty("mActiveWait", &mHRItem::mActiveWait)
			.addProperty("mMaai", &mHRItem::mMaai)
			.addProperty("mRotSpeed", &mHRItem::mRotSpeed)
			.addProperty("mPcHit", &mHRItem::mPcHit)
			.addStaticFunction("mGetTop", &mHRItem::mGetTop)
			.addFunction("mGetNext", &mHRItem::mGetNext)
			.addFunction("mGetDrawDist", &mHRItem::mGetDrawDist)
			.addFunction("mRenderProc", &mHRItem::mRenderProc)
			.addFunction("mFrameProc", &mHRItem::mFrameProc)
			.addFunction("mPcCantGetItem", &mHRItem::mPcCantGetItem)
			.addFunction("mGetItemResource", &mHRItem::mGetItemResource)
			.addStaticFunction("mRenderProcAll", &mHRItem::mRenderProcAll)
			.addStaticFunction("mFrameProcAll", &mHRItem::mFrameProcAll)
			.addStaticFunction("mSetVisible", &mHRItem::mSetVisible)
			.addStaticFunction("mReleaseAll", &mHRItem::mReleaseAll)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRItem::mPos) == 12, "expected mHRItem::mPos to be size 12");
static_assert(sizeof(mHRItem::mKind) == 4, "expected mHRItem::mKind to be size 4");
static_assert(sizeof(mHRItem::mItemDataType) == 4, "expected mHRItem::mItemDataType to be size 4");
static_assert(sizeof(mHRItem::mRotY) == 4, "expected mHRItem::mRotY to be size 4");
static_assert(sizeof(mHRItem::mEffectScale) == 4, "expected mHRItem::mEffectScale to be size 4");
static_assert(sizeof(mHRItem::mpGmf) == 4, "expected mHRItem::mpGmf to be size 4");
static_assert(sizeof(mHRItem::mpGmfEf) == 4, "expected mHRItem::mpGmfEf to be size 4");
static_assert(sizeof(mHRItem::mVisible) == 1, "expected mHRItem::mVisible to be size 1");
static_assert(sizeof(mHRItem::mScale) == 32, "expected mHRItem::mScale to be size 32");
static_assert(sizeof(mHRItem::mActiveWait) == 4, "expected mHRItem::mActiveWait to be size 4");
static_assert(sizeof(mHRItem::mMaai) == 4, "expected mHRItem::mMaai to be size 4");
static_assert(sizeof(mHRItem::mRotSpeed) == 32, "expected mHRItem::mRotSpeed to be size 32");
static_assert(sizeof(mHRItem::mPcHit) == 1, "expected mHRItem::mPcHit to be size 1");
static_assert(sizeof(mHRItem) == 0x84, "expected mHRItem to be size 0x84");

// Unsupported operator
//void* __convention("thiscall") mHRItem::`vector deleting destructor'(class mHRItem* const this, uint32_t arg2)
// Unsupported constructor
//void __convention("thiscall") PJStateMachine::PJStateMachine(class PJStateMachine* const this, class PJZAKO* arg2)
// Unsupported operator
//void* __convention("thiscall") PJZAKO::`vector deleting destructor'(class PJZAKO* const this, uint32_t arg2)
// Unsupported constructor
//void __convention("thiscall") PJZAKO::ZakoInfo::ZakoInfo(struct PJZAKO::ZakoInfo* const this)
// Unsupported constructor
//void __convention("thiscall") PJZAKO::AiInfo::AiInfo(struct PJZAKO::AiInfo* const this)
// Can't export standard library
//void __convention("thiscall") FkStlList<class PJZAKO*>::remove(class FkStlList<PJZAKO *>* const this, class PJZAKO* arg2)
// Unsupported operator
//void* __convention("thiscall") pcSNB::`vector deleting destructor'(class pcSNB* const this, uint32_t arg2)
// Unsupported operator
//void* __convention("thiscall") pcHEN::`vector deleting destructor'(class pcHEN* const this, uint32_t arg2)
// [Structure] class PJZAKOBoneA
class PJZAKOBoneA : public PJZAKO
{
public:
	/// Struct member variables

	// <class PJZAKO field_0, offset 0x0>
	// class PJZAKO Super;

	/// 1 Functions

	// [Function] int32_t __convention("thiscall") PJZAKOBoneA::GetBoneMotMax(class PJZAKOBoneA* const this) [?GetBoneMotMax@PJZAKOBoneA@@UBEHXZ]
	typedef int32_t(__thiscall* _GetBoneMotMax_PJZAKOBoneA__UBEHXZ)(class PJZAKOBoneA* const thisPtr);
	int32_t GetBoneMotMax()
	{
		_GetBoneMotMax_PJZAKOBoneA__UBEHXZ mFunc = (_GetBoneMotMax_PJZAKOBoneA__UBEHXZ)(GameModule + 0xbfe20);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZAKOBoneA [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZAKOBoneA& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZAKOBoneA, PJZAKO>("PJZAKOBoneA")
			.addFunction("__tostring", &PJZAKOBoneA::ToString)
			.addFunction("GetPtrAddr", &PJZAKOBoneA::GetPtrAddr)
			.addFunction("GetBoneMotMax", &PJZAKOBoneA::GetBoneMotMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKOBoneA) == 0x9e4, "expected PJZAKOBoneA to be size 0x9e4");

// [Structure] class PJZAKOBoneB
class PJZAKOBoneB : public PJZAKO
{
public:
	/// Struct member variables

	// <class PJZAKO field_0, offset 0x0>
	// class PJZAKO Super;

	/// 2 Functions

	// [Function] int32_t __convention("thiscall") PJZAKOBoneB::GetBoneMotMax(class PJZAKOBoneB* const this) [?GetBoneMotMax@PJZAKOBoneB@@UBEHXZ]
	typedef int32_t(__thiscall* _GetBoneMotMax_PJZAKOBoneB__UBEHXZ)(class PJZAKOBoneB* const thisPtr);
	int32_t GetBoneMotMax()
	{
		_GetBoneMotMax_PJZAKOBoneB__UBEHXZ mFunc = (_GetBoneMotMax_PJZAKOBoneB__UBEHXZ)(GameModule + 0xc00f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") PJZAKOBoneB::SetDamageReactionBeforeFinishAttack(class PJZAKOBoneB* const this) [?SetDamageReactionBeforeFinishAttack@PJZAKOBoneB@@EAEXXZ]
	typedef void(__thiscall* _SetDamageReactionBeforeFinishAttack_PJZAKOBoneB__EAEXXZ)(class PJZAKOBoneB* const thisPtr);
	void SetDamageReactionBeforeFinishAttack()
	{
		_SetDamageReactionBeforeFinishAttack_PJZAKOBoneB__EAEXXZ mFunc = (_SetDamageReactionBeforeFinishAttack_PJZAKOBoneB__EAEXXZ)(GameModule + 0x623810);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZAKOBoneB [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZAKOBoneB& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZAKOBoneB, PJZAKO>("PJZAKOBoneB")
			.addFunction("__tostring", &PJZAKOBoneB::ToString)
			.addFunction("GetPtrAddr", &PJZAKOBoneB::GetPtrAddr)
			.addFunction("GetBoneMotMax", &PJZAKOBoneB::GetBoneMotMax)
			.addFunction("SetDamageReactionBeforeFinishAttack", &PJZAKOBoneB::SetDamageReactionBeforeFinishAttack)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKOBoneB) == 0x9e4, "expected PJZAKOBoneB to be size 0x9e4");

// [Structure] class State_StrongGlobal
class State_StrongGlobal : public State_Global
{
public:
	/// Struct member variables

	// <class State_Global field_0, offset 0x0>
	// class State_Global Super;

	/// 1 Functions

	// [Function] void __convention("thiscall") State_StrongGlobal::CheckEvacuateTiming(class State_StrongGlobal* const this, class PJZAKO* arg2) [?CheckEvacuateTiming@State_StrongGlobal@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _CheckEvacuateTiming_State_StrongGlobal__UAEXPAVPJZAKO___Z)(class State_StrongGlobal* const thisPtr, class PJZAKO* arg2);
	void CheckEvacuateTiming(class PJZAKO* arg2)
	{
		_CheckEvacuateTiming_State_StrongGlobal__UAEXPAVPJZAKO___Z mFunc = (_CheckEvacuateTiming_State_StrongGlobal__UAEXPAVPJZAKO___Z)(GameModule + 0x6239d0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_StrongGlobal [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_StrongGlobal& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_StrongGlobal, State_Global>("State_StrongGlobal")
			.addFunction("__tostring", &State_StrongGlobal::ToString)
			.addFunction("GetPtrAddr", &State_StrongGlobal::GetPtrAddr)
			.addFunction("CheckEvacuateTiming", &State_StrongGlobal::CheckEvacuateTiming)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_StrongGlobal) == 0x4, "expected State_StrongGlobal to be size 0x4");

// [Structure] class ZkState_ChainSaw_Global
class ZkState_ChainSaw_Global : public State_Global
{
public:
	/// Struct member variables

	// <class State_Global field_0, offset 0x0>
	// class State_Global Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") ZkState_ChainSaw_Global::Exit(class ZkState_ChainSaw_Global* const this, class PJZAKO* arg2) [?Exit@ZkState_ChainSaw_Global@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z)(class ZkState_ChainSaw_Global* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z)(GameModule + 0x500c80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_ChainSaw_Global::ChangeStateCondition(class ZkState_ChainSaw_Global* const this, class PJZAKO* arg2) [?ChangeStateCondition@ZkState_ChainSaw_Global@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_ZkState_ChainSaw_Global__QAEXPAVPJZAKO___Z)(class ZkState_ChainSaw_Global* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_ZkState_ChainSaw_Global__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_ZkState_ChainSaw_Global__QAEXPAVPJZAKO___Z)(GameModule + 0x500c90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_ChainSaw_Global::Execute(class ZkState_ChainSaw_Global* const this, class PJZAKO* arg2) [?Execute@ZkState_ChainSaw_Global@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z)(class ZkState_ChainSaw_Global* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z)(GameModule + 0x500ca0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_ChainSaw_Global::Enter(class ZkState_ChainSaw_Global* const this, class PJZAKO* arg2) [?Enter@ZkState_ChainSaw_Global@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z)(class ZkState_ChainSaw_Global* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_ChainSaw_Global__UAEXPAVPJZAKO___Z)(GameModule + 0x500cb0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_ChainSaw_Global [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_ChainSaw_Global& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_ChainSaw_Global, State_Global>("ZkState_ChainSaw_Global")
			.addFunction("__tostring", &ZkState_ChainSaw_Global::ToString)
			.addFunction("GetPtrAddr", &ZkState_ChainSaw_Global::GetPtrAddr)
			.addFunction("Exit", &ZkState_ChainSaw_Global::Exit)
			.addFunction("ChangeStateCondition", &ZkState_ChainSaw_Global::ChangeStateCondition)
			.addFunction("Execute", &ZkState_ChainSaw_Global::Execute)
			.addFunction("Enter", &ZkState_ChainSaw_Global::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_ChainSaw_Global) == 0x4, "expected ZkState_ChainSaw_Global to be size 0x4");

// [Structure] class PJZAKOBoneC
class PJZAKOBoneC : public PJZAKO
{
public:
	/// Struct member variables

	// <class PJZAKO field_0, offset 0x0>
	// class PJZAKO Super;

	// <class State_StrongGlobal m_GlobalState, offset 0x9e4>
	class State_StrongGlobal m_GlobalState;

	/// 4 Functions

	// [Function] int32_t __convention("thiscall") PJZAKOBoneC::GetBoneMotMax(class PJZAKOBoneC* const this) [?GetBoneMotMax@PJZAKOBoneC@@UBEHXZ]
	typedef int32_t(__thiscall* _GetBoneMotMax_PJZAKOBoneC__UBEHXZ)(class PJZAKOBoneC* const thisPtr);
	int32_t GetBoneMotMax()
	{
		_GetBoneMotMax_PJZAKOBoneC__UBEHXZ mFunc = (_GetBoneMotMax_PJZAKOBoneC__UBEHXZ)(GameModule + 0xc0310);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneC::mInit(class PJZAKOBoneC* const this) [?mInit@PJZAKOBoneC@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mInit_PJZAKOBoneC__UAE_NXZ)(class PJZAKOBoneC* const thisPtr);
	uint8_t mInit()
	{
		_mInit_PJZAKOBoneC__UAE_NXZ mFunc = (_mInit_PJZAKOBoneC__UAE_NXZ)(GameModule + 0x623920);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneC::IsNoStateChangeDamage(class PJZAKOBoneC* const this) [?IsNoStateChangeDamage@PJZAKOBoneC@@EAE_NXZ]
	typedef uint8_t(__thiscall* _IsNoStateChangeDamage_PJZAKOBoneC__EAE_NXZ)(class PJZAKOBoneC* const thisPtr);
	uint8_t IsNoStateChangeDamage()
	{
		_IsNoStateChangeDamage_PJZAKOBoneC__EAE_NXZ mFunc = (_IsNoStateChangeDamage_PJZAKOBoneC__EAE_NXZ)(GameModule + 0x623940);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKOBoneC::mGetBodyTouchFloorTick(class PJZAKOBoneC* const this, int32_t arg2) [?mGetBodyTouchFloorTick@PJZAKOBoneC@@EAEHH@Z]
	typedef int32_t(__thiscall* _mGetBodyTouchFloorTick_PJZAKOBoneC__EAEHH_Z)(class PJZAKOBoneC* const thisPtr, int32_t arg2);
	int32_t mGetBodyTouchFloorTick(int32_t arg2)
	{
		_mGetBodyTouchFloorTick_PJZAKOBoneC__EAEHH_Z mFunc = (_mGetBodyTouchFloorTick_PJZAKOBoneC__EAEHH_Z)(GameModule + 0x623970);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZAKOBoneC [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZAKOBoneC& InObject)
	{
		m_GlobalState = InObject.m_GlobalState;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZAKOBoneC, PJZAKO>("PJZAKOBoneC")
			.addFunction("__tostring", &PJZAKOBoneC::ToString)
			.addFunction("GetPtrAddr", &PJZAKOBoneC::GetPtrAddr)
			.addProperty("m_GlobalState", &PJZAKOBoneC::m_GlobalState)
			.addFunction("GetBoneMotMax", &PJZAKOBoneC::GetBoneMotMax)
			.addFunction("mInit", &PJZAKOBoneC::mInit)
			.addFunction("IsNoStateChangeDamage", &PJZAKOBoneC::IsNoStateChangeDamage)
			.addFunction("mGetBodyTouchFloorTick", &PJZAKOBoneC::mGetBodyTouchFloorTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKOBoneC::m_GlobalState) == 4, "expected PJZAKOBoneC::m_GlobalState to be size 4");
static_assert(sizeof(PJZAKOBoneC) == 0x9e8, "expected PJZAKOBoneC to be size 0x9e8");

// [Structure] class State_FatTojo_EatPizza
class State_FatTojo_EatPizza : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <uint8_t m_boThroughPizza, offset 0x4>
	uint8_t m_boThroughPizza = 0;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	/// 4 Functions

	// [Function] void __convention("thiscall") State_FatTojo_EatPizza::Exit(class State_FatTojo_EatPizza* const this, class PJZAKO* arg2) [?Exit@State_FatTojo_EatPizza@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z)(class State_FatTojo_EatPizza* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z)(GameModule + 0x6242f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_FatTojo_EatPizza::ChangeStateCondition(class State_FatTojo_EatPizza* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_FatTojo_EatPizza@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z)(class State_FatTojo_EatPizza* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z)(GameModule + 0x624340);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_FatTojo_EatPizza::Execute(class State_FatTojo_EatPizza* const this, class PJZAKO* arg2) [?Execute@State_FatTojo_EatPizza@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z)(class State_FatTojo_EatPizza* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z)(GameModule + 0x624350);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_FatTojo_EatPizza::Enter(class State_FatTojo_EatPizza* const this, class PJZAKO* arg2) [?Enter@State_FatTojo_EatPizza@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z)(class State_FatTojo_EatPizza* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_FatTojo_EatPizza__UAEXPAVPJZAKO___Z)(GameModule + 0x624500);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_FatTojo_EatPizza [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_FatTojo_EatPizza& InObject)
	{
		m_boThroughPizza = InObject.m_boThroughPizza;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_FatTojo_EatPizza, State_TojoBaseState>("State_FatTojo_EatPizza")
			.addFunction("__tostring", &State_FatTojo_EatPizza::ToString)
			.addFunction("GetPtrAddr", &State_FatTojo_EatPizza::GetPtrAddr)
			.addProperty("m_boThroughPizza", &State_FatTojo_EatPizza::m_boThroughPizza)
			.addFunction("Exit", &State_FatTojo_EatPizza::Exit)
			.addFunction("ChangeStateCondition", &State_FatTojo_EatPizza::ChangeStateCondition)
			.addFunction("Execute", &State_FatTojo_EatPizza::Execute)
			.addFunction("Enter", &State_FatTojo_EatPizza::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_FatTojo_EatPizza::m_boThroughPizza) == 1, "expected State_FatTojo_EatPizza::m_boThroughPizza to be size 1");
static_assert(sizeof(State_FatTojo_EatPizza) == 0x8, "expected State_FatTojo_EatPizza to be size 0x8");

// [Structure] class PJZAKOBoneD
class PJZAKOBoneD : public PJZAKO
{
public:
	/// Struct member variables

	// <class PJZAKO field_0, offset 0x0>
	// class PJZAKO Super;

	// <class State_FatTojo_EatPizza m_State_TjEatPizza, offset 0x9e4>
	class State_FatTojo_EatPizza m_State_TjEatPizza;

	// <class TGmf* m_pPizzaGmf[0x2], offset 0x9ec>
	class TGmf* m_pPizzaGmf[2];

	/// 15 Functions

	// [Function] int32_t __convention("thiscall") PJZAKOBoneD::GetBoneMotMax(class PJZAKOBoneD* const this) [?GetBoneMotMax@PJZAKOBoneD@@UBEHXZ]
	typedef int32_t(__thiscall* _GetBoneMotMax_PJZAKOBoneD__UBEHXZ)(class PJZAKOBoneD* const thisPtr);
	int32_t GetBoneMotMax()
	{
		_GetBoneMotMax_PJZAKOBoneD__UBEHXZ mFunc = (_GetBoneMotMax_PJZAKOBoneD__UBEHXZ)(GameModule + 0xc0610);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKOBoneD::GetWakeUpReactMotionNo(class PJZAKOBoneD* const this, int32_t arg2) [?GetWakeUpReactMotionNo@PJZAKOBoneD@@UAEHH@Z]
	typedef int32_t(__thiscall* _GetWakeUpReactMotionNo_PJZAKOBoneD__UAEHH_Z)(class PJZAKOBoneD* const thisPtr, int32_t arg2);
	int32_t GetWakeUpReactMotionNo(int32_t arg2)
	{
		_GetWakeUpReactMotionNo_PJZAKOBoneD__UAEHH_Z mFunc = (_GetWakeUpReactMotionNo_PJZAKOBoneD__UAEHH_Z)(GameModule + 0xc0620);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKOBoneD::SetThroughPizza(class PJZAKOBoneD* const this) [?SetThroughPizza@PJZAKOBoneD@@AAEXXZ]
	typedef void(__thiscall* _SetThroughPizza_PJZAKOBoneD__AAEXXZ)(class PJZAKOBoneD* const thisPtr);
	void SetThroughPizza()
	{
		_SetThroughPizza_PJZAKOBoneD__AAEXXZ mFunc = (_SetThroughPizza_PJZAKOBoneD__AAEXXZ)(GameModule + 0x623ac0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::PizzaModelRender(class PJZAKOBoneD* const this) [?PizzaModelRender@PJZAKOBoneD@@AAE_NXZ]
	typedef uint8_t(__thiscall* _PizzaModelRender_PJZAKOBoneD__AAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t PizzaModelRender()
	{
		_PizzaModelRender_PJZAKOBoneD__AAE_NXZ mFunc = (_PizzaModelRender_PJZAKOBoneD__AAE_NXZ)(GameModule + 0x623b80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::PizzaModelProc(class PJZAKOBoneD* const this) [?PizzaModelProc@PJZAKOBoneD@@AAE_NXZ]
	typedef uint8_t(__thiscall* _PizzaModelProc_PJZAKOBoneD__AAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t PizzaModelProc()
	{
		_PizzaModelProc_PJZAKOBoneD__AAE_NXZ mFunc = (_PizzaModelProc_PJZAKOBoneD__AAE_NXZ)(GameModule + 0x623f30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::DestroyPizzaModel(class PJZAKOBoneD* const this) [?DestroyPizzaModel@PJZAKOBoneD@@AAE_NXZ]
	typedef uint8_t(__thiscall* _DestroyPizzaModel_PJZAKOBoneD__AAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t DestroyPizzaModel()
	{
		_DestroyPizzaModel_PJZAKOBoneD__AAE_NXZ mFunc = (_DestroyPizzaModel_PJZAKOBoneD__AAE_NXZ)(GameModule + 0x623f80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::CreatePizzaModel(class PJZAKOBoneD* const this) [?CreatePizzaModel@PJZAKOBoneD@@AAE_NXZ]
	typedef uint8_t(__thiscall* _CreatePizzaModel_PJZAKOBoneD__AAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t CreatePizzaModel()
	{
		_CreatePizzaModel_PJZAKOBoneD__AAE_NXZ mFunc = (_CreatePizzaModel_PJZAKOBoneD__AAE_NXZ)(GameModule + 0x624210);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::mInit(class PJZAKOBoneD* const this) [?mInit@PJZAKOBoneD@@MAE_NXZ]
	typedef uint8_t(__thiscall* _mInit_PJZAKOBoneD__MAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t mInit()
	{
		_mInit_PJZAKOBoneD__MAE_NXZ mFunc = (_mInit_PJZAKOBoneD__MAE_NXZ)(GameModule + 0x624830);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::mPostFrameCommonProc2(class PJZAKOBoneD* const this) [?mPostFrameCommonProc2@PJZAKOBoneD@@MAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameCommonProc2_PJZAKOBoneD__MAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t mPostFrameCommonProc2()
	{
		_mPostFrameCommonProc2_PJZAKOBoneD__MAE_NXZ mFunc = (_mPostFrameCommonProc2_PJZAKOBoneD__MAE_NXZ)(GameModule + 0x624840);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::mRenderProc(class PJZAKOBoneD* const this) [?mRenderProc@PJZAKOBoneD@@EAE_NXZ]
	typedef uint8_t(__thiscall* _mRenderProc_PJZAKOBoneD__EAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t mRenderProc()
	{
		_mRenderProc_PJZAKOBoneD__EAE_NXZ mFunc = (_mRenderProc_PJZAKOBoneD__EAE_NXZ)(GameModule + 0x624a00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::SetEvacuate(class PJZAKOBoneD* const this, enum eEvacuateDir arg2) [?SetEvacuate@PJZAKOBoneD@@UAE_NW4eEvacuateDir@@@Z]
	typedef uint8_t(__thiscall* _SetEvacuate_PJZAKOBoneD__UAE_NW4eEvacuateDir___Z)(class PJZAKOBoneD* const thisPtr, enum eEvacuateDir arg2);
	uint8_t SetEvacuate(/* enum eEvacuateDir */ uint32_t arg2)
	{
		_SetEvacuate_PJZAKOBoneD__UAE_NW4eEvacuateDir___Z mFunc = (_SetEvacuate_PJZAKOBoneD__UAE_NW4eEvacuateDir___Z)(GameModule + 0x624a30);
		return mFunc(this, (enum eEvacuateDir)arg2);
	}
	// [Function] void __convention("thiscall") PJZAKOBoneD::InitStateMachine(class PJZAKOBoneD* const this) [?InitStateMachine@PJZAKOBoneD@@MAEXXZ]
	typedef void(__thiscall* _InitStateMachine_PJZAKOBoneD__MAEXXZ)(class PJZAKOBoneD* const thisPtr);
	void InitStateMachine()
	{
		_InitStateMachine_PJZAKOBoneD__MAEXXZ mFunc = (_InitStateMachine_PJZAKOBoneD__MAEXXZ)(GameModule + 0x624a40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::IsAccumDmgAttackTiming(class PJZAKOBoneD* const this) [?IsAccumDmgAttackTiming@PJZAKOBoneD@@EAE_NXZ]
	typedef uint8_t(__thiscall* _IsAccumDmgAttackTiming_PJZAKOBoneD__EAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t IsAccumDmgAttackTiming()
	{
		_IsAccumDmgAttackTiming_PJZAKOBoneD__EAE_NXZ mFunc = (_IsAccumDmgAttackTiming_PJZAKOBoneD__EAE_NXZ)(GameModule + 0x624a60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKOBoneD::IsNoStateChangeDamage(class PJZAKOBoneD* const this) [?IsNoStateChangeDamage@PJZAKOBoneD@@EAE_NXZ]
	typedef uint8_t(__thiscall* _IsNoStateChangeDamage_PJZAKOBoneD__EAE_NXZ)(class PJZAKOBoneD* const thisPtr);
	uint8_t IsNoStateChangeDamage()
	{
		_IsNoStateChangeDamage_PJZAKOBoneD__EAE_NXZ mFunc = (_IsNoStateChangeDamage_PJZAKOBoneD__EAE_NXZ)(GameModule + 0x624aa0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKOBoneD::mGetBodyTouchFloorTick(class PJZAKOBoneD* const this, int32_t arg2) [?mGetBodyTouchFloorTick@PJZAKOBoneD@@EAEHH@Z]
	typedef int32_t(__thiscall* _mGetBodyTouchFloorTick_PJZAKOBoneD__EAEHH_Z)(class PJZAKOBoneD* const thisPtr, int32_t arg2);
	int32_t mGetBodyTouchFloorTick(int32_t arg2)
	{
		_mGetBodyTouchFloorTick_PJZAKOBoneD__EAEHH_Z mFunc = (_mGetBodyTouchFloorTick_PJZAKOBoneD__EAEHH_Z)(GameModule + 0x624ad0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZAKOBoneD [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZAKOBoneD& InObject)
	{
		m_State_TjEatPizza = InObject.m_State_TjEatPizza;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZAKOBoneD, PJZAKO>("PJZAKOBoneD")
			.addFunction("__tostring", &PJZAKOBoneD::ToString)
			.addFunction("GetPtrAddr", &PJZAKOBoneD::GetPtrAddr)
			.addProperty("m_State_TjEatPizza", &PJZAKOBoneD::m_State_TjEatPizza)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pPizzaGmf", &PJZAKOBoneD::m_pPizzaGmf)
			.addFunction("GetBoneMotMax", &PJZAKOBoneD::GetBoneMotMax)
			.addFunction("GetWakeUpReactMotionNo", &PJZAKOBoneD::GetWakeUpReactMotionNo)
			.addFunction("SetThroughPizza", &PJZAKOBoneD::SetThroughPizza)
			.addFunction("PizzaModelRender", &PJZAKOBoneD::PizzaModelRender)
			.addFunction("PizzaModelProc", &PJZAKOBoneD::PizzaModelProc)
			.addFunction("DestroyPizzaModel", &PJZAKOBoneD::DestroyPizzaModel)
			.addFunction("CreatePizzaModel", &PJZAKOBoneD::CreatePizzaModel)
			.addFunction("mInit", &PJZAKOBoneD::mInit)
			.addFunction("mPostFrameCommonProc2", &PJZAKOBoneD::mPostFrameCommonProc2)
			.addFunction("mRenderProc", &PJZAKOBoneD::mRenderProc)
			.addFunction("SetEvacuate", &PJZAKOBoneD::SetEvacuate)
			.addFunction("InitStateMachine", &PJZAKOBoneD::InitStateMachine)
			.addFunction("IsAccumDmgAttackTiming", &PJZAKOBoneD::IsAccumDmgAttackTiming)
			.addFunction("IsNoStateChangeDamage", &PJZAKOBoneD::IsNoStateChangeDamage)
			.addFunction("mGetBodyTouchFloorTick", &PJZAKOBoneD::mGetBodyTouchFloorTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKOBoneD::m_State_TjEatPizza) == 8, "expected PJZAKOBoneD::m_State_TjEatPizza to be size 8");
static_assert(sizeof(PJZAKOBoneD::m_pPizzaGmf) == 8, "expected PJZAKOBoneD::m_pPizzaGmf to be size 8");
static_assert(sizeof(PJZAKOBoneD) == 0x9f4, "expected PJZAKOBoneD to be size 0x9f4");

// [Structure] class KrBaseState<bsBasic>
template<typename T>
class KrBaseState
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x7], offset 0x0>
	void* (* field_0)[0x7];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class KrBaseState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(KrBaseState<bsBasic>& InObject)
	{
	}
	// Exporting templated types to Lua currently not supported.
	// static void BindLua(luabridge::Namespace& NS)
};
static_assert(sizeof(KrBaseState<bsBasic>::field_0) == 4, "expected KrBaseState<bsBasic>::field_0 to be size 4");
static_assert(sizeof(KrBaseState<bsBasic>) == 0x4, "expected KrBaseState<bsBasic> to be size 0x4");

// [Structure] class GLBDeathState
class GLBDeathState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <int32_t mExpCnt, offset 0x4>
	int32_t mExpCnt = 0;

	/// 4 Functions

	// [Function] void __convention("thiscall") GLBDeathState::ChangeStateCondition(class GLBDeathState* const this, class pcGLB* arg2) [?ChangeStateCondition@GLBDeathState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_GLBDeathState__UAEXPAVpcGLB___Z)(class GLBDeathState* const thisPtr, class pcGLB* arg2);
	void ChangeStateCondition(class pcGLB* arg2)
	{
		_ChangeStateCondition_GLBDeathState__UAEXPAVpcGLB___Z mFunc = (_ChangeStateCondition_GLBDeathState__UAEXPAVpcGLB___Z)(GameModule + 0x54cfb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBDeathState::Exit(class GLBDeathState* const this, class pcGLB* arg2) [?Exit@GLBDeathState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Exit_GLBDeathState__UAEXPAVpcGLB___Z)(class GLBDeathState* const thisPtr, class pcGLB* arg2);
	void Exit(class pcGLB* arg2)
	{
		_Exit_GLBDeathState__UAEXPAVpcGLB___Z mFunc = (_Exit_GLBDeathState__UAEXPAVpcGLB___Z)(GameModule + 0x54cfc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBDeathState::Execute(class GLBDeathState* const this, class pcGLB* arg2) [?Execute@GLBDeathState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Execute_GLBDeathState__UAEXPAVpcGLB___Z)(class GLBDeathState* const thisPtr, class pcGLB* arg2);
	void Execute(class pcGLB* arg2)
	{
		_Execute_GLBDeathState__UAEXPAVpcGLB___Z mFunc = (_Execute_GLBDeathState__UAEXPAVpcGLB___Z)(GameModule + 0x54cfd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBDeathState::Enter(class GLBDeathState* const this, class pcGLB* arg2) [?Enter@GLBDeathState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Enter_GLBDeathState__UAEXPAVpcGLB___Z)(class GLBDeathState* const thisPtr, class pcGLB* arg2);
	void Enter(class pcGLB* arg2)
	{
		_Enter_GLBDeathState__UAEXPAVpcGLB___Z mFunc = (_Enter_GLBDeathState__UAEXPAVpcGLB___Z)(GameModule + 0x54cfe0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GLBDeathState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GLBDeathState& InObject)
	{
		mExpCnt = InObject.mExpCnt;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBDeathState>("GLBDeathState")
			.addFunction("__tostring", &GLBDeathState::ToString)
			.addFunction("GetPtrAddr", &GLBDeathState::GetPtrAddr)
			.addProperty("mExpCnt", &GLBDeathState::mExpCnt)
			.addFunction("ChangeStateCondition", &GLBDeathState::ChangeStateCondition)
			.addFunction("Exit", &GLBDeathState::Exit)
			.addFunction("Execute", &GLBDeathState::Execute)
			.addFunction("Enter", &GLBDeathState::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBDeathState::mExpCnt) == 4, "expected GLBDeathState::mExpCnt to be size 4");
static_assert(sizeof(GLBDeathState) == 0x8, "expected GLBDeathState to be size 0x8");

// [Structure] class GLBWalkState
class GLBWalkState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") GLBWalkState::ChangeStateCondition(class GLBWalkState* const this, class pcGLB* arg2) [?ChangeStateCondition@GLBWalkState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_GLBWalkState__UAEXPAVpcGLB___Z)(class GLBWalkState* const thisPtr, class pcGLB* arg2);
	void ChangeStateCondition(class pcGLB* arg2)
	{
		_ChangeStateCondition_GLBWalkState__UAEXPAVpcGLB___Z mFunc = (_ChangeStateCondition_GLBWalkState__UAEXPAVpcGLB___Z)(GameModule + 0x54dab0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBWalkState::Exit(class GLBWalkState* const this, class pcGLB* arg2) [?Exit@GLBWalkState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Exit_GLBWalkState__UAEXPAVpcGLB___Z)(class GLBWalkState* const thisPtr, class pcGLB* arg2);
	void Exit(class pcGLB* arg2)
	{
		_Exit_GLBWalkState__UAEXPAVpcGLB___Z mFunc = (_Exit_GLBWalkState__UAEXPAVpcGLB___Z)(GameModule + 0x54daf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBWalkState::Execute(class GLBWalkState* const this, class pcGLB* arg2) [?Execute@GLBWalkState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Execute_GLBWalkState__UAEXPAVpcGLB___Z)(class GLBWalkState* const thisPtr, class pcGLB* arg2);
	void Execute(class pcGLB* arg2)
	{
		_Execute_GLBWalkState__UAEXPAVpcGLB___Z mFunc = (_Execute_GLBWalkState__UAEXPAVpcGLB___Z)(GameModule + 0x54db00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBWalkState::Enter(class GLBWalkState* const this, class pcGLB* arg2) [?Enter@GLBWalkState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Enter_GLBWalkState__UAEXPAVpcGLB___Z)(class GLBWalkState* const thisPtr, class pcGLB* arg2);
	void Enter(class pcGLB* arg2)
	{
		_Enter_GLBWalkState__UAEXPAVpcGLB___Z mFunc = (_Enter_GLBWalkState__UAEXPAVpcGLB___Z)(GameModule + 0x54db10);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GLBWalkState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GLBWalkState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBWalkState>("GLBWalkState")
			.addFunction("__tostring", &GLBWalkState::ToString)
			.addFunction("GetPtrAddr", &GLBWalkState::GetPtrAddr)
			.addFunction("ChangeStateCondition", &GLBWalkState::ChangeStateCondition)
			.addFunction("Exit", &GLBWalkState::Exit)
			.addFunction("Execute", &GLBWalkState::Execute)
			.addFunction("Enter", &GLBWalkState::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBWalkState) == 0x4, "expected GLBWalkState to be size 0x4");

// [Structure] class GLBComboState
class GLBComboState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <uint8_t mbCancel, offset 0x4>
	uint8_t mbCancel = 0;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	/// 4 Functions

	// [Function] void __convention("thiscall") GLBComboState::ChangeStateCondition(class GLBComboState* const this, class pcGLB* arg2) [?ChangeStateCondition@GLBComboState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_GLBComboState__UAEXPAVpcGLB___Z)(class GLBComboState* const thisPtr, class pcGLB* arg2);
	void ChangeStateCondition(class pcGLB* arg2)
	{
		_ChangeStateCondition_GLBComboState__UAEXPAVpcGLB___Z mFunc = (_ChangeStateCondition_GLBComboState__UAEXPAVpcGLB___Z)(GameModule + 0x54d320);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBComboState::Exit(class GLBComboState* const this, class pcGLB* arg2) [?Exit@GLBComboState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Exit_GLBComboState__UAEXPAVpcGLB___Z)(class GLBComboState* const thisPtr, class pcGLB* arg2);
	void Exit(class pcGLB* arg2)
	{
		_Exit_GLBComboState__UAEXPAVpcGLB___Z mFunc = (_Exit_GLBComboState__UAEXPAVpcGLB___Z)(GameModule + 0x54d390);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBComboState::Execute(class GLBComboState* const this, class pcGLB* arg2) [?Execute@GLBComboState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Execute_GLBComboState__UAEXPAVpcGLB___Z)(class GLBComboState* const thisPtr, class pcGLB* arg2);
	void Execute(class pcGLB* arg2)
	{
		_Execute_GLBComboState__UAEXPAVpcGLB___Z mFunc = (_Execute_GLBComboState__UAEXPAVpcGLB___Z)(GameModule + 0x54d3a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBComboState::Enter(class GLBComboState* const this, class pcGLB* arg2) [?Enter@GLBComboState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Enter_GLBComboState__UAEXPAVpcGLB___Z)(class GLBComboState* const thisPtr, class pcGLB* arg2);
	void Enter(class pcGLB* arg2)
	{
		_Enter_GLBComboState__UAEXPAVpcGLB___Z mFunc = (_Enter_GLBComboState__UAEXPAVpcGLB___Z)(GameModule + 0x54d460);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GLBComboState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GLBComboState& InObject)
	{
		mbCancel = InObject.mbCancel;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBComboState>("GLBComboState")
			.addFunction("__tostring", &GLBComboState::ToString)
			.addFunction("GetPtrAddr", &GLBComboState::GetPtrAddr)
			.addProperty("mbCancel", &GLBComboState::mbCancel)
			.addFunction("ChangeStateCondition", &GLBComboState::ChangeStateCondition)
			.addFunction("Exit", &GLBComboState::Exit)
			.addFunction("Execute", &GLBComboState::Execute)
			.addFunction("Enter", &GLBComboState::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBComboState::mbCancel) == 1, "expected GLBComboState::mbCancel to be size 1");
static_assert(sizeof(GLBComboState) == 0x8, "expected GLBComboState to be size 0x8");

// [Structure] class GLBIdleState
class GLBIdleState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") GLBIdleState::ChangeStateCondition(class GLBIdleState* const this, class pcGLB* arg2) [?ChangeStateCondition@GLBIdleState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_GLBIdleState__UAEXPAVpcGLB___Z)(class GLBIdleState* const thisPtr, class pcGLB* arg2);
	void ChangeStateCondition(class pcGLB* arg2)
	{
		_ChangeStateCondition_GLBIdleState__UAEXPAVpcGLB___Z mFunc = (_ChangeStateCondition_GLBIdleState__UAEXPAVpcGLB___Z)(GameModule + 0x54d0b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBIdleState::Exit(class GLBIdleState* const this, class pcGLB* arg2) [?Exit@GLBIdleState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Exit_GLBIdleState__UAEXPAVpcGLB___Z)(class GLBIdleState* const thisPtr, class pcGLB* arg2);
	void Exit(class pcGLB* arg2)
	{
		_Exit_GLBIdleState__UAEXPAVpcGLB___Z mFunc = (_Exit_GLBIdleState__UAEXPAVpcGLB___Z)(GameModule + 0x54d0c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBIdleState::Execute(class GLBIdleState* const this, class pcGLB* arg2) [?Execute@GLBIdleState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Execute_GLBIdleState__UAEXPAVpcGLB___Z)(class GLBIdleState* const thisPtr, class pcGLB* arg2);
	void Execute(class pcGLB* arg2)
	{
		_Execute_GLBIdleState__UAEXPAVpcGLB___Z mFunc = (_Execute_GLBIdleState__UAEXPAVpcGLB___Z)(GameModule + 0x54d0d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBIdleState::Enter(class GLBIdleState* const this, class pcGLB* arg2) [?Enter@GLBIdleState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Enter_GLBIdleState__UAEXPAVpcGLB___Z)(class GLBIdleState* const thisPtr, class pcGLB* arg2);
	void Enter(class pcGLB* arg2)
	{
		_Enter_GLBIdleState__UAEXPAVpcGLB___Z mFunc = (_Enter_GLBIdleState__UAEXPAVpcGLB___Z)(GameModule + 0x54d0e0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GLBIdleState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GLBIdleState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBIdleState>("GLBIdleState")
			.addFunction("__tostring", &GLBIdleState::ToString)
			.addFunction("GetPtrAddr", &GLBIdleState::GetPtrAddr)
			.addFunction("ChangeStateCondition", &GLBIdleState::ChangeStateCondition)
			.addFunction("Exit", &GLBIdleState::Exit)
			.addFunction("Execute", &GLBIdleState::Execute)
			.addFunction("Enter", &GLBIdleState::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBIdleState) == 0x4, "expected GLBIdleState to be size 0x4");

// [Structure] class GLBJampState
class GLBJampState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <int32_t JumpTick, offset 0x4>
	int32_t JumpTick = 0;

	/// 5 Functions

	// [Function] void __convention("thiscall") GLBJampState::MoveProc(class GLBJampState* const this, class pcGLB* arg2) [?MoveProc@GLBJampState@@QAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _MoveProc_GLBJampState__QAEXPAVpcGLB___Z)(class GLBJampState* const thisPtr, class pcGLB* arg2);
	void MoveProc(class pcGLB* arg2)
	{
		_MoveProc_GLBJampState__QAEXPAVpcGLB___Z mFunc = (_MoveProc_GLBJampState__QAEXPAVpcGLB___Z)(GameModule + 0x54d850);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBJampState::ChangeStateCondition(class GLBJampState* const this, class pcGLB* arg2) [?ChangeStateCondition@GLBJampState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_GLBJampState__UAEXPAVpcGLB___Z)(class GLBJampState* const thisPtr, class pcGLB* arg2);
	void ChangeStateCondition(class pcGLB* arg2)
	{
		_ChangeStateCondition_GLBJampState__UAEXPAVpcGLB___Z mFunc = (_ChangeStateCondition_GLBJampState__UAEXPAVpcGLB___Z)(GameModule + 0x54d8e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBJampState::Exit(class GLBJampState* const this, class pcGLB* arg2) [?Exit@GLBJampState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Exit_GLBJampState__UAEXPAVpcGLB___Z)(class GLBJampState* const thisPtr, class pcGLB* arg2);
	void Exit(class pcGLB* arg2)
	{
		_Exit_GLBJampState__UAEXPAVpcGLB___Z mFunc = (_Exit_GLBJampState__UAEXPAVpcGLB___Z)(GameModule + 0x54d920);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBJampState::Execute(class GLBJampState* const this, class pcGLB* arg2) [?Execute@GLBJampState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Execute_GLBJampState__UAEXPAVpcGLB___Z)(class GLBJampState* const thisPtr, class pcGLB* arg2);
	void Execute(class pcGLB* arg2)
	{
		_Execute_GLBJampState__UAEXPAVpcGLB___Z mFunc = (_Execute_GLBJampState__UAEXPAVpcGLB___Z)(GameModule + 0x54d930);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBJampState::Enter(class GLBJampState* const this, class pcGLB* arg2) [?Enter@GLBJampState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Enter_GLBJampState__UAEXPAVpcGLB___Z)(class GLBJampState* const thisPtr, class pcGLB* arg2);
	void Enter(class pcGLB* arg2)
	{
		_Enter_GLBJampState__UAEXPAVpcGLB___Z mFunc = (_Enter_GLBJampState__UAEXPAVpcGLB___Z)(GameModule + 0x54da50);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GLBJampState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GLBJampState& InObject)
	{
		JumpTick = InObject.JumpTick;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBJampState>("GLBJampState")
			.addFunction("__tostring", &GLBJampState::ToString)
			.addFunction("GetPtrAddr", &GLBJampState::GetPtrAddr)
			.addProperty("JumpTick", &GLBJampState::JumpTick)
			.addFunction("MoveProc", &GLBJampState::MoveProc)
			.addFunction("ChangeStateCondition", &GLBJampState::ChangeStateCondition)
			.addFunction("Exit", &GLBJampState::Exit)
			.addFunction("Execute", &GLBJampState::Execute)
			.addFunction("Enter", &GLBJampState::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBJampState::JumpTick) == 4, "expected GLBJampState::JumpTick to be size 4");
static_assert(sizeof(GLBJampState) == 0x8, "expected GLBJampState to be size 0x8");

// [Structure] class KrStateMachine<pcGLB,32>
template<typename T1, int T2>
class KrStateMachine
{
public:
	/// Struct member variables

	// <class pcGLB* mpOwner, offset 0x0>
	T1* mpOwner = nullptr;

	// <int32_t mpCurrentIdx, offset 0x4>
	int32_t mpCurrentIdx = 0;

	// <int32_t mpPreviousIdx, offset 0x8>
	int32_t mpPreviousIdx = 0;

	// <int32_t mpGlobalIdx, offset 0xc>
	int32_t mpGlobalIdx = 0;

	// <class KrBaseState<pcGLB>* mpState[0x20], offset 0x10>
	class KrBaseState<T1>* mpState[T2];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class KrStateMachine [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(KrStateMachine<pcGLB,32>& InObject)
	{
		mpOwner = InObject.mpOwner;
		mpCurrentIdx = InObject.mpCurrentIdx;
		mpPreviousIdx = InObject.mpPreviousIdx;
		mpGlobalIdx = InObject.mpGlobalIdx;
	}
	// Exporting templated types to Lua currently not supported.
	// static void BindLua(luabridge::Namespace& NS)
};
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpOwner) == 4, "expected KrStateMachine<pcGLB,32>::mpOwner to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpCurrentIdx) == 4, "expected KrStateMachine<pcGLB,32>::mpCurrentIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpPreviousIdx) == 4, "expected KrStateMachine<pcGLB,32>::mpPreviousIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpGlobalIdx) == 4, "expected KrStateMachine<pcGLB,32>::mpGlobalIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpState) == 128, "expected KrStateMachine<pcGLB,32>::mpState to be size 128");
static_assert(sizeof(KrStateMachine<pcGLB,32>) == 0x90, "expected KrStateMachine<pcGLB,32> to be size 0x90");

// [Structure] class rSideScrollCamera
class rSideScrollCamera
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <struct Vec mPos, offset 0x4>
	struct Vec mPos;

	// <struct Vec mTarget, offset 0x10>
	struct Vec mTarget;

	// <float mInterpolateSpd, offset 0x1c>
	float mInterpolateSpd = 0;

	// <float mPosDist, offset 0x20>
	float mPosDist = 0;

	// <float mXAngle, offset 0x24>
	float mXAngle = 0;

	// <float mYAngle, offset 0x28>
	float mYAngle = 0;

	// <float mAdjustYAngle, offset 0x2c>
	float mAdjustYAngle = 0;

	// <uint8_t mbZoom, offset 0x30>
	uint8_t mbZoom = 0;

	// <Unidentified data segment, offset 0x31>
private:
	char _UnidentifiedData_49[3];

public:
	// <float mZoomDist, offset 0x34>
	float mZoomDist = 0;

	// <float mZoomSpeed, offset 0x38>
	float mZoomSpeed = 0;

	// <struct Vec mZoomDirec, offset 0x3c>
	struct Vec mZoomDirec;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rSideScrollCamera [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rSideScrollCamera& InObject)
	{
		mPos = InObject.mPos;
		mTarget = InObject.mTarget;
		mInterpolateSpd = InObject.mInterpolateSpd;
		mPosDist = InObject.mPosDist;
		mXAngle = InObject.mXAngle;
		mYAngle = InObject.mYAngle;
		mAdjustYAngle = InObject.mAdjustYAngle;
		mbZoom = InObject.mbZoom;
		mZoomDist = InObject.mZoomDist;
		mZoomSpeed = InObject.mZoomSpeed;
		mZoomDirec = InObject.mZoomDirec;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rSideScrollCamera>("rSideScrollCamera")
			.addFunction("__tostring", &rSideScrollCamera::ToString)
			.addFunction("GetPtrAddr", &rSideScrollCamera::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &rSideScrollCamera::field_0)
			.addProperty("mPos", &rSideScrollCamera::mPos)
			.addProperty("mTarget", &rSideScrollCamera::mTarget)
			.addProperty("mInterpolateSpd", &rSideScrollCamera::mInterpolateSpd)
			.addProperty("mPosDist", &rSideScrollCamera::mPosDist)
			.addProperty("mXAngle", &rSideScrollCamera::mXAngle)
			.addProperty("mYAngle", &rSideScrollCamera::mYAngle)
			.addProperty("mAdjustYAngle", &rSideScrollCamera::mAdjustYAngle)
			.addProperty("mbZoom", &rSideScrollCamera::mbZoom)
			.addProperty("mZoomDist", &rSideScrollCamera::mZoomDist)
			.addProperty("mZoomSpeed", &rSideScrollCamera::mZoomSpeed)
			.addProperty("mZoomDirec", &rSideScrollCamera::mZoomDirec)
		.endClass();
	}
#endif
};
static_assert(sizeof(rSideScrollCamera::field_0) == 4, "expected rSideScrollCamera::field_0 to be size 4");
static_assert(sizeof(rSideScrollCamera::mPos) == 12, "expected rSideScrollCamera::mPos to be size 12");
static_assert(sizeof(rSideScrollCamera::mTarget) == 12, "expected rSideScrollCamera::mTarget to be size 12");
static_assert(sizeof(rSideScrollCamera::mInterpolateSpd) == 4, "expected rSideScrollCamera::mInterpolateSpd to be size 4");
static_assert(sizeof(rSideScrollCamera::mPosDist) == 4, "expected rSideScrollCamera::mPosDist to be size 4");
static_assert(sizeof(rSideScrollCamera::mXAngle) == 4, "expected rSideScrollCamera::mXAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mYAngle) == 4, "expected rSideScrollCamera::mYAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mAdjustYAngle) == 4, "expected rSideScrollCamera::mAdjustYAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mbZoom) == 1, "expected rSideScrollCamera::mbZoom to be size 1");
static_assert(sizeof(rSideScrollCamera::mZoomDist) == 4, "expected rSideScrollCamera::mZoomDist to be size 4");
static_assert(sizeof(rSideScrollCamera::mZoomSpeed) == 4, "expected rSideScrollCamera::mZoomSpeed to be size 4");
static_assert(sizeof(rSideScrollCamera::mZoomDirec) == 12, "expected rSideScrollCamera::mZoomDirec to be size 12");
static_assert(sizeof(rSideScrollCamera) == 0x48, "expected rSideScrollCamera to be size 0x48");

// [Structure] class GLBDamageState
class GLBDamageState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") GLBDamageState::ChangeStateCondition(class GLBDamageState* const this, class pcGLB* arg2) [?ChangeStateCondition@GLBDamageState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_GLBDamageState__UAEXPAVpcGLB___Z)(class GLBDamageState* const thisPtr, class pcGLB* arg2);
	void ChangeStateCondition(class pcGLB* arg2)
	{
		_ChangeStateCondition_GLBDamageState__UAEXPAVpcGLB___Z mFunc = (_ChangeStateCondition_GLBDamageState__UAEXPAVpcGLB___Z)(GameModule + 0x54d570);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBDamageState::Exit(class GLBDamageState* const this, class pcGLB* arg2) [?Exit@GLBDamageState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Exit_GLBDamageState__UAEXPAVpcGLB___Z)(class GLBDamageState* const thisPtr, class pcGLB* arg2);
	void Exit(class pcGLB* arg2)
	{
		_Exit_GLBDamageState__UAEXPAVpcGLB___Z mFunc = (_Exit_GLBDamageState__UAEXPAVpcGLB___Z)(GameModule + 0x54d5e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBDamageState::Execute(class GLBDamageState* const this, class pcGLB* arg2) [?Execute@GLBDamageState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Execute_GLBDamageState__UAEXPAVpcGLB___Z)(class GLBDamageState* const thisPtr, class pcGLB* arg2);
	void Execute(class pcGLB* arg2)
	{
		_Execute_GLBDamageState__UAEXPAVpcGLB___Z mFunc = (_Execute_GLBDamageState__UAEXPAVpcGLB___Z)(GameModule + 0x54d5f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBDamageState::Enter(class GLBDamageState* const this, class pcGLB* arg2) [?Enter@GLBDamageState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Enter_GLBDamageState__UAEXPAVpcGLB___Z)(class GLBDamageState* const thisPtr, class pcGLB* arg2);
	void Enter(class pcGLB* arg2)
	{
		_Enter_GLBDamageState__UAEXPAVpcGLB___Z mFunc = (_Enter_GLBDamageState__UAEXPAVpcGLB___Z)(GameModule + 0x54d7c0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GLBDamageState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GLBDamageState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBDamageState>("GLBDamageState")
			.addFunction("__tostring", &GLBDamageState::ToString)
			.addFunction("GetPtrAddr", &GLBDamageState::GetPtrAddr)
			.addFunction("ChangeStateCondition", &GLBDamageState::ChangeStateCondition)
			.addFunction("Exit", &GLBDamageState::Exit)
			.addFunction("Execute", &GLBDamageState::Execute)
			.addFunction("Enter", &GLBDamageState::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBDamageState) == 0x4, "expected GLBDamageState to be size 0x4");

// [Structure] class GLBGuardState
class GLBGuardState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") GLBGuardState::ChangeStateCondition(class GLBGuardState* const this, class pcGLB* arg2) [?ChangeStateCondition@GLBGuardState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_GLBGuardState__UAEXPAVpcGLB___Z)(class GLBGuardState* const thisPtr, class pcGLB* arg2);
	void ChangeStateCondition(class pcGLB* arg2)
	{
		_ChangeStateCondition_GLBGuardState__UAEXPAVpcGLB___Z mFunc = (_ChangeStateCondition_GLBGuardState__UAEXPAVpcGLB___Z)(GameModule + 0x54d490);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBGuardState::Exit(class GLBGuardState* const this, class pcGLB* arg2) [?Exit@GLBGuardState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Exit_GLBGuardState__UAEXPAVpcGLB___Z)(class GLBGuardState* const thisPtr, class pcGLB* arg2);
	void Exit(class pcGLB* arg2)
	{
		_Exit_GLBGuardState__UAEXPAVpcGLB___Z mFunc = (_Exit_GLBGuardState__UAEXPAVpcGLB___Z)(GameModule + 0x54d4e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBGuardState::Execute(class GLBGuardState* const this, class pcGLB* arg2) [?Execute@GLBGuardState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Execute_GLBGuardState__UAEXPAVpcGLB___Z)(class GLBGuardState* const thisPtr, class pcGLB* arg2);
	void Execute(class pcGLB* arg2)
	{
		_Execute_GLBGuardState__UAEXPAVpcGLB___Z mFunc = (_Execute_GLBGuardState__UAEXPAVpcGLB___Z)(GameModule + 0x54d4f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBGuardState::Enter(class GLBGuardState* const this, class pcGLB* arg2) [?Enter@GLBGuardState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Enter_GLBGuardState__UAEXPAVpcGLB___Z)(class GLBGuardState* const thisPtr, class pcGLB* arg2);
	void Enter(class pcGLB* arg2)
	{
		_Enter_GLBGuardState__UAEXPAVpcGLB___Z mFunc = (_Enter_GLBGuardState__UAEXPAVpcGLB___Z)(GameModule + 0x54d540);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GLBGuardState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GLBGuardState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBGuardState>("GLBGuardState")
			.addFunction("__tostring", &GLBGuardState::ToString)
			.addFunction("GetPtrAddr", &GLBGuardState::GetPtrAddr)
			.addFunction("ChangeStateCondition", &GLBGuardState::ChangeStateCondition)
			.addFunction("Exit", &GLBGuardState::Exit)
			.addFunction("Execute", &GLBGuardState::Execute)
			.addFunction("Enter", &GLBGuardState::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBGuardState) == 0x4, "expected GLBGuardState to be size 0x4");

// [Structure] class GLBAirKickState
class GLBAirKickState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	/// 5 Functions

	// [Function] void __convention("thiscall") GLBAirKickState::MoveProc(class GLBAirKickState* const this, class pcGLB* arg2) [?MoveProc@GLBAirKickState@@QAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _MoveProc_GLBAirKickState__QAEXPAVpcGLB___Z)(class GLBAirKickState* const thisPtr, class pcGLB* arg2);
	void MoveProc(class pcGLB* arg2)
	{
		_MoveProc_GLBAirKickState__QAEXPAVpcGLB___Z mFunc = (_MoveProc_GLBAirKickState__QAEXPAVpcGLB___Z)(GameModule + 0x54d110);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBAirKickState::ChangeStateCondition(class GLBAirKickState* const this, class pcGLB* arg2) [?ChangeStateCondition@GLBAirKickState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_GLBAirKickState__UAEXPAVpcGLB___Z)(class GLBAirKickState* const thisPtr, class pcGLB* arg2);
	void ChangeStateCondition(class pcGLB* arg2)
	{
		_ChangeStateCondition_GLBAirKickState__UAEXPAVpcGLB___Z mFunc = (_ChangeStateCondition_GLBAirKickState__UAEXPAVpcGLB___Z)(GameModule + 0x54d1a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBAirKickState::Exit(class GLBAirKickState* const this, class pcGLB* arg2) [?Exit@GLBAirKickState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Exit_GLBAirKickState__UAEXPAVpcGLB___Z)(class GLBAirKickState* const thisPtr, class pcGLB* arg2);
	void Exit(class pcGLB* arg2)
	{
		_Exit_GLBAirKickState__UAEXPAVpcGLB___Z mFunc = (_Exit_GLBAirKickState__UAEXPAVpcGLB___Z)(GameModule + 0x54d240);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBAirKickState::Execute(class GLBAirKickState* const this, class pcGLB* arg2) [?Execute@GLBAirKickState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Execute_GLBAirKickState__UAEXPAVpcGLB___Z)(class GLBAirKickState* const thisPtr, class pcGLB* arg2);
	void Execute(class pcGLB* arg2)
	{
		_Execute_GLBAirKickState__UAEXPAVpcGLB___Z mFunc = (_Execute_GLBAirKickState__UAEXPAVpcGLB___Z)(GameModule + 0x54d250);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") GLBAirKickState::Enter(class GLBAirKickState* const this, class pcGLB* arg2) [?Enter@GLBAirKickState@@UAEXPAVpcGLB@@@Z]
	typedef void(__thiscall* _Enter_GLBAirKickState__UAEXPAVpcGLB___Z)(class GLBAirKickState* const thisPtr, class pcGLB* arg2);
	void Enter(class pcGLB* arg2)
	{
		_Enter_GLBAirKickState__UAEXPAVpcGLB___Z mFunc = (_Enter_GLBAirKickState__UAEXPAVpcGLB___Z)(GameModule + 0x54d2f0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class GLBAirKickState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GLBAirKickState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBAirKickState>("GLBAirKickState")
			.addFunction("__tostring", &GLBAirKickState::ToString)
			.addFunction("GetPtrAddr", &GLBAirKickState::GetPtrAddr)
			.addFunction("MoveProc", &GLBAirKickState::MoveProc)
			.addFunction("ChangeStateCondition", &GLBAirKickState::ChangeStateCondition)
			.addFunction("Exit", &GLBAirKickState::Exit)
			.addFunction("Execute", &GLBAirKickState::Execute)
			.addFunction("Enter", &GLBAirKickState::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBAirKickState) == 0x4, "expected GLBAirKickState to be size 0x4");

// [Structure] class pcGLB
class pcGLB : public mHRChara
{
public:
	// [Structure] struct pcGLB::DmgInfo
	struct DmgInfo
	{
	public:
		/// Struct member variables

		// <uint32_t Kind, offset 0x0>
		uint32_t Kind = 0;

		// <uint32_t DirecKind, offset 0x4>
		uint32_t DirecKind = 0;

		// <float Direc, offset 0x8>
		float Direc = 0;

		// <uint32_t FinishHitNum, offset 0xc>
		uint32_t FinishHitNum = 0;

		// <uint32_t DownFinishHitMax, offset 0x10>
		uint32_t DownFinishHitMax = 0;

		// <float AccumuAmount, offset 0x14>
		float AccumuAmount = 0;

		// <float AccumuMax, offset 0x18>
		float AccumuMax = 0;

		// <float AccumuRecovery, offset 0x1c>
		float AccumuRecovery = 0;

		// <float GroggyAmount, offset 0x20>
		float GroggyAmount = 0;

		// <float GroggyMax, offset 0x24>
		float GroggyMax = 0;

		// <float GroggyRecovery, offset 0x28>
		float GroggyRecovery = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct pcGLB::DmgInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(pcGLB::DmgInfo& InObject)
		{
			Kind = InObject.Kind;
			DirecKind = InObject.DirecKind;
			Direc = InObject.Direc;
			FinishHitNum = InObject.FinishHitNum;
			DownFinishHitMax = InObject.DownFinishHitMax;
			AccumuAmount = InObject.AccumuAmount;
			AccumuMax = InObject.AccumuMax;
			AccumuRecovery = InObject.AccumuRecovery;
			GroggyAmount = InObject.GroggyAmount;
			GroggyMax = InObject.GroggyMax;
			GroggyRecovery = InObject.GroggyRecovery;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<DmgInfo>("pcGLB_DmgInfo")
				.addFunction("__tostring", &pcGLB::DmgInfo::ToString)
				.addFunction("GetPtrAddr", &pcGLB::DmgInfo::GetPtrAddr)
				.addProperty("Kind", &pcGLB::DmgInfo::Kind)
				.addProperty("DirecKind", &pcGLB::DmgInfo::DirecKind)
				.addProperty("Direc", &pcGLB::DmgInfo::Direc)
				.addProperty("FinishHitNum", &pcGLB::DmgInfo::FinishHitNum)
				.addProperty("DownFinishHitMax", &pcGLB::DmgInfo::DownFinishHitMax)
				.addProperty("AccumuAmount", &pcGLB::DmgInfo::AccumuAmount)
				.addProperty("AccumuMax", &pcGLB::DmgInfo::AccumuMax)
				.addProperty("AccumuRecovery", &pcGLB::DmgInfo::AccumuRecovery)
				.addProperty("GroggyAmount", &pcGLB::DmgInfo::GroggyAmount)
				.addProperty("GroggyMax", &pcGLB::DmgInfo::GroggyMax)
				.addProperty("GroggyRecovery", &pcGLB::DmgInfo::GroggyRecovery)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(pcGLB::DmgInfo::Kind) == 4, "expected pcGLB::DmgInfo::Kind to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::DirecKind) == 4, "expected pcGLB::DmgInfo::DirecKind to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::Direc) == 4, "expected pcGLB::DmgInfo::Direc to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::FinishHitNum) == 4, "expected pcGLB::DmgInfo::FinishHitNum to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::DownFinishHitMax) == 4, "expected pcGLB::DmgInfo::DownFinishHitMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuAmount) == 4, "expected pcGLB::DmgInfo::AccumuAmount to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuMax) == 4, "expected pcGLB::DmgInfo::AccumuMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuRecovery) == 4, "expected pcGLB::DmgInfo::AccumuRecovery to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyAmount) == 4, "expected pcGLB::DmgInfo::GroggyAmount to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyMax) == 4, "expected pcGLB::DmgInfo::GroggyMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyRecovery) == 4, "expected pcGLB::DmgInfo::GroggyRecovery to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo) == 0x2c, "expected pcGLB::DmgInfo to be size 0x2c");

	// [Structure] struct pcGLB::TickCnt
	struct TickCnt
	{
	public:
		/// Struct member variables

		// <int32_t Motion, offset 0x0>
		int32_t Motion = 0;

		// <int32_t AtkWait, offset 0x4>
		int32_t AtkWait = 0;

		// <int32_t Loop, offset 0x8>
		int32_t Loop = 0;

		// <int32_t State, offset 0xc>
		int32_t State = 0;

		// <int32_t DmgWait, offset 0x10>
		int32_t DmgWait = 0;

		// <int32_t DmgPlayAccept, offset 0x14>
		int32_t DmgPlayAccept = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct pcGLB::TickCnt [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(pcGLB::TickCnt& InObject)
		{
			Motion = InObject.Motion;
			AtkWait = InObject.AtkWait;
			Loop = InObject.Loop;
			State = InObject.State;
			DmgWait = InObject.DmgWait;
			DmgPlayAccept = InObject.DmgPlayAccept;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TickCnt>("pcGLB_TickCnt")
				.addFunction("__tostring", &pcGLB::TickCnt::ToString)
				.addFunction("GetPtrAddr", &pcGLB::TickCnt::GetPtrAddr)
				.addProperty("Motion", &pcGLB::TickCnt::Motion)
				.addProperty("AtkWait", &pcGLB::TickCnt::AtkWait)
				.addProperty("Loop", &pcGLB::TickCnt::Loop)
				.addProperty("State", &pcGLB::TickCnt::State)
				.addProperty("DmgWait", &pcGLB::TickCnt::DmgWait)
				.addProperty("DmgPlayAccept", &pcGLB::TickCnt::DmgPlayAccept)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(pcGLB::TickCnt::Motion) == 4, "expected pcGLB::TickCnt::Motion to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::AtkWait) == 4, "expected pcGLB::TickCnt::AtkWait to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::Loop) == 4, "expected pcGLB::TickCnt::Loop to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::State) == 4, "expected pcGLB::TickCnt::State to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::DmgWait) == 4, "expected pcGLB::TickCnt::DmgWait to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::DmgPlayAccept) == 4, "expected pcGLB::TickCnt::DmgPlayAccept to be size 4");
	static_assert(sizeof(pcGLB::TickCnt) == 0x18, "expected pcGLB::TickCnt to be size 0x18");

	// enum pcGLB::MiniDemoEnum
	enum MiniDemoEnum : uint32_t
	{
		// <MD_Init = 0xffffffffffffffff>
		MD_Init = UINT32_MAX,

		// <MD_Strawberry = 0x0>
		MD_Strawberry = 0,

		// <MD_London = 0x1>
		MD_London = 1,

		// <MD_Ragvy = 0x2>
		MD_Ragvy = 2

	};

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <uint8_t mCanOperate, offset 0x580>
	uint8_t mCanOperate = 0;

	// <uint8_t mTestOnCanOperate, offset 0x581>
	uint8_t mTestOnCanOperate = 0;

	// <Unidentified data segment, offset 0x582>
private:
	char _UnidentifiedData_1410[2];

public:
	// <class rSideScrollCamera mSideCamera, offset 0x584>
	class rSideScrollCamera mSideCamera;

	// <class EfRoboInterface* mpInterface, offset 0x5cc>
	class EfRoboInterface* mpInterface = nullptr;

	// <class bsSDP* mpSDP, offset 0x5d0>
	class bsSDP* mpSDP = nullptr;

	// <class KrStateMachine<pcGLB,32> mStateMachine, offset 0x5d4>
	class KrStateMachine<pcGLB,32> mStateMachine;

	// <class GLBIdleState mIdleState, offset 0x664>
	class GLBIdleState mIdleState;

	// <class GLBWalkState mWalkState, offset 0x668>
	class GLBWalkState mWalkState;

	// <class GLBJampState mJampState, offset 0x66c>
	class GLBJampState mJampState;

	// <class GLBDamageState mDamageState, offset 0x674>
	class GLBDamageState mDamageState;

	// <class GLBGuardState mGuardState, offset 0x678>
	class GLBGuardState mGuardState;

	// <class GLBComboState mComboState, offset 0x67c>
	class GLBComboState mComboState;

	// <class GLBAirKickState mAirKickState, offset 0x684>
	class GLBAirKickState mAirKickState;

	// <class GLBDeathState mDeathState, offset 0x688>
	class GLBDeathState mDeathState;

	// <struct pcGLB::DmgInfo mDmgInfo, offset 0x690>
	struct pcGLB::DmgInfo mDmgInfo;

	// <struct pcGLB::TickCnt mTickCnt, offset 0x6bc>
	struct pcGLB::TickCnt mTickCnt;

	// <float mAirY, offset 0x6d4>
	float mAirY = 0;

	// <float mAirPower, offset 0x6d8>
	float mAirPower = 0;

	// <uint8_t mbAir, offset 0x6dc>
	uint8_t mbAir = 0;

	// <Unidentified data segment, offset 0x6dd>
private:
	char _UnidentifiedData_1757[3];

public:
	// <float mTension, offset 0x6e0>
	float mTension = 0;

	// <struct Vec mBefPos, offset 0x6e4>
	struct Vec mBefPos;

	// <enum pcGLB::MiniDemoEnum mMDemoNo, offset 0x6f0>
	enum pcGLB::MiniDemoEnum mMDemoNo;

	// <int32_t mPhase, offset 0x6f4>
	int32_t mPhase = 0;

	// <uint32_t mBeamColor, offset 0x6f8>
	uint32_t mBeamColor = 0;

	// <uint8_t mbDemoWait, offset 0x6fc>
	uint8_t mbDemoWait = 0;

	// <Unidentified data segment, offset 0x6fd>
private:
	char _UnidentifiedData_1789[3];

public:
	// <class TGmfNode* mpWristLNode, offset 0x700>
	class TGmfNode* mpWristLNode = nullptr;

	// <class EffectModelBeam* mpWepBeam, offset 0x704>
	class EffectModelBeam* mpWepBeam = nullptr;

	// <uint8_t mbCanKick, offset 0x708>
	uint8_t mbCanKick = 0;

	// <Unidentified data segment, offset 0x709>
private:
	char _UnidentifiedData_1801[3];

public:
	// <int32_t mhVernierSE, offset 0x70c>
	int32_t mhVernierSE = 0;

	// <int32_t mMDFlag, offset 0x710>
	int32_t mMDFlag = 0;

	/// 50 Functions

	// [Function] void __convention("thiscall") pcGLB::SetLoopTick(class pcGLB* const this, int32_t arg2) [?SetLoopTick@pcGLB@@QAEXH@Z]
	typedef void(__thiscall* _SetLoopTick_pcGLB__QAEXH_Z)(class pcGLB* const thisPtr, int32_t arg2);
	void SetLoopTick(int32_t arg2)
	{
		_SetLoopTick_pcGLB__QAEXH_Z mFunc = (_SetLoopTick_pcGLB__QAEXH_Z)(GameModule + 0xc8c50);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") pcGLB::GetLoopTick(class pcGLB* const this) [?GetLoopTick@pcGLB@@QBEHXZ]
	typedef int32_t(__thiscall* _GetLoopTick_pcGLB__QBEHXZ)(class pcGLB* const thisPtr);
	int32_t GetLoopTick()
	{
		_GetLoopTick_pcGLB__QBEHXZ mFunc = (_GetLoopTick_pcGLB__QBEHXZ)(GameModule + 0xc8c60);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") pcGLB::GetAirY(class pcGLB* const this) [?GetAirY@pcGLB@@QBEMXZ]
	typedef float(__thiscall* _GetAirY_pcGLB__QBEMXZ)(class pcGLB* const thisPtr);
	float GetAirY()
	{
		_GetAirY_pcGLB__QBEMXZ mFunc = (_GetAirY_pcGLB__QBEMXZ)(GameModule + 0xc8c70);
		return mFunc(this);
	}
	// [Function] class bsSDP* __convention("thiscall") pcGLB::GetSDP(class pcGLB* const this) [?GetSDP@pcGLB@@QAEPAVbsSDP@@XZ]
	typedef class bsSDP*(__thiscall* _GetSDP_pcGLB__QAEPAVbsSDP__XZ)(class pcGLB* const thisPtr);
	class bsSDP* GetSDP()
	{
		_GetSDP_pcGLB__QAEPAVbsSDP__XZ mFunc = (_GetSDP_pcGLB__QAEPAVbsSDP__XZ)(GameModule + 0xc8c80);
		return mFunc(this);
	}
	// [Function] class EfRoboInterface* __convention("thiscall") pcGLB::GetIntarface(class pcGLB* const this) [?GetIntarface@pcGLB@@QBEPAVEfRoboInterface@@XZ]
	typedef class EfRoboInterface*(__thiscall* _GetIntarface_pcGLB__QBEPAVEfRoboInterface__XZ)(class pcGLB* const thisPtr);
	class EfRoboInterface* GetIntarface()
	{
		_GetIntarface_pcGLB__QBEPAVEfRoboInterface__XZ mFunc = (_GetIntarface_pcGLB__QBEPAVEfRoboInterface__XZ)(GameModule + 0xc9240);
		return mFunc(this);
	}
	// [Function] class rSideScrollCamera* __convention("thiscall") pcGLB::GetCamera(class pcGLB* const this) [?GetCamera@pcGLB@@QAEPAVrSideScrollCamera@@XZ]
	typedef class rSideScrollCamera*(__thiscall* _GetCamera_pcGLB__QAEPAVrSideScrollCamera__XZ)(class pcGLB* const thisPtr);
	class rSideScrollCamera* GetCamera()
	{
		_GetCamera_pcGLB__QAEPAVrSideScrollCamera__XZ mFunc = (_GetCamera_pcGLB__QAEPAVrSideScrollCamera__XZ)(GameModule + 0xc9250);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::IsDemoWait(class pcGLB* const this) [?IsDemoWait@pcGLB@@QBE_NXZ]
	typedef uint8_t(__thiscall* _IsDemoWait_pcGLB__QBE_NXZ)(class pcGLB* const thisPtr);
	uint8_t IsDemoWait()
	{
		_IsDemoWait_pcGLB__QBE_NXZ mFunc = (_IsDemoWait_pcGLB__QBE_NXZ)(GameModule + 0xc9260);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::SetZoom(class pcGLB* const this, uint8_t arg2, float arg3) [?SetZoom@pcGLB@@QAEX_NM@Z]
	typedef void(__thiscall* _SetZoom_pcGLB__QAEX_NM_Z)(class pcGLB* const thisPtr, uint8_t arg2, float arg3);
	void SetZoom(uint8_t arg2, float arg3)
	{
		_SetZoom_pcGLB__QAEX_NM_Z mFunc = (_SetZoom_pcGLB__QAEX_NM_Z)(GameModule + 0xc9270);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t const __convention("thiscall") pcGLB::CanOperate(class pcGLB* const this) [?CanOperate@pcGLB@@QAE?B_NXZ]
	typedef uint8_t const(__thiscall* _CanOperate_pcGLB__QAEB_NXZ)(class pcGLB* const thisPtr);
	uint8_t CanOperate()
	{
		_CanOperate_pcGLB__QAEB_NXZ mFunc = (_CanOperate_pcGLB__QAEB_NXZ)(GameModule + 0xcdbc0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") pcGLB::GetTension(class pcGLB* const this) [?GetTension@pcGLB@@QAEMXZ]
	typedef float(__thiscall* _GetTension_pcGLB__QAEMXZ)(class pcGLB* const thisPtr);
	float GetTension()
	{
		_GetTension_pcGLB__QAEMXZ mFunc = (_GetTension_pcGLB__QAEMXZ)(GameModule + 0xd40a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mPostFrameCommonProc1(class pcGLB* const this) [?mPostFrameCommonProc1@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mPostFrameCommonProc1_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mPostFrameCommonProc1()
	{
		_mPostFrameCommonProc1_pcGLB__UAE_NXZ mFunc = (_mPostFrameCommonProc1_pcGLB__UAE_NXZ)(GameModule + 0x54aad0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::IsMultiStep(class pcGLB* const this) [?IsMultiStep@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _IsMultiStep_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t IsMultiStep()
	{
		_IsMultiStep_pcGLB__UAE_NXZ mFunc = (_IsMultiStep_pcGLB__UAE_NXZ)(GameModule + 0x54ab70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::SeProc(class pcGLB* const this) [?SeProc@pcGLB@@AAEXXZ]
	typedef void(__thiscall* _SeProc_pcGLB__AAEXXZ)(class pcGLB* const thisPtr);
	void SeProc()
	{
		_SeProc_pcGLB__AAEXXZ mFunc = (_SeProc_pcGLB__AAEXXZ)(GameModule + 0x54ab80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::IsAtkObj(class pcGLB* const this, class mHRChara* arg2) [?IsAtkObj@pcGLB@@EAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _IsAtkObj_pcGLB__EAE_NPAVmHRChara___Z)(class pcGLB* const thisPtr, class mHRChara* arg2);
	uint8_t IsAtkObj(class mHRChara* arg2)
	{
		_IsAtkObj_pcGLB__EAE_NPAVmHRChara___Z mFunc = (_IsAtkObj_pcGLB__EAE_NPAVmHRChara___Z)(GameModule + 0x54ac90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcGLB::TensionUp(class pcGLB* const this, float arg2) [?TensionUp@pcGLB@@QAEXM@Z]
	typedef void(__thiscall* _TensionUp_pcGLB__QAEXM_Z)(class pcGLB* const thisPtr, float arg2);
	void TensionUp(float arg2)
	{
		_TensionUp_pcGLB__QAEXM_Z mFunc = (_TensionUp_pcGLB__QAEXM_Z)(GameModule + 0x54acc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcGLB::PlayMiniDemo(class pcGLB* const this, enum pcGLB::MiniDemoEnum arg2, int32_t arg3) [?PlayMiniDemo@pcGLB@@QAEXW4MiniDemoEnum@1@H@Z]
	typedef void(__thiscall* _PlayMiniDemo_pcGLB__QAEXW4MiniDemoEnum_1_H_Z)(class pcGLB* const thisPtr, enum pcGLB::MiniDemoEnum arg2, int32_t arg3);
	void PlayMiniDemo(/* enum pcGLB::MiniDemoEnum */ uint32_t arg2, int32_t arg3)
	{
		_PlayMiniDemo_pcGLB__QAEXW4MiniDemoEnum_1_H_Z mFunc = (_PlayMiniDemo_pcGLB__QAEXW4MiniDemoEnum_1_H_Z)(GameModule + 0x54ad30);
		return mFunc(this, (enum pcGLB::MiniDemoEnum)arg2, arg3);
	}
	// [Function] void __convention("thiscall") pcGLB::AirProc(class pcGLB* const this) [?AirProc@pcGLB@@AAEXXZ]
	typedef void(__thiscall* _AirProc_pcGLB__AAEXXZ)(class pcGLB* const thisPtr);
	void AirProc()
	{
		_AirProc_pcGLB__AAEXXZ mFunc = (_AirProc_pcGLB__AAEXXZ)(GameModule + 0x54ae00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::SetAirDmg(class pcGLB* const this) [?SetAirDmg@pcGLB@@QAEXXZ]
	typedef void(__thiscall* _SetAirDmg_pcGLB__QAEXXZ)(class pcGLB* const thisPtr);
	void SetAirDmg()
	{
		_SetAirDmg_pcGLB__QAEXXZ mFunc = (_SetAirDmg_pcGLB__QAEXXZ)(GameModule + 0x54ae70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::SetJump(class pcGLB* const this) [?SetJump@pcGLB@@QAEXXZ]
	typedef void(__thiscall* _SetJump_pcGLB__QAEXXZ)(class pcGLB* const thisPtr);
	void SetJump()
	{
		_SetJump_pcGLB__QAEXXZ mFunc = (_SetJump_pcGLB__QAEXXZ)(GameModule + 0x54ae80);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") pcGLB::GetCurAtkKind(class pcGLB* const this) [?GetCurAtkKind@pcGLB@@AAEHXZ]
	typedef int32_t(__thiscall* _GetCurAtkKind_pcGLB__AAEHXZ)(class pcGLB* const thisPtr);
	int32_t GetCurAtkKind()
	{
		_GetCurAtkKind_pcGLB__AAEHXZ mFunc = (_GetCurAtkKind_pcGLB__AAEHXZ)(GameModule + 0x54aea0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") pcGLB::GetCurAtkNockBackDist(class pcGLB* const this) [?GetCurAtkNockBackDist@pcGLB@@AAEMXZ]
	typedef float(__thiscall* _GetCurAtkNockBackDist_pcGLB__AAEMXZ)(class pcGLB* const thisPtr);
	float GetCurAtkNockBackDist()
	{
		_GetCurAtkNockBackDist_pcGLB__AAEMXZ mFunc = (_GetCurAtkNockBackDist_pcGLB__AAEMXZ)(GameModule + 0x54aef0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") pcGLB::GetCurAtkDamage(class pcGLB* const this) [?GetCurAtkDamage@pcGLB@@AAEMXZ]
	typedef float(__thiscall* _GetCurAtkDamage_pcGLB__AAEMXZ)(class pcGLB* const thisPtr);
	float GetCurAtkDamage()
	{
		_GetCurAtkDamage_pcGLB__AAEMXZ mFunc = (_GetCurAtkDamage_pcGLB__AAEMXZ)(GameModule + 0x54af40);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") pcGLB::GetCurAtkAngle(class pcGLB* const this) [?GetCurAtkAngle@pcGLB@@AAEMXZ]
	typedef float(__thiscall* _GetCurAtkAngle_pcGLB__AAEMXZ)(class pcGLB* const thisPtr);
	float GetCurAtkAngle()
	{
		_GetCurAtkAngle_pcGLB__AAEMXZ mFunc = (_GetCurAtkAngle_pcGLB__AAEMXZ)(GameModule + 0x54af90);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") pcGLB::GetCurAtkDist(class pcGLB* const this) [?GetCurAtkDist@pcGLB@@AAEMXZ]
	typedef float(__thiscall* _GetCurAtkDist_pcGLB__AAEMXZ)(class pcGLB* const thisPtr);
	float GetCurAtkDist()
	{
		_GetCurAtkDist_pcGLB__AAEMXZ mFunc = (_GetCurAtkDist_pcGLB__AAEMXZ)(GameModule + 0x54afe0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") pcGLB::mGetAtkNo(class pcGLB* const this, int32_t arg2) [?mGetAtkNo@pcGLB@@EAEHH@Z]
	typedef int32_t(__thiscall* _mGetAtkNo_pcGLB__EAEHH_Z)(class pcGLB* const thisPtr, int32_t arg2);
	int32_t mGetAtkNo(int32_t arg2)
	{
		_mGetAtkNo_pcGLB__EAEHH_Z mFunc = (_mGetAtkNo_pcGLB__EAEHH_Z)(GameModule + 0x54b030);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcGLB::AttackCheck(class pcGLB* const this) [?AttackCheck@pcGLB@@AAEXXZ]
	typedef void(__thiscall* _AttackCheck_pcGLB__AAEXXZ)(class pcGLB* const thisPtr);
	void AttackCheck()
	{
		_AttackCheck_pcGLB__AAEXXZ mFunc = (_AttackCheck_pcGLB__AAEXXZ)(GameModule + 0x54b070);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::UpdataInfo(class pcGLB* const this) [?UpdataInfo@pcGLB@@AAEXXZ]
	typedef void(__thiscall* _UpdataInfo_pcGLB__AAEXXZ)(class pcGLB* const thisPtr);
	void UpdataInfo()
	{
		_UpdataInfo_pcGLB__AAEXXZ mFunc = (_UpdataInfo_pcGLB__AAEXXZ)(GameModule + 0x54b420);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") pcGLB::SelectDmgMotion(class pcGLB* const this) [?SelectDmgMotion@pcGLB@@QAEHXZ]
	typedef int32_t(__thiscall* _SelectDmgMotion_pcGLB__QAEHXZ)(class pcGLB* const thisPtr);
	int32_t SelectDmgMotion()
	{
		_SelectDmgMotion_pcGLB__QAEHXZ mFunc = (_SelectDmgMotion_pcGLB__QAEHXZ)(GameModule + 0x54b580);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::SetDamageIK(class pcGLB* const this, class mHRChara* arg2, uint8_t arg3) [?SetDamageIK@pcGLB@@AAEXPAVmHRChara@@_N@Z]
	typedef void(__thiscall* _SetDamageIK_pcGLB__AAEXPAVmHRChara___N_Z)(class pcGLB* const thisPtr, class mHRChara* arg2, uint8_t arg3);
	void SetDamageIK(class mHRChara* arg2, uint8_t arg3)
	{
		_SetDamageIK_pcGLB__AAEXPAVmHRChara___N_Z mFunc = (_SetDamageIK_pcGLB__AAEXPAVmHRChara___N_Z)(GameModule + 0x54b5e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint32_t __convention("thiscall") pcGLB::GetAtkDirecKind(class pcGLB* const this, float arg2) [?GetAtkDirecKind@pcGLB@@AAEIM@Z]
	typedef uint32_t(__thiscall* _GetAtkDirecKind_pcGLB__AAEIM_Z)(class pcGLB* const thisPtr, float arg2);
	uint32_t GetAtkDirecKind(float arg2)
	{
		_GetAtkDirecKind_pcGLB__AAEIM_Z mFunc = (_GetAtkDirecKind_pcGLB__AAEIM_Z)(GameModule + 0x54b640);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::IsCanInput(class pcGLB* const this) [?IsCanInput@pcGLB@@AAE_NXZ]
	typedef uint8_t(__thiscall* _IsCanInput_pcGLB__AAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t IsCanInput()
	{
		_IsCanInput_pcGLB__AAE_NXZ mFunc = (_IsCanInput_pcGLB__AAE_NXZ)(GameModule + 0x54b720);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::KeyInput(class pcGLB* const this) [?KeyInput@pcGLB@@AAEXXZ]
	typedef void(__thiscall* _KeyInput_pcGLB__AAEXXZ)(class pcGLB* const thisPtr);
	void KeyInput()
	{
		_KeyInput_pcGLB__AAEXXZ mFunc = (_KeyInput_pcGLB__AAEXXZ)(GameModule + 0x54b790);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::SetSDP(class pcGLB* const this, class bsSDP* arg2) [?SetSDP@pcGLB@@QAEXPAVbsSDP@@@Z]
	typedef void(__thiscall* _SetSDP_pcGLB__QAEXPAVbsSDP___Z)(class pcGLB* const thisPtr, class bsSDP* arg2);
	void SetSDP(class bsSDP* arg2)
	{
		_SetSDP_pcGLB__QAEXPAVbsSDP___Z mFunc = (_SetSDP_pcGLB__QAEXPAVbsSDP___Z)(GameModule + 0x54b9f0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") pcGLB::GetPrevStateIdx(class pcGLB* const this) [?GetPrevStateIdx@pcGLB@@QAEHXZ]
	typedef int32_t(__thiscall* _GetPrevStateIdx_pcGLB__QAEHXZ)(class pcGLB* const thisPtr);
	int32_t GetPrevStateIdx()
	{
		_GetPrevStateIdx_pcGLB__QAEHXZ mFunc = (_GetPrevStateIdx_pcGLB__QAEHXZ)(GameModule + 0x54ba00);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") pcGLB::GetCurStateIdx(class pcGLB* const this) [?GetCurStateIdx@pcGLB@@QAEHXZ]
	typedef int32_t(__thiscall* _GetCurStateIdx_pcGLB__QAEHXZ)(class pcGLB* const thisPtr);
	int32_t GetCurStateIdx()
	{
		_GetCurStateIdx_pcGLB__QAEHXZ mFunc = (_GetCurStateIdx_pcGLB__QAEHXZ)(GameModule + 0x54ba10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::ChangeState(class pcGLB* const this, int32_t arg2) [?ChangeState@pcGLB@@QAEXH@Z]
	typedef void(__thiscall* _ChangeState_pcGLB__QAEXH_Z)(class pcGLB* const thisPtr, int32_t arg2);
	void ChangeState(int32_t arg2)
	{
		_ChangeState_pcGLB__QAEXH_Z mFunc = (_ChangeState_pcGLB__QAEXH_Z)(GameModule + 0x54ba20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") pcGLB::mLoseTsubazeriai(class pcGLB* const this) [?mLoseTsubazeriai@pcGLB@@UAEXXZ]
	typedef void(__thiscall* _mLoseTsubazeriai_pcGLB__UAEXXZ)(class pcGLB* const thisPtr);
	void mLoseTsubazeriai()
	{
		_mLoseTsubazeriai_pcGLB__UAEXXZ mFunc = (_mLoseTsubazeriai_pcGLB__UAEXXZ)(GameModule + 0x54ba60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::mWinTsubazeriai(class pcGLB* const this) [?mWinTsubazeriai@pcGLB@@UAEXXZ]
	typedef void(__thiscall* _mWinTsubazeriai_pcGLB__UAEXXZ)(class pcGLB* const thisPtr);
	void mWinTsubazeriai()
	{
		_mWinTsubazeriai_pcGLB__UAEXXZ mFunc = (_mWinTsubazeriai_pcGLB__UAEXXZ)(GameModule + 0x54ba70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mCheckTsubazeriai(class pcGLB* const this) [?mCheckTsubazeriai@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckTsubazeriai_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mCheckTsubazeriai()
	{
		_mCheckTsubazeriai_pcGLB__UAE_NXZ mFunc = (_mCheckTsubazeriai_pcGLB__UAE_NXZ)(GameModule + 0x54ba80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") pcGLB::mPlayMotTsubaszeriai(class pcGLB* const this) [?mPlayMotTsubaszeriai@pcGLB@@UAEXXZ]
	typedef void(__thiscall* _mPlayMotTsubaszeriai_pcGLB__UAEXXZ)(class pcGLB* const thisPtr);
	void mPlayMotTsubaszeriai()
	{
		_mPlayMotTsubaszeriai_pcGLB__UAEXXZ mFunc = (_mPlayMotTsubaszeriai_pcGLB__UAEXXZ)(GameModule + 0x54ba90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mCheckIntoTsubazeriai(class pcGLB* const this) [?mCheckIntoTsubazeriai@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckIntoTsubazeriai_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mCheckIntoTsubazeriai()
	{
		_mCheckIntoTsubazeriai_pcGLB__UAE_NXZ mFunc = (_mCheckIntoTsubazeriai_pcGLB__UAE_NXZ)(GameModule + 0x54baa0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mAttackProc(class pcGLB* const this) [?mAttackProc@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mAttackProc_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mAttackProc()
	{
		_mAttackProc_pcGLB__UAE_NXZ mFunc = (_mAttackProc_pcGLB__UAE_NXZ)(GameModule + 0x54bab0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") pcGLB::mGetAttackTableValue(class pcGLB* const this, int32_t arg2, int32_t arg3) [?mGetAttackTableValue@pcGLB@@UAEMHH@Z]
	typedef float(__thiscall* _mGetAttackTableValue_pcGLB__UAEMHH_Z)(class pcGLB* const thisPtr, int32_t arg2, int32_t arg3);
	float mGetAttackTableValue(int32_t arg2, int32_t arg3)
	{
		_mGetAttackTableValue_pcGLB__UAEMHH_Z mFunc = (_mGetAttackTableValue_pcGLB__UAEMHH_Z)(GameModule + 0x54bac0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mCheckComboing(class pcGLB* const this) [?mCheckComboing@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckComboing_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mCheckComboing()
	{
		_mCheckComboing_pcGLB__UAE_NXZ mFunc = (_mCheckComboing_pcGLB__UAE_NXZ)(GameModule + 0x54baf0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mCheckAttack(class pcGLB* const this) [?mCheckAttack@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mCheckAttack_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mCheckAttack()
	{
		_mCheckAttack_pcGLB__UAE_NXZ mFunc = (_mCheckAttack_pcGLB__UAE_NXZ)(GameModule + 0x54bb00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mCheckCanHit(class pcGLB* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mCheckCanHit@pcGLB@@UAE_NH_N0@Z]
	typedef uint8_t(__thiscall* _mCheckCanHit_pcGLB__UAE_NH_N0_Z)(class pcGLB* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
	uint8_t mCheckCanHit(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		_mCheckCanHit_pcGLB__UAE_NH_N0_Z mFunc = (_mCheckCanHit_pcGLB__UAE_NH_N0_Z)(GameModule + 0x54bb10);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mSetDamage(class pcGLB* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@pcGLB@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_pcGLB__UAE_NMHHHMHMMPAVmHRChara___Z)(class pcGLB* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_pcGLB__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_pcGLB__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x54bb60);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mFrameProc(class pcGLB* const this) [?mFrameProc@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mFrameProc_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mFrameProc()
	{
		_mFrameProc_pcGLB__UAE_NXZ mFunc = (_mFrameProc_pcGLB__UAE_NXZ)(GameModule + 0x54bf90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mTerm(class pcGLB* const this) [?mTerm@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mTerm_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mTerm()
	{
		_mTerm_pcGLB__UAE_NXZ mFunc = (_mTerm_pcGLB__UAE_NXZ)(GameModule + 0x54cab0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mInit(class pcGLB* const this) [?mInit@pcGLB@@UAE_NXZ]
	typedef uint8_t(__thiscall* _mInit_pcGLB__UAE_NXZ)(class pcGLB* const thisPtr);
	uint8_t mInit()
	{
		_mInit_pcGLB__UAE_NXZ mFunc = (_mInit_pcGLB__UAE_NXZ)(GameModule + 0x54cc60);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class pcGLB [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(pcGLB& InObject)
	{
		mCanOperate = InObject.mCanOperate;
		mTestOnCanOperate = InObject.mTestOnCanOperate;
		mSideCamera = InObject.mSideCamera;
		mpInterface = InObject.mpInterface;
		mpSDP = InObject.mpSDP;
		mStateMachine = InObject.mStateMachine;
		mIdleState = InObject.mIdleState;
		mWalkState = InObject.mWalkState;
		mJampState = InObject.mJampState;
		mDamageState = InObject.mDamageState;
		mGuardState = InObject.mGuardState;
		mComboState = InObject.mComboState;
		mAirKickState = InObject.mAirKickState;
		mDeathState = InObject.mDeathState;
		mDmgInfo = InObject.mDmgInfo;
		mTickCnt = InObject.mTickCnt;
		mAirY = InObject.mAirY;
		mAirPower = InObject.mAirPower;
		mbAir = InObject.mbAir;
		mTension = InObject.mTension;
		mBefPos = InObject.mBefPos;
		mMDemoNo = InObject.mMDemoNo;
		mPhase = InObject.mPhase;
		mBeamColor = InObject.mBeamColor;
		mbDemoWait = InObject.mbDemoWait;
		mpWristLNode = InObject.mpWristLNode;
		mpWepBeam = InObject.mpWepBeam;
		mbCanKick = InObject.mbCanKick;
		mhVernierSE = InObject.mhVernierSE;
		mMDFlag = InObject.mMDFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<pcGLB, mHRChara>("pcGLB")
			.addFunction("__tostring", &pcGLB::ToString)
			.addFunction("GetPtrAddr", &pcGLB::GetPtrAddr)
			.addProperty("mCanOperate", &pcGLB::mCanOperate)
			.addProperty("mTestOnCanOperate", &pcGLB::mTestOnCanOperate)
			.addProperty("mSideCamera", &pcGLB::mSideCamera)
			.addProperty("mpInterface", &pcGLB::mpInterface)
			.addProperty("mpSDP", &pcGLB::mpSDP)
			.addProperty("mStateMachine", &pcGLB::mStateMachine)
			.addProperty("mIdleState", &pcGLB::mIdleState)
			.addProperty("mWalkState", &pcGLB::mWalkState)
			.addProperty("mJampState", &pcGLB::mJampState)
			.addProperty("mDamageState", &pcGLB::mDamageState)
			.addProperty("mGuardState", &pcGLB::mGuardState)
			.addProperty("mComboState", &pcGLB::mComboState)
			.addProperty("mAirKickState", &pcGLB::mAirKickState)
			.addProperty("mDeathState", &pcGLB::mDeathState)
			.addProperty("mDmgInfo", &pcGLB::mDmgInfo)
			.addProperty("mTickCnt", &pcGLB::mTickCnt)
			.addProperty("mAirY", &pcGLB::mAirY)
			.addProperty("mAirPower", &pcGLB::mAirPower)
			.addProperty("mbAir", &pcGLB::mbAir)
			.addProperty("mTension", &pcGLB::mTension)
			.addProperty("mBefPos", &pcGLB::mBefPos)
			.addProperty("mMDemoNo", &pcGLB::mMDemoNo)
			.addProperty("mPhase", &pcGLB::mPhase)
			.addProperty("mBeamColor", &pcGLB::mBeamColor)
			.addProperty("mbDemoWait", &pcGLB::mbDemoWait)
			.addProperty("mpWristLNode", &pcGLB::mpWristLNode)
			.addProperty("mpWepBeam", &pcGLB::mpWepBeam)
			.addProperty("mbCanKick", &pcGLB::mbCanKick)
			.addProperty("mhVernierSE", &pcGLB::mhVernierSE)
			.addProperty("mMDFlag", &pcGLB::mMDFlag)
			.addFunction("SetLoopTick", &pcGLB::SetLoopTick)
			.addFunction("GetLoopTick", &pcGLB::GetLoopTick)
			.addFunction("GetAirY", &pcGLB::GetAirY)
			.addFunction("GetSDP", &pcGLB::GetSDP)
			.addFunction("GetIntarface", &pcGLB::GetIntarface)
			.addFunction("GetCamera", &pcGLB::GetCamera)
			.addFunction("IsDemoWait", &pcGLB::IsDemoWait)
			.addFunction("SetZoom", &pcGLB::SetZoom)
			.addFunction("CanOperate", &pcGLB::CanOperate)
			.addFunction("GetTension", &pcGLB::GetTension)
			.addFunction("mPostFrameCommonProc1", &pcGLB::mPostFrameCommonProc1)
			.addFunction("IsMultiStep", &pcGLB::IsMultiStep)
			.addFunction("SeProc", &pcGLB::SeProc)
			.addFunction("IsAtkObj", &pcGLB::IsAtkObj)
			.addFunction("TensionUp", &pcGLB::TensionUp)
			.addFunction("PlayMiniDemo", &pcGLB::PlayMiniDemo)
			.addFunction("AirProc", &pcGLB::AirProc)
			.addFunction("SetAirDmg", &pcGLB::SetAirDmg)
			.addFunction("SetJump", &pcGLB::SetJump)
			.addFunction("GetCurAtkKind", &pcGLB::GetCurAtkKind)
			.addFunction("GetCurAtkNockBackDist", &pcGLB::GetCurAtkNockBackDist)
			.addFunction("GetCurAtkDamage", &pcGLB::GetCurAtkDamage)
			.addFunction("GetCurAtkAngle", &pcGLB::GetCurAtkAngle)
			.addFunction("GetCurAtkDist", &pcGLB::GetCurAtkDist)
			.addFunction("mGetAtkNo", &pcGLB::mGetAtkNo)
			.addFunction("AttackCheck", &pcGLB::AttackCheck)
			.addFunction("UpdataInfo", &pcGLB::UpdataInfo)
			.addFunction("SelectDmgMotion", &pcGLB::SelectDmgMotion)
			.addFunction("SetDamageIK", &pcGLB::SetDamageIK)
			.addFunction("GetAtkDirecKind", &pcGLB::GetAtkDirecKind)
			.addFunction("IsCanInput", &pcGLB::IsCanInput)
			.addFunction("KeyInput", &pcGLB::KeyInput)
			.addFunction("SetSDP", &pcGLB::SetSDP)
			.addFunction("GetPrevStateIdx", &pcGLB::GetPrevStateIdx)
			.addFunction("GetCurStateIdx", &pcGLB::GetCurStateIdx)
			.addFunction("ChangeState", &pcGLB::ChangeState)
			.addFunction("mLoseTsubazeriai", &pcGLB::mLoseTsubazeriai)
			.addFunction("mWinTsubazeriai", &pcGLB::mWinTsubazeriai)
			.addFunction("mCheckTsubazeriai", &pcGLB::mCheckTsubazeriai)
			.addFunction("mPlayMotTsubaszeriai", &pcGLB::mPlayMotTsubaszeriai)
			.addFunction("mCheckIntoTsubazeriai", &pcGLB::mCheckIntoTsubazeriai)
			.addFunction("mAttackProc", &pcGLB::mAttackProc)
			.addFunction("mGetAttackTableValue", &pcGLB::mGetAttackTableValue)
			.addFunction("mCheckComboing", &pcGLB::mCheckComboing)
			.addFunction("mCheckAttack", &pcGLB::mCheckAttack)
			.addFunction("mCheckCanHit", &pcGLB::mCheckCanHit)
			.addFunction("mSetDamage", &pcGLB::mSetDamage)
			.addFunction("mFrameProc", &pcGLB::mFrameProc)
			.addFunction("mTerm", &pcGLB::mTerm)
			.addFunction("mInit", &pcGLB::mInit)
		.endClass();
	}
#endif
};
static_assert(sizeof(pcGLB::mCanOperate) == 1, "expected pcGLB::mCanOperate to be size 1");
static_assert(sizeof(pcGLB::mTestOnCanOperate) == 1, "expected pcGLB::mTestOnCanOperate to be size 1");
static_assert(sizeof(pcGLB::mSideCamera) == 72, "expected pcGLB::mSideCamera to be size 72");
static_assert(sizeof(pcGLB::mpInterface) == 4, "expected pcGLB::mpInterface to be size 4");
static_assert(sizeof(pcGLB::mpSDP) == 4, "expected pcGLB::mpSDP to be size 4");
static_assert(sizeof(pcGLB::mStateMachine) == 144, "expected pcGLB::mStateMachine to be size 144");
static_assert(sizeof(pcGLB::mIdleState) == 4, "expected pcGLB::mIdleState to be size 4");
static_assert(sizeof(pcGLB::mWalkState) == 4, "expected pcGLB::mWalkState to be size 4");
static_assert(sizeof(pcGLB::mJampState) == 8, "expected pcGLB::mJampState to be size 8");
static_assert(sizeof(pcGLB::mDamageState) == 4, "expected pcGLB::mDamageState to be size 4");
static_assert(sizeof(pcGLB::mGuardState) == 4, "expected pcGLB::mGuardState to be size 4");
static_assert(sizeof(pcGLB::mComboState) == 8, "expected pcGLB::mComboState to be size 8");
static_assert(sizeof(pcGLB::mAirKickState) == 4, "expected pcGLB::mAirKickState to be size 4");
static_assert(sizeof(pcGLB::mDeathState) == 8, "expected pcGLB::mDeathState to be size 8");
static_assert(sizeof(pcGLB::mDmgInfo) == 44, "expected pcGLB::mDmgInfo to be size 44");
static_assert(sizeof(pcGLB::mTickCnt) == 24, "expected pcGLB::mTickCnt to be size 24");
static_assert(sizeof(pcGLB::mAirY) == 4, "expected pcGLB::mAirY to be size 4");
static_assert(sizeof(pcGLB::mAirPower) == 4, "expected pcGLB::mAirPower to be size 4");
static_assert(sizeof(pcGLB::mbAir) == 1, "expected pcGLB::mbAir to be size 1");
static_assert(sizeof(pcGLB::mTension) == 4, "expected pcGLB::mTension to be size 4");
static_assert(sizeof(pcGLB::mBefPos) == 12, "expected pcGLB::mBefPos to be size 12");
static_assert(sizeof(pcGLB::mMDemoNo) == 4, "expected pcGLB::mMDemoNo to be size 4");
static_assert(sizeof(pcGLB::mPhase) == 4, "expected pcGLB::mPhase to be size 4");
static_assert(sizeof(pcGLB::mBeamColor) == 4, "expected pcGLB::mBeamColor to be size 4");
static_assert(sizeof(pcGLB::mbDemoWait) == 1, "expected pcGLB::mbDemoWait to be size 1");
static_assert(sizeof(pcGLB::mpWristLNode) == 4, "expected pcGLB::mpWristLNode to be size 4");
static_assert(sizeof(pcGLB::mpWepBeam) == 4, "expected pcGLB::mpWepBeam to be size 4");
static_assert(sizeof(pcGLB::mbCanKick) == 1, "expected pcGLB::mbCanKick to be size 1");
static_assert(sizeof(pcGLB::mhVernierSE) == 4, "expected pcGLB::mhVernierSE to be size 4");
static_assert(sizeof(pcGLB::mMDFlag) == 4, "expected pcGLB::mMDFlag to be size 4");
static_assert(sizeof(pcGLB) == 0x714, "expected pcGLB to be size 0x714");

// [Structure] class EfRoboInterface
class EfRoboInterface : public HrTask
{
public:
	// enum EfRoboInterface::InterfaceState
	enum InterfaceState : uint32_t
	{
		// <State_Init = 0x0>
		State_Init = 0,

		// <State_FadeIn = 0x1>
		State_FadeIn = 1,

		// <State_Active = 0x2>
		State_Active = 2,

		// <State_FadeOut = 0x3>
		State_FadeOut = 3

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <class EffectSpeedBlur* mpBlur, offset 0x68>
	class EffectSpeedBlur* mpBlur = nullptr;

	// <struct tagGHMR_TEX mInputCZTex, offset 0x6c>
	struct tagGHMR_TEX mInputCZTex;

	// <struct tagGHMR_TEX mInputLineTex, offset 0x94>
	struct tagGHMR_TEX mInputLineTex;

	// <struct tagGHMR_TEX mPcHpFrameTex, offset 0xbc>
	struct tagGHMR_TEX mPcHpFrameTex;

	// <struct tagGHMR_TEX mEnemyHpFrameTex, offset 0xe4>
	struct tagGHMR_TEX mEnemyHpFrameTex;

	// <struct tagGHMR_TEX mHpTex, offset 0x10c>
	struct tagGHMR_TEX mHpTex;

	// <struct tagGHMR_TEX mFrameDamageTex, offset 0x134>
	struct tagGHMR_TEX mFrameDamageTex;

	// <struct tagGHMR_TEX mFrameTrvDmgTex, offset 0x15c>
	struct tagGHMR_TEX mFrameTrvDmgTex;

	// <struct tagGHMR_TEX mFrameSdpDmgTex, offset 0x184>
	struct tagGHMR_TEX mFrameSdpDmgTex;

	// <struct tagGHMR_TEX mFrameNoiseTex, offset 0x1ac>
	struct tagGHMR_TEX mFrameNoiseTex;

	// <struct tagGHMR_TEX mPcTensionFrameTex, offset 0x1d4>
	struct tagGHMR_TEX mPcTensionFrameTex;

	// <struct tagGHMR_TEX mEnemyTensionFrameTex, offset 0x1fc>
	struct tagGHMR_TEX mEnemyTensionFrameTex;

	// <struct tagGHMR_TEX mTensionTex, offset 0x224>
	struct tagGHMR_TEX mTensionTex;

	// <struct tagGHMR_TEX mPcTensionMaxTex, offset 0x24c>
	struct tagGHMR_TEX mPcTensionMaxTex;

	// <struct tagGHMR_TEX mEnemeyTensionMaxTex, offset 0x274>
	struct tagGHMR_TEX mEnemeyTensionMaxTex;

	// <struct tagGHMR_TEX mLTigerTex, offset 0x29c>
	struct tagGHMR_TEX mLTigerTex;

	// <struct tagGHMR_TEX mLBackTex, offset 0x2c4>
	struct tagGHMR_TEX mLBackTex;

	// <struct tagGHMR_TEX mRTigerTex, offset 0x2ec>
	struct tagGHMR_TEX mRTigerTex;

	// <struct tagGHMR_TEX mRBackTex, offset 0x314>
	struct tagGHMR_TEX mRBackTex;

	// <enum EfRoboInterface::InterfaceState mInputCState, offset 0x33c>
	enum EfRoboInterface::InterfaceState mInputCState;

	// <float mInputCSlide, offset 0x340>
	float mInputCSlide = 0;

	// <uint8_t mbInputCVisble, offset 0x344>
	uint8_t mbInputCVisble = 0;

	// <Unidentified data segment, offset 0x345>
private:
	char _UnidentifiedData_837[3];

public:
	// <float mInputCAlpha, offset 0x348>
	float mInputCAlpha = 0;

	// <enum EfRoboInterface::InterfaceState mBlackState, offset 0x34c>
	enum EfRoboInterface::InterfaceState mBlackState;

	// <float mBlackAlpha, offset 0x350>
	float mBlackAlpha = 0;

	// <enum EfRoboInterface::InterfaceState mPcFlashState, offset 0x354>
	enum EfRoboInterface::InterfaceState mPcFlashState;

	// <int32_t mPcFlashAnimeCnt, offset 0x358>
	int32_t mPcFlashAnimeCnt = 0;

	// <int32_t mPcFlashCnt, offset 0x35c>
	int32_t mPcFlashCnt = 0;

	// <float mPcFlashAlpha, offset 0x360>
	float mPcFlashAlpha = 0;

	// <enum EfRoboInterface::InterfaceState mEnemyFlashState, offset 0x364>
	enum EfRoboInterface::InterfaceState mEnemyFlashState;

	// <int32_t mEnemyFlashAnimeCnt, offset 0x368>
	int32_t mEnemyFlashAnimeCnt = 0;

	// <int32_t mEnemyFlashCnt, offset 0x36c>
	int32_t mEnemyFlashCnt = 0;

	// <float mEnemyFlashAlpha, offset 0x370>
	float mEnemyFlashAlpha = 0;

	// <float mPcHpRate, offset 0x374>
	float mPcHpRate = 0;

	// <float mPcHpRateTarget, offset 0x378>
	float mPcHpRateTarget = 0;

	// <float mBefPcHpRateTarget, offset 0x37c>
	float mBefPcHpRateTarget = 0;

	// <float mPcDmgSubRate, offset 0x380>
	float mPcDmgSubRate = 0;

	// <float mEnemyHpRate, offset 0x384>
	float mEnemyHpRate = 0;

	// <float mEnemyHpRateTarget, offset 0x388>
	float mEnemyHpRateTarget = 0;

	// <float mBefEnemyHpRateTarget, offset 0x38c>
	float mBefEnemyHpRateTarget = 0;

	// <float mEnemyDmgSubRate, offset 0x390>
	float mEnemyDmgSubRate = 0;

	// <float mPcHpWait, offset 0x394>
	float mPcHpWait = 0;

	// <float mEnemyHpWait, offset 0x398>
	float mEnemyHpWait = 0;

	// <float mPcTensionRate, offset 0x39c>
	float mPcTensionRate = 0;

	// <float mPcTensionRateTarget, offset 0x3a0>
	float mPcTensionRateTarget = 0;

	// <float mEnemyTensionRate, offset 0x3a4>
	float mEnemyTensionRate = 0;

	// <float mEnemyTensionRateTarget, offset 0x3a8>
	float mEnemyTensionRateTarget = 0;

	// <float mTensionSlide, offset 0x3ac>
	float mTensionSlide = 0;

	// <uint8_t mbPcMaxVisible, offset 0x3b0>
	uint8_t mbPcMaxVisible = 0;

	// <uint8_t mbEnemyMaxVisible, offset 0x3b1>
	uint8_t mbEnemyMaxVisible = 0;

	// <Unidentified data segment, offset 0x3b2>
private:
	char _UnidentifiedData_946[2];

public:
	// <uint32_t mDmgAnimeCnt, offset 0x3b4>
	uint32_t mDmgAnimeCnt = 0;

	// <uint8_t mbFinish, offset 0x3b8>
	uint8_t mbFinish = 0;

	// <Unidentified data segment, offset 0x3b9>
private:
	char _UnidentifiedData_953[3];

public:
	// <float mBlurAlpha, offset 0x3bc>
	float mBlurAlpha = 0;

	// <uint8_t mBlurValid, offset 0x3c0>
	uint8_t mBlurValid = 0;

	// <Unidentified data segment, offset 0x3c1>
private:
	char _UnidentifiedData_961[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfRoboInterface [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfRoboInterface& InObject)
	{
		field_50 = InObject.field_50;
		mpBlur = InObject.mpBlur;
		mInputCZTex = InObject.mInputCZTex;
		mInputLineTex = InObject.mInputLineTex;
		mPcHpFrameTex = InObject.mPcHpFrameTex;
		mEnemyHpFrameTex = InObject.mEnemyHpFrameTex;
		mHpTex = InObject.mHpTex;
		mFrameDamageTex = InObject.mFrameDamageTex;
		mFrameTrvDmgTex = InObject.mFrameTrvDmgTex;
		mFrameSdpDmgTex = InObject.mFrameSdpDmgTex;
		mFrameNoiseTex = InObject.mFrameNoiseTex;
		mPcTensionFrameTex = InObject.mPcTensionFrameTex;
		mEnemyTensionFrameTex = InObject.mEnemyTensionFrameTex;
		mTensionTex = InObject.mTensionTex;
		mPcTensionMaxTex = InObject.mPcTensionMaxTex;
		mEnemeyTensionMaxTex = InObject.mEnemeyTensionMaxTex;
		mLTigerTex = InObject.mLTigerTex;
		mLBackTex = InObject.mLBackTex;
		mRTigerTex = InObject.mRTigerTex;
		mRBackTex = InObject.mRBackTex;
		mInputCState = InObject.mInputCState;
		mInputCSlide = InObject.mInputCSlide;
		mbInputCVisble = InObject.mbInputCVisble;
		mInputCAlpha = InObject.mInputCAlpha;
		mBlackState = InObject.mBlackState;
		mBlackAlpha = InObject.mBlackAlpha;
		mPcFlashState = InObject.mPcFlashState;
		mPcFlashAnimeCnt = InObject.mPcFlashAnimeCnt;
		mPcFlashCnt = InObject.mPcFlashCnt;
		mPcFlashAlpha = InObject.mPcFlashAlpha;
		mEnemyFlashState = InObject.mEnemyFlashState;
		mEnemyFlashAnimeCnt = InObject.mEnemyFlashAnimeCnt;
		mEnemyFlashCnt = InObject.mEnemyFlashCnt;
		mEnemyFlashAlpha = InObject.mEnemyFlashAlpha;
		mPcHpRate = InObject.mPcHpRate;
		mPcHpRateTarget = InObject.mPcHpRateTarget;
		mBefPcHpRateTarget = InObject.mBefPcHpRateTarget;
		mPcDmgSubRate = InObject.mPcDmgSubRate;
		mEnemyHpRate = InObject.mEnemyHpRate;
		mEnemyHpRateTarget = InObject.mEnemyHpRateTarget;
		mBefEnemyHpRateTarget = InObject.mBefEnemyHpRateTarget;
		mEnemyDmgSubRate = InObject.mEnemyDmgSubRate;
		mPcHpWait = InObject.mPcHpWait;
		mEnemyHpWait = InObject.mEnemyHpWait;
		mPcTensionRate = InObject.mPcTensionRate;
		mPcTensionRateTarget = InObject.mPcTensionRateTarget;
		mEnemyTensionRate = InObject.mEnemyTensionRate;
		mEnemyTensionRateTarget = InObject.mEnemyTensionRateTarget;
		mTensionSlide = InObject.mTensionSlide;
		mbPcMaxVisible = InObject.mbPcMaxVisible;
		mbEnemyMaxVisible = InObject.mbEnemyMaxVisible;
		mDmgAnimeCnt = InObject.mDmgAnimeCnt;
		mbFinish = InObject.mbFinish;
		mBlurAlpha = InObject.mBlurAlpha;
		mBlurValid = InObject.mBlurValid;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfRoboInterface, HrTask>("EfRoboInterface")
			.addFunction("__tostring", &EfRoboInterface::ToString)
			.addFunction("GetPtrAddr", &EfRoboInterface::GetPtrAddr)
			.addProperty("field_50", &EfRoboInterface::field_50)
			.addProperty("mpBlur", &EfRoboInterface::mpBlur)
			.addProperty("mInputCZTex", &EfRoboInterface::mInputCZTex)
			.addProperty("mInputLineTex", &EfRoboInterface::mInputLineTex)
			.addProperty("mPcHpFrameTex", &EfRoboInterface::mPcHpFrameTex)
			.addProperty("mEnemyHpFrameTex", &EfRoboInterface::mEnemyHpFrameTex)
			.addProperty("mHpTex", &EfRoboInterface::mHpTex)
			.addProperty("mFrameDamageTex", &EfRoboInterface::mFrameDamageTex)
			.addProperty("mFrameTrvDmgTex", &EfRoboInterface::mFrameTrvDmgTex)
			.addProperty("mFrameSdpDmgTex", &EfRoboInterface::mFrameSdpDmgTex)
			.addProperty("mFrameNoiseTex", &EfRoboInterface::mFrameNoiseTex)
			.addProperty("mPcTensionFrameTex", &EfRoboInterface::mPcTensionFrameTex)
			.addProperty("mEnemyTensionFrameTex", &EfRoboInterface::mEnemyTensionFrameTex)
			.addProperty("mTensionTex", &EfRoboInterface::mTensionTex)
			.addProperty("mPcTensionMaxTex", &EfRoboInterface::mPcTensionMaxTex)
			.addProperty("mEnemeyTensionMaxTex", &EfRoboInterface::mEnemeyTensionMaxTex)
			.addProperty("mLTigerTex", &EfRoboInterface::mLTigerTex)
			.addProperty("mLBackTex", &EfRoboInterface::mLBackTex)
			.addProperty("mRTigerTex", &EfRoboInterface::mRTigerTex)
			.addProperty("mRBackTex", &EfRoboInterface::mRBackTex)
			.addProperty("mInputCState", &EfRoboInterface::mInputCState)
			.addProperty("mInputCSlide", &EfRoboInterface::mInputCSlide)
			.addProperty("mbInputCVisble", &EfRoboInterface::mbInputCVisble)
			.addProperty("mInputCAlpha", &EfRoboInterface::mInputCAlpha)
			.addProperty("mBlackState", &EfRoboInterface::mBlackState)
			.addProperty("mBlackAlpha", &EfRoboInterface::mBlackAlpha)
			.addProperty("mPcFlashState", &EfRoboInterface::mPcFlashState)
			.addProperty("mPcFlashAnimeCnt", &EfRoboInterface::mPcFlashAnimeCnt)
			.addProperty("mPcFlashCnt", &EfRoboInterface::mPcFlashCnt)
			.addProperty("mPcFlashAlpha", &EfRoboInterface::mPcFlashAlpha)
			.addProperty("mEnemyFlashState", &EfRoboInterface::mEnemyFlashState)
			.addProperty("mEnemyFlashAnimeCnt", &EfRoboInterface::mEnemyFlashAnimeCnt)
			.addProperty("mEnemyFlashCnt", &EfRoboInterface::mEnemyFlashCnt)
			.addProperty("mEnemyFlashAlpha", &EfRoboInterface::mEnemyFlashAlpha)
			.addProperty("mPcHpRate", &EfRoboInterface::mPcHpRate)
			.addProperty("mPcHpRateTarget", &EfRoboInterface::mPcHpRateTarget)
			.addProperty("mBefPcHpRateTarget", &EfRoboInterface::mBefPcHpRateTarget)
			.addProperty("mPcDmgSubRate", &EfRoboInterface::mPcDmgSubRate)
			.addProperty("mEnemyHpRate", &EfRoboInterface::mEnemyHpRate)
			.addProperty("mEnemyHpRateTarget", &EfRoboInterface::mEnemyHpRateTarget)
			.addProperty("mBefEnemyHpRateTarget", &EfRoboInterface::mBefEnemyHpRateTarget)
			.addProperty("mEnemyDmgSubRate", &EfRoboInterface::mEnemyDmgSubRate)
			.addProperty("mPcHpWait", &EfRoboInterface::mPcHpWait)
			.addProperty("mEnemyHpWait", &EfRoboInterface::mEnemyHpWait)
			.addProperty("mPcTensionRate", &EfRoboInterface::mPcTensionRate)
			.addProperty("mPcTensionRateTarget", &EfRoboInterface::mPcTensionRateTarget)
			.addProperty("mEnemyTensionRate", &EfRoboInterface::mEnemyTensionRate)
			.addProperty("mEnemyTensionRateTarget", &EfRoboInterface::mEnemyTensionRateTarget)
			.addProperty("mTensionSlide", &EfRoboInterface::mTensionSlide)
			.addProperty("mbPcMaxVisible", &EfRoboInterface::mbPcMaxVisible)
			.addProperty("mbEnemyMaxVisible", &EfRoboInterface::mbEnemyMaxVisible)
			.addProperty("mDmgAnimeCnt", &EfRoboInterface::mDmgAnimeCnt)
			.addProperty("mbFinish", &EfRoboInterface::mbFinish)
			.addProperty("mBlurAlpha", &EfRoboInterface::mBlurAlpha)
			.addProperty("mBlurValid", &EfRoboInterface::mBlurValid)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfRoboInterface::field_50) == 24, "expected EfRoboInterface::field_50 to be size 24");
static_assert(sizeof(EfRoboInterface::mpBlur) == 4, "expected EfRoboInterface::mpBlur to be size 4");
static_assert(sizeof(EfRoboInterface::mInputCZTex) == 40, "expected EfRoboInterface::mInputCZTex to be size 40");
static_assert(sizeof(EfRoboInterface::mInputLineTex) == 40, "expected EfRoboInterface::mInputLineTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcHpFrameTex) == 40, "expected EfRoboInterface::mPcHpFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemyHpFrameTex) == 40, "expected EfRoboInterface::mEnemyHpFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mHpTex) == 40, "expected EfRoboInterface::mHpTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameDamageTex) == 40, "expected EfRoboInterface::mFrameDamageTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameTrvDmgTex) == 40, "expected EfRoboInterface::mFrameTrvDmgTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameSdpDmgTex) == 40, "expected EfRoboInterface::mFrameSdpDmgTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameNoiseTex) == 40, "expected EfRoboInterface::mFrameNoiseTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcTensionFrameTex) == 40, "expected EfRoboInterface::mPcTensionFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemyTensionFrameTex) == 40, "expected EfRoboInterface::mEnemyTensionFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mTensionTex) == 40, "expected EfRoboInterface::mTensionTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcTensionMaxTex) == 40, "expected EfRoboInterface::mPcTensionMaxTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemeyTensionMaxTex) == 40, "expected EfRoboInterface::mEnemeyTensionMaxTex to be size 40");
static_assert(sizeof(EfRoboInterface::mLTigerTex) == 40, "expected EfRoboInterface::mLTigerTex to be size 40");
static_assert(sizeof(EfRoboInterface::mLBackTex) == 40, "expected EfRoboInterface::mLBackTex to be size 40");
static_assert(sizeof(EfRoboInterface::mRTigerTex) == 40, "expected EfRoboInterface::mRTigerTex to be size 40");
static_assert(sizeof(EfRoboInterface::mRBackTex) == 40, "expected EfRoboInterface::mRBackTex to be size 40");
static_assert(sizeof(EfRoboInterface::mInputCState) == 4, "expected EfRoboInterface::mInputCState to be size 4");
static_assert(sizeof(EfRoboInterface::mInputCSlide) == 4, "expected EfRoboInterface::mInputCSlide to be size 4");
static_assert(sizeof(EfRoboInterface::mbInputCVisble) == 1, "expected EfRoboInterface::mbInputCVisble to be size 1");
static_assert(sizeof(EfRoboInterface::mInputCAlpha) == 4, "expected EfRoboInterface::mInputCAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mBlackState) == 4, "expected EfRoboInterface::mBlackState to be size 4");
static_assert(sizeof(EfRoboInterface::mBlackAlpha) == 4, "expected EfRoboInterface::mBlackAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashState) == 4, "expected EfRoboInterface::mPcFlashState to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashAnimeCnt) == 4, "expected EfRoboInterface::mPcFlashAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashCnt) == 4, "expected EfRoboInterface::mPcFlashCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashAlpha) == 4, "expected EfRoboInterface::mPcFlashAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashState) == 4, "expected EfRoboInterface::mEnemyFlashState to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashAnimeCnt) == 4, "expected EfRoboInterface::mEnemyFlashAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashCnt) == 4, "expected EfRoboInterface::mEnemyFlashCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashAlpha) == 4, "expected EfRoboInterface::mEnemyFlashAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpRate) == 4, "expected EfRoboInterface::mPcHpRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpRateTarget) == 4, "expected EfRoboInterface::mPcHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mBefPcHpRateTarget) == 4, "expected EfRoboInterface::mBefPcHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mPcDmgSubRate) == 4, "expected EfRoboInterface::mPcDmgSubRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpRate) == 4, "expected EfRoboInterface::mEnemyHpRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpRateTarget) == 4, "expected EfRoboInterface::mEnemyHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mBefEnemyHpRateTarget) == 4, "expected EfRoboInterface::mBefEnemyHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyDmgSubRate) == 4, "expected EfRoboInterface::mEnemyDmgSubRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpWait) == 4, "expected EfRoboInterface::mPcHpWait to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpWait) == 4, "expected EfRoboInterface::mEnemyHpWait to be size 4");
static_assert(sizeof(EfRoboInterface::mPcTensionRate) == 4, "expected EfRoboInterface::mPcTensionRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcTensionRateTarget) == 4, "expected EfRoboInterface::mPcTensionRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyTensionRate) == 4, "expected EfRoboInterface::mEnemyTensionRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyTensionRateTarget) == 4, "expected EfRoboInterface::mEnemyTensionRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mTensionSlide) == 4, "expected EfRoboInterface::mTensionSlide to be size 4");
static_assert(sizeof(EfRoboInterface::mbPcMaxVisible) == 1, "expected EfRoboInterface::mbPcMaxVisible to be size 1");
static_assert(sizeof(EfRoboInterface::mbEnemyMaxVisible) == 1, "expected EfRoboInterface::mbEnemyMaxVisible to be size 1");
static_assert(sizeof(EfRoboInterface::mDmgAnimeCnt) == 4, "expected EfRoboInterface::mDmgAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mbFinish) == 1, "expected EfRoboInterface::mbFinish to be size 1");
static_assert(sizeof(EfRoboInterface::mBlurAlpha) == 4, "expected EfRoboInterface::mBlurAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mBlurValid) == 1, "expected EfRoboInterface::mBlurValid to be size 1");
static_assert(sizeof(EfRoboInterface) == 0x3c4, "expected EfRoboInterface to be size 0x3c4");

// [Structure] class CmDeathState
class CmDeathState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <uint8_t mbDeadScriptCall, offset 0x4>
	uint8_t mbDeadScriptCall = 0;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CmDeathState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CmDeathState& InObject)
	{
		mbDeadScriptCall = InObject.mbDeadScriptCall;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmDeathState>("CmDeathState")
			.addFunction("__tostring", &CmDeathState::ToString)
			.addFunction("GetPtrAddr", &CmDeathState::GetPtrAddr)
			.addProperty("mbDeadScriptCall", &CmDeathState::mbDeadScriptCall)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmDeathState::mbDeadScriptCall) == 1, "expected CmDeathState::mbDeadScriptCall to be size 1");
static_assert(sizeof(CmDeathState) == 0x8, "expected CmDeathState to be size 0x8");

// [Structure] class SDPDeathState
class SDPDeathState : public CmDeathState
{
public:
	/// Struct member variables

	// <class CmDeathState field_0, offset 0x0>
	// class CmDeathState Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class SDPDeathState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SDPDeathState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<SDPDeathState, CmDeathState>("SDPDeathState")
			.addFunction("__tostring", &SDPDeathState::ToString)
			.addFunction("GetPtrAddr", &SDPDeathState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPDeathState) == 0x8, "expected SDPDeathState to be size 0x8");

// [Structure] class SDPComboState
class SDPComboState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class SDPComboState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SDPComboState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPComboState>("SDPComboState")
			.addFunction("__tostring", &SDPComboState::ToString)
			.addFunction("GetPtrAddr", &SDPComboState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPComboState) == 0x4, "expected SDPComboState to be size 0x4");

// [Structure] class CmDamageState
class CmDamageState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <int32_t mDownTick, offset 0x4>
	int32_t mDownTick = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CmDamageState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CmDamageState& InObject)
	{
		mDownTick = InObject.mDownTick;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmDamageState>("CmDamageState")
			.addFunction("__tostring", &CmDamageState::ToString)
			.addFunction("GetPtrAddr", &CmDamageState::GetPtrAddr)
			.addProperty("mDownTick", &CmDamageState::mDownTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmDamageState::mDownTick) == 4, "expected CmDamageState::mDownTick to be size 4");
static_assert(sizeof(CmDamageState) == 0x8, "expected CmDamageState to be size 0x8");

// [Structure] class SDPDamageState
class SDPDamageState : public CmDamageState
{
public:
	/// Struct member variables

	// <class CmDamageState field_0, offset 0x0>
	// class CmDamageState Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class SDPDamageState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SDPDamageState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<SDPDamageState, CmDamageState>("SDPDamageState")
			.addFunction("__tostring", &SDPDamageState::ToString)
			.addFunction("GetPtrAddr", &SDPDamageState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPDamageState) == 0x8, "expected SDPDamageState to be size 0x8");

// [Structure] class SDPBeamState
class SDPBeamState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class SDPBeamState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SDPBeamState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPBeamState>("SDPBeamState")
			.addFunction("__tostring", &SDPBeamState::ToString)
			.addFunction("GetPtrAddr", &SDPBeamState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPBeamState) == 0x4, "expected SDPBeamState to be size 0x4");

// [Structure] class CmIdleState
class CmIdleState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <int32_t mContinuTick, offset 0x4>
	int32_t mContinuTick = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CmIdleState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CmIdleState& InObject)
	{
		mContinuTick = InObject.mContinuTick;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmIdleState>("CmIdleState")
			.addFunction("__tostring", &CmIdleState::ToString)
			.addFunction("GetPtrAddr", &CmIdleState::GetPtrAddr)
			.addProperty("mContinuTick", &CmIdleState::mContinuTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmIdleState::mContinuTick) == 4, "expected CmIdleState::mContinuTick to be size 4");
static_assert(sizeof(CmIdleState) == 0x8, "expected CmIdleState to be size 0x8");

// [Structure] class SDPIdleState
class SDPIdleState : public CmIdleState
{
public:
	/// Struct member variables

	// <class CmIdleState field_0, offset 0x0>
	// class CmIdleState Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class SDPIdleState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SDPIdleState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<SDPIdleState, CmIdleState>("SDPIdleState")
			.addFunction("__tostring", &SDPIdleState::ToString)
			.addFunction("GetPtrAddr", &SDPIdleState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPIdleState) == 0x8, "expected SDPIdleState to be size 0x8");

// [Structure] class bsBasic
class bsBasic : public mHRChara
{
public:
	// [Structure] struct bsBasic::PcInfo
	struct PcInfo
	{
	public:
		/// Struct member variables

		// <struct Vec Pos, offset 0x0>
		struct Vec Pos;

		// <struct Vec NavelPos, offset 0xc>
		struct Vec NavelPos;

		// <struct Vec Direc, offset 0x18>
		struct Vec Direc;

		// <float DirecY, offset 0x24>
		float DirecY = 0;

		// <float Dist, offset 0x28>
		float Dist = 0;

		// <float SubAngle, offset 0x2c>
		float SubAngle = 0;

		// <float RotY, offset 0x30>
		float RotY = 0;

		// <uint8_t bObstacle, offset 0x34>
		uint8_t bObstacle = 0;

		// <Unidentified data segment, offset 0x35>
	private:
		char _UnidentifiedData_53[3];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct bsBasic::PcInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(bsBasic::PcInfo& InObject)
		{
			Pos = InObject.Pos;
			NavelPos = InObject.NavelPos;
			Direc = InObject.Direc;
			DirecY = InObject.DirecY;
			Dist = InObject.Dist;
			SubAngle = InObject.SubAngle;
			RotY = InObject.RotY;
			bObstacle = InObject.bObstacle;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PcInfo>("bsBasic_PcInfo")
				.addFunction("__tostring", &bsBasic::PcInfo::ToString)
				.addFunction("GetPtrAddr", &bsBasic::PcInfo::GetPtrAddr)
				.addProperty("Pos", &bsBasic::PcInfo::Pos)
				.addProperty("NavelPos", &bsBasic::PcInfo::NavelPos)
				.addProperty("Direc", &bsBasic::PcInfo::Direc)
				.addProperty("DirecY", &bsBasic::PcInfo::DirecY)
				.addProperty("Dist", &bsBasic::PcInfo::Dist)
				.addProperty("SubAngle", &bsBasic::PcInfo::SubAngle)
				.addProperty("RotY", &bsBasic::PcInfo::RotY)
				.addProperty("bObstacle", &bsBasic::PcInfo::bObstacle)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::PcInfo::Pos) == 12, "expected bsBasic::PcInfo::Pos to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::NavelPos) == 12, "expected bsBasic::PcInfo::NavelPos to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::Direc) == 12, "expected bsBasic::PcInfo::Direc to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::DirecY) == 4, "expected bsBasic::PcInfo::DirecY to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::Dist) == 4, "expected bsBasic::PcInfo::Dist to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::SubAngle) == 4, "expected bsBasic::PcInfo::SubAngle to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::RotY) == 4, "expected bsBasic::PcInfo::RotY to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::bObstacle) == 1, "expected bsBasic::PcInfo::bObstacle to be size 1");
	static_assert(sizeof(bsBasic::PcInfo) == 0x38, "expected bsBasic::PcInfo to be size 0x38");

	// [Structure] struct bsBasic::SurroundInfo
	struct SurroundInfo
	{
	public:
		/// Struct member variables

		// <float SearchDist, offset 0x0>
		float SearchDist = 0;

		// <float FrontDist, offset 0x4>
		float FrontDist = 0;

		// <float BackDist, offset 0x8>
		float BackDist = 0;

		// <float RightDist, offset 0xc>
		float RightDist = 0;

		// <float LeftDist, offset 0x10>
		float LeftDist = 0;

		// <struct Vec FrontPos, offset 0x14>
		struct Vec FrontPos;

		// <struct Vec BackPos, offset 0x20>
		struct Vec BackPos;

		// <struct Vec RightPos, offset 0x2c>
		struct Vec RightPos;

		// <struct Vec LeftPos, offset 0x38>
		struct Vec LeftPos;

		// <float StageFrontDist, offset 0x44>
		float StageFrontDist = 0;

		// <float StageBackDist, offset 0x48>
		float StageBackDist = 0;

		// <float StageRightDist, offset 0x4c>
		float StageRightDist = 0;

		// <float StageLeftDist, offset 0x50>
		float StageLeftDist = 0;

		// <struct Vec StageFrontPos, offset 0x54>
		struct Vec StageFrontPos;

		// <struct Vec StageBackPos, offset 0x60>
		struct Vec StageBackPos;

		// <struct Vec StageRightPos, offset 0x6c>
		struct Vec StageRightPos;

		// <struct Vec StageLeftPos, offset 0x78>
		struct Vec StageLeftPos;

		// <float CharaFrontDist, offset 0x84>
		float CharaFrontDist = 0;

		// <float CharaBackDist, offset 0x88>
		float CharaBackDist = 0;

		// <float CharaRightDist, offset 0x8c>
		float CharaRightDist = 0;

		// <float CharaLeftDist, offset 0x90>
		float CharaLeftDist = 0;

		// <struct Vec CharaFrontPos, offset 0x94>
		struct Vec CharaFrontPos;

		// <struct Vec CharaBackPos, offset 0xa0>
		struct Vec CharaBackPos;

		// <struct Vec CharaRightPos, offset 0xac>
		struct Vec CharaRightPos;

		// <struct Vec CharaLeftPos, offset 0xb8>
		struct Vec CharaLeftPos;

		// <float TargetDist, offset 0xc4>
		float TargetDist = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct bsBasic::SurroundInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(bsBasic::SurroundInfo& InObject)
		{
			SearchDist = InObject.SearchDist;
			FrontDist = InObject.FrontDist;
			BackDist = InObject.BackDist;
			RightDist = InObject.RightDist;
			LeftDist = InObject.LeftDist;
			FrontPos = InObject.FrontPos;
			BackPos = InObject.BackPos;
			RightPos = InObject.RightPos;
			LeftPos = InObject.LeftPos;
			StageFrontDist = InObject.StageFrontDist;
			StageBackDist = InObject.StageBackDist;
			StageRightDist = InObject.StageRightDist;
			StageLeftDist = InObject.StageLeftDist;
			StageFrontPos = InObject.StageFrontPos;
			StageBackPos = InObject.StageBackPos;
			StageRightPos = InObject.StageRightPos;
			StageLeftPos = InObject.StageLeftPos;
			CharaFrontDist = InObject.CharaFrontDist;
			CharaBackDist = InObject.CharaBackDist;
			CharaRightDist = InObject.CharaRightDist;
			CharaLeftDist = InObject.CharaLeftDist;
			CharaFrontPos = InObject.CharaFrontPos;
			CharaBackPos = InObject.CharaBackPos;
			CharaRightPos = InObject.CharaRightPos;
			CharaLeftPos = InObject.CharaLeftPos;
			TargetDist = InObject.TargetDist;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<SurroundInfo>("bsBasic_SurroundInfo")
				.addFunction("__tostring", &bsBasic::SurroundInfo::ToString)
				.addFunction("GetPtrAddr", &bsBasic::SurroundInfo::GetPtrAddr)
				.addProperty("SearchDist", &bsBasic::SurroundInfo::SearchDist)
				.addProperty("FrontDist", &bsBasic::SurroundInfo::FrontDist)
				.addProperty("BackDist", &bsBasic::SurroundInfo::BackDist)
				.addProperty("RightDist", &bsBasic::SurroundInfo::RightDist)
				.addProperty("LeftDist", &bsBasic::SurroundInfo::LeftDist)
				.addProperty("FrontPos", &bsBasic::SurroundInfo::FrontPos)
				.addProperty("BackPos", &bsBasic::SurroundInfo::BackPos)
				.addProperty("RightPos", &bsBasic::SurroundInfo::RightPos)
				.addProperty("LeftPos", &bsBasic::SurroundInfo::LeftPos)
				.addProperty("StageFrontDist", &bsBasic::SurroundInfo::StageFrontDist)
				.addProperty("StageBackDist", &bsBasic::SurroundInfo::StageBackDist)
				.addProperty("StageRightDist", &bsBasic::SurroundInfo::StageRightDist)
				.addProperty("StageLeftDist", &bsBasic::SurroundInfo::StageLeftDist)
				.addProperty("StageFrontPos", &bsBasic::SurroundInfo::StageFrontPos)
				.addProperty("StageBackPos", &bsBasic::SurroundInfo::StageBackPos)
				.addProperty("StageRightPos", &bsBasic::SurroundInfo::StageRightPos)
				.addProperty("StageLeftPos", &bsBasic::SurroundInfo::StageLeftPos)
				.addProperty("CharaFrontDist", &bsBasic::SurroundInfo::CharaFrontDist)
				.addProperty("CharaBackDist", &bsBasic::SurroundInfo::CharaBackDist)
				.addProperty("CharaRightDist", &bsBasic::SurroundInfo::CharaRightDist)
				.addProperty("CharaLeftDist", &bsBasic::SurroundInfo::CharaLeftDist)
				.addProperty("CharaFrontPos", &bsBasic::SurroundInfo::CharaFrontPos)
				.addProperty("CharaBackPos", &bsBasic::SurroundInfo::CharaBackPos)
				.addProperty("CharaRightPos", &bsBasic::SurroundInfo::CharaRightPos)
				.addProperty("CharaLeftPos", &bsBasic::SurroundInfo::CharaLeftPos)
				.addProperty("TargetDist", &bsBasic::SurroundInfo::TargetDist)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::SurroundInfo::SearchDist) == 4, "expected bsBasic::SurroundInfo::SearchDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::FrontDist) == 4, "expected bsBasic::SurroundInfo::FrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::BackDist) == 4, "expected bsBasic::SurroundInfo::BackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::RightDist) == 4, "expected bsBasic::SurroundInfo::RightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::LeftDist) == 4, "expected bsBasic::SurroundInfo::LeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::FrontPos) == 12, "expected bsBasic::SurroundInfo::FrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::BackPos) == 12, "expected bsBasic::SurroundInfo::BackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::RightPos) == 12, "expected bsBasic::SurroundInfo::RightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::LeftPos) == 12, "expected bsBasic::SurroundInfo::LeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageFrontDist) == 4, "expected bsBasic::SurroundInfo::StageFrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageBackDist) == 4, "expected bsBasic::SurroundInfo::StageBackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageRightDist) == 4, "expected bsBasic::SurroundInfo::StageRightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageLeftDist) == 4, "expected bsBasic::SurroundInfo::StageLeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageFrontPos) == 12, "expected bsBasic::SurroundInfo::StageFrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageBackPos) == 12, "expected bsBasic::SurroundInfo::StageBackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageRightPos) == 12, "expected bsBasic::SurroundInfo::StageRightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageLeftPos) == 12, "expected bsBasic::SurroundInfo::StageLeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaFrontDist) == 4, "expected bsBasic::SurroundInfo::CharaFrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaBackDist) == 4, "expected bsBasic::SurroundInfo::CharaBackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaRightDist) == 4, "expected bsBasic::SurroundInfo::CharaRightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaLeftDist) == 4, "expected bsBasic::SurroundInfo::CharaLeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaFrontPos) == 12, "expected bsBasic::SurroundInfo::CharaFrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaBackPos) == 12, "expected bsBasic::SurroundInfo::CharaBackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaRightPos) == 12, "expected bsBasic::SurroundInfo::CharaRightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaLeftPos) == 12, "expected bsBasic::SurroundInfo::CharaLeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::TargetDist) == 4, "expected bsBasic::SurroundInfo::TargetDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo) == 0xc8, "expected bsBasic::SurroundInfo to be size 0xc8");

	// [Structure] struct bsBasic::DistSense
	struct DistSense
	{
	public:
		/// Struct member variables

		// <float Base, offset 0x0>
		float Base = 0;

		// <float Small, offset 0x4>
		float Small = 0;

		// <float Middle, offset 0x8>
		float Middle = 0;

		// <float Long, offset 0xc>
		float Long = 0;

		// <float Allowance, offset 0x10>
		float Allowance = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct bsBasic::DistSense [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(bsBasic::DistSense& InObject)
		{
			Base = InObject.Base;
			Small = InObject.Small;
			Middle = InObject.Middle;
			Long = InObject.Long;
			Allowance = InObject.Allowance;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<DistSense>("bsBasic_DistSense")
				.addFunction("__tostring", &bsBasic::DistSense::ToString)
				.addFunction("GetPtrAddr", &bsBasic::DistSense::GetPtrAddr)
				.addProperty("Base", &bsBasic::DistSense::Base)
				.addProperty("Small", &bsBasic::DistSense::Small)
				.addProperty("Middle", &bsBasic::DistSense::Middle)
				.addProperty("Long", &bsBasic::DistSense::Long)
				.addProperty("Allowance", &bsBasic::DistSense::Allowance)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::DistSense::Base) == 4, "expected bsBasic::DistSense::Base to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Small) == 4, "expected bsBasic::DistSense::Small to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Middle) == 4, "expected bsBasic::DistSense::Middle to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Long) == 4, "expected bsBasic::DistSense::Long to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Allowance) == 4, "expected bsBasic::DistSense::Allowance to be size 4");
	static_assert(sizeof(bsBasic::DistSense) == 0x14, "expected bsBasic::DistSense to be size 0x14");

	// [Structure] struct bsBasic::TickCnt
	struct TickCnt
	{
	public:
		/// Struct member variables

		// <int32_t Motion, offset 0x0>
		int32_t Motion = 0;

		// <int32_t AtkWait, offset 0x4>
		int32_t AtkWait = 0;

		// <int32_t Loop, offset 0x8>
		int32_t Loop = 0;

		// <int32_t State, offset 0xc>
		int32_t State = 0;

		// <int32_t DmgWait, offset 0x10>
		int32_t DmgWait = 0;

		// <int32_t DmgPlayAccept, offset 0x14>
		int32_t DmgPlayAccept = 0;

		// <int32_t PreAvoid, offset 0x18>
		int32_t PreAvoid = 0;

		// <int32_t Piyori, offset 0x1c>
		int32_t Piyori = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct bsBasic::TickCnt [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(bsBasic::TickCnt& InObject)
		{
			Motion = InObject.Motion;
			AtkWait = InObject.AtkWait;
			Loop = InObject.Loop;
			State = InObject.State;
			DmgWait = InObject.DmgWait;
			DmgPlayAccept = InObject.DmgPlayAccept;
			PreAvoid = InObject.PreAvoid;
			Piyori = InObject.Piyori;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TickCnt>("bsBasic_TickCnt")
				.addFunction("__tostring", &bsBasic::TickCnt::ToString)
				.addFunction("GetPtrAddr", &bsBasic::TickCnt::GetPtrAddr)
				.addProperty("Motion", &bsBasic::TickCnt::Motion)
				.addProperty("AtkWait", &bsBasic::TickCnt::AtkWait)
				.addProperty("Loop", &bsBasic::TickCnt::Loop)
				.addProperty("State", &bsBasic::TickCnt::State)
				.addProperty("DmgWait", &bsBasic::TickCnt::DmgWait)
				.addProperty("DmgPlayAccept", &bsBasic::TickCnt::DmgPlayAccept)
				.addProperty("PreAvoid", &bsBasic::TickCnt::PreAvoid)
				.addProperty("Piyori", &bsBasic::TickCnt::Piyori)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::TickCnt::Motion) == 4, "expected bsBasic::TickCnt::Motion to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::AtkWait) == 4, "expected bsBasic::TickCnt::AtkWait to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::Loop) == 4, "expected bsBasic::TickCnt::Loop to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::State) == 4, "expected bsBasic::TickCnt::State to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::DmgWait) == 4, "expected bsBasic::TickCnt::DmgWait to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::DmgPlayAccept) == 4, "expected bsBasic::TickCnt::DmgPlayAccept to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::PreAvoid) == 4, "expected bsBasic::TickCnt::PreAvoid to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::Piyori) == 4, "expected bsBasic::TickCnt::Piyori to be size 4");
	static_assert(sizeof(bsBasic::TickCnt) == 0x20, "expected bsBasic::TickCnt to be size 0x20");

	// [Structure] struct bsBasic::BattleParam
	struct BattleParam
	{
	public:
		/// Struct member variables

		// <struct Vec TargetPos, offset 0x0>
		struct Vec TargetPos;

		// <uint32_t AtkPercent, offset 0xc>
		uint32_t AtkPercent = 0;

		// <uint32_t GrdPercent, offset 0x10>
		uint32_t GrdPercent = 0;

		// <int32_t TsubaTick, offset 0x14>
		int32_t TsubaTick = 0;

		// <uint8_t TsubaRotNum, offset 0x18>
		uint8_t TsubaRotNum = 0;

		// <Unidentified data segment, offset 0x19>
	private:
		char _UnidentifiedData_25[3];

	public:
		// <int32_t HpPhase, offset 0x1c>
		int32_t HpPhase = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct bsBasic::BattleParam [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(bsBasic::BattleParam& InObject)
		{
			TargetPos = InObject.TargetPos;
			AtkPercent = InObject.AtkPercent;
			GrdPercent = InObject.GrdPercent;
			TsubaTick = InObject.TsubaTick;
			TsubaRotNum = InObject.TsubaRotNum;
			HpPhase = InObject.HpPhase;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<BattleParam>("bsBasic_BattleParam")
				.addFunction("__tostring", &bsBasic::BattleParam::ToString)
				.addFunction("GetPtrAddr", &bsBasic::BattleParam::GetPtrAddr)
				.addProperty("TargetPos", &bsBasic::BattleParam::TargetPos)
				.addProperty("AtkPercent", &bsBasic::BattleParam::AtkPercent)
				.addProperty("GrdPercent", &bsBasic::BattleParam::GrdPercent)
				.addProperty("TsubaTick", &bsBasic::BattleParam::TsubaTick)
				.addProperty("TsubaRotNum", &bsBasic::BattleParam::TsubaRotNum)
				.addProperty("HpPhase", &bsBasic::BattleParam::HpPhase)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::BattleParam::TargetPos) == 12, "expected bsBasic::BattleParam::TargetPos to be size 12");
	static_assert(sizeof(bsBasic::BattleParam::AtkPercent) == 4, "expected bsBasic::BattleParam::AtkPercent to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::GrdPercent) == 4, "expected bsBasic::BattleParam::GrdPercent to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::TsubaTick) == 4, "expected bsBasic::BattleParam::TsubaTick to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::TsubaRotNum) == 1, "expected bsBasic::BattleParam::TsubaRotNum to be size 1");
	static_assert(sizeof(bsBasic::BattleParam::HpPhase) == 4, "expected bsBasic::BattleParam::HpPhase to be size 4");
	static_assert(sizeof(bsBasic::BattleParam) == 0x20, "expected bsBasic::BattleParam to be size 0x20");

	// [Structure] struct bsBasic::DmgInfo
	struct DmgInfo
	{
	public:
		/// Struct member variables

		// <uint32_t Kind, offset 0x0>
		uint32_t Kind = 0;

		// <uint32_t DirecKind, offset 0x4>
		uint32_t DirecKind = 0;

		// <float Direc, offset 0x8>
		float Direc = 0;

		// <uint32_t FinishHitNum, offset 0xc>
		uint32_t FinishHitNum = 0;

		// <uint32_t DownFinishHitMax, offset 0x10>
		uint32_t DownFinishHitMax = 0;

		// <float AccumuAmount, offset 0x14>
		float AccumuAmount = 0;

		// <float AccumuMax, offset 0x18>
		float AccumuMax = 0;

		// <float AccumuRecovery, offset 0x1c>
		float AccumuRecovery = 0;

		// <float GroggyAmount, offset 0x20>
		float GroggyAmount = 0;

		// <float GroggyMax, offset 0x24>
		float GroggyMax = 0;

		// <float GroggyRecovery, offset 0x28>
		float GroggyRecovery = 0;

		// <int32_t PiyoriTick, offset 0x2c>
		int32_t PiyoriTick = 0;

		// <float DamagePower, offset 0x30>
		float DamagePower = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct bsBasic::DmgInfo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(bsBasic::DmgInfo& InObject)
		{
			Kind = InObject.Kind;
			DirecKind = InObject.DirecKind;
			Direc = InObject.Direc;
			FinishHitNum = InObject.FinishHitNum;
			DownFinishHitMax = InObject.DownFinishHitMax;
			AccumuAmount = InObject.AccumuAmount;
			AccumuMax = InObject.AccumuMax;
			AccumuRecovery = InObject.AccumuRecovery;
			GroggyAmount = InObject.GroggyAmount;
			GroggyMax = InObject.GroggyMax;
			GroggyRecovery = InObject.GroggyRecovery;
			PiyoriTick = InObject.PiyoriTick;
			DamagePower = InObject.DamagePower;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<DmgInfo>("bsBasic_DmgInfo")
				.addFunction("__tostring", &bsBasic::DmgInfo::ToString)
				.addFunction("GetPtrAddr", &bsBasic::DmgInfo::GetPtrAddr)
				.addProperty("Kind", &bsBasic::DmgInfo::Kind)
				.addProperty("DirecKind", &bsBasic::DmgInfo::DirecKind)
				.addProperty("Direc", &bsBasic::DmgInfo::Direc)
				.addProperty("FinishHitNum", &bsBasic::DmgInfo::FinishHitNum)
				.addProperty("DownFinishHitMax", &bsBasic::DmgInfo::DownFinishHitMax)
				.addProperty("AccumuAmount", &bsBasic::DmgInfo::AccumuAmount)
				.addProperty("AccumuMax", &bsBasic::DmgInfo::AccumuMax)
				.addProperty("AccumuRecovery", &bsBasic::DmgInfo::AccumuRecovery)
				.addProperty("GroggyAmount", &bsBasic::DmgInfo::GroggyAmount)
				.addProperty("GroggyMax", &bsBasic::DmgInfo::GroggyMax)
				.addProperty("GroggyRecovery", &bsBasic::DmgInfo::GroggyRecovery)
				.addProperty("PiyoriTick", &bsBasic::DmgInfo::PiyoriTick)
				.addProperty("DamagePower", &bsBasic::DmgInfo::DamagePower)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::DmgInfo::Kind) == 4, "expected bsBasic::DmgInfo::Kind to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DirecKind) == 4, "expected bsBasic::DmgInfo::DirecKind to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::Direc) == 4, "expected bsBasic::DmgInfo::Direc to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::FinishHitNum) == 4, "expected bsBasic::DmgInfo::FinishHitNum to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DownFinishHitMax) == 4, "expected bsBasic::DmgInfo::DownFinishHitMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuAmount) == 4, "expected bsBasic::DmgInfo::AccumuAmount to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuMax) == 4, "expected bsBasic::DmgInfo::AccumuMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuRecovery) == 4, "expected bsBasic::DmgInfo::AccumuRecovery to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyAmount) == 4, "expected bsBasic::DmgInfo::GroggyAmount to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyMax) == 4, "expected bsBasic::DmgInfo::GroggyMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyRecovery) == 4, "expected bsBasic::DmgInfo::GroggyRecovery to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::PiyoriTick) == 4, "expected bsBasic::DmgInfo::PiyoriTick to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DamagePower) == 4, "expected bsBasic::DmgInfo::DamagePower to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo) == 0x34, "expected bsBasic::DmgInfo to be size 0x34");

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <float mRotSpeed, offset 0x580>
	float mRotSpeed = 0;

	// <struct bsBasic::PcInfo mPcInfo, offset 0x584>
	struct bsBasic::PcInfo mPcInfo;

	// <struct bsBasic::SurroundInfo mSurroundInfo, offset 0x5bc>
	struct bsBasic::SurroundInfo mSurroundInfo;

	// <struct bsBasic::DistSense mDistSense, offset 0x684>
	struct bsBasic::DistSense mDistSense;

	// <struct bsBasic::TickCnt mTickCnt, offset 0x698>
	struct bsBasic::TickCnt mTickCnt;

	// <struct bsBasic::BattleParam mBattleParam, offset 0x6b8>
	struct bsBasic::BattleParam mBattleParam;

	// <struct bsBasic::DmgInfo mDmgInfo, offset 0x6d8>
	struct bsBasic::DmgInfo mDmgInfo;

	// <class KrStateMachine<bsBasic,32> mStateMachine, offset 0x70c>
	class KrStateMachine<bsBasic,32> mStateMachine;

	// <class PathPlanner mPathPlan, offset 0x79c>
	class PathPlanner mPathPlan;

	// <int32_t mVoiceID, offset 0xc60>
	int32_t mVoiceID = 0;

	// <uint8_t mbDownVoice, offset 0xc64>
	uint8_t mbDownVoice = 0;

	// <Unidentified data segment, offset 0xc65>
private:
	char _UnidentifiedData_3173[3];

public:
	// <int32_t mMiniDemoNum, offset 0xc68>
	int32_t mMiniDemoNum = 0;

	// <class TGmf* mpLowModelGmf, offset 0xc6c>
	class TGmf* mpLowModelGmf = nullptr;

	// <class EffectModelBeam* m_pEffectModelBeam, offset 0xc70>
	class EffectModelBeam* m_pEffectModelBeam = nullptr;

	// <class FkObstacleSensor* m_pObsSens, offset 0xc74>
	class FkObstacleSensor* m_pObsSens = nullptr;

	// <uint8_t m_boUseObsSens, offset 0xc78>
	uint8_t m_boUseObsSens = 0;

	// <uint8_t m_boCalledNoGuardEfOnce, offset 0xc79>
	uint8_t m_boCalledNoGuardEfOnce = 0;

	// <Unidentified data segment, offset 0xc7a>
private:
	char _UnidentifiedData_3194[2];

public:
	// <float m_fCheckSrroundHeight, offset 0xc7c>
	float m_fCheckSrroundHeight = 0;

	// <uint32_t mFlag, offset 0xc80>
	uint32_t mFlag = 0;

	/// 3 Functions

	// [Function] void __convention("thiscall") bsBasic::SetDamageIK(class bsBasic* const this, class mHRChara* arg2, uint8_t arg3) [?SetDamageIK@bsBasic@@IAEXPAVmHRChara@@_N@Z]
	typedef void(__thiscall* _SetDamageIK_bsBasic__IAEXPAVmHRChara___N_Z)(class bsBasic* const thisPtr, class mHRChara* arg2, uint8_t arg3);
	void SetDamageIK(class mHRChara* arg2, uint8_t arg3)
	{
		_SetDamageIK_bsBasic__IAEXPAVmHRChara___N_Z mFunc = (_SetDamageIK_bsBasic__IAEXPAVmHRChara___N_Z)(GameModule + 0x573a80);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") bsBasic::mSetDamage(class bsBasic* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsBasic@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_bsBasic__UAE_NMHHHMHMMPAVmHRChara___Z)(class bsBasic* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_bsBasic__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_bsBasic__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x575360);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") bsBasic::IsAtkObj(class bsBasic* const this, class mHRChara* arg2) [?IsAtkObj@bsBasic@@MAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _IsAtkObj_bsBasic__MAE_NPAVmHRChara___Z)(class bsBasic* const thisPtr, class mHRChara* arg2);
	uint8_t IsAtkObj(class mHRChara* arg2)
	{
		_IsAtkObj_bsBasic__MAE_NPAVmHRChara___Z mFunc = (_IsAtkObj_bsBasic__MAE_NPAVmHRChara___Z)(GameModule + 0x5786a0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class bsBasic [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(bsBasic& InObject)
	{
		mRotSpeed = InObject.mRotSpeed;
		mPcInfo = InObject.mPcInfo;
		mSurroundInfo = InObject.mSurroundInfo;
		mDistSense = InObject.mDistSense;
		mTickCnt = InObject.mTickCnt;
		mBattleParam = InObject.mBattleParam;
		mDmgInfo = InObject.mDmgInfo;
		mStateMachine = InObject.mStateMachine;
		mPathPlan = InObject.mPathPlan;
		mVoiceID = InObject.mVoiceID;
		mbDownVoice = InObject.mbDownVoice;
		mMiniDemoNum = InObject.mMiniDemoNum;
		mpLowModelGmf = InObject.mpLowModelGmf;
		m_pEffectModelBeam = InObject.m_pEffectModelBeam;
		m_pObsSens = InObject.m_pObsSens;
		m_boUseObsSens = InObject.m_boUseObsSens;
		m_boCalledNoGuardEfOnce = InObject.m_boCalledNoGuardEfOnce;
		m_fCheckSrroundHeight = InObject.m_fCheckSrroundHeight;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<bsBasic, mHRChara>("bsBasic")
			.addFunction("__tostring", &bsBasic::ToString)
			.addFunction("GetPtrAddr", &bsBasic::GetPtrAddr)
			.addProperty("mRotSpeed", &bsBasic::mRotSpeed)
			.addProperty("mPcInfo", &bsBasic::mPcInfo)
			.addProperty("mSurroundInfo", &bsBasic::mSurroundInfo)
			.addProperty("mDistSense", &bsBasic::mDistSense)
			.addProperty("mTickCnt", &bsBasic::mTickCnt)
			.addProperty("mBattleParam", &bsBasic::mBattleParam)
			.addProperty("mDmgInfo", &bsBasic::mDmgInfo)
			.addProperty("mStateMachine", &bsBasic::mStateMachine)
			.addProperty("mPathPlan", &bsBasic::mPathPlan)
			.addProperty("mVoiceID", &bsBasic::mVoiceID)
			.addProperty("mbDownVoice", &bsBasic::mbDownVoice)
			.addProperty("mMiniDemoNum", &bsBasic::mMiniDemoNum)
			.addProperty("mpLowModelGmf", &bsBasic::mpLowModelGmf)
			.addProperty("m_pEffectModelBeam", &bsBasic::m_pEffectModelBeam)
			.addProperty("m_pObsSens", &bsBasic::m_pObsSens)
			.addProperty("m_boUseObsSens", &bsBasic::m_boUseObsSens)
			.addProperty("m_boCalledNoGuardEfOnce", &bsBasic::m_boCalledNoGuardEfOnce)
			.addProperty("m_fCheckSrroundHeight", &bsBasic::m_fCheckSrroundHeight)
			.addProperty("mFlag", &bsBasic::mFlag)
			.addFunction("SetDamageIK", &bsBasic::SetDamageIK)
			.addFunction("mSetDamage", &bsBasic::mSetDamage)
			.addFunction("IsAtkObj", &bsBasic::IsAtkObj)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsBasic::mRotSpeed) == 4, "expected bsBasic::mRotSpeed to be size 4");
static_assert(sizeof(bsBasic::mPcInfo) == 56, "expected bsBasic::mPcInfo to be size 56");
static_assert(sizeof(bsBasic::mSurroundInfo) == 200, "expected bsBasic::mSurroundInfo to be size 200");
static_assert(sizeof(bsBasic::mDistSense) == 20, "expected bsBasic::mDistSense to be size 20");
static_assert(sizeof(bsBasic::mTickCnt) == 32, "expected bsBasic::mTickCnt to be size 32");
static_assert(sizeof(bsBasic::mBattleParam) == 32, "expected bsBasic::mBattleParam to be size 32");
static_assert(sizeof(bsBasic::mDmgInfo) == 52, "expected bsBasic::mDmgInfo to be size 52");
static_assert(sizeof(bsBasic::mStateMachine) == 144, "expected bsBasic::mStateMachine to be size 144");
static_assert(sizeof(bsBasic::mPathPlan) == 1220, "expected bsBasic::mPathPlan to be size 1220");
static_assert(sizeof(bsBasic::mVoiceID) == 4, "expected bsBasic::mVoiceID to be size 4");
static_assert(sizeof(bsBasic::mbDownVoice) == 1, "expected bsBasic::mbDownVoice to be size 1");
static_assert(sizeof(bsBasic::mMiniDemoNum) == 4, "expected bsBasic::mMiniDemoNum to be size 4");
static_assert(sizeof(bsBasic::mpLowModelGmf) == 4, "expected bsBasic::mpLowModelGmf to be size 4");
static_assert(sizeof(bsBasic::m_pEffectModelBeam) == 4, "expected bsBasic::m_pEffectModelBeam to be size 4");
static_assert(sizeof(bsBasic::m_pObsSens) == 4, "expected bsBasic::m_pObsSens to be size 4");
static_assert(sizeof(bsBasic::m_boUseObsSens) == 1, "expected bsBasic::m_boUseObsSens to be size 1");
static_assert(sizeof(bsBasic::m_boCalledNoGuardEfOnce) == 1, "expected bsBasic::m_boCalledNoGuardEfOnce to be size 1");
static_assert(sizeof(bsBasic::m_fCheckSrroundHeight) == 4, "expected bsBasic::m_fCheckSrroundHeight to be size 4");
static_assert(sizeof(bsBasic::mFlag) == 4, "expected bsBasic::mFlag to be size 4");
static_assert(sizeof(bsBasic) == 0xc84, "expected bsBasic to be size 0xc84");

// [Structure] class SDPMoveState
class SDPMoveState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class SDPMoveState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SDPMoveState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPMoveState>("SDPMoveState")
			.addFunction("__tostring", &SDPMoveState::ToString)
			.addFunction("GetPtrAddr", &SDPMoveState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPMoveState) == 0x4, "expected SDPMoveState to be size 0x4");

// [Structure] class SDPGuardState
class SDPGuardState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class SDPGuardState [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SDPGuardState& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPGuardState>("SDPGuardState")
			.addFunction("__tostring", &SDPGuardState::ToString)
			.addFunction("GetPtrAddr", &SDPGuardState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPGuardState) == 0x4, "expected SDPGuardState to be size 0x4");

// [Structure] class bsSDP
class bsSDP : public bsBasic
{
public:
	/// Struct member variables

	// <class bsBasic field_0, offset 0x0>
	// class bsBasic Super;

	// <class EfRoboInterface* mpIntarface, offset 0xc84>
	class EfRoboInterface* mpIntarface = nullptr;

	// <class pcGLB* mpGLB, offset 0xc88>
	class pcGLB* mpGLB = nullptr;

	// <class EfGeneralBeam* mpGeneralBeam, offset 0xc8c>
	class EfGeneralBeam* mpGeneralBeam = nullptr;

	// <class TGmfNode* mpBeamLaunchNode, offset 0xc90>
	class TGmfNode* mpBeamLaunchNode = nullptr;

	// <class TGmfNode* mpWristRNode, offset 0xc94>
	class TGmfNode* mpWristRNode = nullptr;

	// <float mTension, offset 0xc98>
	float mTension = 0;

	// <class SDPIdleState mIdleState, offset 0xc9c>
	class SDPIdleState mIdleState;

	// <class SDPComboState mComboState, offset 0xca4>
	class SDPComboState mComboState;

	// <class SDPBeamState mBeamState, offset 0xca8>
	class SDPBeamState mBeamState;

	// <class SDPGuardState mGuardState, offset 0xcac>
	class SDPGuardState mGuardState;

	// <class SDPDamageState mDamageState, offset 0xcb0>
	class SDPDamageState mDamageState;

	// <class SDPMoveState mMoveState, offset 0xcb8>
	class SDPMoveState mMoveState;

	// <class SDPDeathState mDeathState, offset 0xcbc>
	class SDPDeathState mDeathState;

	// <struct Vec mBefPos, offset 0xcc4>
	struct Vec mBefPos;

	// <uint8_t mbDemoWait, offset 0xcd0>
	uint8_t mbDemoWait = 0;

	// <uint8_t mbDeadScriptCall, offset 0xcd1>
	uint8_t mbDeadScriptCall = 0;

	// <uint8_t mbFirstSE, offset 0xcd2>
	uint8_t mbFirstSE = 0;

	// <uint8_t mbGLBSE, offset 0xcd3>
	uint8_t mbGLBSE = 0;

	/// 3 Functions

	// [Function] class pcGLB* __convention("thiscall") bsSDP::GetGLB(class bsSDP* const this) [?GetGLB@bsSDP@@QAEPAVpcGLB@@XZ]
	typedef class pcGLB*(__thiscall* _GetGLB_bsSDP__QAEPAVpcGLB__XZ)(class bsSDP* const thisPtr);
	class pcGLB* GetGLB()
	{
		_GetGLB_bsSDP__QAEPAVpcGLB__XZ mFunc = (_GetGLB_bsSDP__QAEPAVpcGLB__XZ)(GameModule + 0xc9380);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") bsSDP::IsAtkObj(class bsSDP* const this, class mHRChara* arg2) [?IsAtkObj@bsSDP@@EAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _IsAtkObj_bsSDP__EAE_NPAVmHRChara___Z)(class bsSDP* const thisPtr, class mHRChara* arg2);
	uint8_t IsAtkObj(class mHRChara* arg2)
	{
		_IsAtkObj_bsSDP__EAE_NPAVmHRChara___Z mFunc = (_IsAtkObj_bsSDP__EAE_NPAVmHRChara___Z)(GameModule + 0x54e160);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") bsSDP::mSetDamage(class bsSDP* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsSDP@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_bsSDP__UAE_NMHHHMHMMPAVmHRChara___Z)(class bsSDP* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_bsSDP__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_bsSDP__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x54ebc0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class bsSDP [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(bsSDP& InObject)
	{
		mpIntarface = InObject.mpIntarface;
		mpGLB = InObject.mpGLB;
		mpGeneralBeam = InObject.mpGeneralBeam;
		mpBeamLaunchNode = InObject.mpBeamLaunchNode;
		mpWristRNode = InObject.mpWristRNode;
		mTension = InObject.mTension;
		mIdleState = InObject.mIdleState;
		mComboState = InObject.mComboState;
		mBeamState = InObject.mBeamState;
		mGuardState = InObject.mGuardState;
		mDamageState = InObject.mDamageState;
		mMoveState = InObject.mMoveState;
		mDeathState = InObject.mDeathState;
		mBefPos = InObject.mBefPos;
		mbDemoWait = InObject.mbDemoWait;
		mbDeadScriptCall = InObject.mbDeadScriptCall;
		mbFirstSE = InObject.mbFirstSE;
		mbGLBSE = InObject.mbGLBSE;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<bsSDP, bsBasic>("bsSDP")
			.addFunction("__tostring", &bsSDP::ToString)
			.addFunction("GetPtrAddr", &bsSDP::GetPtrAddr)
			.addProperty("mpIntarface", &bsSDP::mpIntarface)
			.addProperty("mpGLB", &bsSDP::mpGLB)
			.addProperty("mpGeneralBeam", &bsSDP::mpGeneralBeam)
			.addProperty("mpBeamLaunchNode", &bsSDP::mpBeamLaunchNode)
			.addProperty("mpWristRNode", &bsSDP::mpWristRNode)
			.addProperty("mTension", &bsSDP::mTension)
			.addProperty("mIdleState", &bsSDP::mIdleState)
			.addProperty("mComboState", &bsSDP::mComboState)
			.addProperty("mBeamState", &bsSDP::mBeamState)
			.addProperty("mGuardState", &bsSDP::mGuardState)
			.addProperty("mDamageState", &bsSDP::mDamageState)
			.addProperty("mMoveState", &bsSDP::mMoveState)
			.addProperty("mDeathState", &bsSDP::mDeathState)
			.addProperty("mBefPos", &bsSDP::mBefPos)
			.addProperty("mbDemoWait", &bsSDP::mbDemoWait)
			.addProperty("mbDeadScriptCall", &bsSDP::mbDeadScriptCall)
			.addProperty("mbFirstSE", &bsSDP::mbFirstSE)
			.addProperty("mbGLBSE", &bsSDP::mbGLBSE)
			.addFunction("GetGLB", &bsSDP::GetGLB)
			.addFunction("IsAtkObj", &bsSDP::IsAtkObj)
			.addFunction("mSetDamage", &bsSDP::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsSDP::mpIntarface) == 4, "expected bsSDP::mpIntarface to be size 4");
static_assert(sizeof(bsSDP::mpGLB) == 4, "expected bsSDP::mpGLB to be size 4");
static_assert(sizeof(bsSDP::mpGeneralBeam) == 4, "expected bsSDP::mpGeneralBeam to be size 4");
static_assert(sizeof(bsSDP::mpBeamLaunchNode) == 4, "expected bsSDP::mpBeamLaunchNode to be size 4");
static_assert(sizeof(bsSDP::mpWristRNode) == 4, "expected bsSDP::mpWristRNode to be size 4");
static_assert(sizeof(bsSDP::mTension) == 4, "expected bsSDP::mTension to be size 4");
static_assert(sizeof(bsSDP::mIdleState) == 8, "expected bsSDP::mIdleState to be size 8");
static_assert(sizeof(bsSDP::mComboState) == 4, "expected bsSDP::mComboState to be size 4");
static_assert(sizeof(bsSDP::mBeamState) == 4, "expected bsSDP::mBeamState to be size 4");
static_assert(sizeof(bsSDP::mGuardState) == 4, "expected bsSDP::mGuardState to be size 4");
static_assert(sizeof(bsSDP::mDamageState) == 8, "expected bsSDP::mDamageState to be size 8");
static_assert(sizeof(bsSDP::mMoveState) == 4, "expected bsSDP::mMoveState to be size 4");
static_assert(sizeof(bsSDP::mDeathState) == 8, "expected bsSDP::mDeathState to be size 8");
static_assert(sizeof(bsSDP::mBefPos) == 12, "expected bsSDP::mBefPos to be size 12");
static_assert(sizeof(bsSDP::mbDemoWait) == 1, "expected bsSDP::mbDemoWait to be size 1");
static_assert(sizeof(bsSDP::mbDeadScriptCall) == 1, "expected bsSDP::mbDeadScriptCall to be size 1");
static_assert(sizeof(bsSDP::mbFirstSE) == 1, "expected bsSDP::mbFirstSE to be size 1");
static_assert(sizeof(bsSDP::mbGLBSE) == 1, "expected bsSDP::mbGLBSE to be size 1");
static_assert(sizeof(bsSDP) == 0xcd4, "expected bsSDP to be size 0xcd4");

// [Structure] class FkTriangleList
class FkTriangleList
{
public:
	/// Struct member variables

	// <class FkStlVector<FkVtx> m_VtxArr, offset 0x0>
	class FkStlVector<FkVtx> m_VtxArr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class FkTriangleList [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkTriangleList& InObject)
	{
		m_VtxArr = InObject.m_VtxArr;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkTriangleList>("FkTriangleList")
			.addFunction("__tostring", &FkTriangleList::ToString)
			.addFunction("GetPtrAddr", &FkTriangleList::GetPtrAddr)
			.addProperty("m_VtxArr", &FkTriangleList::m_VtxArr)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkTriangleList::m_VtxArr) == 20, "expected FkTriangleList::m_VtxArr to be size 20");
static_assert(sizeof(FkTriangleList) == 0x14, "expected FkTriangleList to be size 0x14");

// [Structure] class EffectModelBeam
class EffectModelBeam : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class FkTriangleList m_TriangleList, offset 0x50>
	class FkTriangleList m_TriangleList;

	// <class TGmf* m_pGmf, offset 0x64>
	class TGmf* m_pGmf = nullptr;

	// <class TGmfNode* m_pBeamNode, offset 0x68>
	class TGmfNode* m_pBeamNode = nullptr;

	// <uint32_t m_Color, offset 0x6c>
	uint32_t m_Color = 0;

	// <uint8_t m_boVisible, offset 0x70>
	uint8_t m_boVisible = 0;

	// <Unidentified data segment, offset 0x71>
private:
	char _UnidentifiedData_113[3];

public:
	// <float m_fScale, offset 0x74>
	float m_fScale = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectModelBeam [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectModelBeam& InObject)
	{
		m_TriangleList = InObject.m_TriangleList;
		m_pGmf = InObject.m_pGmf;
		m_pBeamNode = InObject.m_pBeamNode;
		m_Color = InObject.m_Color;
		m_boVisible = InObject.m_boVisible;
		m_fScale = InObject.m_fScale;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectModelBeam, HrTask>("EffectModelBeam")
			.addFunction("__tostring", &EffectModelBeam::ToString)
			.addFunction("GetPtrAddr", &EffectModelBeam::GetPtrAddr)
			.addProperty("m_TriangleList", &EffectModelBeam::m_TriangleList)
			.addProperty("m_pGmf", &EffectModelBeam::m_pGmf)
			.addProperty("m_pBeamNode", &EffectModelBeam::m_pBeamNode)
			.addProperty("m_Color", &EffectModelBeam::m_Color)
			.addProperty("m_boVisible", &EffectModelBeam::m_boVisible)
			.addProperty("m_fScale", &EffectModelBeam::m_fScale)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectModelBeam::m_TriangleList) == 20, "expected EffectModelBeam::m_TriangleList to be size 20");
static_assert(sizeof(EffectModelBeam::m_pGmf) == 4, "expected EffectModelBeam::m_pGmf to be size 4");
static_assert(sizeof(EffectModelBeam::m_pBeamNode) == 4, "expected EffectModelBeam::m_pBeamNode to be size 4");
static_assert(sizeof(EffectModelBeam::m_Color) == 4, "expected EffectModelBeam::m_Color to be size 4");
static_assert(sizeof(EffectModelBeam::m_boVisible) == 1, "expected EffectModelBeam::m_boVisible to be size 1");
static_assert(sizeof(EffectModelBeam::m_fScale) == 4, "expected EffectModelBeam::m_fScale to be size 4");
static_assert(sizeof(EffectModelBeam) == 0x78, "expected EffectModelBeam to be size 0x78");

// [Structure] struct FkVtx
struct FkVtx
{
public:
	/// Struct member variables

	// <struct Vec Pos, offset 0x0>
	struct Vec Pos;

	// <struct Vec Norm, offset 0xc>
	struct Vec Norm;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct FkVtx [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkVtx& InObject)
	{
		Pos = InObject.Pos;
		Norm = InObject.Norm;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkVtx>("FkVtx")
			.addFunction("__tostring", &FkVtx::ToString)
			.addFunction("GetPtrAddr", &FkVtx::GetPtrAddr)
			.addProperty("Pos", &FkVtx::Pos)
			.addProperty("Norm", &FkVtx::Norm)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkVtx::Pos) == 12, "expected FkVtx::Pos to be size 12");
static_assert(sizeof(FkVtx::Norm) == 12, "expected FkVtx::Norm to be size 12");
static_assert(sizeof(FkVtx) == 0x18, "expected FkVtx to be size 0x18");

// [Structure] class EfGeneralBeam
class EfGeneralBeam
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[54968];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfGeneralBeam [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfGeneralBeam& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfGeneralBeam>("EfGeneralBeam")
			.addFunction("__tostring", &EfGeneralBeam::ToString)
			.addFunction("GetPtrAddr", &EfGeneralBeam::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfGeneralBeam) == 0xd6b8, "expected EfGeneralBeam to be size 0xd6b8");

// Unsupported operator
//void* __convention("thiscall") pcGLB::`vector deleting destructor'(class pcGLB* const this, uint32_t arg2)
// [Function] void __convention("thiscall") KrStateMachine<class pcGLB,32>::AllClear(class KrStateMachine<pcGLB,32>* const this) [?AllClear@?$KrStateMachine@VpcGLB@@$0CA@@@QAEXXZ]
typedef void(__thiscall* _AllClear_KrStateMachine_VpcGLB__0CA___QAEXXZ)(class KrStateMachine<pcGLB,32>* const thisPtr);
static void AllClear(class KrStateMachine<pcGLB,32>* const thisPtr)
{
	_AllClear_KrStateMachine_VpcGLB__0CA___QAEXXZ mFunc = (_AllClear_KrStateMachine_VpcGLB__0CA___QAEXXZ)(GameModule + 0xc9070);
	return mFunc(thisPtr);
}
// [Function] void __convention("thiscall") KrStateMachine<class pcGLB,32>::AllExit(class KrStateMachine<pcGLB,32>* const this) [?AllExit@?$KrStateMachine@VpcGLB@@$0CA@@@QAEXXZ]
typedef void(__thiscall* _AllExit_KrStateMachine_VpcGLB__0CA___QAEXXZ)(class KrStateMachine<pcGLB,32>* const thisPtr);
static void AllExit(class KrStateMachine<pcGLB,32>* const thisPtr)
{
	_AllExit_KrStateMachine_VpcGLB__0CA___QAEXXZ mFunc = (_AllExit_KrStateMachine_VpcGLB__0CA___QAEXXZ)(GameModule + 0xc90a0);
	return mFunc(thisPtr);
}
// [Function] void __convention("thiscall") KrStateMachine<class pcGLB,32>::ChangeState(class KrStateMachine<pcGLB,32>* const this, int32_t arg2) [?ChangeState@?$KrStateMachine@VpcGLB@@$0CA@@@QAEXH@Z]
typedef void(__thiscall* _ChangeState_KrStateMachine_VpcGLB__0CA___QAEXH_Z)(class KrStateMachine<pcGLB,32>* const thisPtr, int32_t arg2);
static void ChangeState(class KrStateMachine<pcGLB,32>* const thisPtr, int32_t arg2)
{
	_ChangeState_KrStateMachine_VpcGLB__0CA___QAEXH_Z mFunc = (_ChangeState_KrStateMachine_VpcGLB__0CA___QAEXH_Z)(GameModule + 0xc90d0);
	return mFunc(thisPtr, arg2);
}
// [Function] void __convention("thiscall") KrStateMachine<class pcGLB,32>::Update(class KrStateMachine<pcGLB,32>* const this) [?Update@?$KrStateMachine@VpcGLB@@$0CA@@@QAEXXZ]
typedef void(__thiscall* _Update_KrStateMachine_VpcGLB__0CA___QAEXXZ)(class KrStateMachine<pcGLB,32>* const thisPtr);
static void Update(class KrStateMachine<pcGLB,32>* const thisPtr)
{
	_Update_KrStateMachine_VpcGLB__0CA___QAEXXZ mFunc = (_Update_KrStateMachine_VpcGLB__0CA___QAEXXZ)(GameModule + 0xc9110);
	return mFunc(thisPtr);
}
// [Function] void __convention("thiscall") KrStateMachine<class pcGLB,32>::SetState(class KrStateMachine<pcGLB,32>* const this, int32_t arg2, class KrBaseState<pcGLB>* arg3) [?SetState@?$KrStateMachine@VpcGLB@@$0CA@@@QAEXHPAV?$KrBaseState@VpcGLB@@@@@Z]
typedef void(__thiscall* _SetState_KrStateMachine_VpcGLB__0CA___QAEXHPAVKrBaseState_VpcGLB_____Z)(class KrStateMachine<pcGLB,32>* const thisPtr, int32_t arg2, class KrBaseState<pcGLB>* arg3);
static void SetState(class KrStateMachine<pcGLB,32>* const thisPtr, int32_t arg2, class KrBaseState<pcGLB>* arg3)
{
	_SetState_KrStateMachine_VpcGLB__0CA___QAEXHPAVKrBaseState_VpcGLB_____Z mFunc = (_SetState_KrStateMachine_VpcGLB__0CA___QAEXHPAVKrBaseState_VpcGLB_____Z)(GameModule + 0xc9140);
	return mFunc(thisPtr, arg2, arg3);
}
// [Function] int32_t __convention("thiscall") KrStateMachine<class pcGLB,32>::GetPrevStateIdx(class KrStateMachine<pcGLB,32>* const this) [?GetPrevStateIdx@?$KrStateMachine@VpcGLB@@$0CA@@@QAEHXZ]
typedef int32_t(__thiscall* _GetPrevStateIdx_KrStateMachine_VpcGLB__0CA___QAEHXZ)(class KrStateMachine<pcGLB,32>* const thisPtr);
static int32_t GetPrevStateIdx(class KrStateMachine<pcGLB,32>* const thisPtr)
{
	_GetPrevStateIdx_KrStateMachine_VpcGLB__0CA___QAEHXZ mFunc = (_GetPrevStateIdx_KrStateMachine_VpcGLB__0CA___QAEHXZ)(GameModule + 0xc9160);
	return mFunc(thisPtr);
}
// [Function] int32_t __convention("thiscall") KrStateMachine<class pcGLB,32>::GetCurStateIdx(class KrStateMachine<pcGLB,32>* const this) [?GetCurStateIdx@?$KrStateMachine@VpcGLB@@$0CA@@@QAEHXZ]
typedef int32_t(__thiscall* _GetCurStateIdx_KrStateMachine_VpcGLB__0CA___QAEHXZ)(class KrStateMachine<pcGLB,32>* const thisPtr);
static int32_t GetCurStateIdx(class KrStateMachine<pcGLB,32>* const thisPtr)
{
	_GetCurStateIdx_KrStateMachine_VpcGLB__0CA___QAEHXZ mFunc = (_GetCurStateIdx_KrStateMachine_VpcGLB__0CA___QAEHXZ)(GameModule + 0xc9170);
	return mFunc(thisPtr);
}
// Unsupported constructor
//void __convention("thiscall") KrStateMachine<class pcGLB,32>::KrStateMachine<class pcGLB,32>(class KrStateMachine<pcGLB,32>* const this, class pcGLB* arg2)
// [Function] char const* __convention("thiscall") KrBaseState<class pcGLB>::GetName(class KrBaseState<pcGLB>* const this) [?GetName@?$KrBaseState@VpcGLB@@@@UAEPBDXZ]
typedef char const*(__thiscall* _GetName_KrBaseState_VpcGLB____UAEPBDXZ)(class KrBaseState<pcGLB>* const thisPtr);
static std::string GetName(class KrBaseState<pcGLB>* const thisPtr)
{
	_GetName_KrBaseState_VpcGLB____UAEPBDXZ mFunc = (_GetName_KrBaseState_VpcGLB____UAEPBDXZ)(GameModule + 0xc91d0);
	char const* OutResult = mFunc(thisPtr);
	if (OutResult == nullptr) return std::string();
	std::string result_str(OutResult);
	return result_str;
}
// [Function] void __convention("thiscall") KrBaseState<class pcGLB>::Clear(class KrBaseState<pcGLB>* const this) [?Clear@?$KrBaseState@VpcGLB@@@@UAEXXZ]
typedef void(__thiscall* _Clear_KrBaseState_VpcGLB____UAEXXZ)(class KrBaseState<pcGLB>* const thisPtr);
static void Clear(class KrBaseState<pcGLB>* const thisPtr)
{
	_Clear_KrBaseState_VpcGLB____UAEXXZ mFunc = (_Clear_KrBaseState_VpcGLB____UAEXXZ)(GameModule + 0xc91e0);
	return mFunc(thisPtr);
}
// Unsupported destructor
//void __convention("thiscall") KrBaseState<class pcGLB>::~KrBaseState<class pcGLB>(class KrBaseState<pcGLB>* const this)
// Unsupported constructor
//void __convention("thiscall") KrBaseState<class pcGLB>::KrBaseState<class pcGLB>(class KrBaseState<pcGLB>* const this)
// Unsupported operator
//void* __convention("thiscall") KrBaseState<class pcGLB>::`vector deleting destructor'(class KrBaseState<pcGLB>* const this, uint32_t arg2)
// [Structure] class rGlobalData
class rGlobalData
{
public:
	/// Struct member variables

	// <class ghmGcFile m_GcFile, offset 0x0>
	class ghmGcFile m_GcFile;

	// <class ghmResGroup* m_pResLink, offset 0xbc>
	class ghmResGroup* m_pResLink = nullptr;

	// <void* m_pDataBuf, offset 0xc0>
	void* m_pDataBuf = nullptr;

	// <uint8_t m_State, offset 0xc4>
	uint8_t m_State = 0;

	// <Unidentified data segment, offset 0xc5>
private:
	char _UnidentifiedData_197[3];

public:
	/// 1 Functions

	// [Function] class ghmResGroup* __convention("thiscall") rGlobalData::GetResLink(class rGlobalData* const this) [?GetResLink@rGlobalData@@QAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _GetResLink_rGlobalData__QAEPAVghmResGroup__XZ)(class rGlobalData* const thisPtr);
	class ghmResGroup* GetResLink()
	{
		_GetResLink_rGlobalData__QAEPAVghmResGroup__XZ mFunc = (_GetResLink_rGlobalData__QAEPAVghmResGroup__XZ)(GameModule + 0xcca20);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rGlobalData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rGlobalData& InObject)
	{
		m_GcFile = InObject.m_GcFile;
		m_pResLink = InObject.m_pResLink;
		m_pDataBuf = InObject.m_pDataBuf;
		m_State = InObject.m_State;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rGlobalData>("rGlobalData")
			.addFunction("__tostring", &rGlobalData::ToString)
			.addFunction("GetPtrAddr", &rGlobalData::GetPtrAddr)
			.addProperty("m_GcFile", &rGlobalData::m_GcFile)
			.addProperty("m_pResLink", &rGlobalData::m_pResLink)
			// void type not supported in LuaBridge
			//.addProperty("m_pDataBuf", &rGlobalData::m_pDataBuf)
			.addProperty("m_State", &rGlobalData::m_State)
			.addFunction("GetResLink", &rGlobalData::GetResLink)
		.endClass();
	}
#endif
};
static_assert(sizeof(rGlobalData::m_GcFile) == 188, "expected rGlobalData::m_GcFile to be size 188");
static_assert(sizeof(rGlobalData::m_pResLink) == 4, "expected rGlobalData::m_pResLink to be size 4");
static_assert(sizeof(rGlobalData::m_pDataBuf) == 4, "expected rGlobalData::m_pDataBuf to be size 4");
static_assert(sizeof(rGlobalData::m_State) == 1, "expected rGlobalData::m_State to be size 1");
static_assert(sizeof(rGlobalData) == 0xc8, "expected rGlobalData to be size 0xc8");

// [Structure] class JobMissionResult
class JobMissionResult
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[352];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class JobMissionResult [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(JobMissionResult& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<JobMissionResult>("JobMissionResult")
			.addFunction("__tostring", &JobMissionResult::ToString)
			.addFunction("GetPtrAddr", &JobMissionResult::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(JobMissionResult) == 0x160, "expected JobMissionResult to be size 0x160");

// [Structure] class PJJMBase
class PJJMBase
{
public:
	// enum PJJMBase::SysState
	enum SysState : uint32_t
	{
		// <SysState_Init = 0x0>
		SysState_Init = 0,

		// <SysState_Open = 0x1>
		SysState_Open = 1,

		// <SysState_Load = 0x2>
		SysState_Load = 2,

		// <SysState_CmSoundOpen = 0x3>
		SysState_CmSoundOpen = 3,

		// <SysState_CmSoundLoad = 0x4>
		SysState_CmSoundLoad = 4,

		// <SysState_SoundOpen = 0x5>
		SysState_SoundOpen = 5,

		// <SysState_SoundLoad = 0x6>
		SysState_SoundLoad = 6,

		// <SysState_Standby = 0x7>
		SysState_Standby = 7,

		// <SysState_TermReq = 0x8>
		SysState_TermReq = 8,

		// <SysState_Term = 0x9>
		SysState_Term = 9

	};

	// enum PJJMBase::GameState
	enum GameState : uint32_t
	{
		// <GameState_Init = 0x0>
		GameState_Init = 0,

		// <GameState_Title = 0x1>
		GameState_Title = 1,

		// <GameState_StageStart = 0x2>
		GameState_StageStart = 2,

		// <GameState_InGame = 0x3>
		GameState_InGame = 3,

		// <GameState_GameOver = 0x4>
		GameState_GameOver = 4,

		// <GameState_TimeOver = 0x5>
		GameState_TimeOver = 5,

		// <GameState_Clear = 0x6>
		GameState_Clear = 6,

		// <GameState_Result = 0x7>
		GameState_Result = 7

	};

	/// Struct member variables

	// <void* (* field_0)[0x10], offset 0x0>
	void* (* field_0)[0x10];

	// <enum PJJMBase::SysState mSysState, offset 0x4>
	enum PJJMBase::SysState mSysState;

	// <enum PJJMBase::GameState mGameState, offset 0x8>
	enum PJJMBase::GameState mGameState;

	// <class ghmGcFile* mpFile, offset 0xc>
	class ghmGcFile* mpFile = nullptr;

	// <void* mpData, offset 0x10>
	void* mpData = nullptr;

	// <class ghmResGroup* mpResLink, offset 0x14>
	class ghmResGroup* mpResLink = nullptr;

	// <int32_t mMissionNo, offset 0x18>
	int32_t mMissionNo = 0;

	// <int32_t mLevel, offset 0x1c>
	int32_t mLevel = 0;

	// <int32_t mLevelMax, offset 0x20>
	int32_t mLevelMax = 0;

	// <uint8_t mbPause, offset 0x24>
	uint8_t mbPause = 0;

	// <Unidentified data segment, offset 0x25>
private:
	char _UnidentifiedData_37[3];

public:
	// <struct tagGHMR_TEX mFontTex, offset 0x28>
	struct tagGHMR_TEX mFontTex;

	// <class JobMissionResult mResult, offset 0x50>
	class JobMissionResult mResult;

	// <int32_t mCursor, offset 0x1b0>
	int32_t mCursor = 0;

	// <int32_t mTitleTop, offset 0x1b4>
	int32_t mTitleTop = 0;

	// <int32_t mGameStateCnt, offset 0x1b8>
	int32_t mGameStateCnt = 0;

	// <uint32_t mBitFlag, offset 0x1bc>
	uint32_t mBitFlag = 0;

	/// 2 Functions

	// [Function] class ghmResGroup* __convention("thiscall") PJJMBase::GetResLink(class PJJMBase* const this) [?GetResLink@PJJMBase@@QAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _GetResLink_PJJMBase__QAEPAVghmResGroup__XZ)(class PJJMBase* const thisPtr);
	class ghmResGroup* GetResLink()
	{
		_GetResLink_PJJMBase__QAEPAVghmResGroup__XZ mFunc = (_GetResLink_PJJMBase__QAEPAVghmResGroup__XZ)(GameModule + 0xcfd30);
		return mFunc(this);
	}
	// [Function] class ghmResGroup* __convention("thiscall") PJJMBase::GetMissionData(class PJJMBase* const this) [?GetMissionData@PJJMBase@@QAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _GetMissionData_PJJMBase__QAEPAVghmResGroup__XZ)(class PJJMBase* const thisPtr);
	class ghmResGroup* GetMissionData()
	{
		_GetMissionData_PJJMBase__QAEPAVghmResGroup__XZ mFunc = (_GetMissionData_PJJMBase__QAEPAVghmResGroup__XZ)(GameModule + 0x5e02e0);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJJMBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJMBase& InObject)
	{
		mSysState = InObject.mSysState;
		mGameState = InObject.mGameState;
		mpFile = InObject.mpFile;
		mpData = InObject.mpData;
		mpResLink = InObject.mpResLink;
		mMissionNo = InObject.mMissionNo;
		mLevel = InObject.mLevel;
		mLevelMax = InObject.mLevelMax;
		mbPause = InObject.mbPause;
		mFontTex = InObject.mFontTex;
		mResult = InObject.mResult;
		mCursor = InObject.mCursor;
		mTitleTop = InObject.mTitleTop;
		mGameStateCnt = InObject.mGameStateCnt;
		mBitFlag = InObject.mBitFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJJMBase>("PJJMBase")
			.addFunction("__tostring", &PJJMBase::ToString)
			.addFunction("GetPtrAddr", &PJJMBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &PJJMBase::field_0)
			.addProperty("mSysState", &PJJMBase::mSysState)
			.addProperty("mGameState", &PJJMBase::mGameState)
			.addProperty("mpFile", &PJJMBase::mpFile)
			// void type not supported in LuaBridge
			//.addProperty("mpData", &PJJMBase::mpData)
			.addProperty("mpResLink", &PJJMBase::mpResLink)
			.addProperty("mMissionNo", &PJJMBase::mMissionNo)
			.addProperty("mLevel", &PJJMBase::mLevel)
			.addProperty("mLevelMax", &PJJMBase::mLevelMax)
			.addProperty("mbPause", &PJJMBase::mbPause)
			.addProperty("mFontTex", &PJJMBase::mFontTex)
			.addProperty("mResult", &PJJMBase::mResult)
			.addProperty("mCursor", &PJJMBase::mCursor)
			.addProperty("mTitleTop", &PJJMBase::mTitleTop)
			.addProperty("mGameStateCnt", &PJJMBase::mGameStateCnt)
			.addProperty("mBitFlag", &PJJMBase::mBitFlag)
			.addFunction("GetResLink", &PJJMBase::GetResLink)
			.addFunction("GetMissionData", &PJJMBase::GetMissionData)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJMBase::field_0) == 4, "expected PJJMBase::field_0 to be size 4");
static_assert(sizeof(PJJMBase::mSysState) == 4, "expected PJJMBase::mSysState to be size 4");
static_assert(sizeof(PJJMBase::mGameState) == 4, "expected PJJMBase::mGameState to be size 4");
static_assert(sizeof(PJJMBase::mpFile) == 4, "expected PJJMBase::mpFile to be size 4");
static_assert(sizeof(PJJMBase::mpData) == 4, "expected PJJMBase::mpData to be size 4");
static_assert(sizeof(PJJMBase::mpResLink) == 4, "expected PJJMBase::mpResLink to be size 4");
static_assert(sizeof(PJJMBase::mMissionNo) == 4, "expected PJJMBase::mMissionNo to be size 4");
static_assert(sizeof(PJJMBase::mLevel) == 4, "expected PJJMBase::mLevel to be size 4");
static_assert(sizeof(PJJMBase::mLevelMax) == 4, "expected PJJMBase::mLevelMax to be size 4");
static_assert(sizeof(PJJMBase::mbPause) == 1, "expected PJJMBase::mbPause to be size 1");
static_assert(sizeof(PJJMBase::mFontTex) == 40, "expected PJJMBase::mFontTex to be size 40");
static_assert(sizeof(PJJMBase::mResult) == 352, "expected PJJMBase::mResult to be size 352");
static_assert(sizeof(PJJMBase::mCursor) == 4, "expected PJJMBase::mCursor to be size 4");
static_assert(sizeof(PJJMBase::mTitleTop) == 4, "expected PJJMBase::mTitleTop to be size 4");
static_assert(sizeof(PJJMBase::mGameStateCnt) == 4, "expected PJJMBase::mGameStateCnt to be size 4");
static_assert(sizeof(PJJMBase::mBitFlag) == 4, "expected PJJMBase::mBitFlag to be size 4");
static_assert(sizeof(PJJMBase) == 0x1c0, "expected PJJMBase to be size 0x1c0");

// [Structure] class CMotionPlayer
class CMotionPlayer
{
public:
	// [Structure] class CMotionPlayer::CElement
	class CElement
	{
	public:
		/// Struct member variables

		// <int32_t m_nMotIndex, offset 0x0>
		int32_t m_nMotIndex = 0;

		// <enum HRCAMERA_MODE m_eCamMode, offset 0x4>
		enum HRCAMERA_MODE m_eCamMode;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class CMotionPlayer::CElement [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(CMotionPlayer::CElement& InObject)
		{
			m_nMotIndex = InObject.m_nMotIndex;
			m_eCamMode = InObject.m_eCamMode;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CElement>("CMotionPlayer_CElement")
				.addFunction("__tostring", &CMotionPlayer::CElement::ToString)
				.addFunction("GetPtrAddr", &CMotionPlayer::CElement::GetPtrAddr)
				.addProperty("m_nMotIndex", &CMotionPlayer::CElement::m_nMotIndex)
				.addProperty("m_eCamMode", &CMotionPlayer::CElement::m_eCamMode)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(CMotionPlayer::CElement::m_nMotIndex) == 4, "expected CMotionPlayer::CElement::m_nMotIndex to be size 4");
	static_assert(sizeof(CMotionPlayer::CElement::m_eCamMode) == 4, "expected CMotionPlayer::CElement::m_eCamMode to be size 4");
	static_assert(sizeof(CMotionPlayer::CElement) == 0x8, "expected CMotionPlayer::CElement to be size 0x8");

	/// Struct member variables

	// <class CStlVector<CMotionPlayer::CElement> m_ainElement, offset 0x0>
	class std::vector<CMotionPlayer::CElement> m_ainElement;

	// <class mHRChara* m_pChara, offset 0xc>
	class mHRChara* m_pChara = nullptr;

	// <int32_t m_nPlayIndex, offset 0x10>
	int32_t m_nPlayIndex = 0;

	/// 1 Functions

	// [Function] void __convention("thiscall") CMotionPlayer::begin(class CMotionPlayer* const this, class mHRChara* arg2) [?begin@CMotionPlayer@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _begin_CMotionPlayer__QAEXPAVmHRChara___Z)(class CMotionPlayer* const thisPtr, class mHRChara* arg2);
	void begin(class mHRChara* arg2)
	{
		_begin_CMotionPlayer__QAEXPAVmHRChara___Z mFunc = (_begin_CMotionPlayer__QAEXPAVmHRChara___Z)(GameModule + 0x697c70);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CMotionPlayer [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CMotionPlayer& InObject)
	{
		m_ainElement = InObject.m_ainElement;
		m_pChara = InObject.m_pChara;
		m_nPlayIndex = InObject.m_nPlayIndex;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CMotionPlayer>("CMotionPlayer")
			.addFunction("__tostring", &CMotionPlayer::ToString)
			.addFunction("GetPtrAddr", &CMotionPlayer::GetPtrAddr)
			.addProperty("m_ainElement", &CMotionPlayer::m_ainElement)
			.addProperty("m_pChara", &CMotionPlayer::m_pChara)
			.addProperty("m_nPlayIndex", &CMotionPlayer::m_nPlayIndex)
			.addFunction("begin", &CMotionPlayer::begin)
		.endClass();
	}
#endif
};
static_assert(sizeof(CMotionPlayer::m_ainElement) == 12, "expected CMotionPlayer::m_ainElement to be size 12");
static_assert(sizeof(CMotionPlayer::m_pChara) == 4, "expected CMotionPlayer::m_pChara to be size 4");
static_assert(sizeof(CMotionPlayer::m_nPlayIndex) == 4, "expected CMotionPlayer::m_nPlayIndex to be size 4");
static_assert(sizeof(CMotionPlayer) == 0x14, "expected CMotionPlayer to be size 0x14");

// [Structure] class CNYShopNPCTalkBase
class CNYShopNPCTalkBase
{
public:
	// enum CNYShopNPCTalkBase::TALK_TYPE
	enum TALK_TYPE : uint32_t
	{
		// <TALK_NONE = 0x0>
		TALK_NONE = 0,

		// <TALK_INTO = 0x1>
		TALK_INTO = 1,

		// <TALK_GO_OUT = 0x2>
		TALK_GO_OUT = 2,

		// <TALK_SPECIAL_1 = 0x3>
		TALK_SPECIAL_1 = 3,

		// <TALK_SPECIAL_2 = 0x4>
		TALK_SPECIAL_2 = 4,

		// <TALK_SPECIAL_3 = 0x5>
		TALK_SPECIAL_3 = 5,

		// <TALK_SPECIAL_4 = 0x6>
		TALK_SPECIAL_4 = 6,

		// <TALK_TYPE_MAX = 0x7>
		TALK_TYPE_MAX = 7

	};

	// enum CNYShopNPCTalkBase::MOTION_TYPE
	enum MOTION_TYPE : uint32_t
	{
		// <MOTION_NATURAL = 0x0>
		MOTION_NATURAL = 0,

		// <MOTION_TALK_START = 0x1>
		MOTION_TALK_START = 1,

		// <MOTION_TALK = 0x2>
		MOTION_TALK = 2,

		// <MOTION_TALK_SPECIAL_ACTION_1 = 0x3>
		MOTION_TALK_SPECIAL_ACTION_1 = 3,

		// <MOTION_TALK_SPECIAL_ACTION_2 = 0x4>
		MOTION_TALK_SPECIAL_ACTION_2 = 4,

		// <MOTION_TALK_SPECIAL_ACTION_3 = 0x5>
		MOTION_TALK_SPECIAL_ACTION_3 = 5,

		// <MOTION_TALK_SPECIAL_ACTION_4 = 0x6>
		MOTION_TALK_SPECIAL_ACTION_4 = 6,

		// <MOTION_TALK_SPECIAL_ACTION_5 = 0x7>
		MOTION_TALK_SPECIAL_ACTION_5 = 7,

		// <MOTION_TALK_FINISH = 0x8>
		MOTION_TALK_FINISH = 8,

		// <MOTION_TYPE_MAX = 0x9>
		MOTION_TYPE_MAX = 9

	};

	// enum CNYShopNPCTalkBase::CONTROLLER_TYPE
	enum CONTROLLER_TYPE : uint32_t
	{
		// <CONTROLLER_NORMAL = 0x0>
		CONTROLLER_NORMAL = 0,

		// <CONTROLLER_CLASSIC = 0x1>
		CONTROLLER_CLASSIC = 1,

		// <CONTROLLER_TYPE_MAX = 0x2>
		CONTROLLER_TYPE_MAX = 2

	};

	/// Struct member variables

	// <void* (* field_0)[0x8], offset 0x0>
	void* (* field_0)[0x8];

	// <class CMotionPlayer m_MotionPlayer, offset 0x4>
	class CMotionPlayer m_MotionPlayer;

	// <void (* m_pPhaseProc[0x8][0x1])(CNYShopNPCTalkBase* const this), offset 0x18>
	void (* m_pPhaseProc[0x8][0x1])(CNYShopNPCTalkBase* const ThisPtr);

	// <class NYPhase m_Phase, offset 0x38>
	class NYPhase m_Phase;

	// <class mHRChara* m_pChara, offset 0x54>
	class mHRChara* m_pChara = nullptr;

	// <uint8_t m_bMotionPlay, offset 0x58>
	uint8_t m_bMotionPlay = 0;

	// <char m_FileName[0xa], offset 0x59>
	char m_FileName[10];

	// <Unidentified data segment, offset 0x63>
private:
	char _UnidentifiedData_99[1];

public:
	// <int32_t m_TalkMotionNo[0x9][0x2], offset 0x64>
	int32_t m_TalkMotionNo[9][2];

	// <enum CNYShopNPCTalkBase::TALK_TYPE m_TalkType, offset 0xac>
	enum CNYShopNPCTalkBase::TALK_TYPE m_TalkType;

	// <enum CNYShopNPCTalkBase::MOTION_TYPE m_TalkStartMotionType, offset 0xb0>
	enum CNYShopNPCTalkBase::MOTION_TYPE m_TalkStartMotionType;

	// <enum CNYShopNPCTalkBase::MOTION_TYPE m_TalkingMotionType, offset 0xb4>
	enum CNYShopNPCTalkBase::MOTION_TYPE m_TalkingMotionType;

	// <enum CNYShopNPCTalkBase::MOTION_TYPE m_TalkFinishMotionType, offset 0xb8>
	enum CNYShopNPCTalkBase::MOTION_TYPE m_TalkFinishMotionType;

	// <enum CNYShopNPCTalkBase::CONTROLLER_TYPE m_ControllerType, offset 0xbc>
	enum CNYShopNPCTalkBase::CONTROLLER_TYPE m_ControllerType;

	// <class HrTalk* m_pHrTalk, offset 0xc0>
	class HrTalk* m_pHrTalk = nullptr;

	/// 2 Functions

	// [Function] class HrTalk* __convention("thiscall") CNYShopNPCTalkBase::GetHrTalk(class CNYShopNPCTalkBase* const this) [?GetHrTalk@CNYShopNPCTalkBase@@IAEPAVHrTalk@@XZ]
	typedef class HrTalk*(__thiscall* _GetHrTalk_CNYShopNPCTalkBase__IAEPAVHrTalk__XZ)(class CNYShopNPCTalkBase* const thisPtr);
	class HrTalk* GetHrTalk()
	{
		_GetHrTalk_CNYShopNPCTalkBase__IAEPAVHrTalk__XZ mFunc = (_GetHrTalk_CNYShopNPCTalkBase__IAEPAVHrTalk__XZ)(GameModule + 0xd02b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") CNYShopNPCTalkBase::ResetHrTalk(class CNYShopNPCTalkBase* const this) [?ResetHrTalk@CNYShopNPCTalkBase@@IAEXXZ]
	typedef void(__thiscall* _ResetHrTalk_CNYShopNPCTalkBase__IAEXXZ)(class CNYShopNPCTalkBase* const thisPtr);
	void ResetHrTalk()
	{
		_ResetHrTalk_CNYShopNPCTalkBase__IAEXXZ mFunc = (_ResetHrTalk_CNYShopNPCTalkBase__IAEXXZ)(GameModule + 0xe2cd0);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CNYShopNPCTalkBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CNYShopNPCTalkBase& InObject)
	{
		m_MotionPlayer = InObject.m_MotionPlayer;
		m_Phase = InObject.m_Phase;
		m_pChara = InObject.m_pChara;
		m_bMotionPlay = InObject.m_bMotionPlay;
		m_TalkType = InObject.m_TalkType;
		m_TalkStartMotionType = InObject.m_TalkStartMotionType;
		m_TalkingMotionType = InObject.m_TalkingMotionType;
		m_TalkFinishMotionType = InObject.m_TalkFinishMotionType;
		m_ControllerType = InObject.m_ControllerType;
		m_pHrTalk = InObject.m_pHrTalk;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CNYShopNPCTalkBase>("CNYShopNPCTalkBase")
			.addFunction("__tostring", &CNYShopNPCTalkBase::ToString)
			.addFunction("GetPtrAddr", &CNYShopNPCTalkBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &CNYShopNPCTalkBase::field_0)
			.addProperty("m_MotionPlayer", &CNYShopNPCTalkBase::m_MotionPlayer)
			// void type not supported in LuaBridge
			//.addProperty("m_pPhaseProc", &CNYShopNPCTalkBase::m_pPhaseProc)
			.addProperty("m_Phase", &CNYShopNPCTalkBase::m_Phase)
			.addProperty("m_pChara", &CNYShopNPCTalkBase::m_pChara)
			.addProperty("m_bMotionPlay", &CNYShopNPCTalkBase::m_bMotionPlay)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_FileName", &CNYShopNPCTalkBase::m_FileName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_TalkMotionNo", &CNYShopNPCTalkBase::m_TalkMotionNo)
			.addProperty("m_TalkType", &CNYShopNPCTalkBase::m_TalkType)
			.addProperty("m_TalkStartMotionType", &CNYShopNPCTalkBase::m_TalkStartMotionType)
			.addProperty("m_TalkingMotionType", &CNYShopNPCTalkBase::m_TalkingMotionType)
			.addProperty("m_TalkFinishMotionType", &CNYShopNPCTalkBase::m_TalkFinishMotionType)
			.addProperty("m_ControllerType", &CNYShopNPCTalkBase::m_ControllerType)
			.addProperty("m_pHrTalk", &CNYShopNPCTalkBase::m_pHrTalk)
			.addFunction("GetHrTalk", &CNYShopNPCTalkBase::GetHrTalk)
			.addFunction("ResetHrTalk", &CNYShopNPCTalkBase::ResetHrTalk)
		.endClass();
	}
#endif
};
static_assert(sizeof(CNYShopNPCTalkBase::field_0) == 4, "expected CNYShopNPCTalkBase::field_0 to be size 4");
static_assert(sizeof(CNYShopNPCTalkBase::m_MotionPlayer) == 20, "expected CNYShopNPCTalkBase::m_MotionPlayer to be size 20");
static_assert(sizeof(CNYShopNPCTalkBase::m_pPhaseProc) == 32, "expected CNYShopNPCTalkBase::m_pPhaseProc to be size 32");
static_assert(sizeof(CNYShopNPCTalkBase::m_Phase) == 28, "expected CNYShopNPCTalkBase::m_Phase to be size 28");
static_assert(sizeof(CNYShopNPCTalkBase::m_pChara) == 4, "expected CNYShopNPCTalkBase::m_pChara to be size 4");
static_assert(sizeof(CNYShopNPCTalkBase::m_bMotionPlay) == 1, "expected CNYShopNPCTalkBase::m_bMotionPlay to be size 1");
static_assert(sizeof(CNYShopNPCTalkBase::m_FileName) == 10, "expected CNYShopNPCTalkBase::m_FileName to be size 10");
static_assert(sizeof(CNYShopNPCTalkBase::m_TalkMotionNo) == 72, "expected CNYShopNPCTalkBase::m_TalkMotionNo to be size 72");
static_assert(sizeof(CNYShopNPCTalkBase::m_TalkType) == 4, "expected CNYShopNPCTalkBase::m_TalkType to be size 4");
static_assert(sizeof(CNYShopNPCTalkBase::m_TalkStartMotionType) == 4, "expected CNYShopNPCTalkBase::m_TalkStartMotionType to be size 4");
static_assert(sizeof(CNYShopNPCTalkBase::m_TalkingMotionType) == 4, "expected CNYShopNPCTalkBase::m_TalkingMotionType to be size 4");
static_assert(sizeof(CNYShopNPCTalkBase::m_TalkFinishMotionType) == 4, "expected CNYShopNPCTalkBase::m_TalkFinishMotionType to be size 4");
static_assert(sizeof(CNYShopNPCTalkBase::m_ControllerType) == 4, "expected CNYShopNPCTalkBase::m_ControllerType to be size 4");
static_assert(sizeof(CNYShopNPCTalkBase::m_pHrTalk) == 4, "expected CNYShopNPCTalkBase::m_pHrTalk to be size 4");
static_assert(sizeof(CNYShopNPCTalkBase) == 0xc4, "expected CNYShopNPCTalkBase to be size 0xc4");

// [Structure] struct HRSAVEDATA_SHOP
struct HRSAVEDATA_SHOP
{
public:
	/// Struct member variables

	// <uint32_t m_checkedFlag[0xd], offset 0x0>
	uint32_t m_checkedFlag[13];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct HRSAVEDATA_SHOP [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HRSAVEDATA_SHOP& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HRSAVEDATA_SHOP>("HRSAVEDATA_SHOP")
			.addFunction("__tostring", &HRSAVEDATA_SHOP::ToString)
			.addFunction("GetPtrAddr", &HRSAVEDATA_SHOP::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_checkedFlag", &HRSAVEDATA_SHOP::m_checkedFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(HRSAVEDATA_SHOP::m_checkedFlag) == 52, "expected HRSAVEDATA_SHOP::m_checkedFlag to be size 52");
static_assert(sizeof(HRSAVEDATA_SHOP) == 0x34, "expected HRSAVEDATA_SHOP to be size 0x34");

// Unsupported constructor
//void __convention("thiscall") HrMissionResult::HrMissionResult(class HrMissionResult* const this)
// [Structure] class PJZAKOBoneFive
class PJZAKOBoneFive : public PJZAKO
{
public:
	/// Struct member variables

	// <class PJZAKO field_0, offset 0x0>
	// class PJZAKO Super;

	/// 2 Functions

	// [Function] int32_t __convention("thiscall") PJZAKOBoneFive::GetBoneMotMax(class PJZAKOBoneFive* const this) [?GetBoneMotMax@PJZAKOBoneFive@@UBEHXZ]
	typedef int32_t(__thiscall* _GetBoneMotMax_PJZAKOBoneFive__UBEHXZ)(class PJZAKOBoneFive* const thisPtr);
	int32_t GetBoneMotMax()
	{
		_GetBoneMotMax_PJZAKOBoneFive__UBEHXZ mFunc = (_GetBoneMotMax_PJZAKOBoneFive__UBEHXZ)(GameModule + 0xd89a0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") PJZAKOBoneFive::GetBoneCmnMotIdx(class PJZAKOBoneFive* const this, int32_t arg2) [?GetBoneCmnMotIdx@PJZAKOBoneFive@@UBEHH@Z]
	typedef int32_t(__thiscall* _GetBoneCmnMotIdx_PJZAKOBoneFive__UBEHH_Z)(class PJZAKOBoneFive* const thisPtr, int32_t arg2);
	int32_t GetBoneCmnMotIdx(int32_t arg2)
	{
		_GetBoneCmnMotIdx_PJZAKOBoneFive__UBEHH_Z mFunc = (_GetBoneCmnMotIdx_PJZAKOBoneFive__UBEHH_Z)(GameModule + 0x5d4fd0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZAKOBoneFive [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZAKOBoneFive& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZAKOBoneFive, PJZAKO>("PJZAKOBoneFive")
			.addFunction("__tostring", &PJZAKOBoneFive::ToString)
			.addFunction("GetPtrAddr", &PJZAKOBoneFive::GetPtrAddr)
			.addFunction("GetBoneMotMax", &PJZAKOBoneFive::GetBoneMotMax)
			.addFunction("GetBoneCmnMotIdx", &PJZAKOBoneFive::GetBoneCmnMotIdx)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKOBoneFive) == 0x9e4, "expected PJZAKOBoneFive to be size 0x9e4");

// Unsupported operator
//void* __convention("thiscall") PJZAKOBoneFive::`vector deleting destructor'(class PJZAKOBoneFive* const this, uint32_t arg2)
// Unsupported operator
//void* __convention("thiscall") PJZAKOBoneA::`vector deleting destructor'(class PJZAKOBoneA* const this, uint32_t arg2)
// Unsupported operator
//void* __convention("thiscall") PJZAKOBoneB::`vector deleting destructor'(class PJZAKOBoneB* const this, uint32_t arg2)
// Unsupported operator
//void* __convention("thiscall") PJZAKOBoneC::`vector deleting destructor'(class PJZAKOBoneC* const this, uint32_t arg2)
// Unsupported operator
//void* __convention("thiscall") PJZAKOBoneD::`vector deleting destructor'(class PJZAKOBoneD* const this, uint32_t arg2)
// Unsupported operator
//void* __convention("thiscall") WGdl::`vector deleting destructor'(class WGdl* const this, uint32_t arg2)
// [Structure] class HrScript
class HrScript : public ghmListObj
{
public:
	// enum HrScript::eRevengeMissionResult
	enum eRevengeMissionResult : uint32_t
	{
		// <eRevengeMissionResult_Doing = 0xffffffffffffffff>
		eRevengeMissionResult_Doing = UINT32_MAX,

		// <eRevengeMissionResult_Cancel = 0x0>
		eRevengeMissionResult_Cancel = 0,

		// <eRevengeMissionResult_Success = 0x1>
		eRevengeMissionResult_Success = 1,

		// <eRevengeMissionResult_TimeOver = 0x2>
		eRevengeMissionResult_TimeOver = 2

	};

	// enum HrScript::HRSCRIPT_CNTDISP
	enum HRSCRIPT_CNTDISP : uint32_t
	{
		// <HRSCRIPT_CNTDISP_SLEEP = 0x0>
		HRSCRIPT_CNTDISP_SLEEP = 0,

		// <HRSCRIPT_CNTDISP_INIT = 0x1>
		HRSCRIPT_CNTDISP_INIT = 1,

		// <HRSCRIPT_CNTDISP_DISP = 0x2>
		HRSCRIPT_CNTDISP_DISP = 2,

		// <HRSCRIPT_CNTDISP_MAX = 0x3>
		HRSCRIPT_CNTDISP_MAX = 3

	};

	// enum HrScript::HRSCRIPT_ID
	enum HRSCRIPT_ID : uint32_t
	{
		// <HRSCRIPT_BOOT = 0x0>
		HRSCRIPT_BOOT = 0,

		// <HRSCRIPT_SET = 0x1>
		HRSCRIPT_SET = 1,

		// <HRSCRIPT_LOAD = 0x2>
		HRSCRIPT_LOAD = 2,

		// <HRSCRIPT_IDLE = 0x3>
		HRSCRIPT_IDLE = 3,

		// <HRSCRIPT_PROCESS = 0x4>
		HRSCRIPT_PROCESS = 4,

		// <HRSCRIPT_END = 0x5>
		HRSCRIPT_END = 5,

		// <HRSCRIPT_DELETE = 0x6>
		HRSCRIPT_DELETE = 6,

		// <HRSCRIPT_ID_MAX = 0x7>
		HRSCRIPT_ID_MAX = 7

	};

	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <uint8_t mRunSubMission, offset 0x10>
	uint8_t mRunSubMission = 0;

	// <Unidentified data segment, offset 0x11>
private:
	char _UnidentifiedData_17[3];

public:
	// <enum HrScript::eRevengeMissionResult m_eRevengeMissionResult, offset 0x14>
	enum HrScript::eRevengeMissionResult m_eRevengeMissionResult;

	// <int64_t m_SubMissionTime, offset 0x18>
	int64_t m_SubMissionTime;

	// <int64_t m_SubMissionLimitTime, offset 0x20>
	int64_t m_SubMissionLimitTime;

	// <enum HrScript::HRSCRIPT_CNTDISP m_CntDispProc, offset 0x28>
	enum HrScript::HRSCRIPT_CNTDISP m_CntDispProc;

	// <int32_t m_RevengeMissionLastEnmKillPerformCnt, offset 0x2c>
	int32_t m_RevengeMissionLastEnmKillPerformCnt = 0;

	// <class EveObj* m_pEveObj, offset 0x30>
	class EveObj* m_pEveObj = nullptr;

	// <uint32_t m_GetNum, offset 0x34>
	uint32_t m_GetNum = 0;

	// <int32_t m_smkillcnt, offset 0x38>
	int32_t m_smkillcnt = 0;

	// <int32_t m_smkillupsoundtimer, offset 0x3c>
	int32_t m_smkillupsoundtimer = 0;

	// <int32_t m_killcntold, offset 0x40>
	int32_t m_killcntold = 0;

	// <class ghmScript* m_pGhmScript, offset 0x44>
	class ghmScript* m_pGhmScript = nullptr;

	// <class ghmScript* m_pEventScript, offset 0x48>
	class ghmScript* m_pEventScript = nullptr;

	// <class HrScriptFunc* m_pScriptFunc[0x14], offset 0x4c>
	class HrScriptFunc* m_pScriptFunc[20];

	// <class HrScriptFunc* m_pCurrentFunc, offset 0x9c>
	class HrScriptFunc* m_pCurrentFunc = nullptr;

	// <enum HrScript::HRSCRIPT_ID m_Process, offset 0xa0>
	enum HrScript::HRSCRIPT_ID m_Process;

	// <uint32_t m_Handle, offset 0xa4>
	uint32_t m_Handle = 0;

	// <uint32_t m_ParentHandle, offset 0xa8>
	uint32_t m_ParentHandle = 0;

	// <class TGan* m_pGan[0x20], offset 0xac>
	class TGan* m_pGan[32];

	// <class ghmResGroup* m_pNPCModlGmf, offset 0x12c>
	class ghmResGroup* m_pNPCModlGmf = nullptr;

	// <char m_SubName[0x10], offset 0x130>
	char m_SubName[16];

	// <uint8_t m_CountSeFlag, offset 0x140>
	uint8_t m_CountSeFlag = 0;

	// <Unidentified data segment, offset 0x141>
private:
	char _UnidentifiedData_321[3];

public:
	// <int32_t m_CountSeTmp, offset 0x144>
	int32_t m_CountSeTmp = 0;

	// <uint8_t m_IsSubMissionTitle, offset 0x148>
	uint8_t m_IsSubMissionTitle = 0;

	// <Unidentified data segment, offset 0x149>
private:
	char _UnidentifiedData_329[3];

public:
	// <struct tagGHMR_TEX m_SubMissionTitle, offset 0x14c>
	struct tagGHMR_TEX m_SubMissionTitle;

	// <struct Vec m_Position, offset 0x174>
	struct Vec m_Position;

	// <class HrMainMissionFax* m_pLetter, offset 0x180>
	class HrMainMissionFax* m_pLetter = nullptr;

	// <class ghmGcFile m_File, offset 0x184>
	class ghmGcFile m_File;

	// <char m_FileName[0x20], offset 0x240>
	char m_FileName[32];

	// <class ghmResGroup* m_pRsl, offset 0x260>
	class ghmResGroup* m_pRsl = nullptr;

	// <void* m_pRslData, offset 0x264>
	void* m_pRslData = nullptr;

	// <void* m_pScrData, offset 0x268>
	void* m_pScrData = nullptr;

	// <Unidentified data segment, offset 0x26c>
private:
	char _UnidentifiedData_620[4];

public:
	/// 3 Functions

	// [Function] class ghmResGroup* HrScript::GetSubMissionRsl() [?GetSubMissionRsl@HrScript@@SAPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__fastcall* _GetSubMissionRsl_HrScript__SAPAVghmResGroup__XZ)();
	static class ghmResGroup* GetSubMissionRsl()
	{
		_GetSubMissionRsl_HrScript__SAPAVghmResGroup__XZ mFunc = (_GetSubMissionRsl_HrScript__SAPAVghmResGroup__XZ)(GameModule + 0x3ca990);
		return mFunc();
	}
	// [Function] class ghmResGroup* __convention("thiscall") HrScript::GetpRsl(class HrScript* const this) [?GetpRsl@HrScript@@QAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _GetpRsl_HrScript__QAEPAVghmResGroup__XZ)(class HrScript* const thisPtr);
	class ghmResGroup* GetpRsl()
	{
		_GetpRsl_HrScript__QAEPAVghmResGroup__XZ mFunc = (_GetpRsl_HrScript__QAEPAVghmResGroup__XZ)(GameModule + 0x3cb650);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrScript::SetModelData(class HrScript* const this, class ghmResGroup* arg2) [?SetModelData@HrScript@@QAEXPAVghmResGroup@@@Z]
	typedef void(__thiscall* _SetModelData_HrScript__QAEXPAVghmResGroup___Z)(class HrScript* const thisPtr, class ghmResGroup* arg2);
	void SetModelData(class ghmResGroup* arg2)
	{
		_SetModelData_HrScript__QAEXPAVghmResGroup___Z mFunc = (_SetModelData_HrScript__QAEXPAVghmResGroup___Z)(GameModule + 0x3dc2b0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrScript [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrScript& InObject)
	{
		mRunSubMission = InObject.mRunSubMission;
		m_eRevengeMissionResult = InObject.m_eRevengeMissionResult;
		m_SubMissionTime = InObject.m_SubMissionTime;
		m_SubMissionLimitTime = InObject.m_SubMissionLimitTime;
		m_CntDispProc = InObject.m_CntDispProc;
		m_RevengeMissionLastEnmKillPerformCnt = InObject.m_RevengeMissionLastEnmKillPerformCnt;
		m_pEveObj = InObject.m_pEveObj;
		m_GetNum = InObject.m_GetNum;
		m_smkillcnt = InObject.m_smkillcnt;
		m_smkillupsoundtimer = InObject.m_smkillupsoundtimer;
		m_killcntold = InObject.m_killcntold;
		m_pGhmScript = InObject.m_pGhmScript;
		m_pEventScript = InObject.m_pEventScript;
		m_pCurrentFunc = InObject.m_pCurrentFunc;
		m_Process = InObject.m_Process;
		m_Handle = InObject.m_Handle;
		m_ParentHandle = InObject.m_ParentHandle;
		m_pNPCModlGmf = InObject.m_pNPCModlGmf;
		m_CountSeFlag = InObject.m_CountSeFlag;
		m_CountSeTmp = InObject.m_CountSeTmp;
		m_IsSubMissionTitle = InObject.m_IsSubMissionTitle;
		m_SubMissionTitle = InObject.m_SubMissionTitle;
		m_Position = InObject.m_Position;
		m_pLetter = InObject.m_pLetter;
		m_File = InObject.m_File;
		m_pRsl = InObject.m_pRsl;
		m_pRslData = InObject.m_pRslData;
		m_pScrData = InObject.m_pScrData;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrScript, ghmListObj>("HrScript")
			.addFunction("__tostring", &HrScript::ToString)
			.addFunction("GetPtrAddr", &HrScript::GetPtrAddr)
			.addProperty("mRunSubMission", &HrScript::mRunSubMission)
			.addProperty("m_eRevengeMissionResult", &HrScript::m_eRevengeMissionResult)
			.addProperty("m_SubMissionTime", &HrScript::m_SubMissionTime)
			.addProperty("m_SubMissionLimitTime", &HrScript::m_SubMissionLimitTime)
			.addProperty("m_CntDispProc", &HrScript::m_CntDispProc)
			.addProperty("m_RevengeMissionLastEnmKillPerformCnt", &HrScript::m_RevengeMissionLastEnmKillPerformCnt)
			.addProperty("m_pEveObj", &HrScript::m_pEveObj)
			.addProperty("m_GetNum", &HrScript::m_GetNum)
			.addProperty("m_smkillcnt", &HrScript::m_smkillcnt)
			.addProperty("m_smkillupsoundtimer", &HrScript::m_smkillupsoundtimer)
			.addProperty("m_killcntold", &HrScript::m_killcntold)
			.addProperty("m_pGhmScript", &HrScript::m_pGhmScript)
			.addProperty("m_pEventScript", &HrScript::m_pEventScript)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pScriptFunc", &HrScript::m_pScriptFunc)
			.addProperty("m_pCurrentFunc", &HrScript::m_pCurrentFunc)
			.addProperty("m_Process", &HrScript::m_Process)
			.addProperty("m_Handle", &HrScript::m_Handle)
			.addProperty("m_ParentHandle", &HrScript::m_ParentHandle)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pGan", &HrScript::m_pGan)
			.addProperty("m_pNPCModlGmf", &HrScript::m_pNPCModlGmf)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_SubName", &HrScript::m_SubName)
			.addProperty("m_CountSeFlag", &HrScript::m_CountSeFlag)
			.addProperty("m_CountSeTmp", &HrScript::m_CountSeTmp)
			.addProperty("m_IsSubMissionTitle", &HrScript::m_IsSubMissionTitle)
			.addProperty("m_SubMissionTitle", &HrScript::m_SubMissionTitle)
			.addProperty("m_Position", &HrScript::m_Position)
			.addProperty("m_pLetter", &HrScript::m_pLetter)
			.addProperty("m_File", &HrScript::m_File)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_FileName", &HrScript::m_FileName)
			.addProperty("m_pRsl", &HrScript::m_pRsl)
			// void type not supported in LuaBridge
			//.addProperty("m_pRslData", &HrScript::m_pRslData)
			// void type not supported in LuaBridge
			//.addProperty("m_pScrData", &HrScript::m_pScrData)
			.addStaticFunction("GetSubMissionRsl", &HrScript::GetSubMissionRsl)
			.addFunction("GetpRsl", &HrScript::GetpRsl)
			.addFunction("SetModelData", &HrScript::SetModelData)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrScript::mRunSubMission) == 1, "expected HrScript::mRunSubMission to be size 1");
static_assert(sizeof(HrScript::m_eRevengeMissionResult) == 4, "expected HrScript::m_eRevengeMissionResult to be size 4");
static_assert(sizeof(HrScript::m_SubMissionTime) == 8, "expected HrScript::m_SubMissionTime to be size 8");
static_assert(sizeof(HrScript::m_SubMissionLimitTime) == 8, "expected HrScript::m_SubMissionLimitTime to be size 8");
static_assert(sizeof(HrScript::m_CntDispProc) == 4, "expected HrScript::m_CntDispProc to be size 4");
static_assert(sizeof(HrScript::m_RevengeMissionLastEnmKillPerformCnt) == 4, "expected HrScript::m_RevengeMissionLastEnmKillPerformCnt to be size 4");
static_assert(sizeof(HrScript::m_pEveObj) == 4, "expected HrScript::m_pEveObj to be size 4");
static_assert(sizeof(HrScript::m_GetNum) == 4, "expected HrScript::m_GetNum to be size 4");
static_assert(sizeof(HrScript::m_smkillcnt) == 4, "expected HrScript::m_smkillcnt to be size 4");
static_assert(sizeof(HrScript::m_smkillupsoundtimer) == 4, "expected HrScript::m_smkillupsoundtimer to be size 4");
static_assert(sizeof(HrScript::m_killcntold) == 4, "expected HrScript::m_killcntold to be size 4");
static_assert(sizeof(HrScript::m_pGhmScript) == 4, "expected HrScript::m_pGhmScript to be size 4");
static_assert(sizeof(HrScript::m_pEventScript) == 4, "expected HrScript::m_pEventScript to be size 4");
static_assert(sizeof(HrScript::m_pScriptFunc) == 80, "expected HrScript::m_pScriptFunc to be size 80");
static_assert(sizeof(HrScript::m_pCurrentFunc) == 4, "expected HrScript::m_pCurrentFunc to be size 4");
static_assert(sizeof(HrScript::m_Process) == 4, "expected HrScript::m_Process to be size 4");
static_assert(sizeof(HrScript::m_Handle) == 4, "expected HrScript::m_Handle to be size 4");
static_assert(sizeof(HrScript::m_ParentHandle) == 4, "expected HrScript::m_ParentHandle to be size 4");
static_assert(sizeof(HrScript::m_pGan) == 128, "expected HrScript::m_pGan to be size 128");
static_assert(sizeof(HrScript::m_pNPCModlGmf) == 4, "expected HrScript::m_pNPCModlGmf to be size 4");
static_assert(sizeof(HrScript::m_SubName) == 16, "expected HrScript::m_SubName to be size 16");
static_assert(sizeof(HrScript::m_CountSeFlag) == 1, "expected HrScript::m_CountSeFlag to be size 1");
static_assert(sizeof(HrScript::m_CountSeTmp) == 4, "expected HrScript::m_CountSeTmp to be size 4");
static_assert(sizeof(HrScript::m_IsSubMissionTitle) == 1, "expected HrScript::m_IsSubMissionTitle to be size 1");
static_assert(sizeof(HrScript::m_SubMissionTitle) == 40, "expected HrScript::m_SubMissionTitle to be size 40");
static_assert(sizeof(HrScript::m_Position) == 12, "expected HrScript::m_Position to be size 12");
static_assert(sizeof(HrScript::m_pLetter) == 4, "expected HrScript::m_pLetter to be size 4");
static_assert(sizeof(HrScript::m_File) == 188, "expected HrScript::m_File to be size 188");
static_assert(sizeof(HrScript::m_FileName) == 32, "expected HrScript::m_FileName to be size 32");
static_assert(sizeof(HrScript::m_pRsl) == 4, "expected HrScript::m_pRsl to be size 4");
static_assert(sizeof(HrScript::m_pRslData) == 4, "expected HrScript::m_pRslData to be size 4");
static_assert(sizeof(HrScript::m_pScrData) == 4, "expected HrScript::m_pScrData to be size 4");
static_assert(sizeof(HrScript) == 0x270, "expected HrScript to be size 0x270");

// [Structure] class EveObj
class EveObj : public ghmListObj
{
public:
	// enum EveObj::EVE_OBJ_KIND
	enum EVE_OBJ_KIND : uint32_t
	{
		// <EVEN_OBJ_NONE = 0x0>
		EVEN_OBJ_NONE = 0,

		// <EVEN_OBJ_GARBAGE = 0x1>
		EVEN_OBJ_GARBAGE = 1,

		// <EVEN_OBJ_MODEL = 0x2>
		EVEN_OBJ_MODEL = 2,

		// <EVEN_OBJ_STGMODEL = 0x3>
		EVEN_OBJ_STGMODEL = 3,

		// <EVEN_OBJ_MAX = 0x4>
		EVEN_OBJ_MAX = 4

	};

	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class TGmf* m_pNPCModlGmf, offset 0x10>
	class TGmf* m_pNPCModlGmf = nullptr;

	// <enum EveObj::EVE_OBJ_KIND m_Kind, offset 0x14>
	enum EveObj::EVE_OBJ_KIND m_Kind;

	// <uint32_t m_handle, offset 0x18>
	uint32_t m_handle = 0;

	// <uint32_t m_ScrHandle, offset 0x1c>
	uint32_t m_ScrHandle = 0;

	// <uint8_t m_Visible, offset 0x20>
	uint8_t m_Visible = 0;

	// <Unidentified data segment, offset 0x21>
private:
	char _UnidentifiedData_33[3];

public:
	// <struct Vec m_Pos, offset 0x24>
	struct Vec m_Pos;

	// <struct Vec m_Dir, offset 0x30>
	struct Vec m_Dir;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EveObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EveObj& InObject)
	{
		m_pNPCModlGmf = InObject.m_pNPCModlGmf;
		m_Kind = InObject.m_Kind;
		m_handle = InObject.m_handle;
		m_ScrHandle = InObject.m_ScrHandle;
		m_Visible = InObject.m_Visible;
		m_Pos = InObject.m_Pos;
		m_Dir = InObject.m_Dir;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EveObj, ghmListObj>("EveObj")
			.addFunction("__tostring", &EveObj::ToString)
			.addFunction("GetPtrAddr", &EveObj::GetPtrAddr)
			.addProperty("m_pNPCModlGmf", &EveObj::m_pNPCModlGmf)
			.addProperty("m_Kind", &EveObj::m_Kind)
			.addProperty("m_handle", &EveObj::m_handle)
			.addProperty("m_ScrHandle", &EveObj::m_ScrHandle)
			.addProperty("m_Visible", &EveObj::m_Visible)
			.addProperty("m_Pos", &EveObj::m_Pos)
			.addProperty("m_Dir", &EveObj::m_Dir)
		.endClass();
	}
#endif
};
static_assert(sizeof(EveObj::m_pNPCModlGmf) == 4, "expected EveObj::m_pNPCModlGmf to be size 4");
static_assert(sizeof(EveObj::m_Kind) == 4, "expected EveObj::m_Kind to be size 4");
static_assert(sizeof(EveObj::m_handle) == 4, "expected EveObj::m_handle to be size 4");
static_assert(sizeof(EveObj::m_ScrHandle) == 4, "expected EveObj::m_ScrHandle to be size 4");
static_assert(sizeof(EveObj::m_Visible) == 1, "expected EveObj::m_Visible to be size 1");
static_assert(sizeof(EveObj::m_Pos) == 12, "expected EveObj::m_Pos to be size 12");
static_assert(sizeof(EveObj::m_Dir) == 12, "expected EveObj::m_Dir to be size 12");
static_assert(sizeof(EveObj) == 0x3c, "expected EveObj to be size 0x3c");

// [Structure] class HrMainMissionFax
class HrMainMissionFax : public HrTask
{
public:
	// enum HrMainMissionFax::D_FAX_STAT
	enum D_FAX_STAT : uint32_t
	{
		// <D_FAX_NONE = 0x0>
		D_FAX_NONE = 0,

		// <D_FAX_INIT = 0x1>
		D_FAX_INIT = 1,

		// <D_FAX_FILEOPEN = 0x2>
		D_FAX_FILEOPEN = 2,

		// <D_FAX_LOADING = 0x3>
		D_FAX_LOADING = 3,

		// <D_FAX_READY = 0x4>
		D_FAX_READY = 4,

		// <D_FAX_END = 0x5>
		D_FAX_END = 5,

		// <D_FAX_DRAW = 0x6>
		D_FAX_DRAW = 6

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <enum HrMainMissionFax::D_FAX_STAT m_Stat, offset 0x50>
	enum HrMainMissionFax::D_FAX_STAT m_Stat;

	// <uint8_t m_ClassType, offset 0x54>
	uint8_t m_ClassType = 0;

	// <Unidentified data segment, offset 0x55>
private:
	char _UnidentifiedData_85[3];

public:
	// <class ghmGcFile* m_pFile, offset 0x58>
	class ghmGcFile* m_pFile = nullptr;

	// <void* m_pRSL, offset 0x5c>
	void* m_pRSL = nullptr;

	// <struct tagGHMR_TEX* m_pObjectTex, offset 0x60>
	struct tagGHMR_TEX* m_pObjectTex = nullptr;

	// <int16_t m_ObjctNum, offset 0x64>
	int16_t m_ObjctNum = 0;

	// <int16_t m_Counter[0x5], offset 0x66>
	int16_t m_Counter[5];

	// <int16_t m_MekuriCounter, offset 0x70>
	int16_t m_MekuriCounter = 0;

	// <Unidentified data segment, offset 0x72>
private:
	char _UnidentifiedData_114[2];

public:
	// <uint32_t m_Handl, offset 0x74>
	uint32_t m_Handl = 0;

	// <int32_t m_Index, offset 0x78>
	int32_t m_Index = 0;

	// <int32_t m_NowLine[0x2], offset 0x7c>
	int32_t m_NowLine[2];

	// <int32_t m_NowSentence, offset 0x84>
	int32_t m_NowSentence = 0;

	// <int16_t m_NowWord, offset 0x88>
	int16_t m_NowWord = 0;

	// <uint8_t m_Fax_End_f, offset 0x8a>
	uint8_t m_Fax_End_f = 0;

	// <Unidentified data segment, offset 0x8b>
private:
	char _UnidentifiedData_139[1];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMainMissionFax [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMainMissionFax& InObject)
	{
		m_Stat = InObject.m_Stat;
		m_ClassType = InObject.m_ClassType;
		m_pFile = InObject.m_pFile;
		m_pRSL = InObject.m_pRSL;
		m_pObjectTex = InObject.m_pObjectTex;
		m_ObjctNum = InObject.m_ObjctNum;
		m_MekuriCounter = InObject.m_MekuriCounter;
		m_Handl = InObject.m_Handl;
		m_Index = InObject.m_Index;
		m_NowSentence = InObject.m_NowSentence;
		m_NowWord = InObject.m_NowWord;
		m_Fax_End_f = InObject.m_Fax_End_f;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMainMissionFax, HrTask>("HrMainMissionFax")
			.addFunction("__tostring", &HrMainMissionFax::ToString)
			.addFunction("GetPtrAddr", &HrMainMissionFax::GetPtrAddr)
			.addProperty("m_Stat", &HrMainMissionFax::m_Stat)
			.addProperty("m_ClassType", &HrMainMissionFax::m_ClassType)
			.addProperty("m_pFile", &HrMainMissionFax::m_pFile)
			// void type not supported in LuaBridge
			//.addProperty("m_pRSL", &HrMainMissionFax::m_pRSL)
			.addProperty("m_pObjectTex", &HrMainMissionFax::m_pObjectTex)
			.addProperty("m_ObjctNum", &HrMainMissionFax::m_ObjctNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_Counter", &HrMainMissionFax::m_Counter)
			.addProperty("m_MekuriCounter", &HrMainMissionFax::m_MekuriCounter)
			.addProperty("m_Handl", &HrMainMissionFax::m_Handl)
			.addProperty("m_Index", &HrMainMissionFax::m_Index)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_NowLine", &HrMainMissionFax::m_NowLine)
			.addProperty("m_NowSentence", &HrMainMissionFax::m_NowSentence)
			.addProperty("m_NowWord", &HrMainMissionFax::m_NowWord)
			.addProperty("m_Fax_End_f", &HrMainMissionFax::m_Fax_End_f)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMainMissionFax::m_Stat) == 4, "expected HrMainMissionFax::m_Stat to be size 4");
static_assert(sizeof(HrMainMissionFax::m_ClassType) == 1, "expected HrMainMissionFax::m_ClassType to be size 1");
static_assert(sizeof(HrMainMissionFax::m_pFile) == 4, "expected HrMainMissionFax::m_pFile to be size 4");
static_assert(sizeof(HrMainMissionFax::m_pRSL) == 4, "expected HrMainMissionFax::m_pRSL to be size 4");
static_assert(sizeof(HrMainMissionFax::m_pObjectTex) == 4, "expected HrMainMissionFax::m_pObjectTex to be size 4");
static_assert(sizeof(HrMainMissionFax::m_ObjctNum) == 2, "expected HrMainMissionFax::m_ObjctNum to be size 2");
static_assert(sizeof(HrMainMissionFax::m_Counter) == 10, "expected HrMainMissionFax::m_Counter to be size 10");
static_assert(sizeof(HrMainMissionFax::m_MekuriCounter) == 2, "expected HrMainMissionFax::m_MekuriCounter to be size 2");
static_assert(sizeof(HrMainMissionFax::m_Handl) == 4, "expected HrMainMissionFax::m_Handl to be size 4");
static_assert(sizeof(HrMainMissionFax::m_Index) == 4, "expected HrMainMissionFax::m_Index to be size 4");
static_assert(sizeof(HrMainMissionFax::m_NowLine) == 8, "expected HrMainMissionFax::m_NowLine to be size 8");
static_assert(sizeof(HrMainMissionFax::m_NowSentence) == 4, "expected HrMainMissionFax::m_NowSentence to be size 4");
static_assert(sizeof(HrMainMissionFax::m_NowWord) == 2, "expected HrMainMissionFax::m_NowWord to be size 2");
static_assert(sizeof(HrMainMissionFax::m_Fax_End_f) == 1, "expected HrMainMissionFax::m_Fax_End_f to be size 1");
static_assert(sizeof(HrMainMissionFax) == 0x8c, "expected HrMainMissionFax to be size 0x8c");

// [Function] uint8_t __convention("thiscall") j_sub_792010(class CBgCtrl* const this) [j_sub_792010]
typedef uint8_t(__thiscall* _j_sub_792010)(class CBgCtrl* const thisPtr);
uint8_t j_sub_792010(class CBgCtrl* const thisPtr)
{
	_j_sub_792010 mFunc = (_j_sub_792010)(GameModule + 0x392620);
	return mFunc(thisPtr);
}
// Unsupported destructor
//void __convention("thiscall") CBgCtrl::~CBgCtrl(class CBgCtrl* const this)
// Unsupported constructor
//void __convention("thiscall") CBgCtrl::CBgCtrl(class CBgCtrl* const this)
// [Structure] class CCameraVibManager
class CCameraVibManager
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[576];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraVibManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraVibManager& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraVibManager>("CCameraVibManager")
			.addFunction("__tostring", &CCameraVibManager::ToString)
			.addFunction("GetPtrAddr", &CCameraVibManager::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraVibManager) == 0x240, "expected CCameraVibManager to be size 0x240");

// [Structure] class CCameraBank
class CCameraBank
{
public:
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inOfst, offset 0x0>
	class CDoubleSpringInterpolate m_inOfst;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraBank [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraBank& InObject)
	{
		m_inOfst = InObject.m_inOfst;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraBank>("CCameraBank")
			.addFunction("__tostring", &CCameraBank::ToString)
			.addFunction("GetPtrAddr", &CCameraBank::GetPtrAddr)
			.addProperty("m_inOfst", &CCameraBank::m_inOfst)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraBank::m_inOfst) == 48, "expected CCameraBank::m_inOfst to be size 48");
static_assert(sizeof(CCameraBank) == 0x30, "expected CCameraBank to be size 0x30");

// [Structure] class CCameraModeSubjective
class CCameraModeSubjective : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <float m_fTimer, offset 0x14>
	float m_fTimer = 0;

	// <float m_fDisappearTimer, offset 0x18>
	float m_fDisappearTimer = 0;

	// <Unidentified data segment, offset 0x1c>
private:
	char _UnidentifiedData_28[4];

public:
	// <class tiVector m_inSrcLookAtPosi, offset 0x20>
	class tiVector m_inSrcLookAtPosi;

	// <class tiVector m_inInterpLookAtPosi, offset 0x30>
	class tiVector m_inInterpLookAtPosi;

	// <float m_fSrcDistToLookAt, offset 0x40>
	float m_fSrcDistToLookAt = 0;

	// <float m_fInterpDistToLookAt, offset 0x44>
	float m_fInterpDistToLookAt = 0;

	// <float m_fSrcYaw, offset 0x48>
	float m_fSrcYaw = 0;

	// <float m_fInterpYaw, offset 0x4c>
	float m_fInterpYaw = 0;

	// <float m_fPitch, offset 0x50>
	float m_fPitch = 0;

	// <Unidentified data segment, offset 0x54>
private:
	char _UnidentifiedData_84[12];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModeSubjective [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModeSubjective& InObject)
	{
		m_fTimer = InObject.m_fTimer;
		m_fDisappearTimer = InObject.m_fDisappearTimer;
		m_inSrcLookAtPosi = InObject.m_inSrcLookAtPosi;
		m_inInterpLookAtPosi = InObject.m_inInterpLookAtPosi;
		m_fSrcDistToLookAt = InObject.m_fSrcDistToLookAt;
		m_fInterpDistToLookAt = InObject.m_fInterpDistToLookAt;
		m_fSrcYaw = InObject.m_fSrcYaw;
		m_fInterpYaw = InObject.m_fInterpYaw;
		m_fPitch = InObject.m_fPitch;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeSubjective, ACameraModeBase>("CCameraModeSubjective")
			.addFunction("__tostring", &CCameraModeSubjective::ToString)
			.addFunction("GetPtrAddr", &CCameraModeSubjective::GetPtrAddr)
			.addProperty("m_fTimer", &CCameraModeSubjective::m_fTimer)
			.addProperty("m_fDisappearTimer", &CCameraModeSubjective::m_fDisappearTimer)
			.addProperty("m_inSrcLookAtPosi", &CCameraModeSubjective::m_inSrcLookAtPosi)
			.addProperty("m_inInterpLookAtPosi", &CCameraModeSubjective::m_inInterpLookAtPosi)
			.addProperty("m_fSrcDistToLookAt", &CCameraModeSubjective::m_fSrcDistToLookAt)
			.addProperty("m_fInterpDistToLookAt", &CCameraModeSubjective::m_fInterpDistToLookAt)
			.addProperty("m_fSrcYaw", &CCameraModeSubjective::m_fSrcYaw)
			.addProperty("m_fInterpYaw", &CCameraModeSubjective::m_fInterpYaw)
			.addProperty("m_fPitch", &CCameraModeSubjective::m_fPitch)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeSubjective::m_fTimer) == 4, "expected CCameraModeSubjective::m_fTimer to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fDisappearTimer) == 4, "expected CCameraModeSubjective::m_fDisappearTimer to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_inSrcLookAtPosi) == 16, "expected CCameraModeSubjective::m_inSrcLookAtPosi to be size 16");
static_assert(sizeof(CCameraModeSubjective::m_inInterpLookAtPosi) == 16, "expected CCameraModeSubjective::m_inInterpLookAtPosi to be size 16");
static_assert(sizeof(CCameraModeSubjective::m_fSrcDistToLookAt) == 4, "expected CCameraModeSubjective::m_fSrcDistToLookAt to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fInterpDistToLookAt) == 4, "expected CCameraModeSubjective::m_fInterpDistToLookAt to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fSrcYaw) == 4, "expected CCameraModeSubjective::m_fSrcYaw to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fInterpYaw) == 4, "expected CCameraModeSubjective::m_fInterpYaw to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fPitch) == 4, "expected CCameraModeSubjective::m_fPitch to be size 4");
static_assert(sizeof(CCameraModeSubjective) == 0x60, "expected CCameraModeSubjective to be size 0x60");

// [Structure] class CCameraModePetitMovie
class CCameraModePetitMovie : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData_20[12];

public:
	// <class CDoubleSpringInterpolate3D m_inAngle, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAngle;

	// <uint8_t m_bAct, offset 0x80>
	uint8_t m_bAct = 0;

	// <Unidentified data segment, offset 0x81>
private:
	char _UnidentifiedData_129[3];

public:
	// <float m_fLookAtOfstX, offset 0x84>
	float m_fLookAtOfstX = 0;

	// <float m_fLookAtOfstY, offset 0x88>
	float m_fLookAtOfstY = 0;

	// <float m_fDistToLookAt, offset 0x8c>
	float m_fDistToLookAt = 0;

	// <float m_fYawOfst, offset 0x90>
	float m_fYawOfst = 0;

	// <float m_fPitchOfst, offset 0x94>
	float m_fPitchOfst = 0;

	// <Unidentified data segment, offset 0x98>
private:
	char _UnidentifiedData_152[8];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModePetitMovie [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModePetitMovie& InObject)
	{
		m_inAngle = InObject.m_inAngle;
		m_bAct = InObject.m_bAct;
		m_fLookAtOfstX = InObject.m_fLookAtOfstX;
		m_fLookAtOfstY = InObject.m_fLookAtOfstY;
		m_fDistToLookAt = InObject.m_fDistToLookAt;
		m_fYawOfst = InObject.m_fYawOfst;
		m_fPitchOfst = InObject.m_fPitchOfst;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModePetitMovie, ACameraModeBase>("CCameraModePetitMovie")
			.addFunction("__tostring", &CCameraModePetitMovie::ToString)
			.addFunction("GetPtrAddr", &CCameraModePetitMovie::GetPtrAddr)
			.addProperty("m_inAngle", &CCameraModePetitMovie::m_inAngle)
			.addProperty("m_bAct", &CCameraModePetitMovie::m_bAct)
			.addProperty("m_fLookAtOfstX", &CCameraModePetitMovie::m_fLookAtOfstX)
			.addProperty("m_fLookAtOfstY", &CCameraModePetitMovie::m_fLookAtOfstY)
			.addProperty("m_fDistToLookAt", &CCameraModePetitMovie::m_fDistToLookAt)
			.addProperty("m_fYawOfst", &CCameraModePetitMovie::m_fYawOfst)
			.addProperty("m_fPitchOfst", &CCameraModePetitMovie::m_fPitchOfst)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModePetitMovie::m_inAngle) == 96, "expected CCameraModePetitMovie::m_inAngle to be size 96");
static_assert(sizeof(CCameraModePetitMovie::m_bAct) == 1, "expected CCameraModePetitMovie::m_bAct to be size 1");
static_assert(sizeof(CCameraModePetitMovie::m_fLookAtOfstX) == 4, "expected CCameraModePetitMovie::m_fLookAtOfstX to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fLookAtOfstY) == 4, "expected CCameraModePetitMovie::m_fLookAtOfstY to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fDistToLookAt) == 4, "expected CCameraModePetitMovie::m_fDistToLookAt to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fYawOfst) == 4, "expected CCameraModePetitMovie::m_fYawOfst to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fPitchOfst) == 4, "expected CCameraModePetitMovie::m_fPitchOfst to be size 4");
static_assert(sizeof(CCameraModePetitMovie) == 0xa0, "expected CCameraModePetitMovie to be size 0xa0");

// [Structure] class CCameraModeCircle
class CCameraModeCircle : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <uint8_t m_bIsPlusRot, offset 0x14>
	uint8_t m_bIsPlusRot = 0;

	// <Unidentified data segment, offset 0x15>
private:
	char _UnidentifiedData_21[3];

public:
	// <float m_fRotVel, offset 0x18>
	float m_fRotVel = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModeCircle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModeCircle& InObject)
	{
		m_bIsPlusRot = InObject.m_bIsPlusRot;
		m_fRotVel = InObject.m_fRotVel;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeCircle, ACameraModeBase>("CCameraModeCircle")
			.addFunction("__tostring", &CCameraModeCircle::ToString)
			.addFunction("GetPtrAddr", &CCameraModeCircle::GetPtrAddr)
			.addProperty("m_bIsPlusRot", &CCameraModeCircle::m_bIsPlusRot)
			.addProperty("m_fRotVel", &CCameraModeCircle::m_fRotVel)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeCircle::m_bIsPlusRot) == 1, "expected CCameraModeCircle::m_bIsPlusRot to be size 1");
static_assert(sizeof(CCameraModeCircle::m_fRotVel) == 4, "expected CCameraModeCircle::m_fRotVel to be size 4");
static_assert(sizeof(CCameraModeCircle) == 0x1c, "expected CCameraModeCircle to be size 0x1c");

// [Structure] class CCameraModeDefaultAngle
class CCameraModeDefaultAngle : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData_20[12];

public:
	// <class CDoubleSpringInterpolate3D m_inAngle, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAngle;

	// <class tiVector m_inHopeAngle, offset 0x80>
	class tiVector m_inHopeAngle;

	// <uint8_t m_bIsInputButton, offset 0x90>
	uint8_t m_bIsInputButton = 0;

	// <Unidentified data segment, offset 0x91>
private:
	char _UnidentifiedData_145[15];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModeDefaultAngle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModeDefaultAngle& InObject)
	{
		m_inAngle = InObject.m_inAngle;
		m_inHopeAngle = InObject.m_inHopeAngle;
		m_bIsInputButton = InObject.m_bIsInputButton;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeDefaultAngle, ACameraModeBase>("CCameraModeDefaultAngle")
			.addFunction("__tostring", &CCameraModeDefaultAngle::ToString)
			.addFunction("GetPtrAddr", &CCameraModeDefaultAngle::GetPtrAddr)
			.addProperty("m_inAngle", &CCameraModeDefaultAngle::m_inAngle)
			.addProperty("m_inHopeAngle", &CCameraModeDefaultAngle::m_inHopeAngle)
			.addProperty("m_bIsInputButton", &CCameraModeDefaultAngle::m_bIsInputButton)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeDefaultAngle::m_inAngle) == 96, "expected CCameraModeDefaultAngle::m_inAngle to be size 96");
static_assert(sizeof(CCameraModeDefaultAngle::m_inHopeAngle) == 16, "expected CCameraModeDefaultAngle::m_inHopeAngle to be size 16");
static_assert(sizeof(CCameraModeDefaultAngle::m_bIsInputButton) == 1, "expected CCameraModeDefaultAngle::m_bIsInputButton to be size 1");
static_assert(sizeof(CCameraModeDefaultAngle) == 0xa0, "expected CCameraModeDefaultAngle to be size 0xa0");

// [Structure] class CCameraModeFree
class CCameraModeFree : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <float m_fInputYaw, offset 0x14>
	float m_fInputYaw = 0;

	// <float m_fInputPitch, offset 0x18>
	float m_fInputPitch = 0;

	// <float m_fKeepTimer, offset 0x1c>
	float m_fKeepTimer = 0;

	// <class CDoubleSpringInterpolate3D m_inAddYP, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAddYP;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModeFree [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModeFree& InObject)
	{
		m_fInputYaw = InObject.m_fInputYaw;
		m_fInputPitch = InObject.m_fInputPitch;
		m_fKeepTimer = InObject.m_fKeepTimer;
		m_inAddYP = InObject.m_inAddYP;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeFree, ACameraModeBase>("CCameraModeFree")
			.addFunction("__tostring", &CCameraModeFree::ToString)
			.addFunction("GetPtrAddr", &CCameraModeFree::GetPtrAddr)
			.addProperty("m_fInputYaw", &CCameraModeFree::m_fInputYaw)
			.addProperty("m_fInputPitch", &CCameraModeFree::m_fInputPitch)
			.addProperty("m_fKeepTimer", &CCameraModeFree::m_fKeepTimer)
			.addProperty("m_inAddYP", &CCameraModeFree::m_inAddYP)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeFree::m_fInputYaw) == 4, "expected CCameraModeFree::m_fInputYaw to be size 4");
static_assert(sizeof(CCameraModeFree::m_fInputPitch) == 4, "expected CCameraModeFree::m_fInputPitch to be size 4");
static_assert(sizeof(CCameraModeFree::m_fKeepTimer) == 4, "expected CCameraModeFree::m_fKeepTimer to be size 4");
static_assert(sizeof(CCameraModeFree::m_inAddYP) == 96, "expected CCameraModeFree::m_inAddYP to be size 96");
static_assert(sizeof(CCameraModeFree) == 0x80, "expected CCameraModeFree to be size 0x80");

// [Structure] class CCameraModeNormal
class CCameraModeNormal : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <class CDoubleSpringInterpolate m_inYaw, offset 0x14>
	class CDoubleSpringInterpolate m_inYaw;

	// <class CDoubleSpringInterpolate m_inPitch, offset 0x44>
	class CDoubleSpringInterpolate m_inPitch;

	// <float m_fHopeYaw, offset 0x74>
	float m_fHopeYaw = 0;

	// <class CTimeRatioInterpolate m_inYawRatio, offset 0x78>
	class CTimeRatioInterpolate m_inYawRatio;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModeNormal [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModeNormal& InObject)
	{
		m_inYaw = InObject.m_inYaw;
		m_inPitch = InObject.m_inPitch;
		m_fHopeYaw = InObject.m_fHopeYaw;
		m_inYawRatio = InObject.m_inYawRatio;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeNormal, ACameraModeBase>("CCameraModeNormal")
			.addFunction("__tostring", &CCameraModeNormal::ToString)
			.addFunction("GetPtrAddr", &CCameraModeNormal::GetPtrAddr)
			.addProperty("m_inYaw", &CCameraModeNormal::m_inYaw)
			.addProperty("m_inPitch", &CCameraModeNormal::m_inPitch)
			.addProperty("m_fHopeYaw", &CCameraModeNormal::m_fHopeYaw)
			.addProperty("m_inYawRatio", &CCameraModeNormal::m_inYawRatio)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeNormal::m_inYaw) == 48, "expected CCameraModeNormal::m_inYaw to be size 48");
static_assert(sizeof(CCameraModeNormal::m_inPitch) == 48, "expected CCameraModeNormal::m_inPitch to be size 48");
static_assert(sizeof(CCameraModeNormal::m_fHopeYaw) == 4, "expected CCameraModeNormal::m_fHopeYaw to be size 4");
static_assert(sizeof(CCameraModeNormal::m_inYawRatio) == 12, "expected CCameraModeNormal::m_inYawRatio to be size 12");
static_assert(sizeof(CCameraModeNormal) == 0x84, "expected CCameraModeNormal to be size 0x84");

// [Structure] class CCameraModeReset
class CCameraModeReset : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <uint8_t m_bIsSetResetYaw, offset 0x14>
	uint8_t m_bIsSetResetYaw = 0;

	// <Unidentified data segment, offset 0x15>
private:
	char _UnidentifiedData_21[3];

public:
	// <float m_fResetYaw, offset 0x18>
	float m_fResetYaw = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModeReset [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModeReset& InObject)
	{
		m_bIsSetResetYaw = InObject.m_bIsSetResetYaw;
		m_fResetYaw = InObject.m_fResetYaw;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeReset, ACameraModeBase>("CCameraModeReset")
			.addFunction("__tostring", &CCameraModeReset::ToString)
			.addFunction("GetPtrAddr", &CCameraModeReset::GetPtrAddr)
			.addProperty("m_bIsSetResetYaw", &CCameraModeReset::m_bIsSetResetYaw)
			.addProperty("m_fResetYaw", &CCameraModeReset::m_fResetYaw)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeReset::m_bIsSetResetYaw) == 1, "expected CCameraModeReset::m_bIsSetResetYaw to be size 1");
static_assert(sizeof(CCameraModeReset::m_fResetYaw) == 4, "expected CCameraModeReset::m_fResetYaw to be size 4");
static_assert(sizeof(CCameraModeReset) == 0x1c, "expected CCameraModeReset to be size 0x1c");

// [Structure] class CCameraDistToLookAt
class CCameraDistToLookAt
{
public:
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inDistToLookAt, offset 0x0>
	class CDoubleSpringInterpolate m_inDistToLookAt;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraDistToLookAt [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraDistToLookAt& InObject)
	{
		m_inDistToLookAt = InObject.m_inDistToLookAt;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDistToLookAt>("CCameraDistToLookAt")
			.addFunction("__tostring", &CCameraDistToLookAt::ToString)
			.addFunction("GetPtrAddr", &CCameraDistToLookAt::GetPtrAddr)
			.addProperty("m_inDistToLookAt", &CCameraDistToLookAt::m_inDistToLookAt)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDistToLookAt::m_inDistToLookAt) == 48, "expected CCameraDistToLookAt::m_inDistToLookAt to be size 48");
static_assert(sizeof(CCameraDistToLookAt) == 0x30, "expected CCameraDistToLookAt to be size 0x30");

// [Structure] class CCameraFollowRot
class CCameraFollowRot
{
public:
	/// Struct member variables

	// <class CDoubleSpringInterpolate3D m_inMove, offset 0x0>
	class CDoubleSpringInterpolate3D m_inMove;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraFollowRot [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraFollowRot& InObject)
	{
		m_inMove = InObject.m_inMove;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraFollowRot>("CCameraFollowRot")
			.addFunction("__tostring", &CCameraFollowRot::ToString)
			.addFunction("GetPtrAddr", &CCameraFollowRot::GetPtrAddr)
			.addProperty("m_inMove", &CCameraFollowRot::m_inMove)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraFollowRot::m_inMove) == 96, "expected CCameraFollowRot::m_inMove to be size 96");
static_assert(sizeof(CCameraFollowRot) == 0x60, "expected CCameraFollowRot to be size 0x60");

// [Structure] class CCameraLookAtOffset
class CCameraLookAtOffset
{
public:
	/// Struct member variables

	// <class CTimeRatioInterpolate m_inInterpCoeRatio, offset 0x0>
	class CTimeRatioInterpolate m_inInterpCoeRatio;

	// <Unidentified data segment, offset 0xc>
private:
	char _UnidentifiedData_12[4];

public:
	// <class CDoubleSpringInterpolate3D m_inLocalOfst, offset 0x10>
	class CDoubleSpringInterpolate3D m_inLocalOfst;

	// <class tiVector m_inHopeLocalOfst, offset 0x70>
	class tiVector m_inHopeLocalOfst;

	// <float m_fOfstXTimer, offset 0x80>
	float m_fOfstXTimer = 0;

	// <uint8_t m_bIsOfstRayHit, offset 0x84>
	uint8_t m_bIsOfstRayHit = 0;

	// <Unidentified data segment, offset 0x85>
private:
	char _UnidentifiedData_133[3];

public:
	// <float m_fOfstRayHitTimer, offset 0x88>
	float m_fOfstRayHitTimer = 0;

	// <float m_fOfstRayHitOfstX, offset 0x8c>
	float m_fOfstRayHitOfstX = 0;

	// <class tiVector m_inCamAxisX, offset 0x90>
	class tiVector m_inCamAxisX;

	// <class tiVector m_inCamAxisY, offset 0xa0>
	class tiVector m_inCamAxisY;

	// <class tiVector m_inCamAxisZ, offset 0xb0>
	class tiVector m_inCamAxisZ;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraLookAtOffset [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraLookAtOffset& InObject)
	{
		m_inInterpCoeRatio = InObject.m_inInterpCoeRatio;
		m_inLocalOfst = InObject.m_inLocalOfst;
		m_inHopeLocalOfst = InObject.m_inHopeLocalOfst;
		m_fOfstXTimer = InObject.m_fOfstXTimer;
		m_bIsOfstRayHit = InObject.m_bIsOfstRayHit;
		m_fOfstRayHitTimer = InObject.m_fOfstRayHitTimer;
		m_fOfstRayHitOfstX = InObject.m_fOfstRayHitOfstX;
		m_inCamAxisX = InObject.m_inCamAxisX;
		m_inCamAxisY = InObject.m_inCamAxisY;
		m_inCamAxisZ = InObject.m_inCamAxisZ;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLookAtOffset>("CCameraLookAtOffset")
			.addFunction("__tostring", &CCameraLookAtOffset::ToString)
			.addFunction("GetPtrAddr", &CCameraLookAtOffset::GetPtrAddr)
			.addProperty("m_inInterpCoeRatio", &CCameraLookAtOffset::m_inInterpCoeRatio)
			.addProperty("m_inLocalOfst", &CCameraLookAtOffset::m_inLocalOfst)
			.addProperty("m_inHopeLocalOfst", &CCameraLookAtOffset::m_inHopeLocalOfst)
			.addProperty("m_fOfstXTimer", &CCameraLookAtOffset::m_fOfstXTimer)
			.addProperty("m_bIsOfstRayHit", &CCameraLookAtOffset::m_bIsOfstRayHit)
			.addProperty("m_fOfstRayHitTimer", &CCameraLookAtOffset::m_fOfstRayHitTimer)
			.addProperty("m_fOfstRayHitOfstX", &CCameraLookAtOffset::m_fOfstRayHitOfstX)
			.addProperty("m_inCamAxisX", &CCameraLookAtOffset::m_inCamAxisX)
			.addProperty("m_inCamAxisY", &CCameraLookAtOffset::m_inCamAxisY)
			.addProperty("m_inCamAxisZ", &CCameraLookAtOffset::m_inCamAxisZ)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLookAtOffset::m_inInterpCoeRatio) == 12, "expected CCameraLookAtOffset::m_inInterpCoeRatio to be size 12");
static_assert(sizeof(CCameraLookAtOffset::m_inLocalOfst) == 96, "expected CCameraLookAtOffset::m_inLocalOfst to be size 96");
static_assert(sizeof(CCameraLookAtOffset::m_inHopeLocalOfst) == 16, "expected CCameraLookAtOffset::m_inHopeLocalOfst to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstXTimer) == 4, "expected CCameraLookAtOffset::m_fOfstXTimer to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_bIsOfstRayHit) == 1, "expected CCameraLookAtOffset::m_bIsOfstRayHit to be size 1");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstRayHitTimer) == 4, "expected CCameraLookAtOffset::m_fOfstRayHitTimer to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstRayHitOfstX) == 4, "expected CCameraLookAtOffset::m_fOfstRayHitOfstX to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisX) == 16, "expected CCameraLookAtOffset::m_inCamAxisX to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisY) == 16, "expected CCameraLookAtOffset::m_inCamAxisY to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisZ) == 16, "expected CCameraLookAtOffset::m_inCamAxisZ to be size 16");
static_assert(sizeof(CCameraLookAtOffset) == 0xc0, "expected CCameraLookAtOffset to be size 0xc0");

// [Structure] class CCameraLookAtBase
class CCameraLookAtBase
{
public:
	/// Struct member variables

	// <class tiVector m_inPosi, offset 0x0>
	class tiVector m_inPosi;

	// <class tiVector m_inPrePosi, offset 0x10>
	class tiVector m_inPrePosi;

	// <class tiVector m_inPreHopePosi, offset 0x20>
	class tiVector m_inPreHopePosi;

	// <class CDoubleSpringInterpolate3D m_inSpringCoe, offset 0x30>
	class CDoubleSpringInterpolate3D m_inSpringCoe;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraLookAtBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraLookAtBase& InObject)
	{
		m_inPosi = InObject.m_inPosi;
		m_inPrePosi = InObject.m_inPrePosi;
		m_inPreHopePosi = InObject.m_inPreHopePosi;
		m_inSpringCoe = InObject.m_inSpringCoe;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLookAtBase>("CCameraLookAtBase")
			.addFunction("__tostring", &CCameraLookAtBase::ToString)
			.addFunction("GetPtrAddr", &CCameraLookAtBase::GetPtrAddr)
			.addProperty("m_inPosi", &CCameraLookAtBase::m_inPosi)
			.addProperty("m_inPrePosi", &CCameraLookAtBase::m_inPrePosi)
			.addProperty("m_inPreHopePosi", &CCameraLookAtBase::m_inPreHopePosi)
			.addProperty("m_inSpringCoe", &CCameraLookAtBase::m_inSpringCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLookAtBase::m_inPosi) == 16, "expected CCameraLookAtBase::m_inPosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inPrePosi) == 16, "expected CCameraLookAtBase::m_inPrePosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inPreHopePosi) == 16, "expected CCameraLookAtBase::m_inPreHopePosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inSpringCoe) == 96, "expected CCameraLookAtBase::m_inSpringCoe to be size 96");
static_assert(sizeof(CCameraLookAtBase) == 0x90, "expected CCameraLookAtBase to be size 0x90");

// [Structure] class CCameraDefaultAngle
class CCameraDefaultAngle
{
public:
	/// Struct member variables

	// <class tiVector m_inDefaultYP, offset 0x0>
	class tiVector m_inDefaultYP;

	// <uint8_t m_bActYawRot, offset 0x10>
	uint8_t m_bActYawRot = 0;

	// <uint8_t m_bIsDownAttackPitchUp, offset 0x11>
	uint8_t m_bIsDownAttackPitchUp = 0;

	// <Unidentified data segment, offset 0x12>
private:
	char _UnidentifiedData_18[2];

public:
	// <float m_fSlopeCheckDelayTimer, offset 0x14>
	float m_fSlopeCheckDelayTimer = 0;

	// <float m_fSlopeCheckPitchOfst, offset 0x18>
	float m_fSlopeCheckPitchOfst = 0;

	// <int32_t m_nSlopeCheckPhase, offset 0x1c>
	int32_t m_nSlopeCheckPhase = 0;

	// <class tiVector m_inSlopeCheckPosi, offset 0x20>
	class tiVector m_inSlopeCheckPosi;

	// <float m_fSlopeCheckYaw, offset 0x30>
	float m_fSlopeCheckYaw = 0;

	// <Unidentified data segment, offset 0x34>
private:
	char _UnidentifiedData_52[12];

public:
	// <class tiVector m_inSlopeCheckDir, offset 0x40>
	class tiVector m_inSlopeCheckDir;

	// <class tiVector m_inSlopeCheckTopPosi, offset 0x50>
	class tiVector m_inSlopeCheckTopPosi;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraDefaultAngle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraDefaultAngle& InObject)
	{
		m_inDefaultYP = InObject.m_inDefaultYP;
		m_bActYawRot = InObject.m_bActYawRot;
		m_bIsDownAttackPitchUp = InObject.m_bIsDownAttackPitchUp;
		m_fSlopeCheckDelayTimer = InObject.m_fSlopeCheckDelayTimer;
		m_fSlopeCheckPitchOfst = InObject.m_fSlopeCheckPitchOfst;
		m_nSlopeCheckPhase = InObject.m_nSlopeCheckPhase;
		m_inSlopeCheckPosi = InObject.m_inSlopeCheckPosi;
		m_fSlopeCheckYaw = InObject.m_fSlopeCheckYaw;
		m_inSlopeCheckDir = InObject.m_inSlopeCheckDir;
		m_inSlopeCheckTopPosi = InObject.m_inSlopeCheckTopPosi;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDefaultAngle>("CCameraDefaultAngle")
			.addFunction("__tostring", &CCameraDefaultAngle::ToString)
			.addFunction("GetPtrAddr", &CCameraDefaultAngle::GetPtrAddr)
			.addProperty("m_inDefaultYP", &CCameraDefaultAngle::m_inDefaultYP)
			.addProperty("m_bActYawRot", &CCameraDefaultAngle::m_bActYawRot)
			.addProperty("m_bIsDownAttackPitchUp", &CCameraDefaultAngle::m_bIsDownAttackPitchUp)
			.addProperty("m_fSlopeCheckDelayTimer", &CCameraDefaultAngle::m_fSlopeCheckDelayTimer)
			.addProperty("m_fSlopeCheckPitchOfst", &CCameraDefaultAngle::m_fSlopeCheckPitchOfst)
			.addProperty("m_nSlopeCheckPhase", &CCameraDefaultAngle::m_nSlopeCheckPhase)
			.addProperty("m_inSlopeCheckPosi", &CCameraDefaultAngle::m_inSlopeCheckPosi)
			.addProperty("m_fSlopeCheckYaw", &CCameraDefaultAngle::m_fSlopeCheckYaw)
			.addProperty("m_inSlopeCheckDir", &CCameraDefaultAngle::m_inSlopeCheckDir)
			.addProperty("m_inSlopeCheckTopPosi", &CCameraDefaultAngle::m_inSlopeCheckTopPosi)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDefaultAngle::m_inDefaultYP) == 16, "expected CCameraDefaultAngle::m_inDefaultYP to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_bActYawRot) == 1, "expected CCameraDefaultAngle::m_bActYawRot to be size 1");
static_assert(sizeof(CCameraDefaultAngle::m_bIsDownAttackPitchUp) == 1, "expected CCameraDefaultAngle::m_bIsDownAttackPitchUp to be size 1");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckDelayTimer) == 4, "expected CCameraDefaultAngle::m_fSlopeCheckDelayTimer to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckPitchOfst) == 4, "expected CCameraDefaultAngle::m_fSlopeCheckPitchOfst to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_nSlopeCheckPhase) == 4, "expected CCameraDefaultAngle::m_nSlopeCheckPhase to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckPosi) == 16, "expected CCameraDefaultAngle::m_inSlopeCheckPosi to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckYaw) == 4, "expected CCameraDefaultAngle::m_fSlopeCheckYaw to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckDir) == 16, "expected CCameraDefaultAngle::m_inSlopeCheckDir to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckTopPosi) == 16, "expected CCameraDefaultAngle::m_inSlopeCheckTopPosi to be size 16");
static_assert(sizeof(CCameraDefaultAngle) == 0x60, "expected CCameraDefaultAngle to be size 0x60");

// [Structure] class CCameraLockOnModeData
class CCameraLockOnModeData
{
public:
	/// Struct member variables

	// <float m_fLookAtOfstMinX, offset 0x0>
	float m_fLookAtOfstMinX = 0;

	// <float m_fLookAtOfstRatioX, offset 0x4>
	float m_fLookAtOfstRatioX = 0;

	// <float m_fLookAtOfstMinY, offset 0x8>
	float m_fLookAtOfstMinY = 0;

	// <float m_fLookAtOfstRatioY, offset 0xc>
	float m_fLookAtOfstRatioY = 0;

	// <float m_fYawOfstMin, offset 0x10>
	float m_fYawOfstMin = 0;

	// <float m_fYawOfstMax, offset 0x14>
	float m_fYawOfstMax = 0;

	// <float m_fPitchMax, offset 0x18>
	float m_fPitchMax = 0;

	// <float m_fPitchMin, offset 0x1c>
	float m_fPitchMin = 0;

	// <float m_fDistToLookAtMin, offset 0x20>
	float m_fDistToLookAtMin = 0;

	// <float m_fDistToLookAtMax, offset 0x24>
	float m_fDistToLookAtMax = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraLockOnModeData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraLockOnModeData& InObject)
	{
		m_fLookAtOfstMinX = InObject.m_fLookAtOfstMinX;
		m_fLookAtOfstRatioX = InObject.m_fLookAtOfstRatioX;
		m_fLookAtOfstMinY = InObject.m_fLookAtOfstMinY;
		m_fLookAtOfstRatioY = InObject.m_fLookAtOfstRatioY;
		m_fYawOfstMin = InObject.m_fYawOfstMin;
		m_fYawOfstMax = InObject.m_fYawOfstMax;
		m_fPitchMax = InObject.m_fPitchMax;
		m_fPitchMin = InObject.m_fPitchMin;
		m_fDistToLookAtMin = InObject.m_fDistToLookAtMin;
		m_fDistToLookAtMax = InObject.m_fDistToLookAtMax;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLockOnModeData>("CCameraLockOnModeData")
			.addFunction("__tostring", &CCameraLockOnModeData::ToString)
			.addFunction("GetPtrAddr", &CCameraLockOnModeData::GetPtrAddr)
			.addProperty("m_fLookAtOfstMinX", &CCameraLockOnModeData::m_fLookAtOfstMinX)
			.addProperty("m_fLookAtOfstRatioX", &CCameraLockOnModeData::m_fLookAtOfstRatioX)
			.addProperty("m_fLookAtOfstMinY", &CCameraLockOnModeData::m_fLookAtOfstMinY)
			.addProperty("m_fLookAtOfstRatioY", &CCameraLockOnModeData::m_fLookAtOfstRatioY)
			.addProperty("m_fYawOfstMin", &CCameraLockOnModeData::m_fYawOfstMin)
			.addProperty("m_fYawOfstMax", &CCameraLockOnModeData::m_fYawOfstMax)
			.addProperty("m_fPitchMax", &CCameraLockOnModeData::m_fPitchMax)
			.addProperty("m_fPitchMin", &CCameraLockOnModeData::m_fPitchMin)
			.addProperty("m_fDistToLookAtMin", &CCameraLockOnModeData::m_fDistToLookAtMin)
			.addProperty("m_fDistToLookAtMax", &CCameraLockOnModeData::m_fDistToLookAtMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstMinX) == 4, "expected CCameraLockOnModeData::m_fLookAtOfstMinX to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstRatioX) == 4, "expected CCameraLockOnModeData::m_fLookAtOfstRatioX to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstMinY) == 4, "expected CCameraLockOnModeData::m_fLookAtOfstMinY to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstRatioY) == 4, "expected CCameraLockOnModeData::m_fLookAtOfstRatioY to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fYawOfstMin) == 4, "expected CCameraLockOnModeData::m_fYawOfstMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fYawOfstMax) == 4, "expected CCameraLockOnModeData::m_fYawOfstMax to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fPitchMax) == 4, "expected CCameraLockOnModeData::m_fPitchMax to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fPitchMin) == 4, "expected CCameraLockOnModeData::m_fPitchMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fDistToLookAtMin) == 4, "expected CCameraLockOnModeData::m_fDistToLookAtMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fDistToLookAtMax) == 4, "expected CCameraLockOnModeData::m_fDistToLookAtMax to be size 4");
static_assert(sizeof(CCameraLockOnModeData) == 0x28, "expected CCameraLockOnModeData to be size 0x28");

// [Structure] class CCameraNormalModeData
class CCameraNormalModeData
{
public:
	/// Struct member variables

	// <float m_fFollowRotCoe, offset 0x0>
	float m_fFollowRotCoe = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraNormalModeData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraNormalModeData& InObject)
	{
		m_fFollowRotCoe = InObject.m_fFollowRotCoe;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraNormalModeData>("CCameraNormalModeData")
			.addFunction("__tostring", &CCameraNormalModeData::ToString)
			.addFunction("GetPtrAddr", &CCameraNormalModeData::GetPtrAddr)
			.addProperty("m_fFollowRotCoe", &CCameraNormalModeData::m_fFollowRotCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraNormalModeData::m_fFollowRotCoe) == 4, "expected CCameraNormalModeData::m_fFollowRotCoe to be size 4");
static_assert(sizeof(CCameraNormalModeData) == 0x4, "expected CCameraNormalModeData to be size 0x4");

// [Structure] class CCameraModeCommonData
class CCameraModeCommonData
{
public:
	/// Struct member variables

	// <float m_fLookAtOfstMinX, offset 0x0>
	float m_fLookAtOfstMinX = 0;

	// <float m_fLookAtOfstRatioX, offset 0x4>
	float m_fLookAtOfstRatioX = 0;

	// <float m_fLookAtOfstMinY, offset 0x8>
	float m_fLookAtOfstMinY = 0;

	// <float m_fLookAtOfstRatioY, offset 0xc>
	float m_fLookAtOfstRatioY = 0;

	// <float m_fLookAtOfstYDistZero, offset 0x10>
	float m_fLookAtOfstYDistZero = 0;

	// <float m_fDefaultPitchOfst, offset 0x14>
	float m_fDefaultPitchOfst = 0;

	// <int32_t m_bIsAddSlopePitchOfst, offset 0x18>
	int32_t m_bIsAddSlopePitchOfst = 0;

	// <float m_fDistToLookAt, offset 0x1c>
	float m_fDistToLookAt = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraModeCommonData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraModeCommonData& InObject)
	{
		m_fLookAtOfstMinX = InObject.m_fLookAtOfstMinX;
		m_fLookAtOfstRatioX = InObject.m_fLookAtOfstRatioX;
		m_fLookAtOfstMinY = InObject.m_fLookAtOfstMinY;
		m_fLookAtOfstRatioY = InObject.m_fLookAtOfstRatioY;
		m_fLookAtOfstYDistZero = InObject.m_fLookAtOfstYDistZero;
		m_fDefaultPitchOfst = InObject.m_fDefaultPitchOfst;
		m_bIsAddSlopePitchOfst = InObject.m_bIsAddSlopePitchOfst;
		m_fDistToLookAt = InObject.m_fDistToLookAt;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeCommonData>("CCameraModeCommonData")
			.addFunction("__tostring", &CCameraModeCommonData::ToString)
			.addFunction("GetPtrAddr", &CCameraModeCommonData::GetPtrAddr)
			.addProperty("m_fLookAtOfstMinX", &CCameraModeCommonData::m_fLookAtOfstMinX)
			.addProperty("m_fLookAtOfstRatioX", &CCameraModeCommonData::m_fLookAtOfstRatioX)
			.addProperty("m_fLookAtOfstMinY", &CCameraModeCommonData::m_fLookAtOfstMinY)
			.addProperty("m_fLookAtOfstRatioY", &CCameraModeCommonData::m_fLookAtOfstRatioY)
			.addProperty("m_fLookAtOfstYDistZero", &CCameraModeCommonData::m_fLookAtOfstYDistZero)
			.addProperty("m_fDefaultPitchOfst", &CCameraModeCommonData::m_fDefaultPitchOfst)
			.addProperty("m_bIsAddSlopePitchOfst", &CCameraModeCommonData::m_bIsAddSlopePitchOfst)
			.addProperty("m_fDistToLookAt", &CCameraModeCommonData::m_fDistToLookAt)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstMinX) == 4, "expected CCameraModeCommonData::m_fLookAtOfstMinX to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstRatioX) == 4, "expected CCameraModeCommonData::m_fLookAtOfstRatioX to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstMinY) == 4, "expected CCameraModeCommonData::m_fLookAtOfstMinY to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstRatioY) == 4, "expected CCameraModeCommonData::m_fLookAtOfstRatioY to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstYDistZero) == 4, "expected CCameraModeCommonData::m_fLookAtOfstYDistZero to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fDefaultPitchOfst) == 4, "expected CCameraModeCommonData::m_fDefaultPitchOfst to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_bIsAddSlopePitchOfst) == 4, "expected CCameraModeCommonData::m_bIsAddSlopePitchOfst to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fDistToLookAt) == 4, "expected CCameraModeCommonData::m_fDistToLookAt to be size 4");
static_assert(sizeof(CCameraModeCommonData) == 0x20, "expected CCameraModeCommonData to be size 0x20");

// [Structure] class CCameraDataManager
class CCameraDataManager
{
public:
	/// Struct member variables

	// <int32_t m_eEventCond, offset 0x0>
	int32_t m_eEventCond = 0;

	// <class CGameDataLink m_inModeManagerDataLink, offset 0x4>
	class CGameDataLink m_inModeManagerDataLink;

	// <class CGameDataLink m_inModeCommonDataLink, offset 0x10>
	class CGameDataLink m_inModeCommonDataLink;

	// <class CGameDataLink m_inNormalModeDataLink, offset 0x1c>
	class CGameDataLink m_inNormalModeDataLink;

	// <class CGameDataLink m_inLockOnModeDataLink, offset 0x28>
	class CGameDataLink m_inLockOnModeDataLink;

	// <class CCameraModeCommonData m_inModeCommonData, offset 0x34>
	class CCameraModeCommonData m_inModeCommonData;

	// <class CCameraNormalModeData m_inNormalModeData, offset 0x54>
	class CCameraNormalModeData m_inNormalModeData;

	// <class CCameraLockOnModeData m_inLockOnModeData, offset 0x58>
	class CCameraLockOnModeData m_inLockOnModeData;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraDataManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraDataManager& InObject)
	{
		m_eEventCond = InObject.m_eEventCond;
		m_inModeManagerDataLink = InObject.m_inModeManagerDataLink;
		m_inModeCommonDataLink = InObject.m_inModeCommonDataLink;
		m_inNormalModeDataLink = InObject.m_inNormalModeDataLink;
		m_inLockOnModeDataLink = InObject.m_inLockOnModeDataLink;
		m_inModeCommonData = InObject.m_inModeCommonData;
		m_inNormalModeData = InObject.m_inNormalModeData;
		m_inLockOnModeData = InObject.m_inLockOnModeData;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDataManager>("CCameraDataManager")
			.addFunction("__tostring", &CCameraDataManager::ToString)
			.addFunction("GetPtrAddr", &CCameraDataManager::GetPtrAddr)
			.addProperty("m_eEventCond", &CCameraDataManager::m_eEventCond)
			.addProperty("m_inModeManagerDataLink", &CCameraDataManager::m_inModeManagerDataLink)
			.addProperty("m_inModeCommonDataLink", &CCameraDataManager::m_inModeCommonDataLink)
			.addProperty("m_inNormalModeDataLink", &CCameraDataManager::m_inNormalModeDataLink)
			.addProperty("m_inLockOnModeDataLink", &CCameraDataManager::m_inLockOnModeDataLink)
			.addProperty("m_inModeCommonData", &CCameraDataManager::m_inModeCommonData)
			.addProperty("m_inNormalModeData", &CCameraDataManager::m_inNormalModeData)
			.addProperty("m_inLockOnModeData", &CCameraDataManager::m_inLockOnModeData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDataManager::m_eEventCond) == 4, "expected CCameraDataManager::m_eEventCond to be size 4");
static_assert(sizeof(CCameraDataManager::m_inModeManagerDataLink) == 12, "expected CCameraDataManager::m_inModeManagerDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inModeCommonDataLink) == 12, "expected CCameraDataManager::m_inModeCommonDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inNormalModeDataLink) == 12, "expected CCameraDataManager::m_inNormalModeDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inLockOnModeDataLink) == 12, "expected CCameraDataManager::m_inLockOnModeDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inModeCommonData) == 32, "expected CCameraDataManager::m_inModeCommonData to be size 32");
static_assert(sizeof(CCameraDataManager::m_inNormalModeData) == 4, "expected CCameraDataManager::m_inNormalModeData to be size 4");
static_assert(sizeof(CCameraDataManager::m_inLockOnModeData) == 40, "expected CCameraDataManager::m_inLockOnModeData to be size 40");
static_assert(sizeof(CCameraDataManager) == 0x80, "expected CCameraDataManager to be size 0x80");

// [Structure] class CCameraAreaManager
class CCameraAreaManager
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[4336];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraAreaManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraAreaManager& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraAreaManager>("CCameraAreaManager")
			.addFunction("__tostring", &CCameraAreaManager::ToString)
			.addFunction("GetPtrAddr", &CCameraAreaManager::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraAreaManager) == 0x10f0, "expected CCameraAreaManager to be size 0x10f0");

// [Structure] class gameUtil::CPositionControl
namespace gameUtil
{
	class CPositionControl
	{
	public:
		/// Struct member variables

		// <class tiVector m_inPosi, offset 0x0>
		class tiVector m_inPosi;

		// <float m_fUpdateDistSqu, offset 0x10>
		float m_fUpdateDistSqu = 0;

		// <Unidentified data segment, offset 0x14>
	private:
		char _UnidentifiedData_20[12];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class gameUtil::CPositionControl [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(gameUtil::CPositionControl& InObject)
		{
			m_inPosi = InObject.m_inPosi;
			m_fUpdateDistSqu = InObject.m_fUpdateDistSqu;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CPositionControl>("gameUtil_CPositionControl")
				.addFunction("__tostring", &gameUtil::CPositionControl::ToString)
				.addFunction("GetPtrAddr", &gameUtil::CPositionControl::GetPtrAddr)
				.addProperty("m_inPosi", &gameUtil::CPositionControl::m_inPosi)
				.addProperty("m_fUpdateDistSqu", &gameUtil::CPositionControl::m_fUpdateDistSqu)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(gameUtil::CPositionControl::m_inPosi) == 16, "expected gameUtil::CPositionControl::m_inPosi to be size 16");
static_assert(sizeof(gameUtil::CPositionControl::m_fUpdateDistSqu) == 4, "expected gameUtil::CPositionControl::m_fUpdateDistSqu to be size 4");
static_assert(sizeof(gameUtil::CPositionControl) == 0x20, "expected gameUtil::CPositionControl to be size 0x20");

// [Structure] class CCameraTarget
class CCameraTarget
{
public:
	/// Struct member variables

	// <class mot::IBoneEffectModel* m_pModel, offset 0x0>
	class mot::IBoneEffectModel* m_pModel = nullptr;

	// <Unidentified data segment, offset 0x4>
private:
	char _UnidentifiedData_4[12];

public:
	// <class tiVector m_inCenterPosi, offset 0x10>
	class tiVector m_inCenterPosi;

	// <float m_fYaw, offset 0x20>
	float m_fYaw = 0;

	// <float m_fPitch, offset 0x24>
	float m_fPitch = 0;

	// <uint8_t m_bIsIdleTime, offset 0x28>
	uint8_t m_bIsIdleTime = 0;

	// <uint8_t m_bIsVisible, offset 0x29>
	uint8_t m_bIsVisible = 0;

	// <uint8_t m_bIsVisibleYawExist, offset 0x2a>
	uint8_t m_bIsVisibleYawExist = 0;

	// <Unidentified data segment, offset 0x2b>
private:
	char _UnidentifiedData_43[1];

public:
	// <float m_fVisibleYaw, offset 0x2c>
	float m_fVisibleYaw = 0;

	// <class gameUtil::CPositionControl m_inVisibleCheckPosi, offset 0x30>
	class gameUtil::CPositionControl m_inVisibleCheckPosi;

	// <float m_fVisiblePosiInterpTimer, offset 0x50>
	float m_fVisiblePosiInterpTimer = 0;

	// <Unidentified data segment, offset 0x54>
private:
	char _UnidentifiedData_84[12];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraTarget [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraTarget& InObject)
	{
		m_pModel = InObject.m_pModel;
		m_inCenterPosi = InObject.m_inCenterPosi;
		m_fYaw = InObject.m_fYaw;
		m_fPitch = InObject.m_fPitch;
		m_bIsIdleTime = InObject.m_bIsIdleTime;
		m_bIsVisible = InObject.m_bIsVisible;
		m_bIsVisibleYawExist = InObject.m_bIsVisibleYawExist;
		m_fVisibleYaw = InObject.m_fVisibleYaw;
		m_inVisibleCheckPosi = InObject.m_inVisibleCheckPosi;
		m_fVisiblePosiInterpTimer = InObject.m_fVisiblePosiInterpTimer;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraTarget>("CCameraTarget")
			.addFunction("__tostring", &CCameraTarget::ToString)
			.addFunction("GetPtrAddr", &CCameraTarget::GetPtrAddr)
			.addProperty("m_pModel", &CCameraTarget::m_pModel)
			.addProperty("m_inCenterPosi", &CCameraTarget::m_inCenterPosi)
			.addProperty("m_fYaw", &CCameraTarget::m_fYaw)
			.addProperty("m_fPitch", &CCameraTarget::m_fPitch)
			.addProperty("m_bIsIdleTime", &CCameraTarget::m_bIsIdleTime)
			.addProperty("m_bIsVisible", &CCameraTarget::m_bIsVisible)
			.addProperty("m_bIsVisibleYawExist", &CCameraTarget::m_bIsVisibleYawExist)
			.addProperty("m_fVisibleYaw", &CCameraTarget::m_fVisibleYaw)
			.addProperty("m_inVisibleCheckPosi", &CCameraTarget::m_inVisibleCheckPosi)
			.addProperty("m_fVisiblePosiInterpTimer", &CCameraTarget::m_fVisiblePosiInterpTimer)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraTarget::m_pModel) == 4, "expected CCameraTarget::m_pModel to be size 4");
static_assert(sizeof(CCameraTarget::m_inCenterPosi) == 16, "expected CCameraTarget::m_inCenterPosi to be size 16");
static_assert(sizeof(CCameraTarget::m_fYaw) == 4, "expected CCameraTarget::m_fYaw to be size 4");
static_assert(sizeof(CCameraTarget::m_fPitch) == 4, "expected CCameraTarget::m_fPitch to be size 4");
static_assert(sizeof(CCameraTarget::m_bIsIdleTime) == 1, "expected CCameraTarget::m_bIsIdleTime to be size 1");
static_assert(sizeof(CCameraTarget::m_bIsVisible) == 1, "expected CCameraTarget::m_bIsVisible to be size 1");
static_assert(sizeof(CCameraTarget::m_bIsVisibleYawExist) == 1, "expected CCameraTarget::m_bIsVisibleYawExist to be size 1");
static_assert(sizeof(CCameraTarget::m_fVisibleYaw) == 4, "expected CCameraTarget::m_fVisibleYaw to be size 4");
static_assert(sizeof(CCameraTarget::m_inVisibleCheckPosi) == 32, "expected CCameraTarget::m_inVisibleCheckPosi to be size 32");
static_assert(sizeof(CCameraTarget::m_fVisiblePosiInterpTimer) == 4, "expected CCameraTarget::m_fVisiblePosiInterpTimer to be size 4");
static_assert(sizeof(CCameraTarget) == 0x60, "expected CCameraTarget to be size 0x60");

// enum EGameCameraMode
enum EGameCameraMode : uint32_t
{
	// <GAME_CAMERA_MODE_NONE = 0xffffffffffffffff>
	GAME_CAMERA_MODE_NONE = UINT32_MAX,

	// <GAME_CAMERA_MODE_RESET = 0x0>
	GAME_CAMERA_MODE_RESET = 0,

	// <GAME_CAMERA_MODE_NORMAL = 0x1>
	GAME_CAMERA_MODE_NORMAL = 1,

	// <GAME_CAMERA_MODE_FREE = 0x2>
	GAME_CAMERA_MODE_FREE = 2,

	// <GAME_CAMERA_MODE_DEFAULT_ANGLE = 0x3>
	GAME_CAMERA_MODE_DEFAULT_ANGLE = 3,

	// <GAME_CAMERA_MODE_LOCK_ON = 0x4>
	GAME_CAMERA_MODE_LOCK_ON = 4,

	// <GAME_CAMERA_MODE_CIRCLE = 0x5>
	GAME_CAMERA_MODE_CIRCLE = 5,

	// <GAME_CAMERA_MODE_PETIT_MOVIE = 0x6>
	GAME_CAMERA_MODE_PETIT_MOVIE = 6,

	// <GAME_CAMERA_MODE_SUBJECTIVE = 0x7>
	GAME_CAMERA_MODE_SUBJECTIVE = 7

};

// [Structure] class ti::CCamera
namespace ti
{
	class CCamera
	{
	public:
		/// Struct member variables

		// <class tiVector m_inPosi, offset 0x0>
		class tiVector m_inPosi;

		// <class tiVector m_inDir, offset 0x10>
		class tiVector m_inDir;

		// <class tiVector m_inUpDir, offset 0x20>
		class tiVector m_inUpDir;

		// <class tiVector m_inLookAtPosi, offset 0x30>
		class tiVector m_inLookAtPosi;

		// <float m_fDistToLookAt, offset 0x40>
		float m_fDistToLookAt = 0;

		// <float m_fYaw, offset 0x44>
		float m_fYaw = 0;

		// <float m_fPitch, offset 0x48>
		float m_fPitch = 0;

		// <float m_fBank, offset 0x4c>
		float m_fBank = 0;

		// <float m_fViewAngleRadi, offset 0x50>
		float m_fViewAngleRadi = 0;

		// <float m_fAspectRatio, offset 0x54>
		float m_fAspectRatio = 0;

		// <Unidentified data segment, offset 0x58>
	private:
		char _UnidentifiedData_88[8];

	public:
		// <class tiMatrix m_inWorldMat, offset 0x60>
		class tiMatrix m_inWorldMat;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "class ti::CCamera [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(ti::CCamera& InObject)
		{
			m_inPosi = InObject.m_inPosi;
			m_inDir = InObject.m_inDir;
			m_inUpDir = InObject.m_inUpDir;
			m_inLookAtPosi = InObject.m_inLookAtPosi;
			m_fDistToLookAt = InObject.m_fDistToLookAt;
			m_fYaw = InObject.m_fYaw;
			m_fPitch = InObject.m_fPitch;
			m_fBank = InObject.m_fBank;
			m_fViewAngleRadi = InObject.m_fViewAngleRadi;
			m_fAspectRatio = InObject.m_fAspectRatio;
			m_inWorldMat = InObject.m_inWorldMat;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CCamera>("ti_CCamera")
				.addFunction("__tostring", &ti::CCamera::ToString)
				.addFunction("GetPtrAddr", &ti::CCamera::GetPtrAddr)
				.addProperty("m_inPosi", &ti::CCamera::m_inPosi)
				.addProperty("m_inDir", &ti::CCamera::m_inDir)
				.addProperty("m_inUpDir", &ti::CCamera::m_inUpDir)
				.addProperty("m_inLookAtPosi", &ti::CCamera::m_inLookAtPosi)
				.addProperty("m_fDistToLookAt", &ti::CCamera::m_fDistToLookAt)
				.addProperty("m_fYaw", &ti::CCamera::m_fYaw)
				.addProperty("m_fPitch", &ti::CCamera::m_fPitch)
				.addProperty("m_fBank", &ti::CCamera::m_fBank)
				.addProperty("m_fViewAngleRadi", &ti::CCamera::m_fViewAngleRadi)
				.addProperty("m_fAspectRatio", &ti::CCamera::m_fAspectRatio)
				.addProperty("m_inWorldMat", &ti::CCamera::m_inWorldMat)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(ti::CCamera::m_inPosi) == 16, "expected ti::CCamera::m_inPosi to be size 16");
static_assert(sizeof(ti::CCamera::m_inDir) == 16, "expected ti::CCamera::m_inDir to be size 16");
static_assert(sizeof(ti::CCamera::m_inUpDir) == 16, "expected ti::CCamera::m_inUpDir to be size 16");
static_assert(sizeof(ti::CCamera::m_inLookAtPosi) == 16, "expected ti::CCamera::m_inLookAtPosi to be size 16");
static_assert(sizeof(ti::CCamera::m_fDistToLookAt) == 4, "expected ti::CCamera::m_fDistToLookAt to be size 4");
static_assert(sizeof(ti::CCamera::m_fYaw) == 4, "expected ti::CCamera::m_fYaw to be size 4");
static_assert(sizeof(ti::CCamera::m_fPitch) == 4, "expected ti::CCamera::m_fPitch to be size 4");
static_assert(sizeof(ti::CCamera::m_fBank) == 4, "expected ti::CCamera::m_fBank to be size 4");
static_assert(sizeof(ti::CCamera::m_fViewAngleRadi) == 4, "expected ti::CCamera::m_fViewAngleRadi to be size 4");
static_assert(sizeof(ti::CCamera::m_fAspectRatio) == 4, "expected ti::CCamera::m_fAspectRatio to be size 4");
static_assert(sizeof(ti::CCamera::m_inWorldMat) == 64, "expected ti::CCamera::m_inWorldMat to be size 64");
static_assert(sizeof(ti::CCamera) == 0xa0, "expected ti::CCamera to be size 0xa0");

// [Structure] class CGameCamera
class CGameCamera
{
public:
	/// Struct member variables

	// <class ti::CCamera m_inCamera, offset 0x0>
	class ti::CCamera m_inCamera;

	// <float m_fYawVel, offset 0xa0>
	float m_fYawVel = 0;

	// <enum EGameCameraMode m_eMode, offset 0xa4>
	enum EGameCameraMode m_eMode;

	// <int32_t m_nResetModeCounter, offset 0xa8>
	int32_t m_nResetModeCounter = 0;

	// <uint8_t m_bActCircle, offset 0xac>
	uint8_t m_bActCircle = 0;

	// <Unidentified data segment, offset 0xad>
private:
	char _UnidentifiedData_173[3];

public:
	// <float m_fSearchAreaTimer, offset 0xb0>
	float m_fSearchAreaTimer = 0;

	// <Unidentified data segment, offset 0xb4>
private:
	char _UnidentifiedData_180[12];

public:
	// <class CCameraTarget m_inTarget, offset 0xc0>
	class CCameraTarget m_inTarget;

	// <class CCameraAreaManager m_inAreaManager, offset 0x120>
	class CCameraAreaManager m_inAreaManager;

	// <class CCameraDataManager m_inDataManager, offset 0x1210>
	class CCameraDataManager m_inDataManager;

	// <class CCameraDefaultAngle m_inDefaultAngle, offset 0x1290>
	class CCameraDefaultAngle m_inDefaultAngle;

	// <class CCameraLookAtBase m_inLookAtBase, offset 0x12f0>
	class CCameraLookAtBase m_inLookAtBase;

	// <class CCameraLookAtOffset m_inLookAtOffset, offset 0x1380>
	class CCameraLookAtOffset m_inLookAtOffset;

	// <class CCameraFollowRot m_inFollowRot, offset 0x1440>
	class CCameraFollowRot m_inFollowRot;

	// <class CCameraDistToLookAt m_inDistToLookAt, offset 0x14a0>
	class CCameraDistToLookAt m_inDistToLookAt;

	// <class CCameraModeReset m_inResetMode, offset 0x14d0>
	class CCameraModeReset m_inResetMode;

	// <class CCameraModeNormal m_inNormalMode, offset 0x14ec>
	class CCameraModeNormal m_inNormalMode;

	// <class CCameraModeFree m_inFreeMode, offset 0x1570>
	class CCameraModeFree m_inFreeMode;

	// <class CCameraModeDefaultAngle m_inDefaultAngleMode, offset 0x15f0>
	class CCameraModeDefaultAngle m_inDefaultAngleMode;

	// <class CCameraModeLockOn m_inLockOnMode, offset 0x1690>
	class CCameraModeLockOn m_inLockOnMode;

	// <class CCameraModeCircle m_inCircleMode, offset 0x1740>
	class CCameraModeCircle m_inCircleMode;

	// <Unidentified data segment, offset 0x175c>
private:
	char _UnidentifiedData_5980[4];

public:
	// <class CCameraModePetitMovie m_inPetitMovieMode, offset 0x1760>
	class CCameraModePetitMovie m_inPetitMovieMode;

	// <class CCameraModeSubjective m_inSubjectiveMode, offset 0x1800>
	class CCameraModeSubjective m_inSubjectiveMode;

	// <class CCameraCollision m_inCollision, offset 0x1860>
	class CCameraCollision m_inCollision;

	// <Unidentified data segment, offset 0x1861>
private:
	char _UnidentifiedData_6241[3];

public:
	// <class CCameraBank m_inBank, offset 0x1864>
	class CCameraBank m_inBank;

	// <Unidentified data segment, offset 0x1894>
private:
	char _UnidentifiedData_6292[12];

public:
	// <class CCameraVibManager m_inVibManager, offset 0x18a0>
	class CCameraVibManager m_inVibManager;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CGameCamera [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CGameCamera& InObject)
	{
		m_inCamera = InObject.m_inCamera;
		m_fYawVel = InObject.m_fYawVel;
		m_eMode = InObject.m_eMode;
		m_nResetModeCounter = InObject.m_nResetModeCounter;
		m_bActCircle = InObject.m_bActCircle;
		m_fSearchAreaTimer = InObject.m_fSearchAreaTimer;
		m_inTarget = InObject.m_inTarget;
		m_inAreaManager = InObject.m_inAreaManager;
		m_inDataManager = InObject.m_inDataManager;
		m_inDefaultAngle = InObject.m_inDefaultAngle;
		m_inLookAtBase = InObject.m_inLookAtBase;
		m_inLookAtOffset = InObject.m_inLookAtOffset;
		m_inFollowRot = InObject.m_inFollowRot;
		m_inDistToLookAt = InObject.m_inDistToLookAt;
		m_inResetMode = InObject.m_inResetMode;
		m_inNormalMode = InObject.m_inNormalMode;
		m_inFreeMode = InObject.m_inFreeMode;
		m_inDefaultAngleMode = InObject.m_inDefaultAngleMode;
		m_inLockOnMode = InObject.m_inLockOnMode;
		m_inCircleMode = InObject.m_inCircleMode;
		m_inPetitMovieMode = InObject.m_inPetitMovieMode;
		m_inSubjectiveMode = InObject.m_inSubjectiveMode;
		m_inCollision = InObject.m_inCollision;
		m_inBank = InObject.m_inBank;
		m_inVibManager = InObject.m_inVibManager;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameCamera>("CGameCamera")
			.addFunction("__tostring", &CGameCamera::ToString)
			.addFunction("GetPtrAddr", &CGameCamera::GetPtrAddr)
			.addProperty("m_inCamera", &CGameCamera::m_inCamera)
			.addProperty("m_fYawVel", &CGameCamera::m_fYawVel)
			.addProperty("m_eMode", &CGameCamera::m_eMode)
			.addProperty("m_nResetModeCounter", &CGameCamera::m_nResetModeCounter)
			.addProperty("m_bActCircle", &CGameCamera::m_bActCircle)
			.addProperty("m_fSearchAreaTimer", &CGameCamera::m_fSearchAreaTimer)
			.addProperty("m_inTarget", &CGameCamera::m_inTarget)
			.addProperty("m_inAreaManager", &CGameCamera::m_inAreaManager)
			.addProperty("m_inDataManager", &CGameCamera::m_inDataManager)
			.addProperty("m_inDefaultAngle", &CGameCamera::m_inDefaultAngle)
			.addProperty("m_inLookAtBase", &CGameCamera::m_inLookAtBase)
			.addProperty("m_inLookAtOffset", &CGameCamera::m_inLookAtOffset)
			.addProperty("m_inFollowRot", &CGameCamera::m_inFollowRot)
			.addProperty("m_inDistToLookAt", &CGameCamera::m_inDistToLookAt)
			.addProperty("m_inResetMode", &CGameCamera::m_inResetMode)
			.addProperty("m_inNormalMode", &CGameCamera::m_inNormalMode)
			.addProperty("m_inFreeMode", &CGameCamera::m_inFreeMode)
			.addProperty("m_inDefaultAngleMode", &CGameCamera::m_inDefaultAngleMode)
			.addProperty("m_inLockOnMode", &CGameCamera::m_inLockOnMode)
			.addProperty("m_inCircleMode", &CGameCamera::m_inCircleMode)
			.addProperty("m_inPetitMovieMode", &CGameCamera::m_inPetitMovieMode)
			.addProperty("m_inSubjectiveMode", &CGameCamera::m_inSubjectiveMode)
			.addProperty("m_inCollision", &CGameCamera::m_inCollision)
			.addProperty("m_inBank", &CGameCamera::m_inBank)
			.addProperty("m_inVibManager", &CGameCamera::m_inVibManager)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameCamera::m_inCamera) == 160, "expected CGameCamera::m_inCamera to be size 160");
static_assert(sizeof(CGameCamera::m_fYawVel) == 4, "expected CGameCamera::m_fYawVel to be size 4");
static_assert(sizeof(CGameCamera::m_eMode) == 4, "expected CGameCamera::m_eMode to be size 4");
static_assert(sizeof(CGameCamera::m_nResetModeCounter) == 4, "expected CGameCamera::m_nResetModeCounter to be size 4");
static_assert(sizeof(CGameCamera::m_bActCircle) == 1, "expected CGameCamera::m_bActCircle to be size 1");
static_assert(sizeof(CGameCamera::m_fSearchAreaTimer) == 4, "expected CGameCamera::m_fSearchAreaTimer to be size 4");
static_assert(sizeof(CGameCamera::m_inTarget) == 96, "expected CGameCamera::m_inTarget to be size 96");
static_assert(sizeof(CGameCamera::m_inAreaManager) == 4336, "expected CGameCamera::m_inAreaManager to be size 4336");
static_assert(sizeof(CGameCamera::m_inDataManager) == 128, "expected CGameCamera::m_inDataManager to be size 128");
static_assert(sizeof(CGameCamera::m_inDefaultAngle) == 96, "expected CGameCamera::m_inDefaultAngle to be size 96");
static_assert(sizeof(CGameCamera::m_inLookAtBase) == 144, "expected CGameCamera::m_inLookAtBase to be size 144");
static_assert(sizeof(CGameCamera::m_inLookAtOffset) == 192, "expected CGameCamera::m_inLookAtOffset to be size 192");
static_assert(sizeof(CGameCamera::m_inFollowRot) == 96, "expected CGameCamera::m_inFollowRot to be size 96");
static_assert(sizeof(CGameCamera::m_inDistToLookAt) == 48, "expected CGameCamera::m_inDistToLookAt to be size 48");
static_assert(sizeof(CGameCamera::m_inResetMode) == 28, "expected CGameCamera::m_inResetMode to be size 28");
static_assert(sizeof(CGameCamera::m_inNormalMode) == 132, "expected CGameCamera::m_inNormalMode to be size 132");
static_assert(sizeof(CGameCamera::m_inFreeMode) == 128, "expected CGameCamera::m_inFreeMode to be size 128");
static_assert(sizeof(CGameCamera::m_inDefaultAngleMode) == 160, "expected CGameCamera::m_inDefaultAngleMode to be size 160");
static_assert(sizeof(CGameCamera::m_inLockOnMode) == 176, "expected CGameCamera::m_inLockOnMode to be size 176");
static_assert(sizeof(CGameCamera::m_inCircleMode) == 28, "expected CGameCamera::m_inCircleMode to be size 28");
static_assert(sizeof(CGameCamera::m_inPetitMovieMode) == 160, "expected CGameCamera::m_inPetitMovieMode to be size 160");
static_assert(sizeof(CGameCamera::m_inSubjectiveMode) == 96, "expected CGameCamera::m_inSubjectiveMode to be size 96");
static_assert(sizeof(CGameCamera::m_inCollision) == 1, "expected CGameCamera::m_inCollision to be size 1");
static_assert(sizeof(CGameCamera::m_inBank) == 48, "expected CGameCamera::m_inBank to be size 48");
static_assert(sizeof(CGameCamera::m_inVibManager) == 576, "expected CGameCamera::m_inVibManager to be size 576");
static_assert(sizeof(CGameCamera) == 0x1ae0, "expected CGameCamera to be size 0x1ae0");

// enum ECameraResetType
enum ECameraResetType : uint32_t
{
	// <CAMERA_RESET_TYPE_NONE = 0x0>
	CAMERA_RESET_TYPE_NONE = 0,

	// <CAMERA_RESET_TYPE_NORMAL = 0x1>
	CAMERA_RESET_TYPE_NORMAL = 1,

	// <CAMERA_RESET_TYPE_SEAMLESS = 0x2>
	CAMERA_RESET_TYPE_SEAMLESS = 2,

	// <CAMERA_RESET_TYPE_SET_YAW = 0x3>
	CAMERA_RESET_TYPE_SET_YAW = 3

};

// [Structure] class CCameraman
class CCameraman
{
public:
	// enum CCameraman::ECameraMode
	enum ECameraMode : uint32_t
	{
		// <CAMERA_MODE_NONE = 0xffffffffffffffff>
		CAMERA_MODE_NONE = UINT32_MAX,

		// <CAMERA_MODE_GAME = 0x0>
		CAMERA_MODE_GAME = 0,

		// <CAMERA_MODE_DEBUG_GLOBAL = 0x1>
		CAMERA_MODE_DEBUG_GLOBAL = 1

	};

	/// Struct member variables

	// <class ti::CCamera m_inCamera, offset 0x0>
	class ti::CCamera m_inCamera;

	// <uint8_t m_bIsCalledOnUpdate, offset 0xa0>
	uint8_t m_bIsCalledOnUpdate = 0;

	// <Unidentified data segment, offset 0xa1>
private:
	char _UnidentifiedData_161[3];

public:
	// <enum ECameraResetType m_eResetType, offset 0xa4>
	enum ECameraResetType m_eResetType;

	// <enum CCameraman::ECameraMode m_eCamMode, offset 0xa8>
	enum CCameraman::ECameraMode m_eCamMode;

	// <class mot::IBoneEffectModel* m_pTarget, offset 0xac>
	class mot::IBoneEffectModel* m_pTarget = nullptr;

	// <class CGameCamera m_inGameCamera, offset 0xb0>
	class CGameCamera m_inGameCamera;

	// <uint8_t m_bIsTsubazeriai, offset 0x1b90>
	uint8_t m_bIsTsubazeriai = 0;

	// <Unidentified data segment, offset 0x1b91>
private:
	char _UnidentifiedData_7057[3];

public:
	// <enum enCharaType m_eTsubaTarget, offset 0x1b94>
	enum enCharaType m_eTsubaTarget;

	// <float m_fTsubaSuperiorRatio, offset 0x1b98>
	float m_fTsubaSuperiorRatio = 0;

	// <uint8_t m_bIsTsubaYawPlus, offset 0x1b9c>
	uint8_t m_bIsTsubaYawPlus = 0;

	// <Unidentified data segment, offset 0x1b9d>
private:
	char _UnidentifiedData_7069[3];

public:
	// <int32_t m_nTsubaCamVibID, offset 0x1ba0>
	int32_t m_nTsubaCamVibID = 0;

	// <Unidentified data segment, offset 0x1ba4>
private:
	char _UnidentifiedData_7076[12];

public:
	/// 1 Functions

	// [Function] void __convention("thiscall") CCameraman::beginTsubazeriai(class CCameraman* const this, class mHRChara* arg2, float const arg3) [?beginTsubazeriai@CCameraman@@QAEXPBVmHRChara@@M@Z]
	typedef void(__thiscall* _beginTsubazeriai_CCameraman__QAEXPBVmHRChara__M_Z)(class CCameraman* const thisPtr, class mHRChara* arg2, float const arg3);
	void beginTsubazeriai(class mHRChara* arg2, float const arg3)
	{
		_beginTsubazeriai_CCameraman__QAEXPBVmHRChara__M_Z mFunc = (_beginTsubazeriai_CCameraman__QAEXPBVmHRChara__M_Z)(GameModule + 0x398630);
		return mFunc(this, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CCameraman [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CCameraman& InObject)
	{
		m_inCamera = InObject.m_inCamera;
		m_bIsCalledOnUpdate = InObject.m_bIsCalledOnUpdate;
		m_eResetType = InObject.m_eResetType;
		m_eCamMode = InObject.m_eCamMode;
		m_pTarget = InObject.m_pTarget;
		m_inGameCamera = InObject.m_inGameCamera;
		m_bIsTsubazeriai = InObject.m_bIsTsubazeriai;
		m_eTsubaTarget = InObject.m_eTsubaTarget;
		m_fTsubaSuperiorRatio = InObject.m_fTsubaSuperiorRatio;
		m_bIsTsubaYawPlus = InObject.m_bIsTsubaYawPlus;
		m_nTsubaCamVibID = InObject.m_nTsubaCamVibID;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraman>("CCameraman")
			.addFunction("__tostring", &CCameraman::ToString)
			.addFunction("GetPtrAddr", &CCameraman::GetPtrAddr)
			.addProperty("m_inCamera", &CCameraman::m_inCamera)
			.addProperty("m_bIsCalledOnUpdate", &CCameraman::m_bIsCalledOnUpdate)
			.addProperty("m_eResetType", &CCameraman::m_eResetType)
			.addProperty("m_eCamMode", &CCameraman::m_eCamMode)
			.addProperty("m_pTarget", &CCameraman::m_pTarget)
			.addProperty("m_inGameCamera", &CCameraman::m_inGameCamera)
			.addProperty("m_bIsTsubazeriai", &CCameraman::m_bIsTsubazeriai)
			.addProperty("m_eTsubaTarget", &CCameraman::m_eTsubaTarget)
			.addProperty("m_fTsubaSuperiorRatio", &CCameraman::m_fTsubaSuperiorRatio)
			.addProperty("m_bIsTsubaYawPlus", &CCameraman::m_bIsTsubaYawPlus)
			.addProperty("m_nTsubaCamVibID", &CCameraman::m_nTsubaCamVibID)
			.addFunction("beginTsubazeriai", &CCameraman::beginTsubazeriai)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraman::m_inCamera) == 160, "expected CCameraman::m_inCamera to be size 160");
static_assert(sizeof(CCameraman::m_bIsCalledOnUpdate) == 1, "expected CCameraman::m_bIsCalledOnUpdate to be size 1");
static_assert(sizeof(CCameraman::m_eResetType) == 4, "expected CCameraman::m_eResetType to be size 4");
static_assert(sizeof(CCameraman::m_eCamMode) == 4, "expected CCameraman::m_eCamMode to be size 4");
static_assert(sizeof(CCameraman::m_pTarget) == 4, "expected CCameraman::m_pTarget to be size 4");
static_assert(sizeof(CCameraman::m_inGameCamera) == 6880, "expected CCameraman::m_inGameCamera to be size 6880");
static_assert(sizeof(CCameraman::m_bIsTsubazeriai) == 1, "expected CCameraman::m_bIsTsubazeriai to be size 1");
static_assert(sizeof(CCameraman::m_eTsubaTarget) == 4, "expected CCameraman::m_eTsubaTarget to be size 4");
static_assert(sizeof(CCameraman::m_fTsubaSuperiorRatio) == 4, "expected CCameraman::m_fTsubaSuperiorRatio to be size 4");
static_assert(sizeof(CCameraman::m_bIsTsubaYawPlus) == 1, "expected CCameraman::m_bIsTsubaYawPlus to be size 1");
static_assert(sizeof(CCameraman::m_nTsubaCamVibID) == 4, "expected CCameraman::m_nTsubaCamVibID to be size 4");
static_assert(sizeof(CCameraman) == 0x1bb0, "expected CCameraman to be size 0x1bb0");

// enum GHMR_VERTTYPE
enum GHMR_VERTTYPE : uint32_t
{
	// <GHMR_VERTTYPE_NOTEX = 0x0>
	GHMR_VERTTYPE_NOTEX = 0,

	// <GHMR_VERTTYPE_USETEX = 0x1>
	GHMR_VERTTYPE_USETEX = 1,

	// <GHMR_VERTTYPE_USEMULTITEX = 0x2>
	GHMR_VERTTYPE_USEMULTITEX = 2,

	// <GHMR_VERTTYPE_GMF_SKIN_NOCOLOR = 0x3>
	GHMR_VERTTYPE_GMF_SKIN_NOCOLOR = 3,

	// <GHMR_VERTTYPE_GMF_SKIN_USECOLOR = 0x4>
	GHMR_VERTTYPE_GMF_SKIN_USECOLOR = 4,

	// <GHMR_VERTTYPE_GMF_NOCOLOR = 0x5>
	GHMR_VERTTYPE_GMF_NOCOLOR = 5,

	// <GHMR_VERTTYPE_GMF_USECOLOR = 0x6>
	GHMR_VERTTYPE_GMF_USECOLOR = 6,

	// <GHMR_VERTTYPE_USETEX_NOCLR = 0x7>
	GHMR_VERTTYPE_USETEX_NOCLR = 7,

	// <GHMR_VERTTYPE_NUM = 0x8>
	GHMR_VERTTYPE_NUM = 8

};

// [Function] int32_t __convention("thiscall") sub_3e5549(class HrStageDraw* arg1, enum GHMR_VERTTYPE arg2 @ esi, float arg3 @ edi, void* arg4) [sub_3e5549]
typedef int32_t(__thiscall* _sub_3e5549)(class HrStageDraw* arg1, enum GHMR_VERTTYPE arg2, float arg3, void* arg4);
int32_t sub_3e5549(class HrStageDraw* arg1, /* enum GHMR_VERTTYPE */ uint32_t arg2, float arg3, void* arg4)
{
	_sub_3e5549 mFunc = (_sub_3e5549)(GameModule + 0x3e5549);
	return mFunc(arg1, (enum GHMR_VERTTYPE)arg2, arg3, arg4);
}
// Unsupported constructor
//void __convention("thiscall") mHRBattle::mHRBattle(class mHRBattle* const this)
// Unsupported destructor
//void __convention("thiscall") mHRBattle::~mHRBattle(class mHRBattle* const this)
// [Structure] class HrDemo
class HrDemo : public HrTask
{
public:
	// enum HrDemo::HRDEMO_STS
	enum HRDEMO_STS : uint32_t
	{
		// <HRDEMO_INIT = 0x0>
		HRDEMO_INIT = 0,

		// <HRDEMO_SETUP = 0x1>
		HRDEMO_SETUP = 1,

		// <HRDEMO_SETUP2 = 0x2>
		HRDEMO_SETUP2 = 2,

		// <HRDEMO_LOAD = 0x3>
		HRDEMO_LOAD = 3,

		// <HRDEMO_SETMOT = 0x4>
		HRDEMO_SETMOT = 4,

		// <HRDEMO_LOADMOT = 0x5>
		HRDEMO_LOADMOT = 5,

		// <HRDEMO_WAIT = 0x6>
		HRDEMO_WAIT = 6,

		// <HRDEMO_STARTWAIT = 0x7>
		HRDEMO_STARTWAIT = 7,

		// <HRDEMO_RESTART = 0x8>
		HRDEMO_RESTART = 8,

		// <HRDEMO_DOING = 0x9>
		HRDEMO_DOING = 9,

		// <HRDEMO_MOTIONWAIT = 0xa>
		HRDEMO_MOTIONWAIT = 10,

		// <HRDEMO_PAUSE = 0xb>
		HRDEMO_PAUSE = 11,

		// <HRDEMO_STAFFROLL2 = 0xc>
		HRDEMO_STAFFROLL2 = 12,

		// <HRDEMO_IDLE = 0xd>
		HRDEMO_IDLE = 13,

		// <HRDEMO_RELEASEFADEWAIT = 0xe>
		HRDEMO_RELEASEFADEWAIT = 14,

		// <HRDEMO_RELEASE = 0xf>
		HRDEMO_RELEASE = 15,

		// <HRDEMO_MAX = 0x10>
		HRDEMO_MAX = 16

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct HRDEMO_DATA* pd, offset 0x50>
	struct HRDEMO_DATA* pd = nullptr;

	// <float mRate, offset 0x54>
	float mRate = 0;

	// <float mSlowRate, offset 0x58>
	float mSlowRate = 0;

	// <int32_t mSoundGroup, offset 0x5c>
	int32_t mSoundGroup = 0;

	// <int32_t mPcWepNum, offset 0x60>
	int32_t mPcWepNum = 0;

	// <int32_t mSlashKind, offset 0x64>
	int32_t mSlashKind = 0;

	// <uint8_t mbSlashArrow, offset 0x68>
	uint8_t mbSlashArrow = 0;

	// <uint8_t mbFadeUse, offset 0x69>
	uint8_t mbFadeUse = 0;

	// <uint8_t mbSkipDis, offset 0x6a>
	uint8_t mbSkipDis = 0;

	// <uint8_t mbFractionRateAdjust, offset 0x6b>
	uint8_t mbFractionRateAdjust = 0;

	// <uint8_t mLoadingVisible, offset 0x6c>
	uint8_t mLoadingVisible = 0;

	// <Unidentified data segment, offset 0x6d>
private:
	char _UnidentifiedData_109[3];

public:
	// <float mFractionRate, offset 0x70>
	float mFractionRate = 0;

	// <float mBgmVol, offset 0x74>
	float mBgmVol = 0;

	// <int32_t mLastRead, offset 0x78>
	int32_t mLastRead = 0;

	/// 2 Functions

	// [Function] void __convention("thiscall") HrDemo::InitLensFlare(class HrDemo* const this, int32_t arg2, class ghmResGroup* arg3) [?InitLensFlare@HrDemo@@IAEXHPAVghmResGroup@@@Z]
	typedef void(__thiscall* _InitLensFlare_HrDemo__IAEXHPAVghmResGroup___Z)(class HrDemo* const thisPtr, int32_t arg2, class ghmResGroup* arg3);
	void InitLensFlare(int32_t arg2, class ghmResGroup* arg3)
	{
		_InitLensFlare_HrDemo__IAEXHPAVghmResGroup___Z mFunc = (_InitLensFlare_HrDemo__IAEXHPAVghmResGroup___Z)(GameModule + 0x4039c0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class ghmResGroup* HrDemo::GetResLink() [?GetResLink@HrDemo@@SAPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__fastcall* _GetResLink_HrDemo__SAPAVghmResGroup__XZ)();
	static class ghmResGroup* GetResLink()
	{
		_GetResLink_HrDemo__SAPAVghmResGroup__XZ mFunc = (_GetResLink_HrDemo__SAPAVghmResGroup__XZ)(GameModule + 0x40b040);
		return mFunc();
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrDemo [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrDemo& InObject)
	{
		pd = InObject.pd;
		mRate = InObject.mRate;
		mSlowRate = InObject.mSlowRate;
		mSoundGroup = InObject.mSoundGroup;
		mPcWepNum = InObject.mPcWepNum;
		mSlashKind = InObject.mSlashKind;
		mbSlashArrow = InObject.mbSlashArrow;
		mbFadeUse = InObject.mbFadeUse;
		mbSkipDis = InObject.mbSkipDis;
		mbFractionRateAdjust = InObject.mbFractionRateAdjust;
		mLoadingVisible = InObject.mLoadingVisible;
		mFractionRate = InObject.mFractionRate;
		mBgmVol = InObject.mBgmVol;
		mLastRead = InObject.mLastRead;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrDemo, HrTask>("HrDemo")
			.addFunction("__tostring", &HrDemo::ToString)
			.addFunction("GetPtrAddr", &HrDemo::GetPtrAddr)
			.addProperty("pd", &HrDemo::pd)
			.addProperty("mRate", &HrDemo::mRate)
			.addProperty("mSlowRate", &HrDemo::mSlowRate)
			.addProperty("mSoundGroup", &HrDemo::mSoundGroup)
			.addProperty("mPcWepNum", &HrDemo::mPcWepNum)
			.addProperty("mSlashKind", &HrDemo::mSlashKind)
			.addProperty("mbSlashArrow", &HrDemo::mbSlashArrow)
			.addProperty("mbFadeUse", &HrDemo::mbFadeUse)
			.addProperty("mbSkipDis", &HrDemo::mbSkipDis)
			.addProperty("mbFractionRateAdjust", &HrDemo::mbFractionRateAdjust)
			.addProperty("mLoadingVisible", &HrDemo::mLoadingVisible)
			.addProperty("mFractionRate", &HrDemo::mFractionRate)
			.addProperty("mBgmVol", &HrDemo::mBgmVol)
			.addProperty("mLastRead", &HrDemo::mLastRead)
			.addFunction("InitLensFlare", &HrDemo::InitLensFlare)
			.addStaticFunction("GetResLink", &HrDemo::GetResLink)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrDemo::pd) == 4, "expected HrDemo::pd to be size 4");
static_assert(sizeof(HrDemo::mRate) == 4, "expected HrDemo::mRate to be size 4");
static_assert(sizeof(HrDemo::mSlowRate) == 4, "expected HrDemo::mSlowRate to be size 4");
static_assert(sizeof(HrDemo::mSoundGroup) == 4, "expected HrDemo::mSoundGroup to be size 4");
static_assert(sizeof(HrDemo::mPcWepNum) == 4, "expected HrDemo::mPcWepNum to be size 4");
static_assert(sizeof(HrDemo::mSlashKind) == 4, "expected HrDemo::mSlashKind to be size 4");
static_assert(sizeof(HrDemo::mbSlashArrow) == 1, "expected HrDemo::mbSlashArrow to be size 1");
static_assert(sizeof(HrDemo::mbFadeUse) == 1, "expected HrDemo::mbFadeUse to be size 1");
static_assert(sizeof(HrDemo::mbSkipDis) == 1, "expected HrDemo::mbSkipDis to be size 1");
static_assert(sizeof(HrDemo::mbFractionRateAdjust) == 1, "expected HrDemo::mbFractionRateAdjust to be size 1");
static_assert(sizeof(HrDemo::mLoadingVisible) == 1, "expected HrDemo::mLoadingVisible to be size 1");
static_assert(sizeof(HrDemo::mFractionRate) == 4, "expected HrDemo::mFractionRate to be size 4");
static_assert(sizeof(HrDemo::mBgmVol) == 4, "expected HrDemo::mBgmVol to be size 4");
static_assert(sizeof(HrDemo::mLastRead) == 4, "expected HrDemo::mLastRead to be size 4");
static_assert(sizeof(HrDemo) == 0x7c, "expected HrDemo to be size 0x7c");

// [Structure] struct HRDEMO_DATA
struct HRDEMO_DATA
{
public:
	/// Struct member variables

	// <enum HrDemo::HRDEMO_STS mStatus, offset 0x0>
	enum HrDemo::HRDEMO_STS mStatus;

	// <enum HrDemo::HRDEMO_STS mNextStatus, offset 0x4>
	enum HrDemo::HRDEMO_STS mNextStatus;

	// <int32_t mDemoNum, offset 0x8>
	int32_t mDemoNum = 0;

	// <int32_t mDemoID, offset 0xc>
	int32_t mDemoID = 0;

	// <char mFileName[0x10], offset 0x10>
	char mFileName[16];

	// <class ghmGcFile* mFileptr, offset 0x20>
	class ghmGcFile* mFileptr = nullptr;

	// <int32_t Counter, offset 0x24>
	int32_t Counter = 0;

	// <void* mpDummyAlloc, offset 0x28>
	void* mpDummyAlloc = nullptr;

	// <void* mpRslData, offset 0x2c>
	void* mpRslData = nullptr;

	// <class ghmResGroup* mpRsl, offset 0x30>
	class ghmResGroup* mpRsl = nullptr;

	// <class TGmf* mpRShadowModel, offset 0x34>
	class TGmf* mpRShadowModel = nullptr;

	// <class TGan* mpGan[0x2], offset 0x38>
	class TGan* mpGan[2];

	// <void* mpMotData[0x2], offset 0x40>
	void* mpMotData[2];

	// <int32_t mCurrentID, offset 0x48>
	int32_t mCurrentID = 0;

	// <int32_t mReadID, offset 0x4c>
	int32_t mReadID = 0;

	// <int32_t mReadCount, offset 0x50>
	int32_t mReadCount = 0;

	// <int32_t mMotNum, offset 0x54>
	int32_t mMotNum = 0;

	// <int32_t mFileID, offset 0x58>
	int32_t mFileID = 0;

	// <int32_t mInFadeType, offset 0x5c>
	int32_t mInFadeType = 0;

	// <int32_t mOutFadeType, offset 0x60>
	int32_t mOutFadeType = 0;

	// <int32_t mInFadeTick, offset 0x64>
	int32_t mInFadeTick = 0;

	// <int32_t mOutFadeTick, offset 0x68>
	int32_t mOutFadeTick = 0;

	// <uint32_t mEqNum_DB[0x8], offset 0x6c>
	uint32_t mEqNum_DB[8];

	// <class EffectSwordLaser* mpSword, offset 0x8c>
	class EffectSwordLaser* mpSword = nullptr;

	// <float mStartTick, offset 0x90>
	float mStartTick = 0;

	// <uint8_t mPause, offset 0x94>
	uint8_t mPause = 0;

	// <uint8_t mPauseNoFrameSkipDisable, offset 0x95>
	uint8_t mPauseNoFrameSkipDisable = 0;

	// <uint8_t mPauseEnd, offset 0x96>
	uint8_t mPauseEnd = 0;

	// <uint8_t mStart, offset 0x97>
	uint8_t mStart = 0;

	// <uint8_t mPressFile, offset 0x98>
	uint8_t mPressFile = 0;

	// <uint8_t mShadowType2, offset 0x99>
	uint8_t mShadowType2 = 0;

	// <uint8_t mDiskErrorSkip, offset 0x9a>
	uint8_t mDiskErrorSkip = 0;

	// <Unidentified data segment, offset 0x9b>
private:
	char _UnidentifiedData_155[1];

public:
	// <class HrSkip* mpSkip, offset 0x9c>
	class HrSkip* mpSkip = nullptr;

	// <uint8_t mDisEnableStatusReturn, offset 0xa0>
	uint8_t mDisEnableStatusReturn = 0;

	// <uint8_t mDebugMenu, offset 0xa1>
	uint8_t mDebugMenu = 0;

	// <Unidentified data segment, offset 0xa2>
private:
	char _UnidentifiedData_162[2];

public:
	// <int32_t mPauseStatus, offset 0xa4>
	int32_t mPauseStatus = 0;

	// <int32_t mEtcProc, offset 0xa8>
	int32_t mEtcProc = 0;

	// <int32_t mNextDemoNo, offset 0xac>
	int32_t mNextDemoNo = 0;

	// <uint8_t mMessageVisible, offset 0xb0>
	uint8_t mMessageVisible = 0;

	// <Unidentified data segment, offset 0xb1>
private:
	char _UnidentifiedData_177[3];

public:
	// <int32_t mFadeCount, offset 0xb4>
	int32_t mFadeCount = 0;

	// <class HrKeyEvent mKeyEvent, offset 0xb8>
	class HrKeyEvent mKeyEvent;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct HRDEMO_DATA [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HRDEMO_DATA& InObject)
	{
		mStatus = InObject.mStatus;
		mNextStatus = InObject.mNextStatus;
		mDemoNum = InObject.mDemoNum;
		mDemoID = InObject.mDemoID;
		mFileptr = InObject.mFileptr;
		Counter = InObject.Counter;
		mpDummyAlloc = InObject.mpDummyAlloc;
		mpRslData = InObject.mpRslData;
		mpRsl = InObject.mpRsl;
		mpRShadowModel = InObject.mpRShadowModel;
		mCurrentID = InObject.mCurrentID;
		mReadID = InObject.mReadID;
		mReadCount = InObject.mReadCount;
		mMotNum = InObject.mMotNum;
		mFileID = InObject.mFileID;
		mInFadeType = InObject.mInFadeType;
		mOutFadeType = InObject.mOutFadeType;
		mInFadeTick = InObject.mInFadeTick;
		mOutFadeTick = InObject.mOutFadeTick;
		mpSword = InObject.mpSword;
		mStartTick = InObject.mStartTick;
		mPause = InObject.mPause;
		mPauseNoFrameSkipDisable = InObject.mPauseNoFrameSkipDisable;
		mPauseEnd = InObject.mPauseEnd;
		mStart = InObject.mStart;
		mPressFile = InObject.mPressFile;
		mShadowType2 = InObject.mShadowType2;
		mDiskErrorSkip = InObject.mDiskErrorSkip;
		mpSkip = InObject.mpSkip;
		mDisEnableStatusReturn = InObject.mDisEnableStatusReturn;
		mDebugMenu = InObject.mDebugMenu;
		mPauseStatus = InObject.mPauseStatus;
		mEtcProc = InObject.mEtcProc;
		mNextDemoNo = InObject.mNextDemoNo;
		mMessageVisible = InObject.mMessageVisible;
		mFadeCount = InObject.mFadeCount;
		mKeyEvent = InObject.mKeyEvent;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HRDEMO_DATA>("HRDEMO_DATA")
			.addFunction("__tostring", &HRDEMO_DATA::ToString)
			.addFunction("GetPtrAddr", &HRDEMO_DATA::GetPtrAddr)
			.addProperty("mStatus", &HRDEMO_DATA::mStatus)
			.addProperty("mNextStatus", &HRDEMO_DATA::mNextStatus)
			.addProperty("mDemoNum", &HRDEMO_DATA::mDemoNum)
			.addProperty("mDemoID", &HRDEMO_DATA::mDemoID)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mFileName", &HRDEMO_DATA::mFileName)
			.addProperty("mFileptr", &HRDEMO_DATA::mFileptr)
			.addProperty("Counter", &HRDEMO_DATA::Counter)
			// void type not supported in LuaBridge
			//.addProperty("mpDummyAlloc", &HRDEMO_DATA::mpDummyAlloc)
			// void type not supported in LuaBridge
			//.addProperty("mpRslData", &HRDEMO_DATA::mpRslData)
			.addProperty("mpRsl", &HRDEMO_DATA::mpRsl)
			.addProperty("mpRShadowModel", &HRDEMO_DATA::mpRShadowModel)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpGan", &HRDEMO_DATA::mpGan)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpMotData", &HRDEMO_DATA::mpMotData)
			.addProperty("mCurrentID", &HRDEMO_DATA::mCurrentID)
			.addProperty("mReadID", &HRDEMO_DATA::mReadID)
			.addProperty("mReadCount", &HRDEMO_DATA::mReadCount)
			.addProperty("mMotNum", &HRDEMO_DATA::mMotNum)
			.addProperty("mFileID", &HRDEMO_DATA::mFileID)
			.addProperty("mInFadeType", &HRDEMO_DATA::mInFadeType)
			.addProperty("mOutFadeType", &HRDEMO_DATA::mOutFadeType)
			.addProperty("mInFadeTick", &HRDEMO_DATA::mInFadeTick)
			.addProperty("mOutFadeTick", &HRDEMO_DATA::mOutFadeTick)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mEqNum_DB", &HRDEMO_DATA::mEqNum_DB)
			.addProperty("mpSword", &HRDEMO_DATA::mpSword)
			.addProperty("mStartTick", &HRDEMO_DATA::mStartTick)
			.addProperty("mPause", &HRDEMO_DATA::mPause)
			.addProperty("mPauseNoFrameSkipDisable", &HRDEMO_DATA::mPauseNoFrameSkipDisable)
			.addProperty("mPauseEnd", &HRDEMO_DATA::mPauseEnd)
			.addProperty("mStart", &HRDEMO_DATA::mStart)
			.addProperty("mPressFile", &HRDEMO_DATA::mPressFile)
			.addProperty("mShadowType2", &HRDEMO_DATA::mShadowType2)
			.addProperty("mDiskErrorSkip", &HRDEMO_DATA::mDiskErrorSkip)
			.addProperty("mpSkip", &HRDEMO_DATA::mpSkip)
			.addProperty("mDisEnableStatusReturn", &HRDEMO_DATA::mDisEnableStatusReturn)
			.addProperty("mDebugMenu", &HRDEMO_DATA::mDebugMenu)
			.addProperty("mPauseStatus", &HRDEMO_DATA::mPauseStatus)
			.addProperty("mEtcProc", &HRDEMO_DATA::mEtcProc)
			.addProperty("mNextDemoNo", &HRDEMO_DATA::mNextDemoNo)
			.addProperty("mMessageVisible", &HRDEMO_DATA::mMessageVisible)
			.addProperty("mFadeCount", &HRDEMO_DATA::mFadeCount)
			.addProperty("mKeyEvent", &HRDEMO_DATA::mKeyEvent)
		.endClass();
	}
#endif
};
static_assert(sizeof(HRDEMO_DATA::mStatus) == 4, "expected HRDEMO_DATA::mStatus to be size 4");
static_assert(sizeof(HRDEMO_DATA::mNextStatus) == 4, "expected HRDEMO_DATA::mNextStatus to be size 4");
static_assert(sizeof(HRDEMO_DATA::mDemoNum) == 4, "expected HRDEMO_DATA::mDemoNum to be size 4");
static_assert(sizeof(HRDEMO_DATA::mDemoID) == 4, "expected HRDEMO_DATA::mDemoID to be size 4");
static_assert(sizeof(HRDEMO_DATA::mFileName) == 16, "expected HRDEMO_DATA::mFileName to be size 16");
static_assert(sizeof(HRDEMO_DATA::mFileptr) == 4, "expected HRDEMO_DATA::mFileptr to be size 4");
static_assert(sizeof(HRDEMO_DATA::Counter) == 4, "expected HRDEMO_DATA::Counter to be size 4");
static_assert(sizeof(HRDEMO_DATA::mpDummyAlloc) == 4, "expected HRDEMO_DATA::mpDummyAlloc to be size 4");
static_assert(sizeof(HRDEMO_DATA::mpRslData) == 4, "expected HRDEMO_DATA::mpRslData to be size 4");
static_assert(sizeof(HRDEMO_DATA::mpRsl) == 4, "expected HRDEMO_DATA::mpRsl to be size 4");
static_assert(sizeof(HRDEMO_DATA::mpRShadowModel) == 4, "expected HRDEMO_DATA::mpRShadowModel to be size 4");
static_assert(sizeof(HRDEMO_DATA::mpGan) == 8, "expected HRDEMO_DATA::mpGan to be size 8");
static_assert(sizeof(HRDEMO_DATA::mpMotData) == 8, "expected HRDEMO_DATA::mpMotData to be size 8");
static_assert(sizeof(HRDEMO_DATA::mCurrentID) == 4, "expected HRDEMO_DATA::mCurrentID to be size 4");
static_assert(sizeof(HRDEMO_DATA::mReadID) == 4, "expected HRDEMO_DATA::mReadID to be size 4");
static_assert(sizeof(HRDEMO_DATA::mReadCount) == 4, "expected HRDEMO_DATA::mReadCount to be size 4");
static_assert(sizeof(HRDEMO_DATA::mMotNum) == 4, "expected HRDEMO_DATA::mMotNum to be size 4");
static_assert(sizeof(HRDEMO_DATA::mFileID) == 4, "expected HRDEMO_DATA::mFileID to be size 4");
static_assert(sizeof(HRDEMO_DATA::mInFadeType) == 4, "expected HRDEMO_DATA::mInFadeType to be size 4");
static_assert(sizeof(HRDEMO_DATA::mOutFadeType) == 4, "expected HRDEMO_DATA::mOutFadeType to be size 4");
static_assert(sizeof(HRDEMO_DATA::mInFadeTick) == 4, "expected HRDEMO_DATA::mInFadeTick to be size 4");
static_assert(sizeof(HRDEMO_DATA::mOutFadeTick) == 4, "expected HRDEMO_DATA::mOutFadeTick to be size 4");
static_assert(sizeof(HRDEMO_DATA::mEqNum_DB) == 32, "expected HRDEMO_DATA::mEqNum_DB to be size 32");
static_assert(sizeof(HRDEMO_DATA::mpSword) == 4, "expected HRDEMO_DATA::mpSword to be size 4");
static_assert(sizeof(HRDEMO_DATA::mStartTick) == 4, "expected HRDEMO_DATA::mStartTick to be size 4");
static_assert(sizeof(HRDEMO_DATA::mPause) == 1, "expected HRDEMO_DATA::mPause to be size 1");
static_assert(sizeof(HRDEMO_DATA::mPauseNoFrameSkipDisable) == 1, "expected HRDEMO_DATA::mPauseNoFrameSkipDisable to be size 1");
static_assert(sizeof(HRDEMO_DATA::mPauseEnd) == 1, "expected HRDEMO_DATA::mPauseEnd to be size 1");
static_assert(sizeof(HRDEMO_DATA::mStart) == 1, "expected HRDEMO_DATA::mStart to be size 1");
static_assert(sizeof(HRDEMO_DATA::mPressFile) == 1, "expected HRDEMO_DATA::mPressFile to be size 1");
static_assert(sizeof(HRDEMO_DATA::mShadowType2) == 1, "expected HRDEMO_DATA::mShadowType2 to be size 1");
static_assert(sizeof(HRDEMO_DATA::mDiskErrorSkip) == 1, "expected HRDEMO_DATA::mDiskErrorSkip to be size 1");
static_assert(sizeof(HRDEMO_DATA::mpSkip) == 4, "expected HRDEMO_DATA::mpSkip to be size 4");
static_assert(sizeof(HRDEMO_DATA::mDisEnableStatusReturn) == 1, "expected HRDEMO_DATA::mDisEnableStatusReturn to be size 1");
static_assert(sizeof(HRDEMO_DATA::mDebugMenu) == 1, "expected HRDEMO_DATA::mDebugMenu to be size 1");
static_assert(sizeof(HRDEMO_DATA::mPauseStatus) == 4, "expected HRDEMO_DATA::mPauseStatus to be size 4");
static_assert(sizeof(HRDEMO_DATA::mEtcProc) == 4, "expected HRDEMO_DATA::mEtcProc to be size 4");
static_assert(sizeof(HRDEMO_DATA::mNextDemoNo) == 4, "expected HRDEMO_DATA::mNextDemoNo to be size 4");
static_assert(sizeof(HRDEMO_DATA::mMessageVisible) == 1, "expected HRDEMO_DATA::mMessageVisible to be size 1");
static_assert(sizeof(HRDEMO_DATA::mFadeCount) == 4, "expected HRDEMO_DATA::mFadeCount to be size 4");
static_assert(sizeof(HRDEMO_DATA::mKeyEvent) == 40, "expected HRDEMO_DATA::mKeyEvent to be size 40");
static_assert(sizeof(HRDEMO_DATA) == 0xe0, "expected HRDEMO_DATA to be size 0xe0");

// [Structure] class EffectSwordLaser
class EffectSwordLaser
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[164];

public:
	// <uint32_t Color, offset 0xa4>
	uint32_t Color = 0;

	// <Unidentified data segment, offset 0xa8>
private:
	char _UnidentifiedData_168[1584];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectSwordLaser [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectSwordLaser& InObject)
	{
		Color = InObject.Color;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectSwordLaser>("EffectSwordLaser")
			.addFunction("__tostring", &EffectSwordLaser::ToString)
			.addFunction("GetPtrAddr", &EffectSwordLaser::GetPtrAddr)
			.addProperty("Color", &EffectSwordLaser::Color)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSwordLaser::Color) == 4, "expected EffectSwordLaser::Color to be size 4");
static_assert(sizeof(EffectSwordLaser) == 0x6d8, "expected EffectSwordLaser to be size 0x6d8");

// [Structure] class HrDemoObj
class HrDemoObj : public ghmListObj
{
public:
	// enum HrDemoObj::HRDEMOOBJ_ID
	enum HRDEMOOBJ_ID : uint32_t
	{
		// <HRDEMOOBJ_NONE = 0x0>
		HRDEMOOBJ_NONE = 0,

		// <HRDEMOOBJ_MESSAGE = 0x1>
		HRDEMOOBJ_MESSAGE = 1,

		// <HRDEMOOBJ_TRV = 0x2>
		HRDEMOOBJ_TRV = 2,

		// <HRDEMOOBJ_MODEL = 0x3>
		HRDEMOOBJ_MODEL = 3,

		// <HRDEMOOBJ_CAMERA = 0x4>
		HRDEMOOBJ_CAMERA = 4,

		// <HRDEMOOBJ_SOUND = 0x5>
		HRDEMOOBJ_SOUND = 5,

		// <HRDEMOOBJ_EFFECT = 0x6>
		HRDEMOOBJ_EFFECT = 6,

		// <HRDEMOOBJ_MAX = 0x7>
		HRDEMOOBJ_MAX = 7

	};

	// enum HrDemoObj::HRDEMOOBJ_STS
	enum HRDEMOOBJ_STS : uint32_t
	{
		// <HRDEMOOBJ_STS_INIT = 0x0>
		HRDEMOOBJ_STS_INIT = 0,

		// <HRDEMOOBJ_STS_SET = 0x1>
		HRDEMOOBJ_STS_SET = 1,

		// <HRDEMOOBJ_STS_LOAD = 0x2>
		HRDEMOOBJ_STS_LOAD = 2,

		// <HRDEMOOBJ_STS_PRE_STANDBY = 0x3>
		HRDEMOOBJ_STS_PRE_STANDBY = 3,

		// <HRDEMOOBJ_STS_STANDBY = 0x4>
		HRDEMOOBJ_STS_STANDBY = 4,

		// <HRDEMOOBJ_STS_START = 0x5>
		HRDEMOOBJ_STS_START = 5,

		// <HRDEMOOBJ_STS_DOING = 0x6>
		HRDEMOOBJ_STS_DOING = 6,

		// <HRDEMOOBJ_STS_PAUSE = 0x7>
		HRDEMOOBJ_STS_PAUSE = 7,

		// <HRDEMOOBJ_STS_FINISH = 0x8>
		HRDEMOOBJ_STS_FINISH = 8,

		// <HRDEMOOBJ_STS_DESTROY = 0x9>
		HRDEMOOBJ_STS_DESTROY = 9,

		// <HRDEMOOBJ_STS_MAX = 0xa>
		HRDEMOOBJ_STS_MAX = 10

	};

	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <enum HrDemoObj::HRDEMOOBJ_ID mKind, offset 0x10>
	enum HrDemoObj::HRDEMOOBJ_ID mKind;

	// <enum HrDemoObj::HRDEMOOBJ_STS mStatus, offset 0x14>
	enum HrDemoObj::HRDEMOOBJ_STS mStatus;

	// <float mStartTick, offset 0x18>
	float mStartTick = 0;

	// <char mName[0x10], offset 0x1c>
	char mName[16];

	// <int32_t mFinishDelay, offset 0x2c>
	int32_t mFinishDelay = 0;

	// <uint8_t mbDrawMirror, offset 0x30>
	uint8_t mbDrawMirror = 0;

	// <uint8_t mbShadowDraw, offset 0x31>
	uint8_t mbShadowDraw = 0;

	// <uint8_t mbVisible, offset 0x32>
	uint8_t mbVisible = 0;

	// <Unidentified data segment, offset 0x33>
private:
	char _UnidentifiedData_51[1];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrDemoObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrDemoObj& InObject)
	{
		mKind = InObject.mKind;
		mStatus = InObject.mStatus;
		mStartTick = InObject.mStartTick;
		mFinishDelay = InObject.mFinishDelay;
		mbDrawMirror = InObject.mbDrawMirror;
		mbShadowDraw = InObject.mbShadowDraw;
		mbVisible = InObject.mbVisible;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrDemoObj, ghmListObj>("HrDemoObj")
			.addFunction("__tostring", &HrDemoObj::ToString)
			.addFunction("GetPtrAddr", &HrDemoObj::GetPtrAddr)
			.addProperty("mKind", &HrDemoObj::mKind)
			.addProperty("mStatus", &HrDemoObj::mStatus)
			.addProperty("mStartTick", &HrDemoObj::mStartTick)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mName", &HrDemoObj::mName)
			.addProperty("mFinishDelay", &HrDemoObj::mFinishDelay)
			.addProperty("mbDrawMirror", &HrDemoObj::mbDrawMirror)
			.addProperty("mbShadowDraw", &HrDemoObj::mbShadowDraw)
			.addProperty("mbVisible", &HrDemoObj::mbVisible)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrDemoObj::mKind) == 4, "expected HrDemoObj::mKind to be size 4");
static_assert(sizeof(HrDemoObj::mStatus) == 4, "expected HrDemoObj::mStatus to be size 4");
static_assert(sizeof(HrDemoObj::mStartTick) == 4, "expected HrDemoObj::mStartTick to be size 4");
static_assert(sizeof(HrDemoObj::mName) == 16, "expected HrDemoObj::mName to be size 16");
static_assert(sizeof(HrDemoObj::mFinishDelay) == 4, "expected HrDemoObj::mFinishDelay to be size 4");
static_assert(sizeof(HrDemoObj::mbDrawMirror) == 1, "expected HrDemoObj::mbDrawMirror to be size 1");
static_assert(sizeof(HrDemoObj::mbShadowDraw) == 1, "expected HrDemoObj::mbShadowDraw to be size 1");
static_assert(sizeof(HrDemoObj::mbVisible) == 1, "expected HrDemoObj::mbVisible to be size 1");
static_assert(sizeof(HrDemoObj) == 0x34, "expected HrDemoObj to be size 0x34");

// [Structure] class HrDemoMessage
class HrDemoMessage : public HrDemoObj
{
public:
	/// Struct member variables

	// <class HrDemoObj field_0, offset 0x0>
	// class HrDemoObj Super;

	// <uint32_t mMessHndl, offset 0x34>
	uint32_t mMessHndl = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrDemoMessage [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrDemoMessage& InObject)
	{
		mMessHndl = InObject.mMessHndl;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrDemoMessage, HrDemoObj>("HrDemoMessage")
			.addFunction("__tostring", &HrDemoMessage::ToString)
			.addFunction("GetPtrAddr", &HrDemoMessage::GetPtrAddr)
			.addProperty("mMessHndl", &HrDemoMessage::mMessHndl)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrDemoMessage::mMessHndl) == 4, "expected HrDemoMessage::mMessHndl to be size 4");
static_assert(sizeof(HrDemoMessage) == 0x38, "expected HrDemoMessage to be size 0x38");

// Unsupported constructor
//void __convention("thiscall") HrDemoMessage::HrDemoMessage(class HrDemoMessage* const this, class ghmResGroup* arg2)
// [Structure] class hList<hEffPacket>
template<typename T>
class hList
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class hEffPacket* mTop, offset 0x4>
	T* mTop = nullptr;

	// <class hEffPacket* mEnd, offset 0x8>
	T* mEnd = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hList [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hList<hEffPacket>& InObject)
	{
		mTop = InObject.mTop;
		mEnd = InObject.mEnd;
	}
	// Exporting templated types to Lua currently not supported.
	// static void BindLua(luabridge::Namespace& NS)
};
static_assert(sizeof(hList<hEffPacket>::field_0) == 4, "expected hList<hEffPacket>::field_0 to be size 4");
static_assert(sizeof(hList<hEffPacket>::mTop) == 4, "expected hList<hEffPacket>::mTop to be size 4");
static_assert(sizeof(hList<hEffPacket>::mEnd) == 4, "expected hList<hEffPacket>::mEnd to be size 4");
static_assert(sizeof(hList<hEffPacket>) == 0xc, "expected hList<hEffPacket> to be size 0xc");

// [Structure] class hEffectManager
class hEffectManager : public hList<hEffPacket>
{
public:
	/// Struct member variables

	// <class hList<hEffPacket> field_0, offset 0x0>
	// class hList<hEffPacket> Super;

	// <uint8_t mbFook, offset 0xc>
	uint8_t mbFook = 0;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData_13[3];

public:
	// <int64_t mFookName, offset 0x10>
	int64_t mFookName;

	// <class hEffect* mFookEffPtr, offset 0x18>
	class hEffect* mFookEffPtr = nullptr;

	// <Unidentified data segment, offset 0x1c>
private:
	char _UnidentifiedData_28[4];

public:
	/// 1 Functions

	// [Function] void __convention("thiscall") hEffectManager::PlayEffect(class hEffectManager* const this, struct STHrEffect* pEff, class TGmf* pWeaponNode, class ghmResGroup* pRes) [?PlayEffect@hEffectManager@@QAEXPAUSTHrEffect@@PAVTGmf@@PAVghmResGroup@@@Z]
	typedef void(__thiscall* _PlayEffect_hEffectManager__QAEXPAUSTHrEffect__PAVTGmf__PAVghmResGroup___Z)(class hEffectManager* const thisPtr, struct STHrEffect* pEff, class TGmf* pWeaponNode, class ghmResGroup* pRes);
	void PlayEffect(struct STHrEffect* pEff, class TGmf* pWeaponNode, class ghmResGroup* pRes)
	{
		_PlayEffect_hEffectManager__QAEXPAUSTHrEffect__PAVTGmf__PAVghmResGroup___Z mFunc = (_PlayEffect_hEffectManager__QAEXPAUSTHrEffect__PAVTGmf__PAVghmResGroup___Z)(GameModule + 0x482840);
		return mFunc(this, pEff, pWeaponNode, pRes);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hEffectManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hEffectManager& InObject)
	{
		mbFook = InObject.mbFook;
		mFookName = InObject.mFookName;
		mFookEffPtr = InObject.mFookEffPtr;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hEffectManager>("hEffectManager")
			.addFunction("__tostring", &hEffectManager::ToString)
			.addFunction("GetPtrAddr", &hEffectManager::GetPtrAddr)
			.addProperty("mbFook", &hEffectManager::mbFook)
			.addProperty("mFookName", &hEffectManager::mFookName)
			.addProperty("mFookEffPtr", &hEffectManager::mFookEffPtr)
			.addFunction("PlayEffect", &hEffectManager::PlayEffect)
		.endClass();
	}
#endif
};
static_assert(sizeof(hEffectManager::mbFook) == 1, "expected hEffectManager::mbFook to be size 1");
static_assert(sizeof(hEffectManager::mFookName) == 8, "expected hEffectManager::mFookName to be size 8");
static_assert(sizeof(hEffectManager::mFookEffPtr) == 4, "expected hEffectManager::mFookEffPtr to be size 4");
static_assert(sizeof(hEffectManager) == 0x20, "expected hEffectManager to be size 0x20");

// [Structure] class HrMiniDemoEffect
class HrMiniDemoEffect : public HrMiniDemoObj
{
public:
	/// Struct member variables

	// <class HrMiniDemoObj field_0, offset 0x0>
	// class HrMiniDemoObj Super;

	// <class TGanPlay* mpGanPlay, offset 0x50>
	class TGanPlay* mpGanPlay = nullptr;

	// <struct WGanNodeSpec* mpGanNodeSpec, offset 0x54>
	struct WGanNodeSpec* mpGanNodeSpec = nullptr;

	// <class ghmResGroup* mpRes, offset 0x58>
	class ghmResGroup* mpRes = nullptr;

	// <struct STHrEffect* mpEff, offset 0x5c>
	struct STHrEffect* mpEff = nullptr;

	// <int32_t mEffNum, offset 0x60>
	int32_t mEffNum = 0;

	// <Unidentified data segment, offset 0x64>
private:
	char _UnidentifiedData_100[4];

public:
	// <class hEffectManager mEffectManager, offset 0x68>
	class hEffectManager mEffectManager;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMiniDemoEffect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMiniDemoEffect& InObject)
	{
		mpGanPlay = InObject.mpGanPlay;
		mpGanNodeSpec = InObject.mpGanNodeSpec;
		mpRes = InObject.mpRes;
		mpEff = InObject.mpEff;
		mEffNum = InObject.mEffNum;
		mEffectManager = InObject.mEffectManager;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMiniDemoEffect, HrMiniDemoObj>("HrMiniDemoEffect")
			.addFunction("__tostring", &HrMiniDemoEffect::ToString)
			.addFunction("GetPtrAddr", &HrMiniDemoEffect::GetPtrAddr)
			.addProperty("mpGanPlay", &HrMiniDemoEffect::mpGanPlay)
			.addProperty("mpGanNodeSpec", &HrMiniDemoEffect::mpGanNodeSpec)
			.addProperty("mpRes", &HrMiniDemoEffect::mpRes)
			.addProperty("mpEff", &HrMiniDemoEffect::mpEff)
			.addProperty("mEffNum", &HrMiniDemoEffect::mEffNum)
			.addProperty("mEffectManager", &HrMiniDemoEffect::mEffectManager)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemoEffect::mpGanPlay) == 4, "expected HrMiniDemoEffect::mpGanPlay to be size 4");
static_assert(sizeof(HrMiniDemoEffect::mpGanNodeSpec) == 4, "expected HrMiniDemoEffect::mpGanNodeSpec to be size 4");
static_assert(sizeof(HrMiniDemoEffect::mpRes) == 4, "expected HrMiniDemoEffect::mpRes to be size 4");
static_assert(sizeof(HrMiniDemoEffect::mpEff) == 4, "expected HrMiniDemoEffect::mpEff to be size 4");
static_assert(sizeof(HrMiniDemoEffect::mEffNum) == 4, "expected HrMiniDemoEffect::mEffNum to be size 4");
static_assert(sizeof(HrMiniDemoEffect::mEffectManager) == 32, "expected HrMiniDemoEffect::mEffectManager to be size 32");
static_assert(sizeof(HrMiniDemoEffect) == 0x88, "expected HrMiniDemoEffect to be size 0x88");

// Unsupported constructor
//void __convention("thiscall") HrMiniDemoEffect::HrMiniDemoEffect(class HrMiniDemoEffect* const this, class TGan* arg2, class ghmResGroup* arg3)
// [Structure] struct STHrEffect
struct STHrEffect
{
public:
	/// Struct member variables

	// <class TGanPlayNode* tpGanPlayNode, offset 0x0>
	class TGanPlayNode* tpGanPlayNode = nullptr;

	// <class HrTask* tpTask, offset 0x4>
	class HrTask* tpTask = nullptr;

	// <struct Vec tPos, offset 0x8>
	struct Vec tPos;

	// <struct Vec tDir, offset 0x14>
	struct Vec tDir;

	// <struct Vec tScale, offset 0x20>
	struct Vec tScale;

	// <uint8_t tGanName[0x9], offset 0x2c>
	uint8_t tGanName[9];

	// <Unidentified data segment, offset 0x35>
private:
	char _UnidentifiedData_53[3];

public:
	// <int32_t tEffNo, offset 0x38>
	int32_t tEffNo = 0;

	// <uint8_t tVisible, offset 0x3c>
	uint8_t tVisible = 0;

	// <Unidentified data segment, offset 0x3d>
private:
	char _UnidentifiedData_61[3];

public:
	// <class ghmResGroup* tpEffectRes, offset 0x40>
	class ghmResGroup* tpEffectRes = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct STHrEffect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(STHrEffect& InObject)
	{
		tpGanPlayNode = InObject.tpGanPlayNode;
		tpTask = InObject.tpTask;
		tPos = InObject.tPos;
		tDir = InObject.tDir;
		tScale = InObject.tScale;
		tEffNo = InObject.tEffNo;
		tVisible = InObject.tVisible;
		tpEffectRes = InObject.tpEffectRes;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<STHrEffect>("STHrEffect")
			.addFunction("__tostring", &STHrEffect::ToString)
			.addFunction("GetPtrAddr", &STHrEffect::GetPtrAddr)
			.addProperty("tpGanPlayNode", &STHrEffect::tpGanPlayNode)
			.addProperty("tpTask", &STHrEffect::tpTask)
			.addProperty("tPos", &STHrEffect::tPos)
			.addProperty("tDir", &STHrEffect::tDir)
			.addProperty("tScale", &STHrEffect::tScale)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("tGanName", &STHrEffect::tGanName)
			.addProperty("tEffNo", &STHrEffect::tEffNo)
			.addProperty("tVisible", &STHrEffect::tVisible)
			.addProperty("tpEffectRes", &STHrEffect::tpEffectRes)
		.endClass();
	}
#endif
};
static_assert(sizeof(STHrEffect::tpGanPlayNode) == 4, "expected STHrEffect::tpGanPlayNode to be size 4");
static_assert(sizeof(STHrEffect::tpTask) == 4, "expected STHrEffect::tpTask to be size 4");
static_assert(sizeof(STHrEffect::tPos) == 12, "expected STHrEffect::tPos to be size 12");
static_assert(sizeof(STHrEffect::tDir) == 12, "expected STHrEffect::tDir to be size 12");
static_assert(sizeof(STHrEffect::tScale) == 12, "expected STHrEffect::tScale to be size 12");
static_assert(sizeof(STHrEffect::tGanName) == 9, "expected STHrEffect::tGanName to be size 9");
static_assert(sizeof(STHrEffect::tEffNo) == 4, "expected STHrEffect::tEffNo to be size 4");
static_assert(sizeof(STHrEffect::tVisible) == 1, "expected STHrEffect::tVisible to be size 1");
static_assert(sizeof(STHrEffect::tpEffectRes) == 4, "expected STHrEffect::tpEffectRes to be size 4");
static_assert(sizeof(STHrEffect) == 0x44, "expected STHrEffect to be size 0x44");

// [Structure] class hListObj<hEffPacket>
template<typename T>
class hListObj
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class hEffPacket* mPrev, offset 0x4>
	T* mPrev = nullptr;

	// <class hEffPacket* mNext, offset 0x8>
	T* mNext = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hListObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hListObj<hEffPacket>& InObject)
	{
		mPrev = InObject.mPrev;
		mNext = InObject.mNext;
	}
	// Exporting templated types to Lua currently not supported.
	// static void BindLua(luabridge::Namespace& NS)
};
static_assert(sizeof(hListObj<hEffPacket>::field_0) == 4, "expected hListObj<hEffPacket>::field_0 to be size 4");
static_assert(sizeof(hListObj<hEffPacket>::mPrev) == 4, "expected hListObj<hEffPacket>::mPrev to be size 4");
static_assert(sizeof(hListObj<hEffPacket>::mNext) == 4, "expected hListObj<hEffPacket>::mNext to be size 4");
static_assert(sizeof(hListObj<hEffPacket>) == 0xc, "expected hListObj<hEffPacket> to be size 0xc");

// [Structure] class hEffPacket
class hEffPacket : public hListObj<hEffPacket>
{
public:
	/// Struct member variables

	// <class hListObj<hEffPacket> field_0, offset 0x0>
	// class hListObj<hEffPacket> Super;

	// <int32_t mID, offset 0xc>
	int32_t mID = 0;

	// <struct STHrEffect* mEffstr, offset 0x10>
	struct STHrEffect* mEffstr = nullptr;

	// <void* mEffPtr, offset 0x14>
	void* mEffPtr = nullptr;

	// <class HrTask* mTaskPtr, offset 0x18>
	class HrTask* mTaskPtr = nullptr;

	// <struct tagHRTASKCHECK mTaskCheck, offset 0x1c>
	struct tagHRTASKCHECK mTaskCheck;

	// <class TGmf* mNode, offset 0x24>
	class TGmf* mNode = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hEffPacket [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hEffPacket& InObject)
	{
		mID = InObject.mID;
		mEffstr = InObject.mEffstr;
		mEffPtr = InObject.mEffPtr;
		mTaskPtr = InObject.mTaskPtr;
		mTaskCheck = InObject.mTaskCheck;
		mNode = InObject.mNode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hEffPacket>("hEffPacket")
			.addFunction("__tostring", &hEffPacket::ToString)
			.addFunction("GetPtrAddr", &hEffPacket::GetPtrAddr)
			.addProperty("mID", &hEffPacket::mID)
			.addProperty("mEffstr", &hEffPacket::mEffstr)
			// void type not supported in LuaBridge
			//.addProperty("mEffPtr", &hEffPacket::mEffPtr)
			.addProperty("mTaskPtr", &hEffPacket::mTaskPtr)
			.addProperty("mTaskCheck", &hEffPacket::mTaskCheck)
			.addProperty("mNode", &hEffPacket::mNode)
		.endClass();
	}
#endif
};
static_assert(sizeof(hEffPacket::mID) == 4, "expected hEffPacket::mID to be size 4");
static_assert(sizeof(hEffPacket::mEffstr) == 4, "expected hEffPacket::mEffstr to be size 4");
static_assert(sizeof(hEffPacket::mEffPtr) == 4, "expected hEffPacket::mEffPtr to be size 4");
static_assert(sizeof(hEffPacket::mTaskPtr) == 4, "expected hEffPacket::mTaskPtr to be size 4");
static_assert(sizeof(hEffPacket::mTaskCheck) == 8, "expected hEffPacket::mTaskCheck to be size 8");
static_assert(sizeof(hEffPacket::mNode) == 4, "expected hEffPacket::mNode to be size 4");
static_assert(sizeof(hEffPacket) == 0x28, "expected hEffPacket to be size 0x28");

// [Structure] class hEffect
class hEffect
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <char mEffectHeader[0x4], offset 0x4>
	char mEffectHeader[4];

	// <uint32_t mEffectVer, offset 0x8>
	uint32_t mEffectVer = 0;

	// <class hEffectLayer* mLayer, offset 0xc>
	class hEffectLayer* mLayer = nullptr;

	// <int32_t mLayerNum, offset 0x10>
	int32_t mLayerNum = 0;

	// <struct Vec* mLocaterPos, offset 0x14>
	struct Vec* mLocaterPos = nullptr;

	// <struct Vec* mLocaterDir, offset 0x18>
	struct Vec* mLocaterDir = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hEffect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hEffect& InObject)
	{
		mEffectVer = InObject.mEffectVer;
		mLayer = InObject.mLayer;
		mLayerNum = InObject.mLayerNum;
		mLocaterPos = InObject.mLocaterPos;
		mLocaterDir = InObject.mLocaterDir;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hEffect>("hEffect")
			.addFunction("__tostring", &hEffect::ToString)
			.addFunction("GetPtrAddr", &hEffect::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &hEffect::field_0)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mEffectHeader", &hEffect::mEffectHeader)
			.addProperty("mEffectVer", &hEffect::mEffectVer)
			.addProperty("mLayer", &hEffect::mLayer)
			.addProperty("mLayerNum", &hEffect::mLayerNum)
			.addProperty("mLocaterPos", &hEffect::mLocaterPos)
			.addProperty("mLocaterDir", &hEffect::mLocaterDir)
		.endClass();
	}
#endif
};
static_assert(sizeof(hEffect::field_0) == 4, "expected hEffect::field_0 to be size 4");
static_assert(sizeof(hEffect::mEffectHeader) == 4, "expected hEffect::mEffectHeader to be size 4");
static_assert(sizeof(hEffect::mEffectVer) == 4, "expected hEffect::mEffectVer to be size 4");
static_assert(sizeof(hEffect::mLayer) == 4, "expected hEffect::mLayer to be size 4");
static_assert(sizeof(hEffect::mLayerNum) == 4, "expected hEffect::mLayerNum to be size 4");
static_assert(sizeof(hEffect::mLocaterPos) == 4, "expected hEffect::mLocaterPos to be size 4");
static_assert(sizeof(hEffect::mLocaterDir) == 4, "expected hEffect::mLocaterDir to be size 4");
static_assert(sizeof(hEffect) == 0x1c, "expected hEffect to be size 0x1c");

// [Structure] class hEffectLayer
class hEffectLayer
{
public:
	/// Struct member variables

	// <uint16_t mEffectFrame, offset 0x0>
	uint16_t mEffectFrame = 0;

	// <uint16_t mEffectKeyNum, offset 0x2>
	uint16_t mEffectKeyNum = 0;

	// <uint16_t mPerticleFrame, offset 0x4>
	uint16_t mPerticleFrame = 0;

	// <uint16_t mPerticleKeyNum, offset 0x6>
	uint16_t mPerticleKeyNum = 0;

	// <struct hEffectKey* mpEffectKey, offset 0x8>
	struct hEffectKey* mpEffectKey = nullptr;

	// <struct hPerticleKey* mpPerticleKey, offset 0xc>
	struct hPerticleKey* mpPerticleKey = nullptr;

	// <int32_t mState, offset 0x10>
	int32_t mState = 0;

	// <uint16_t mNowKey, offset 0x14>
	uint16_t mNowKey = 0;

	// <uint16_t mFrameCnt, offset 0x16>
	uint16_t mFrameCnt = 0;

	// <struct Vec mPos, offset 0x18>
	struct Vec mPos;

	// <struct Vec* mLocaterPos, offset 0x24>
	struct Vec* mLocaterPos = nullptr;

	// <struct Vec* mLocaterDir, offset 0x28>
	struct Vec* mLocaterDir = nullptr;

	// <class hPerticle* mpPerticle, offset 0x2c>
	class hPerticle* mpPerticle = nullptr;

	// <struct tagGHMR_TEX* mpTexture, offset 0x30>
	struct tagGHMR_TEX* mpTexture = nullptr;

	// <int32_t mTexIndex, offset 0x34>
	int32_t mTexIndex = 0;

	// <class hAnimTex* mpAnimPattern, offset 0x38>
	class hAnimTex* mpAnimPattern = nullptr;

	// <int32_t mAnimPatIndex, offset 0x3c>
	int32_t mAnimPatIndex = 0;

	// <class hPerticle* mTop, offset 0x40>
	class hPerticle* mTop = nullptr;

	// <class hPerticle* mEnd, offset 0x44>
	class hPerticle* mEnd = nullptr;

	// <int32_t mPerticleNum, offset 0x48>
	int32_t mPerticleNum = 0;

	// <float mLocalMat[0x3][0x4], offset 0x4c>
	float mLocalMat[3][4];

	// <uint32_t mFlag, offset 0x7c>
	uint32_t mFlag = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hEffectLayer [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hEffectLayer& InObject)
	{
		mEffectFrame = InObject.mEffectFrame;
		mEffectKeyNum = InObject.mEffectKeyNum;
		mPerticleFrame = InObject.mPerticleFrame;
		mPerticleKeyNum = InObject.mPerticleKeyNum;
		mpEffectKey = InObject.mpEffectKey;
		mpPerticleKey = InObject.mpPerticleKey;
		mState = InObject.mState;
		mNowKey = InObject.mNowKey;
		mFrameCnt = InObject.mFrameCnt;
		mPos = InObject.mPos;
		mLocaterPos = InObject.mLocaterPos;
		mLocaterDir = InObject.mLocaterDir;
		mpPerticle = InObject.mpPerticle;
		mpTexture = InObject.mpTexture;
		mTexIndex = InObject.mTexIndex;
		mpAnimPattern = InObject.mpAnimPattern;
		mAnimPatIndex = InObject.mAnimPatIndex;
		mTop = InObject.mTop;
		mEnd = InObject.mEnd;
		mPerticleNum = InObject.mPerticleNum;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hEffectLayer>("hEffectLayer")
			.addFunction("__tostring", &hEffectLayer::ToString)
			.addFunction("GetPtrAddr", &hEffectLayer::GetPtrAddr)
			.addProperty("mEffectFrame", &hEffectLayer::mEffectFrame)
			.addProperty("mEffectKeyNum", &hEffectLayer::mEffectKeyNum)
			.addProperty("mPerticleFrame", &hEffectLayer::mPerticleFrame)
			.addProperty("mPerticleKeyNum", &hEffectLayer::mPerticleKeyNum)
			.addProperty("mpEffectKey", &hEffectLayer::mpEffectKey)
			.addProperty("mpPerticleKey", &hEffectLayer::mpPerticleKey)
			.addProperty("mState", &hEffectLayer::mState)
			.addProperty("mNowKey", &hEffectLayer::mNowKey)
			.addProperty("mFrameCnt", &hEffectLayer::mFrameCnt)
			.addProperty("mPos", &hEffectLayer::mPos)
			.addProperty("mLocaterPos", &hEffectLayer::mLocaterPos)
			.addProperty("mLocaterDir", &hEffectLayer::mLocaterDir)
			.addProperty("mpPerticle", &hEffectLayer::mpPerticle)
			.addProperty("mpTexture", &hEffectLayer::mpTexture)
			.addProperty("mTexIndex", &hEffectLayer::mTexIndex)
			.addProperty("mpAnimPattern", &hEffectLayer::mpAnimPattern)
			.addProperty("mAnimPatIndex", &hEffectLayer::mAnimPatIndex)
			.addProperty("mTop", &hEffectLayer::mTop)
			.addProperty("mEnd", &hEffectLayer::mEnd)
			.addProperty("mPerticleNum", &hEffectLayer::mPerticleNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mLocalMat", &hEffectLayer::mLocalMat)
			.addProperty("mFlag", &hEffectLayer::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(hEffectLayer::mEffectFrame) == 2, "expected hEffectLayer::mEffectFrame to be size 2");
static_assert(sizeof(hEffectLayer::mEffectKeyNum) == 2, "expected hEffectLayer::mEffectKeyNum to be size 2");
static_assert(sizeof(hEffectLayer::mPerticleFrame) == 2, "expected hEffectLayer::mPerticleFrame to be size 2");
static_assert(sizeof(hEffectLayer::mPerticleKeyNum) == 2, "expected hEffectLayer::mPerticleKeyNum to be size 2");
static_assert(sizeof(hEffectLayer::mpEffectKey) == 4, "expected hEffectLayer::mpEffectKey to be size 4");
static_assert(sizeof(hEffectLayer::mpPerticleKey) == 4, "expected hEffectLayer::mpPerticleKey to be size 4");
static_assert(sizeof(hEffectLayer::mState) == 4, "expected hEffectLayer::mState to be size 4");
static_assert(sizeof(hEffectLayer::mNowKey) == 2, "expected hEffectLayer::mNowKey to be size 2");
static_assert(sizeof(hEffectLayer::mFrameCnt) == 2, "expected hEffectLayer::mFrameCnt to be size 2");
static_assert(sizeof(hEffectLayer::mPos) == 12, "expected hEffectLayer::mPos to be size 12");
static_assert(sizeof(hEffectLayer::mLocaterPos) == 4, "expected hEffectLayer::mLocaterPos to be size 4");
static_assert(sizeof(hEffectLayer::mLocaterDir) == 4, "expected hEffectLayer::mLocaterDir to be size 4");
static_assert(sizeof(hEffectLayer::mpPerticle) == 4, "expected hEffectLayer::mpPerticle to be size 4");
static_assert(sizeof(hEffectLayer::mpTexture) == 4, "expected hEffectLayer::mpTexture to be size 4");
static_assert(sizeof(hEffectLayer::mTexIndex) == 4, "expected hEffectLayer::mTexIndex to be size 4");
static_assert(sizeof(hEffectLayer::mpAnimPattern) == 4, "expected hEffectLayer::mpAnimPattern to be size 4");
static_assert(sizeof(hEffectLayer::mAnimPatIndex) == 4, "expected hEffectLayer::mAnimPatIndex to be size 4");
static_assert(sizeof(hEffectLayer::mTop) == 4, "expected hEffectLayer::mTop to be size 4");
static_assert(sizeof(hEffectLayer::mEnd) == 4, "expected hEffectLayer::mEnd to be size 4");
static_assert(sizeof(hEffectLayer::mPerticleNum) == 4, "expected hEffectLayer::mPerticleNum to be size 4");
static_assert(sizeof(hEffectLayer::mLocalMat) == 48, "expected hEffectLayer::mLocalMat to be size 48");
static_assert(sizeof(hEffectLayer::mFlag) == 4, "expected hEffectLayer::mFlag to be size 4");
static_assert(sizeof(hEffectLayer) == 0x80, "expected hEffectLayer to be size 0x80");

// [Structure] struct hEffectKey
struct hEffectKey
{
public:
	/// Struct member variables

	// <int32_t mKey, offset 0x0>
	int32_t mKey = 0;

	// <int32_t mSpreadNum, offset 0x4>
	int32_t mSpreadNum = 0;

	// <int32_t mSpreadTime, offset 0x8>
	int32_t mSpreadTime = 0;

	// <struct Vec mSpreadPos, offset 0xc>
	struct Vec mSpreadPos;

	// <struct Vec mSpreadDir, offset 0x18>
	struct Vec mSpreadDir;

	// <struct Vec mSpreadRange, offset 0x24>
	struct Vec mSpreadRange;

	// <struct Vec mSpreadAngle, offset 0x30>
	struct Vec mSpreadAngle;

	// <float mSpreadSpeed, offset 0x3c>
	float mSpreadSpeed = 0;

	// <float mGravity, offset 0x40>
	float mGravity = 0;

	// <int32_t mRandamRange, offset 0x44>
	int32_t mRandamRange = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct hEffectKey [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hEffectKey& InObject)
	{
		mKey = InObject.mKey;
		mSpreadNum = InObject.mSpreadNum;
		mSpreadTime = InObject.mSpreadTime;
		mSpreadPos = InObject.mSpreadPos;
		mSpreadDir = InObject.mSpreadDir;
		mSpreadRange = InObject.mSpreadRange;
		mSpreadAngle = InObject.mSpreadAngle;
		mSpreadSpeed = InObject.mSpreadSpeed;
		mGravity = InObject.mGravity;
		mRandamRange = InObject.mRandamRange;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hEffectKey>("hEffectKey")
			.addFunction("__tostring", &hEffectKey::ToString)
			.addFunction("GetPtrAddr", &hEffectKey::GetPtrAddr)
			.addProperty("mKey", &hEffectKey::mKey)
			.addProperty("mSpreadNum", &hEffectKey::mSpreadNum)
			.addProperty("mSpreadTime", &hEffectKey::mSpreadTime)
			.addProperty("mSpreadPos", &hEffectKey::mSpreadPos)
			.addProperty("mSpreadDir", &hEffectKey::mSpreadDir)
			.addProperty("mSpreadRange", &hEffectKey::mSpreadRange)
			.addProperty("mSpreadAngle", &hEffectKey::mSpreadAngle)
			.addProperty("mSpreadSpeed", &hEffectKey::mSpreadSpeed)
			.addProperty("mGravity", &hEffectKey::mGravity)
			.addProperty("mRandamRange", &hEffectKey::mRandamRange)
		.endClass();
	}
#endif
};
static_assert(sizeof(hEffectKey::mKey) == 4, "expected hEffectKey::mKey to be size 4");
static_assert(sizeof(hEffectKey::mSpreadNum) == 4, "expected hEffectKey::mSpreadNum to be size 4");
static_assert(sizeof(hEffectKey::mSpreadTime) == 4, "expected hEffectKey::mSpreadTime to be size 4");
static_assert(sizeof(hEffectKey::mSpreadPos) == 12, "expected hEffectKey::mSpreadPos to be size 12");
static_assert(sizeof(hEffectKey::mSpreadDir) == 12, "expected hEffectKey::mSpreadDir to be size 12");
static_assert(sizeof(hEffectKey::mSpreadRange) == 12, "expected hEffectKey::mSpreadRange to be size 12");
static_assert(sizeof(hEffectKey::mSpreadAngle) == 12, "expected hEffectKey::mSpreadAngle to be size 12");
static_assert(sizeof(hEffectKey::mSpreadSpeed) == 4, "expected hEffectKey::mSpreadSpeed to be size 4");
static_assert(sizeof(hEffectKey::mGravity) == 4, "expected hEffectKey::mGravity to be size 4");
static_assert(sizeof(hEffectKey::mRandamRange) == 4, "expected hEffectKey::mRandamRange to be size 4");
static_assert(sizeof(hEffectKey) == 0x48, "expected hEffectKey to be size 0x48");

// [Structure] struct HCOLOR
struct HCOLOR
{
public:
	/// Struct member variables

	// <uint8_t R, offset 0x0>
	uint8_t R = 0;

	// <uint8_t G, offset 0x1>
	uint8_t G = 0;

	// <uint8_t B, offset 0x2>
	uint8_t B = 0;

	// <uint8_t A, offset 0x3>
	uint8_t A = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct HCOLOR [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HCOLOR& InObject)
	{
		R = InObject.R;
		G = InObject.G;
		B = InObject.B;
		A = InObject.A;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HCOLOR>("HCOLOR")
			.addFunction("__tostring", &HCOLOR::ToString)
			.addFunction("GetPtrAddr", &HCOLOR::GetPtrAddr)
			.addProperty("R", &HCOLOR::R)
			.addProperty("G", &HCOLOR::G)
			.addProperty("B", &HCOLOR::B)
			.addProperty("A", &HCOLOR::A)
		.endClass();
	}
#endif
};
static_assert(sizeof(HCOLOR::R) == 1, "expected HCOLOR::R to be size 1");
static_assert(sizeof(HCOLOR::G) == 1, "expected HCOLOR::G to be size 1");
static_assert(sizeof(HCOLOR::B) == 1, "expected HCOLOR::B to be size 1");
static_assert(sizeof(HCOLOR::A) == 1, "expected HCOLOR::A to be size 1");
static_assert(sizeof(HCOLOR) == 0x4, "expected HCOLOR to be size 0x4");

// [Structure] struct hPerticleKey
struct hPerticleKey
{
public:
	/// Struct member variables

	// <int32_t mKey, offset 0x0>
	int32_t mKey = 0;

	// <struct Vec mPos, offset 0x4>
	struct Vec mPos;

	// <struct Vec mDir, offset 0x10>
	struct Vec mDir;

	// <float mWidth, offset 0x1c>
	float mWidth = 0;

	// <float mHeight, offset 0x20>
	float mHeight = 0;

	// <struct HCOLOR mColor, offset 0x24>
	struct HCOLOR mColor;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct hPerticleKey [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hPerticleKey& InObject)
	{
		mKey = InObject.mKey;
		mPos = InObject.mPos;
		mDir = InObject.mDir;
		mWidth = InObject.mWidth;
		mHeight = InObject.mHeight;
		mColor = InObject.mColor;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hPerticleKey>("hPerticleKey")
			.addFunction("__tostring", &hPerticleKey::ToString)
			.addFunction("GetPtrAddr", &hPerticleKey::GetPtrAddr)
			.addProperty("mKey", &hPerticleKey::mKey)
			.addProperty("mPos", &hPerticleKey::mPos)
			.addProperty("mDir", &hPerticleKey::mDir)
			.addProperty("mWidth", &hPerticleKey::mWidth)
			.addProperty("mHeight", &hPerticleKey::mHeight)
			.addProperty("mColor", &hPerticleKey::mColor)
		.endClass();
	}
#endif
};
static_assert(sizeof(hPerticleKey::mKey) == 4, "expected hPerticleKey::mKey to be size 4");
static_assert(sizeof(hPerticleKey::mPos) == 12, "expected hPerticleKey::mPos to be size 12");
static_assert(sizeof(hPerticleKey::mDir) == 12, "expected hPerticleKey::mDir to be size 12");
static_assert(sizeof(hPerticleKey::mWidth) == 4, "expected hPerticleKey::mWidth to be size 4");
static_assert(sizeof(hPerticleKey::mHeight) == 4, "expected hPerticleKey::mHeight to be size 4");
static_assert(sizeof(hPerticleKey::mColor) == 4, "expected hPerticleKey::mColor to be size 4");
static_assert(sizeof(hPerticleKey) == 0x28, "expected hPerticleKey to be size 0x28");

// [Structure] class hPerticle
class hPerticle
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <uint16_t mState, offset 0x4>
	uint16_t mState = 0;

	// <uint16_t mNowKey, offset 0x6>
	uint16_t mNowKey = 0;

	// <uint16_t mFrame, offset 0x8>
	uint16_t mFrame = 0;

	// <uint16_t mFrameCnt, offset 0xa>
	uint16_t mFrameCnt = 0;

	// <struct Vec mPos, offset 0xc>
	struct Vec mPos;

	// <struct Vec mDir, offset 0x18>
	struct Vec mDir;

	// <struct Vec mMoveVec, offset 0x24>
	struct Vec mMoveVec;

	// <float mRandamRange, offset 0x30>
	float mRandamRange = 0;

	// <float mWidth, offset 0x34>
	float mWidth = 0;

	// <float mHeight, offset 0x38>
	float mHeight = 0;

	// <struct HCOLOR mColor, offset 0x3c>
	struct HCOLOR mColor;

	// <struct Vec mWorldPos, offset 0x40>
	struct Vec mWorldPos;

	// <struct Vec mWorldDir, offset 0x4c>
	struct Vec mWorldDir;

	// <float mU0, offset 0x58>
	float mU0 = 0;

	// <float mV0, offset 0x5c>
	float mV0 = 0;

	// <float mU1, offset 0x60>
	float mU1 = 0;

	// <float mV1, offset 0x64>
	float mV1 = 0;

	// <int32_t mAnimCnt, offset 0x68>
	int32_t mAnimCnt = 0;

	// <int32_t mNowAnimPat, offset 0x6c>
	int32_t mNowAnimPat = 0;

	// <hPerticle* mPrev, offset 0x70>
	hPerticle* mPrev = nullptr;

	// <hPerticle* mNext, offset 0x74>
	hPerticle* mNext = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hPerticle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hPerticle& InObject)
	{
		mState = InObject.mState;
		mNowKey = InObject.mNowKey;
		mFrame = InObject.mFrame;
		mFrameCnt = InObject.mFrameCnt;
		mPos = InObject.mPos;
		mDir = InObject.mDir;
		mMoveVec = InObject.mMoveVec;
		mRandamRange = InObject.mRandamRange;
		mWidth = InObject.mWidth;
		mHeight = InObject.mHeight;
		mColor = InObject.mColor;
		mWorldPos = InObject.mWorldPos;
		mWorldDir = InObject.mWorldDir;
		mU0 = InObject.mU0;
		mV0 = InObject.mV0;
		mU1 = InObject.mU1;
		mV1 = InObject.mV1;
		mAnimCnt = InObject.mAnimCnt;
		mNowAnimPat = InObject.mNowAnimPat;
		mPrev = InObject.mPrev;
		mNext = InObject.mNext;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hPerticle>("hPerticle")
			.addFunction("__tostring", &hPerticle::ToString)
			.addFunction("GetPtrAddr", &hPerticle::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &hPerticle::field_0)
			.addProperty("mState", &hPerticle::mState)
			.addProperty("mNowKey", &hPerticle::mNowKey)
			.addProperty("mFrame", &hPerticle::mFrame)
			.addProperty("mFrameCnt", &hPerticle::mFrameCnt)
			.addProperty("mPos", &hPerticle::mPos)
			.addProperty("mDir", &hPerticle::mDir)
			.addProperty("mMoveVec", &hPerticle::mMoveVec)
			.addProperty("mRandamRange", &hPerticle::mRandamRange)
			.addProperty("mWidth", &hPerticle::mWidth)
			.addProperty("mHeight", &hPerticle::mHeight)
			.addProperty("mColor", &hPerticle::mColor)
			.addProperty("mWorldPos", &hPerticle::mWorldPos)
			.addProperty("mWorldDir", &hPerticle::mWorldDir)
			.addProperty("mU0", &hPerticle::mU0)
			.addProperty("mV0", &hPerticle::mV0)
			.addProperty("mU1", &hPerticle::mU1)
			.addProperty("mV1", &hPerticle::mV1)
			.addProperty("mAnimCnt", &hPerticle::mAnimCnt)
			.addProperty("mNowAnimPat", &hPerticle::mNowAnimPat)
			.addProperty("mPrev", &hPerticle::mPrev)
			.addProperty("mNext", &hPerticle::mNext)
		.endClass();
	}
#endif
};
static_assert(sizeof(hPerticle::field_0) == 4, "expected hPerticle::field_0 to be size 4");
static_assert(sizeof(hPerticle::mState) == 2, "expected hPerticle::mState to be size 2");
static_assert(sizeof(hPerticle::mNowKey) == 2, "expected hPerticle::mNowKey to be size 2");
static_assert(sizeof(hPerticle::mFrame) == 2, "expected hPerticle::mFrame to be size 2");
static_assert(sizeof(hPerticle::mFrameCnt) == 2, "expected hPerticle::mFrameCnt to be size 2");
static_assert(sizeof(hPerticle::mPos) == 12, "expected hPerticle::mPos to be size 12");
static_assert(sizeof(hPerticle::mDir) == 12, "expected hPerticle::mDir to be size 12");
static_assert(sizeof(hPerticle::mMoveVec) == 12, "expected hPerticle::mMoveVec to be size 12");
static_assert(sizeof(hPerticle::mRandamRange) == 4, "expected hPerticle::mRandamRange to be size 4");
static_assert(sizeof(hPerticle::mWidth) == 4, "expected hPerticle::mWidth to be size 4");
static_assert(sizeof(hPerticle::mHeight) == 4, "expected hPerticle::mHeight to be size 4");
static_assert(sizeof(hPerticle::mColor) == 4, "expected hPerticle::mColor to be size 4");
static_assert(sizeof(hPerticle::mWorldPos) == 12, "expected hPerticle::mWorldPos to be size 12");
static_assert(sizeof(hPerticle::mWorldDir) == 12, "expected hPerticle::mWorldDir to be size 12");
static_assert(sizeof(hPerticle::mU0) == 4, "expected hPerticle::mU0 to be size 4");
static_assert(sizeof(hPerticle::mV0) == 4, "expected hPerticle::mV0 to be size 4");
static_assert(sizeof(hPerticle::mU1) == 4, "expected hPerticle::mU1 to be size 4");
static_assert(sizeof(hPerticle::mV1) == 4, "expected hPerticle::mV1 to be size 4");
static_assert(sizeof(hPerticle::mAnimCnt) == 4, "expected hPerticle::mAnimCnt to be size 4");
static_assert(sizeof(hPerticle::mNowAnimPat) == 4, "expected hPerticle::mNowAnimPat to be size 4");
static_assert(sizeof(hPerticle::mPrev) == 4, "expected hPerticle::mPrev to be size 4");
static_assert(sizeof(hPerticle::mNext) == 4, "expected hPerticle::mNext to be size 4");
static_assert(sizeof(hPerticle) == 0x78, "expected hPerticle to be size 0x78");

// [Structure] class hAnimTex
class hAnimTex
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <int32_t mTotalFrame, offset 0x4>
	int32_t mTotalFrame = 0;

	// <int32_t mFrameTime, offset 0x8>
	int32_t mFrameTime = 0;

	// <float mWidth, offset 0xc>
	float mWidth = 0;

	// <float mHeight, offset 0x10>
	float mHeight = 0;

	// <struct hAnimChip* mpAnimChip, offset 0x14>
	struct hAnimChip* mpAnimChip = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hAnimTex [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hAnimTex& InObject)
	{
		mTotalFrame = InObject.mTotalFrame;
		mFrameTime = InObject.mFrameTime;
		mWidth = InObject.mWidth;
		mHeight = InObject.mHeight;
		mpAnimChip = InObject.mpAnimChip;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hAnimTex>("hAnimTex")
			.addFunction("__tostring", &hAnimTex::ToString)
			.addFunction("GetPtrAddr", &hAnimTex::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &hAnimTex::field_0)
			.addProperty("mTotalFrame", &hAnimTex::mTotalFrame)
			.addProperty("mFrameTime", &hAnimTex::mFrameTime)
			.addProperty("mWidth", &hAnimTex::mWidth)
			.addProperty("mHeight", &hAnimTex::mHeight)
			.addProperty("mpAnimChip", &hAnimTex::mpAnimChip)
		.endClass();
	}
#endif
};
static_assert(sizeof(hAnimTex::field_0) == 4, "expected hAnimTex::field_0 to be size 4");
static_assert(sizeof(hAnimTex::mTotalFrame) == 4, "expected hAnimTex::mTotalFrame to be size 4");
static_assert(sizeof(hAnimTex::mFrameTime) == 4, "expected hAnimTex::mFrameTime to be size 4");
static_assert(sizeof(hAnimTex::mWidth) == 4, "expected hAnimTex::mWidth to be size 4");
static_assert(sizeof(hAnimTex::mHeight) == 4, "expected hAnimTex::mHeight to be size 4");
static_assert(sizeof(hAnimTex::mpAnimChip) == 4, "expected hAnimTex::mpAnimChip to be size 4");
static_assert(sizeof(hAnimTex) == 0x18, "expected hAnimTex to be size 0x18");

// [Structure] struct hAnimChip
struct hAnimChip
{
public:
	/// Struct member variables

	// <int16_t px, offset 0x0>
	int16_t px = 0;

	// <int16_t py, offset 0x2>
	int16_t py = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct hAnimChip [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hAnimChip& InObject)
	{
		px = InObject.px;
		py = InObject.py;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hAnimChip>("hAnimChip")
			.addFunction("__tostring", &hAnimChip::ToString)
			.addFunction("GetPtrAddr", &hAnimChip::GetPtrAddr)
			.addProperty("px", &hAnimChip::px)
			.addProperty("py", &hAnimChip::py)
		.endClass();
	}
#endif
};
static_assert(sizeof(hAnimChip::px) == 2, "expected hAnimChip::px to be size 2");
static_assert(sizeof(hAnimChip::py) == 2, "expected hAnimChip::py to be size 2");
static_assert(sizeof(hAnimChip) == 0x4, "expected hAnimChip to be size 0x4");

// [Structure] class HrMiniDemoModel
class HrMiniDemoModel : public HrMiniDemoObj
{
public:
	/// Struct member variables

	// <class HrMiniDemoObj field_0, offset 0x0>
	// class HrMiniDemoObj Super;

	// <struct WGanNodeSpec* mpGanNodeSpec, offset 0x50>
	struct WGanNodeSpec* mpGanNodeSpec = nullptr;

	// <class TGmf* mpGmf, offset 0x54>
	class TGmf* mpGmf = nullptr;

	// <class mHRChara* mpChara, offset 0x58>
	class mHRChara* mpChara = nullptr;

	// <struct Vec mPos, offset 0x5c>
	struct Vec mPos;

	// <struct Vec mRot, offset 0x68>
	struct Vec mRot;

	// <uint8_t mUseTexShadow, offset 0x74>
	uint8_t mUseTexShadow = 0;

	// <Unidentified data segment, offset 0x75>
private:
	char _UnidentifiedData_117[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class HrMiniDemoModel [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(HrMiniDemoModel& InObject)
	{
		mpGanNodeSpec = InObject.mpGanNodeSpec;
		mpGmf = InObject.mpGmf;
		mpChara = InObject.mpChara;
		mPos = InObject.mPos;
		mRot = InObject.mRot;
		mUseTexShadow = InObject.mUseTexShadow;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMiniDemoModel, HrMiniDemoObj>("HrMiniDemoModel")
			.addFunction("__tostring", &HrMiniDemoModel::ToString)
			.addFunction("GetPtrAddr", &HrMiniDemoModel::GetPtrAddr)
			.addProperty("mpGanNodeSpec", &HrMiniDemoModel::mpGanNodeSpec)
			.addProperty("mpGmf", &HrMiniDemoModel::mpGmf)
			.addProperty("mpChara", &HrMiniDemoModel::mpChara)
			.addProperty("mPos", &HrMiniDemoModel::mPos)
			.addProperty("mRot", &HrMiniDemoModel::mRot)
			.addProperty("mUseTexShadow", &HrMiniDemoModel::mUseTexShadow)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemoModel::mpGanNodeSpec) == 4, "expected HrMiniDemoModel::mpGanNodeSpec to be size 4");
static_assert(sizeof(HrMiniDemoModel::mpGmf) == 4, "expected HrMiniDemoModel::mpGmf to be size 4");
static_assert(sizeof(HrMiniDemoModel::mpChara) == 4, "expected HrMiniDemoModel::mpChara to be size 4");
static_assert(sizeof(HrMiniDemoModel::mPos) == 12, "expected HrMiniDemoModel::mPos to be size 12");
static_assert(sizeof(HrMiniDemoModel::mRot) == 12, "expected HrMiniDemoModel::mRot to be size 12");
static_assert(sizeof(HrMiniDemoModel::mUseTexShadow) == 1, "expected HrMiniDemoModel::mUseTexShadow to be size 1");
static_assert(sizeof(HrMiniDemoModel) == 0x78, "expected HrMiniDemoModel to be size 0x78");

// Unsupported constructor
//void __convention("thiscall") HrMiniDemoModel::HrMiniDemoModel(class HrMiniDemoModel* const this, class TGan* arg2, struct WGanNodeSpec* arg3, class mHRChara* arg4)
// enum _GXSpotFn
enum _GXSpotFn : uint32_t
{
	// <GX_SP_OFF = 0x0>
	GX_SP_OFF = 0,

	// <GX_SP_FLAT = 0x1>
	GX_SP_FLAT = 1,

	// <GX_SP_COS = 0x2>
	GX_SP_COS = 2,

	// <GX_SP_COS2 = 0x3>
	GX_SP_COS2 = 3,

	// <GX_SP_SHARP = 0x4>
	GX_SP_SHARP = 4,

	// <GX_SP_RING1 = 0x5>
	GX_SP_RING1 = 5,

	// <GX_SP_RING2 = 0x6>
	GX_SP_RING2 = 6

};

// enum _GXDistAttnFn
enum _GXDistAttnFn : uint32_t
{
	// <GX_DA_OFF = 0x0>
	GX_DA_OFF = 0,

	// <GX_DA_GENTLE = 0x1>
	GX_DA_GENTLE = 1,

	// <GX_DA_MEDIUM = 0x2>
	GX_DA_MEDIUM = 2,

	// <GX_DA_STEEP = 0x3>
	GX_DA_STEEP = 3

};

// [Structure] struct TGMFLIGHT
struct TGMFLIGHT
{
public:
	/// Struct member variables

	// <uint8_t Valid, offset 0x0>
	uint8_t Valid = 0;

	// <uint8_t CharCancel, offset 0x1>
	uint8_t CharCancel = 0;

	// <uint8_t StageCancel, offset 0x2>
	uint8_t StageCancel = 0;

	// <Unidentified data segment, offset 0x3>
private:
	char _UnidentifiedData_3[1];

public:
	// <struct GXColor Color, offset 0x4>
	struct GXColor Color;

	// <float Intensity, offset 0x8>
	float Intensity = 0;

	// <struct Vec Direction, offset 0xc>
	struct Vec Direction;

	// <struct Vec Position, offset 0x18>
	struct Vec Position;

	// <float Bright, offset 0x24>
	float Bright = 0;

	// <float Distance, offset 0x28>
	float Distance = 0;

	// <enum _GXDistAttnFn DistFunc, offset 0x2c>
	enum _GXDistAttnFn DistFunc;

	// <float ConeAngle, offset 0x30>
	float ConeAngle = 0;

	// <enum _GXSpotFn SpotFunc, offset 0x34>
	enum _GXSpotFn SpotFunc;

	// <float Shininess, offset 0x38>
	float Shininess = 0;

	// <uint8_t bCharLight, offset 0x3c>
	uint8_t bCharLight = 0;

	// <Unidentified data segment, offset 0x3d>
private:
	char _UnidentifiedData_61[3];

public:
	// <class TGmf* pPrivateGmf, offset 0x40>
	class TGmf* pPrivateGmf = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct TGMFLIGHT [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(TGMFLIGHT& InObject)
	{
		Valid = InObject.Valid;
		CharCancel = InObject.CharCancel;
		StageCancel = InObject.StageCancel;
		Color = InObject.Color;
		Intensity = InObject.Intensity;
		Direction = InObject.Direction;
		Position = InObject.Position;
		Bright = InObject.Bright;
		Distance = InObject.Distance;
		DistFunc = InObject.DistFunc;
		ConeAngle = InObject.ConeAngle;
		SpotFunc = InObject.SpotFunc;
		Shininess = InObject.Shininess;
		bCharLight = InObject.bCharLight;
		pPrivateGmf = InObject.pPrivateGmf;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGMFLIGHT>("TGMFLIGHT")
			.addFunction("__tostring", &TGMFLIGHT::ToString)
			.addFunction("GetPtrAddr", &TGMFLIGHT::GetPtrAddr)
			.addProperty("Valid", &TGMFLIGHT::Valid)
			.addProperty("CharCancel", &TGMFLIGHT::CharCancel)
			.addProperty("StageCancel", &TGMFLIGHT::StageCancel)
			.addProperty("Color", &TGMFLIGHT::Color)
			.addProperty("Intensity", &TGMFLIGHT::Intensity)
			.addProperty("Direction", &TGMFLIGHT::Direction)
			.addProperty("Position", &TGMFLIGHT::Position)
			.addProperty("Bright", &TGMFLIGHT::Bright)
			.addProperty("Distance", &TGMFLIGHT::Distance)
			.addProperty("DistFunc", &TGMFLIGHT::DistFunc)
			.addProperty("ConeAngle", &TGMFLIGHT::ConeAngle)
			.addProperty("SpotFunc", &TGMFLIGHT::SpotFunc)
			.addProperty("Shininess", &TGMFLIGHT::Shininess)
			.addProperty("bCharLight", &TGMFLIGHT::bCharLight)
			.addProperty("pPrivateGmf", &TGMFLIGHT::pPrivateGmf)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGMFLIGHT::Valid) == 1, "expected TGMFLIGHT::Valid to be size 1");
static_assert(sizeof(TGMFLIGHT::CharCancel) == 1, "expected TGMFLIGHT::CharCancel to be size 1");
static_assert(sizeof(TGMFLIGHT::StageCancel) == 1, "expected TGMFLIGHT::StageCancel to be size 1");
static_assert(sizeof(TGMFLIGHT::Color) == 4, "expected TGMFLIGHT::Color to be size 4");
static_assert(sizeof(TGMFLIGHT::Intensity) == 4, "expected TGMFLIGHT::Intensity to be size 4");
static_assert(sizeof(TGMFLIGHT::Direction) == 12, "expected TGMFLIGHT::Direction to be size 12");
static_assert(sizeof(TGMFLIGHT::Position) == 12, "expected TGMFLIGHT::Position to be size 12");
static_assert(sizeof(TGMFLIGHT::Bright) == 4, "expected TGMFLIGHT::Bright to be size 4");
static_assert(sizeof(TGMFLIGHT::Distance) == 4, "expected TGMFLIGHT::Distance to be size 4");
static_assert(sizeof(TGMFLIGHT::DistFunc) == 4, "expected TGMFLIGHT::DistFunc to be size 4");
static_assert(sizeof(TGMFLIGHT::ConeAngle) == 4, "expected TGMFLIGHT::ConeAngle to be size 4");
static_assert(sizeof(TGMFLIGHT::SpotFunc) == 4, "expected TGMFLIGHT::SpotFunc to be size 4");
static_assert(sizeof(TGMFLIGHT::Shininess) == 4, "expected TGMFLIGHT::Shininess to be size 4");
static_assert(sizeof(TGMFLIGHT::bCharLight) == 1, "expected TGMFLIGHT::bCharLight to be size 1");
static_assert(sizeof(TGMFLIGHT::pPrivateGmf) == 4, "expected TGMFLIGHT::pPrivateGmf to be size 4");
static_assert(sizeof(TGMFLIGHT) == 0x44, "expected TGMFLIGHT to be size 0x44");

// Unsupported constructor
//void __convention("thiscall") HrStageDraw::HrStageDraw(class HrStageDraw* const this)
// Unsupported destructor
//void __convention("thiscall") HrStageDraw::~HrStageDraw(class HrStageDraw* const this)
// [Structure] class Archive
class Archive
{
public:
	/// Struct member variables

	// <uint8_t* FileImage, offset 0x0>
	uint8_t* FileImage = nullptr;

	// <int32_t FileImageSize, offset 0x4>
	int32_t FileImageSize = 0;

	// <struct tagDARC_HEAD* Head, offset 0x8>
	struct tagDARC_HEAD* Head = nullptr;

	// <struct tagDARC_FILEHEAD* FileTable, offset 0xc>
	struct tagDARC_FILEHEAD* FileTable = nullptr;

	// <struct tagDARC_DIRECTORY* DirTable, offset 0x10>
	struct tagDARC_DIRECTORY* DirTable = nullptr;

	// <uint8_t* NameTable, offset 0x14>
	uint8_t* NameTable = nullptr;

	// <struct tagDARC_DIRECTORY* CurrentDirectory, offset 0x18>
	struct tagDARC_DIRECTORY* CurrentDirectory = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class Archive [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(Archive& InObject)
	{
		FileImage = InObject.FileImage;
		FileImageSize = InObject.FileImageSize;
		Head = InObject.Head;
		FileTable = InObject.FileTable;
		DirTable = InObject.DirTable;
		NameTable = InObject.NameTable;
		CurrentDirectory = InObject.CurrentDirectory;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Archive>("Archive")
			.addFunction("__tostring", &Archive::ToString)
			.addFunction("GetPtrAddr", &Archive::GetPtrAddr)
			// native pointer type (uint8_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("FileImage", &Archive::FileImage)
			.addProperty("FileImageSize", &Archive::FileImageSize)
			.addProperty("Head", &Archive::Head)
			.addProperty("FileTable", &Archive::FileTable)
			.addProperty("DirTable", &Archive::DirTable)
			// native pointer type (uint8_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("NameTable", &Archive::NameTable)
			.addProperty("CurrentDirectory", &Archive::CurrentDirectory)
		.endClass();
	}
#endif
};
static_assert(sizeof(Archive::FileImage) == 4, "expected Archive::FileImage to be size 4");
static_assert(sizeof(Archive::FileImageSize) == 4, "expected Archive::FileImageSize to be size 4");
static_assert(sizeof(Archive::Head) == 4, "expected Archive::Head to be size 4");
static_assert(sizeof(Archive::FileTable) == 4, "expected Archive::FileTable to be size 4");
static_assert(sizeof(Archive::DirTable) == 4, "expected Archive::DirTable to be size 4");
static_assert(sizeof(Archive::NameTable) == 4, "expected Archive::NameTable to be size 4");
static_assert(sizeof(Archive::CurrentDirectory) == 4, "expected Archive::CurrentDirectory to be size 4");
static_assert(sizeof(Archive) == 0x1c, "expected Archive to be size 0x1c");

// [Structure] struct tagDARC_HEAD
struct tagDARC_HEAD
{
public:
	/// Struct member variables

	// <uint16_t Head, offset 0x0>
	uint16_t Head = 0;

	// <uint16_t Version, offset 0x2>
	uint16_t Version = 0;

	// <uint32_t HeadSize, offset 0x4>
	uint32_t HeadSize = 0;

	// <uint32_t DataStartAddress, offset 0x8>
	uint32_t DataStartAddress = 0;

	// <uint32_t FileNameTableStartAddress, offset 0xc>
	uint32_t FileNameTableStartAddress = 0;

	// <uint32_t FileTableStartAddress, offset 0x10>
	uint32_t FileTableStartAddress = 0;

	// <uint32_t DirectoryTableStartAddress, offset 0x14>
	uint32_t DirectoryTableStartAddress = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct tagDARC_HEAD [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tagDARC_HEAD& InObject)
	{
		Head = InObject.Head;
		Version = InObject.Version;
		HeadSize = InObject.HeadSize;
		DataStartAddress = InObject.DataStartAddress;
		FileNameTableStartAddress = InObject.FileNameTableStartAddress;
		FileTableStartAddress = InObject.FileTableStartAddress;
		DirectoryTableStartAddress = InObject.DirectoryTableStartAddress;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagDARC_HEAD>("tagDARC_HEAD")
			.addFunction("__tostring", &tagDARC_HEAD::ToString)
			.addFunction("GetPtrAddr", &tagDARC_HEAD::GetPtrAddr)
			.addProperty("Head", &tagDARC_HEAD::Head)
			.addProperty("Version", &tagDARC_HEAD::Version)
			.addProperty("HeadSize", &tagDARC_HEAD::HeadSize)
			.addProperty("DataStartAddress", &tagDARC_HEAD::DataStartAddress)
			.addProperty("FileNameTableStartAddress", &tagDARC_HEAD::FileNameTableStartAddress)
			.addProperty("FileTableStartAddress", &tagDARC_HEAD::FileTableStartAddress)
			.addProperty("DirectoryTableStartAddress", &tagDARC_HEAD::DirectoryTableStartAddress)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagDARC_HEAD::Head) == 2, "expected tagDARC_HEAD::Head to be size 2");
static_assert(sizeof(tagDARC_HEAD::Version) == 2, "expected tagDARC_HEAD::Version to be size 2");
static_assert(sizeof(tagDARC_HEAD::HeadSize) == 4, "expected tagDARC_HEAD::HeadSize to be size 4");
static_assert(sizeof(tagDARC_HEAD::DataStartAddress) == 4, "expected tagDARC_HEAD::DataStartAddress to be size 4");
static_assert(sizeof(tagDARC_HEAD::FileNameTableStartAddress) == 4, "expected tagDARC_HEAD::FileNameTableStartAddress to be size 4");
static_assert(sizeof(tagDARC_HEAD::FileTableStartAddress) == 4, "expected tagDARC_HEAD::FileTableStartAddress to be size 4");
static_assert(sizeof(tagDARC_HEAD::DirectoryTableStartAddress) == 4, "expected tagDARC_HEAD::DirectoryTableStartAddress to be size 4");
static_assert(sizeof(tagDARC_HEAD) == 0x18, "expected tagDARC_HEAD to be size 0x18");

// [Structure] struct tagDARC_FILETIME
struct tagDARC_FILETIME
{
public:
	/// Struct member variables

	// <uint64_t Create, offset 0x0>
	uint64_t Create;

	// <uint64_t LastAccess, offset 0x8>
	uint64_t LastAccess;

	// <uint64_t LastWrite, offset 0x10>
	uint64_t LastWrite;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct tagDARC_FILETIME [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tagDARC_FILETIME& InObject)
	{
		Create = InObject.Create;
		LastAccess = InObject.LastAccess;
		LastWrite = InObject.LastWrite;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagDARC_FILETIME>("tagDARC_FILETIME")
			.addFunction("__tostring", &tagDARC_FILETIME::ToString)
			.addFunction("GetPtrAddr", &tagDARC_FILETIME::GetPtrAddr)
			.addProperty("Create", &tagDARC_FILETIME::Create)
			.addProperty("LastAccess", &tagDARC_FILETIME::LastAccess)
			.addProperty("LastWrite", &tagDARC_FILETIME::LastWrite)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagDARC_FILETIME::Create) == 8, "expected tagDARC_FILETIME::Create to be size 8");
static_assert(sizeof(tagDARC_FILETIME::LastAccess) == 8, "expected tagDARC_FILETIME::LastAccess to be size 8");
static_assert(sizeof(tagDARC_FILETIME::LastWrite) == 8, "expected tagDARC_FILETIME::LastWrite to be size 8");
static_assert(sizeof(tagDARC_FILETIME) == 0x18, "expected tagDARC_FILETIME to be size 0x18");

// [Structure] struct tagDARC_FILEHEAD
struct tagDARC_FILEHEAD
{
public:
	/// Struct member variables

	// <uint32_t NameAddress, offset 0x0>
	uint32_t NameAddress = 0;

	// <uint32_t Attributes, offset 0x4>
	uint32_t Attributes = 0;

	// <struct tagDARC_FILETIME Time, offset 0x8>
	struct tagDARC_FILETIME Time;

	// <uint32_t DataAddress, offset 0x20>
	uint32_t DataAddress = 0;

	// <uint32_t DataSize, offset 0x24>
	uint32_t DataSize = 0;

	// <uint32_t PressDataSize, offset 0x28>
	uint32_t PressDataSize = 0;

	// <Unidentified data segment, offset 0x2c>
private:
	char _UnidentifiedData_44[4];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct tagDARC_FILEHEAD [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tagDARC_FILEHEAD& InObject)
	{
		NameAddress = InObject.NameAddress;
		Attributes = InObject.Attributes;
		Time = InObject.Time;
		DataAddress = InObject.DataAddress;
		DataSize = InObject.DataSize;
		PressDataSize = InObject.PressDataSize;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagDARC_FILEHEAD>("tagDARC_FILEHEAD")
			.addFunction("__tostring", &tagDARC_FILEHEAD::ToString)
			.addFunction("GetPtrAddr", &tagDARC_FILEHEAD::GetPtrAddr)
			.addProperty("NameAddress", &tagDARC_FILEHEAD::NameAddress)
			.addProperty("Attributes", &tagDARC_FILEHEAD::Attributes)
			.addProperty("Time", &tagDARC_FILEHEAD::Time)
			.addProperty("DataAddress", &tagDARC_FILEHEAD::DataAddress)
			.addProperty("DataSize", &tagDARC_FILEHEAD::DataSize)
			.addProperty("PressDataSize", &tagDARC_FILEHEAD::PressDataSize)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagDARC_FILEHEAD::NameAddress) == 4, "expected tagDARC_FILEHEAD::NameAddress to be size 4");
static_assert(sizeof(tagDARC_FILEHEAD::Attributes) == 4, "expected tagDARC_FILEHEAD::Attributes to be size 4");
static_assert(sizeof(tagDARC_FILEHEAD::Time) == 24, "expected tagDARC_FILEHEAD::Time to be size 24");
static_assert(sizeof(tagDARC_FILEHEAD::DataAddress) == 4, "expected tagDARC_FILEHEAD::DataAddress to be size 4");
static_assert(sizeof(tagDARC_FILEHEAD::DataSize) == 4, "expected tagDARC_FILEHEAD::DataSize to be size 4");
static_assert(sizeof(tagDARC_FILEHEAD::PressDataSize) == 4, "expected tagDARC_FILEHEAD::PressDataSize to be size 4");
static_assert(sizeof(tagDARC_FILEHEAD) == 0x30, "expected tagDARC_FILEHEAD to be size 0x30");

// [Structure] struct tagDARC_DIRECTORY
struct tagDARC_DIRECTORY
{
public:
	/// Struct member variables

	// <uint32_t DirectoryAddress, offset 0x0>
	uint32_t DirectoryAddress = 0;

	// <uint32_t ParentDirectoryAddress, offset 0x4>
	uint32_t ParentDirectoryAddress = 0;

	// <uint32_t FileHeadNum, offset 0x8>
	uint32_t FileHeadNum = 0;

	// <uint32_t FileHeadAddress, offset 0xc>
	uint32_t FileHeadAddress = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct tagDARC_DIRECTORY [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tagDARC_DIRECTORY& InObject)
	{
		DirectoryAddress = InObject.DirectoryAddress;
		ParentDirectoryAddress = InObject.ParentDirectoryAddress;
		FileHeadNum = InObject.FileHeadNum;
		FileHeadAddress = InObject.FileHeadAddress;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagDARC_DIRECTORY>("tagDARC_DIRECTORY")
			.addFunction("__tostring", &tagDARC_DIRECTORY::ToString)
			.addFunction("GetPtrAddr", &tagDARC_DIRECTORY::GetPtrAddr)
			.addProperty("DirectoryAddress", &tagDARC_DIRECTORY::DirectoryAddress)
			.addProperty("ParentDirectoryAddress", &tagDARC_DIRECTORY::ParentDirectoryAddress)
			.addProperty("FileHeadNum", &tagDARC_DIRECTORY::FileHeadNum)
			.addProperty("FileHeadAddress", &tagDARC_DIRECTORY::FileHeadAddress)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagDARC_DIRECTORY::DirectoryAddress) == 4, "expected tagDARC_DIRECTORY::DirectoryAddress to be size 4");
static_assert(sizeof(tagDARC_DIRECTORY::ParentDirectoryAddress) == 4, "expected tagDARC_DIRECTORY::ParentDirectoryAddress to be size 4");
static_assert(sizeof(tagDARC_DIRECTORY::FileHeadNum) == 4, "expected tagDARC_DIRECTORY::FileHeadNum to be size 4");
static_assert(sizeof(tagDARC_DIRECTORY::FileHeadAddress) == 4, "expected tagDARC_DIRECTORY::FileHeadAddress to be size 4");
static_assert(sizeof(tagDARC_DIRECTORY) == 0x10, "expected tagDARC_DIRECTORY to be size 0x10");

// [Function] int32_t __convention("thiscall") j_sub_849ca0(class mHRPc* const this) [j_sub_849ca0]
typedef int32_t(__thiscall* _j_sub_849ca0)(class mHRPc* const thisPtr);
int32_t j_sub_849ca0(class mHRPc* const thisPtr)
{
	_j_sub_849ca0 mFunc = (_j_sub_849ca0)(GameModule + 0x41efc0);
	return mFunc(thisPtr);
}
// Unsupported destructor
//void __convention("thiscall") mHRPc::~mHRPc(class mHRPc* const this)
// Unsupported constructor
//void __convention("thiscall") mHRPc::mHRPc(class mHRPc* const this)
// [Function] int32_t sub_4467e6(int32_t* arg1 @ ebp, class mHRPc* arg2 @ esi, class mHRChara* arg3 @ edi) [sub_4467e6]
typedef int32_t(__fastcall* _sub_4467e6)(int32_t* arg1, class mHRPc* arg2, class mHRChara* arg3);
int32_t sub_4467e6(int32_t* arg1, class mHRPc* arg2, class mHRChara* arg3)
{
	_sub_4467e6 mFunc = (_sub_4467e6)(GameModule + 0x4467e6);
	return mFunc(arg1, arg2, arg3);
}
// [Function] int32_t __fastcall sub_446bbd(class mHRPad* arg1, int32_t* arg2 @ ebp, void* arg3 @ esi, int32_t* arg4 @ edi) [sub_446bbd]
typedef int32_t(__fastcall* _sub_446bbd)(class mHRPad* arg1, int32_t* arg2, void* arg3, int32_t* arg4);
int32_t sub_446bbd(class mHRPad* arg1, int32_t* arg2, void* arg3, int32_t* arg4)
{
	_sub_446bbd mFunc = (_sub_446bbd)(GameModule + 0x446bbd);
	return mFunc(arg1, arg2, arg3, arg4);
}
// Unsupported destructor
//void __convention("thiscall") HrCamera::~HrCamera(class HrCamera* const this)
// Unsupported constructor
//void __convention("thiscall") HrCamera::HrCamera(class HrCamera* const this)
// Unsupported constructor
//void __convention("thiscall") HrMap::HrMap(class HrMap* const this)
// [Structure] class STG0202
class STG0202
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[96];

public:
	/// 1 Functions

	// [Function] void __convention("thiscall") STG0202::CharMoveByConbeyor(class STG0202* const this, class mHRChara* arg2) [?CharMoveByConbeyor@STG0202@@AAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _CharMoveByConbeyor_STG0202__AAEXPAVmHRChara___Z)(class STG0202* const thisPtr, class mHRChara* arg2);
	void CharMoveByConbeyor(class mHRChara* arg2)
	{
		_CharMoveByConbeyor_STG0202__AAEXPAVmHRChara___Z mFunc = (_CharMoveByConbeyor_STG0202__AAEXPAVmHRChara___Z)(GameModule + 0x455920);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class STG0202 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(STG0202& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<STG0202>("STG0202")
			.addFunction("__tostring", &STG0202::ToString)
			.addFunction("GetPtrAddr", &STG0202::GetPtrAddr)
			.addFunction("CharMoveByConbeyor", &STG0202::CharMoveByConbeyor)
		.endClass();
	}
#endif
};
static_assert(sizeof(STG0202) == 0x60, "expected STG0202 to be size 0x60");

// Unsupported destructor
//void __convention("thiscall") rSkyMap::~rSkyMap(class rSkyMap* const this)
// [Structure] struct GTEX_UVSET
struct GTEX_UVSET
{
public:
	/// Struct member variables

	// <float gfTexU, offset 0x0>
	float gfTexU = 0;

	// <float gfTexV, offset 0x4>
	float gfTexV = 0;

	// <float gfSide, offset 0x8>
	float gfSide = 0;

	// <float gfLen, offset 0xc>
	float gfLen = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct GTEX_UVSET [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(GTEX_UVSET& InObject)
	{
		gfTexU = InObject.gfTexU;
		gfTexV = InObject.gfTexV;
		gfSide = InObject.gfSide;
		gfLen = InObject.gfLen;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GTEX_UVSET>("GTEX_UVSET")
			.addFunction("__tostring", &GTEX_UVSET::ToString)
			.addFunction("GetPtrAddr", &GTEX_UVSET::GetPtrAddr)
			.addProperty("gfTexU", &GTEX_UVSET::gfTexU)
			.addProperty("gfTexV", &GTEX_UVSET::gfTexV)
			.addProperty("gfSide", &GTEX_UVSET::gfSide)
			.addProperty("gfLen", &GTEX_UVSET::gfLen)
		.endClass();
	}
#endif
};
static_assert(sizeof(GTEX_UVSET::gfTexU) == 4, "expected GTEX_UVSET::gfTexU to be size 4");
static_assert(sizeof(GTEX_UVSET::gfTexV) == 4, "expected GTEX_UVSET::gfTexV to be size 4");
static_assert(sizeof(GTEX_UVSET::gfSide) == 4, "expected GTEX_UVSET::gfSide to be size 4");
static_assert(sizeof(GTEX_UVSET::gfLen) == 4, "expected GTEX_UVSET::gfLen to be size 4");
static_assert(sizeof(GTEX_UVSET) == 0x10, "expected GTEX_UVSET to be size 0x10");

// Unsupported constructor
//void __convention("thiscall") rSkyMap::rSkyMap(class rSkyMap* const this)
// Unsupported constructor
//void __convention("thiscall") HrScreenStatus::HrScreenStatus(class HrScreenStatus* const this)
// [Structure] class EffectBoneElect
class EffectBoneElect : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class TGmf* m_pGmf, offset 0x50>
	class TGmf* m_pGmf = nullptr;

	// <uint32_t m_Color, offset 0x54>
	uint32_t m_Color = 0;

	// <class FkStlList<BoneStreamObj *> m_BoneStrmObjPtrList, offset 0x58>
	class FkStlList<BoneStreamObj *> m_BoneStrmObjPtrList;

	// <int32_t m_CeateID, offset 0x64>
	int32_t m_CeateID = 0;

	// <class EffectMetalElect* m_pMetalEffect, offset 0x68>
	class EffectMetalElect* m_pMetalEffect = nullptr;

	// <int32_t m_Cnt, offset 0x6c>
	int32_t m_Cnt = 0;

	// <class mHRChara* m_pTargetChara, offset 0x70>
	class mHRChara* m_pTargetChara = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectBoneElect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectBoneElect& InObject)
	{
		m_pGmf = InObject.m_pGmf;
		m_Color = InObject.m_Color;
		m_BoneStrmObjPtrList = InObject.m_BoneStrmObjPtrList;
		m_CeateID = InObject.m_CeateID;
		m_pMetalEffect = InObject.m_pMetalEffect;
		m_Cnt = InObject.m_Cnt;
		m_pTargetChara = InObject.m_pTargetChara;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectBoneElect, HrTask>("EffectBoneElect")
			.addFunction("__tostring", &EffectBoneElect::ToString)
			.addFunction("GetPtrAddr", &EffectBoneElect::GetPtrAddr)
			.addProperty("m_pGmf", &EffectBoneElect::m_pGmf)
			.addProperty("m_Color", &EffectBoneElect::m_Color)
			.addProperty("m_BoneStrmObjPtrList", &EffectBoneElect::m_BoneStrmObjPtrList)
			.addProperty("m_CeateID", &EffectBoneElect::m_CeateID)
			.addProperty("m_pMetalEffect", &EffectBoneElect::m_pMetalEffect)
			.addProperty("m_Cnt", &EffectBoneElect::m_Cnt)
			.addProperty("m_pTargetChara", &EffectBoneElect::m_pTargetChara)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectBoneElect::m_pGmf) == 4, "expected EffectBoneElect::m_pGmf to be size 4");
static_assert(sizeof(EffectBoneElect::m_Color) == 4, "expected EffectBoneElect::m_Color to be size 4");
static_assert(sizeof(EffectBoneElect::m_BoneStrmObjPtrList) == 12, "expected EffectBoneElect::m_BoneStrmObjPtrList to be size 12");
static_assert(sizeof(EffectBoneElect::m_CeateID) == 4, "expected EffectBoneElect::m_CeateID to be size 4");
static_assert(sizeof(EffectBoneElect::m_pMetalEffect) == 4, "expected EffectBoneElect::m_pMetalEffect to be size 4");
static_assert(sizeof(EffectBoneElect::m_Cnt) == 4, "expected EffectBoneElect::m_Cnt to be size 4");
static_assert(sizeof(EffectBoneElect::m_pTargetChara) == 4, "expected EffectBoneElect::m_pTargetChara to be size 4");
static_assert(sizeof(EffectBoneElect) == 0x74, "expected EffectBoneElect to be size 0x74");

// [Structure] class EffectMetalElect
class EffectMetalElect
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[226464];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectMetalElect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectMetalElect& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectMetalElect>("EffectMetalElect")
			.addFunction("__tostring", &EffectMetalElect::ToString)
			.addFunction("GetPtrAddr", &EffectMetalElect::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectMetalElect) == 0x374a0, "expected EffectMetalElect to be size 0x374a0");

// Unsupported destructor
//void __convention("thiscall") mHRChara::~mHRChara(class mHRChara* const this)
// Unsupported constructor
//void __convention("thiscall") mHRChara::mHRChara(class mHRChara* const this)
// enum PJSAVEPLAYER
enum PJSAVEPLAYER : uint32_t
{
	// <PJSAVE_PLAYER_TRAVIS = 0x0>
	PJSAVE_PLAYER_TRAVIS = 0,

	// <PJSAVE_PLAYER_SHINOBU = 0x1>
	PJSAVE_PLAYER_SHINOBU = 1,

	// <PJSAVE_PLAYER_HENRY = 0x2>
	PJSAVE_PLAYER_HENRY = 2,

	// <PJSAVE_PLAYER_MAX = 0x3>
	PJSAVE_PLAYER_MAX = 3

};

// enum PJSAVEMODE
enum PJSAVEMODE : uint32_t
{
	// <PJSAVEMODE_TITLE = 0x0>
	PJSAVEMODE_TITLE = 0,

	// <PJSAVEMODE_PRECHECK = 0x1>
	PJSAVEMODE_PRECHECK = 1,

	// <PJSAVEMODE_GAMESAVE = 0x2>
	PJSAVEMODE_GAMESAVE = 2,

	// <PJSAVEMODE_GAMELOAD = 0x3>
	PJSAVEMODE_GAMELOAD = 3,

	// <PJSAVEMODE_SYSONLYSAVE = 0x4>
	PJSAVEMODE_SYSONLYSAVE = 4

};

// [Structure] class PjSave
class PjSave
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[8488];

public:
	/// 2 Functions

	// [Function] void __convention("thiscall") PjSave::Load(class PjSave* const this, class ghmResGroup* arg2, enum PJSAVEMODE arg3, enum PJSAVEPLAYER arg4) [?Load@PjSave@@QAEXPAVghmResGroup@@W4PJSAVEMODE@@W4PJSAVEPLAYER@@@Z]
	typedef void(__thiscall* _Load_PjSave__QAEXPAVghmResGroup__W4PJSAVEMODE__W4PJSAVEPLAYER___Z)(class PjSave* const thisPtr, class ghmResGroup* arg2, enum PJSAVEMODE arg3, enum PJSAVEPLAYER arg4);
	void Load(class ghmResGroup* arg2, /* enum PJSAVEMODE */ uint32_t arg3, /* enum PJSAVEPLAYER */ uint32_t arg4)
	{
		_Load_PjSave__QAEXPAVghmResGroup__W4PJSAVEMODE__W4PJSAVEPLAYER___Z mFunc = (_Load_PjSave__QAEXPAVghmResGroup__W4PJSAVEMODE__W4PJSAVEPLAYER___Z)(GameModule + 0x480870);
		return mFunc(this, arg2, (enum PJSAVEMODE)arg3, (enum PJSAVEPLAYER)arg4);
	}
	// [Function] void __convention("thiscall") PjSave::LoadEffect(class PjSave* const this, class ghmResGroup* arg2, enum PJSAVEPLAYER arg3) [?LoadEffect@PjSave@@QAEXPAVghmResGroup@@W4PJSAVEPLAYER@@@Z]
	typedef void(__thiscall* _LoadEffect_PjSave__QAEXPAVghmResGroup__W4PJSAVEPLAYER___Z)(class PjSave* const thisPtr, class ghmResGroup* arg2, enum PJSAVEPLAYER arg3);
	void LoadEffect(class ghmResGroup* arg2, /* enum PJSAVEPLAYER */ uint32_t arg3)
	{
		_LoadEffect_PjSave__QAEXPAVghmResGroup__W4PJSAVEPLAYER___Z mFunc = (_LoadEffect_PjSave__QAEXPAVghmResGroup__W4PJSAVEPLAYER___Z)(GameModule + 0x4824a0);
		return mFunc(this, arg2, (enum PJSAVEPLAYER)arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PjSave [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PjSave& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PjSave>("PjSave")
			.addFunction("__tostring", &PjSave::ToString)
			.addFunction("GetPtrAddr", &PjSave::GetPtrAddr)
			.addFunction("Load", &PjSave::Load)
			.addFunction("LoadEffect", &PjSave::LoadEffect)
		.endClass();
	}
#endif
};
static_assert(sizeof(PjSave) == 0x2128, "expected PjSave to be size 0x2128");

// Unsupported destructor
//void __convention("thiscall") MessLines::~MessLines(class MessLines* const this)
// Unsupported constructor
//void __convention("thiscall") MessLines::MessLines(class MessLines* const this, struct GdlLines* arg2, class ghmListObj* arg3)
// Unsupported destructor
//void __convention("thiscall") HrMessage::~HrMessage(class HrMessage* const this)
// Unsupported constructor
//void __convention("thiscall") HrMessage::HrMessage(class HrMessage* const this, void* arg2)
// Unsupported destructor
//void __convention("thiscall") PJTateshi::~PJTateshi(class PJTateshi* const this)
// Unsupported constructor
//void __convention("thiscall") PJTateshi::PJTateshi(class PJTateshi* const this)
// Unsupported destructor
//void __convention("thiscall") mHRItem::~mHRItem(class mHRItem* const this)
// Unsupported constructor
//void __convention("thiscall") mHRItem::mHRItem(class mHRItem* const this, struct Vec* arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
// Unsupported destructor
//void __convention("thiscall") PJZAKO::~PJZAKO(class PJZAKO* const this)
// Unsupported constructor
//void __convention("thiscall") PJZAKO::PJZAKO(class PJZAKO* const this)
// enum eZkPopCar
enum eZkPopCar : uint32_t
{
	// <eZkPopCar_UNKNOWN = 0xffffffffffffffff>
	eZkPopCar_UNKNOWN = UINT32_MAX,

	// <eZkPopCar_VAN = 0x0>
	eZkPopCar_VAN = 0,

	// <eZkPopCar_SEDAN = 0x1>
	eZkPopCar_SEDAN = 1,

	// <eZkPopCar_NUM = 0x2>
	eZkPopCar_NUM = 2

};

// [Structure] class PJZakoCarBase
class PJZakoCarBase : public mHRChara
{
public:
	// enum PJZakoCarBase::eStat
	enum eStat : uint32_t
	{
		// <eStat_Initialize = 0x0>
		eStat_Initialize = 0,

		// <eStat_StandBY = 0x1>
		eStat_StandBY = 1,

		// <eStat_WayPoint = 0x2>
		eStat_WayPoint = 2,

		// <eStat_ReachGoal = 0x3>
		eStat_ReachGoal = 3,

		// <eStat_GetOffZako = 0x4>
		eStat_GetOffZako = 4

	};

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <enum PJZakoCarBase::eStat m_eStat, offset 0x580>
	enum PJZakoCarBase::eStat m_eStat;

	// <enum eZkPopCar m_eZkPopCar, offset 0x584>
	enum eZkPopCar m_eZkPopCar;

	// <class FkStlVector<Vec> m_WayPointArr, offset 0x588>
	class FkStlVector<Vec> m_WayPointArr;

	// <int32_t m_iNowWayPoint, offset 0x59c>
	int32_t m_iNowWayPoint = 0;

	// <uint8_t m_DoorOpenFlag[0x5], offset 0x5a0>
	uint8_t m_DoorOpenFlag[5];

	// <Unidentified data segment, offset 0x5a5>
private:
	char _UnidentifiedData_1445[3];

public:
	// <class WGcl mGcl, offset 0x5a8>
	class WGcl mGcl;

	// <uint8_t m_boAttackChar, offset 0x614>
	uint8_t m_boAttackChar = 0;

	// <Unidentified data segment, offset 0x615>
private:
	char _UnidentifiedData_1557[3];

public:
	// <float m_fSpd, offset 0x618>
	float m_fSpd = 0;

	// <float m_fBreakRunOverDist, offset 0x61c>
	float m_fBreakRunOverDist = 0;

	// <int32_t m_SeHnd_IdleEngine, offset 0x620>
	int32_t m_SeHnd_IdleEngine = 0;

	// <int32_t m_SeHnd_Driving, offset 0x624>
	int32_t m_SeHnd_Driving = 0;

	// <float m_fSeDrivePitch, offset 0x628>
	float m_fSeDrivePitch = 0;

	// <uint8_t m_boBreak, offset 0x62c>
	uint8_t m_boBreak = 0;

	// <uint8_t m_boReqDeleteOutOfCamera, offset 0x62d>
	uint8_t m_boReqDeleteOutOfCamera = 0;

	// <Unidentified data segment, offset 0x62e>
private:
	char _UnidentifiedData_1582[2];

public:
	/// 1 Functions

	// [Function] void __convention("thiscall") PJZakoCarBase::GetOffZako(class PJZakoCarBase* const this, class PJZAKO* arg2, enum eZkCarSheet& arg3) [?GetOffZako@PJZakoCarBase@@QAEXPAVPJZAKO@@ABW4eZkCarSheet@@@Z]
	typedef void(__thiscall* _GetOffZako_PJZakoCarBase__QAEXPAVPJZAKO__ABW4eZkCarSheet___Z)(class PJZakoCarBase* const thisPtr, class PJZAKO* arg2, enum eZkCarSheet& arg3);
	void GetOffZako(class PJZAKO* arg2, /* enum eZkCarSheet& */ uint32_t arg3)
	{
		_GetOffZako_PJZakoCarBase__QAEXPAVPJZAKO__ABW4eZkCarSheet___Z mFunc = (_GetOffZako_PJZakoCarBase__QAEXPAVPJZAKO__ABW4eZkCarSheet___Z)(GameModule + 0x4e1ec0);
		return mFunc(this, arg2, (enum eZkCarSheet&)arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZakoCarBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZakoCarBase& InObject)
	{
		m_eStat = InObject.m_eStat;
		m_eZkPopCar = InObject.m_eZkPopCar;
		m_WayPointArr = InObject.m_WayPointArr;
		m_iNowWayPoint = InObject.m_iNowWayPoint;
		mGcl = InObject.mGcl;
		m_boAttackChar = InObject.m_boAttackChar;
		m_fSpd = InObject.m_fSpd;
		m_fBreakRunOverDist = InObject.m_fBreakRunOverDist;
		m_SeHnd_IdleEngine = InObject.m_SeHnd_IdleEngine;
		m_SeHnd_Driving = InObject.m_SeHnd_Driving;
		m_fSeDrivePitch = InObject.m_fSeDrivePitch;
		m_boBreak = InObject.m_boBreak;
		m_boReqDeleteOutOfCamera = InObject.m_boReqDeleteOutOfCamera;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZakoCarBase, mHRChara>("PJZakoCarBase")
			.addFunction("__tostring", &PJZakoCarBase::ToString)
			.addFunction("GetPtrAddr", &PJZakoCarBase::GetPtrAddr)
			.addProperty("m_eStat", &PJZakoCarBase::m_eStat)
			.addProperty("m_eZkPopCar", &PJZakoCarBase::m_eZkPopCar)
			.addProperty("m_WayPointArr", &PJZakoCarBase::m_WayPointArr)
			.addProperty("m_iNowWayPoint", &PJZakoCarBase::m_iNowWayPoint)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_DoorOpenFlag", &PJZakoCarBase::m_DoorOpenFlag)
			.addProperty("mGcl", &PJZakoCarBase::mGcl)
			.addProperty("m_boAttackChar", &PJZakoCarBase::m_boAttackChar)
			.addProperty("m_fSpd", &PJZakoCarBase::m_fSpd)
			.addProperty("m_fBreakRunOverDist", &PJZakoCarBase::m_fBreakRunOverDist)
			.addProperty("m_SeHnd_IdleEngine", &PJZakoCarBase::m_SeHnd_IdleEngine)
			.addProperty("m_SeHnd_Driving", &PJZakoCarBase::m_SeHnd_Driving)
			.addProperty("m_fSeDrivePitch", &PJZakoCarBase::m_fSeDrivePitch)
			.addProperty("m_boBreak", &PJZakoCarBase::m_boBreak)
			.addProperty("m_boReqDeleteOutOfCamera", &PJZakoCarBase::m_boReqDeleteOutOfCamera)
			// Can't export & pointer 'enum eZkCarSheet&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("GetOffZako", &PJZakoCarBase::GetOffZako)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoCarBase::m_eStat) == 4, "expected PJZakoCarBase::m_eStat to be size 4");
static_assert(sizeof(PJZakoCarBase::m_eZkPopCar) == 4, "expected PJZakoCarBase::m_eZkPopCar to be size 4");
static_assert(sizeof(PJZakoCarBase::m_WayPointArr) == 20, "expected PJZakoCarBase::m_WayPointArr to be size 20");
static_assert(sizeof(PJZakoCarBase::m_iNowWayPoint) == 4, "expected PJZakoCarBase::m_iNowWayPoint to be size 4");
static_assert(sizeof(PJZakoCarBase::m_DoorOpenFlag) == 5, "expected PJZakoCarBase::m_DoorOpenFlag to be size 5");
static_assert(sizeof(PJZakoCarBase::mGcl) == 108, "expected PJZakoCarBase::mGcl to be size 108");
static_assert(sizeof(PJZakoCarBase::m_boAttackChar) == 1, "expected PJZakoCarBase::m_boAttackChar to be size 1");
static_assert(sizeof(PJZakoCarBase::m_fSpd) == 4, "expected PJZakoCarBase::m_fSpd to be size 4");
static_assert(sizeof(PJZakoCarBase::m_fBreakRunOverDist) == 4, "expected PJZakoCarBase::m_fBreakRunOverDist to be size 4");
static_assert(sizeof(PJZakoCarBase::m_SeHnd_IdleEngine) == 4, "expected PJZakoCarBase::m_SeHnd_IdleEngine to be size 4");
static_assert(sizeof(PJZakoCarBase::m_SeHnd_Driving) == 4, "expected PJZakoCarBase::m_SeHnd_Driving to be size 4");
static_assert(sizeof(PJZakoCarBase::m_fSeDrivePitch) == 4, "expected PJZakoCarBase::m_fSeDrivePitch to be size 4");
static_assert(sizeof(PJZakoCarBase::m_boBreak) == 1, "expected PJZakoCarBase::m_boBreak to be size 1");
static_assert(sizeof(PJZakoCarBase::m_boReqDeleteOutOfCamera) == 1, "expected PJZakoCarBase::m_boReqDeleteOutOfCamera to be size 1");
static_assert(sizeof(PJZakoCarBase) == 0x630, "expected PJZakoCarBase to be size 0x630");

// [Structure] class PJZakoCarVan
class PJZakoCarVan : public PJZakoCarBase
{
public:
	/// Struct member variables

	// <class PJZakoCarBase field_0, offset 0x0>
	// class PJZakoCarBase Super;

	/// 1 Functions

	// [Function] void __convention("thiscall") PJZakoCarVan::SetZakoGetOffStartPosRot(class PJZakoCarVan* const this, class PJZAKO* arg2, enum eZkCarSheet& arg3) [?SetZakoGetOffStartPosRot@PJZakoCarVan@@UAEXPAVPJZAKO@@ABW4eZkCarSheet@@@Z]
	typedef void(__thiscall* _SetZakoGetOffStartPosRot_PJZakoCarVan__UAEXPAVPJZAKO__ABW4eZkCarSheet___Z)(class PJZakoCarVan* const thisPtr, class PJZAKO* arg2, enum eZkCarSheet& arg3);
	void SetZakoGetOffStartPosRot(class PJZAKO* arg2, /* enum eZkCarSheet& */ uint32_t arg3)
	{
		_SetZakoGetOffStartPosRot_PJZakoCarVan__UAEXPAVPJZAKO__ABW4eZkCarSheet___Z mFunc = (_SetZakoGetOffStartPosRot_PJZakoCarVan__UAEXPAVPJZAKO__ABW4eZkCarSheet___Z)(GameModule + 0x4e0130);
		return mFunc(this, arg2, (enum eZkCarSheet&)arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZakoCarVan [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZakoCarVan& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZakoCarVan, PJZakoCarBase>("PJZakoCarVan")
			.addFunction("__tostring", &PJZakoCarVan::ToString)
			.addFunction("GetPtrAddr", &PJZakoCarVan::GetPtrAddr)
			// Can't export & pointer 'enum eZkCarSheet&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetZakoGetOffStartPosRot", &PJZakoCarVan::SetZakoGetOffStartPosRot)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoCarVan) == 0x630, "expected PJZakoCarVan to be size 0x630");

// [Structure] class PJZakoCarSedan
class PJZakoCarSedan : public PJZakoCarBase
{
public:
	/// Struct member variables

	// <class PJZakoCarBase field_0, offset 0x0>
	// class PJZakoCarBase Super;

	/// 1 Functions

	// [Function] void __convention("thiscall") PJZakoCarSedan::SetZakoGetOffStartPosRot(class PJZakoCarSedan* const this, class PJZAKO* arg2, enum eZkCarSheet& arg3) [?SetZakoGetOffStartPosRot@PJZakoCarSedan@@EAEXPAVPJZAKO@@ABW4eZkCarSheet@@@Z]
	typedef void(__thiscall* _SetZakoGetOffStartPosRot_PJZakoCarSedan__EAEXPAVPJZAKO__ABW4eZkCarSheet___Z)(class PJZakoCarSedan* const thisPtr, class PJZAKO* arg2, enum eZkCarSheet& arg3);
	void SetZakoGetOffStartPosRot(class PJZAKO* arg2, /* enum eZkCarSheet& */ uint32_t arg3)
	{
		_SetZakoGetOffStartPosRot_PJZakoCarSedan__EAEXPAVPJZAKO__ABW4eZkCarSheet___Z mFunc = (_SetZakoGetOffStartPosRot_PJZakoCarSedan__EAEXPAVPJZAKO__ABW4eZkCarSheet___Z)(GameModule + 0x4e0230);
		return mFunc(this, arg2, (enum eZkCarSheet&)arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZakoCarSedan [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZakoCarSedan& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZakoCarSedan, PJZakoCarBase>("PJZakoCarSedan")
			.addFunction("__tostring", &PJZakoCarSedan::ToString)
			.addFunction("GetPtrAddr", &PJZakoCarSedan::GetPtrAddr)
			// Can't export & pointer 'enum eZkCarSheet&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetZakoGetOffStartPosRot", &PJZakoCarSedan::SetZakoGetOffStartPosRot)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoCarSedan) == 0x630, "expected PJZakoCarSedan to be size 0x630");

// enum enRotDir
enum enRotDir : uint32_t
{
	// <eRotRight = 0x0>
	eRotRight = 0,

	// <eRotLeft = 0x1>
	eRotLeft = 1,

	// <eRotMax = 0x2>
	eRotMax = 2

};

// [Structure] struct stRotDat
struct stRotDat
{
public:
	/// Struct member variables

	// <char cnt, offset 0x0>
	char cnt;

	// <char process, offset 0x1>
	char process;

	// <Unidentified data segment, offset 0x2>
private:
	char _UnidentifiedData_2[2];

public:
	// <enum enRotDir dir, offset 0x4>
	enum enRotDir dir;

	// <enum enAccDir accDir, offset 0x8>
	enum enAccDir accDir;

	// <int32_t limitTick, offset 0xc>
	int32_t limitTick = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct stRotDat [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(stRotDat& InObject)
	{
		cnt = InObject.cnt;
		process = InObject.process;
		dir = InObject.dir;
		accDir = InObject.accDir;
		limitTick = InObject.limitTick;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stRotDat>("stRotDat")
			.addFunction("__tostring", &stRotDat::ToString)
			.addFunction("GetPtrAddr", &stRotDat::GetPtrAddr)
			.addProperty("cnt", &stRotDat::cnt)
			.addProperty("process", &stRotDat::process)
			.addProperty("dir", &stRotDat::dir)
			.addProperty("accDir", &stRotDat::accDir)
			.addProperty("limitTick", &stRotDat::limitTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(stRotDat::cnt) == 1, "expected stRotDat::cnt to be size 1");
static_assert(sizeof(stRotDat::process) == 1, "expected stRotDat::process to be size 1");
static_assert(sizeof(stRotDat::dir) == 4, "expected stRotDat::dir to be size 4");
static_assert(sizeof(stRotDat::accDir) == 4, "expected stRotDat::accDir to be size 4");
static_assert(sizeof(stRotDat::limitTick) == 4, "expected stRotDat::limitTick to be size 4");
static_assert(sizeof(stRotDat) == 0x10, "expected stRotDat to be size 0x10");

// Unsupported constructor
//void __convention("thiscall") mHRPad::mHRPad(class mHRPad* const this)
// Unsupported destructor
//void __convention("thiscall") mHRPad::~mHRPad(class mHRPad* const this)
// Unsupported destructor
//void __convention("thiscall") pcSNB::~pcSNB(class pcSNB* const this)
// Unsupported constructor
//void __convention("thiscall") pcSNB::pcSNB(class pcSNB* const this)
// Unsupported destructor
//void __convention("thiscall") pcHEN::~pcHEN(class pcHEN* const this)
// Unsupported constructor
//void __convention("thiscall") pcHEN::pcHEN(class pcHEN* const this)
// [Structure] class ZkState_HandGun_Shoot
class ZkState_HandGun_Shoot : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_WaitTriggerCnt, offset 0x4>
	int32_t m_WaitTriggerCnt = 0;

	// <int32_t m_nShot, offset 0x8>
	int32_t m_nShot = 0;

	// <uint8_t m_boTrigger, offset 0xc>
	uint8_t m_boTrigger = 0;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData_13[3];

public:
	/// 4 Functions

	// [Function] void __convention("thiscall") ZkState_HandGun_Shoot::Exit(class ZkState_HandGun_Shoot* const this, class PJZAKO* arg2) [?Exit@ZkState_HandGun_Shoot@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z)(class ZkState_HandGun_Shoot* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z)(GameModule + 0x4fc030);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_HandGun_Shoot::ChangeStateCondition(class ZkState_HandGun_Shoot* const this, class PJZAKO* arg2) [?ChangeStateCondition@ZkState_HandGun_Shoot@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_ZkState_HandGun_Shoot__QAEXPAVPJZAKO___Z)(class ZkState_HandGun_Shoot* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_ZkState_HandGun_Shoot__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_ZkState_HandGun_Shoot__QAEXPAVPJZAKO___Z)(GameModule + 0x4fc090);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_HandGun_Shoot::Execute(class ZkState_HandGun_Shoot* const this, class PJZAKO* arg2) [?Execute@ZkState_HandGun_Shoot@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z)(class ZkState_HandGun_Shoot* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z)(GameModule + 0x4fc120);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_HandGun_Shoot::Enter(class ZkState_HandGun_Shoot* const this, class PJZAKO* arg2) [?Enter@ZkState_HandGun_Shoot@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z)(class ZkState_HandGun_Shoot* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_HandGun_Shoot__UAEXPAVPJZAKO___Z)(GameModule + 0x4fc3d0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_HandGun_Shoot [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_HandGun_Shoot& InObject)
	{
		m_WaitTriggerCnt = InObject.m_WaitTriggerCnt;
		m_nShot = InObject.m_nShot;
		m_boTrigger = InObject.m_boTrigger;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_HandGun_Shoot, PJState>("ZkState_HandGun_Shoot")
			.addFunction("__tostring", &ZkState_HandGun_Shoot::ToString)
			.addFunction("GetPtrAddr", &ZkState_HandGun_Shoot::GetPtrAddr)
			.addProperty("m_WaitTriggerCnt", &ZkState_HandGun_Shoot::m_WaitTriggerCnt)
			.addProperty("m_nShot", &ZkState_HandGun_Shoot::m_nShot)
			.addProperty("m_boTrigger", &ZkState_HandGun_Shoot::m_boTrigger)
			.addFunction("Exit", &ZkState_HandGun_Shoot::Exit)
			.addFunction("ChangeStateCondition", &ZkState_HandGun_Shoot::ChangeStateCondition)
			.addFunction("Execute", &ZkState_HandGun_Shoot::Execute)
			.addFunction("Enter", &ZkState_HandGun_Shoot::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_HandGun_Shoot::m_WaitTriggerCnt) == 4, "expected ZkState_HandGun_Shoot::m_WaitTriggerCnt to be size 4");
static_assert(sizeof(ZkState_HandGun_Shoot::m_nShot) == 4, "expected ZkState_HandGun_Shoot::m_nShot to be size 4");
static_assert(sizeof(ZkState_HandGun_Shoot::m_boTrigger) == 1, "expected ZkState_HandGun_Shoot::m_boTrigger to be size 1");
static_assert(sizeof(ZkState_HandGun_Shoot) == 0x10, "expected ZkState_HandGun_Shoot to be size 0x10");

// [Structure] class ZkState_SubMachingeGun_Shoot
class ZkState_SubMachingeGun_Shoot : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_WaitTriggerCnt, offset 0x4>
	int32_t m_WaitTriggerCnt = 0;

	// <int32_t m_Counter, offset 0x8>
	int32_t m_Counter = 0;

	// <int32_t m_nFired, offset 0xc>
	int32_t m_nFired = 0;

	/// 4 Functions

	// [Function] void __convention("thiscall") ZkState_SubMachingeGun_Shoot::Exit(class ZkState_SubMachingeGun_Shoot* const this, class PJZAKO* arg2) [?Exit@ZkState_SubMachingeGun_Shoot@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z)(class ZkState_SubMachingeGun_Shoot* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z)(GameModule + 0x4fcc20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_SubMachingeGun_Shoot::ChangeStateCondition(class ZkState_SubMachingeGun_Shoot* const this, class PJZAKO* arg2) [?ChangeStateCondition@ZkState_SubMachingeGun_Shoot@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_ZkState_SubMachingeGun_Shoot__QAEXPAVPJZAKO___Z)(class ZkState_SubMachingeGun_Shoot* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_ZkState_SubMachingeGun_Shoot__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_ZkState_SubMachingeGun_Shoot__QAEXPAVPJZAKO___Z)(GameModule + 0x4fcc80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_SubMachingeGun_Shoot::Execute(class ZkState_SubMachingeGun_Shoot* const this, class PJZAKO* arg2) [?Execute@ZkState_SubMachingeGun_Shoot@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z)(class ZkState_SubMachingeGun_Shoot* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z)(GameModule + 0x4fcd10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_SubMachingeGun_Shoot::Enter(class ZkState_SubMachingeGun_Shoot* const this, class PJZAKO* arg2) [?Enter@ZkState_SubMachingeGun_Shoot@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z)(class ZkState_SubMachingeGun_Shoot* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_SubMachingeGun_Shoot__UAEXPAVPJZAKO___Z)(GameModule + 0x4fcf70);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_SubMachingeGun_Shoot [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_SubMachingeGun_Shoot& InObject)
	{
		m_WaitTriggerCnt = InObject.m_WaitTriggerCnt;
		m_Counter = InObject.m_Counter;
		m_nFired = InObject.m_nFired;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_SubMachingeGun_Shoot, PJState>("ZkState_SubMachingeGun_Shoot")
			.addFunction("__tostring", &ZkState_SubMachingeGun_Shoot::ToString)
			.addFunction("GetPtrAddr", &ZkState_SubMachingeGun_Shoot::GetPtrAddr)
			.addProperty("m_WaitTriggerCnt", &ZkState_SubMachingeGun_Shoot::m_WaitTriggerCnt)
			.addProperty("m_Counter", &ZkState_SubMachingeGun_Shoot::m_Counter)
			.addProperty("m_nFired", &ZkState_SubMachingeGun_Shoot::m_nFired)
			.addFunction("Exit", &ZkState_SubMachingeGun_Shoot::Exit)
			.addFunction("ChangeStateCondition", &ZkState_SubMachingeGun_Shoot::ChangeStateCondition)
			.addFunction("Execute", &ZkState_SubMachingeGun_Shoot::Execute)
			.addFunction("Enter", &ZkState_SubMachingeGun_Shoot::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_SubMachingeGun_Shoot::m_WaitTriggerCnt) == 4, "expected ZkState_SubMachingeGun_Shoot::m_WaitTriggerCnt to be size 4");
static_assert(sizeof(ZkState_SubMachingeGun_Shoot::m_Counter) == 4, "expected ZkState_SubMachingeGun_Shoot::m_Counter to be size 4");
static_assert(sizeof(ZkState_SubMachingeGun_Shoot::m_nFired) == 4, "expected ZkState_SubMachingeGun_Shoot::m_nFired to be size 4");
static_assert(sizeof(ZkState_SubMachingeGun_Shoot) == 0x10, "expected ZkState_SubMachingeGun_Shoot to be size 0x10");

// [Structure] class State_SubMachineGunDying
class State_SubMachineGunDying : public State_Dying
{
public:
	/// Struct member variables

	// <class State_Dying field_0, offset 0x0>
	// class State_Dying Super;

	// <int32_t m_Counter, offset 0x4>
	int32_t m_Counter = 0;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_SubMachineGunDying::Exit(class State_SubMachineGunDying* const this, class PJZAKO* arg2) [?Exit@State_SubMachineGunDying@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_SubMachineGunDying__UAEXPAVPJZAKO___Z)(class State_SubMachineGunDying* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_SubMachineGunDying__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_SubMachineGunDying__UAEXPAVPJZAKO___Z)(GameModule + 0x4fcff0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_SubMachineGunDying::Execute(class State_SubMachineGunDying* const this, class PJZAKO* arg2) [?Execute@State_SubMachineGunDying@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_SubMachineGunDying__UAEXPAVPJZAKO___Z)(class State_SubMachineGunDying* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_SubMachineGunDying__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_SubMachineGunDying__UAEXPAVPJZAKO___Z)(GameModule + 0x4fd000);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_SubMachineGunDying::ChangeStateCondition(class State_SubMachineGunDying* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_SubMachineGunDying@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_SubMachineGunDying__QAEXPAVPJZAKO___Z)(class State_SubMachineGunDying* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_SubMachineGunDying__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_SubMachineGunDying__QAEXPAVPJZAKO___Z)(GameModule + 0x4fd080);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_SubMachineGunDying::Enter(class State_SubMachineGunDying* const this, class PJZAKO* arg2) [?Enter@State_SubMachineGunDying@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_SubMachineGunDying__UAEXPAVPJZAKO___Z)(class State_SubMachineGunDying* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_SubMachineGunDying__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_SubMachineGunDying__UAEXPAVPJZAKO___Z)(GameModule + 0x4fd090);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_SubMachineGunDying [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_SubMachineGunDying& InObject)
	{
		m_Counter = InObject.m_Counter;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_SubMachineGunDying, State_Dying>("State_SubMachineGunDying")
			.addFunction("__tostring", &State_SubMachineGunDying::ToString)
			.addFunction("GetPtrAddr", &State_SubMachineGunDying::GetPtrAddr)
			.addProperty("m_Counter", &State_SubMachineGunDying::m_Counter)
			.addFunction("Exit", &State_SubMachineGunDying::Exit)
			.addFunction("Execute", &State_SubMachineGunDying::Execute)
			.addFunction("ChangeStateCondition", &State_SubMachineGunDying::ChangeStateCondition)
			.addFunction("Enter", &State_SubMachineGunDying::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_SubMachineGunDying::m_Counter) == 4, "expected State_SubMachineGunDying::m_Counter to be size 4");
static_assert(sizeof(State_SubMachineGunDying) == 0x8, "expected State_SubMachineGunDying to be size 0x8");

// [Structure] class State_Tojo_Knife_SuddenAttack
class State_Tojo_Knife_SuddenAttack : public State_Tojo_SuddenAttack
{
public:
	// enum State_Tojo_Knife_SuddenAttack::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_WaitPcClose = 0x1>
		eStat_WaitPcClose = 1,

		// <eStat_Attack = 0x2>
		eStat_Attack = 2

	};

	/// Struct member variables

	// <class State_Tojo_SuddenAttack field_0, offset 0x0>
	// class State_Tojo_SuddenAttack Super;

	// <enum State_Tojo_Knife_SuddenAttack::eStat m_eStat, offset 0x4>
	enum State_Tojo_Knife_SuddenAttack::eStat m_eStat;

	// <struct Vec m_TrapPos, offset 0x8>
	struct Vec m_TrapPos;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_Tojo_Knife_SuddenAttack::Exit(class State_Tojo_Knife_SuddenAttack* const this, class PJZAKO* arg2) [?Exit@State_Tojo_Knife_SuddenAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z)(class State_Tojo_Knife_SuddenAttack* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x4fdbf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Knife_SuddenAttack::ChangeStateCondition(class State_Tojo_Knife_SuddenAttack* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_Tojo_Knife_SuddenAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z)(class State_Tojo_Knife_SuddenAttack* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x4fdc20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Knife_SuddenAttack::Execute(class State_Tojo_Knife_SuddenAttack* const this, class PJZAKO* arg2) [?Execute@State_Tojo_Knife_SuddenAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z)(class State_Tojo_Knife_SuddenAttack* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x4fdc30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_Tojo_Knife_SuddenAttack::Enter(class State_Tojo_Knife_SuddenAttack* const this, class PJZAKO* arg2) [?Enter@State_Tojo_Knife_SuddenAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z)(class State_Tojo_Knife_SuddenAttack* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_Tojo_Knife_SuddenAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x4fdf10);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_Tojo_Knife_SuddenAttack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_Tojo_Knife_SuddenAttack& InObject)
	{
		m_eStat = InObject.m_eStat;
		m_TrapPos = InObject.m_TrapPos;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Knife_SuddenAttack, State_Tojo_SuddenAttack>("State_Tojo_Knife_SuddenAttack")
			.addFunction("__tostring", &State_Tojo_Knife_SuddenAttack::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Knife_SuddenAttack::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_Knife_SuddenAttack::m_eStat)
			.addProperty("m_TrapPos", &State_Tojo_Knife_SuddenAttack::m_TrapPos)
			.addFunction("Exit", &State_Tojo_Knife_SuddenAttack::Exit)
			.addFunction("ChangeStateCondition", &State_Tojo_Knife_SuddenAttack::ChangeStateCondition)
			.addFunction("Execute", &State_Tojo_Knife_SuddenAttack::Execute)
			.addFunction("Enter", &State_Tojo_Knife_SuddenAttack::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Knife_SuddenAttack::m_eStat) == 4, "expected State_Tojo_Knife_SuddenAttack::m_eStat to be size 4");
static_assert(sizeof(State_Tojo_Knife_SuddenAttack::m_TrapPos) == 12, "expected State_Tojo_Knife_SuddenAttack::m_TrapPos to be size 12");
static_assert(sizeof(State_Tojo_Knife_SuddenAttack) == 0x14, "expected State_Tojo_Knife_SuddenAttack to be size 0x14");

// [Structure] class ZkKnifeState_ThroughKnife
class ZkKnifeState_ThroughKnife : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <uint8_t m_boTrigger, offset 0x4>
	uint8_t m_boTrigger = 0;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	/// 4 Functions

	// [Function] void __convention("thiscall") ZkKnifeState_ThroughKnife::Exit(class ZkKnifeState_ThroughKnife* const this, class PJZAKO* arg2) [?Exit@ZkKnifeState_ThroughKnife@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z)(class ZkKnifeState_ThroughKnife* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z)(GameModule + 0x4fe320);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkKnifeState_ThroughKnife::ChangeStateCondition(class ZkKnifeState_ThroughKnife* const this, class PJZAKO* arg2) [?ChangeStateCondition@ZkKnifeState_ThroughKnife@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_ZkKnifeState_ThroughKnife__QAEXPAVPJZAKO___Z)(class ZkKnifeState_ThroughKnife* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_ZkKnifeState_ThroughKnife__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_ZkKnifeState_ThroughKnife__QAEXPAVPJZAKO___Z)(GameModule + 0x4fe340);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkKnifeState_ThroughKnife::Execute(class ZkKnifeState_ThroughKnife* const this, class PJZAKO* arg2) [?Execute@ZkKnifeState_ThroughKnife@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z)(class ZkKnifeState_ThroughKnife* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z)(GameModule + 0x4fe3a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkKnifeState_ThroughKnife::Enter(class ZkKnifeState_ThroughKnife* const this, class PJZAKO* arg2) [?Enter@ZkKnifeState_ThroughKnife@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z)(class ZkKnifeState_ThroughKnife* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkKnifeState_ThroughKnife__UAEXPAVPJZAKO___Z)(GameModule + 0x4fe4c0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkKnifeState_ThroughKnife [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkKnifeState_ThroughKnife& InObject)
	{
		m_boTrigger = InObject.m_boTrigger;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkKnifeState_ThroughKnife, PJState>("ZkKnifeState_ThroughKnife")
			.addFunction("__tostring", &ZkKnifeState_ThroughKnife::ToString)
			.addFunction("GetPtrAddr", &ZkKnifeState_ThroughKnife::GetPtrAddr)
			.addProperty("m_boTrigger", &ZkKnifeState_ThroughKnife::m_boTrigger)
			.addFunction("Exit", &ZkKnifeState_ThroughKnife::Exit)
			.addFunction("ChangeStateCondition", &ZkKnifeState_ThroughKnife::ChangeStateCondition)
			.addFunction("Execute", &ZkKnifeState_ThroughKnife::Execute)
			.addFunction("Enter", &ZkKnifeState_ThroughKnife::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkKnifeState_ThroughKnife::m_boTrigger) == 1, "expected ZkKnifeState_ThroughKnife::m_boTrigger to be size 1");
static_assert(sizeof(ZkKnifeState_ThroughKnife) == 0x8, "expected ZkKnifeState_ThroughKnife to be size 0x8");

// [Structure] class PJZakoKnife
class PJZakoKnife : public PJZAKOBoneB
{
public:
	/// Struct member variables

	// <class PJZAKOBoneB field_0, offset 0x0>
	// class PJZAKOBoneB Super;

	// <class ZkKnifeState_ThroughKnife m_State_ThroughKnife, offset 0x9e4>
	class ZkKnifeState_ThroughKnife m_State_ThroughKnife;

	// <class State_Tojo_Knife_SuddenAttack m_State_SdnAtk, offset 0x9ec>
	class State_Tojo_Knife_SuddenAttack m_State_SdnAtk;

	/// 1 Functions

	// [Function] int32_t __convention("thiscall") PJZakoKnife::ConvertDmgMot(class PJZakoKnife* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4) [?ConvertDmgMot@PJZakoKnife@@UAEHHHPAVmHRChara@@@Z]
	typedef int32_t(__thiscall* _ConvertDmgMot_PJZakoKnife__UAEHHHPAVmHRChara___Z)(class PJZakoKnife* const thisPtr, int32_t const arg2, int32_t const arg3, class mHRChara* arg4);
	int32_t ConvertDmgMot(int32_t const arg2, int32_t const arg3, class mHRChara* arg4)
	{
		_ConvertDmgMot_PJZakoKnife__UAEHHHPAVmHRChara___Z mFunc = (_ConvertDmgMot_PJZakoKnife__UAEHHHPAVmHRChara___Z)(GameModule + 0x4fd290);
		return mFunc(this, arg2, arg3, arg4);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJZakoKnife [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJZakoKnife& InObject)
	{
		m_State_ThroughKnife = InObject.m_State_ThroughKnife;
		m_State_SdnAtk = InObject.m_State_SdnAtk;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZakoKnife, PJZAKOBoneB>("PJZakoKnife")
			.addFunction("__tostring", &PJZakoKnife::ToString)
			.addFunction("GetPtrAddr", &PJZakoKnife::GetPtrAddr)
			.addProperty("m_State_ThroughKnife", &PJZakoKnife::m_State_ThroughKnife)
			.addProperty("m_State_SdnAtk", &PJZakoKnife::m_State_SdnAtk)
			.addFunction("ConvertDmgMot", &PJZakoKnife::ConvertDmgMot)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoKnife::m_State_ThroughKnife) == 8, "expected PJZakoKnife::m_State_ThroughKnife to be size 8");
static_assert(sizeof(PJZakoKnife::m_State_SdnAtk) == 20, "expected PJZakoKnife::m_State_SdnAtk to be size 20");
static_assert(sizeof(PJZakoKnife) == 0xa00, "expected PJZakoKnife to be size 0xa00");

// [Structure] class ZkState_Kakuto_Hagaijime
class ZkState_Kakuto_Hagaijime : public PJState
{
public:
	// enum ZkState_Kakuto_Hagaijime::eStat
	enum eStat : uint32_t
	{
		// <eStat_HagaTry_In = 0x0>
		eStat_HagaTry_In = 0,

		// <eStat_HagaFalse = 0x1>
		eStat_HagaFalse = 1,

		// <eStat_HagaSuccess = 0x2>
		eStat_HagaSuccess = 2,

		// <eStat_HagaIng = 0x3>
		eStat_HagaIng = 3,

		// <eStat_HagaPcDamage = 0x4>
		eStat_HagaPcDamage = 4,

		// <eStat_HagaFuritokare = 0x5>
		eStat_HagaFuritokare = 5,

		// <eStat_HagaFuritoki = 0x6>
		eStat_HagaFuritoki = 6

	};

	// enum ZkState_Kakuto_Hagaijime::eReleaseType
	enum eReleaseType : uint32_t
	{
		// <eReleaseType_UNKNOWN = 0xffffffffffffffff>
		eReleaseType_UNKNOWN = UINT32_MAX,

		// <eReleaseType_PcJiriki = 0x0>
		eReleaseType_PcJiriki = 0,

		// <eReleaseType_ZakoFuritoki = 0x1>
		eReleaseType_ZakoFuritoki = 1

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum ZkState_Kakuto_Hagaijime::eStat m_eStat, offset 0x4>
	enum ZkState_Kakuto_Hagaijime::eStat m_eStat;

	// <int32_t m_HagaCnt, offset 0x8>
	int32_t m_HagaCnt = 0;

	// <uint8_t m_boReleasedPc, offset 0xc>
	uint8_t m_boReleasedPc = 0;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData_13[3];

public:
	// <enum ZkState_Kakuto_Hagaijime::eReleaseType m_eReleaseType, offset 0x10>
	enum ZkState_Kakuto_Hagaijime::eReleaseType m_eReleaseType;

	// <uint8_t m_boCatchSuccess, offset 0x14>
	uint8_t m_boCatchSuccess = 0;

	// <uint8_t m_boPcDeadRelease, offset 0x15>
	uint8_t m_boPcDeadRelease = 0;

	// <Unidentified data segment, offset 0x16>
private:
	char _UnidentifiedData_22[2];

public:
	/// 4 Functions

	// [Function] void __convention("thiscall") ZkState_Kakuto_Hagaijime::Exit(class ZkState_Kakuto_Hagaijime* const this, class PJZAKO* arg2) [?Exit@ZkState_Kakuto_Hagaijime@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z)(class ZkState_Kakuto_Hagaijime* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z mFunc = (_Exit_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z)(GameModule + 0x4feb30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_Kakuto_Hagaijime::PcDamageProc(class ZkState_Kakuto_Hagaijime* const this, class PJZAKO* arg2) [?PcDamageProc@ZkState_Kakuto_Hagaijime@@AAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _PcDamageProc_ZkState_Kakuto_Hagaijime__AAEXPAVPJZAKO___Z)(class ZkState_Kakuto_Hagaijime* const thisPtr, class PJZAKO* arg2);
	void PcDamageProc(class PJZAKO* arg2)
	{
		_PcDamageProc_ZkState_Kakuto_Hagaijime__AAEXPAVPJZAKO___Z mFunc = (_PcDamageProc_ZkState_Kakuto_Hagaijime__AAEXPAVPJZAKO___Z)(GameModule + 0x4fec30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_Kakuto_Hagaijime::Execute(class ZkState_Kakuto_Hagaijime* const this, class PJZAKO* arg2) [?Execute@ZkState_Kakuto_Hagaijime@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z)(class ZkState_Kakuto_Hagaijime* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z)(GameModule + 0x4fee20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_Kakuto_Hagaijime::Enter(class ZkState_Kakuto_Hagaijime* const this, class PJZAKO* arg2) [?Enter@ZkState_Kakuto_Hagaijime@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z)(class ZkState_Kakuto_Hagaijime* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_Kakuto_Hagaijime__UAEXPAVPJZAKO___Z)(GameModule + 0x4ff3f0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_Kakuto_Hagaijime [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_Kakuto_Hagaijime& InObject)
	{
		m_eStat = InObject.m_eStat;
		m_HagaCnt = InObject.m_HagaCnt;
		m_boReleasedPc = InObject.m_boReleasedPc;
		m_eReleaseType = InObject.m_eReleaseType;
		m_boCatchSuccess = InObject.m_boCatchSuccess;
		m_boPcDeadRelease = InObject.m_boPcDeadRelease;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_Kakuto_Hagaijime, PJState>("ZkState_Kakuto_Hagaijime")
			.addFunction("__tostring", &ZkState_Kakuto_Hagaijime::ToString)
			.addFunction("GetPtrAddr", &ZkState_Kakuto_Hagaijime::GetPtrAddr)
			.addProperty("m_eStat", &ZkState_Kakuto_Hagaijime::m_eStat)
			.addProperty("m_HagaCnt", &ZkState_Kakuto_Hagaijime::m_HagaCnt)
			.addProperty("m_boReleasedPc", &ZkState_Kakuto_Hagaijime::m_boReleasedPc)
			.addProperty("m_eReleaseType", &ZkState_Kakuto_Hagaijime::m_eReleaseType)
			.addProperty("m_boCatchSuccess", &ZkState_Kakuto_Hagaijime::m_boCatchSuccess)
			.addProperty("m_boPcDeadRelease", &ZkState_Kakuto_Hagaijime::m_boPcDeadRelease)
			.addFunction("Exit", &ZkState_Kakuto_Hagaijime::Exit)
			.addFunction("PcDamageProc", &ZkState_Kakuto_Hagaijime::PcDamageProc)
			.addFunction("Execute", &ZkState_Kakuto_Hagaijime::Execute)
			.addFunction("Enter", &ZkState_Kakuto_Hagaijime::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_Kakuto_Hagaijime::m_eStat) == 4, "expected ZkState_Kakuto_Hagaijime::m_eStat to be size 4");
static_assert(sizeof(ZkState_Kakuto_Hagaijime::m_HagaCnt) == 4, "expected ZkState_Kakuto_Hagaijime::m_HagaCnt to be size 4");
static_assert(sizeof(ZkState_Kakuto_Hagaijime::m_boReleasedPc) == 1, "expected ZkState_Kakuto_Hagaijime::m_boReleasedPc to be size 1");
static_assert(sizeof(ZkState_Kakuto_Hagaijime::m_eReleaseType) == 4, "expected ZkState_Kakuto_Hagaijime::m_eReleaseType to be size 4");
static_assert(sizeof(ZkState_Kakuto_Hagaijime::m_boCatchSuccess) == 1, "expected ZkState_Kakuto_Hagaijime::m_boCatchSuccess to be size 1");
static_assert(sizeof(ZkState_Kakuto_Hagaijime::m_boPcDeadRelease) == 1, "expected ZkState_Kakuto_Hagaijime::m_boPcDeadRelease to be size 1");
static_assert(sizeof(ZkState_Kakuto_Hagaijime) == 0x18, "expected ZkState_Kakuto_Hagaijime to be size 0x18");

// [Structure] class ZkState_Kakuto_Global
class ZkState_Kakuto_Global : public State_StrongGlobal
{
public:
	/// Struct member variables

	// <class State_StrongGlobal field_0, offset 0x0>
	// class State_StrongGlobal Super;

	/// 2 Functions

	// [Function] void __convention("thiscall") ZkState_Kakuto_Global::ChangeStateCondition(class ZkState_Kakuto_Global* const this, class PJZAKO* arg2) [?ChangeStateCondition@ZkState_Kakuto_Global@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_ZkState_Kakuto_Global__QAEXPAVPJZAKO___Z)(class ZkState_Kakuto_Global* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_ZkState_Kakuto_Global__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_ZkState_Kakuto_Global__QAEXPAVPJZAKO___Z)(GameModule + 0x4ff480);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") ZkState_Kakuto_Global::Execute(class ZkState_Kakuto_Global* const this, class PJZAKO* arg2) [?Execute@ZkState_Kakuto_Global@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_ZkState_Kakuto_Global__UAEXPAVPJZAKO___Z)(class ZkState_Kakuto_Global* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_ZkState_Kakuto_Global__UAEXPAVPJZAKO___Z mFunc = (_Execute_ZkState_Kakuto_Global__UAEXPAVPJZAKO___Z)(GameModule + 0x4ff5d0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_Kakuto_Global [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_Kakuto_Global& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_Kakuto_Global, State_StrongGlobal>("ZkState_Kakuto_Global")
			.addFunction("__tostring", &ZkState_Kakuto_Global::ToString)
			.addFunction("GetPtrAddr", &ZkState_Kakuto_Global::GetPtrAddr)
			.addFunction("ChangeStateCondition", &ZkState_Kakuto_Global::ChangeStateCondition)
			.addFunction("Execute", &ZkState_Kakuto_Global::Execute)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_Kakuto_Global) == 0x4, "expected ZkState_Kakuto_Global to be size 0x4");

// [Structure] class State_ChainSawComboAttack
class State_ChainSawComboAttack : public State_ComboAttack
{
public:
	/// Struct member variables

	// <class State_ComboAttack field_0, offset 0x0>
	// class State_ComboAttack Super;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_ChainSawComboAttack::Exit(class State_ChainSawComboAttack* const this, class PJZAKO* arg2) [?Exit@State_ChainSawComboAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z)(class State_ChainSawComboAttack* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x500a40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ChainSawComboAttack::ChangeStateCondition(class State_ChainSawComboAttack* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_ChainSawComboAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z)(class State_ChainSawComboAttack* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x500a50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ChainSawComboAttack::Execute(class State_ChainSawComboAttack* const this, class PJZAKO* arg2) [?Execute@State_ChainSawComboAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z)(class State_ChainSawComboAttack* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x500ab0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_ChainSawComboAttack::Enter(class State_ChainSawComboAttack* const this, class PJZAKO* arg2) [?Enter@State_ChainSawComboAttack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z)(class State_ChainSawComboAttack* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_ChainSawComboAttack__UAEXPAVPJZAKO___Z)(GameModule + 0x500b80);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_ChainSawComboAttack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_ChainSawComboAttack& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_ChainSawComboAttack, State_ComboAttack>("State_ChainSawComboAttack")
			.addFunction("__tostring", &State_ChainSawComboAttack::ToString)
			.addFunction("GetPtrAddr", &State_ChainSawComboAttack::GetPtrAddr)
			.addFunction("Exit", &State_ChainSawComboAttack::Exit)
			.addFunction("ChangeStateCondition", &State_ChainSawComboAttack::ChangeStateCondition)
			.addFunction("Execute", &State_ChainSawComboAttack::Execute)
			.addFunction("Enter", &State_ChainSawComboAttack::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ChainSawComboAttack) == 0xc, "expected State_ChainSawComboAttack to be size 0xc");

// [Structure] class ZkState_ChainSaw_Close
class ZkState_ChainSaw_Close : public State_Close
{
public:
	/// Struct member variables

	// <class State_Close field_0, offset 0x0>
	// class State_Close Super;

	/// 1 Functions

	// [Function] void __convention("thiscall") ZkState_ChainSaw_Close::Enter(class ZkState_ChainSaw_Close* const this, class PJZAKO* arg2) [?Enter@ZkState_ChainSaw_Close@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_ZkState_ChainSaw_Close__UAEXPAVPJZAKO___Z)(class ZkState_ChainSaw_Close* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_ZkState_ChainSaw_Close__UAEXPAVPJZAKO___Z mFunc = (_Enter_ZkState_ChainSaw_Close__UAEXPAVPJZAKO___Z)(GameModule + 0x500c10);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ZkState_ChainSaw_Close [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ZkState_ChainSaw_Close& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_ChainSaw_Close, State_Close>("ZkState_ChainSaw_Close")
			.addFunction("__tostring", &ZkState_ChainSaw_Close::ToString)
			.addFunction("GetPtrAddr", &ZkState_ChainSaw_Close::GetPtrAddr)
			.addFunction("Enter", &ZkState_ChainSaw_Close::Enter)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_ChainSaw_Close) == 0x4, "expected ZkState_ChainSaw_Close to be size 0x4");

// [Structure] class bsSKE
class bsSKE
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[3684];

public:
	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") bsSKE::mSetDamage(class bsSKE* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsSKE@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_bsSKE__UAE_NMHHHMHMMPAVmHRChara___Z)(class bsSKE* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_bsSKE__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_bsSKE__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x501450);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class bsSKE [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(bsSKE& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsSKE>("bsSKE")
			.addFunction("__tostring", &bsSKE::ToString)
			.addFunction("GetPtrAddr", &bsSKE::GetPtrAddr)
			.addFunction("mSetDamage", &bsSKE::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsSKE) == 0xe64, "expected bsSKE to be size 0xe64");

// [Structure] class bsLEZ
class bsLEZ
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[4412];

public:
	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") bsLEZ::mSetDamage(class bsLEZ* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsLEZ@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_bsLEZ__UAE_NMHHHMHMMPAVmHRChara___Z)(class bsLEZ* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_bsLEZ__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_bsLEZ__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x52ed70);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class bsLEZ [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(bsLEZ& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsLEZ>("bsLEZ")
			.addFunction("__tostring", &bsLEZ::ToString)
			.addFunction("GetPtrAddr", &bsLEZ::GetPtrAddr)
			.addFunction("mSetDamage", &bsLEZ::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsLEZ) == 0x113c, "expected bsLEZ to be size 0x113c");

// [Structure] class bsCEW
class bsCEW
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[4232];

public:
	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") bsCEW::mSetDamage(class bsCEW* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsCEW@@EAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_bsCEW__EAE_NMHHHMHMMPAVmHRChara___Z)(class bsCEW* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_bsCEW__EAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_bsCEW__EAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x533080);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class bsCEW [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(bsCEW& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsCEW>("bsCEW")
			.addFunction("__tostring", &bsCEW::ToString)
			.addFunction("GetPtrAddr", &bsCEW::GetPtrAddr)
			.addFunction("mSetDamage", &bsCEW::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsCEW) == 0x1088, "expected bsCEW to be size 0x1088");

// [Structure] class bsAST
class bsAST
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[4352];

public:
	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") bsAST::mSetDamage(class bsAST* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsAST@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_bsAST__UAE_NMHHHMHMMPAVmHRChara___Z)(class bsAST* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_bsAST__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_bsAST__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x541b20);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class bsAST [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(bsAST& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsAST>("bsAST")
			.addFunction("__tostring", &bsAST::ToString)
			.addFunction("GetPtrAddr", &bsAST::GetPtrAddr)
			.addFunction("mSetDamage", &bsAST::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsAST) == 0x1100, "expected bsAST to be size 0x1100");

// [Structure] class bsRKT
class bsRKT
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[4672];

public:
	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") bsRKT::mSetDamage(class bsRKT* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsRKT@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_bsRKT__UAE_NMHHHMHMMPAVmHRChara___Z)(class bsRKT* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_bsRKT__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_bsRKT__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x547690);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class bsRKT [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(bsRKT& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsRKT>("bsRKT")
			.addFunction("__tostring", &bsRKT::ToString)
			.addFunction("GetPtrAddr", &bsRKT::GetPtrAddr)
			.addFunction("mSetDamage", &bsRKT::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsRKT) == 0x1240, "expected bsRKT to be size 0x1240");

// Unsupported destructor
//void __convention("thiscall") pcGLB::~pcGLB(class pcGLB* const this)
// Unsupported constructor
//void __convention("thiscall") pcGLB::pcGLB(class pcGLB* const this)
// [Structure] class PJOBJ0029
class PJOBJ0029 : public commonObj
{
public:
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class TGmfNode* mpTopNode, offset 0x64c>
	class TGmfNode* mpTopNode = nullptr;

	// <uint8_t mbBreak, offset 0x650>
	uint8_t mbBreak = 0;

	// <Unidentified data segment, offset 0x651>
private:
	char _UnidentifiedData_1617[3];

public:
	// <float mRadius, offset 0x654>
	float mRadius = 0;

	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") PJOBJ0029::mSetDamage(class PJOBJ0029* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11) [?mSetDamage@PJOBJ0029@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJOBJ0029__UAE_NMHHHMHMMPAVmHRChara__M_Z)(class PJOBJ0029* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)
	{
		_mSetDamage_PJOBJ0029__UAE_NMHHHMHMMPAVmHRChara__M_Z mFunc = (_mSetDamage_PJOBJ0029__UAE_NMHHHMHMMPAVmHRChara__M_Z)(GameModule + 0x5541f0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJOBJ0029 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJOBJ0029& InObject)
	{
		mpTopNode = InObject.mpTopNode;
		mbBreak = InObject.mbBreak;
		mRadius = InObject.mRadius;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0029, commonObj>("PJOBJ0029")
			.addFunction("__tostring", &PJOBJ0029::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0029::GetPtrAddr)
			.addProperty("mpTopNode", &PJOBJ0029::mpTopNode)
			.addProperty("mbBreak", &PJOBJ0029::mbBreak)
			.addProperty("mRadius", &PJOBJ0029::mRadius)
			.addFunction("mSetDamage", &PJOBJ0029::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0029::mpTopNode) == 4, "expected PJOBJ0029::mpTopNode to be size 4");
static_assert(sizeof(PJOBJ0029::mbBreak) == 1, "expected PJOBJ0029::mbBreak to be size 1");
static_assert(sizeof(PJOBJ0029::mRadius) == 4, "expected PJOBJ0029::mRadius to be size 4");
static_assert(sizeof(PJOBJ0029) == 0x658, "expected PJOBJ0029 to be size 0x658");

// [Structure] class PJOBJ0033
class PJOBJ0033 : public commonObj
{
public:
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <int32_t m_BreakCnt, offset 0x64c>
	int32_t m_BreakCnt = 0;

	// <uint8_t m_Dead, offset 0x650>
	uint8_t m_Dead = 0;

	// <uint8_t m_Motion, offset 0x651>
	uint8_t m_Motion = 0;

	// <uint8_t m_Off, offset 0x652>
	uint8_t m_Off = 0;

	// <Unidentified data segment, offset 0x653>
private:
	char _UnidentifiedData_1619[1];

public:
	// <struct Vec m_CenterPos, offset 0x654>
	struct Vec m_CenterPos;

	// <float m_fAccumDmg, offset 0x660>
	float m_fAccumDmg = 0;

	// <float m_fMaxAccumDmg, offset 0x664>
	float m_fMaxAccumDmg = 0;

	// <uint8_t m_boGetBreakNode, offset 0x668>
	uint8_t m_boGetBreakNode = 0;

	// <uint8_t m_boCreateFire, offset 0x669>
	uint8_t m_boCreateFire = 0;

	// <Unidentified data segment, offset 0x66a>
private:
	char _UnidentifiedData_1642[2];

public:
	// <int32_t m_BlinkCnt, offset 0x66c>
	int32_t m_BlinkCnt = 0;

	// <uint8_t m_boBlink, offset 0x670>
	uint8_t m_boBlink = 0;

	// <Unidentified data segment, offset 0x671>
private:
	char _UnidentifiedData_1649[3];

public:
	// <class FkStlVector<TGmfNode const *> m_apNode, offset 0x674>
	class FkStlVector<TGmfNode const *> m_apNode;

	// <class FkStlVector<EffectModelFire *> m_pModelFireArr, offset 0x688>
	class FkStlVector<EffectModelFire *> m_pModelFireArr;

	// <int32_t m_SeHnd, offset 0x69c>
	int32_t m_SeHnd = 0;

	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") PJOBJ0033::mSetDamage(class PJOBJ0033* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11) [?mSetDamage@PJOBJ0033@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJOBJ0033__UAE_NMHHHMHMMPAVmHRChara__M_Z)(class PJOBJ0033* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)
	{
		_mSetDamage_PJOBJ0033__UAE_NMHHHMHMMPAVmHRChara__M_Z mFunc = (_mSetDamage_PJOBJ0033__UAE_NMHHHMHMMPAVmHRChara__M_Z)(GameModule + 0x554750);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJOBJ0033 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJOBJ0033& InObject)
	{
		m_BreakCnt = InObject.m_BreakCnt;
		m_Dead = InObject.m_Dead;
		m_Motion = InObject.m_Motion;
		m_Off = InObject.m_Off;
		m_CenterPos = InObject.m_CenterPos;
		m_fAccumDmg = InObject.m_fAccumDmg;
		m_fMaxAccumDmg = InObject.m_fMaxAccumDmg;
		m_boGetBreakNode = InObject.m_boGetBreakNode;
		m_boCreateFire = InObject.m_boCreateFire;
		m_BlinkCnt = InObject.m_BlinkCnt;
		m_boBlink = InObject.m_boBlink;
		m_apNode = InObject.m_apNode;
		m_pModelFireArr = InObject.m_pModelFireArr;
		m_SeHnd = InObject.m_SeHnd;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0033, commonObj>("PJOBJ0033")
			.addFunction("__tostring", &PJOBJ0033::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0033::GetPtrAddr)
			.addProperty("m_BreakCnt", &PJOBJ0033::m_BreakCnt)
			.addProperty("m_Dead", &PJOBJ0033::m_Dead)
			.addProperty("m_Motion", &PJOBJ0033::m_Motion)
			.addProperty("m_Off", &PJOBJ0033::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0033::m_CenterPos)
			.addProperty("m_fAccumDmg", &PJOBJ0033::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0033::m_fMaxAccumDmg)
			.addProperty("m_boGetBreakNode", &PJOBJ0033::m_boGetBreakNode)
			.addProperty("m_boCreateFire", &PJOBJ0033::m_boCreateFire)
			.addProperty("m_BlinkCnt", &PJOBJ0033::m_BlinkCnt)
			.addProperty("m_boBlink", &PJOBJ0033::m_boBlink)
			.addProperty("m_apNode", &PJOBJ0033::m_apNode)
			.addProperty("m_pModelFireArr", &PJOBJ0033::m_pModelFireArr)
			.addProperty("m_SeHnd", &PJOBJ0033::m_SeHnd)
			.addFunction("mSetDamage", &PJOBJ0033::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0033::m_BreakCnt) == 4, "expected PJOBJ0033::m_BreakCnt to be size 4");
static_assert(sizeof(PJOBJ0033::m_Dead) == 1, "expected PJOBJ0033::m_Dead to be size 1");
static_assert(sizeof(PJOBJ0033::m_Motion) == 1, "expected PJOBJ0033::m_Motion to be size 1");
static_assert(sizeof(PJOBJ0033::m_Off) == 1, "expected PJOBJ0033::m_Off to be size 1");
static_assert(sizeof(PJOBJ0033::m_CenterPos) == 12, "expected PJOBJ0033::m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0033::m_fAccumDmg) == 4, "expected PJOBJ0033::m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0033::m_fMaxAccumDmg) == 4, "expected PJOBJ0033::m_fMaxAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0033::m_boGetBreakNode) == 1, "expected PJOBJ0033::m_boGetBreakNode to be size 1");
static_assert(sizeof(PJOBJ0033::m_boCreateFire) == 1, "expected PJOBJ0033::m_boCreateFire to be size 1");
static_assert(sizeof(PJOBJ0033::m_BlinkCnt) == 4, "expected PJOBJ0033::m_BlinkCnt to be size 4");
static_assert(sizeof(PJOBJ0033::m_boBlink) == 1, "expected PJOBJ0033::m_boBlink to be size 1");
static_assert(sizeof(PJOBJ0033::m_apNode) == 20, "expected PJOBJ0033::m_apNode to be size 20");
static_assert(sizeof(PJOBJ0033::m_pModelFireArr) == 20, "expected PJOBJ0033::m_pModelFireArr to be size 20");
static_assert(sizeof(PJOBJ0033::m_SeHnd) == 4, "expected PJOBJ0033::m_SeHnd to be size 4");
static_assert(sizeof(PJOBJ0033) == 0x6a0, "expected PJOBJ0033 to be size 0x6a0");

// [Structure] struct EFFECTSIMPLEOBJ3PARAM
struct EFFECTSIMPLEOBJ3PARAM
{
public:
	/// Struct member variables

	// <int32_t MaxObjNum, offset 0x0>
	int32_t MaxObjNum = 0;

	// <float SpeedUpSpeed, offset 0x4>
	float SpeedUpSpeed = 0;

	// <float SideSpeedDownRate, offset 0x8>
	float SideSpeedDownRate = 0;

	// <int16_t MaxVisibleTime, offset 0xc>
	int16_t MaxVisibleTime = 0;

	// <int16_t MinVisibleTime, offset 0xe>
	int16_t MinVisibleTime = 0;

	// <int16_t MaxFadeInSpeed, offset 0x10>
	int16_t MaxFadeInSpeed = 0;

	// <int16_t MinFadeInSpeed, offset 0x12>
	int16_t MinFadeInSpeed = 0;

	// <int16_t MaxFadeOutSpeed, offset 0x14>
	int16_t MaxFadeOutSpeed = 0;

	// <int16_t MinFadeOutSpeed, offset 0x16>
	int16_t MinFadeOutSpeed = 0;

	// <float MaxSideSpeed, offset 0x18>
	float MaxSideSpeed = 0;

	// <float MinSideSpeed, offset 0x1c>
	float MinSideSpeed = 0;

	// <float InitMaxSpeed, offset 0x20>
	float InitMaxSpeed = 0;

	// <float InitMinSpeed, offset 0x24>
	float InitMinSpeed = 0;

	// <float MaxWidth, offset 0x28>
	float MaxWidth = 0;

	// <float MinWidth, offset 0x2c>
	float MinWidth = 0;

	// <uint32_t Color, offset 0x30>
	uint32_t Color = 0;

	// <int32_t ColorRand, offset 0x34>
	int32_t ColorRand = 0;

	// <struct tagGHMR_TEX* pTexture, offset 0x38>
	struct tagGHMR_TEX* pTexture = nullptr;

	// <int32_t TexDivX, offset 0x3c>
	int32_t TexDivX = 0;

	// <int32_t TexDivY, offset 0x40>
	int32_t TexDivY = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct EFFECTSIMPLEOBJ3PARAM [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EFFECTSIMPLEOBJ3PARAM& InObject)
	{
		MaxObjNum = InObject.MaxObjNum;
		SpeedUpSpeed = InObject.SpeedUpSpeed;
		SideSpeedDownRate = InObject.SideSpeedDownRate;
		MaxVisibleTime = InObject.MaxVisibleTime;
		MinVisibleTime = InObject.MinVisibleTime;
		MaxFadeInSpeed = InObject.MaxFadeInSpeed;
		MinFadeInSpeed = InObject.MinFadeInSpeed;
		MaxFadeOutSpeed = InObject.MaxFadeOutSpeed;
		MinFadeOutSpeed = InObject.MinFadeOutSpeed;
		MaxSideSpeed = InObject.MaxSideSpeed;
		MinSideSpeed = InObject.MinSideSpeed;
		InitMaxSpeed = InObject.InitMaxSpeed;
		InitMinSpeed = InObject.InitMinSpeed;
		MaxWidth = InObject.MaxWidth;
		MinWidth = InObject.MinWidth;
		Color = InObject.Color;
		ColorRand = InObject.ColorRand;
		pTexture = InObject.pTexture;
		TexDivX = InObject.TexDivX;
		TexDivY = InObject.TexDivY;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EFFECTSIMPLEOBJ3PARAM>("EFFECTSIMPLEOBJ3PARAM")
			.addFunction("__tostring", &EFFECTSIMPLEOBJ3PARAM::ToString)
			.addFunction("GetPtrAddr", &EFFECTSIMPLEOBJ3PARAM::GetPtrAddr)
			.addProperty("MaxObjNum", &EFFECTSIMPLEOBJ3PARAM::MaxObjNum)
			.addProperty("SpeedUpSpeed", &EFFECTSIMPLEOBJ3PARAM::SpeedUpSpeed)
			.addProperty("SideSpeedDownRate", &EFFECTSIMPLEOBJ3PARAM::SideSpeedDownRate)
			.addProperty("MaxVisibleTime", &EFFECTSIMPLEOBJ3PARAM::MaxVisibleTime)
			.addProperty("MinVisibleTime", &EFFECTSIMPLEOBJ3PARAM::MinVisibleTime)
			.addProperty("MaxFadeInSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxFadeInSpeed)
			.addProperty("MinFadeInSpeed", &EFFECTSIMPLEOBJ3PARAM::MinFadeInSpeed)
			.addProperty("MaxFadeOutSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxFadeOutSpeed)
			.addProperty("MinFadeOutSpeed", &EFFECTSIMPLEOBJ3PARAM::MinFadeOutSpeed)
			.addProperty("MaxSideSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxSideSpeed)
			.addProperty("MinSideSpeed", &EFFECTSIMPLEOBJ3PARAM::MinSideSpeed)
			.addProperty("InitMaxSpeed", &EFFECTSIMPLEOBJ3PARAM::InitMaxSpeed)
			.addProperty("InitMinSpeed", &EFFECTSIMPLEOBJ3PARAM::InitMinSpeed)
			.addProperty("MaxWidth", &EFFECTSIMPLEOBJ3PARAM::MaxWidth)
			.addProperty("MinWidth", &EFFECTSIMPLEOBJ3PARAM::MinWidth)
			.addProperty("Color", &EFFECTSIMPLEOBJ3PARAM::Color)
			.addProperty("ColorRand", &EFFECTSIMPLEOBJ3PARAM::ColorRand)
			.addProperty("pTexture", &EFFECTSIMPLEOBJ3PARAM::pTexture)
			.addProperty("TexDivX", &EFFECTSIMPLEOBJ3PARAM::TexDivX)
			.addProperty("TexDivY", &EFFECTSIMPLEOBJ3PARAM::TexDivY)
		.endClass();
	}
#endif
};
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxObjNum) == 4, "expected EFFECTSIMPLEOBJ3PARAM::MaxObjNum to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::SpeedUpSpeed) == 4, "expected EFFECTSIMPLEOBJ3PARAM::SpeedUpSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::SideSpeedDownRate) == 4, "expected EFFECTSIMPLEOBJ3PARAM::SideSpeedDownRate to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxVisibleTime) == 2, "expected EFFECTSIMPLEOBJ3PARAM::MaxVisibleTime to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinVisibleTime) == 2, "expected EFFECTSIMPLEOBJ3PARAM::MinVisibleTime to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxFadeInSpeed) == 2, "expected EFFECTSIMPLEOBJ3PARAM::MaxFadeInSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinFadeInSpeed) == 2, "expected EFFECTSIMPLEOBJ3PARAM::MinFadeInSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxFadeOutSpeed) == 2, "expected EFFECTSIMPLEOBJ3PARAM::MaxFadeOutSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinFadeOutSpeed) == 2, "expected EFFECTSIMPLEOBJ3PARAM::MinFadeOutSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxSideSpeed) == 4, "expected EFFECTSIMPLEOBJ3PARAM::MaxSideSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinSideSpeed) == 4, "expected EFFECTSIMPLEOBJ3PARAM::MinSideSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::InitMaxSpeed) == 4, "expected EFFECTSIMPLEOBJ3PARAM::InitMaxSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::InitMinSpeed) == 4, "expected EFFECTSIMPLEOBJ3PARAM::InitMinSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxWidth) == 4, "expected EFFECTSIMPLEOBJ3PARAM::MaxWidth to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinWidth) == 4, "expected EFFECTSIMPLEOBJ3PARAM::MinWidth to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::Color) == 4, "expected EFFECTSIMPLEOBJ3PARAM::Color to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::ColorRand) == 4, "expected EFFECTSIMPLEOBJ3PARAM::ColorRand to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::pTexture) == 4, "expected EFFECTSIMPLEOBJ3PARAM::pTexture to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::TexDivX) == 4, "expected EFFECTSIMPLEOBJ3PARAM::TexDivX to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::TexDivY) == 4, "expected EFFECTSIMPLEOBJ3PARAM::TexDivY to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM) == 0x44, "expected EFFECTSIMPLEOBJ3PARAM to be size 0x44");

// [Structure] struct EFFECTMODELFIREPARAM
struct EFFECTMODELFIREPARAM
{
public:
	/// Struct member variables

	// <float CreateRate, offset 0x0>
	float CreateRate = 0;

	// <float CreateArea, offset 0x4>
	float CreateArea = 0;

	// <struct EFFECTSIMPLEOBJ3PARAM Obj3Param, offset 0x8>
	struct EFFECTSIMPLEOBJ3PARAM Obj3Param;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct EFFECTMODELFIREPARAM [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EFFECTMODELFIREPARAM& InObject)
	{
		CreateRate = InObject.CreateRate;
		CreateArea = InObject.CreateArea;
		Obj3Param = InObject.Obj3Param;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EFFECTMODELFIREPARAM>("EFFECTMODELFIREPARAM")
			.addFunction("__tostring", &EFFECTMODELFIREPARAM::ToString)
			.addFunction("GetPtrAddr", &EFFECTMODELFIREPARAM::GetPtrAddr)
			.addProperty("CreateRate", &EFFECTMODELFIREPARAM::CreateRate)
			.addProperty("CreateArea", &EFFECTMODELFIREPARAM::CreateArea)
			.addProperty("Obj3Param", &EFFECTMODELFIREPARAM::Obj3Param)
		.endClass();
	}
#endif
};
static_assert(sizeof(EFFECTMODELFIREPARAM::CreateRate) == 4, "expected EFFECTMODELFIREPARAM::CreateRate to be size 4");
static_assert(sizeof(EFFECTMODELFIREPARAM::CreateArea) == 4, "expected EFFECTMODELFIREPARAM::CreateArea to be size 4");
static_assert(sizeof(EFFECTMODELFIREPARAM::Obj3Param) == 68, "expected EFFECTMODELFIREPARAM::Obj3Param to be size 68");
static_assert(sizeof(EFFECTMODELFIREPARAM) == 0x4c, "expected EFFECTMODELFIREPARAM to be size 0x4c");

// [Structure] class EffectModelFire
class EffectModelFire : public HrTask
{
public:
	// [Structure] struct EffectModelFire::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <class TGmf* pGmf, offset 0x0>
		class TGmf* pGmf = nullptr;

		// <class TGmfNode* pGmfNode, offset 0x4>
		class TGmfNode* pGmfNode = nullptr;

		// <float CreateCounter, offset 0x8>
		float CreateCounter = 0;

		// <int32_t SinCounter[0x3], offset 0xc>
		int32_t SinCounter[3];

		// <int32_t SinSpeed[0x3], offset 0x18>
		int32_t SinSpeed[3];

		// <float NowCreateRate, offset 0x24>
		float NowCreateRate = 0;

		// <float MinY, offset 0x28>
		float MinY = 0;

		// <float MaxY, offset 0x2c>
		float MaxY = 0;

		// <float BoarderY, offset 0x30>
		float BoarderY = 0;

		// <float OutRate, offset 0x34>
		float OutRate = 0;

		// <int32_t SoundID, offset 0x38>
		int32_t SoundID = 0;

		// <int32_t SoundHandle, offset 0x3c>
		int32_t SoundHandle = 0;

		// <struct EFFECTMODELFIREPARAM Param, offset 0x40>
		struct EFFECTMODELFIREPARAM Param;

		// <class EffectSimpleObj3* pObj3, offset 0x8c>
		class EffectSimpleObj3* pObj3 = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectModelFire::MAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectModelFire::MAIN& InObject)
		{
			pGmf = InObject.pGmf;
			pGmfNode = InObject.pGmfNode;
			CreateCounter = InObject.CreateCounter;
			NowCreateRate = InObject.NowCreateRate;
			MinY = InObject.MinY;
			MaxY = InObject.MaxY;
			BoarderY = InObject.BoarderY;
			OutRate = InObject.OutRate;
			SoundID = InObject.SoundID;
			SoundHandle = InObject.SoundHandle;
			Param = InObject.Param;
			pObj3 = InObject.pObj3;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MAIN>("EffectModelFire_MAIN")
				.addFunction("__tostring", &EffectModelFire::MAIN::ToString)
				.addFunction("GetPtrAddr", &EffectModelFire::MAIN::GetPtrAddr)
				.addProperty("pGmf", &EffectModelFire::MAIN::pGmf)
				.addProperty("pGmfNode", &EffectModelFire::MAIN::pGmfNode)
				.addProperty("CreateCounter", &EffectModelFire::MAIN::CreateCounter)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("SinCounter", &EffectModelFire::MAIN::SinCounter)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("SinSpeed", &EffectModelFire::MAIN::SinSpeed)
				.addProperty("NowCreateRate", &EffectModelFire::MAIN::NowCreateRate)
				.addProperty("MinY", &EffectModelFire::MAIN::MinY)
				.addProperty("MaxY", &EffectModelFire::MAIN::MaxY)
				.addProperty("BoarderY", &EffectModelFire::MAIN::BoarderY)
				.addProperty("OutRate", &EffectModelFire::MAIN::OutRate)
				.addProperty("SoundID", &EffectModelFire::MAIN::SoundID)
				.addProperty("SoundHandle", &EffectModelFire::MAIN::SoundHandle)
				.addProperty("Param", &EffectModelFire::MAIN::Param)
				.addProperty("pObj3", &EffectModelFire::MAIN::pObj3)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectModelFire::MAIN::pGmf) == 4, "expected EffectModelFire::MAIN::pGmf to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::pGmfNode) == 4, "expected EffectModelFire::MAIN::pGmfNode to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::CreateCounter) == 4, "expected EffectModelFire::MAIN::CreateCounter to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SinCounter) == 12, "expected EffectModelFire::MAIN::SinCounter to be size 12");
	static_assert(sizeof(EffectModelFire::MAIN::SinSpeed) == 12, "expected EffectModelFire::MAIN::SinSpeed to be size 12");
	static_assert(sizeof(EffectModelFire::MAIN::NowCreateRate) == 4, "expected EffectModelFire::MAIN::NowCreateRate to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::MinY) == 4, "expected EffectModelFire::MAIN::MinY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::MaxY) == 4, "expected EffectModelFire::MAIN::MaxY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::BoarderY) == 4, "expected EffectModelFire::MAIN::BoarderY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::OutRate) == 4, "expected EffectModelFire::MAIN::OutRate to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SoundID) == 4, "expected EffectModelFire::MAIN::SoundID to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SoundHandle) == 4, "expected EffectModelFire::MAIN::SoundHandle to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::Param) == 76, "expected EffectModelFire::MAIN::Param to be size 76");
	static_assert(sizeof(EffectModelFire::MAIN::pObj3) == 4, "expected EffectModelFire::MAIN::pObj3 to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN) == 0x90, "expected EffectModelFire::MAIN to be size 0x90");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectModelFire::MAIN dat, offset 0x50>
	struct EffectModelFire::MAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectModelFire [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectModelFire& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectModelFire, HrTask>("EffectModelFire")
			.addFunction("__tostring", &EffectModelFire::ToString)
			.addFunction("GetPtrAddr", &EffectModelFire::GetPtrAddr)
			.addProperty("dat", &EffectModelFire::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectModelFire::dat) == 144, "expected EffectModelFire::dat to be size 144");
static_assert(sizeof(EffectModelFire) == 0xe0, "expected EffectModelFire to be size 0xe0");

// [Structure] class EffectSimpleObj3
class EffectSimpleObj3 : public HrTask
{
public:
	// [Structure] struct EffectSimpleObj3::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <int32_t ObjNum, offset 0x0>
		int32_t ObjNum = 0;

		// <struct EffectSimpleObj3::OBJECT* Obj, offset 0x4>
		struct OBJECT* Obj = nullptr;

		// <struct tagTLIST* ValidFirstObj, offset 0x8>
		struct tagTLIST* ValidFirstObj = nullptr;

		// <struct tagTLIST* FreeFirstObj, offset 0xc>
		struct tagTLIST* FreeFirstObj = nullptr;

		// <struct EFFECTSIMPLEOBJ3PARAM Param, offset 0x10>
		struct EFFECTSIMPLEOBJ3PARAM Param;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectSimpleObj3::MAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectSimpleObj3::MAIN& InObject)
		{
			ObjNum = InObject.ObjNum;
			Obj = InObject.Obj;
			ValidFirstObj = InObject.ValidFirstObj;
			FreeFirstObj = InObject.FreeFirstObj;
			Param = InObject.Param;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MAIN>("EffectSimpleObj3_MAIN")
				.addFunction("__tostring", &EffectSimpleObj3::MAIN::ToString)
				.addFunction("GetPtrAddr", &EffectSimpleObj3::MAIN::GetPtrAddr)
				.addProperty("ObjNum", &EffectSimpleObj3::MAIN::ObjNum)
				.addProperty("Obj", &EffectSimpleObj3::MAIN::Obj)
				.addProperty("ValidFirstObj", &EffectSimpleObj3::MAIN::ValidFirstObj)
				.addProperty("FreeFirstObj", &EffectSimpleObj3::MAIN::FreeFirstObj)
				.addProperty("Param", &EffectSimpleObj3::MAIN::Param)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectSimpleObj3::MAIN::ObjNum) == 4, "expected EffectSimpleObj3::MAIN::ObjNum to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::Obj) == 4, "expected EffectSimpleObj3::MAIN::Obj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::ValidFirstObj) == 4, "expected EffectSimpleObj3::MAIN::ValidFirstObj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::FreeFirstObj) == 4, "expected EffectSimpleObj3::MAIN::FreeFirstObj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::Param) == 68, "expected EffectSimpleObj3::MAIN::Param to be size 68");
	static_assert(sizeof(EffectSimpleObj3::MAIN) == 0x54, "expected EffectSimpleObj3::MAIN to be size 0x54");

	// [Structure] struct EffectSimpleObj3::OBJECT
	struct OBJECT
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData_0[68];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectSimpleObj3::OBJECT [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectSimpleObj3::OBJECT& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<OBJECT>("EffectSimpleObj3_OBJECT")
				.addFunction("__tostring", &EffectSimpleObj3::OBJECT::ToString)
				.addFunction("GetPtrAddr", &EffectSimpleObj3::OBJECT::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectSimpleObj3::OBJECT) == 0x44, "expected EffectSimpleObj3::OBJECT to be size 0x44");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectSimpleObj3::MAIN dat, offset 0x50>
	struct EffectSimpleObj3::MAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectSimpleObj3 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectSimpleObj3& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSimpleObj3, HrTask>("EffectSimpleObj3")
			.addFunction("__tostring", &EffectSimpleObj3::ToString)
			.addFunction("GetPtrAddr", &EffectSimpleObj3::GetPtrAddr)
			.addProperty("dat", &EffectSimpleObj3::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSimpleObj3::dat) == 84, "expected EffectSimpleObj3::dat to be size 84");
static_assert(sizeof(EffectSimpleObj3) == 0xa4, "expected EffectSimpleObj3 to be size 0xa4");

// [Structure] struct tagTLIST
struct tagTLIST
{
public:
	/// Struct member variables

	// <tagTLIST* Prev, offset 0x0>
	tagTLIST* Prev = nullptr;

	// <tagTLIST* Next, offset 0x4>
	tagTLIST* Next = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct tagTLIST [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tagTLIST& InObject)
	{
		Prev = InObject.Prev;
		Next = InObject.Next;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagTLIST>("tagTLIST")
			.addFunction("__tostring", &tagTLIST::ToString)
			.addFunction("GetPtrAddr", &tagTLIST::GetPtrAddr)
			.addProperty("Prev", &tagTLIST::Prev)
			.addProperty("Next", &tagTLIST::Next)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagTLIST::Prev) == 4, "expected tagTLIST::Prev to be size 4");
static_assert(sizeof(tagTLIST::Next) == 4, "expected tagTLIST::Next to be size 4");
static_assert(sizeof(tagTLIST) == 0x8, "expected tagTLIST to be size 0x8");

// [Structure] class PJOBJ0036
class PJOBJ0036 : public commonObj
{
public:
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <uint8_t m_Dead, offset 0x64c>
	uint8_t m_Dead = 0;

	// <uint8_t m_Motion, offset 0x64d>
	uint8_t m_Motion = 0;

	// <uint8_t m_Off, offset 0x64e>
	uint8_t m_Off = 0;

	// <Unidentified data segment, offset 0x64f>
private:
	char _UnidentifiedData_1615[1];

public:
	// <struct Vec m_CenterPos, offset 0x650>
	struct Vec m_CenterPos;

	// <int32_t m_Cnt, offset 0x65c>
	int32_t m_Cnt = 0;

	// <float m_fAccumDmg, offset 0x660>
	float m_fAccumDmg = 0;

	// <float m_fMaxAccumDmg, offset 0x664>
	float m_fMaxAccumDmg = 0;

	// <uint8_t m_boGetBreakNode, offset 0x668>
	uint8_t m_boGetBreakNode = 0;

	// <Unidentified data segment, offset 0x669>
private:
	char _UnidentifiedData_1641[3];

public:
	// <struct tagGHMR_TEX m_Tex, offset 0x66c>
	struct tagGHMR_TEX m_Tex;

	// <class FkStlVector<TGmfNode const *> m_apNode, offset 0x694>
	class FkStlVector<TGmfNode const *> m_apNode;

	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") PJOBJ0036::mSetDamage(class PJOBJ0036* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0036@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJOBJ0036__UAE_NMHHHMHMMPAVmHRChara___Z)(class PJOBJ0036* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_PJOBJ0036__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_PJOBJ0036__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x556080);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJOBJ0036 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJOBJ0036& InObject)
	{
		m_Dead = InObject.m_Dead;
		m_Motion = InObject.m_Motion;
		m_Off = InObject.m_Off;
		m_CenterPos = InObject.m_CenterPos;
		m_Cnt = InObject.m_Cnt;
		m_fAccumDmg = InObject.m_fAccumDmg;
		m_fMaxAccumDmg = InObject.m_fMaxAccumDmg;
		m_boGetBreakNode = InObject.m_boGetBreakNode;
		m_Tex = InObject.m_Tex;
		m_apNode = InObject.m_apNode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0036, commonObj>("PJOBJ0036")
			.addFunction("__tostring", &PJOBJ0036::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0036::GetPtrAddr)
			.addProperty("m_Dead", &PJOBJ0036::m_Dead)
			.addProperty("m_Motion", &PJOBJ0036::m_Motion)
			.addProperty("m_Off", &PJOBJ0036::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0036::m_CenterPos)
			.addProperty("m_Cnt", &PJOBJ0036::m_Cnt)
			.addProperty("m_fAccumDmg", &PJOBJ0036::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0036::m_fMaxAccumDmg)
			.addProperty("m_boGetBreakNode", &PJOBJ0036::m_boGetBreakNode)
			.addProperty("m_Tex", &PJOBJ0036::m_Tex)
			.addProperty("m_apNode", &PJOBJ0036::m_apNode)
			.addFunction("mSetDamage", &PJOBJ0036::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0036::m_Dead) == 1, "expected PJOBJ0036::m_Dead to be size 1");
static_assert(sizeof(PJOBJ0036::m_Motion) == 1, "expected PJOBJ0036::m_Motion to be size 1");
static_assert(sizeof(PJOBJ0036::m_Off) == 1, "expected PJOBJ0036::m_Off to be size 1");
static_assert(sizeof(PJOBJ0036::m_CenterPos) == 12, "expected PJOBJ0036::m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0036::m_Cnt) == 4, "expected PJOBJ0036::m_Cnt to be size 4");
static_assert(sizeof(PJOBJ0036::m_fAccumDmg) == 4, "expected PJOBJ0036::m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0036::m_fMaxAccumDmg) == 4, "expected PJOBJ0036::m_fMaxAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0036::m_boGetBreakNode) == 1, "expected PJOBJ0036::m_boGetBreakNode to be size 1");
static_assert(sizeof(PJOBJ0036::m_Tex) == 40, "expected PJOBJ0036::m_Tex to be size 40");
static_assert(sizeof(PJOBJ0036::m_apNode) == 20, "expected PJOBJ0036::m_apNode to be size 20");
static_assert(sizeof(PJOBJ0036) == 0x6a8, "expected PJOBJ0036 to be size 0x6a8");

// [Structure] class PJOBJ0037
class PJOBJ0037 : public commonObj
{
public:
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") PJOBJ0037::mSetDamage(class PJOBJ0037* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0037@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJOBJ0037__UAE_NMHHHMHMMPAVmHRChara___Z)(class PJOBJ0037* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_PJOBJ0037__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_PJOBJ0037__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x556390);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") PJOBJ0037::IsHitChar(class PJOBJ0037* const this, class mHRChara* arg2) [?IsHitChar@PJOBJ0037@@AAE_NPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _IsHitChar_PJOBJ0037__AAE_NPAVmHRChara___Z)(class PJOBJ0037* const thisPtr, class mHRChara* arg2);
	uint8_t IsHitChar(class mHRChara* arg2)
	{
		_IsHitChar_PJOBJ0037__AAE_NPAVmHRChara___Z mFunc = (_IsHitChar_PJOBJ0037__AAE_NPAVmHRChara___Z)(GameModule + 0x556590);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJOBJ0037 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJOBJ0037& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0037, commonObj>("PJOBJ0037")
			.addFunction("__tostring", &PJOBJ0037::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0037::GetPtrAddr)
			.addFunction("mSetDamage", &PJOBJ0037::mSetDamage)
			.addFunction("IsHitChar", &PJOBJ0037::IsHitChar)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0037) == 0x64c, "expected PJOBJ0037 to be size 0x64c");

// [Structure] class PJOBJ0104
class PJOBJ0104 : public commonObj
{
public:
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <uint8_t m_Dead, offset 0x64c>
	uint8_t m_Dead = 0;

	// <uint8_t m_Motion, offset 0x64d>
	uint8_t m_Motion = 0;

	// <uint8_t m_Off, offset 0x64e>
	uint8_t m_Off = 0;

	// <Unidentified data segment, offset 0x64f>
private:
	char _UnidentifiedData_1615[1];

public:
	// <struct Vec m_CenterPos, offset 0x650>
	struct Vec m_CenterPos;

	// <class TGmf* m_DamageModel[0x3], offset 0x65c>
	class TGmf* m_DamageModel[3];

	// <class TGan* m_BreakMotion, offset 0x668>
	class TGan* m_BreakMotion = nullptr;

	// <float m_fAccumDmg, offset 0x66c>
	float m_fAccumDmg = 0;

	// <float m_fMaxAccumDmg, offset 0x670>
	float m_fMaxAccumDmg = 0;

	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") PJOBJ0104::mSetDamage(class PJOBJ0104* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0104@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJOBJ0104__UAE_NMHHHMHMMPAVmHRChara___Z)(class PJOBJ0104* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_PJOBJ0104__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_PJOBJ0104__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x556730);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJOBJ0104 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJOBJ0104& InObject)
	{
		m_Dead = InObject.m_Dead;
		m_Motion = InObject.m_Motion;
		m_Off = InObject.m_Off;
		m_CenterPos = InObject.m_CenterPos;
		m_BreakMotion = InObject.m_BreakMotion;
		m_fAccumDmg = InObject.m_fAccumDmg;
		m_fMaxAccumDmg = InObject.m_fMaxAccumDmg;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0104, commonObj>("PJOBJ0104")
			.addFunction("__tostring", &PJOBJ0104::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0104::GetPtrAddr)
			.addProperty("m_Dead", &PJOBJ0104::m_Dead)
			.addProperty("m_Motion", &PJOBJ0104::m_Motion)
			.addProperty("m_Off", &PJOBJ0104::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0104::m_CenterPos)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_DamageModel", &PJOBJ0104::m_DamageModel)
			.addProperty("m_BreakMotion", &PJOBJ0104::m_BreakMotion)
			.addProperty("m_fAccumDmg", &PJOBJ0104::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0104::m_fMaxAccumDmg)
			.addFunction("mSetDamage", &PJOBJ0104::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0104::m_Dead) == 1, "expected PJOBJ0104::m_Dead to be size 1");
static_assert(sizeof(PJOBJ0104::m_Motion) == 1, "expected PJOBJ0104::m_Motion to be size 1");
static_assert(sizeof(PJOBJ0104::m_Off) == 1, "expected PJOBJ0104::m_Off to be size 1");
static_assert(sizeof(PJOBJ0104::m_CenterPos) == 12, "expected PJOBJ0104::m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0104::m_DamageModel) == 12, "expected PJOBJ0104::m_DamageModel to be size 12");
static_assert(sizeof(PJOBJ0104::m_BreakMotion) == 4, "expected PJOBJ0104::m_BreakMotion to be size 4");
static_assert(sizeof(PJOBJ0104::m_fAccumDmg) == 4, "expected PJOBJ0104::m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0104::m_fMaxAccumDmg) == 4, "expected PJOBJ0104::m_fMaxAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0104) == 0x674, "expected PJOBJ0104 to be size 0x674");

// [Structure] class PJOBJ0155
class PJOBJ0155 : public commonObj
{
public:
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <int32_t m_AlphaVisibleCnt, offset 0x64c>
	int32_t m_AlphaVisibleCnt = 0;

	// <int32_t m_AlphaVisibleFrmMax, offset 0x650>
	int32_t m_AlphaVisibleFrmMax = 0;

	// <uint8_t m_Dead, offset 0x654>
	uint8_t m_Dead = 0;

	// <uint8_t m_Motion, offset 0x655>
	uint8_t m_Motion = 0;

	// <uint8_t m_Off, offset 0x656>
	uint8_t m_Off = 0;

	// <Unidentified data segment, offset 0x657>
private:
	char _UnidentifiedData_1623[1];

public:
	// <struct Vec m_CenterPos, offset 0x658>
	struct Vec m_CenterPos;

	// <int32_t m_Counter, offset 0x664>
	int32_t m_Counter = 0;

	// <int32_t m_nPipe, offset 0x668>
	int32_t m_nPipe = 0;

	// <struct tagGHMR_TEX m_Tex, offset 0x66c>
	struct tagGHMR_TEX m_Tex;

	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") PJOBJ0155::mSetDamage(class PJOBJ0155* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0155@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJOBJ0155__UAE_NMHHHMHMMPAVmHRChara___Z)(class PJOBJ0155* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_PJOBJ0155__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_PJOBJ0155__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x556c00);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJOBJ0155 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJOBJ0155& InObject)
	{
		m_AlphaVisibleCnt = InObject.m_AlphaVisibleCnt;
		m_AlphaVisibleFrmMax = InObject.m_AlphaVisibleFrmMax;
		m_Dead = InObject.m_Dead;
		m_Motion = InObject.m_Motion;
		m_Off = InObject.m_Off;
		m_CenterPos = InObject.m_CenterPos;
		m_Counter = InObject.m_Counter;
		m_nPipe = InObject.m_nPipe;
		m_Tex = InObject.m_Tex;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0155, commonObj>("PJOBJ0155")
			.addFunction("__tostring", &PJOBJ0155::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0155::GetPtrAddr)
			.addProperty("m_AlphaVisibleCnt", &PJOBJ0155::m_AlphaVisibleCnt)
			.addProperty("m_AlphaVisibleFrmMax", &PJOBJ0155::m_AlphaVisibleFrmMax)
			.addProperty("m_Dead", &PJOBJ0155::m_Dead)
			.addProperty("m_Motion", &PJOBJ0155::m_Motion)
			.addProperty("m_Off", &PJOBJ0155::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0155::m_CenterPos)
			.addProperty("m_Counter", &PJOBJ0155::m_Counter)
			.addProperty("m_nPipe", &PJOBJ0155::m_nPipe)
			.addProperty("m_Tex", &PJOBJ0155::m_Tex)
			.addFunction("mSetDamage", &PJOBJ0155::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0155::m_AlphaVisibleCnt) == 4, "expected PJOBJ0155::m_AlphaVisibleCnt to be size 4");
static_assert(sizeof(PJOBJ0155::m_AlphaVisibleFrmMax) == 4, "expected PJOBJ0155::m_AlphaVisibleFrmMax to be size 4");
static_assert(sizeof(PJOBJ0155::m_Dead) == 1, "expected PJOBJ0155::m_Dead to be size 1");
static_assert(sizeof(PJOBJ0155::m_Motion) == 1, "expected PJOBJ0155::m_Motion to be size 1");
static_assert(sizeof(PJOBJ0155::m_Off) == 1, "expected PJOBJ0155::m_Off to be size 1");
static_assert(sizeof(PJOBJ0155::m_CenterPos) == 12, "expected PJOBJ0155::m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0155::m_Counter) == 4, "expected PJOBJ0155::m_Counter to be size 4");
static_assert(sizeof(PJOBJ0155::m_nPipe) == 4, "expected PJOBJ0155::m_nPipe to be size 4");
static_assert(sizeof(PJOBJ0155::m_Tex) == 40, "expected PJOBJ0155::m_Tex to be size 40");
static_assert(sizeof(PJOBJ0155) == 0x694, "expected PJOBJ0155 to be size 0x694");

// [Structure] class PJOBJ0190
class PJOBJ0190 : public commonObj
{
public:
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class TGmfNode* mpTopNode, offset 0x64c>
	class TGmfNode* mpTopNode = nullptr;

	// <uint8_t mbBreak, offset 0x650>
	uint8_t mbBreak = 0;

	// <Unidentified data segment, offset 0x651>
private:
	char _UnidentifiedData_1617[3];

public:
	// <float mRadius, offset 0x654>
	float mRadius = 0;

	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") PJOBJ0190::mSetDamage(class PJOBJ0190* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11) [?mSetDamage@PJOBJ0190@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJOBJ0190__UAE_NMHHHMHMMPAVmHRChara__M_Z)(class PJOBJ0190* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)
	{
		_mSetDamage_PJOBJ0190__UAE_NMHHHMHMMPAVmHRChara__M_Z mFunc = (_mSetDamage_PJOBJ0190__UAE_NMHHHMHMMPAVmHRChara__M_Z)(GameModule + 0x557250);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] uint8_t __convention("thiscall") PJOBJ0190::mSetDamage(class PJOBJ0190* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0190@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJOBJ0190__UAE_NMHHHMHMMPAVmHRChara___Z_2)(class PJOBJ0190* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage_2(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_PJOBJ0190__UAE_NMHHHMHMMPAVmHRChara___Z_2 mFunc = (_mSetDamage_PJOBJ0190__UAE_NMHHHMHMMPAVmHRChara___Z_2)(GameModule + 0x557320);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJOBJ0190 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJOBJ0190& InObject)
	{
		mpTopNode = InObject.mpTopNode;
		mbBreak = InObject.mbBreak;
		mRadius = InObject.mRadius;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0190, commonObj>("PJOBJ0190")
			.addFunction("__tostring", &PJOBJ0190::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0190::GetPtrAddr)
			.addProperty("mpTopNode", &PJOBJ0190::mpTopNode)
			.addProperty("mbBreak", &PJOBJ0190::mbBreak)
			.addProperty("mRadius", &PJOBJ0190::mRadius)
			.addFunction("mSetDamage", &PJOBJ0190::mSetDamage)
			.addFunction("mSetDamage_2", &PJOBJ0190::mSetDamage_2)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0190::mpTopNode) == 4, "expected PJOBJ0190::mpTopNode to be size 4");
static_assert(sizeof(PJOBJ0190::mbBreak) == 1, "expected PJOBJ0190::mbBreak to be size 1");
static_assert(sizeof(PJOBJ0190::mRadius) == 4, "expected PJOBJ0190::mRadius to be size 4");
static_assert(sizeof(PJOBJ0190) == 0x658, "expected PJOBJ0190 to be size 0x658");

// [Structure] class PJPTR
class PJPTR
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[1668];

public:
	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") PJPTR::mSetDamage(class PJPTR* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJPTR@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_PJPTR__UAE_NMHHHMHMMPAVmHRChara___Z)(class PJPTR* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_PJPTR__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_PJPTR__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x557550);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJPTR [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJPTR& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJPTR>("PJPTR")
			.addFunction("__tostring", &PJPTR::ToString)
			.addFunction("GetPtrAddr", &PJPTR::GetPtrAddr)
			.addFunction("mSetDamage", &PJPTR::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJPTR) == 0x684, "expected PJPTR to be size 0x684");

// Unsupported constructor
//void __convention("thiscall") HrScreenStatusSlot::HrScreenStatusSlot(class HrScreenStatusSlot* const this)
// Unsupported destructor
//void __convention("thiscall") HrScreenStatusSlot::~HrScreenStatusSlot(class HrScreenStatusSlot* const this)
// Unsupported constructor
//void __convention("thiscall") mHRLockOnList::mHRLockOnList(class mHRLockOnList* const this, class mHRChara* arg2)
// [Structure] class EfSnow
class EfSnow
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[64184];

public:
	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") EfSnow::Initialize(class EfSnow* const this, struct Vec& arg2, class ghmResGroup* arg3, float arg4, float arg5, float arg6, int32_t arg7) [?Initialize@EfSnow@@AAE_NABUVec@@PAVghmResGroup@@MMMH@Z]
	typedef uint8_t(__thiscall* _Initialize_EfSnow__AAE_NABUVec__PAVghmResGroup__MMMH_Z)(class EfSnow* const thisPtr, struct Vec& arg2, class ghmResGroup* arg3, float arg4, float arg5, float arg6, int32_t arg7);
	uint8_t Initialize(struct Vec& arg2, class ghmResGroup* arg3, float arg4, float arg5, float arg6, int32_t arg7)
	{
		_Initialize_EfSnow__AAE_NABUVec__PAVghmResGroup__MMMH_Z mFunc = (_Initialize_EfSnow__AAE_NABUVec__PAVghmResGroup__MMMH_Z)(GameModule + 0x58efa0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	// [Function] class EfSnow* EfSnow::Create(struct Vec& arg1, class ghmResGroup* arg2, float arg3, float arg4, float arg5, int32_t arg6) [?Create@EfSnow@@SAPAV1@ABUVec@@PAVghmResGroup@@MMMH@Z]
	typedef class EfSnow*(__fastcall* _Create_EfSnow__SAPAV1_ABUVec__PAVghmResGroup__MMMH_Z)(struct Vec& arg1, class ghmResGroup* arg2, float arg3, float arg4, float arg5, int32_t arg6);
	static class EfSnow* Create(struct Vec& arg1, class ghmResGroup* arg2, float arg3, float arg4, float arg5, int32_t arg6)
	{
		_Create_EfSnow__SAPAV1_ABUVec__PAVghmResGroup__MMMH_Z mFunc = (_Create_EfSnow__SAPAV1_ABUVec__PAVghmResGroup__MMMH_Z)(GameModule + 0x58f1e0);
		return mFunc(arg1, arg2, arg3, arg4, arg5, arg6);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfSnow [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfSnow& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfSnow>("EfSnow")
			.addFunction("__tostring", &EfSnow::ToString)
			.addFunction("GetPtrAddr", &EfSnow::GetPtrAddr)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("Initialize", &EfSnow::Initialize)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EfSnow::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfSnow) == 0xfab8, "expected EfSnow to be size 0xfab8");

// [Structure] struct NYPictData
struct NYPictData
{
public:
	/// Struct member variables

	// <int32_t m_texId, offset 0x0>
	int32_t m_texId = 0;

	// <float m_texelOffsetX, offset 0x4>
	float m_texelOffsetX = 0;

	// <float m_texelOffsetY, offset 0x8>
	float m_texelOffsetY = 0;

	// <float m_width, offset 0xc>
	float m_width = 0;

	// <float m_height, offset 0x10>
	float m_height = 0;

	// <float m_scaleX, offset 0x14>
	float m_scaleX = 0;

	// <float m_scaleY, offset 0x18>
	float m_scaleY = 0;

	// <float m_pixelOffsetX, offset 0x1c>
	float m_pixelOffsetX = 0;

	// <float m_pixelOffsetY, offset 0x20>
	float m_pixelOffsetY = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct NYPictData [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(NYPictData& InObject)
	{
		m_texId = InObject.m_texId;
		m_texelOffsetX = InObject.m_texelOffsetX;
		m_texelOffsetY = InObject.m_texelOffsetY;
		m_width = InObject.m_width;
		m_height = InObject.m_height;
		m_scaleX = InObject.m_scaleX;
		m_scaleY = InObject.m_scaleY;
		m_pixelOffsetX = InObject.m_pixelOffsetX;
		m_pixelOffsetY = InObject.m_pixelOffsetY;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NYPictData>("NYPictData")
			.addFunction("__tostring", &NYPictData::ToString)
			.addFunction("GetPtrAddr", &NYPictData::GetPtrAddr)
			.addProperty("m_texId", &NYPictData::m_texId)
			.addProperty("m_texelOffsetX", &NYPictData::m_texelOffsetX)
			.addProperty("m_texelOffsetY", &NYPictData::m_texelOffsetY)
			.addProperty("m_width", &NYPictData::m_width)
			.addProperty("m_height", &NYPictData::m_height)
			.addProperty("m_scaleX", &NYPictData::m_scaleX)
			.addProperty("m_scaleY", &NYPictData::m_scaleY)
			.addProperty("m_pixelOffsetX", &NYPictData::m_pixelOffsetX)
			.addProperty("m_pixelOffsetY", &NYPictData::m_pixelOffsetY)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYPictData::m_texId) == 4, "expected NYPictData::m_texId to be size 4");
static_assert(sizeof(NYPictData::m_texelOffsetX) == 4, "expected NYPictData::m_texelOffsetX to be size 4");
static_assert(sizeof(NYPictData::m_texelOffsetY) == 4, "expected NYPictData::m_texelOffsetY to be size 4");
static_assert(sizeof(NYPictData::m_width) == 4, "expected NYPictData::m_width to be size 4");
static_assert(sizeof(NYPictData::m_height) == 4, "expected NYPictData::m_height to be size 4");
static_assert(sizeof(NYPictData::m_scaleX) == 4, "expected NYPictData::m_scaleX to be size 4");
static_assert(sizeof(NYPictData::m_scaleY) == 4, "expected NYPictData::m_scaleY to be size 4");
static_assert(sizeof(NYPictData::m_pixelOffsetX) == 4, "expected NYPictData::m_pixelOffsetX to be size 4");
static_assert(sizeof(NYPictData::m_pixelOffsetY) == 4, "expected NYPictData::m_pixelOffsetY to be size 4");
static_assert(sizeof(NYPictData) == 0x24, "expected NYPictData to be size 0x24");

// Unsupported constructor
//void __convention("thiscall") HrScreenStatusBalloon::HrScreenStatusBalloon(class HrScreenStatusBalloon* const this, struct tagGHMR_TEX* arg2)
// Unsupported constructor
//void __convention("thiscall") CharController::CharController(class CharController* const this, class mHRChara* arg2)
// [Function] void mHRCharaVoiceTable_Initialize() [mHRCharaVoiceTable_Initialize]
typedef void(__fastcall* _mHRCharaVoiceTable_Initialize)();
void mHRCharaVoiceTable_Initialize()
{
	_mHRCharaVoiceTable_Initialize mFunc = (_mHRCharaVoiceTable_Initialize)(GameModule + 0x5b1950);
	return mFunc();
}
// [Structure] struct FkDbgInfo_EventArea
struct FkDbgInfo_EventArea
{
public:
	/// Struct member variables

	// <float fRadius, offset 0x0>
	float fRadius = 0;

	// <struct Vec CenterPos, offset 0x4>
	struct Vec CenterPos;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct FkDbgInfo_EventArea [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkDbgInfo_EventArea& InObject)
	{
		fRadius = InObject.fRadius;
		CenterPos = InObject.CenterPos;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkDbgInfo_EventArea>("FkDbgInfo_EventArea")
			.addFunction("__tostring", &FkDbgInfo_EventArea::ToString)
			.addFunction("GetPtrAddr", &FkDbgInfo_EventArea::GetPtrAddr)
			.addProperty("fRadius", &FkDbgInfo_EventArea::fRadius)
			.addProperty("CenterPos", &FkDbgInfo_EventArea::CenterPos)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkDbgInfo_EventArea::fRadius) == 4, "expected FkDbgInfo_EventArea::fRadius to be size 4");
static_assert(sizeof(FkDbgInfo_EventArea::CenterPos) == 12, "expected FkDbgInfo_EventArea::CenterPos to be size 12");
static_assert(sizeof(FkDbgInfo_EventArea) == 0x10, "expected FkDbgInfo_EventArea to be size 0x10");

// [Structure] class FkGlobalDBG
class FkGlobalDBG
{
public:
	// [Structure] struct FkGlobalDBG::CommonObjSetInf
	struct CommonObjSetInf
	{
	public:
		/// Struct member variables

		// <int32_t iNowCursor, offset 0x0>
		int32_t iNowCursor = 0;

		// <uint32_t nObjRegist, offset 0x4>
		uint32_t nObjRegist = 0;

		// <struct Vec SetPos, offset 0x8>
		struct Vec SetPos;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct FkGlobalDBG::CommonObjSetInf [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(FkGlobalDBG::CommonObjSetInf& InObject)
		{
			iNowCursor = InObject.iNowCursor;
			nObjRegist = InObject.nObjRegist;
			SetPos = InObject.SetPos;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CommonObjSetInf>("FkGlobalDBG_CommonObjSetInf")
				.addFunction("__tostring", &FkGlobalDBG::CommonObjSetInf::ToString)
				.addFunction("GetPtrAddr", &FkGlobalDBG::CommonObjSetInf::GetPtrAddr)
				.addProperty("iNowCursor", &FkGlobalDBG::CommonObjSetInf::iNowCursor)
				.addProperty("nObjRegist", &FkGlobalDBG::CommonObjSetInf::nObjRegist)
				.addProperty("SetPos", &FkGlobalDBG::CommonObjSetInf::SetPos)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::iNowCursor) == 4, "expected FkGlobalDBG::CommonObjSetInf::iNowCursor to be size 4");
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::nObjRegist) == 4, "expected FkGlobalDBG::CommonObjSetInf::nObjRegist to be size 4");
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::SetPos) == 12, "expected FkGlobalDBG::CommonObjSetInf::SetPos to be size 12");
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf) == 0x14, "expected FkGlobalDBG::CommonObjSetInf to be size 0x14");

	/// Struct member variables

	// <struct FkDbgInfo_EventArea m_EventAreaDbgInfo, offset 0x0>
	struct FkDbgInfo_EventArea m_EventAreaDbgInfo;

	// <class PathPlanner* m_pPathPlanner, offset 0x10>
	class PathPlanner* m_pPathPlanner = nullptr;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData_20[4];

public:
	// <uint64_t m_PathPlanningTime, offset 0x18>
	uint64_t m_PathPlanningTime;

	// <class mHRChara* m_pCtrlChar, offset 0x20>
	class mHRChara* m_pCtrlChar = nullptr;

	// <struct FkGlobalDBG::CommonObjSetInf m_CmnObjSetInf, offset 0x24>
	struct FkGlobalDBG::CommonObjSetInf m_CmnObjSetInf;

	/// 1 Functions

	// [Function] void __convention("thiscall") FkGlobalDBG::ReleaseCtrlChar(class FkGlobalDBG* const this, class mHRChara* arg2) [?ReleaseCtrlChar@FkGlobalDBG@@QAEXPAVmHRChara@@@Z]
	typedef void(__thiscall* _ReleaseCtrlChar_FkGlobalDBG__QAEXPAVmHRChara___Z)(class FkGlobalDBG* const thisPtr, class mHRChara* arg2);
	void ReleaseCtrlChar(class mHRChara* arg2)
	{
		_ReleaseCtrlChar_FkGlobalDBG__QAEXPAVmHRChara___Z mFunc = (_ReleaseCtrlChar_FkGlobalDBG__QAEXPAVmHRChara___Z)(GameModule + 0x5b39a0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class FkGlobalDBG [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkGlobalDBG& InObject)
	{
		m_EventAreaDbgInfo = InObject.m_EventAreaDbgInfo;
		m_pPathPlanner = InObject.m_pPathPlanner;
		m_PathPlanningTime = InObject.m_PathPlanningTime;
		m_pCtrlChar = InObject.m_pCtrlChar;
		m_CmnObjSetInf = InObject.m_CmnObjSetInf;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkGlobalDBG>("FkGlobalDBG")
			.addFunction("__tostring", &FkGlobalDBG::ToString)
			.addFunction("GetPtrAddr", &FkGlobalDBG::GetPtrAddr)
			.addProperty("m_EventAreaDbgInfo", &FkGlobalDBG::m_EventAreaDbgInfo)
			.addProperty("m_pPathPlanner", &FkGlobalDBG::m_pPathPlanner)
			.addProperty("m_PathPlanningTime", &FkGlobalDBG::m_PathPlanningTime)
			.addProperty("m_pCtrlChar", &FkGlobalDBG::m_pCtrlChar)
			.addProperty("m_CmnObjSetInf", &FkGlobalDBG::m_CmnObjSetInf)
			.addFunction("ReleaseCtrlChar", &FkGlobalDBG::ReleaseCtrlChar)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkGlobalDBG::m_EventAreaDbgInfo) == 16, "expected FkGlobalDBG::m_EventAreaDbgInfo to be size 16");
static_assert(sizeof(FkGlobalDBG::m_pPathPlanner) == 4, "expected FkGlobalDBG::m_pPathPlanner to be size 4");
static_assert(sizeof(FkGlobalDBG::m_PathPlanningTime) == 8, "expected FkGlobalDBG::m_PathPlanningTime to be size 8");
static_assert(sizeof(FkGlobalDBG::m_pCtrlChar) == 4, "expected FkGlobalDBG::m_pCtrlChar to be size 4");
static_assert(sizeof(FkGlobalDBG::m_CmnObjSetInf) == 20, "expected FkGlobalDBG::m_CmnObjSetInf to be size 20");
static_assert(sizeof(FkGlobalDBG) == 0x38, "expected FkGlobalDBG to be size 0x38");

// [Structure] class EffectBloodSplash
class EffectBloodSplash : public HrTask
{
public:
	// [Structure] struct EffectBloodSplash::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <class TGmfNode* Node, offset 0x0>
		class TGmfNode* Node = nullptr;

		// <class EffectSimpleObj2* Line, offset 0x4>
		class EffectSimpleObj2* Line = nullptr;

		// <struct TGMFMESH** MeshList, offset 0x8>
		struct TGMFMESH** MeshList = nullptr;

		// <float AreaSize, offset 0xc>
		float AreaSize = 0;

		// <float MaxSpeed, offset 0x10>
		float MaxSpeed = 0;

		// <float MinSpeed, offset 0x14>
		float MinSpeed = 0;

		// <float MaxWidth, offset 0x18>
		float MaxWidth = 0;

		// <float MinWidth, offset 0x1c>
		float MinWidth = 0;

		// <float MaxSize, offset 0x20>
		float MaxSize = 0;

		// <float MinSize, offset 0x24>
		float MinSize = 0;

		// <float Length, offset 0x28>
		float Length = 0;

		// <float Width, offset 0x2c>
		float Width = 0;

		// <float CreateRate, offset 0x30>
		float CreateRate = 0;

		// <float TimeCounter, offset 0x34>
		float TimeCounter = 0;

		// <float Time, offset 0x38>
		float Time = 0;

		// <float FadeTime, offset 0x3c>
		float FadeTime = 0;

		// <float SpeedRate, offset 0x40>
		float SpeedRate = 0;

		// <float SpeedRate2, offset 0x44>
		float SpeedRate2 = 0;

		// <int32_t MinRangeCounter, offset 0x48>
		int32_t MinRangeCounter = 0;

		// <int32_t MinRangeSpeed, offset 0x4c>
		int32_t MinRangeSpeed = 0;

		// <int32_t MinRangeSpeedTime, offset 0x50>
		int32_t MinRangeSpeedTime = 0;

		// <float MinRimitSpeed, offset 0x54>
		float MinRimitSpeed = 0;

		// <float MinCreateRate, offset 0x58>
		float MinCreateRate = 0;

		// <float CenterRate, offset 0x5c>
		float CenterRate = 0;

		// <float FadeSpeed, offset 0x60>
		float FadeSpeed = 0;

		// <float FadeSpeed2, offset 0x64>
		float FadeSpeed2 = 0;

		// <float MinRange, offset 0x68>
		float MinRange = 0;

		// <float DirRange, offset 0x6c>
		float DirRange = 0;

		// <float FadeTime2CreateRate, offset 0x70>
		float FadeTime2CreateRate = 0;

		// <float FadeTime2SpeedRate, offset 0x74>
		float FadeTime2SpeedRate = 0;

		// <float FadeTime2, offset 0x78>
		float FadeTime2 = 0;

		// <struct Vec Pos, offset 0x7c>
		struct Vec Pos;

		// <struct Vec Dir, offset 0x88>
		struct Vec Dir;

		// <uint8_t DirValid, offset 0x94>
		uint8_t DirValid = 0;

		// <uint8_t AddStopFlag, offset 0x95>
		uint8_t AddStopFlag = 0;

		// <Unidentified data segment, offset 0x96>
	private:
		char _UnidentifiedData_150[2];

	public:
		// <int32_t id, offset 0x98>
		int32_t id = 0;

		// <class mHRChara* pOwner, offset 0x9c>
		class mHRChara* pOwner = nullptr;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectBloodSplash::MAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectBloodSplash::MAIN& InObject)
		{
			Node = InObject.Node;
			Line = InObject.Line;
			MeshList = InObject.MeshList;
			AreaSize = InObject.AreaSize;
			MaxSpeed = InObject.MaxSpeed;
			MinSpeed = InObject.MinSpeed;
			MaxWidth = InObject.MaxWidth;
			MinWidth = InObject.MinWidth;
			MaxSize = InObject.MaxSize;
			MinSize = InObject.MinSize;
			Length = InObject.Length;
			Width = InObject.Width;
			CreateRate = InObject.CreateRate;
			TimeCounter = InObject.TimeCounter;
			Time = InObject.Time;
			FadeTime = InObject.FadeTime;
			SpeedRate = InObject.SpeedRate;
			SpeedRate2 = InObject.SpeedRate2;
			MinRangeCounter = InObject.MinRangeCounter;
			MinRangeSpeed = InObject.MinRangeSpeed;
			MinRangeSpeedTime = InObject.MinRangeSpeedTime;
			MinRimitSpeed = InObject.MinRimitSpeed;
			MinCreateRate = InObject.MinCreateRate;
			CenterRate = InObject.CenterRate;
			FadeSpeed = InObject.FadeSpeed;
			FadeSpeed2 = InObject.FadeSpeed2;
			MinRange = InObject.MinRange;
			DirRange = InObject.DirRange;
			FadeTime2CreateRate = InObject.FadeTime2CreateRate;
			FadeTime2SpeedRate = InObject.FadeTime2SpeedRate;
			FadeTime2 = InObject.FadeTime2;
			Pos = InObject.Pos;
			Dir = InObject.Dir;
			DirValid = InObject.DirValid;
			AddStopFlag = InObject.AddStopFlag;
			id = InObject.id;
			pOwner = InObject.pOwner;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MAIN>("EffectBloodSplash_MAIN")
				.addFunction("__tostring", &EffectBloodSplash::MAIN::ToString)
				.addFunction("GetPtrAddr", &EffectBloodSplash::MAIN::GetPtrAddr)
				.addProperty("Node", &EffectBloodSplash::MAIN::Node)
				.addProperty("Line", &EffectBloodSplash::MAIN::Line)
				// pointer to pointer is not supported in LuaBridge
				//.addProperty("MeshList", &EffectBloodSplash::MAIN::MeshList)
				.addProperty("AreaSize", &EffectBloodSplash::MAIN::AreaSize)
				.addProperty("MaxSpeed", &EffectBloodSplash::MAIN::MaxSpeed)
				.addProperty("MinSpeed", &EffectBloodSplash::MAIN::MinSpeed)
				.addProperty("MaxWidth", &EffectBloodSplash::MAIN::MaxWidth)
				.addProperty("MinWidth", &EffectBloodSplash::MAIN::MinWidth)
				.addProperty("MaxSize", &EffectBloodSplash::MAIN::MaxSize)
				.addProperty("MinSize", &EffectBloodSplash::MAIN::MinSize)
				.addProperty("Length", &EffectBloodSplash::MAIN::Length)
				.addProperty("Width", &EffectBloodSplash::MAIN::Width)
				.addProperty("CreateRate", &EffectBloodSplash::MAIN::CreateRate)
				.addProperty("TimeCounter", &EffectBloodSplash::MAIN::TimeCounter)
				.addProperty("Time", &EffectBloodSplash::MAIN::Time)
				.addProperty("FadeTime", &EffectBloodSplash::MAIN::FadeTime)
				.addProperty("SpeedRate", &EffectBloodSplash::MAIN::SpeedRate)
				.addProperty("SpeedRate2", &EffectBloodSplash::MAIN::SpeedRate2)
				.addProperty("MinRangeCounter", &EffectBloodSplash::MAIN::MinRangeCounter)
				.addProperty("MinRangeSpeed", &EffectBloodSplash::MAIN::MinRangeSpeed)
				.addProperty("MinRangeSpeedTime", &EffectBloodSplash::MAIN::MinRangeSpeedTime)
				.addProperty("MinRimitSpeed", &EffectBloodSplash::MAIN::MinRimitSpeed)
				.addProperty("MinCreateRate", &EffectBloodSplash::MAIN::MinCreateRate)
				.addProperty("CenterRate", &EffectBloodSplash::MAIN::CenterRate)
				.addProperty("FadeSpeed", &EffectBloodSplash::MAIN::FadeSpeed)
				.addProperty("FadeSpeed2", &EffectBloodSplash::MAIN::FadeSpeed2)
				.addProperty("MinRange", &EffectBloodSplash::MAIN::MinRange)
				.addProperty("DirRange", &EffectBloodSplash::MAIN::DirRange)
				.addProperty("FadeTime2CreateRate", &EffectBloodSplash::MAIN::FadeTime2CreateRate)
				.addProperty("FadeTime2SpeedRate", &EffectBloodSplash::MAIN::FadeTime2SpeedRate)
				.addProperty("FadeTime2", &EffectBloodSplash::MAIN::FadeTime2)
				.addProperty("Pos", &EffectBloodSplash::MAIN::Pos)
				.addProperty("Dir", &EffectBloodSplash::MAIN::Dir)
				.addProperty("DirValid", &EffectBloodSplash::MAIN::DirValid)
				.addProperty("AddStopFlag", &EffectBloodSplash::MAIN::AddStopFlag)
				.addProperty("id", &EffectBloodSplash::MAIN::id)
				.addProperty("pOwner", &EffectBloodSplash::MAIN::pOwner)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectBloodSplash::MAIN::Node) == 4, "expected EffectBloodSplash::MAIN::Node to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Line) == 4, "expected EffectBloodSplash::MAIN::Line to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MeshList) == 4, "expected EffectBloodSplash::MAIN::MeshList to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::AreaSize) == 4, "expected EffectBloodSplash::MAIN::AreaSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxSpeed) == 4, "expected EffectBloodSplash::MAIN::MaxSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinSpeed) == 4, "expected EffectBloodSplash::MAIN::MinSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxWidth) == 4, "expected EffectBloodSplash::MAIN::MaxWidth to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinWidth) == 4, "expected EffectBloodSplash::MAIN::MinWidth to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxSize) == 4, "expected EffectBloodSplash::MAIN::MaxSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinSize) == 4, "expected EffectBloodSplash::MAIN::MinSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Length) == 4, "expected EffectBloodSplash::MAIN::Length to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Width) == 4, "expected EffectBloodSplash::MAIN::Width to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::CreateRate) == 4, "expected EffectBloodSplash::MAIN::CreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::TimeCounter) == 4, "expected EffectBloodSplash::MAIN::TimeCounter to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Time) == 4, "expected EffectBloodSplash::MAIN::Time to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime) == 4, "expected EffectBloodSplash::MAIN::FadeTime to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::SpeedRate) == 4, "expected EffectBloodSplash::MAIN::SpeedRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::SpeedRate2) == 4, "expected EffectBloodSplash::MAIN::SpeedRate2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeCounter) == 4, "expected EffectBloodSplash::MAIN::MinRangeCounter to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeSpeed) == 4, "expected EffectBloodSplash::MAIN::MinRangeSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeSpeedTime) == 4, "expected EffectBloodSplash::MAIN::MinRangeSpeedTime to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRimitSpeed) == 4, "expected EffectBloodSplash::MAIN::MinRimitSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinCreateRate) == 4, "expected EffectBloodSplash::MAIN::MinCreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::CenterRate) == 4, "expected EffectBloodSplash::MAIN::CenterRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeSpeed) == 4, "expected EffectBloodSplash::MAIN::FadeSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeSpeed2) == 4, "expected EffectBloodSplash::MAIN::FadeSpeed2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRange) == 4, "expected EffectBloodSplash::MAIN::MinRange to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::DirRange) == 4, "expected EffectBloodSplash::MAIN::DirRange to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2CreateRate) == 4, "expected EffectBloodSplash::MAIN::FadeTime2CreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2SpeedRate) == 4, "expected EffectBloodSplash::MAIN::FadeTime2SpeedRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2) == 4, "expected EffectBloodSplash::MAIN::FadeTime2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Pos) == 12, "expected EffectBloodSplash::MAIN::Pos to be size 12");
	static_assert(sizeof(EffectBloodSplash::MAIN::Dir) == 12, "expected EffectBloodSplash::MAIN::Dir to be size 12");
	static_assert(sizeof(EffectBloodSplash::MAIN::DirValid) == 1, "expected EffectBloodSplash::MAIN::DirValid to be size 1");
	static_assert(sizeof(EffectBloodSplash::MAIN::AddStopFlag) == 1, "expected EffectBloodSplash::MAIN::AddStopFlag to be size 1");
	static_assert(sizeof(EffectBloodSplash::MAIN::id) == 4, "expected EffectBloodSplash::MAIN::id to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::pOwner) == 4, "expected EffectBloodSplash::MAIN::pOwner to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN) == 0xa0, "expected EffectBloodSplash::MAIN to be size 0xa0");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <float m_fCreateNum, offset 0x50>
	float m_fCreateNum = 0;

	// <struct EffectBloodSplash::MAIN dat, offset 0x54>
	struct EffectBloodSplash::MAIN dat;

	/// 2 Functions

	// [Function] class EffectBloodSplash* EffectBloodSplash::Create(class TGmfNode* GmfNode, int32_t Time, int32_t FadeTime, float MaxSpeed, float MinSpeed, float MaxSize, float MinSize, float MaxWidth, float MinWidth, float Length, float Width, float PaintSizeRate, float PaintSizeSpeed, float CreateRate, int32_t MaxObjNum, float FloorY, int32_t PaintFadeWait, float MinRimitSpeed, float MinCreateRate, float CenterRate, float arg21, float arg22, float arg23, float arg24, float arg25, float arg26, float arg27, uint32_t arg28, uint8_t arg29, class mHRChara* arg30) [?Create@EffectBloodSplash@@SAPAV1@PAVTGmfNode@@HHMMMMMMMMMMMHMHMMMMMMMMMMI_NPAVmHRChara@@@Z]
	typedef class EffectBloodSplash*(__fastcall* _Create_EffectBloodSplash__SAPAV1_PAVTGmfNode__HHMMMMMMMMMMMHMHMMMMMMMMMMI_NPAVmHRChara___Z)(class TGmfNode* GmfNode, int32_t Time, int32_t FadeTime, float MaxSpeed, float MinSpeed, float MaxSize, float MinSize, float MaxWidth, float MinWidth, float Length, float Width, float PaintSizeRate, float PaintSizeSpeed, float CreateRate, int32_t MaxObjNum, float FloorY, int32_t PaintFadeWait, float MinRimitSpeed, float MinCreateRate, float CenterRate, float arg21, float arg22, float arg23, float arg24, float arg25, float arg26, float arg27, uint32_t arg28, uint8_t arg29, class mHRChara* arg30);
	static class EffectBloodSplash* Create(class TGmfNode* GmfNode, int32_t Time, int32_t FadeTime, float MaxSpeed, float MinSpeed, float MaxSize, float MinSize, float MaxWidth, float MinWidth, float Length, float Width, float PaintSizeRate, float PaintSizeSpeed, float CreateRate, int32_t MaxObjNum, float FloorY, int32_t PaintFadeWait, float MinRimitSpeed, float MinCreateRate, float CenterRate, float arg21, float arg22, float arg23, float arg24, float arg25, float arg26, float arg27, uint32_t arg28, uint8_t arg29, class mHRChara* arg30)
	{
		_Create_EffectBloodSplash__SAPAV1_PAVTGmfNode__HHMMMMMMMMMMMHMHMMMMMMMMMMI_NPAVmHRChara___Z mFunc = (_Create_EffectBloodSplash__SAPAV1_PAVTGmfNode__HHMMMMMMMMMMMHMHMMMMMMMMMMI_NPAVmHRChara___Z)(GameModule + 0x5b4ec0);
		return mFunc(GmfNode, Time, FadeTime, MaxSpeed, MinSpeed, MaxSize, MinSize, MaxWidth, MinWidth, Length, Width, PaintSizeRate, PaintSizeSpeed, CreateRate, MaxObjNum, FloorY, PaintFadeWait, MinRimitSpeed, MinCreateRate, CenterRate, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30);
	}
	// [Function] class EffectBloodSplash* __fastcall EffectBloodSplash::Create2(class TGmfNode* GmfNode, float FloorY, float PowerRate, float DirRangeAdd, float CreateNumRate, int32_t arg6, bool NoPaint, class mHRChara* pOwner) [?Create2@EffectBloodSplash@@SAPAV1@PAVTGmfNode@@MMMMH_NPAVmHRChara@@@Z]
	typedef class EffectBloodSplash*(__fastcall* _Create2_EffectBloodSplash__SAPAV1_PAVTGmfNode__MMMMH_NPAVmHRChara___Z)(class TGmfNode* GmfNode, float FloorY, float PowerRate, float DirRangeAdd, float CreateNumRate, int32_t arg6, bool NoPaint, class mHRChara* pOwner);
	static class EffectBloodSplash* Create2(class TGmfNode* GmfNode, float FloorY, float PowerRate, float DirRangeAdd, float CreateNumRate, int32_t arg6, bool NoPaint, class mHRChara* pOwner)
	{
		_Create2_EffectBloodSplash__SAPAV1_PAVTGmfNode__MMMMH_NPAVmHRChara___Z mFunc = (_Create2_EffectBloodSplash__SAPAV1_PAVTGmfNode__MMMMH_NPAVmHRChara___Z)(GameModule + 0x5b5410);
		return mFunc(GmfNode, FloorY, PowerRate, DirRangeAdd, CreateNumRate, arg6, NoPaint, pOwner);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectBloodSplash [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectBloodSplash& InObject)
	{
		m_fCreateNum = InObject.m_fCreateNum;
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectBloodSplash, HrTask>("EffectBloodSplash")
			.addFunction("__tostring", &EffectBloodSplash::ToString)
			.addFunction("GetPtrAddr", &EffectBloodSplash::GetPtrAddr)
			.addProperty("m_fCreateNum", &EffectBloodSplash::m_fCreateNum)
			.addProperty("dat", &EffectBloodSplash::dat)
			// Can't export functions with more than 11 parameters to LuaBridge.
			//.addStaticFunction("Create", &EffectBloodSplash::Create)
			.addStaticFunction("Create2", &EffectBloodSplash::Create2)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectBloodSplash::m_fCreateNum) == 4, "expected EffectBloodSplash::m_fCreateNum to be size 4");
static_assert(sizeof(EffectBloodSplash::dat) == 160, "expected EffectBloodSplash::dat to be size 160");
static_assert(sizeof(EffectBloodSplash) == 0xf4, "expected EffectBloodSplash to be size 0xf4");

// [Structure] class EffectSimpleObj2
class EffectSimpleObj2 : public HrTask
{
public:
	// [Structure] struct EffectSimpleObj2::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <int32_t ObjNum2, offset 0x0>
		int32_t ObjNum2 = 0;

		// <int32_t ObjNum1, offset 0x4>
		int32_t ObjNum1 = 0;

		// <struct EffectSimpleObj2::OBJECT* obj, offset 0x8>
		struct OBJECT* obj = nullptr;

		// <Unidentified data segment, offset 0xc>
	private:
		char _UnidentifiedData_12[156];

	public:
		// <bool bAddBlend, offset 0xa8>
		bool bAddBlend;

		// <Unidentified data segment, offset 0xa9>
	private:
		char _UnidentifiedData_169[7];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectSimpleObj2::MAIN [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectSimpleObj2::MAIN& InObject)
		{
			ObjNum2 = InObject.ObjNum2;
			ObjNum1 = InObject.ObjNum1;
			obj = InObject.obj;
			bAddBlend = InObject.bAddBlend;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<MAIN>("EffectSimpleObj2_MAIN")
				.addFunction("__tostring", &EffectSimpleObj2::MAIN::ToString)
				.addFunction("GetPtrAddr", &EffectSimpleObj2::MAIN::GetPtrAddr)
				.addProperty("ObjNum2", &EffectSimpleObj2::MAIN::ObjNum2)
				.addProperty("ObjNum1", &EffectSimpleObj2::MAIN::ObjNum1)
				.addProperty("obj", &EffectSimpleObj2::MAIN::obj)
				.addProperty("bAddBlend", &EffectSimpleObj2::MAIN::bAddBlend)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectSimpleObj2::MAIN::ObjNum2) == 4, "expected EffectSimpleObj2::MAIN::ObjNum2 to be size 4");
	static_assert(sizeof(EffectSimpleObj2::MAIN::ObjNum1) == 4, "expected EffectSimpleObj2::MAIN::ObjNum1 to be size 4");
	static_assert(sizeof(EffectSimpleObj2::MAIN::obj) == 4, "expected EffectSimpleObj2::MAIN::obj to be size 4");
	static_assert(sizeof(EffectSimpleObj2::MAIN::bAddBlend) == 1, "expected EffectSimpleObj2::MAIN::bAddBlend to be size 1");
	static_assert(sizeof(EffectSimpleObj2::MAIN) == 0xb0, "expected EffectSimpleObj2::MAIN to be size 0xb0");

	// [Structure] struct EffectSimpleObj2::OBJECT
	struct OBJECT
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData_0[80];

	public:
		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct EffectSimpleObj2::OBJECT [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(EffectSimpleObj2::OBJECT& InObject)
		{
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<OBJECT>("EffectSimpleObj2_OBJECT")
				.addFunction("__tostring", &EffectSimpleObj2::OBJECT::ToString)
				.addFunction("GetPtrAddr", &EffectSimpleObj2::OBJECT::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectSimpleObj2::OBJECT) == 0x50, "expected EffectSimpleObj2::OBJECT to be size 0x50");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectSimpleObj2::MAIN dat, offset 0x50>
	struct EffectSimpleObj2::MAIN dat;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectSimpleObj2 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectSimpleObj2& InObject)
	{
		dat = InObject.dat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSimpleObj2, HrTask>("EffectSimpleObj2")
			.addFunction("__tostring", &EffectSimpleObj2::ToString)
			.addFunction("GetPtrAddr", &EffectSimpleObj2::GetPtrAddr)
			.addProperty("dat", &EffectSimpleObj2::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSimpleObj2::dat) == 176, "expected EffectSimpleObj2::dat to be size 176");
static_assert(sizeof(EffectSimpleObj2) == 0x100, "expected EffectSimpleObj2 to be size 0x100");

// [Structure] class EfBossDead
class EfBossDead : public HrTask
{
public:
	// enum EfBossDead::Chapter
	enum Chapter : uint32_t
	{
		// <Chapter_SKE = 0x1>
		Chapter_SKE = 1,

		// <Chapter_GYN = 0x2>
		Chapter_GYN = 2,

		// <Chapter_SDP = 0x3>
		Chapter_SDP = 3,

		// <Chapter_MGN = 0x4>
		Chapter_MGN = 4,

		// <Chapter_SPU = 0x5>
		Chapter_SPU = 5,

		// <Chapter_POP = 0x6>
		Chapter_POP = 6,

		// <Chapter_LET = 0x7>
		Chapter_LET = 7,

		// <Chapter_CEW = 0x8>
		Chapter_CEW = 8,

		// <Chapter_DSL = 0x9>
		Chapter_DSL = 9,

		// <Chapter_JPY = 0xa>
		Chapter_JPY = 10,

		// <Chapter_MOE = 0xb>
		Chapter_MOE = 11,

		// <Chapter_GSR = 0xc>
		Chapter_GSR = 12,

		// <Chapter_AST = 0xd>
		Chapter_AST = 13,

		// <Chapter_RKT = 0xe>
		Chapter_RKT = 14,

		// <Chapter_JBJ = 0xf>
		Chapter_JBJ = 15

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <class EfDeadString* mpDeadString, offset 0x68>
	class EfDeadString* mpDeadString = nullptr;

	// <struct tagGHMR_TEX mBossTex, offset 0x6c>
	struct tagGHMR_TEX mBossTex;

	// <struct tagGHMR_TEX mDeadTex, offset 0x94>
	struct tagGHMR_TEX mDeadTex;

	// <enum EfBossDead::Chapter mChapterNo, offset 0xbc>
	enum EfBossDead::Chapter mChapterNo;

	// <char mBossName[0x8], offset 0xc0>
	char mBossName[8];

	// <uint8_t mNameActive, offset 0xc8>
	uint8_t mNameActive = 0;

	// <uint8_t mDeadActive, offset 0xc9>
	uint8_t mDeadActive = 0;

	// <Unidentified data segment, offset 0xca>
private:
	char _UnidentifiedData_202[2];

public:
	// <float mNameSlide, offset 0xcc>
	float mNameSlide = 0;

	// <float mDeadScale, offset 0xd0>
	float mDeadScale = 0;

	// <float mDeadRot, offset 0xd4>
	float mDeadRot = 0;

	// <int32_t mDeadRotCnt, offset 0xd8>
	int32_t mDeadRotCnt = 0;

	// <uint8_t mbFarBloom, offset 0xdc>
	uint8_t mbFarBloom = 0;

	// <uint8_t mbThresoldBloom, offset 0xdd>
	uint8_t mbThresoldBloom = 0;

	// <uint8_t mbDelete, offset 0xde>
	uint8_t mbDelete = 0;

	// <Unidentified data segment, offset 0xdf>
private:
	char _UnidentifiedData_223[1];

public:
	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") EfBossDead::Initialize(class EfBossDead* const this, int32_t arg2, class ghmResGroup* arg3) [?Initialize@EfBossDead@@AAE_NHPAVghmResGroup@@@Z]
	typedef uint8_t(__thiscall* _Initialize_EfBossDead__AAE_NHPAVghmResGroup___Z)(class EfBossDead* const thisPtr, int32_t arg2, class ghmResGroup* arg3);
	uint8_t Initialize(int32_t arg2, class ghmResGroup* arg3)
	{
		_Initialize_EfBossDead__AAE_NHPAVghmResGroup___Z mFunc = (_Initialize_EfBossDead__AAE_NHPAVghmResGroup___Z)(GameModule + 0x5b9110);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class EfBossDead* EfBossDead::Create(int32_t arg1, class ghmResGroup* arg2) [?Create@EfBossDead@@SAPAV1@HPAVghmResGroup@@@Z]
	typedef class EfBossDead*(__fastcall* _Create_EfBossDead__SAPAV1_HPAVghmResGroup___Z)(int32_t arg1, class ghmResGroup* arg2);
	static class EfBossDead* Create(int32_t arg1, class ghmResGroup* arg2)
	{
		_Create_EfBossDead__SAPAV1_HPAVghmResGroup___Z mFunc = (_Create_EfBossDead__SAPAV1_HPAVghmResGroup___Z)(GameModule + 0x5b9a40);
		return mFunc(arg1, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfBossDead [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfBossDead& InObject)
	{
		field_50 = InObject.field_50;
		mpDeadString = InObject.mpDeadString;
		mBossTex = InObject.mBossTex;
		mDeadTex = InObject.mDeadTex;
		mChapterNo = InObject.mChapterNo;
		mNameActive = InObject.mNameActive;
		mDeadActive = InObject.mDeadActive;
		mNameSlide = InObject.mNameSlide;
		mDeadScale = InObject.mDeadScale;
		mDeadRot = InObject.mDeadRot;
		mDeadRotCnt = InObject.mDeadRotCnt;
		mbFarBloom = InObject.mbFarBloom;
		mbThresoldBloom = InObject.mbThresoldBloom;
		mbDelete = InObject.mbDelete;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfBossDead, HrTask>("EfBossDead")
			.addFunction("__tostring", &EfBossDead::ToString)
			.addFunction("GetPtrAddr", &EfBossDead::GetPtrAddr)
			.addProperty("field_50", &EfBossDead::field_50)
			.addProperty("mpDeadString", &EfBossDead::mpDeadString)
			.addProperty("mBossTex", &EfBossDead::mBossTex)
			.addProperty("mDeadTex", &EfBossDead::mDeadTex)
			.addProperty("mChapterNo", &EfBossDead::mChapterNo)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mBossName", &EfBossDead::mBossName)
			.addProperty("mNameActive", &EfBossDead::mNameActive)
			.addProperty("mDeadActive", &EfBossDead::mDeadActive)
			.addProperty("mNameSlide", &EfBossDead::mNameSlide)
			.addProperty("mDeadScale", &EfBossDead::mDeadScale)
			.addProperty("mDeadRot", &EfBossDead::mDeadRot)
			.addProperty("mDeadRotCnt", &EfBossDead::mDeadRotCnt)
			.addProperty("mbFarBloom", &EfBossDead::mbFarBloom)
			.addProperty("mbThresoldBloom", &EfBossDead::mbThresoldBloom)
			.addProperty("mbDelete", &EfBossDead::mbDelete)
			.addFunction("Initialize", &EfBossDead::Initialize)
			.addStaticFunction("Create", &EfBossDead::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfBossDead::field_50) == 24, "expected EfBossDead::field_50 to be size 24");
static_assert(sizeof(EfBossDead::mpDeadString) == 4, "expected EfBossDead::mpDeadString to be size 4");
static_assert(sizeof(EfBossDead::mBossTex) == 40, "expected EfBossDead::mBossTex to be size 40");
static_assert(sizeof(EfBossDead::mDeadTex) == 40, "expected EfBossDead::mDeadTex to be size 40");
static_assert(sizeof(EfBossDead::mChapterNo) == 4, "expected EfBossDead::mChapterNo to be size 4");
static_assert(sizeof(EfBossDead::mBossName) == 8, "expected EfBossDead::mBossName to be size 8");
static_assert(sizeof(EfBossDead::mNameActive) == 1, "expected EfBossDead::mNameActive to be size 1");
static_assert(sizeof(EfBossDead::mDeadActive) == 1, "expected EfBossDead::mDeadActive to be size 1");
static_assert(sizeof(EfBossDead::mNameSlide) == 4, "expected EfBossDead::mNameSlide to be size 4");
static_assert(sizeof(EfBossDead::mDeadScale) == 4, "expected EfBossDead::mDeadScale to be size 4");
static_assert(sizeof(EfBossDead::mDeadRot) == 4, "expected EfBossDead::mDeadRot to be size 4");
static_assert(sizeof(EfBossDead::mDeadRotCnt) == 4, "expected EfBossDead::mDeadRotCnt to be size 4");
static_assert(sizeof(EfBossDead::mbFarBloom) == 1, "expected EfBossDead::mbFarBloom to be size 1");
static_assert(sizeof(EfBossDead::mbThresoldBloom) == 1, "expected EfBossDead::mbThresoldBloom to be size 1");
static_assert(sizeof(EfBossDead::mbDelete) == 1, "expected EfBossDead::mbDelete to be size 1");
static_assert(sizeof(EfBossDead) == 0xe0, "expected EfBossDead to be size 0xe0");

// [Structure] class EfDeadString
class EfDeadString : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <struct tagGHMR_TEX mDeadTex, offset 0x68>
	struct tagGHMR_TEX mDeadTex;

	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") EfDeadString::Initialize(class EfDeadString* const this, int32_t arg2, class ghmResGroup* arg3) [?Initialize@EfDeadString@@AAE_NHPAVghmResGroup@@@Z]
	typedef uint8_t(__thiscall* _Initialize_EfDeadString__AAE_NHPAVghmResGroup___Z)(class EfDeadString* const thisPtr, int32_t arg2, class ghmResGroup* arg3);
	uint8_t Initialize(int32_t arg2, class ghmResGroup* arg3)
	{
		_Initialize_EfDeadString__AAE_NHPAVghmResGroup___Z mFunc = (_Initialize_EfDeadString__AAE_NHPAVghmResGroup___Z)(GameModule + 0x679210);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class EfDeadString* EfDeadString::Create(int32_t arg1, class ghmResGroup* arg2) [?Create@EfDeadString@@SAPAV1@HPAVghmResGroup@@@Z]
	typedef class EfDeadString*(__fastcall* _Create_EfDeadString__SAPAV1_HPAVghmResGroup___Z)(int32_t arg1, class ghmResGroup* arg2);
	static class EfDeadString* Create(int32_t arg1, class ghmResGroup* arg2)
	{
		_Create_EfDeadString__SAPAV1_HPAVghmResGroup___Z mFunc = (_Create_EfDeadString__SAPAV1_HPAVghmResGroup___Z)(GameModule + 0x679270);
		return mFunc(arg1, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfDeadString [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfDeadString& InObject)
	{
		field_50 = InObject.field_50;
		mDeadTex = InObject.mDeadTex;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfDeadString, HrTask>("EfDeadString")
			.addFunction("__tostring", &EfDeadString::ToString)
			.addFunction("GetPtrAddr", &EfDeadString::GetPtrAddr)
			.addProperty("field_50", &EfDeadString::field_50)
			.addProperty("mDeadTex", &EfDeadString::mDeadTex)
			.addFunction("Initialize", &EfDeadString::Initialize)
			.addStaticFunction("Create", &EfDeadString::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfDeadString::field_50) == 24, "expected EfDeadString::field_50 to be size 24");
static_assert(sizeof(EfDeadString::mDeadTex) == 40, "expected EfDeadString::mDeadTex to be size 40");
static_assert(sizeof(EfDeadString) == 0x90, "expected EfDeadString to be size 0x90");

// [Structure] class EffectDemo2D
class EffectDemo2D : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class ghmResGroup* mpRes, offset 0x50>
	class ghmResGroup* mpRes = nullptr;

	// <struct tagGHMR_TEX* mpTex, offset 0x54>
	struct tagGHMR_TEX* mpTex = nullptr;

	// <struct Vec* mPos, offset 0x58>
	struct Vec* mPos = nullptr;

	// <struct Vec* mScale, offset 0x5c>
	struct Vec* mScale = nullptr;

	// <int32_t mR, offset 0x60>
	int32_t mR = 0;

	// <int32_t mG, offset 0x64>
	int32_t mG = 0;

	// <int32_t mB, offset 0x68>
	int32_t mB = 0;

	// <enum GHMR_BLEND mBlendMode, offset 0x6c>
	enum GHMR_BLEND mBlendMode;

	/// 1 Functions

	// [Function] class EffectDemo2D* EffectDemo2D::Create(int32_t arg1, int32_t arg2, int32_t arg3, struct Vec* arg4, struct Vec* arg5, class ghmResGroup* arg6) [?Create@EffectDemo2D@@SAPAV1@HHHPAUVec@@0PAVghmResGroup@@@Z]
	typedef class EffectDemo2D*(__fastcall* _Create_EffectDemo2D__SAPAV1_HHHPAUVec__0PAVghmResGroup___Z)(int32_t arg1, int32_t arg2, int32_t arg3, struct Vec* arg4, struct Vec* arg5, class ghmResGroup* arg6);
	static class EffectDemo2D* Create(int32_t arg1, int32_t arg2, int32_t arg3, struct Vec* arg4, struct Vec* arg5, class ghmResGroup* arg6)
	{
		_Create_EffectDemo2D__SAPAV1_HHHPAUVec__0PAVghmResGroup___Z mFunc = (_Create_EffectDemo2D__SAPAV1_HHHPAUVec__0PAVghmResGroup___Z)(GameModule + 0x5ba390);
		return mFunc(arg1, arg2, arg3, arg4, arg5, arg6);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectDemo2D [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectDemo2D& InObject)
	{
		mpRes = InObject.mpRes;
		mpTex = InObject.mpTex;
		mPos = InObject.mPos;
		mScale = InObject.mScale;
		mR = InObject.mR;
		mG = InObject.mG;
		mB = InObject.mB;
		mBlendMode = InObject.mBlendMode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectDemo2D, HrTask>("EffectDemo2D")
			.addFunction("__tostring", &EffectDemo2D::ToString)
			.addFunction("GetPtrAddr", &EffectDemo2D::GetPtrAddr)
			.addProperty("mpRes", &EffectDemo2D::mpRes)
			.addProperty("mpTex", &EffectDemo2D::mpTex)
			.addProperty("mPos", &EffectDemo2D::mPos)
			.addProperty("mScale", &EffectDemo2D::mScale)
			.addProperty("mR", &EffectDemo2D::mR)
			.addProperty("mG", &EffectDemo2D::mG)
			.addProperty("mB", &EffectDemo2D::mB)
			.addProperty("mBlendMode", &EffectDemo2D::mBlendMode)
			.addStaticFunction("Create", &EffectDemo2D::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectDemo2D::mpRes) == 4, "expected EffectDemo2D::mpRes to be size 4");
static_assert(sizeof(EffectDemo2D::mpTex) == 4, "expected EffectDemo2D::mpTex to be size 4");
static_assert(sizeof(EffectDemo2D::mPos) == 4, "expected EffectDemo2D::mPos to be size 4");
static_assert(sizeof(EffectDemo2D::mScale) == 4, "expected EffectDemo2D::mScale to be size 4");
static_assert(sizeof(EffectDemo2D::mR) == 4, "expected EffectDemo2D::mR to be size 4");
static_assert(sizeof(EffectDemo2D::mG) == 4, "expected EffectDemo2D::mG to be size 4");
static_assert(sizeof(EffectDemo2D::mB) == 4, "expected EffectDemo2D::mB to be size 4");
static_assert(sizeof(EffectDemo2D::mBlendMode) == 4, "expected EffectDemo2D::mBlendMode to be size 4");
static_assert(sizeof(EffectDemo2D) == 0x70, "expected EffectDemo2D to be size 0x70");

// [Structure] class EffectFade
class EffectFade : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class ghmResGroup* mpRes, offset 0x50>
	class ghmResGroup* mpRes = nullptr;

	// <struct tagGHMR_TEX* mpTex, offset 0x54>
	struct tagGHMR_TEX* mpTex = nullptr;

	// <struct Vec* mScale, offset 0x58>
	struct Vec* mScale = nullptr;

	// <int32_t mR, offset 0x5c>
	int32_t mR = 0;

	// <int32_t mG, offset 0x60>
	int32_t mG = 0;

	// <int32_t mB, offset 0x64>
	int32_t mB = 0;

	// <enum GHMR_BLEND mBlendMode, offset 0x68>
	enum GHMR_BLEND mBlendMode;

	/// 1 Functions

	// [Function] class EffectFade* EffectFade::Create(int32_t arg1, int32_t arg2, int32_t arg3, struct Vec* arg4, class ghmResGroup* arg5) [?Create@EffectFade@@SAPAV1@HHHPAUVec@@PAVghmResGroup@@@Z]
	typedef class EffectFade*(__fastcall* _Create_EffectFade__SAPAV1_HHHPAUVec__PAVghmResGroup___Z)(int32_t arg1, int32_t arg2, int32_t arg3, struct Vec* arg4, class ghmResGroup* arg5);
	static class EffectFade* Create(int32_t arg1, int32_t arg2, int32_t arg3, struct Vec* arg4, class ghmResGroup* arg5)
	{
		_Create_EffectFade__SAPAV1_HHHPAUVec__PAVghmResGroup___Z mFunc = (_Create_EffectFade__SAPAV1_HHHPAUVec__PAVghmResGroup___Z)(GameModule + 0x5bcaf0);
		return mFunc(arg1, arg2, arg3, arg4, arg5);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectFade [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectFade& InObject)
	{
		mpRes = InObject.mpRes;
		mpTex = InObject.mpTex;
		mScale = InObject.mScale;
		mR = InObject.mR;
		mG = InObject.mG;
		mB = InObject.mB;
		mBlendMode = InObject.mBlendMode;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectFade, HrTask>("EffectFade")
			.addFunction("__tostring", &EffectFade::ToString)
			.addFunction("GetPtrAddr", &EffectFade::GetPtrAddr)
			.addProperty("mpRes", &EffectFade::mpRes)
			.addProperty("mpTex", &EffectFade::mpTex)
			.addProperty("mScale", &EffectFade::mScale)
			.addProperty("mR", &EffectFade::mR)
			.addProperty("mG", &EffectFade::mG)
			.addProperty("mB", &EffectFade::mB)
			.addProperty("mBlendMode", &EffectFade::mBlendMode)
			.addStaticFunction("Create", &EffectFade::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectFade::mpRes) == 4, "expected EffectFade::mpRes to be size 4");
static_assert(sizeof(EffectFade::mpTex) == 4, "expected EffectFade::mpTex to be size 4");
static_assert(sizeof(EffectFade::mScale) == 4, "expected EffectFade::mScale to be size 4");
static_assert(sizeof(EffectFade::mR) == 4, "expected EffectFade::mR to be size 4");
static_assert(sizeof(EffectFade::mG) == 4, "expected EffectFade::mG to be size 4");
static_assert(sizeof(EffectFade::mB) == 4, "expected EffectFade::mB to be size 4");
static_assert(sizeof(EffectFade::mBlendMode) == 4, "expected EffectFade::mBlendMode to be size 4");
static_assert(sizeof(EffectFade) == 0x6c, "expected EffectFade to be size 0x6c");

// [Structure] class EfSubtitles
class EfSubtitles : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <struct tagGHMR_TEX mSubTex, offset 0x68>
	struct tagGHMR_TEX mSubTex;

	// <struct Vec mPos, offset 0x90>
	struct Vec mPos;

	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") EfSubtitles::Initialize(class EfSubtitles* const this, int32_t arg2, struct Vec& arg3, class ghmResGroup* arg4) [?Initialize@EfSubtitles@@AAE_NHABUVec@@PAVghmResGroup@@@Z]
	typedef uint8_t(__thiscall* _Initialize_EfSubtitles__AAE_NHABUVec__PAVghmResGroup___Z)(class EfSubtitles* const thisPtr, int32_t arg2, struct Vec& arg3, class ghmResGroup* arg4);
	uint8_t Initialize(int32_t arg2, struct Vec& arg3, class ghmResGroup* arg4)
	{
		_Initialize_EfSubtitles__AAE_NHABUVec__PAVghmResGroup___Z mFunc = (_Initialize_EfSubtitles__AAE_NHABUVec__PAVghmResGroup___Z)(GameModule + 0x5bcbe0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class EfSubtitles* EfSubtitles::Create(int32_t arg1, struct Vec& arg2, class ghmResGroup* arg3) [?Create@EfSubtitles@@SAPAV1@HABUVec@@PAVghmResGroup@@@Z]
	typedef class EfSubtitles*(__fastcall* _Create_EfSubtitles__SAPAV1_HABUVec__PAVghmResGroup___Z)(int32_t arg1, struct Vec& arg2, class ghmResGroup* arg3);
	static class EfSubtitles* Create(int32_t arg1, struct Vec& arg2, class ghmResGroup* arg3)
	{
		_Create_EfSubtitles__SAPAV1_HABUVec__PAVghmResGroup___Z mFunc = (_Create_EfSubtitles__SAPAV1_HABUVec__PAVghmResGroup___Z)(GameModule + 0x5bcd10);
		return mFunc(arg1, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EfSubtitles [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EfSubtitles& InObject)
	{
		field_50 = InObject.field_50;
		mSubTex = InObject.mSubTex;
		mPos = InObject.mPos;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfSubtitles, HrTask>("EfSubtitles")
			.addFunction("__tostring", &EfSubtitles::ToString)
			.addFunction("GetPtrAddr", &EfSubtitles::GetPtrAddr)
			.addProperty("field_50", &EfSubtitles::field_50)
			.addProperty("mSubTex", &EfSubtitles::mSubTex)
			.addProperty("mPos", &EfSubtitles::mPos)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("Initialize", &EfSubtitles::Initialize)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EfSubtitles::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfSubtitles::field_50) == 24, "expected EfSubtitles::field_50 to be size 24");
static_assert(sizeof(EfSubtitles::mSubTex) == 40, "expected EfSubtitles::mSubTex to be size 40");
static_assert(sizeof(EfSubtitles::mPos) == 12, "expected EfSubtitles::mPos to be size 12");
static_assert(sizeof(EfSubtitles) == 0x9c, "expected EfSubtitles to be size 0x9c");

// [Structure] class EffectSys
class EffectSys : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct Vec* mpPos, offset 0x50>
	struct Vec* mpPos = nullptr;

	// <struct Vec* mpRot, offset 0x54>
	struct Vec* mpRot = nullptr;

	// <class hEffect* mpEffect, offset 0x58>
	class hEffect* mpEffect = nullptr;

	// <int32_t mTexNum, offset 0x5c>
	int32_t mTexNum = 0;

	// <struct tagGHMR_TEX* mpTex, offset 0x60>
	struct tagGHMR_TEX* mpTex = nullptr;

	// <int32_t mAnimPatNum, offset 0x64>
	int32_t mAnimPatNum = 0;

	// <class hAnimTex* mpAnimPat, offset 0x68>
	class hAnimTex* mpAnimPat = nullptr;

	// <uint8_t mbMemAlloc, offset 0x6c>
	uint8_t mbMemAlloc = 0;

	// <Unidentified data segment, offset 0x6d>
private:
	char _UnidentifiedData_109[3];

public:
	/// 1 Functions

	// [Function] class EffectSys* EffectSys::Create(struct Vec* arg1, struct Vec* arg2, class ghmResGroup* arg3, struct Vec* arg4) [?Create@EffectSys@@SAPAV1@PAUVec@@0PAVghmResGroup@@0@Z]
	typedef class EffectSys*(__fastcall* _Create_EffectSys__SAPAV1_PAUVec__0PAVghmResGroup__0_Z)(struct Vec* arg1, struct Vec* arg2, class ghmResGroup* arg3, struct Vec* arg4);
	static class EffectSys* Create(struct Vec* arg1, struct Vec* arg2, class ghmResGroup* arg3, struct Vec* arg4)
	{
		_Create_EffectSys__SAPAV1_PAUVec__0PAVghmResGroup__0_Z mFunc = (_Create_EffectSys__SAPAV1_PAUVec__0PAVghmResGroup__0_Z)(GameModule + 0x5bd110);
		return mFunc(arg1, arg2, arg3, arg4);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectSys [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectSys& InObject)
	{
		mpPos = InObject.mpPos;
		mpRot = InObject.mpRot;
		mpEffect = InObject.mpEffect;
		mTexNum = InObject.mTexNum;
		mpTex = InObject.mpTex;
		mAnimPatNum = InObject.mAnimPatNum;
		mpAnimPat = InObject.mpAnimPat;
		mbMemAlloc = InObject.mbMemAlloc;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSys, HrTask>("EffectSys")
			.addFunction("__tostring", &EffectSys::ToString)
			.addFunction("GetPtrAddr", &EffectSys::GetPtrAddr)
			.addProperty("mpPos", &EffectSys::mpPos)
			.addProperty("mpRot", &EffectSys::mpRot)
			.addProperty("mpEffect", &EffectSys::mpEffect)
			.addProperty("mTexNum", &EffectSys::mTexNum)
			.addProperty("mpTex", &EffectSys::mpTex)
			.addProperty("mAnimPatNum", &EffectSys::mAnimPatNum)
			.addProperty("mpAnimPat", &EffectSys::mpAnimPat)
			.addProperty("mbMemAlloc", &EffectSys::mbMemAlloc)
			.addStaticFunction("Create", &EffectSys::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSys::mpPos) == 4, "expected EffectSys::mpPos to be size 4");
static_assert(sizeof(EffectSys::mpRot) == 4, "expected EffectSys::mpRot to be size 4");
static_assert(sizeof(EffectSys::mpEffect) == 4, "expected EffectSys::mpEffect to be size 4");
static_assert(sizeof(EffectSys::mTexNum) == 4, "expected EffectSys::mTexNum to be size 4");
static_assert(sizeof(EffectSys::mpTex) == 4, "expected EffectSys::mpTex to be size 4");
static_assert(sizeof(EffectSys::mAnimPatNum) == 4, "expected EffectSys::mAnimPatNum to be size 4");
static_assert(sizeof(EffectSys::mpAnimPat) == 4, "expected EffectSys::mpAnimPat to be size 4");
static_assert(sizeof(EffectSys::mbMemAlloc) == 1, "expected EffectSys::mbMemAlloc to be size 1");
static_assert(sizeof(EffectSys) == 0x70, "expected EffectSys to be size 0x70");

// Unsupported constructor
//void __convention("thiscall") FkObstacleSensor::FkObstacleSensor(class FkObstacleSensor* const this, class mHRChara* arg2)
// [Function] void __convention("thiscall") j_sub_8dcfa0(class PJZAKOBoneFive* const this) [j_sub_8dcfa0]
typedef void(__thiscall* _j_sub_8dcfa0)(class PJZAKOBoneFive* const thisPtr);
void j_sub_8dcfa0(class PJZAKOBoneFive* const thisPtr)
{
	_j_sub_8dcfa0 mFunc = (_j_sub_8dcfa0)(GameModule + 0x5d4f80);
	return mFunc(thisPtr);
}
// Unsupported destructor
//void __convention("thiscall") PJZAKOBoneFive::~PJZAKOBoneFive(class PJZAKOBoneFive* const this)
// Unsupported constructor
//void __convention("thiscall") PJZAKOBoneFive::PJZAKOBoneFive(class PJZAKOBoneFive* const this)
// [Structure] class State_UnderCtrl_Attack
class State_UnderCtrl_Attack : public PJState
{
public:
	// enum State_UnderCtrl_Attack::eCtrlZkAtkSnSt
	enum eCtrlZkAtkSnSt : uint32_t
	{
		// <eCtrlZkAtkStat_ENTERFRAME = 0x0>
		eCtrlZkAtkStat_ENTERFRAME = 0,

		// <eCtrlZkAtkStat_ATTACKSTART = 0x1>
		eCtrlZkAtkStat_ATTACKSTART = 1,

		// <eCtrlZkAtkStat_ATTACKING = 0x2>
		eCtrlZkAtkStat_ATTACKING = 2,

		// <eCtrlZkAtkStat_END = 0x3>
		eCtrlZkAtkStat_END = 3

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_UnderCtrl_Attack::eCtrlZkAtkSnSt m_eStat, offset 0x4>
	enum State_UnderCtrl_Attack::eCtrlZkAtkSnSt m_eStat;

	/// 4 Functions

	// [Function] void __convention("thiscall") State_UnderCtrl_Attack::ChangeStateCondition(class State_UnderCtrl_Attack* const this, class PJZAKO* arg2) [?ChangeStateCondition@State_UnderCtrl_Attack@@QAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _ChangeStateCondition_State_UnderCtrl_Attack__QAEXPAVPJZAKO___Z)(class State_UnderCtrl_Attack* const thisPtr, class PJZAKO* arg2);
	void ChangeStateCondition(class PJZAKO* arg2)
	{
		_ChangeStateCondition_State_UnderCtrl_Attack__QAEXPAVPJZAKO___Z mFunc = (_ChangeStateCondition_State_UnderCtrl_Attack__QAEXPAVPJZAKO___Z)(GameModule + 0x5d7d50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_UnderCtrl_Attack::Enter(class State_UnderCtrl_Attack* const this, class PJZAKO* arg2) [?Enter@State_UnderCtrl_Attack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Enter_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z)(class State_UnderCtrl_Attack* const thisPtr, class PJZAKO* arg2);
	void Enter(class PJZAKO* arg2)
	{
		_Enter_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z mFunc = (_Enter_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z)(GameModule + 0x5dce70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_UnderCtrl_Attack::Execute(class State_UnderCtrl_Attack* const this, class PJZAKO* arg2) [?Execute@State_UnderCtrl_Attack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Execute_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z)(class State_UnderCtrl_Attack* const thisPtr, class PJZAKO* arg2);
	void Execute(class PJZAKO* arg2)
	{
		_Execute_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z mFunc = (_Execute_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z)(GameModule + 0x5dced0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") State_UnderCtrl_Attack::Exit(class State_UnderCtrl_Attack* const this, class PJZAKO* arg2) [?Exit@State_UnderCtrl_Attack@@UAEXPAVPJZAKO@@@Z]
	typedef void(__thiscall* _Exit_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z)(class State_UnderCtrl_Attack* const thisPtr, class PJZAKO* arg2);
	void Exit(class PJZAKO* arg2)
	{
		_Exit_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z mFunc = (_Exit_State_UnderCtrl_Attack__UAEXPAVPJZAKO___Z)(GameModule + 0x5dd0e0);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class State_UnderCtrl_Attack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(State_UnderCtrl_Attack& InObject)
	{
		m_eStat = InObject.m_eStat;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_UnderCtrl_Attack, PJState>("State_UnderCtrl_Attack")
			.addFunction("__tostring", &State_UnderCtrl_Attack::ToString)
			.addFunction("GetPtrAddr", &State_UnderCtrl_Attack::GetPtrAddr)
			.addProperty("m_eStat", &State_UnderCtrl_Attack::m_eStat)
			.addFunction("ChangeStateCondition", &State_UnderCtrl_Attack::ChangeStateCondition)
			.addFunction("Enter", &State_UnderCtrl_Attack::Enter)
			.addFunction("Execute", &State_UnderCtrl_Attack::Execute)
			.addFunction("Exit", &State_UnderCtrl_Attack::Exit)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_UnderCtrl_Attack::m_eStat) == 4, "expected State_UnderCtrl_Attack::m_eStat to be size 4");
static_assert(sizeof(State_UnderCtrl_Attack) == 0x8, "expected State_UnderCtrl_Attack to be size 0x8");

// [Function] void CheckSameStatePtr(class PJState* arg1, class PJZAKO* arg2) [?CheckSameStatePtr@@YAXPAVPJState@@PAVPJZAKO@@@Z]
typedef void(__fastcall* _CheckSameStatePtr__YAXPAVPJState__PAVPJZAKO___Z)(class PJState* arg1, class PJZAKO* arg2);
void CheckSameStatePtr(class PJState* arg1, class PJZAKO* arg2)
{
	_CheckSameStatePtr__YAXPAVPJState__PAVPJZAKO___Z mFunc = (_CheckSameStatePtr__YAXPAVPJState__PAVPJZAKO___Z)(GameModule + 0x5d7d70);
	return mFunc(arg1, arg2);
}
// enum FlowDirection
enum FlowDirection : uint32_t
{
	// <NAGARE_HOUKOU_UE_SITA = 0x0>
	NAGARE_HOUKOU_UE_SITA = 0,

	// <NAGARE_HOUKOU_SITA_UE = 0x1>
	NAGARE_HOUKOU_SITA_UE = 1,

	// <NAGARE_HOUKOU_HIDARI_MIGI = 0x2>
	NAGARE_HOUKOU_HIDARI_MIGI = 2,

	// <NAGARE_HOUKOU_MIGI_HIDARI = 0x3>
	NAGARE_HOUKOU_MIGI_HIDARI = 3,

	// <NAGARE_HOUKOU_HIDARI_UE = 0x4>
	NAGARE_HOUKOU_HIDARI_UE = 4,

	// <NAGARE_HOUKOU_UE_HIDARI = 0x5>
	NAGARE_HOUKOU_UE_HIDARI = 5,

	// <NAGARE_HOUKOU_MIGI_UE = 0x6>
	NAGARE_HOUKOU_MIGI_UE = 6,

	// <NAGARE_HOUKOU_UE_MIGI = 0x7>
	NAGARE_HOUKOU_UE_MIGI = 7,

	// <NAGARE_HOUKOU_HIDARI_SITA = 0x8>
	NAGARE_HOUKOU_HIDARI_SITA = 8,

	// <NAGARE_HOUKOU_SITA_HIDARI = 0x9>
	NAGARE_HOUKOU_SITA_HIDARI = 9,

	// <NAGARE_HOUKOU_MIGI_SITA = 0xa>
	NAGARE_HOUKOU_MIGI_SITA = 10,

	// <NAGARE_HOUKOU_SITA_MIGI = 0xb>
	NAGARE_HOUKOU_SITA_MIGI = 11

};

// [Structure] struct NAGASU_MASU
struct NAGASU_MASU
{
public:
	/// Struct member variables

	// <uint8_t isFlowing, offset 0x0>
	uint8_t isFlowing = 0;

	// <uint8_t isCompleted, offset 0x1>
	uint8_t isCompleted = 0;

	// <Unidentified data segment, offset 0x2>
private:
	char _UnidentifiedData_2[2];

public:
	// <enum FlowDirection flowDirection, offset 0x4>
	enum FlowDirection flowDirection;

	// <uint32_t framesFlowing, offset 0x8>
	uint32_t framesFlowing = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct NAGASU_MASU [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(NAGASU_MASU& InObject)
	{
		isFlowing = InObject.isFlowing;
		isCompleted = InObject.isCompleted;
		flowDirection = InObject.flowDirection;
		framesFlowing = InObject.framesFlowing;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NAGASU_MASU>("NAGASU_MASU")
			.addFunction("__tostring", &NAGASU_MASU::ToString)
			.addFunction("GetPtrAddr", &NAGASU_MASU::GetPtrAddr)
			.addProperty("isFlowing", &NAGASU_MASU::isFlowing)
			.addProperty("isCompleted", &NAGASU_MASU::isCompleted)
			.addProperty("flowDirection", &NAGASU_MASU::flowDirection)
			.addProperty("framesFlowing", &NAGASU_MASU::framesFlowing)
		.endClass();
	}
#endif
};
static_assert(sizeof(NAGASU_MASU::isFlowing) == 1, "expected NAGASU_MASU::isFlowing to be size 1");
static_assert(sizeof(NAGASU_MASU::isCompleted) == 1, "expected NAGASU_MASU::isCompleted to be size 1");
static_assert(sizeof(NAGASU_MASU::flowDirection) == 4, "expected NAGASU_MASU::flowDirection to be size 4");
static_assert(sizeof(NAGASU_MASU::framesFlowing) == 4, "expected NAGASU_MASU::framesFlowing to be size 4");
static_assert(sizeof(NAGASU_MASU) == 0xc, "expected NAGASU_MASU to be size 0xc");

// [Structure] struct PIPE_MASU
struct PIPE_MASU
{
public:
	/// Struct member variables

	// <int32_t pType, offset 0x0>
	int32_t pType = 0;

	// <uint8_t pRot, offset 0x4>
	uint8_t pRot = 0;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData_5[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct PIPE_MASU [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PIPE_MASU& InObject)
	{
		pType = InObject.pType;
		pRot = InObject.pRot;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PIPE_MASU>("PIPE_MASU")
			.addFunction("__tostring", &PIPE_MASU::ToString)
			.addFunction("GetPtrAddr", &PIPE_MASU::GetPtrAddr)
			.addProperty("pType", &PIPE_MASU::pType)
			.addProperty("pRot", &PIPE_MASU::pRot)
		.endClass();
	}
#endif
};
static_assert(sizeof(PIPE_MASU::pType) == 4, "expected PIPE_MASU::pType to be size 4");
static_assert(sizeof(PIPE_MASU::pRot) == 1, "expected PIPE_MASU::pRot to be size 1");
static_assert(sizeof(PIPE_MASU) == 0x8, "expected PIPE_MASU to be size 0x8");

// enum pjjmchaState
enum pjjmchaState : uint32_t
{
	// <chaNONE = 0x0>
	chaNONE = 0,

	// <chaFLIE_OPEN = 0x1>
	chaFLIE_OPEN = 1,

	// <chaFLIE_LOAD = 0x2>
	chaFLIE_LOAD = 2,

	// <chaINIT = 0x3>
	chaINIT = 3,

	// <chaACTIV = 0x4>
	chaACTIV = 4,

	// <chaTERM = 0x5>
	chaTERM = 5

};

// enum SubMode
enum SubMode : uint32_t
{
	// <First = 0x0>
	First = 0,

	// <Loop = 0x1>
	Loop = 1,

	// <Last = 0x2>
	Last = 2

};

// enum pjjmActionMode
enum pjjmActionMode : uint32_t
{
	// <IdolMode = 0x0>
	IdolMode = 0,

	// <MoveMode = 0x1>
	MoveMode = 1,

	// <AttackMode = 0x2>
	AttackMode = 2,

	// <SearchMode = 0x3>
	SearchMode = 3,

	// <GuardMode = 0x4>
	GuardMode = 4,

	// <DamageMode = 0x5>
	DamageMode = 5,

	// <RunAwayMode = 0x6>
	RunAwayMode = 6,

	// <DeadMode = 0x7>
	DeadMode = 7,

	// <DemoMode = 0x8>
	DemoMode = 8,

	// <ItemGetMode = 0x9>
	ItemGetMode = 9,

	// <ItemUseMode = 0xa>
	ItemUseMode = 10,

	// <ItemChangeMode = 0xb>
	ItemChangeMode = 11,

	// <PiyoriMode = 0xc>
	PiyoriMode = 12,

	// <WeponUseMode = 0xd>
	WeponUseMode = 13,

	// <ClearMode = 0xe>
	ClearMode = 14

};

// enum pjjmDirection
enum pjjmDirection : uint32_t
{
	// <Nouth = 0x1>
	Nouth = 1,

	// <East = 0x2>
	East = 2,

	// <South = 0x3>
	South = 3,

	// <West = 0x4>
	West = 4

};

// enum PJJMObj
enum PJJMObj : uint32_t
{
	// <chaPC = 0x0>
	chaPC = 0,

	// <chaEnemy = 0x1>
	chaEnemy = 1,

	// <chaItem = 0x2>
	chaItem = 2

};

// [Structure] struct PJJMObjStatus
struct PJJMObjStatus
{
public:
	/// Struct member variables

	// <enum PJJMObj msObj, offset 0x0>
	enum PJJMObj msObj;

	// <struct Vec msPosition, offset 0x4>
	struct Vec msPosition;

	// <struct Vec msPositionH, offset 0x10>
	struct Vec msPositionH;

	// <float msW, offset 0x1c>
	float msW = 0;

	// <float msH, offset 0x20>
	float msH = 0;

	// <enum pjjmDirection msDirection, offset 0x24>
	enum pjjmDirection msDirection;

	// <enum pjjmDirection msSubDirection, offset 0x28>
	enum pjjmDirection msSubDirection;

	// <float msHp, offset 0x2c>
	float msHp = 0;

	// <float msMp, offset 0x30>
	float msMp = 0;

	// <enum pjjmActionMode msActionMode, offset 0x34>
	enum pjjmActionMode msActionMode;

	// <enum SubMode msSubMode, offset 0x38>
	enum SubMode msSubMode;

	// <float msAnimCnt[0x2], offset 0x3c>
	float msAnimCnt[2];

	// <float msAccel, offset 0x44>
	float msAccel = 0;

	// <float msChangeAccel, offset 0x48>
	float msChangeAccel = 0;

	// <int16_t msMaxMoveAnim, offset 0x4c>
	int16_t msMaxMoveAnim = 0;

	// <Unidentified data segment, offset 0x4e>
private:
	char _UnidentifiedData_78[2];

public:
	// <float msDamage[0x3], offset 0x50>
	float msDamage[3];

	// <uint32_t msAccelSec, offset 0x5c>
	uint32_t msAccelSec = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct PJJMObjStatus [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJMObjStatus& InObject)
	{
		msObj = InObject.msObj;
		msPosition = InObject.msPosition;
		msPositionH = InObject.msPositionH;
		msW = InObject.msW;
		msH = InObject.msH;
		msDirection = InObject.msDirection;
		msSubDirection = InObject.msSubDirection;
		msHp = InObject.msHp;
		msMp = InObject.msMp;
		msActionMode = InObject.msActionMode;
		msSubMode = InObject.msSubMode;
		msAccel = InObject.msAccel;
		msChangeAccel = InObject.msChangeAccel;
		msMaxMoveAnim = InObject.msMaxMoveAnim;
		msAccelSec = InObject.msAccelSec;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJJMObjStatus>("PJJMObjStatus")
			.addFunction("__tostring", &PJJMObjStatus::ToString)
			.addFunction("GetPtrAddr", &PJJMObjStatus::GetPtrAddr)
			.addProperty("msObj", &PJJMObjStatus::msObj)
			.addProperty("msPosition", &PJJMObjStatus::msPosition)
			.addProperty("msPositionH", &PJJMObjStatus::msPositionH)
			.addProperty("msW", &PJJMObjStatus::msW)
			.addProperty("msH", &PJJMObjStatus::msH)
			.addProperty("msDirection", &PJJMObjStatus::msDirection)
			.addProperty("msSubDirection", &PJJMObjStatus::msSubDirection)
			.addProperty("msHp", &PJJMObjStatus::msHp)
			.addProperty("msMp", &PJJMObjStatus::msMp)
			.addProperty("msActionMode", &PJJMObjStatus::msActionMode)
			.addProperty("msSubMode", &PJJMObjStatus::msSubMode)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("msAnimCnt", &PJJMObjStatus::msAnimCnt)
			.addProperty("msAccel", &PJJMObjStatus::msAccel)
			.addProperty("msChangeAccel", &PJJMObjStatus::msChangeAccel)
			.addProperty("msMaxMoveAnim", &PJJMObjStatus::msMaxMoveAnim)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("msDamage", &PJJMObjStatus::msDamage)
			.addProperty("msAccelSec", &PJJMObjStatus::msAccelSec)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJMObjStatus::msObj) == 4, "expected PJJMObjStatus::msObj to be size 4");
static_assert(sizeof(PJJMObjStatus::msPosition) == 12, "expected PJJMObjStatus::msPosition to be size 12");
static_assert(sizeof(PJJMObjStatus::msPositionH) == 12, "expected PJJMObjStatus::msPositionH to be size 12");
static_assert(sizeof(PJJMObjStatus::msW) == 4, "expected PJJMObjStatus::msW to be size 4");
static_assert(sizeof(PJJMObjStatus::msH) == 4, "expected PJJMObjStatus::msH to be size 4");
static_assert(sizeof(PJJMObjStatus::msDirection) == 4, "expected PJJMObjStatus::msDirection to be size 4");
static_assert(sizeof(PJJMObjStatus::msSubDirection) == 4, "expected PJJMObjStatus::msSubDirection to be size 4");
static_assert(sizeof(PJJMObjStatus::msHp) == 4, "expected PJJMObjStatus::msHp to be size 4");
static_assert(sizeof(PJJMObjStatus::msMp) == 4, "expected PJJMObjStatus::msMp to be size 4");
static_assert(sizeof(PJJMObjStatus::msActionMode) == 4, "expected PJJMObjStatus::msActionMode to be size 4");
static_assert(sizeof(PJJMObjStatus::msSubMode) == 4, "expected PJJMObjStatus::msSubMode to be size 4");
static_assert(sizeof(PJJMObjStatus::msAnimCnt) == 8, "expected PJJMObjStatus::msAnimCnt to be size 8");
static_assert(sizeof(PJJMObjStatus::msAccel) == 4, "expected PJJMObjStatus::msAccel to be size 4");
static_assert(sizeof(PJJMObjStatus::msChangeAccel) == 4, "expected PJJMObjStatus::msChangeAccel to be size 4");
static_assert(sizeof(PJJMObjStatus::msMaxMoveAnim) == 2, "expected PJJMObjStatus::msMaxMoveAnim to be size 2");
static_assert(sizeof(PJJMObjStatus::msDamage) == 12, "expected PJJMObjStatus::msDamage to be size 12");
static_assert(sizeof(PJJMObjStatus::msAccelSec) == 4, "expected PJJMObjStatus::msAccelSec to be size 4");
static_assert(sizeof(PJJMObjStatus) == 0x60, "expected PJJMObjStatus to be size 0x60");

// [Structure] class PJJMChar
class PJJMChar : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct PJJMObjStatus mStatus, offset 0x10>
	struct PJJMObjStatus mStatus;

	// <enum pjjmchaState mStat, offset 0x70>
	enum pjjmchaState mStat;

	// <struct tagGHMR_TEX mCharTex, offset 0x74>
	struct tagGHMR_TEX mCharTex;

	// <float mHScale, offset 0x9c>
	float mHScale = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJJMChar [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJMChar& InObject)
	{
		mStatus = InObject.mStatus;
		mStat = InObject.mStat;
		mCharTex = InObject.mCharTex;
		mHScale = InObject.mHScale;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJJMChar, ghmListObj>("PJJMChar")
			.addFunction("__tostring", &PJJMChar::ToString)
			.addFunction("GetPtrAddr", &PJJMChar::GetPtrAddr)
			.addProperty("mStatus", &PJJMChar::mStatus)
			.addProperty("mStat", &PJJMChar::mStat)
			.addProperty("mCharTex", &PJJMChar::mCharTex)
			.addProperty("mHScale", &PJJMChar::mHScale)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJMChar::mStatus) == 96, "expected PJJMChar::mStatus to be size 96");
static_assert(sizeof(PJJMChar::mStat) == 4, "expected PJJMChar::mStat to be size 4");
static_assert(sizeof(PJJMChar::mCharTex) == 40, "expected PJJMChar::mCharTex to be size 40");
static_assert(sizeof(PJJMChar::mHScale) == 4, "expected PJJMChar::mHScale to be size 4");
static_assert(sizeof(PJJMChar) == 0xa0, "expected PJJMChar to be size 0xa0");

// [Structure] class PJJMPlumberItem
class PJJMPlumberItem : public PJJMChar
{
public:
	/// Struct member variables

	// <class PJJMChar field_0, offset 0x0>
	// class PJJMChar Super;

	// <uint8_t mSelect, offset 0xa0>
	uint8_t mSelect = 0;

	// <Unidentified data segment, offset 0xa1>
private:
	char _UnidentifiedData_161[3];

public:
	// <struct PIPE_MASU mInfo, offset 0xa4>
	struct PIPE_MASU mInfo;

	// <uint8_t mEvtflg, offset 0xac>
	uint8_t mEvtflg = 0;

	// <uint8_t mExPipeNo, offset 0xad>
	uint8_t mExPipeNo = 0;

	// <Unidentified data segment, offset 0xae>
private:
	char _UnidentifiedData_174[2];

public:
	// <struct NAGASU_MASU mNagasu, offset 0xb0>
	struct NAGASU_MASU mNagasu;

	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") PJJMPlumberItem::ItemInit(class PJJMPlumberItem* const this, int16_t arg2, int16_t arg3, int16_t arg4, uint8_t arg5, uint8_t arg6, uint8_t arg7, class ghmResGroup* arg8) [?ItemInit@PJJMPlumberItem@@QAE_NFFFEEEPAVghmResGroup@@@Z]
	typedef uint8_t(__thiscall* _ItemInit_PJJMPlumberItem__QAE_NFFFEEEPAVghmResGroup___Z)(class PJJMPlumberItem* const thisPtr, int16_t arg2, int16_t arg3, int16_t arg4, uint8_t arg5, uint8_t arg6, uint8_t arg7, class ghmResGroup* arg8);
	uint8_t ItemInit(int16_t arg2, int16_t arg3, int16_t arg4, uint8_t arg5, uint8_t arg6, uint8_t arg7, class ghmResGroup* arg8)
	{
		_ItemInit_PJJMPlumberItem__QAE_NFFFEEEPAVghmResGroup___Z mFunc = (_ItemInit_PJJMPlumberItem__QAE_NFFFEEEPAVghmResGroup___Z)(GameModule + 0x5edb70);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJJMPlumberItem [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJMPlumberItem& InObject)
	{
		mSelect = InObject.mSelect;
		mInfo = InObject.mInfo;
		mEvtflg = InObject.mEvtflg;
		mExPipeNo = InObject.mExPipeNo;
		mNagasu = InObject.mNagasu;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJJMPlumberItem, PJJMChar>("PJJMPlumberItem")
			.addFunction("__tostring", &PJJMPlumberItem::ToString)
			.addFunction("GetPtrAddr", &PJJMPlumberItem::GetPtrAddr)
			.addProperty("mSelect", &PJJMPlumberItem::mSelect)
			.addProperty("mInfo", &PJJMPlumberItem::mInfo)
			.addProperty("mEvtflg", &PJJMPlumberItem::mEvtflg)
			.addProperty("mExPipeNo", &PJJMPlumberItem::mExPipeNo)
			.addProperty("mNagasu", &PJJMPlumberItem::mNagasu)
			.addFunction("ItemInit", &PJJMPlumberItem::ItemInit)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJMPlumberItem::mSelect) == 1, "expected PJJMPlumberItem::mSelect to be size 1");
static_assert(sizeof(PJJMPlumberItem::mInfo) == 8, "expected PJJMPlumberItem::mInfo to be size 8");
static_assert(sizeof(PJJMPlumberItem::mEvtflg) == 1, "expected PJJMPlumberItem::mEvtflg to be size 1");
static_assert(sizeof(PJJMPlumberItem::mExPipeNo) == 1, "expected PJJMPlumberItem::mExPipeNo to be size 1");
static_assert(sizeof(PJJMPlumberItem::mNagasu) == 12, "expected PJJMPlumberItem::mNagasu to be size 12");
static_assert(sizeof(PJJMPlumberItem) == 0xbc, "expected PJJMPlumberItem to be size 0xbc");

// [Structure] class PJJMPlumberPc
class PJJMPlumberPc : public PJJMChar
{
public:
	/// Struct member variables

	// <class PJJMChar field_0, offset 0x0>
	// class PJJMChar Super;

	// <uint8_t mSelect, offset 0xa0>
	uint8_t mSelect = 0;

	// <Unidentified data segment, offset 0xa1>
private:
	char _UnidentifiedData_161[3];

public:
	// <int32_t mChangeCnt, offset 0xa4>
	int32_t mChangeCnt = 0;

	// <struct tagGHMR_TEX mSelectTex, offset 0xa8>
	struct tagGHMR_TEX mSelectTex;

	// <struct tagGHMR_TEX mCarryTex, offset 0xd0>
	struct tagGHMR_TEX mCarryTex;

	// <uint8_t mStartMode, offset 0xf8>
	uint8_t mStartMode = 0;

	// <Unidentified data segment, offset 0xf9>
private:
	char _UnidentifiedData_249[3];

public:
	// <void* mpGetPipe, offset 0xfc>
	void* mpGetPipe = nullptr;

	// <uint8_t mPipeRotFlag, offset 0x100>
	uint8_t mPipeRotFlag = 0;

	// <Unidentified data segment, offset 0x101>
private:
	char _UnidentifiedData_257[3];

public:
	// <enum SubMode mPipeRotSubMode, offset 0x104>
	enum SubMode mPipeRotSubMode;

	// <int32_t mPcMoveDir, offset 0x108>
	int32_t mPcMoveDir = 0;

	// <uint8_t mPcDir_N, offset 0x10c>
	uint8_t mPcDir_N = 0;

	// <uint8_t mPcDir_E, offset 0x10d>
	uint8_t mPcDir_E = 0;

	// <uint8_t mPcDir_W, offset 0x10e>
	uint8_t mPcDir_W = 0;

	// <uint8_t mPcDir_S, offset 0x10f>
	uint8_t mPcDir_S = 0;

	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") PJJMPlumberPc::JMPF_PcInit(class PJJMPlumberPc* const this, int16_t arg2, int16_t arg3, class ghmResGroup* arg4) [?JMPF_PcInit@PJJMPlumberPc@@QAE_NFFPAVghmResGroup@@@Z]
	typedef uint8_t(__thiscall* _JMPF_PcInit_PJJMPlumberPc__QAE_NFFPAVghmResGroup___Z)(class PJJMPlumberPc* const thisPtr, int16_t arg2, int16_t arg3, class ghmResGroup* arg4);
	uint8_t JMPF_PcInit(int16_t arg2, int16_t arg3, class ghmResGroup* arg4)
	{
		_JMPF_PcInit_PJJMPlumberPc__QAE_NFFPAVghmResGroup___Z mFunc = (_JMPF_PcInit_PJJMPlumberPc__QAE_NFFPAVghmResGroup___Z)(GameModule + 0x5eed70);
		return mFunc(this, arg2, arg3, arg4);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJJMPlumberPc [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJMPlumberPc& InObject)
	{
		mSelect = InObject.mSelect;
		mChangeCnt = InObject.mChangeCnt;
		mSelectTex = InObject.mSelectTex;
		mCarryTex = InObject.mCarryTex;
		mStartMode = InObject.mStartMode;
		mpGetPipe = InObject.mpGetPipe;
		mPipeRotFlag = InObject.mPipeRotFlag;
		mPipeRotSubMode = InObject.mPipeRotSubMode;
		mPcMoveDir = InObject.mPcMoveDir;
		mPcDir_N = InObject.mPcDir_N;
		mPcDir_E = InObject.mPcDir_E;
		mPcDir_W = InObject.mPcDir_W;
		mPcDir_S = InObject.mPcDir_S;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJJMPlumberPc, PJJMChar>("PJJMPlumberPc")
			.addFunction("__tostring", &PJJMPlumberPc::ToString)
			.addFunction("GetPtrAddr", &PJJMPlumberPc::GetPtrAddr)
			.addProperty("mSelect", &PJJMPlumberPc::mSelect)
			.addProperty("mChangeCnt", &PJJMPlumberPc::mChangeCnt)
			.addProperty("mSelectTex", &PJJMPlumberPc::mSelectTex)
			.addProperty("mCarryTex", &PJJMPlumberPc::mCarryTex)
			.addProperty("mStartMode", &PJJMPlumberPc::mStartMode)
			// void type not supported in LuaBridge
			//.addProperty("mpGetPipe", &PJJMPlumberPc::mpGetPipe)
			.addProperty("mPipeRotFlag", &PJJMPlumberPc::mPipeRotFlag)
			.addProperty("mPipeRotSubMode", &PJJMPlumberPc::mPipeRotSubMode)
			.addProperty("mPcMoveDir", &PJJMPlumberPc::mPcMoveDir)
			.addProperty("mPcDir_N", &PJJMPlumberPc::mPcDir_N)
			.addProperty("mPcDir_E", &PJJMPlumberPc::mPcDir_E)
			.addProperty("mPcDir_W", &PJJMPlumberPc::mPcDir_W)
			.addProperty("mPcDir_S", &PJJMPlumberPc::mPcDir_S)
			.addFunction("JMPF_PcInit", &PJJMPlumberPc::JMPF_PcInit)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJMPlumberPc::mSelect) == 1, "expected PJJMPlumberPc::mSelect to be size 1");
static_assert(sizeof(PJJMPlumberPc::mChangeCnt) == 4, "expected PJJMPlumberPc::mChangeCnt to be size 4");
static_assert(sizeof(PJJMPlumberPc::mSelectTex) == 40, "expected PJJMPlumberPc::mSelectTex to be size 40");
static_assert(sizeof(PJJMPlumberPc::mCarryTex) == 40, "expected PJJMPlumberPc::mCarryTex to be size 40");
static_assert(sizeof(PJJMPlumberPc::mStartMode) == 1, "expected PJJMPlumberPc::mStartMode to be size 1");
static_assert(sizeof(PJJMPlumberPc::mpGetPipe) == 4, "expected PJJMPlumberPc::mpGetPipe to be size 4");
static_assert(sizeof(PJJMPlumberPc::mPipeRotFlag) == 1, "expected PJJMPlumberPc::mPipeRotFlag to be size 1");
static_assert(sizeof(PJJMPlumberPc::mPipeRotSubMode) == 4, "expected PJJMPlumberPc::mPipeRotSubMode to be size 4");
static_assert(sizeof(PJJMPlumberPc::mPcMoveDir) == 4, "expected PJJMPlumberPc::mPcMoveDir to be size 4");
static_assert(sizeof(PJJMPlumberPc::mPcDir_N) == 1, "expected PJJMPlumberPc::mPcDir_N to be size 1");
static_assert(sizeof(PJJMPlumberPc::mPcDir_E) == 1, "expected PJJMPlumberPc::mPcDir_E to be size 1");
static_assert(sizeof(PJJMPlumberPc::mPcDir_W) == 1, "expected PJJMPlumberPc::mPcDir_W to be size 1");
static_assert(sizeof(PJJMPlumberPc::mPcDir_S) == 1, "expected PJJMPlumberPc::mPcDir_S to be size 1");
static_assert(sizeof(PJJMPlumberPc) == 0x110, "expected PJJMPlumberPc to be size 0x110");

// [Structure] class SideMissionBase
class SideMissionBase
{
public:
	// enum SideMissionBase::GameState
	enum GameState : uint32_t
	{
		// <GameState_Init = 0x0>
		GameState_Init = 0,

		// <GameState_Ready = 0x1>
		GameState_Ready = 1,

		// <GameState_InGame = 0x2>
		GameState_InGame = 2,

		// <GameState_Failed = 0x3>
		GameState_Failed = 3,

		// <GameState_TimeOver = 0x4>
		GameState_TimeOver = 4,

		// <GameState_Result = 0x5>
		GameState_Result = 5,

		// <GameState_Term = 0x6>
		GameState_Term = 6

	};

	/// Struct member variables

	// <void* (* field_0)[0x8], offset 0x0>
	void* (* field_0)[0x8];

	// <enum SideMissionBase::GameState mGameState, offset 0x4>
	enum SideMissionBase::GameState mGameState;

	// <class ghmResGroup* mpResLink, offset 0x8>
	class ghmResGroup* mpResLink = nullptr;

	// <int32_t mhBGM, offset 0xc>
	int32_t mhBGM = 0;

	/// 1 Functions

	// [Function] class ghmResGroup* __convention("thiscall") SideMissionBase::GetMissionData(class SideMissionBase* const this) [?GetMissionData@SideMissionBase@@QAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _GetMissionData_SideMissionBase__QAEPAVghmResGroup__XZ)(class SideMissionBase* const thisPtr);
	class ghmResGroup* GetMissionData()
	{
		_GetMissionData_SideMissionBase__QAEPAVghmResGroup__XZ mFunc = (_GetMissionData_SideMissionBase__QAEPAVghmResGroup__XZ)(GameModule + 0x612ce0);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class SideMissionBase [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(SideMissionBase& InObject)
	{
		mGameState = InObject.mGameState;
		mpResLink = InObject.mpResLink;
		mhBGM = InObject.mhBGM;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SideMissionBase>("SideMissionBase")
			.addFunction("__tostring", &SideMissionBase::ToString)
			.addFunction("GetPtrAddr", &SideMissionBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &SideMissionBase::field_0)
			.addProperty("mGameState", &SideMissionBase::mGameState)
			.addProperty("mpResLink", &SideMissionBase::mpResLink)
			.addProperty("mhBGM", &SideMissionBase::mhBGM)
			.addFunction("GetMissionData", &SideMissionBase::GetMissionData)
		.endClass();
	}
#endif
};
static_assert(sizeof(SideMissionBase::field_0) == 4, "expected SideMissionBase::field_0 to be size 4");
static_assert(sizeof(SideMissionBase::mGameState) == 4, "expected SideMissionBase::mGameState to be size 4");
static_assert(sizeof(SideMissionBase::mpResLink) == 4, "expected SideMissionBase::mpResLink to be size 4");
static_assert(sizeof(SideMissionBase::mhBGM) == 4, "expected SideMissionBase::mhBGM to be size 4");
static_assert(sizeof(SideMissionBase) == 0x10, "expected SideMissionBase to be size 0x10");

// [Structure] class EffectWaveBlow
class EffectWaveBlow : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag = 0;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData_81[3];

public:
	// <class ghmResGroup* m_pResGroup, offset 0x54>
	class ghmResGroup* m_pResGroup = nullptr;

	// <class TGmf* m_pGmf, offset 0x58>
	class TGmf* m_pGmf = nullptr;

	// <class TGan* m_pGan, offset 0x5c>
	class TGan* m_pGan = nullptr;

	// <struct Vec m_CenterVec, offset 0x60>
	struct Vec m_CenterVec;

	// <struct Vec m_BefPos, offset 0x6c>
	struct Vec m_BefPos;

	// <struct Vec m_MoveVec, offset 0x78>
	struct Vec m_MoveVec;

	// <float m_TimeCount, offset 0x84>
	float m_TimeCount = 0;

	// <int32_t m_TimeFrame, offset 0x88>
	int32_t m_TimeFrame = 0;

	// <float m_TimeRate, offset 0x8c>
	float m_TimeRate = 0;

	// <float m_Speed, offset 0x90>
	float m_Speed = 0;

	// <float m_Accel, offset 0x94>
	float m_Accel = 0;

	// <uint8_t m_CollHit, offset 0x98>
	uint8_t m_CollHit = 0;

	// <uint8_t m_DemoBit, offset 0x99>
	uint8_t m_DemoBit = 0;

	// <Unidentified data segment, offset 0x9a>
private:
	char _UnidentifiedData_154[2];

public:
	// <struct Vec* m_pLocatorPos, offset 0x9c>
	struct Vec* m_pLocatorPos = nullptr;

	// <struct Vec* m_pLocatorDir, offset 0xa0>
	struct Vec* m_pLocatorDir = nullptr;

	// <class ghmGcCollObjSphere m_HitSphere, offset 0xa4>
	class ghmGcCollObjSphere m_HitSphere;

	/// 3 Functions

	// [Function] uint8_t __convention("thiscall") EffectWaveBlow::Initialize(class EffectWaveBlow* const this, class ghmResGroup* arg2, uint8_t arg3, int32_t arg4) [?Initialize@EffectWaveBlow@@AAE_NPAVghmResGroup@@_NH@Z]
	typedef uint8_t(__thiscall* _Initialize_EffectWaveBlow__AAE_NPAVghmResGroup___NH_Z)(class EffectWaveBlow* const thisPtr, class ghmResGroup* arg2, uint8_t arg3, int32_t arg4);
	uint8_t Initialize(class ghmResGroup* arg2, uint8_t arg3, int32_t arg4)
	{
		_Initialize_EffectWaveBlow__AAE_NPAVghmResGroup___NH_Z mFunc = (_Initialize_EffectWaveBlow__AAE_NPAVghmResGroup___NH_Z)(GameModule + 0x6177c0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class EffectWaveBlow* EffectWaveBlow::DemoCreate(struct Vec* arg1, struct Vec* arg2, class ghmResGroup* arg3) [?DemoCreate@EffectWaveBlow@@SAPAV1@PAUVec@@0PAVghmResGroup@@@Z]
	typedef class EffectWaveBlow*(__fastcall* _DemoCreate_EffectWaveBlow__SAPAV1_PAUVec__0PAVghmResGroup___Z)(struct Vec* arg1, struct Vec* arg2, class ghmResGroup* arg3);
	static class EffectWaveBlow* DemoCreate(struct Vec* arg1, struct Vec* arg2, class ghmResGroup* arg3)
	{
		_DemoCreate_EffectWaveBlow__SAPAV1_PAUVec__0PAVghmResGroup___Z mFunc = (_DemoCreate_EffectWaveBlow__SAPAV1_PAUVec__0PAVghmResGroup___Z)(GameModule + 0x617980);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] class EffectWaveBlow* EffectWaveBlow::Create(struct Vec& arg1, float arg2, float arg3, float arg4, class ghmResGroup* arg5, uint8_t arg6, int32_t arg7) [?Create@EffectWaveBlow@@SAPAV1@ABUVec@@MMMPAVghmResGroup@@_NH@Z]
	typedef class EffectWaveBlow*(__fastcall* _Create_EffectWaveBlow__SAPAV1_ABUVec__MMMPAVghmResGroup___NH_Z)(struct Vec& arg1, float arg2, float arg3, float arg4, class ghmResGroup* arg5, uint8_t arg6, int32_t arg7);
	static class EffectWaveBlow* Create(struct Vec& arg1, float arg2, float arg3, float arg4, class ghmResGroup* arg5, uint8_t arg6, int32_t arg7)
	{
		_Create_EffectWaveBlow__SAPAV1_ABUVec__MMMPAVghmResGroup___NH_Z mFunc = (_Create_EffectWaveBlow__SAPAV1_ABUVec__MMMPAVghmResGroup___NH_Z)(GameModule + 0x617aa0);
		return mFunc(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectWaveBlow [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectWaveBlow& InObject)
	{
		m_Flag = InObject.m_Flag;
		m_pResGroup = InObject.m_pResGroup;
		m_pGmf = InObject.m_pGmf;
		m_pGan = InObject.m_pGan;
		m_CenterVec = InObject.m_CenterVec;
		m_BefPos = InObject.m_BefPos;
		m_MoveVec = InObject.m_MoveVec;
		m_TimeCount = InObject.m_TimeCount;
		m_TimeFrame = InObject.m_TimeFrame;
		m_TimeRate = InObject.m_TimeRate;
		m_Speed = InObject.m_Speed;
		m_Accel = InObject.m_Accel;
		m_CollHit = InObject.m_CollHit;
		m_DemoBit = InObject.m_DemoBit;
		m_pLocatorPos = InObject.m_pLocatorPos;
		m_pLocatorDir = InObject.m_pLocatorDir;
		m_HitSphere = InObject.m_HitSphere;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectWaveBlow, HrTask>("EffectWaveBlow")
			.addFunction("__tostring", &EffectWaveBlow::ToString)
			.addFunction("GetPtrAddr", &EffectWaveBlow::GetPtrAddr)
			.addProperty("m_Flag", &EffectWaveBlow::m_Flag)
			.addProperty("m_pResGroup", &EffectWaveBlow::m_pResGroup)
			.addProperty("m_pGmf", &EffectWaveBlow::m_pGmf)
			.addProperty("m_pGan", &EffectWaveBlow::m_pGan)
			.addProperty("m_CenterVec", &EffectWaveBlow::m_CenterVec)
			.addProperty("m_BefPos", &EffectWaveBlow::m_BefPos)
			.addProperty("m_MoveVec", &EffectWaveBlow::m_MoveVec)
			.addProperty("m_TimeCount", &EffectWaveBlow::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectWaveBlow::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectWaveBlow::m_TimeRate)
			.addProperty("m_Speed", &EffectWaveBlow::m_Speed)
			.addProperty("m_Accel", &EffectWaveBlow::m_Accel)
			.addProperty("m_CollHit", &EffectWaveBlow::m_CollHit)
			.addProperty("m_DemoBit", &EffectWaveBlow::m_DemoBit)
			.addProperty("m_pLocatorPos", &EffectWaveBlow::m_pLocatorPos)
			.addProperty("m_pLocatorDir", &EffectWaveBlow::m_pLocatorDir)
			.addProperty("m_HitSphere", &EffectWaveBlow::m_HitSphere)
			.addFunction("Initialize", &EffectWaveBlow::Initialize)
			.addStaticFunction("DemoCreate", &EffectWaveBlow::DemoCreate)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectWaveBlow::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectWaveBlow::m_Flag) == 1, "expected EffectWaveBlow::m_Flag to be size 1");
static_assert(sizeof(EffectWaveBlow::m_pResGroup) == 4, "expected EffectWaveBlow::m_pResGroup to be size 4");
static_assert(sizeof(EffectWaveBlow::m_pGmf) == 4, "expected EffectWaveBlow::m_pGmf to be size 4");
static_assert(sizeof(EffectWaveBlow::m_pGan) == 4, "expected EffectWaveBlow::m_pGan to be size 4");
static_assert(sizeof(EffectWaveBlow::m_CenterVec) == 12, "expected EffectWaveBlow::m_CenterVec to be size 12");
static_assert(sizeof(EffectWaveBlow::m_BefPos) == 12, "expected EffectWaveBlow::m_BefPos to be size 12");
static_assert(sizeof(EffectWaveBlow::m_MoveVec) == 12, "expected EffectWaveBlow::m_MoveVec to be size 12");
static_assert(sizeof(EffectWaveBlow::m_TimeCount) == 4, "expected EffectWaveBlow::m_TimeCount to be size 4");
static_assert(sizeof(EffectWaveBlow::m_TimeFrame) == 4, "expected EffectWaveBlow::m_TimeFrame to be size 4");
static_assert(sizeof(EffectWaveBlow::m_TimeRate) == 4, "expected EffectWaveBlow::m_TimeRate to be size 4");
static_assert(sizeof(EffectWaveBlow::m_Speed) == 4, "expected EffectWaveBlow::m_Speed to be size 4");
static_assert(sizeof(EffectWaveBlow::m_Accel) == 4, "expected EffectWaveBlow::m_Accel to be size 4");
static_assert(sizeof(EffectWaveBlow::m_CollHit) == 1, "expected EffectWaveBlow::m_CollHit to be size 1");
static_assert(sizeof(EffectWaveBlow::m_DemoBit) == 1, "expected EffectWaveBlow::m_DemoBit to be size 1");
static_assert(sizeof(EffectWaveBlow::m_pLocatorPos) == 4, "expected EffectWaveBlow::m_pLocatorPos to be size 4");
static_assert(sizeof(EffectWaveBlow::m_pLocatorDir) == 4, "expected EffectWaveBlow::m_pLocatorDir to be size 4");
static_assert(sizeof(EffectWaveBlow::m_HitSphere) == 80, "expected EffectWaveBlow::m_HitSphere to be size 80");
static_assert(sizeof(EffectWaveBlow) == 0xf4, "expected EffectWaveBlow to be size 0xf4");

// [Structure] class EffectPop
class EffectPop
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[3424];

public:
	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") EffectPop::Initialize(class EffectPop* const this, class ghmResGroup* arg2) [?Initialize@EffectPop@@AAE_NPAVghmResGroup@@@Z]
	typedef uint8_t(__thiscall* _Initialize_EffectPop__AAE_NPAVghmResGroup___Z)(class EffectPop* const thisPtr, class ghmResGroup* arg2);
	uint8_t Initialize(class ghmResGroup* arg2)
	{
		_Initialize_EffectPop__AAE_NPAVghmResGroup___Z mFunc = (_Initialize_EffectPop__AAE_NPAVghmResGroup___Z)(GameModule + 0x61a0b0);
		return mFunc(this, arg2);
	}
	// [Function] class EffectPop* EffectPop::Create(struct Vec& arg1, struct GXColor arg2, float arg3, uint8_t arg4, class ghmResGroup* arg5) [?Create@EffectPop@@SAPAV1@ABUVec@@UGXColor@@M_NPAVghmResGroup@@@Z]
	typedef class EffectPop*(__fastcall* _Create_EffectPop__SAPAV1_ABUVec__UGXColor__M_NPAVghmResGroup___Z)(struct Vec& arg1, struct GXColor arg2, float arg3, uint8_t arg4, class ghmResGroup* arg5);
	static class EffectPop* Create(struct Vec& arg1, struct GXColor arg2, float arg3, uint8_t arg4, class ghmResGroup* arg5)
	{
		_Create_EffectPop__SAPAV1_ABUVec__UGXColor__M_NPAVghmResGroup___Z mFunc = (_Create_EffectPop__SAPAV1_ABUVec__UGXColor__M_NPAVghmResGroup___Z)(GameModule + 0x61a2f0);
		return mFunc(arg1, arg2, arg3, arg4, arg5);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectPop [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectPop& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectPop>("EffectPop")
			.addFunction("__tostring", &EffectPop::ToString)
			.addFunction("GetPtrAddr", &EffectPop::GetPtrAddr)
			.addFunction("Initialize", &EffectPop::Initialize)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectPop::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectPop) == 0xd60, "expected EffectPop to be size 0xd60");

// [Structure] class EffectMuzzle
class EffectMuzzle
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[756];

public:
	/// 2 Functions

	// [Function] uint8_t __convention("thiscall") EffectMuzzle::Initialize(class EffectMuzzle* const this, class ghmResGroup* arg2) [?Initialize@EffectMuzzle@@AAE_NPAVghmResGroup@@@Z]
	typedef uint8_t(__thiscall* _Initialize_EffectMuzzle__AAE_NPAVghmResGroup___Z)(class EffectMuzzle* const thisPtr, class ghmResGroup* arg2);
	uint8_t Initialize(class ghmResGroup* arg2)
	{
		_Initialize_EffectMuzzle__AAE_NPAVghmResGroup___Z mFunc = (_Initialize_EffectMuzzle__AAE_NPAVghmResGroup___Z)(GameModule + 0x61b130);
		return mFunc(this, arg2);
	}
	// [Function] class EffectMuzzle* EffectMuzzle::Create(struct Vec& arg1, float arg2, class ghmResGroup* arg3) [?Create@EffectMuzzle@@SAPAV1@ABUVec@@MPAVghmResGroup@@@Z]
	typedef class EffectMuzzle*(__fastcall* _Create_EffectMuzzle__SAPAV1_ABUVec__MPAVghmResGroup___Z)(struct Vec& arg1, float arg2, class ghmResGroup* arg3);
	static class EffectMuzzle* Create(struct Vec& arg1, float arg2, class ghmResGroup* arg3)
	{
		_Create_EffectMuzzle__SAPAV1_ABUVec__MPAVghmResGroup___Z mFunc = (_Create_EffectMuzzle__SAPAV1_ABUVec__MPAVghmResGroup___Z)(GameModule + 0x61b2c0);
		return mFunc(arg1, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectMuzzle [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectMuzzle& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectMuzzle>("EffectMuzzle")
			.addFunction("__tostring", &EffectMuzzle::ToString)
			.addFunction("GetPtrAddr", &EffectMuzzle::GetPtrAddr)
			.addFunction("Initialize", &EffectMuzzle::Initialize)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectMuzzle::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectMuzzle) == 0x2f4, "expected EffectMuzzle to be size 0x2f4");

// [Structure] class EffectSlashHit
class EffectSlashHit : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct Vec m_SlashVec, offset 0x50>
	struct Vec m_SlashVec;

	// <struct Vec m_SlashPlnNrm, offset 0x5c>
	struct Vec m_SlashPlnNrm;

	// <class mHRChara* m_pChara, offset 0x68>
	class mHRChara* m_pChara = nullptr;

	// <struct Vec m_Pos, offset 0x6c>
	struct Vec m_Pos;

	// <enum eEfDmgLevel m_eDamageLevel, offset 0x78>
	enum eEfDmgLevel m_eDamageLevel;

	// <uint32_t m_nColor, offset 0x7c>
	uint32_t m_nColor = 0;

	// <int32_t m_nCounter, offset 0x80>
	int32_t m_nCounter = 0;

	// <float m_fScale, offset 0x84>
	float m_fScale = 0;

	/// 1 Functions

	// [Function] class EffectSlashHit* EffectSlashHit::Create(struct Vec& arg1, struct Vec& arg2, class mHRChara* arg3, float const arg4) [?Create@EffectSlashHit@@SAPAV1@ABUVec@@0PBVmHRChara@@M@Z]
	typedef class EffectSlashHit*(__fastcall* _Create_EffectSlashHit__SAPAV1_ABUVec__0PBVmHRChara__M_Z)(struct Vec& arg1, struct Vec& arg2, class mHRChara* arg3, float const arg4);
	static class EffectSlashHit* Create(struct Vec& arg1, struct Vec& arg2, class mHRChara* arg3, float const arg4)
	{
		_Create_EffectSlashHit__SAPAV1_ABUVec__0PBVmHRChara__M_Z mFunc = (_Create_EffectSlashHit__SAPAV1_ABUVec__0PBVmHRChara__M_Z)(GameModule + 0x61f210);
		return mFunc(arg1, arg2, arg3, arg4);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectSlashHit [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectSlashHit& InObject)
	{
		m_SlashVec = InObject.m_SlashVec;
		m_SlashPlnNrm = InObject.m_SlashPlnNrm;
		m_pChara = InObject.m_pChara;
		m_Pos = InObject.m_Pos;
		m_eDamageLevel = InObject.m_eDamageLevel;
		m_nColor = InObject.m_nColor;
		m_nCounter = InObject.m_nCounter;
		m_fScale = InObject.m_fScale;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSlashHit, HrTask>("EffectSlashHit")
			.addFunction("__tostring", &EffectSlashHit::ToString)
			.addFunction("GetPtrAddr", &EffectSlashHit::GetPtrAddr)
			.addProperty("m_SlashVec", &EffectSlashHit::m_SlashVec)
			.addProperty("m_SlashPlnNrm", &EffectSlashHit::m_SlashPlnNrm)
			.addProperty("m_pChara", &EffectSlashHit::m_pChara)
			.addProperty("m_Pos", &EffectSlashHit::m_Pos)
			.addProperty("m_eDamageLevel", &EffectSlashHit::m_eDamageLevel)
			.addProperty("m_nColor", &EffectSlashHit::m_nColor)
			.addProperty("m_nCounter", &EffectSlashHit::m_nCounter)
			.addProperty("m_fScale", &EffectSlashHit::m_fScale)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectSlashHit::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSlashHit::m_SlashVec) == 12, "expected EffectSlashHit::m_SlashVec to be size 12");
static_assert(sizeof(EffectSlashHit::m_SlashPlnNrm) == 12, "expected EffectSlashHit::m_SlashPlnNrm to be size 12");
static_assert(sizeof(EffectSlashHit::m_pChara) == 4, "expected EffectSlashHit::m_pChara to be size 4");
static_assert(sizeof(EffectSlashHit::m_Pos) == 12, "expected EffectSlashHit::m_Pos to be size 12");
static_assert(sizeof(EffectSlashHit::m_eDamageLevel) == 4, "expected EffectSlashHit::m_eDamageLevel to be size 4");
static_assert(sizeof(EffectSlashHit::m_nColor) == 4, "expected EffectSlashHit::m_nColor to be size 4");
static_assert(sizeof(EffectSlashHit::m_nCounter) == 4, "expected EffectSlashHit::m_nCounter to be size 4");
static_assert(sizeof(EffectSlashHit::m_fScale) == 4, "expected EffectSlashHit::m_fScale to be size 4");
static_assert(sizeof(EffectSlashHit) == 0x88, "expected EffectSlashHit to be size 0x88");

// Unsupported constructor
//void __convention("thiscall") PJZAKOBoneA::PJZAKOBoneA(class PJZAKOBoneA* const this)
// Unsupported destructor
//void __convention("thiscall") PJZAKOBoneA::~PJZAKOBoneA(class PJZAKOBoneA* const this)
// [Function] void __convention("thiscall") j_sub_8dcfa0(class PJZAKOBoneA* const this) [j_sub_8dcfa0]
typedef void(__thiscall* _j_sub_8dcfa0_2)(class PJZAKOBoneA* const thisPtr);
void j_sub_8dcfa0_2(class PJZAKOBoneA* const thisPtr)
{
	_j_sub_8dcfa0_2 mFunc = (_j_sub_8dcfa0_2)(GameModule + 0x6237c0);
	return mFunc(thisPtr);
}
// Unsupported constructor
//void __convention("thiscall") PJZAKOBoneB::PJZAKOBoneB(class PJZAKOBoneB* const this)
// Unsupported destructor
//void __convention("thiscall") PJZAKOBoneB::~PJZAKOBoneB(class PJZAKOBoneB* const this)
// Unsupported constructor
//void __convention("thiscall") PJZAKOBoneC::PJZAKOBoneC(class PJZAKOBoneC* const this)
// Unsupported destructor
//void __convention("thiscall") PJZAKOBoneC::~PJZAKOBoneC(class PJZAKOBoneC* const this)
// Unsupported constructor
//void __convention("thiscall") PJZAKOBoneD::PJZAKOBoneD(class PJZAKOBoneD* const this)
// Unsupported destructor
//void __convention("thiscall") PJZAKOBoneD::~PJZAKOBoneD(class PJZAKOBoneD* const this)
// [Structure] class FkBoss
class FkBoss : public bsBasic
{
public:
	// [Structure] struct FkBoss::GuardParam
	struct GuardParam
	{
	public:
		/// Struct member variables

		// <int32_t GuardBeginCnt, offset 0x0>
		int32_t GuardBeginCnt = 0;

		// <int32_t GuardContinueCnt, offset 0x4>
		int32_t GuardContinueCnt = 0;

		/// 0 Functions

		/// Meta

		std::string ToString() const { std::stringstream stream; stream << "struct FkBoss::GuardParam [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
		int GetPtrAddr() const { return (int)this; }
		void CopyFrom(FkBoss::GuardParam& InObject)
		{
			GuardBeginCnt = InObject.GuardBeginCnt;
			GuardContinueCnt = InObject.GuardContinueCnt;
		}
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<GuardParam>("FkBoss_GuardParam")
				.addFunction("__tostring", &FkBoss::GuardParam::ToString)
				.addFunction("GetPtrAddr", &FkBoss::GuardParam::GetPtrAddr)
				.addProperty("GuardBeginCnt", &FkBoss::GuardParam::GuardBeginCnt)
				.addProperty("GuardContinueCnt", &FkBoss::GuardParam::GuardContinueCnt)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBoss::GuardParam::GuardBeginCnt) == 4, "expected FkBoss::GuardParam::GuardBeginCnt to be size 4");
	static_assert(sizeof(FkBoss::GuardParam::GuardContinueCnt) == 4, "expected FkBoss::GuardParam::GuardContinueCnt to be size 4");
	static_assert(sizeof(FkBoss::GuardParam) == 0x8, "expected FkBoss::GuardParam to be size 0x8");

	// enum FkBoss::eReqAvoidDir
	enum eReqAvoidDir : uint32_t
	{
		// <eReqAvoidDir_UNKNOWN = 0xffffffffffffffff>
		eReqAvoidDir_UNKNOWN = UINT32_MAX,

		// <eReqAvoidDir_Side = 0x0>
		eReqAvoidDir_Side = 0,

		// <eReqAvoidDir_Back = 0x1>
		eReqAvoidDir_Back = 1

	};

	/// Struct member variables

	// <class bsBasic field_0, offset 0x0>
	// class bsBasic Super;

	// <int32_t m_ContinueAvoidNum, offset 0xc84>
	int32_t m_ContinueAvoidNum = 0;

	// <int32_t m_GeneralComboAttackArray[0x5][0xa], offset 0xc88>
	int32_t m_GeneralComboAttackArray[5][10];

	// <struct FkBoss::GuardParam m_GuardParam, offset 0xd50>
	struct FkBoss::GuardParam m_GuardParam;

	// <int32_t m_ThinkCnt, offset 0xd58>
	int32_t m_ThinkCnt = 0;

	// <int32_t m_AttackCnt, offset 0xd5c>
	int32_t m_AttackCnt = 0;

	// <enum FightSpirit m_FightSpirit, offset 0xd60>
	enum FightSpirit m_FightSpirit;

	// <int32_t m_ContinueDamageNum, offset 0xd64>
	int32_t m_ContinueDamageNum = 0;

	// <int32_t m_ContinueGuardNum, offset 0xd68>
	int32_t m_ContinueGuardNum = 0;

	// <enum FkBoss::eReqAvoidDir m_eReqAvoidDir, offset 0xd6c>
	enum FkBoss::eReqAvoidDir m_eReqAvoidDir;

	// <uint8_t m_boNoEfGuard, offset 0xd70>
	uint8_t m_boNoEfGuard = 0;

	// <Unidentified data segment, offset 0xd71>
private:
	char _UnidentifiedData_3441[3];

public:
	// <struct Vec m_FrontDir, offset 0xd74>
	struct Vec m_FrontDir;

	// <class FkStlVector<Vec> m_RunAwayPointArr, offset 0xd80>
	class FkStlVector<Vec> m_RunAwayPointArr;

	// <int32_t m_ComboAttackNo, offset 0xd94>
	int32_t m_ComboAttackNo = 0;

	// <int32_t m_SafetyStateChangeTick, offset 0xd98>
	int32_t m_SafetyStateChangeTick = 0;

	// <float m_fEventAccumDamage, offset 0xd9c>
	float m_fEventAccumDamage = 0;

	// <struct tagGHMR_TEX* m_apTex[0x1], offset 0xda0>
	struct tagGHMR_TEX* m_apTex[1];

	// <class EffectSlashTrack* m_pEfSamasoTrack[0x2], offset 0xda4>
	class EffectSlashTrack* m_pEfSamasoTrack[2];

	/// 1 Functions

	// [Function] uint8_t __convention("thiscall") FkBoss::mSetDamage(class FkBoss* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@FkBoss@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	typedef uint8_t(__thiscall* _mSetDamage_FkBoss__UAE_NMHHHMHMMPAVmHRChara___Z)(class FkBoss* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		_mSetDamage_FkBoss__UAE_NMHHHMHMMPAVmHRChara___Z mFunc = (_mSetDamage_FkBoss__UAE_NMHHHMHMMPAVmHRChara___Z)(GameModule + 0x6392c0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class FkBoss [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(FkBoss& InObject)
	{
		m_ContinueAvoidNum = InObject.m_ContinueAvoidNum;
		m_GuardParam = InObject.m_GuardParam;
		m_ThinkCnt = InObject.m_ThinkCnt;
		m_AttackCnt = InObject.m_AttackCnt;
		m_FightSpirit = InObject.m_FightSpirit;
		m_ContinueDamageNum = InObject.m_ContinueDamageNum;
		m_ContinueGuardNum = InObject.m_ContinueGuardNum;
		m_eReqAvoidDir = InObject.m_eReqAvoidDir;
		m_boNoEfGuard = InObject.m_boNoEfGuard;
		m_FrontDir = InObject.m_FrontDir;
		m_RunAwayPointArr = InObject.m_RunAwayPointArr;
		m_ComboAttackNo = InObject.m_ComboAttackNo;
		m_SafetyStateChangeTick = InObject.m_SafetyStateChangeTick;
		m_fEventAccumDamage = InObject.m_fEventAccumDamage;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<FkBoss, bsBasic>("FkBoss")
			.addFunction("__tostring", &FkBoss::ToString)
			.addFunction("GetPtrAddr", &FkBoss::GetPtrAddr)
			.addProperty("m_ContinueAvoidNum", &FkBoss::m_ContinueAvoidNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_GeneralComboAttackArray", &FkBoss::m_GeneralComboAttackArray)
			.addProperty("m_GuardParam", &FkBoss::m_GuardParam)
			.addProperty("m_ThinkCnt", &FkBoss::m_ThinkCnt)
			.addProperty("m_AttackCnt", &FkBoss::m_AttackCnt)
			.addProperty("m_FightSpirit", &FkBoss::m_FightSpirit)
			.addProperty("m_ContinueDamageNum", &FkBoss::m_ContinueDamageNum)
			.addProperty("m_ContinueGuardNum", &FkBoss::m_ContinueGuardNum)
			.addProperty("m_eReqAvoidDir", &FkBoss::m_eReqAvoidDir)
			.addProperty("m_boNoEfGuard", &FkBoss::m_boNoEfGuard)
			.addProperty("m_FrontDir", &FkBoss::m_FrontDir)
			.addProperty("m_RunAwayPointArr", &FkBoss::m_RunAwayPointArr)
			.addProperty("m_ComboAttackNo", &FkBoss::m_ComboAttackNo)
			.addProperty("m_SafetyStateChangeTick", &FkBoss::m_SafetyStateChangeTick)
			.addProperty("m_fEventAccumDamage", &FkBoss::m_fEventAccumDamage)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_apTex", &FkBoss::m_apTex)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pEfSamasoTrack", &FkBoss::m_pEfSamasoTrack)
			.addFunction("mSetDamage", &FkBoss::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkBoss::m_ContinueAvoidNum) == 4, "expected FkBoss::m_ContinueAvoidNum to be size 4");
static_assert(sizeof(FkBoss::m_GeneralComboAttackArray) == 200, "expected FkBoss::m_GeneralComboAttackArray to be size 200");
static_assert(sizeof(FkBoss::m_GuardParam) == 8, "expected FkBoss::m_GuardParam to be size 8");
static_assert(sizeof(FkBoss::m_ThinkCnt) == 4, "expected FkBoss::m_ThinkCnt to be size 4");
static_assert(sizeof(FkBoss::m_AttackCnt) == 4, "expected FkBoss::m_AttackCnt to be size 4");
static_assert(sizeof(FkBoss::m_FightSpirit) == 4, "expected FkBoss::m_FightSpirit to be size 4");
static_assert(sizeof(FkBoss::m_ContinueDamageNum) == 4, "expected FkBoss::m_ContinueDamageNum to be size 4");
static_assert(sizeof(FkBoss::m_ContinueGuardNum) == 4, "expected FkBoss::m_ContinueGuardNum to be size 4");
static_assert(sizeof(FkBoss::m_eReqAvoidDir) == 4, "expected FkBoss::m_eReqAvoidDir to be size 4");
static_assert(sizeof(FkBoss::m_boNoEfGuard) == 1, "expected FkBoss::m_boNoEfGuard to be size 1");
static_assert(sizeof(FkBoss::m_FrontDir) == 12, "expected FkBoss::m_FrontDir to be size 12");
static_assert(sizeof(FkBoss::m_RunAwayPointArr) == 20, "expected FkBoss::m_RunAwayPointArr to be size 20");
static_assert(sizeof(FkBoss::m_ComboAttackNo) == 4, "expected FkBoss::m_ComboAttackNo to be size 4");
static_assert(sizeof(FkBoss::m_SafetyStateChangeTick) == 4, "expected FkBoss::m_SafetyStateChangeTick to be size 4");
static_assert(sizeof(FkBoss::m_fEventAccumDamage) == 4, "expected FkBoss::m_fEventAccumDamage to be size 4");
static_assert(sizeof(FkBoss::m_apTex) == 4, "expected FkBoss::m_apTex to be size 4");
static_assert(sizeof(FkBoss::m_pEfSamasoTrack) == 8, "expected FkBoss::m_pEfSamasoTrack to be size 8");
static_assert(sizeof(FkBoss) == 0xdac, "expected FkBoss to be size 0xdac");

// [Structure] class EffectSlashTrack
class EffectSlashTrack
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[944];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectSlashTrack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectSlashTrack& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectSlashTrack>("EffectSlashTrack")
			.addFunction("__tostring", &EffectSlashTrack::ToString)
			.addFunction("GetPtrAddr", &EffectSlashTrack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSlashTrack) == 0x3b0, "expected EffectSlashTrack to be size 0x3b0");

// [Structure] class EffectBeamDragon
class EffectBeamDragon
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[520];

public:
	/// 2 Functions

	// [Function] void __convention("thiscall") EffectBeamDragon::Set(class EffectBeamDragon* const this, struct Vec* arg2, class mHRChara* arg3) [?Set@EffectBeamDragon@@QAEXPAUVec@@PAVmHRChara@@@Z]
	typedef void(__thiscall* _Set_EffectBeamDragon__QAEXPAUVec__PAVmHRChara___Z)(class EffectBeamDragon* const thisPtr, struct Vec* arg2, class mHRChara* arg3);
	void Set(struct Vec* arg2, class mHRChara* arg3)
	{
		_Set_EffectBeamDragon__QAEXPAUVec__PAVmHRChara___Z mFunc = (_Set_EffectBeamDragon__QAEXPAUVec__PAVmHRChara___Z)(GameModule + 0x643840);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class EffectBeamDragon* EffectBeamDragon::Create(struct Vec* arg1, class mHRChara* arg2) [?Create@EffectBeamDragon@@SAPAV1@PAUVec@@PAVmHRChara@@@Z]
	typedef class EffectBeamDragon*(__fastcall* _Create_EffectBeamDragon__SAPAV1_PAUVec__PAVmHRChara___Z)(struct Vec* arg1, class mHRChara* arg2);
	static class EffectBeamDragon* Create(struct Vec* arg1, class mHRChara* arg2)
	{
		_Create_EffectBeamDragon__SAPAV1_PAUVec__PAVmHRChara___Z mFunc = (_Create_EffectBeamDragon__SAPAV1_PAUVec__PAVmHRChara___Z)(GameModule + 0x644130);
		return mFunc(arg1, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectBeamDragon [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectBeamDragon& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectBeamDragon>("EffectBeamDragon")
			.addFunction("__tostring", &EffectBeamDragon::ToString)
			.addFunction("GetPtrAddr", &EffectBeamDragon::GetPtrAddr)
			.addFunction("Set", &EffectBeamDragon::Set)
			.addStaticFunction("Create", &EffectBeamDragon::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectBeamDragon) == 0x208, "expected EffectBeamDragon to be size 0x208");

// [Structure] class EffectGYNMissile
class EffectGYNMissile : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pTgtChar, offset 0x50>
	class mHRChara* m_pTgtChar = nullptr;

	// <class TGmf* m_pMissileGmf, offset 0x54>
	class TGmf* m_pMissileGmf = nullptr;

	// <struct Vec m_Pos, offset 0x58>
	struct Vec m_Pos;

	// <struct Vec m_BeforePos, offset 0x64>
	struct Vec m_BeforePos;

	// <struct Vec m_Rot, offset 0x70>
	struct Vec m_Rot;

	// <struct Vec m_MoveVec, offset 0x7c>
	struct Vec m_MoveVec;

	// <struct Vec m_LaunchVec, offset 0x88>
	struct Vec m_LaunchVec;

	// <float m_fRotYSpd, offset 0x94>
	float m_fRotYSpd = 0;

	// <float m_fMoveSpd, offset 0x98>
	float m_fMoveSpd = 0;

	// <int32_t m_Cnt, offset 0x9c>
	int32_t m_Cnt = 0;

	// <int32_t m_SeHnd, offset 0xa0>
	int32_t m_SeHnd = 0;

	// <uint8_t m_boHoming, offset 0xa4>
	uint8_t m_boHoming = 0;

	// <Unidentified data segment, offset 0xa5>
private:
	char _UnidentifiedData_165[3];

public:
	/// 2 Functions

	// [Function] void __convention("thiscall") EffectGYNMissile::Set(class EffectGYNMissile* const this, struct Vec& arg2, float const arg3, class mHRChara* arg4) [?Set@EffectGYNMissile@@AAEXABUVec@@MPAVmHRChara@@@Z]
	typedef void(__thiscall* _Set_EffectGYNMissile__AAEXABUVec__MPAVmHRChara___Z)(class EffectGYNMissile* const thisPtr, struct Vec& arg2, float const arg3, class mHRChara* arg4);
	void Set(struct Vec& arg2, float const arg3, class mHRChara* arg4)
	{
		_Set_EffectGYNMissile__AAEXABUVec__MPAVmHRChara___Z mFunc = (_Set_EffectGYNMissile__AAEXABUVec__MPAVmHRChara___Z)(GameModule + 0x646520);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class EffectGYNMissile* EffectGYNMissile::Create(struct Vec& arg1, float const arg2, class mHRChara* arg3) [?Create@EffectGYNMissile@@SAPAV1@ABUVec@@MPAVmHRChara@@@Z]
	typedef class EffectGYNMissile*(__fastcall* _Create_EffectGYNMissile__SAPAV1_ABUVec__MPAVmHRChara___Z)(struct Vec& arg1, float const arg2, class mHRChara* arg3);
	static class EffectGYNMissile* Create(struct Vec& arg1, float const arg2, class mHRChara* arg3)
	{
		_Create_EffectGYNMissile__SAPAV1_ABUVec__MPAVmHRChara___Z mFunc = (_Create_EffectGYNMissile__SAPAV1_ABUVec__MPAVmHRChara___Z)(GameModule + 0x6467a0);
		return mFunc(arg1, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectGYNMissile [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectGYNMissile& InObject)
	{
		m_pTgtChar = InObject.m_pTgtChar;
		m_pMissileGmf = InObject.m_pMissileGmf;
		m_Pos = InObject.m_Pos;
		m_BeforePos = InObject.m_BeforePos;
		m_Rot = InObject.m_Rot;
		m_MoveVec = InObject.m_MoveVec;
		m_LaunchVec = InObject.m_LaunchVec;
		m_fRotYSpd = InObject.m_fRotYSpd;
		m_fMoveSpd = InObject.m_fMoveSpd;
		m_Cnt = InObject.m_Cnt;
		m_SeHnd = InObject.m_SeHnd;
		m_boHoming = InObject.m_boHoming;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectGYNMissile, HrTask>("EffectGYNMissile")
			.addFunction("__tostring", &EffectGYNMissile::ToString)
			.addFunction("GetPtrAddr", &EffectGYNMissile::GetPtrAddr)
			.addProperty("m_pTgtChar", &EffectGYNMissile::m_pTgtChar)
			.addProperty("m_pMissileGmf", &EffectGYNMissile::m_pMissileGmf)
			.addProperty("m_Pos", &EffectGYNMissile::m_Pos)
			.addProperty("m_BeforePos", &EffectGYNMissile::m_BeforePos)
			.addProperty("m_Rot", &EffectGYNMissile::m_Rot)
			.addProperty("m_MoveVec", &EffectGYNMissile::m_MoveVec)
			.addProperty("m_LaunchVec", &EffectGYNMissile::m_LaunchVec)
			.addProperty("m_fRotYSpd", &EffectGYNMissile::m_fRotYSpd)
			.addProperty("m_fMoveSpd", &EffectGYNMissile::m_fMoveSpd)
			.addProperty("m_Cnt", &EffectGYNMissile::m_Cnt)
			.addProperty("m_SeHnd", &EffectGYNMissile::m_SeHnd)
			.addProperty("m_boHoming", &EffectGYNMissile::m_boHoming)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("Set", &EffectGYNMissile::Set)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectGYNMissile::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectGYNMissile::m_pTgtChar) == 4, "expected EffectGYNMissile::m_pTgtChar to be size 4");
static_assert(sizeof(EffectGYNMissile::m_pMissileGmf) == 4, "expected EffectGYNMissile::m_pMissileGmf to be size 4");
static_assert(sizeof(EffectGYNMissile::m_Pos) == 12, "expected EffectGYNMissile::m_Pos to be size 12");
static_assert(sizeof(EffectGYNMissile::m_BeforePos) == 12, "expected EffectGYNMissile::m_BeforePos to be size 12");
static_assert(sizeof(EffectGYNMissile::m_Rot) == 12, "expected EffectGYNMissile::m_Rot to be size 12");
static_assert(sizeof(EffectGYNMissile::m_MoveVec) == 12, "expected EffectGYNMissile::m_MoveVec to be size 12");
static_assert(sizeof(EffectGYNMissile::m_LaunchVec) == 12, "expected EffectGYNMissile::m_LaunchVec to be size 12");
static_assert(sizeof(EffectGYNMissile::m_fRotYSpd) == 4, "expected EffectGYNMissile::m_fRotYSpd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_fMoveSpd) == 4, "expected EffectGYNMissile::m_fMoveSpd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_Cnt) == 4, "expected EffectGYNMissile::m_Cnt to be size 4");
static_assert(sizeof(EffectGYNMissile::m_SeHnd) == 4, "expected EffectGYNMissile::m_SeHnd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_boHoming) == 1, "expected EffectGYNMissile::m_boHoming to be size 1");
static_assert(sizeof(EffectGYNMissile) == 0xa8, "expected EffectGYNMissile to be size 0xa8");

// [Structure] class EffectMoeMissile
class EffectMoeMissile : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pTgtChar, offset 0x50>
	class mHRChara* m_pTgtChar = nullptr;

	// <struct Vec m_Pos, offset 0x54>
	struct Vec m_Pos;

	// <struct Vec m_BeforePos, offset 0x60>
	struct Vec m_BeforePos;

	// <struct Vec m_Rot, offset 0x6c>
	struct Vec m_Rot;

	// <struct Vec m_MoveDir, offset 0x78>
	struct Vec m_MoveDir;

	// <struct Vec m_MoveVec, offset 0x84>
	struct Vec m_MoveVec;

	// <uint8_t m_boHoming, offset 0x90>
	uint8_t m_boHoming = 0;

	// <Unidentified data segment, offset 0x91>
private:
	char _UnidentifiedData_145[3];

public:
	// <class EffectFixFire* m_pFire, offset 0x94>
	class EffectFixFire* m_pFire = nullptr;

	// <float m_MatRot[0x3][0x4], offset 0x98>
	float m_MatRot[3][4];

	// <float m_fSpd, offset 0xc8>
	float m_fSpd = 0;

	// <class TGmf* m_pMissileGmf, offset 0xcc>
	class TGmf* m_pMissileGmf = nullptr;

	/// 2 Functions

	// [Function] void __convention("thiscall") EffectMoeMissile::Set(class EffectMoeMissile* const this, struct Vec& arg2, float const arg3, class mHRChara* arg4) [?Set@EffectMoeMissile@@AAEXABUVec@@MPAVmHRChara@@@Z]
	typedef void(__thiscall* _Set_EffectMoeMissile__AAEXABUVec__MPAVmHRChara___Z)(class EffectMoeMissile* const thisPtr, struct Vec& arg2, float const arg3, class mHRChara* arg4);
	void Set(struct Vec& arg2, float const arg3, class mHRChara* arg4)
	{
		_Set_EffectMoeMissile__AAEXABUVec__MPAVmHRChara___Z mFunc = (_Set_EffectMoeMissile__AAEXABUVec__MPAVmHRChara___Z)(GameModule + 0x64a900);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class EffectMoeMissile* EffectMoeMissile::Create(struct Vec& arg1, float const arg2, class mHRChara* arg3) [?Create@EffectMoeMissile@@SAPAV1@ABUVec@@MPAVmHRChara@@@Z]
	typedef class EffectMoeMissile*(__fastcall* _Create_EffectMoeMissile__SAPAV1_ABUVec__MPAVmHRChara___Z)(struct Vec& arg1, float const arg2, class mHRChara* arg3);
	static class EffectMoeMissile* Create(struct Vec& arg1, float const arg2, class mHRChara* arg3)
	{
		_Create_EffectMoeMissile__SAPAV1_ABUVec__MPAVmHRChara___Z mFunc = (_Create_EffectMoeMissile__SAPAV1_ABUVec__MPAVmHRChara___Z)(GameModule + 0x64a930);
		return mFunc(arg1, arg2, arg3);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class EffectMoeMissile [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(EffectMoeMissile& InObject)
	{
		m_pTgtChar = InObject.m_pTgtChar;
		m_Pos = InObject.m_Pos;
		m_BeforePos = InObject.m_BeforePos;
		m_Rot = InObject.m_Rot;
		m_MoveDir = InObject.m_MoveDir;
		m_MoveVec = InObject.m_MoveVec;
		m_boHoming = InObject.m_boHoming;
		m_pFire = InObject.m_pFire;
		m_fSpd = InObject.m_fSpd;
		m_pMissileGmf = InObject.m_pMissileGmf;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectMoeMissile, HrTask>("EffectMoeMissile")
			.addFunction("__tostring", &EffectMoeMissile::ToString)
			.addFunction("GetPtrAddr", &EffectMoeMissile::GetPtrAddr)
			.addProperty("m_pTgtChar", &EffectMoeMissile::m_pTgtChar)
			.addProperty("m_Pos", &EffectMoeMissile::m_Pos)
			.addProperty("m_BeforePos", &EffectMoeMissile::m_BeforePos)
			.addProperty("m_Rot", &EffectMoeMissile::m_Rot)
			.addProperty("m_MoveDir", &EffectMoeMissile::m_MoveDir)
			.addProperty("m_MoveVec", &EffectMoeMissile::m_MoveVec)
			.addProperty("m_boHoming", &EffectMoeMissile::m_boHoming)
			.addProperty("m_pFire", &EffectMoeMissile::m_pFire)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_MatRot", &EffectMoeMissile::m_MatRot)
			.addProperty("m_fSpd", &EffectMoeMissile::m_fSpd)
			.addProperty("m_pMissileGmf", &EffectMoeMissile::m_pMissileGmf)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("Set", &EffectMoeMissile::Set)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectMoeMissile::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectMoeMissile::m_pTgtChar) == 4, "expected EffectMoeMissile::m_pTgtChar to be size 4");
static_assert(sizeof(EffectMoeMissile::m_Pos) == 12, "expected EffectMoeMissile::m_Pos to be size 12");
static_assert(sizeof(EffectMoeMissile::m_BeforePos) == 12, "expected EffectMoeMissile::m_BeforePos to be size 12");
static_assert(sizeof(EffectMoeMissile::m_Rot) == 12, "expected EffectMoeMissile::m_Rot to be size 12");
static_assert(sizeof(EffectMoeMissile::m_MoveDir) == 12, "expected EffectMoeMissile::m_MoveDir to be size 12");
static_assert(sizeof(EffectMoeMissile::m_MoveVec) == 12, "expected EffectMoeMissile::m_MoveVec to be size 12");
static_assert(sizeof(EffectMoeMissile::m_boHoming) == 1, "expected EffectMoeMissile::m_boHoming to be size 1");
static_assert(sizeof(EffectMoeMissile::m_pFire) == 4, "expected EffectMoeMissile::m_pFire to be size 4");
static_assert(sizeof(EffectMoeMissile::m_MatRot) == 48, "expected EffectMoeMissile::m_MatRot to be size 48");
static_assert(sizeof(EffectMoeMissile::m_fSpd) == 4, "expected EffectMoeMissile::m_fSpd to be size 4");
static_assert(sizeof(EffectMoeMissile::m_pMissileGmf) == 4, "expected EffectMoeMissile::m_pMissileGmf to be size 4");
static_assert(sizeof(EffectMoeMissile) == 0xd0, "expected EffectMoeMissile to be size 0xd0");

// [Structure] class NYMenuManager
class NYMenuManager
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[80992];

public:
	/// 2 Functions

	// [Function] class ghmResGroup* __convention("thiscall") NYMenuManager::GetLanguageGroup(class NYMenuManager* const this, class ghmResGroup* arg2) [?GetLanguageGroup@NYMenuManager@@AAEPAVghmResGroup@@PAV2@@Z]
	typedef class ghmResGroup*(__thiscall* _GetLanguageGroup_NYMenuManager__AAEPAVghmResGroup__PAV2__Z)(class NYMenuManager* const thisPtr, class ghmResGroup* arg2);
	class ghmResGroup* GetLanguageGroup(class ghmResGroup* arg2)
	{
		_GetLanguageGroup_NYMenuManager__AAEPAVghmResGroup__PAV2__Z mFunc = (_GetLanguageGroup_NYMenuManager__AAEPAVghmResGroup__PAV2__Z)(GameModule + 0x66b950);
		return mFunc(this, arg2);
	}
	// [Function] class ghmResGroup* __convention("thiscall") NYMenuManager::LoadShop2DGraph(class NYMenuManager* const this) [?LoadShop2DGraph@NYMenuManager@@IAEPAVghmResGroup@@XZ]
	typedef class ghmResGroup*(__thiscall* _LoadShop2DGraph_NYMenuManager__IAEPAVghmResGroup__XZ)(class NYMenuManager* const thisPtr);
	class ghmResGroup* LoadShop2DGraph()
	{
		_LoadShop2DGraph_NYMenuManager__IAEPAVghmResGroup__XZ mFunc = (_LoadShop2DGraph_NYMenuManager__IAEPAVghmResGroup__XZ)(GameModule + 0x66b9d0);
		return mFunc(this);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class NYMenuManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(NYMenuManager& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NYMenuManager>("NYMenuManager")
			.addFunction("__tostring", &NYMenuManager::ToString)
			.addFunction("GetPtrAddr", &NYMenuManager::GetPtrAddr)
			.addFunction("GetLanguageGroup", &NYMenuManager::GetLanguageGroup)
			.addFunction("LoadShop2DGraph", &NYMenuManager::LoadShop2DGraph)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYMenuManager) == 0x13c60, "expected NYMenuManager to be size 0x13c60");

// [Structure] class INYTrainingCallBack
class INYTrainingCallBack
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x3], offset 0x0>
	void* (* field_0)[0x3];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class INYTrainingCallBack [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(INYTrainingCallBack& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<INYTrainingCallBack>("INYTrainingCallBack")
			.addFunction("__tostring", &INYTrainingCallBack::ToString)
			.addFunction("GetPtrAddr", &INYTrainingCallBack::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &INYTrainingCallBack::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(INYTrainingCallBack::field_0) == 4, "expected INYTrainingCallBack::field_0 to be size 4");
static_assert(sizeof(INYTrainingCallBack) == 0x4, "expected INYTrainingCallBack to be size 0x4");

// [Structure] class CNYTrainingManager
class CNYTrainingManager : public INYTrainingCallBack
{
public:
	// enum CNYTrainingManager::TRAINING_TYPE
	enum TRAINING_TYPE : uint32_t
	{
		// <TRAINING_STAMINA = 0x0>
		TRAINING_STAMINA = 0,

		// <TRAINING_MUSCLE = 0x1>
		TRAINING_MUSCLE = 1,

		// <TRAINING_TYPE_MAX = 0x2>
		TRAINING_TYPE_MAX = 2

	};

	// enum CNYTrainingManager::TRAINING_RESULT_TYPE
	enum TRAINING_RESULT_TYPE : uint32_t
	{
		// <TRAINING_NONE = 0x0>
		TRAINING_NONE = 0,

		// <TRAINING_SUCCESS = 0x1>
		TRAINING_SUCCESS = 1,

		// <TRAINING_FAIL = 0x2>
		TRAINING_FAIL = 2,

		// <TRAINING_BREAK = 0x3>
		TRAINING_BREAK = 3,

		// <TRAINING_RESULT_TYPE_MAX = 0x4>
		TRAINING_RESULT_TYPE_MAX = 4

	};

	/// Struct member variables

	// <class INYTrainingCallBack field_0, offset 0x0>
	// class INYTrainingCallBack Super;

	// <void (* m_pPhaseProc[0x7])(CNYTrainingManager* const this), offset 0x4>
	void (* m_pPhaseProc[0x7])(CNYTrainingManager* const ThisPtr);

	// <class NYPhase m_Phase, offset 0x20>
	class NYPhase m_Phase;

	// <class PJJobMissionManage* m_pJobManager, offset 0x3c>
	class PJJobMissionManage* m_pJobManager = nullptr;

	// <class PJJMBase* m_pJobMission, offset 0x40>
	class PJJMBase* m_pJobMission = nullptr;

	// <enum CNYTrainingManager::TRAINING_TYPE m_TrainingType, offset 0x44>
	enum CNYTrainingManager::TRAINING_TYPE m_TrainingType;

	// <int32_t m_Level, offset 0x48>
	int32_t m_Level = 0;

	// <enum CNYTrainingManager::TRAINING_RESULT_TYPE m_Result, offset 0x4c>
	enum CNYTrainingManager::TRAINING_RESULT_TYPE m_Result;

	// <enum CNYTrainingManager::TRAINING_RESULT_TYPE (* m_pTrainingProc[0x2])(CNYTrainingManager* const this), offset 0x50>
	enum CNYTrainingManager::TRAINING_RESULT_TYPE (* m_pTrainingProc[0x2])(CNYTrainingManager* const ThisPtr);

	// <class HrSysMessage* m_pSysMessage, offset 0x58>
	class HrSysMessage* m_pSysMessage = nullptr;

	// <struct tagHRTASKCHECK m_SysMessageTaskCheck, offset 0x5c>
	struct tagHRTASKCHECK m_SysMessageTaskCheck;

	/// 1 Functions

	// [Function] class ghmResGroup* __convention("thiscall") CNYTrainingManager::GetLanguageGroup(class CNYTrainingManager* const this, class ghmResGroup* arg2) [?GetLanguageGroup@CNYTrainingManager@@AAEPAVghmResGroup@@PAV2@@Z]
	typedef class ghmResGroup*(__thiscall* _GetLanguageGroup_CNYTrainingManager__AAEPAVghmResGroup__PAV2__Z)(class CNYTrainingManager* const thisPtr, class ghmResGroup* arg2);
	class ghmResGroup* GetLanguageGroup(class ghmResGroup* arg2)
	{
		_GetLanguageGroup_CNYTrainingManager__AAEPAVghmResGroup__PAV2__Z mFunc = (_GetLanguageGroup_CNYTrainingManager__AAEPAVghmResGroup__PAV2__Z)(GameModule + 0x676f20);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class CNYTrainingManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(CNYTrainingManager& InObject)
	{
		m_Phase = InObject.m_Phase;
		m_pJobManager = InObject.m_pJobManager;
		m_pJobMission = InObject.m_pJobMission;
		m_TrainingType = InObject.m_TrainingType;
		m_Level = InObject.m_Level;
		m_Result = InObject.m_Result;
		m_pSysMessage = InObject.m_pSysMessage;
		m_SysMessageTaskCheck = InObject.m_SysMessageTaskCheck;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CNYTrainingManager, INYTrainingCallBack>("CNYTrainingManager")
			.addFunction("__tostring", &CNYTrainingManager::ToString)
			.addFunction("GetPtrAddr", &CNYTrainingManager::GetPtrAddr)
			// void type not supported in LuaBridge
			//.addProperty("m_pPhaseProc", &CNYTrainingManager::m_pPhaseProc)
			.addProperty("m_Phase", &CNYTrainingManager::m_Phase)
			.addProperty("m_pJobManager", &CNYTrainingManager::m_pJobManager)
			.addProperty("m_pJobMission", &CNYTrainingManager::m_pJobMission)
			.addProperty("m_TrainingType", &CNYTrainingManager::m_TrainingType)
			.addProperty("m_Level", &CNYTrainingManager::m_Level)
			.addProperty("m_Result", &CNYTrainingManager::m_Result)
			//.addProperty("m_pTrainingProc", &CNYTrainingManager::m_pTrainingProc)
			.addProperty("m_pSysMessage", &CNYTrainingManager::m_pSysMessage)
			.addProperty("m_SysMessageTaskCheck", &CNYTrainingManager::m_SysMessageTaskCheck)
			.addFunction("GetLanguageGroup", &CNYTrainingManager::GetLanguageGroup)
		.endClass();
	}
#endif
};
static_assert(sizeof(CNYTrainingManager::m_pPhaseProc) == 28, "expected CNYTrainingManager::m_pPhaseProc to be size 28");
static_assert(sizeof(CNYTrainingManager::m_Phase) == 28, "expected CNYTrainingManager::m_Phase to be size 28");
static_assert(sizeof(CNYTrainingManager::m_pJobManager) == 4, "expected CNYTrainingManager::m_pJobManager to be size 4");
static_assert(sizeof(CNYTrainingManager::m_pJobMission) == 4, "expected CNYTrainingManager::m_pJobMission to be size 4");
static_assert(sizeof(CNYTrainingManager::m_TrainingType) == 4, "expected CNYTrainingManager::m_TrainingType to be size 4");
static_assert(sizeof(CNYTrainingManager::m_Level) == 4, "expected CNYTrainingManager::m_Level to be size 4");
static_assert(sizeof(CNYTrainingManager::m_Result) == 4, "expected CNYTrainingManager::m_Result to be size 4");
static_assert(sizeof(CNYTrainingManager::m_pTrainingProc) == 8, "expected CNYTrainingManager::m_pTrainingProc to be size 8");
static_assert(sizeof(CNYTrainingManager::m_pSysMessage) == 4, "expected CNYTrainingManager::m_pSysMessage to be size 4");
static_assert(sizeof(CNYTrainingManager::m_SysMessageTaskCheck) == 8, "expected CNYTrainingManager::m_SysMessageTaskCheck to be size 8");
static_assert(sizeof(CNYTrainingManager) == 0x64, "expected CNYTrainingManager to be size 0x64");

// [Structure] class PJJobMissionManage
class PJJobMissionManage : public HrTask
{
public:
	// enum PJJobMissionManage::jmSTAT
	enum jmSTAT : uint32_t
	{
		// <jmNONE = 0x0>
		jmNONE = 0,

		// <jmCmnSndOPEN = 0x1>
		jmCmnSndOPEN = 1,

		// <jmCmnSndLOAD = 0x2>
		jmCmnSndLOAD = 2,

		// <jmINIT = 0x3>
		jmINIT = 3,

		// <jmFLIE_OPEN = 0x4>
		jmFLIE_OPEN = 4,

		// <jmFLIE_LOAD = 0x5>
		jmFLIE_LOAD = 5,

		// <jmACTIV = 0x6>
		jmACTIV = 6,

		// <jmRESULT = 0x7>
		jmRESULT = 7,

		// <jmWAIT = 0x8>
		jmWAIT = 8,

		// <jmTERM = 0x9>
		jmTERM = 9

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class PJJMBase* mpJobMission, offset 0x50>
	class PJJMBase* mpJobMission = nullptr;

	// <class PJJMHarmfulInsect* mpHarmfulInsect, offset 0x54>
	class PJJMHarmfulInsect* mpHarmfulInsect = nullptr;

	// <class PJJMPlumber* mpPlumber, offset 0x58>
	class PJJMPlumber* mpPlumber = nullptr;

	// <class PJJMResult* mpResult, offset 0x5c>
	class PJJMResult* mpResult = nullptr;

	// <int16_t* mKillEnemy, offset 0x60>
	int16_t* mKillEnemy = nullptr;

	// <int16_t* mPopEnemy, offset 0x64>
	int16_t* mPopEnemy = nullptr;

	// <int16_t* mEnemyMoney, offset 0x68>
	int16_t* mEnemyMoney = nullptr;

	// <float mNokoriTime, offset 0x6c>
	float mNokoriTime = 0;

	// <int16_t mPipeNum, offset 0x70>
	int16_t mPipeNum = 0;

	// <uint8_t mClear, offset 0x72>
	uint8_t mClear = 0;

	// <Unidentified data segment, offset 0x73>
private:
	char _UnidentifiedData_115[1];

public:
	// <enum PJJobMissionManage::jmSTAT mStat, offset 0x74>
	enum PJJobMissionManage::jmSTAT mStat;

	// <int32_t mMissionNo, offset 0x78>
	int32_t mMissionNo = 0;

	// <int32_t mPJJMLevel, offset 0x7c>
	int32_t mPJJMLevel = 0;

	// <uint8_t mbOldMission, offset 0x80>
	uint8_t mbOldMission = 0;

	// <Unidentified data segment, offset 0x81>
private:
	char _UnidentifiedData_129[3];

public:
	// <int32_t mFadeAlpha, offset 0x84>
	int32_t mFadeAlpha = 0;

	// <uint8_t mbFade, offset 0x88>
	uint8_t mbFade = 0;

	// <Unidentified data segment, offset 0x89>
private:
	char _UnidentifiedData_137[3];

public:
	// <int32_t mFadeValue, offset 0x8c>
	int32_t mFadeValue = 0;

	// <uint8_t mGameStart, offset 0x90>
	uint8_t mGameStart = 0;

	// <uint8_t mGameEnd, offset 0x91>
	uint8_t mGameEnd = 0;

	// <Unidentified data segment, offset 0x92>
private:
	char _UnidentifiedData_146[2];

public:
	// <int32_t mhFadeSe, offset 0x94>
	int32_t mhFadeSe = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJJobMissionManage [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJobMissionManage& InObject)
	{
		mpJobMission = InObject.mpJobMission;
		mpHarmfulInsect = InObject.mpHarmfulInsect;
		mpPlumber = InObject.mpPlumber;
		mpResult = InObject.mpResult;
		mKillEnemy = InObject.mKillEnemy;
		mPopEnemy = InObject.mPopEnemy;
		mEnemyMoney = InObject.mEnemyMoney;
		mNokoriTime = InObject.mNokoriTime;
		mPipeNum = InObject.mPipeNum;
		mClear = InObject.mClear;
		mStat = InObject.mStat;
		mMissionNo = InObject.mMissionNo;
		mPJJMLevel = InObject.mPJJMLevel;
		mbOldMission = InObject.mbOldMission;
		mFadeAlpha = InObject.mFadeAlpha;
		mbFade = InObject.mbFade;
		mFadeValue = InObject.mFadeValue;
		mGameStart = InObject.mGameStart;
		mGameEnd = InObject.mGameEnd;
		mhFadeSe = InObject.mhFadeSe;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJJobMissionManage, HrTask>("PJJobMissionManage")
			.addFunction("__tostring", &PJJobMissionManage::ToString)
			.addFunction("GetPtrAddr", &PJJobMissionManage::GetPtrAddr)
			.addProperty("mpJobMission", &PJJobMissionManage::mpJobMission)
			.addProperty("mpHarmfulInsect", &PJJobMissionManage::mpHarmfulInsect)
			.addProperty("mpPlumber", &PJJobMissionManage::mpPlumber)
			.addProperty("mpResult", &PJJobMissionManage::mpResult)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mKillEnemy", &PJJobMissionManage::mKillEnemy)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mPopEnemy", &PJJobMissionManage::mPopEnemy)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mEnemyMoney", &PJJobMissionManage::mEnemyMoney)
			.addProperty("mNokoriTime", &PJJobMissionManage::mNokoriTime)
			.addProperty("mPipeNum", &PJJobMissionManage::mPipeNum)
			.addProperty("mClear", &PJJobMissionManage::mClear)
			.addProperty("mStat", &PJJobMissionManage::mStat)
			.addProperty("mMissionNo", &PJJobMissionManage::mMissionNo)
			.addProperty("mPJJMLevel", &PJJobMissionManage::mPJJMLevel)
			.addProperty("mbOldMission", &PJJobMissionManage::mbOldMission)
			.addProperty("mFadeAlpha", &PJJobMissionManage::mFadeAlpha)
			.addProperty("mbFade", &PJJobMissionManage::mbFade)
			.addProperty("mFadeValue", &PJJobMissionManage::mFadeValue)
			.addProperty("mGameStart", &PJJobMissionManage::mGameStart)
			.addProperty("mGameEnd", &PJJobMissionManage::mGameEnd)
			.addProperty("mhFadeSe", &PJJobMissionManage::mhFadeSe)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJobMissionManage::mpJobMission) == 4, "expected PJJobMissionManage::mpJobMission to be size 4");
static_assert(sizeof(PJJobMissionManage::mpHarmfulInsect) == 4, "expected PJJobMissionManage::mpHarmfulInsect to be size 4");
static_assert(sizeof(PJJobMissionManage::mpPlumber) == 4, "expected PJJobMissionManage::mpPlumber to be size 4");
static_assert(sizeof(PJJobMissionManage::mpResult) == 4, "expected PJJobMissionManage::mpResult to be size 4");
static_assert(sizeof(PJJobMissionManage::mKillEnemy) == 4, "expected PJJobMissionManage::mKillEnemy to be size 4");
static_assert(sizeof(PJJobMissionManage::mPopEnemy) == 4, "expected PJJobMissionManage::mPopEnemy to be size 4");
static_assert(sizeof(PJJobMissionManage::mEnemyMoney) == 4, "expected PJJobMissionManage::mEnemyMoney to be size 4");
static_assert(sizeof(PJJobMissionManage::mNokoriTime) == 4, "expected PJJobMissionManage::mNokoriTime to be size 4");
static_assert(sizeof(PJJobMissionManage::mPipeNum) == 2, "expected PJJobMissionManage::mPipeNum to be size 2");
static_assert(sizeof(PJJobMissionManage::mClear) == 1, "expected PJJobMissionManage::mClear to be size 1");
static_assert(sizeof(PJJobMissionManage::mStat) == 4, "expected PJJobMissionManage::mStat to be size 4");
static_assert(sizeof(PJJobMissionManage::mMissionNo) == 4, "expected PJJobMissionManage::mMissionNo to be size 4");
static_assert(sizeof(PJJobMissionManage::mPJJMLevel) == 4, "expected PJJobMissionManage::mPJJMLevel to be size 4");
static_assert(sizeof(PJJobMissionManage::mbOldMission) == 1, "expected PJJobMissionManage::mbOldMission to be size 1");
static_assert(sizeof(PJJobMissionManage::mFadeAlpha) == 4, "expected PJJobMissionManage::mFadeAlpha to be size 4");
static_assert(sizeof(PJJobMissionManage::mbFade) == 1, "expected PJJobMissionManage::mbFade to be size 1");
static_assert(sizeof(PJJobMissionManage::mFadeValue) == 4, "expected PJJobMissionManage::mFadeValue to be size 4");
static_assert(sizeof(PJJobMissionManage::mGameStart) == 1, "expected PJJobMissionManage::mGameStart to be size 1");
static_assert(sizeof(PJJobMissionManage::mGameEnd) == 1, "expected PJJobMissionManage::mGameEnd to be size 1");
static_assert(sizeof(PJJobMissionManage::mhFadeSe) == 4, "expected PJJobMissionManage::mhFadeSe to be size 4");
static_assert(sizeof(PJJobMissionManage) == 0x98, "expected PJJobMissionManage to be size 0x98");

// [Structure] class PJJMHarmfulInsect
class PJJMHarmfulInsect
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[8608];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJJMHarmfulInsect [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJMHarmfulInsect& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJJMHarmfulInsect>("PJJMHarmfulInsect")
			.addFunction("__tostring", &PJJMHarmfulInsect::ToString)
			.addFunction("GetPtrAddr", &PJJMHarmfulInsect::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJMHarmfulInsect) == 0x21a0, "expected PJJMHarmfulInsect to be size 0x21a0");

// [Structure] class PJJMPlumber
class PJJMPlumber
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[832];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJJMPlumber [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJMPlumber& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJJMPlumber>("PJJMPlumber")
			.addFunction("__tostring", &PJJMPlumber::ToString)
			.addFunction("GetPtrAddr", &PJJMPlumber::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJMPlumber) == 0x340, "expected PJJMPlumber to be size 0x340");

// [Structure] class PJJMResult
class PJJMResult
{
public:
	// enum PJJMResult::jmrSTAT
	enum jmrSTAT : uint32_t
	{
		// <jmrNONE = 0x0>
		jmrNONE = 0,

		// <jmrFLIE_OPEN = 0x1>
		jmrFLIE_OPEN = 1,

		// <jmrFLIE_LOAD = 0x2>
		jmrFLIE_LOAD = 2,

		// <jmrSOUND_OPEN = 0x3>
		jmrSOUND_OPEN = 3,

		// <jmrSOUND_LOAD = 0x4>
		jmrSOUND_LOAD = 4,

		// <jmrINIT = 0x5>
		jmrINIT = 5,

		// <jmrACTIV = 0x6>
		jmrACTIV = 6,

		// <jmrTERM = 0x7>
		jmrTERM = 7

	};

	/// Struct member variables

	// <enum PJJMResult::jmrSTAT mStat, offset 0x0>
	enum PJJMResult::jmrSTAT mStat;

	// <class ghmGcFile* mpFile, offset 0x4>
	class ghmGcFile* mpFile = nullptr;

	// <void* mpRSL, offset 0x8>
	void* mpRSL = nullptr;

	// <struct tagGHMR_TEX mFontTex, offset 0xc>
	struct tagGHMR_TEX mFontTex;

	// <struct tagGHMR_TEX mInfoTex, offset 0x34>
	struct tagGHMR_TEX mInfoTex;

	// <uint8_t mClearFlag, offset 0x5c>
	uint8_t mClearFlag = 0;

	// <uint8_t mContinue, offset 0x5d>
	uint8_t mContinue = 0;

	// <Unidentified data segment, offset 0x5e>
private:
	char _UnidentifiedData_94[2];

public:
	// <int16_t* mpData1, offset 0x60>
	int16_t* mpData1 = nullptr;

	// <int16_t mData1Num, offset 0x64>
	int16_t mData1Num = 0;

	// <Unidentified data segment, offset 0x66>
private:
	char _UnidentifiedData_102[2];

public:
	// <int16_t* mpData2, offset 0x68>
	int16_t* mpData2 = nullptr;

	// <int16_t mData2Num, offset 0x6c>
	int16_t mData2Num = 0;

	// <Unidentified data segment, offset 0x6e>
private:
	char _UnidentifiedData_110[2];

public:
	// <int16_t* mpData3, offset 0x70>
	int16_t* mpData3 = nullptr;

	// <int16_t mData3Num, offset 0x74>
	int16_t mData3Num = 0;

	// <int16_t mDisplayNum, offset 0x76>
	int16_t mDisplayNum = 0;

	// <int16_t* mpDisplayFlag, offset 0x78>
	int16_t* mpDisplayFlag = nullptr;

	// <int16_t mMissionNo, offset 0x7c>
	int16_t mMissionNo = 0;

	// <int16_t mPage, offset 0x7e>
	int16_t mPage = 0;

	// <int16_t mStageLevel, offset 0x80>
	int16_t mStageLevel = 0;

	// <uint8_t mNextStage, offset 0x82>
	uint8_t mNextStage = 0;

	// <Unidentified data segment, offset 0x83>
private:
	char _UnidentifiedData_131[1];

public:
	// <float mTime, offset 0x84>
	float mTime = 0;

	// <float mHTime, offset 0x88>
	float mHTime = 0;

	// <int32_t mCnt, offset 0x8c>
	int32_t mCnt = 0;

	// <int16_t* mEnemyTotal, offset 0x90>
	int16_t* mEnemyTotal = nullptr;

	// <int16_t* mHEnemyTotal, offset 0x94>
	int16_t* mHEnemyTotal = nullptr;

	// <int16_t mSTotal[0x2], offset 0x98>
	int16_t mSTotal[2];

	// <int16_t mHSTotal[0x2], offset 0x9c>
	int16_t mHSTotal[2];

	// <int16_t mGTotal, offset 0xa0>
	int16_t mGTotal = 0;

	// <Unidentified data segment, offset 0xa2>
private:
	char _UnidentifiedData_162[2];

public:
	// <int32_t mGameOverSEHandle, offset 0xa4>
	int32_t mGameOverSEHandle = 0;

	// <int32_t mClearSEHandle, offset 0xa8>
	int32_t mClearSEHandle = 0;

	// <int32_t mSeLoopHandle, offset 0xac>
	int32_t mSeLoopHandle = 0;

	// <int32_t mSeHandle, offset 0xb0>
	int32_t mSeHandle = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class PJJMResult [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(PJJMResult& InObject)
	{
		mStat = InObject.mStat;
		mpFile = InObject.mpFile;
		mpRSL = InObject.mpRSL;
		mFontTex = InObject.mFontTex;
		mInfoTex = InObject.mInfoTex;
		mClearFlag = InObject.mClearFlag;
		mContinue = InObject.mContinue;
		mpData1 = InObject.mpData1;
		mData1Num = InObject.mData1Num;
		mpData2 = InObject.mpData2;
		mData2Num = InObject.mData2Num;
		mpData3 = InObject.mpData3;
		mData3Num = InObject.mData3Num;
		mDisplayNum = InObject.mDisplayNum;
		mpDisplayFlag = InObject.mpDisplayFlag;
		mMissionNo = InObject.mMissionNo;
		mPage = InObject.mPage;
		mStageLevel = InObject.mStageLevel;
		mNextStage = InObject.mNextStage;
		mTime = InObject.mTime;
		mHTime = InObject.mHTime;
		mCnt = InObject.mCnt;
		mEnemyTotal = InObject.mEnemyTotal;
		mHEnemyTotal = InObject.mHEnemyTotal;
		mGTotal = InObject.mGTotal;
		mGameOverSEHandle = InObject.mGameOverSEHandle;
		mClearSEHandle = InObject.mClearSEHandle;
		mSeLoopHandle = InObject.mSeLoopHandle;
		mSeHandle = InObject.mSeHandle;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJJMResult>("PJJMResult")
			.addFunction("__tostring", &PJJMResult::ToString)
			.addFunction("GetPtrAddr", &PJJMResult::GetPtrAddr)
			.addProperty("mStat", &PJJMResult::mStat)
			.addProperty("mpFile", &PJJMResult::mpFile)
			// void type not supported in LuaBridge
			//.addProperty("mpRSL", &PJJMResult::mpRSL)
			.addProperty("mFontTex", &PJJMResult::mFontTex)
			.addProperty("mInfoTex", &PJJMResult::mInfoTex)
			.addProperty("mClearFlag", &PJJMResult::mClearFlag)
			.addProperty("mContinue", &PJJMResult::mContinue)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpData1", &PJJMResult::mpData1)
			.addProperty("mData1Num", &PJJMResult::mData1Num)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpData2", &PJJMResult::mpData2)
			.addProperty("mData2Num", &PJJMResult::mData2Num)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpData3", &PJJMResult::mpData3)
			.addProperty("mData3Num", &PJJMResult::mData3Num)
			.addProperty("mDisplayNum", &PJJMResult::mDisplayNum)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpDisplayFlag", &PJJMResult::mpDisplayFlag)
			.addProperty("mMissionNo", &PJJMResult::mMissionNo)
			.addProperty("mPage", &PJJMResult::mPage)
			.addProperty("mStageLevel", &PJJMResult::mStageLevel)
			.addProperty("mNextStage", &PJJMResult::mNextStage)
			.addProperty("mTime", &PJJMResult::mTime)
			.addProperty("mHTime", &PJJMResult::mHTime)
			.addProperty("mCnt", &PJJMResult::mCnt)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mEnemyTotal", &PJJMResult::mEnemyTotal)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mHEnemyTotal", &PJJMResult::mHEnemyTotal)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mSTotal", &PJJMResult::mSTotal)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mHSTotal", &PJJMResult::mHSTotal)
			.addProperty("mGTotal", &PJJMResult::mGTotal)
			.addProperty("mGameOverSEHandle", &PJJMResult::mGameOverSEHandle)
			.addProperty("mClearSEHandle", &PJJMResult::mClearSEHandle)
			.addProperty("mSeLoopHandle", &PJJMResult::mSeLoopHandle)
			.addProperty("mSeHandle", &PJJMResult::mSeHandle)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJJMResult::mStat) == 4, "expected PJJMResult::mStat to be size 4");
static_assert(sizeof(PJJMResult::mpFile) == 4, "expected PJJMResult::mpFile to be size 4");
static_assert(sizeof(PJJMResult::mpRSL) == 4, "expected PJJMResult::mpRSL to be size 4");
static_assert(sizeof(PJJMResult::mFontTex) == 40, "expected PJJMResult::mFontTex to be size 40");
static_assert(sizeof(PJJMResult::mInfoTex) == 40, "expected PJJMResult::mInfoTex to be size 40");
static_assert(sizeof(PJJMResult::mClearFlag) == 1, "expected PJJMResult::mClearFlag to be size 1");
static_assert(sizeof(PJJMResult::mContinue) == 1, "expected PJJMResult::mContinue to be size 1");
static_assert(sizeof(PJJMResult::mpData1) == 4, "expected PJJMResult::mpData1 to be size 4");
static_assert(sizeof(PJJMResult::mData1Num) == 2, "expected PJJMResult::mData1Num to be size 2");
static_assert(sizeof(PJJMResult::mpData2) == 4, "expected PJJMResult::mpData2 to be size 4");
static_assert(sizeof(PJJMResult::mData2Num) == 2, "expected PJJMResult::mData2Num to be size 2");
static_assert(sizeof(PJJMResult::mpData3) == 4, "expected PJJMResult::mpData3 to be size 4");
static_assert(sizeof(PJJMResult::mData3Num) == 2, "expected PJJMResult::mData3Num to be size 2");
static_assert(sizeof(PJJMResult::mDisplayNum) == 2, "expected PJJMResult::mDisplayNum to be size 2");
static_assert(sizeof(PJJMResult::mpDisplayFlag) == 4, "expected PJJMResult::mpDisplayFlag to be size 4");
static_assert(sizeof(PJJMResult::mMissionNo) == 2, "expected PJJMResult::mMissionNo to be size 2");
static_assert(sizeof(PJJMResult::mPage) == 2, "expected PJJMResult::mPage to be size 2");
static_assert(sizeof(PJJMResult::mStageLevel) == 2, "expected PJJMResult::mStageLevel to be size 2");
static_assert(sizeof(PJJMResult::mNextStage) == 1, "expected PJJMResult::mNextStage to be size 1");
static_assert(sizeof(PJJMResult::mTime) == 4, "expected PJJMResult::mTime to be size 4");
static_assert(sizeof(PJJMResult::mHTime) == 4, "expected PJJMResult::mHTime to be size 4");
static_assert(sizeof(PJJMResult::mCnt) == 4, "expected PJJMResult::mCnt to be size 4");
static_assert(sizeof(PJJMResult::mEnemyTotal) == 4, "expected PJJMResult::mEnemyTotal to be size 4");
static_assert(sizeof(PJJMResult::mHEnemyTotal) == 4, "expected PJJMResult::mHEnemyTotal to be size 4");
static_assert(sizeof(PJJMResult::mSTotal) == 4, "expected PJJMResult::mSTotal to be size 4");
static_assert(sizeof(PJJMResult::mHSTotal) == 4, "expected PJJMResult::mHSTotal to be size 4");
static_assert(sizeof(PJJMResult::mGTotal) == 2, "expected PJJMResult::mGTotal to be size 2");
static_assert(sizeof(PJJMResult::mGameOverSEHandle) == 4, "expected PJJMResult::mGameOverSEHandle to be size 4");
static_assert(sizeof(PJJMResult::mClearSEHandle) == 4, "expected PJJMResult::mClearSEHandle to be size 4");
static_assert(sizeof(PJJMResult::mSeLoopHandle) == 4, "expected PJJMResult::mSeLoopHandle to be size 4");
static_assert(sizeof(PJJMResult::mSeHandle) == 4, "expected PJJMResult::mSeHandle to be size 4");
static_assert(sizeof(PJJMResult) == 0xb4, "expected PJJMResult to be size 0xb4");

// [Structure] class hRECT
class hRECT
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <struct hPOINT mPoint, offset 0x4>
	struct hPOINT mPoint;

	// <float mWidth, offset 0xc>
	float mWidth = 0;

	// <float mHeight, offset 0x10>
	float mHeight = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hRECT [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hRECT& InObject)
	{
		mPoint = InObject.mPoint;
		mWidth = InObject.mWidth;
		mHeight = InObject.mHeight;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hRECT>("hRECT")
			.addFunction("__tostring", &hRECT::ToString)
			.addFunction("GetPtrAddr", &hRECT::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &hRECT::field_0)
			.addProperty("mPoint", &hRECT::mPoint)
			.addProperty("mWidth", &hRECT::mWidth)
			.addProperty("mHeight", &hRECT::mHeight)
		.endClass();
	}
#endif
};
static_assert(sizeof(hRECT::field_0) == 4, "expected hRECT::field_0 to be size 4");
static_assert(sizeof(hRECT::mPoint) == 8, "expected hRECT::mPoint to be size 8");
static_assert(sizeof(hRECT::mWidth) == 4, "expected hRECT::mWidth to be size 4");
static_assert(sizeof(hRECT::mHeight) == 4, "expected hRECT::mHeight to be size 4");
static_assert(sizeof(hRECT) == 0x14, "expected hRECT to be size 0x14");

// [Structure] class hChildListObj<hGUIObj>
template<typename T>
class hChildListObj : public hListObj<hGUIObj>
{
public:
	/// Struct member variables

	// <class hListObj<hGUIObj> field_0, offset 0x0>
	// class hListObj<T> Super;

	// <class hGUIObj* mParent, offset 0xc>
	T* mParent = nullptr;

	// <class hGUIObj* mChild, offset 0x10>
	T* mChild = nullptr;

	// <class hGUIObj* mLastChild, offset 0x14>
	T* mLastChild = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hChildListObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hChildListObj<hGUIObj>& InObject)
	{
		mParent = InObject.mParent;
		mChild = InObject.mChild;
		mLastChild = InObject.mLastChild;
	}
	// Exporting templated types to Lua currently not supported.
	// static void BindLua(luabridge::Namespace& NS)
};
static_assert(sizeof(hChildListObj<hGUIObj>::mParent) == 4, "expected hChildListObj<hGUIObj>::mParent to be size 4");
static_assert(sizeof(hChildListObj<hGUIObj>::mChild) == 4, "expected hChildListObj<hGUIObj>::mChild to be size 4");
static_assert(sizeof(hChildListObj<hGUIObj>::mLastChild) == 4, "expected hChildListObj<hGUIObj>::mLastChild to be size 4");
static_assert(sizeof(hChildListObj<hGUIObj>) == 0x18, "expected hChildListObj<hGUIObj> to be size 0x18");

// [Structure] class hGUIObj
class hGUIObj : public hChildListObj<hGUIObj>
{
public:
	/// Struct member variables

	// <class hChildListObj<hGUIObj> field_0, offset 0x0>
	// class hChildListObj<hGUIObj> Super;

	// <uint32_t mID, offset 0x18>
	uint32_t mID = 0;

	// <struct Vec mPos, offset 0x1c>
	struct Vec mPos;

	// <class hGUIManager* mpManager, offset 0x28>
	class hGUIManager* mpManager = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUIObj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUIObj& InObject)
	{
		mID = InObject.mID;
		mPos = InObject.mPos;
		mpManager = InObject.mpManager;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hGUIObj>("hGUIObj")
			.addFunction("__tostring", &hGUIObj::ToString)
			.addFunction("GetPtrAddr", &hGUIObj::GetPtrAddr)
			.addProperty("mID", &hGUIObj::mID)
			.addProperty("mPos", &hGUIObj::mPos)
			.addProperty("mpManager", &hGUIObj::mpManager)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUIObj::mID) == 4, "expected hGUIObj::mID to be size 4");
static_assert(sizeof(hGUIObj::mPos) == 12, "expected hGUIObj::mPos to be size 12");
static_assert(sizeof(hGUIObj::mpManager) == 4, "expected hGUIObj::mpManager to be size 4");
static_assert(sizeof(hGUIObj) == 0x2c, "expected hGUIObj to be size 0x2c");

// [Structure] class hGUIWindow
class hGUIWindow : public hGUIObj
{
public:
	/// Struct member variables

	// <class hGUIObj field_0, offset 0x0>
	// class hGUIObj Super;

	// <char mName[0x20], offset 0x2c>
	char mName[32];

	// <int32_t mWidth, offset 0x4c>
	int32_t mWidth = 0;

	// <int32_t mHeight, offset 0x50>
	int32_t mHeight = 0;

	// <uint32_t mColor, offset 0x54>
	uint32_t mColor = 0;

	// <struct Vec mCrientPos, offset 0x58>
	struct Vec mCrientPos;

	// <uint16_t mFlag, offset 0x64>
	uint16_t mFlag = 0;

	// <Unidentified data segment, offset 0x66>
private:
	char _UnidentifiedData_102[2];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUIWindow [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUIWindow& InObject)
	{
		mWidth = InObject.mWidth;
		mHeight = InObject.mHeight;
		mColor = InObject.mColor;
		mCrientPos = InObject.mCrientPos;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hGUIWindow, hGUIObj>("hGUIWindow")
			.addFunction("__tostring", &hGUIWindow::ToString)
			.addFunction("GetPtrAddr", &hGUIWindow::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mName", &hGUIWindow::mName)
			.addProperty("mWidth", &hGUIWindow::mWidth)
			.addProperty("mHeight", &hGUIWindow::mHeight)
			.addProperty("mColor", &hGUIWindow::mColor)
			.addProperty("mCrientPos", &hGUIWindow::mCrientPos)
			.addProperty("mFlag", &hGUIWindow::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUIWindow::mName) == 32, "expected hGUIWindow::mName to be size 32");
static_assert(sizeof(hGUIWindow::mWidth) == 4, "expected hGUIWindow::mWidth to be size 4");
static_assert(sizeof(hGUIWindow::mHeight) == 4, "expected hGUIWindow::mHeight to be size 4");
static_assert(sizeof(hGUIWindow::mColor) == 4, "expected hGUIWindow::mColor to be size 4");
static_assert(sizeof(hGUIWindow::mCrientPos) == 12, "expected hGUIWindow::mCrientPos to be size 12");
static_assert(sizeof(hGUIWindow::mFlag) == 2, "expected hGUIWindow::mFlag to be size 2");
static_assert(sizeof(hGUIWindow) == 0x68, "expected hGUIWindow to be size 0x68");

// [Structure] class hGUISlideBar
class hGUISlideBar : public hGUIWindow
{
public:
	/// Struct member variables

	// <class hGUIWindow field_0, offset 0x0>
	// class hGUIWindow Super;

	// <class hRECT mCenter, offset 0x68>
	class hRECT mCenter;

	// <class hRECT mSlideRect, offset 0x7c>
	class hRECT mSlideRect;

	// <int32_t mMinNum, offset 0x90>
	int32_t mMinNum = 0;

	// <int32_t mMaxNum, offset 0x94>
	int32_t mMaxNum = 0;

	// <int32_t mNowNum, offset 0x98>
	int32_t mNowNum = 0;

	// <uint8_t mbDown, offset 0x9c>
	uint8_t mbDown = 0;

	// <Unidentified data segment, offset 0x9d>
private:
	char _UnidentifiedData_157[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUISlideBar [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUISlideBar& InObject)
	{
		mCenter = InObject.mCenter;
		mSlideRect = InObject.mSlideRect;
		mMinNum = InObject.mMinNum;
		mMaxNum = InObject.mMaxNum;
		mNowNum = InObject.mNowNum;
		mbDown = InObject.mbDown;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hGUISlideBar, hGUIWindow>("hGUISlideBar")
			.addFunction("__tostring", &hGUISlideBar::ToString)
			.addFunction("GetPtrAddr", &hGUISlideBar::GetPtrAddr)
			.addProperty("mCenter", &hGUISlideBar::mCenter)
			.addProperty("mSlideRect", &hGUISlideBar::mSlideRect)
			.addProperty("mMinNum", &hGUISlideBar::mMinNum)
			.addProperty("mMaxNum", &hGUISlideBar::mMaxNum)
			.addProperty("mNowNum", &hGUISlideBar::mNowNum)
			.addProperty("mbDown", &hGUISlideBar::mbDown)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUISlideBar::mCenter) == 20, "expected hGUISlideBar::mCenter to be size 20");
static_assert(sizeof(hGUISlideBar::mSlideRect) == 20, "expected hGUISlideBar::mSlideRect to be size 20");
static_assert(sizeof(hGUISlideBar::mMinNum) == 4, "expected hGUISlideBar::mMinNum to be size 4");
static_assert(sizeof(hGUISlideBar::mMaxNum) == 4, "expected hGUISlideBar::mMaxNum to be size 4");
static_assert(sizeof(hGUISlideBar::mNowNum) == 4, "expected hGUISlideBar::mNowNum to be size 4");
static_assert(sizeof(hGUISlideBar::mbDown) == 1, "expected hGUISlideBar::mbDown to be size 1");
static_assert(sizeof(hGUISlideBar) == 0xa0, "expected hGUISlideBar to be size 0xa0");

// [Structure] class hGUIKeyFrame
class hGUIKeyFrame : public hGUISlideBar
{
public:
	/// Struct member variables

	// <class hGUISlideBar field_0, offset 0x0>
	// class hGUISlideBar Super;

	// <int32_t mCopyKey, offset 0xa0>
	int32_t mCopyKey = 0;

	// <int32_t mSelectKey, offset 0xa4>
	int32_t mSelectKey = 0;

	// <int32_t mKeyNum, offset 0xa8>
	int32_t mKeyNum = 0;

	// <struct hPerticleKey* mpKey, offset 0xac>
	struct hPerticleKey* mpKey = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUIKeyFrame [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUIKeyFrame& InObject)
	{
		mCopyKey = InObject.mCopyKey;
		mSelectKey = InObject.mSelectKey;
		mKeyNum = InObject.mKeyNum;
		mpKey = InObject.mpKey;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hGUIKeyFrame, hGUISlideBar>("hGUIKeyFrame")
			.addFunction("__tostring", &hGUIKeyFrame::ToString)
			.addFunction("GetPtrAddr", &hGUIKeyFrame::GetPtrAddr)
			.addProperty("mCopyKey", &hGUIKeyFrame::mCopyKey)
			.addProperty("mSelectKey", &hGUIKeyFrame::mSelectKey)
			.addProperty("mKeyNum", &hGUIKeyFrame::mKeyNum)
			.addProperty("mpKey", &hGUIKeyFrame::mpKey)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUIKeyFrame::mCopyKey) == 4, "expected hGUIKeyFrame::mCopyKey to be size 4");
static_assert(sizeof(hGUIKeyFrame::mSelectKey) == 4, "expected hGUIKeyFrame::mSelectKey to be size 4");
static_assert(sizeof(hGUIKeyFrame::mKeyNum) == 4, "expected hGUIKeyFrame::mKeyNum to be size 4");
static_assert(sizeof(hGUIKeyFrame::mpKey) == 4, "expected hGUIKeyFrame::mpKey to be size 4");
static_assert(sizeof(hGUIKeyFrame) == 0xb0, "expected hGUIKeyFrame to be size 0xb0");

// [Structure] class hGUIUVEditor
class hGUIUVEditor
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[200];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUIUVEditor [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUIUVEditor& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hGUIUVEditor>("hGUIUVEditor")
			.addFunction("__tostring", &hGUIUVEditor::ToString)
			.addFunction("GetPtrAddr", &hGUIUVEditor::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUIUVEditor) == 0xc8, "expected hGUIUVEditor to be size 0xc8");

// [Structure] class hGUIMenuWindow
class hGUIMenuWindow : public hGUIWindow
{
public:
	/// Struct member variables

	// <class hGUIWindow field_0, offset 0x0>
	// class hGUIWindow Super;

	// <uint32_t mMenuColor, offset 0x68>
	uint32_t mMenuColor = 0;

	// <uint16_t mMenuFlag, offset 0x6c>
	uint16_t mMenuFlag = 0;

	// <Unidentified data segment, offset 0x6e>
private:
	char _UnidentifiedData_110[2];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUIMenuWindow [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUIMenuWindow& InObject)
	{
		mMenuColor = InObject.mMenuColor;
		mMenuFlag = InObject.mMenuFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hGUIMenuWindow, hGUIWindow>("hGUIMenuWindow")
			.addFunction("__tostring", &hGUIMenuWindow::ToString)
			.addFunction("GetPtrAddr", &hGUIMenuWindow::GetPtrAddr)
			.addProperty("mMenuColor", &hGUIMenuWindow::mMenuColor)
			.addProperty("mMenuFlag", &hGUIMenuWindow::mMenuFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUIMenuWindow::mMenuColor) == 4, "expected hGUIMenuWindow::mMenuColor to be size 4");
static_assert(sizeof(hGUIMenuWindow::mMenuFlag) == 2, "expected hGUIMenuWindow::mMenuFlag to be size 2");
static_assert(sizeof(hGUIMenuWindow) == 0x70, "expected hGUIMenuWindow to be size 0x70");

// [Structure] class hGUIColorPicker
class hGUIColorPicker : public hGUIMenuWindow
{
public:
	/// Struct member variables

	// <class hGUIMenuWindow field_0, offset 0x0>
	// class hGUIMenuWindow Super;

	// <struct Vec mSelectPoint, offset 0x70>
	struct Vec mSelectPoint;

	// <struct Vec mSelectH, offset 0x7c>
	struct Vec mSelectH;

	// <struct Vec mSelectAlpha, offset 0x88>
	struct Vec mSelectAlpha;

	// <uint32_t mSelectColor, offset 0x94>
	uint32_t mSelectColor = 0;

	// <int16_t mColorH, offset 0x98>
	int16_t mColorH = 0;

	// <uint8_t mColorS, offset 0x9a>
	uint8_t mColorS = 0;

	// <uint8_t mColorV, offset 0x9b>
	uint8_t mColorV = 0;

	// <uint8_t mColorA, offset 0x9c>
	uint8_t mColorA = 0;

	// <uint8_t mbColCatch, offset 0x9d>
	uint8_t mbColCatch = 0;

	// <uint8_t mbBarCatch, offset 0x9e>
	uint8_t mbBarCatch = 0;

	// <uint8_t mbAlphaCatch, offset 0x9f>
	uint8_t mbAlphaCatch = 0;

	// <uint16_t mColWidth, offset 0xa0>
	uint16_t mColWidth = 0;

	// <uint16_t mColHeight, offset 0xa2>
	uint16_t mColHeight = 0;

	// <uint16_t mBarWidth, offset 0xa4>
	uint16_t mBarWidth = 0;

	// <uint16_t mBarHeight, offset 0xa6>
	uint16_t mBarHeight = 0;

	// <uint16_t mAlphaWidth, offset 0xa8>
	uint16_t mAlphaWidth = 0;

	// <uint16_t mAlphaHeight, offset 0xaa>
	uint16_t mAlphaHeight = 0;

	// <class hRECT mHSVRect, offset 0xac>
	class hRECT mHSVRect;

	// <class hRECT mColorBarRect, offset 0xc0>
	class hRECT mColorBarRect;

	// <class hRECT mAlphaBarRect, offset 0xd4>
	class hRECT mAlphaBarRect;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUIColorPicker [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUIColorPicker& InObject)
	{
		mSelectPoint = InObject.mSelectPoint;
		mSelectH = InObject.mSelectH;
		mSelectAlpha = InObject.mSelectAlpha;
		mSelectColor = InObject.mSelectColor;
		mColorH = InObject.mColorH;
		mColorS = InObject.mColorS;
		mColorV = InObject.mColorV;
		mColorA = InObject.mColorA;
		mbColCatch = InObject.mbColCatch;
		mbBarCatch = InObject.mbBarCatch;
		mbAlphaCatch = InObject.mbAlphaCatch;
		mColWidth = InObject.mColWidth;
		mColHeight = InObject.mColHeight;
		mBarWidth = InObject.mBarWidth;
		mBarHeight = InObject.mBarHeight;
		mAlphaWidth = InObject.mAlphaWidth;
		mAlphaHeight = InObject.mAlphaHeight;
		mHSVRect = InObject.mHSVRect;
		mColorBarRect = InObject.mColorBarRect;
		mAlphaBarRect = InObject.mAlphaBarRect;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hGUIColorPicker, hGUIMenuWindow>("hGUIColorPicker")
			.addFunction("__tostring", &hGUIColorPicker::ToString)
			.addFunction("GetPtrAddr", &hGUIColorPicker::GetPtrAddr)
			.addProperty("mSelectPoint", &hGUIColorPicker::mSelectPoint)
			.addProperty("mSelectH", &hGUIColorPicker::mSelectH)
			.addProperty("mSelectAlpha", &hGUIColorPicker::mSelectAlpha)
			.addProperty("mSelectColor", &hGUIColorPicker::mSelectColor)
			.addProperty("mColorH", &hGUIColorPicker::mColorH)
			.addProperty("mColorS", &hGUIColorPicker::mColorS)
			.addProperty("mColorV", &hGUIColorPicker::mColorV)
			.addProperty("mColorA", &hGUIColorPicker::mColorA)
			.addProperty("mbColCatch", &hGUIColorPicker::mbColCatch)
			.addProperty("mbBarCatch", &hGUIColorPicker::mbBarCatch)
			.addProperty("mbAlphaCatch", &hGUIColorPicker::mbAlphaCatch)
			.addProperty("mColWidth", &hGUIColorPicker::mColWidth)
			.addProperty("mColHeight", &hGUIColorPicker::mColHeight)
			.addProperty("mBarWidth", &hGUIColorPicker::mBarWidth)
			.addProperty("mBarHeight", &hGUIColorPicker::mBarHeight)
			.addProperty("mAlphaWidth", &hGUIColorPicker::mAlphaWidth)
			.addProperty("mAlphaHeight", &hGUIColorPicker::mAlphaHeight)
			.addProperty("mHSVRect", &hGUIColorPicker::mHSVRect)
			.addProperty("mColorBarRect", &hGUIColorPicker::mColorBarRect)
			.addProperty("mAlphaBarRect", &hGUIColorPicker::mAlphaBarRect)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUIColorPicker::mSelectPoint) == 12, "expected hGUIColorPicker::mSelectPoint to be size 12");
static_assert(sizeof(hGUIColorPicker::mSelectH) == 12, "expected hGUIColorPicker::mSelectH to be size 12");
static_assert(sizeof(hGUIColorPicker::mSelectAlpha) == 12, "expected hGUIColorPicker::mSelectAlpha to be size 12");
static_assert(sizeof(hGUIColorPicker::mSelectColor) == 4, "expected hGUIColorPicker::mSelectColor to be size 4");
static_assert(sizeof(hGUIColorPicker::mColorH) == 2, "expected hGUIColorPicker::mColorH to be size 2");
static_assert(sizeof(hGUIColorPicker::mColorS) == 1, "expected hGUIColorPicker::mColorS to be size 1");
static_assert(sizeof(hGUIColorPicker::mColorV) == 1, "expected hGUIColorPicker::mColorV to be size 1");
static_assert(sizeof(hGUIColorPicker::mColorA) == 1, "expected hGUIColorPicker::mColorA to be size 1");
static_assert(sizeof(hGUIColorPicker::mbColCatch) == 1, "expected hGUIColorPicker::mbColCatch to be size 1");
static_assert(sizeof(hGUIColorPicker::mbBarCatch) == 1, "expected hGUIColorPicker::mbBarCatch to be size 1");
static_assert(sizeof(hGUIColorPicker::mbAlphaCatch) == 1, "expected hGUIColorPicker::mbAlphaCatch to be size 1");
static_assert(sizeof(hGUIColorPicker::mColWidth) == 2, "expected hGUIColorPicker::mColWidth to be size 2");
static_assert(sizeof(hGUIColorPicker::mColHeight) == 2, "expected hGUIColorPicker::mColHeight to be size 2");
static_assert(sizeof(hGUIColorPicker::mBarWidth) == 2, "expected hGUIColorPicker::mBarWidth to be size 2");
static_assert(sizeof(hGUIColorPicker::mBarHeight) == 2, "expected hGUIColorPicker::mBarHeight to be size 2");
static_assert(sizeof(hGUIColorPicker::mAlphaWidth) == 2, "expected hGUIColorPicker::mAlphaWidth to be size 2");
static_assert(sizeof(hGUIColorPicker::mAlphaHeight) == 2, "expected hGUIColorPicker::mAlphaHeight to be size 2");
static_assert(sizeof(hGUIColorPicker::mHSVRect) == 20, "expected hGUIColorPicker::mHSVRect to be size 20");
static_assert(sizeof(hGUIColorPicker::mColorBarRect) == 20, "expected hGUIColorPicker::mColorBarRect to be size 20");
static_assert(sizeof(hGUIColorPicker::mAlphaBarRect) == 20, "expected hGUIColorPicker::mAlphaBarRect to be size 20");
static_assert(sizeof(hGUIColorPicker) == 0xe8, "expected hGUIColorPicker to be size 0xe8");

// [Structure] class hGUICursor
class hGUICursor : public hGUIObj
{
public:
	/// Struct member variables

	// <class hGUIObj field_0, offset 0x0>
	// class hGUIObj Super;

	// <uint16_t mClickInterval, offset 0x2c>
	uint16_t mClickInterval = 0;

	// <uint16_t mClickCnt, offset 0x2e>
	uint16_t mClickCnt = 0;

	// <uint8_t mHoldFlag, offset 0x30>
	uint8_t mHoldFlag = 0;

	// <Unidentified data segment, offset 0x31>
private:
	char _UnidentifiedData_49[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUICursor [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUICursor& InObject)
	{
		mClickInterval = InObject.mClickInterval;
		mClickCnt = InObject.mClickCnt;
		mHoldFlag = InObject.mHoldFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hGUICursor, hGUIObj>("hGUICursor")
			.addFunction("__tostring", &hGUICursor::ToString)
			.addFunction("GetPtrAddr", &hGUICursor::GetPtrAddr)
			.addProperty("mClickInterval", &hGUICursor::mClickInterval)
			.addProperty("mClickCnt", &hGUICursor::mClickCnt)
			.addProperty("mHoldFlag", &hGUICursor::mHoldFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUICursor::mClickInterval) == 2, "expected hGUICursor::mClickInterval to be size 2");
static_assert(sizeof(hGUICursor::mClickCnt) == 2, "expected hGUICursor::mClickCnt to be size 2");
static_assert(sizeof(hGUICursor::mHoldFlag) == 1, "expected hGUICursor::mHoldFlag to be size 1");
static_assert(sizeof(hGUICursor) == 0x34, "expected hGUICursor to be size 0x34");

// [Structure] class hGUIManager
class hGUIManager : public hList<hGUIObj>
{
public:
	/// Struct member variables

	// <class hList<hGUIObj> field_0, offset 0x0>
	// class hList<hGUIObj> Super;

	// <class hGUIObj* mpCursor, offset 0xc>
	class hGUIObj* mpCursor = nullptr;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUIManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUIManager& InObject)
	{
		mpCursor = InObject.mpCursor;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hGUIManager>("hGUIManager")
			.addFunction("__tostring", &hGUIManager::ToString)
			.addFunction("GetPtrAddr", &hGUIManager::GetPtrAddr)
			.addProperty("mpCursor", &hGUIManager::mpCursor)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUIManager::mpCursor) == 4, "expected hGUIManager::mpCursor to be size 4");
static_assert(sizeof(hGUIManager) == 0x10, "expected hGUIManager to be size 0x10");

// [Structure] class rCamera
class rCamera
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <struct Vec m_Point, offset 0x4>
	struct Vec m_Point;

	// <struct Vec m_Target, offset 0x10>
	struct Vec m_Target;

	// <struct Vec m_Up, offset 0x1c>
	struct Vec m_Up;

	// <float m_Speed, offset 0x28>
	float m_Speed = 0;

	// <uint8_t m_BitFlag, offset 0x2c>
	uint8_t m_BitFlag = 0;

	// <Unidentified data segment, offset 0x2d>
private:
	char _UnidentifiedData_45[3];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class rCamera [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(rCamera& InObject)
	{
		m_Point = InObject.m_Point;
		m_Target = InObject.m_Target;
		m_Up = InObject.m_Up;
		m_Speed = InObject.m_Speed;
		m_BitFlag = InObject.m_BitFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rCamera>("rCamera")
			.addFunction("__tostring", &rCamera::ToString)
			.addFunction("GetPtrAddr", &rCamera::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &rCamera::field_0)
			.addProperty("m_Point", &rCamera::m_Point)
			.addProperty("m_Target", &rCamera::m_Target)
			.addProperty("m_Up", &rCamera::m_Up)
			.addProperty("m_Speed", &rCamera::m_Speed)
			.addProperty("m_BitFlag", &rCamera::m_BitFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(rCamera::field_0) == 4, "expected rCamera::field_0 to be size 4");
static_assert(sizeof(rCamera::m_Point) == 12, "expected rCamera::m_Point to be size 12");
static_assert(sizeof(rCamera::m_Target) == 12, "expected rCamera::m_Target to be size 12");
static_assert(sizeof(rCamera::m_Up) == 12, "expected rCamera::m_Up to be size 12");
static_assert(sizeof(rCamera::m_Speed) == 4, "expected rCamera::m_Speed to be size 4");
static_assert(sizeof(rCamera::m_BitFlag) == 1, "expected rCamera::m_BitFlag to be size 1");
static_assert(sizeof(rCamera) == 0x30, "expected rCamera to be size 0x30");

// [Structure] class hEffectEdit
class hEffectEdit
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class ghmResGroup* mpResource, offset 0x4>
	class ghmResGroup* mpResource = nullptr;

	// <class rCamera mCamera, offset 0x8>
	class rCamera mCamera;

	// <class hGUIManager mManager, offset 0x38>
	class hGUIManager mManager;

	// <class hGUICursor mCursor, offset 0x48>
	class hGUICursor mCursor;

	// <class hEffMenu* mMenu, offset 0x7c>
	class hEffMenu* mMenu = nullptr;

	// <class hGUIColorPicker mCPicker, offset 0x80>
	class hGUIColorPicker mCPicker;

	// <class hGUIMenuWindow mTexWindow, offset 0x168>
	class hGUIMenuWindow mTexWindow;

	// <class hGUIButton* mTexButton, offset 0x1d8>
	class hGUIButton* mTexButton = nullptr;

	// <class hGUIMenuWindow mAnimPatWindow, offset 0x1dc>
	class hGUIMenuWindow mAnimPatWindow;

	// <class hGUIButton* mAnimPatButton, offset 0x24c>
	class hGUIButton* mAnimPatButton = nullptr;

	// <class hGUIUVEditor mUvEdit, offset 0x250>
	class hGUIUVEditor mUvEdit;

	// <class hGUIKeyFrame mKeyFrame, offset 0x318>
	class hGUIKeyFrame mKeyFrame;

	// <class hGUIMenuWindow mFileWindow, offset 0x3c8>
	class hGUIMenuWindow mFileWindow;

	// <class hGUIButton* mFileButton, offset 0x438>
	class hGUIButton* mFileButton = nullptr;

	// <class hEffect* mpEffect, offset 0x43c>
	class hEffect* mpEffect = nullptr;

	// <struct hPerticleKey mTempKey, offset 0x440>
	struct hPerticleKey mTempKey;

	// <int32_t mSelectKey, offset 0x468>
	int32_t mSelectKey = 0;

	// <int32_t mSelectLayer, offset 0x46c>
	int32_t mSelectLayer = 0;

	// <uint32_t mFileNum, offset 0x470>
	uint32_t mFileNum = 0;

	// <uint32_t mTexNum, offset 0x474>
	uint32_t mTexNum = 0;

	// <struct tagGHMR_TEX* mTexture, offset 0x478>
	struct tagGHMR_TEX* mTexture = nullptr;

	// <uint32_t mAnimNum, offset 0x47c>
	uint32_t mAnimNum = 0;

	// <class hAnimTex* mAnimTex, offset 0x480>
	class hAnimTex* mAnimTex = nullptr;

	// <uint8_t mFrameStart, offset 0x484>
	uint8_t mFrameStart = 0;

	// <uint8_t mCopyFlag, offset 0x485>
	uint8_t mCopyFlag = 0;

	// <Unidentified data segment, offset 0x486>
private:
	char _UnidentifiedData_1158[2];

public:
	// <int32_t mVisibleMode, offset 0x488>
	int32_t mVisibleMode = 0;

	// <uint32_t mBgColor, offset 0x48c>
	uint32_t mBgColor = 0;

	/// 1 Functions

	// [Function] void __convention("thiscall") hEffectEdit::SetResource(class hEffectEdit* const this, class ghmResGroup* arg2) [?SetResource@hEffectEdit@@QAEXPAVghmResGroup@@@Z]
	typedef void(__thiscall* _SetResource_hEffectEdit__QAEXPAVghmResGroup___Z)(class hEffectEdit* const thisPtr, class ghmResGroup* arg2);
	void SetResource(class ghmResGroup* arg2)
	{
		_SetResource_hEffectEdit__QAEXPAVghmResGroup___Z mFunc = (_SetResource_hEffectEdit__QAEXPAVghmResGroup___Z)(GameModule + 0x681400);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hEffectEdit [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hEffectEdit& InObject)
	{
		mpResource = InObject.mpResource;
		mCamera = InObject.mCamera;
		mManager = InObject.mManager;
		mCursor = InObject.mCursor;
		mMenu = InObject.mMenu;
		mCPicker = InObject.mCPicker;
		mTexWindow = InObject.mTexWindow;
		mTexButton = InObject.mTexButton;
		mAnimPatWindow = InObject.mAnimPatWindow;
		mAnimPatButton = InObject.mAnimPatButton;
		mUvEdit = InObject.mUvEdit;
		mKeyFrame = InObject.mKeyFrame;
		mFileWindow = InObject.mFileWindow;
		mFileButton = InObject.mFileButton;
		mpEffect = InObject.mpEffect;
		mTempKey = InObject.mTempKey;
		mSelectKey = InObject.mSelectKey;
		mSelectLayer = InObject.mSelectLayer;
		mFileNum = InObject.mFileNum;
		mTexNum = InObject.mTexNum;
		mTexture = InObject.mTexture;
		mAnimNum = InObject.mAnimNum;
		mAnimTex = InObject.mAnimTex;
		mFrameStart = InObject.mFrameStart;
		mCopyFlag = InObject.mCopyFlag;
		mVisibleMode = InObject.mVisibleMode;
		mBgColor = InObject.mBgColor;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hEffectEdit>("hEffectEdit")
			.addFunction("__tostring", &hEffectEdit::ToString)
			.addFunction("GetPtrAddr", &hEffectEdit::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &hEffectEdit::field_0)
			.addProperty("mpResource", &hEffectEdit::mpResource)
			.addProperty("mCamera", &hEffectEdit::mCamera)
			.addProperty("mManager", &hEffectEdit::mManager)
			.addProperty("mCursor", &hEffectEdit::mCursor)
			.addProperty("mMenu", &hEffectEdit::mMenu)
			.addProperty("mCPicker", &hEffectEdit::mCPicker)
			.addProperty("mTexWindow", &hEffectEdit::mTexWindow)
			.addProperty("mTexButton", &hEffectEdit::mTexButton)
			.addProperty("mAnimPatWindow", &hEffectEdit::mAnimPatWindow)
			.addProperty("mAnimPatButton", &hEffectEdit::mAnimPatButton)
			.addProperty("mUvEdit", &hEffectEdit::mUvEdit)
			.addProperty("mKeyFrame", &hEffectEdit::mKeyFrame)
			.addProperty("mFileWindow", &hEffectEdit::mFileWindow)
			.addProperty("mFileButton", &hEffectEdit::mFileButton)
			.addProperty("mpEffect", &hEffectEdit::mpEffect)
			.addProperty("mTempKey", &hEffectEdit::mTempKey)
			.addProperty("mSelectKey", &hEffectEdit::mSelectKey)
			.addProperty("mSelectLayer", &hEffectEdit::mSelectLayer)
			.addProperty("mFileNum", &hEffectEdit::mFileNum)
			.addProperty("mTexNum", &hEffectEdit::mTexNum)
			.addProperty("mTexture", &hEffectEdit::mTexture)
			.addProperty("mAnimNum", &hEffectEdit::mAnimNum)
			.addProperty("mAnimTex", &hEffectEdit::mAnimTex)
			.addProperty("mFrameStart", &hEffectEdit::mFrameStart)
			.addProperty("mCopyFlag", &hEffectEdit::mCopyFlag)
			.addProperty("mVisibleMode", &hEffectEdit::mVisibleMode)
			.addProperty("mBgColor", &hEffectEdit::mBgColor)
			.addFunction("SetResource", &hEffectEdit::SetResource)
		.endClass();
	}
#endif
};
static_assert(sizeof(hEffectEdit::field_0) == 4, "expected hEffectEdit::field_0 to be size 4");
static_assert(sizeof(hEffectEdit::mpResource) == 4, "expected hEffectEdit::mpResource to be size 4");
static_assert(sizeof(hEffectEdit::mCamera) == 48, "expected hEffectEdit::mCamera to be size 48");
static_assert(sizeof(hEffectEdit::mManager) == 16, "expected hEffectEdit::mManager to be size 16");
static_assert(sizeof(hEffectEdit::mCursor) == 52, "expected hEffectEdit::mCursor to be size 52");
static_assert(sizeof(hEffectEdit::mMenu) == 4, "expected hEffectEdit::mMenu to be size 4");
static_assert(sizeof(hEffectEdit::mCPicker) == 232, "expected hEffectEdit::mCPicker to be size 232");
static_assert(sizeof(hEffectEdit::mTexWindow) == 112, "expected hEffectEdit::mTexWindow to be size 112");
static_assert(sizeof(hEffectEdit::mTexButton) == 4, "expected hEffectEdit::mTexButton to be size 4");
static_assert(sizeof(hEffectEdit::mAnimPatWindow) == 112, "expected hEffectEdit::mAnimPatWindow to be size 112");
static_assert(sizeof(hEffectEdit::mAnimPatButton) == 4, "expected hEffectEdit::mAnimPatButton to be size 4");
static_assert(sizeof(hEffectEdit::mUvEdit) == 200, "expected hEffectEdit::mUvEdit to be size 200");
static_assert(sizeof(hEffectEdit::mKeyFrame) == 176, "expected hEffectEdit::mKeyFrame to be size 176");
static_assert(sizeof(hEffectEdit::mFileWindow) == 112, "expected hEffectEdit::mFileWindow to be size 112");
static_assert(sizeof(hEffectEdit::mFileButton) == 4, "expected hEffectEdit::mFileButton to be size 4");
static_assert(sizeof(hEffectEdit::mpEffect) == 4, "expected hEffectEdit::mpEffect to be size 4");
static_assert(sizeof(hEffectEdit::mTempKey) == 40, "expected hEffectEdit::mTempKey to be size 40");
static_assert(sizeof(hEffectEdit::mSelectKey) == 4, "expected hEffectEdit::mSelectKey to be size 4");
static_assert(sizeof(hEffectEdit::mSelectLayer) == 4, "expected hEffectEdit::mSelectLayer to be size 4");
static_assert(sizeof(hEffectEdit::mFileNum) == 4, "expected hEffectEdit::mFileNum to be size 4");
static_assert(sizeof(hEffectEdit::mTexNum) == 4, "expected hEffectEdit::mTexNum to be size 4");
static_assert(sizeof(hEffectEdit::mTexture) == 4, "expected hEffectEdit::mTexture to be size 4");
static_assert(sizeof(hEffectEdit::mAnimNum) == 4, "expected hEffectEdit::mAnimNum to be size 4");
static_assert(sizeof(hEffectEdit::mAnimTex) == 4, "expected hEffectEdit::mAnimTex to be size 4");
static_assert(sizeof(hEffectEdit::mFrameStart) == 1, "expected hEffectEdit::mFrameStart to be size 1");
static_assert(sizeof(hEffectEdit::mCopyFlag) == 1, "expected hEffectEdit::mCopyFlag to be size 1");
static_assert(sizeof(hEffectEdit::mVisibleMode) == 4, "expected hEffectEdit::mVisibleMode to be size 4");
static_assert(sizeof(hEffectEdit::mBgColor) == 4, "expected hEffectEdit::mBgColor to be size 4");
static_assert(sizeof(hEffectEdit) == 0x490, "expected hEffectEdit to be size 0x490");

// [Structure] class hEffMenu
class hEffMenu
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[6184];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hEffMenu [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hEffMenu& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hEffMenu>("hEffMenu")
			.addFunction("__tostring", &hEffMenu::ToString)
			.addFunction("GetPtrAddr", &hEffMenu::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(hEffMenu) == 0x1828, "expected hEffMenu to be size 0x1828");

// [Structure] class hGUIButton
class hGUIButton : public hGUIWindow
{
public:
	/// Struct member variables

	// <class hGUIWindow field_0, offset 0x0>
	// class hGUIWindow Super;

	// <uint32_t mFontColor, offset 0x68>
	uint32_t mFontColor = 0;

	// <uint32_t mSelectColor, offset 0x6c>
	uint32_t mSelectColor = 0;

	// <int32_t mNamePos, offset 0x70>
	int32_t mNamePos = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hGUIButton [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hGUIButton& InObject)
	{
		mFontColor = InObject.mFontColor;
		mSelectColor = InObject.mSelectColor;
		mNamePos = InObject.mNamePos;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hGUIButton, hGUIWindow>("hGUIButton")
			.addFunction("__tostring", &hGUIButton::ToString)
			.addFunction("GetPtrAddr", &hGUIButton::GetPtrAddr)
			.addProperty("mFontColor", &hGUIButton::mFontColor)
			.addProperty("mSelectColor", &hGUIButton::mSelectColor)
			.addProperty("mNamePos", &hGUIButton::mNamePos)
		.endClass();
	}
#endif
};
static_assert(sizeof(hGUIButton::mFontColor) == 4, "expected hGUIButton::mFontColor to be size 4");
static_assert(sizeof(hGUIButton::mSelectColor) == 4, "expected hGUIButton::mSelectColor to be size 4");
static_assert(sizeof(hGUIButton::mNamePos) == 4, "expected hGUIButton::mNamePos to be size 4");
static_assert(sizeof(hGUIButton) == 0x74, "expected hGUIButton to be size 0x74");

// enum BJ2_DIFFICULT
enum BJ2_DIFFICULT : uint32_t
{
	// <BJ2_EASY = 0x0>
	BJ2_EASY = 0,

	// <BJ2_NORMAL = 0x1>
	BJ2_NORMAL = 1,

	// <BJ2_HARD = 0x2>
	BJ2_HARD = 2,

	// <BJ2_NIGHTMARE = 0x3>
	BJ2_NIGHTMARE = 3

};

// [Structure] class hBj2Stage
class hBj2Stage
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <int32_t mTimeCnt, offset 0x4>
	int32_t mTimeCnt = 0;

	// <class TGmf* mStageModel, offset 0x8>
	class TGmf* mStageModel = nullptr;

	// <class TGan* mStageMotion, offset 0xc>
	class TGan* mStageMotion = nullptr;

	// <class hBj2Player* mpPlayer, offset 0x10>
	class hBj2Player* mpPlayer = nullptr;

	// <class hBj2ObjManager* mpManager, offset 0x14>
	class hBj2ObjManager* mpManager = nullptr;

	// <struct hBj2TimeTable* mpTimeTable, offset 0x18>
	struct hBj2TimeTable* mpTimeTable = nullptr;

	// <int32_t mTableNum, offset 0x1c>
	int32_t mTableNum = 0;

	// <int32_t mTableIndex, offset 0x20>
	int32_t mTableIndex = 0;

	// <int32_t mTableCnt, offset 0x24>
	int32_t mTableCnt = 0;

	// <class ghmResGroup* mpResource, offset 0x28>
	class ghmResGroup* mpResource = nullptr;

	// <enum BJ2_DIFFICULT mDifficult, offset 0x2c>
	enum BJ2_DIFFICULT mDifficult;

	// <float mStagePosZ, offset 0x30>
	float mStagePosZ = 0;

	// <uint8_t mbPause, offset 0x34>
	uint8_t mbPause = 0;

	// <uint8_t mbBossApproach, offset 0x35>
	uint8_t mbBossApproach = 0;

	// <Unidentified data segment, offset 0x36>
private:
	char _UnidentifiedData_54[2];

public:
	/// 1 Functions

	// [Function] void __convention("thiscall") hBj2Stage::Load(class hBj2Stage* const this, class ghmResGroup* arg2, class hBj2Player* arg3, int32_t arg4, struct hBj2TimeTable* arg5, class hBj2ObjManager* arg6) [?Load@hBj2Stage@@QAEXPAVghmResGroup@@PAVhBj2Player@@HPAUhBj2TimeTable@@PAVhBj2ObjManager@@@Z]
	typedef void(__thiscall* _Load_hBj2Stage__QAEXPAVghmResGroup__PAVhBj2Player__HPAUhBj2TimeTable__PAVhBj2ObjManager___Z)(class hBj2Stage* const thisPtr, class ghmResGroup* arg2, class hBj2Player* arg3, int32_t arg4, struct hBj2TimeTable* arg5, class hBj2ObjManager* arg6);
	void Load(class ghmResGroup* arg2, class hBj2Player* arg3, int32_t arg4, struct hBj2TimeTable* arg5, class hBj2ObjManager* arg6)
	{
		_Load_hBj2Stage__QAEXPAVghmResGroup__PAVhBj2Player__HPAUhBj2TimeTable__PAVhBj2ObjManager___Z mFunc = (_Load_hBj2Stage__QAEXPAVghmResGroup__PAVhBj2Player__HPAUhBj2TimeTable__PAVhBj2ObjManager___Z)(GameModule + 0x6944a0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hBj2Stage [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hBj2Stage& InObject)
	{
		mTimeCnt = InObject.mTimeCnt;
		mStageModel = InObject.mStageModel;
		mStageMotion = InObject.mStageMotion;
		mpPlayer = InObject.mpPlayer;
		mpManager = InObject.mpManager;
		mpTimeTable = InObject.mpTimeTable;
		mTableNum = InObject.mTableNum;
		mTableIndex = InObject.mTableIndex;
		mTableCnt = InObject.mTableCnt;
		mpResource = InObject.mpResource;
		mDifficult = InObject.mDifficult;
		mStagePosZ = InObject.mStagePosZ;
		mbPause = InObject.mbPause;
		mbBossApproach = InObject.mbBossApproach;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hBj2Stage>("hBj2Stage")
			.addFunction("__tostring", &hBj2Stage::ToString)
			.addFunction("GetPtrAddr", &hBj2Stage::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &hBj2Stage::field_0)
			.addProperty("mTimeCnt", &hBj2Stage::mTimeCnt)
			.addProperty("mStageModel", &hBj2Stage::mStageModel)
			.addProperty("mStageMotion", &hBj2Stage::mStageMotion)
			.addProperty("mpPlayer", &hBj2Stage::mpPlayer)
			.addProperty("mpManager", &hBj2Stage::mpManager)
			.addProperty("mpTimeTable", &hBj2Stage::mpTimeTable)
			.addProperty("mTableNum", &hBj2Stage::mTableNum)
			.addProperty("mTableIndex", &hBj2Stage::mTableIndex)
			.addProperty("mTableCnt", &hBj2Stage::mTableCnt)
			.addProperty("mpResource", &hBj2Stage::mpResource)
			.addProperty("mDifficult", &hBj2Stage::mDifficult)
			.addProperty("mStagePosZ", &hBj2Stage::mStagePosZ)
			.addProperty("mbPause", &hBj2Stage::mbPause)
			.addProperty("mbBossApproach", &hBj2Stage::mbBossApproach)
			.addFunction("Load", &hBj2Stage::Load)
		.endClass();
	}
#endif
};
static_assert(sizeof(hBj2Stage::field_0) == 4, "expected hBj2Stage::field_0 to be size 4");
static_assert(sizeof(hBj2Stage::mTimeCnt) == 4, "expected hBj2Stage::mTimeCnt to be size 4");
static_assert(sizeof(hBj2Stage::mStageModel) == 4, "expected hBj2Stage::mStageModel to be size 4");
static_assert(sizeof(hBj2Stage::mStageMotion) == 4, "expected hBj2Stage::mStageMotion to be size 4");
static_assert(sizeof(hBj2Stage::mpPlayer) == 4, "expected hBj2Stage::mpPlayer to be size 4");
static_assert(sizeof(hBj2Stage::mpManager) == 4, "expected hBj2Stage::mpManager to be size 4");
static_assert(sizeof(hBj2Stage::mpTimeTable) == 4, "expected hBj2Stage::mpTimeTable to be size 4");
static_assert(sizeof(hBj2Stage::mTableNum) == 4, "expected hBj2Stage::mTableNum to be size 4");
static_assert(sizeof(hBj2Stage::mTableIndex) == 4, "expected hBj2Stage::mTableIndex to be size 4");
static_assert(sizeof(hBj2Stage::mTableCnt) == 4, "expected hBj2Stage::mTableCnt to be size 4");
static_assert(sizeof(hBj2Stage::mpResource) == 4, "expected hBj2Stage::mpResource to be size 4");
static_assert(sizeof(hBj2Stage::mDifficult) == 4, "expected hBj2Stage::mDifficult to be size 4");
static_assert(sizeof(hBj2Stage::mStagePosZ) == 4, "expected hBj2Stage::mStagePosZ to be size 4");
static_assert(sizeof(hBj2Stage::mbPause) == 1, "expected hBj2Stage::mbPause to be size 1");
static_assert(sizeof(hBj2Stage::mbBossApproach) == 1, "expected hBj2Stage::mbBossApproach to be size 1");
static_assert(sizeof(hBj2Stage) == 0x38, "expected hBj2Stage to be size 0x38");

// enum BJ2OBJTYPE
enum BJ2OBJTYPE : uint32_t
{
	// <BJ2OBJTYPE_UNKNOWN = 0x0>
	BJ2OBJTYPE_UNKNOWN = 0,

	// <BJ2OBJTYPE_PLAYER = 0x1>
	BJ2OBJTYPE_PLAYER = 1,

	// <BJ2OBJTYPE_ENEMY = 0x2>
	BJ2OBJTYPE_ENEMY = 2,

	// <BJ2OBJTYPE_BOSS = 0x3>
	BJ2OBJTYPE_BOSS = 3,

	// <BJ2OBJTYPE_SHOT = 0x4>
	BJ2OBJTYPE_SHOT = 4,

	// <BJ2OBJTYPE_BOMB = 0x5>
	BJ2OBJTYPE_BOMB = 5,

	// <BJ2OBJTYPE_ITEM = 0x6>
	BJ2OBJTYPE_ITEM = 6,

	// <BJ2OBJTYPE_WALL = 0x7>
	BJ2OBJTYPE_WALL = 7,

	// <BJ2OBJTYPE_BARRIER = 0x8>
	BJ2OBJTYPE_BARRIER = 8

};

// [Structure] class hBj2Obj
class hBj2Obj : public hListObj<hBj2Obj>
{
public:
	/// Struct member variables

	// <class hListObj<hBj2Obj> field_0, offset 0x0>
	// class hListObj<hBj2Obj> Super;

	// <struct Vec mPos, offset 0xc>
	struct Vec mPos;

	// <struct Vec mRot, offset 0x18>
	struct Vec mRot;

	// <float mWidth, offset 0x24>
	float mWidth = 0;

	// <float mHeight, offset 0x28>
	float mHeight = 0;

	// <int32_t mScore, offset 0x2c>
	int32_t mScore = 0;

	// <float mSpeed, offset 0x30>
	float mSpeed = 0;

	// <int32_t mHP, offset 0x34>
	int32_t mHP = 0;

	// <int32_t mCount, offset 0x38>
	int32_t mCount = 0;

	// <float mRadius, offset 0x3c>
	float mRadius = 0;

	// <class hBj2ObjManager* mParentManager, offset 0x40>
	class hBj2ObjManager* mParentManager = nullptr;

	// <enum BJ2OBJTYPE mType, offset 0x44>
	enum BJ2OBJTYPE mType;

	// <uint32_t mFlag, offset 0x48>
	uint32_t mFlag = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hBj2Obj [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hBj2Obj& InObject)
	{
		mPos = InObject.mPos;
		mRot = InObject.mRot;
		mWidth = InObject.mWidth;
		mHeight = InObject.mHeight;
		mScore = InObject.mScore;
		mSpeed = InObject.mSpeed;
		mHP = InObject.mHP;
		mCount = InObject.mCount;
		mRadius = InObject.mRadius;
		mParentManager = InObject.mParentManager;
		mType = InObject.mType;
		mFlag = InObject.mFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hBj2Obj>("hBj2Obj")
			.addFunction("__tostring", &hBj2Obj::ToString)
			.addFunction("GetPtrAddr", &hBj2Obj::GetPtrAddr)
			.addProperty("mPos", &hBj2Obj::mPos)
			.addProperty("mRot", &hBj2Obj::mRot)
			.addProperty("mWidth", &hBj2Obj::mWidth)
			.addProperty("mHeight", &hBj2Obj::mHeight)
			.addProperty("mScore", &hBj2Obj::mScore)
			.addProperty("mSpeed", &hBj2Obj::mSpeed)
			.addProperty("mHP", &hBj2Obj::mHP)
			.addProperty("mCount", &hBj2Obj::mCount)
			.addProperty("mRadius", &hBj2Obj::mRadius)
			.addProperty("mParentManager", &hBj2Obj::mParentManager)
			.addProperty("mType", &hBj2Obj::mType)
			.addProperty("mFlag", &hBj2Obj::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(hBj2Obj::mPos) == 12, "expected hBj2Obj::mPos to be size 12");
static_assert(sizeof(hBj2Obj::mRot) == 12, "expected hBj2Obj::mRot to be size 12");
static_assert(sizeof(hBj2Obj::mWidth) == 4, "expected hBj2Obj::mWidth to be size 4");
static_assert(sizeof(hBj2Obj::mHeight) == 4, "expected hBj2Obj::mHeight to be size 4");
static_assert(sizeof(hBj2Obj::mScore) == 4, "expected hBj2Obj::mScore to be size 4");
static_assert(sizeof(hBj2Obj::mSpeed) == 4, "expected hBj2Obj::mSpeed to be size 4");
static_assert(sizeof(hBj2Obj::mHP) == 4, "expected hBj2Obj::mHP to be size 4");
static_assert(sizeof(hBj2Obj::mCount) == 4, "expected hBj2Obj::mCount to be size 4");
static_assert(sizeof(hBj2Obj::mRadius) == 4, "expected hBj2Obj::mRadius to be size 4");
static_assert(sizeof(hBj2Obj::mParentManager) == 4, "expected hBj2Obj::mParentManager to be size 4");
static_assert(sizeof(hBj2Obj::mType) == 4, "expected hBj2Obj::mType to be size 4");
static_assert(sizeof(hBj2Obj::mFlag) == 4, "expected hBj2Obj::mFlag to be size 4");
static_assert(sizeof(hBj2Obj) == 0x4c, "expected hBj2Obj to be size 0x4c");

// [Structure] class hBj2Model
class hBj2Model : public hBj2Obj
{
public:
	/// Struct member variables

	// <class hBj2Obj field_0, offset 0x0>
	// class hBj2Obj Super;

	// <class TGmf* mModel, offset 0x4c>
	class TGmf* mModel = nullptr;

	// <class TGan** mMotion, offset 0x50>
	class TGan** mMotion = nullptr;

	// <int32_t mMotionNum, offset 0x54>
	int32_t mMotionNum = 0;

	// <int32_t mNowMotion, offset 0x58>
	int32_t mNowMotion = 0;

	/// 1 Functions

	// [Function] void __convention("thiscall") hBj2Model::LoadMotion(class hBj2Model* const this, class ghmResGroup* arg2) [?LoadMotion@hBj2Model@@QAEXPAVghmResGroup@@@Z]
	typedef void(__thiscall* _LoadMotion_hBj2Model__QAEXPAVghmResGroup___Z)(class hBj2Model* const thisPtr, class ghmResGroup* arg2);
	void LoadMotion(class ghmResGroup* arg2)
	{
		_LoadMotion_hBj2Model__QAEXPAVghmResGroup___Z mFunc = (_LoadMotion_hBj2Model__QAEXPAVghmResGroup___Z)(GameModule + 0x69d860);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hBj2Model [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hBj2Model& InObject)
	{
		mModel = InObject.mModel;
		mMotion = InObject.mMotion;
		mMotionNum = InObject.mMotionNum;
		mNowMotion = InObject.mNowMotion;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hBj2Model, hBj2Obj>("hBj2Model")
			.addFunction("__tostring", &hBj2Model::ToString)
			.addFunction("GetPtrAddr", &hBj2Model::GetPtrAddr)
			.addProperty("mModel", &hBj2Model::mModel)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mMotion", &hBj2Model::mMotion)
			.addProperty("mMotionNum", &hBj2Model::mMotionNum)
			.addProperty("mNowMotion", &hBj2Model::mNowMotion)
			.addFunction("LoadMotion", &hBj2Model::LoadMotion)
		.endClass();
	}
#endif
};
static_assert(sizeof(hBj2Model::mModel) == 4, "expected hBj2Model::mModel to be size 4");
static_assert(sizeof(hBj2Model::mMotion) == 4, "expected hBj2Model::mMotion to be size 4");
static_assert(sizeof(hBj2Model::mMotionNum) == 4, "expected hBj2Model::mMotionNum to be size 4");
static_assert(sizeof(hBj2Model::mNowMotion) == 4, "expected hBj2Model::mNowMotion to be size 4");
static_assert(sizeof(hBj2Model) == 0x5c, "expected hBj2Model to be size 0x5c");

// [Structure] class hBj2Player
class hBj2Player : public hBj2Model
{
public:
	// enum hBj2Player::BJ2PLAYER_STATE
	enum BJ2PLAYER_STATE : uint32_t
	{
		// <BJ2PLAYER_STATE_IN = 0x0>
		BJ2PLAYER_STATE_IN = 0,

		// <BJ2PLAYER_STATE_DEF = 0x1>
		BJ2PLAYER_STATE_DEF = 1,

		// <BJ2PLAYER_STATE_REVIVALWAIT = 0x2>
		BJ2PLAYER_STATE_REVIVALWAIT = 2,

		// <BJ2PLAYER_STATE_CONTINUEWAIT = 0x3>
		BJ2PLAYER_STATE_CONTINUEWAIT = 3,

		// <BJ2PLAYER_STATE_DEADWAIT = 0x4>
		BJ2PLAYER_STATE_DEADWAIT = 4,

		// <BJ2PLAYER_STATE_DEAD = 0x5>
		BJ2PLAYER_STATE_DEAD = 5,

		// <BJ2PLAYER_STATE_STAGECLEAR = 0x6>
		BJ2PLAYER_STATE_STAGECLEAR = 6,

		// <BJ2PLAYER_STATE_RETURNWAIT = 0x7>
		BJ2PLAYER_STATE_RETURNWAIT = 7,

		// <BJ2PLAYER_STATE_CHARSEL = 0x8>
		BJ2PLAYER_STATE_CHARSEL = 8

	};

	/// Struct member variables

	// <class hBj2Model field_0, offset 0x0>
	// class hBj2Model Super;

	// <int32_t mShotDir, offset 0x5c>
	int32_t mShotDir = 0;

	// <int32_t mPlayerType, offset 0x60>
	int32_t mPlayerType = 0;

	// <int32_t mDeadCnt, offset 0x64>
	int32_t mDeadCnt = 0;

	// <int32_t mRest, offset 0x68>
	int32_t mRest = 0;

	// <float mRotateX, offset 0x6c>
	float mRotateX = 0;

	// <int32_t mInvincibleTimeCnt, offset 0x70>
	int32_t mInvincibleTimeCnt = 0;

	// <int32_t mContinueCount, offset 0x74>
	int32_t mContinueCount = 0;

	// <enum hBj2Player::BJ2PLAYER_STATE mState, offset 0x78>
	enum hBj2Player::BJ2PLAYER_STATE mState;

	// <uint8_t mInvincible, offset 0x7c>
	uint8_t mInvincible = 0;

	// <uint8_t mNightmareFlag, offset 0x7d>
	uint8_t mNightmareFlag = 0;

	// <uint8_t mBossDeadFlag, offset 0x7e>
	uint8_t mBossDeadFlag = 0;

	// <Unidentified data segment, offset 0x7f>
private:
	char _UnidentifiedData_127[1];

public:
	// <int32_t mShotCounter, offset 0x80>
	int32_t mShotCounter = 0;

	// <int32_t mLocalCount, offset 0x84>
	int32_t mLocalCount = 0;

	// <int32_t mShotRimit, offset 0x88>
	int32_t mShotRimit = 0;

	// <int32_t mBGHandle, offset 0x8c>
	int32_t mBGHandle = 0;

	// <int32_t mBGHandle2, offset 0x90>
	int32_t mBGHandle2 = 0;

	// <int32_t mBGVol, offset 0x94>
	int32_t mBGVol = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hBj2Player [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hBj2Player& InObject)
	{
		mShotDir = InObject.mShotDir;
		mPlayerType = InObject.mPlayerType;
		mDeadCnt = InObject.mDeadCnt;
		mRest = InObject.mRest;
		mRotateX = InObject.mRotateX;
		mInvincibleTimeCnt = InObject.mInvincibleTimeCnt;
		mContinueCount = InObject.mContinueCount;
		mState = InObject.mState;
		mInvincible = InObject.mInvincible;
		mNightmareFlag = InObject.mNightmareFlag;
		mBossDeadFlag = InObject.mBossDeadFlag;
		mShotCounter = InObject.mShotCounter;
		mLocalCount = InObject.mLocalCount;
		mShotRimit = InObject.mShotRimit;
		mBGHandle = InObject.mBGHandle;
		mBGHandle2 = InObject.mBGHandle2;
		mBGVol = InObject.mBGVol;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<hBj2Player, hBj2Model>("hBj2Player")
			.addFunction("__tostring", &hBj2Player::ToString)
			.addFunction("GetPtrAddr", &hBj2Player::GetPtrAddr)
			.addProperty("mShotDir", &hBj2Player::mShotDir)
			.addProperty("mPlayerType", &hBj2Player::mPlayerType)
			.addProperty("mDeadCnt", &hBj2Player::mDeadCnt)
			.addProperty("mRest", &hBj2Player::mRest)
			.addProperty("mRotateX", &hBj2Player::mRotateX)
			.addProperty("mInvincibleTimeCnt", &hBj2Player::mInvincibleTimeCnt)
			.addProperty("mContinueCount", &hBj2Player::mContinueCount)
			.addProperty("mState", &hBj2Player::mState)
			.addProperty("mInvincible", &hBj2Player::mInvincible)
			.addProperty("mNightmareFlag", &hBj2Player::mNightmareFlag)
			.addProperty("mBossDeadFlag", &hBj2Player::mBossDeadFlag)
			.addProperty("mShotCounter", &hBj2Player::mShotCounter)
			.addProperty("mLocalCount", &hBj2Player::mLocalCount)
			.addProperty("mShotRimit", &hBj2Player::mShotRimit)
			.addProperty("mBGHandle", &hBj2Player::mBGHandle)
			.addProperty("mBGHandle2", &hBj2Player::mBGHandle2)
			.addProperty("mBGVol", &hBj2Player::mBGVol)
		.endClass();
	}
#endif
};
static_assert(sizeof(hBj2Player::mShotDir) == 4, "expected hBj2Player::mShotDir to be size 4");
static_assert(sizeof(hBj2Player::mPlayerType) == 4, "expected hBj2Player::mPlayerType to be size 4");
static_assert(sizeof(hBj2Player::mDeadCnt) == 4, "expected hBj2Player::mDeadCnt to be size 4");
static_assert(sizeof(hBj2Player::mRest) == 4, "expected hBj2Player::mRest to be size 4");
static_assert(sizeof(hBj2Player::mRotateX) == 4, "expected hBj2Player::mRotateX to be size 4");
static_assert(sizeof(hBj2Player::mInvincibleTimeCnt) == 4, "expected hBj2Player::mInvincibleTimeCnt to be size 4");
static_assert(sizeof(hBj2Player::mContinueCount) == 4, "expected hBj2Player::mContinueCount to be size 4");
static_assert(sizeof(hBj2Player::mState) == 4, "expected hBj2Player::mState to be size 4");
static_assert(sizeof(hBj2Player::mInvincible) == 1, "expected hBj2Player::mInvincible to be size 1");
static_assert(sizeof(hBj2Player::mNightmareFlag) == 1, "expected hBj2Player::mNightmareFlag to be size 1");
static_assert(sizeof(hBj2Player::mBossDeadFlag) == 1, "expected hBj2Player::mBossDeadFlag to be size 1");
static_assert(sizeof(hBj2Player::mShotCounter) == 4, "expected hBj2Player::mShotCounter to be size 4");
static_assert(sizeof(hBj2Player::mLocalCount) == 4, "expected hBj2Player::mLocalCount to be size 4");
static_assert(sizeof(hBj2Player::mShotRimit) == 4, "expected hBj2Player::mShotRimit to be size 4");
static_assert(sizeof(hBj2Player::mBGHandle) == 4, "expected hBj2Player::mBGHandle to be size 4");
static_assert(sizeof(hBj2Player::mBGHandle2) == 4, "expected hBj2Player::mBGHandle2 to be size 4");
static_assert(sizeof(hBj2Player::mBGVol) == 4, "expected hBj2Player::mBGVol to be size 4");
static_assert(sizeof(hBj2Player) == 0x98, "expected hBj2Player to be size 0x98");

// [Structure] class hBj2ObjManager
class hBj2ObjManager : public hList<hBj2Obj>
{
public:
	/// Struct member variables

	// <class hList<hBj2Obj> field_0, offset 0x0>
	// class hList<hBj2Obj> Super;

	// <struct tagGHMR_TEX* mTexture, offset 0xc>
	struct tagGHMR_TEX* mTexture = nullptr;

	// <uint32_t mTexNum, offset 0x10>
	uint32_t mTexNum = 0;

	/// 1 Functions

	// [Function] void __convention("thiscall") hBj2ObjManager::Load(class hBj2ObjManager* const this, class ghmResGroup* arg2) [?Load@hBj2ObjManager@@QAEXPAVghmResGroup@@@Z]
	typedef void(__thiscall* _Load_hBj2ObjManager__QAEXPAVghmResGroup___Z)(class hBj2ObjManager* const thisPtr, class ghmResGroup* arg2);
	void Load(class ghmResGroup* arg2)
	{
		_Load_hBj2ObjManager__QAEXPAVghmResGroup___Z mFunc = (_Load_hBj2ObjManager__QAEXPAVghmResGroup___Z)(GameModule + 0x69da90);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hBj2ObjManager [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hBj2ObjManager& InObject)
	{
		mTexture = InObject.mTexture;
		mTexNum = InObject.mTexNum;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hBj2ObjManager>("hBj2ObjManager")
			.addFunction("__tostring", &hBj2ObjManager::ToString)
			.addFunction("GetPtrAddr", &hBj2ObjManager::GetPtrAddr)
			.addProperty("mTexture", &hBj2ObjManager::mTexture)
			.addProperty("mTexNum", &hBj2ObjManager::mTexNum)
			.addFunction("Load", &hBj2ObjManager::Load)
		.endClass();
	}
#endif
};
static_assert(sizeof(hBj2ObjManager::mTexture) == 4, "expected hBj2ObjManager::mTexture to be size 4");
static_assert(sizeof(hBj2ObjManager::mTexNum) == 4, "expected hBj2ObjManager::mTexNum to be size 4");
static_assert(sizeof(hBj2ObjManager) == 0x14, "expected hBj2ObjManager to be size 0x14");

// [Structure] struct hBj2TimeTable
struct hBj2TimeTable
{
public:
	/// Struct member variables

	// <int16_t mCount, offset 0x0>
	int16_t mCount = 0;

	// <int16_t mType, offset 0x2>
	int16_t mType = 0;

	// <float px, offset 0x4>
	float px = 0;

	// <float py, offset 0x8>
	float py = 0;

	// <int32_t dir, offset 0xc>
	int32_t dir = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct hBj2TimeTable [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hBj2TimeTable& InObject)
	{
		mCount = InObject.mCount;
		mType = InObject.mType;
		px = InObject.px;
		py = InObject.py;
		dir = InObject.dir;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hBj2TimeTable>("hBj2TimeTable")
			.addFunction("__tostring", &hBj2TimeTable::ToString)
			.addFunction("GetPtrAddr", &hBj2TimeTable::GetPtrAddr)
			.addProperty("mCount", &hBj2TimeTable::mCount)
			.addProperty("mType", &hBj2TimeTable::mType)
			.addProperty("px", &hBj2TimeTable::px)
			.addProperty("py", &hBj2TimeTable::py)
			.addProperty("dir", &hBj2TimeTable::dir)
		.endClass();
	}
#endif
};
static_assert(sizeof(hBj2TimeTable::mCount) == 2, "expected hBj2TimeTable::mCount to be size 2");
static_assert(sizeof(hBj2TimeTable::mType) == 2, "expected hBj2TimeTable::mType to be size 2");
static_assert(sizeof(hBj2TimeTable::px) == 4, "expected hBj2TimeTable::px to be size 4");
static_assert(sizeof(hBj2TimeTable::py) == 4, "expected hBj2TimeTable::py to be size 4");
static_assert(sizeof(hBj2TimeTable::dir) == 4, "expected hBj2TimeTable::dir to be size 4");
static_assert(sizeof(hBj2TimeTable) == 0x10, "expected hBj2TimeTable to be size 0x10");

// enum FADE_STATE
enum FADE_STATE : uint32_t
{
	// <BJ2_FADESTATE_WAIT = 0x0>
	BJ2_FADESTATE_WAIT = 0,

	// <BJ2_FADESTATE_FADE = 0x1>
	BJ2_FADESTATE_FADE = 1,

	// <BJ2_FADESTATE_PAUSE = 0x2>
	BJ2_FADESTATE_PAUSE = 2,

	// <BJ2_FADESTATE_END = 0x3>
	BJ2_FADESTATE_END = 3

};

// enum FADE_MODE
enum FADE_MODE : uint32_t
{
	// <BJ2_FADEIN = 0x0>
	BJ2_FADEIN = 0,

	// <BJ2_FADEOUT = 0x1>
	BJ2_FADEOUT = 1

};

// enum FADE_TYPE
enum FADE_TYPE : uint32_t
{
	// <BJ2_FADETYPE_DEF = 0x0>
	BJ2_FADETYPE_DEF = 0,

	// <BJ2_FADETYPE_TILE = 0x1>
	BJ2_FADETYPE_TILE = 1

};

// [Structure] class hBj2Fade
class hBj2Fade
{
public:
	/// Struct member variables

	// <int32_t mFadeCnt, offset 0x0>
	int32_t mFadeCnt = 0;

	// <int32_t mFadeTime, offset 0x4>
	int32_t mFadeTime = 0;

	// <enum FADE_TYPE mFadeType, offset 0x8>
	enum FADE_TYPE mFadeType;

	// <enum FADE_MODE mFadeMode, offset 0xc>
	enum FADE_MODE mFadeMode;

	// <enum FADE_STATE mFadeState, offset 0x10>
	enum FADE_STATE mFadeState;

	// <uint32_t mFadeColor, offset 0x14>
	uint32_t mFadeColor = 0;

	// <uint32_t mFadeAlpha, offset 0x18>
	uint32_t mFadeAlpha = 0;

	// <class Bj2Tile* mpTile, offset 0x1c>
	class Bj2Tile* mpTile = nullptr;

	// <int32_t mTileNumW, offset 0x20>
	int32_t mTileNumW = 0;

	// <int32_t mTileNumH, offset 0x24>
	int32_t mTileNumH = 0;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hBj2Fade [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hBj2Fade& InObject)
	{
		mFadeCnt = InObject.mFadeCnt;
		mFadeTime = InObject.mFadeTime;
		mFadeType = InObject.mFadeType;
		mFadeMode = InObject.mFadeMode;
		mFadeState = InObject.mFadeState;
		mFadeColor = InObject.mFadeColor;
		mFadeAlpha = InObject.mFadeAlpha;
		mpTile = InObject.mpTile;
		mTileNumW = InObject.mTileNumW;
		mTileNumH = InObject.mTileNumH;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hBj2Fade>("hBj2Fade")
			.addFunction("__tostring", &hBj2Fade::ToString)
			.addFunction("GetPtrAddr", &hBj2Fade::GetPtrAddr)
			.addProperty("mFadeCnt", &hBj2Fade::mFadeCnt)
			.addProperty("mFadeTime", &hBj2Fade::mFadeTime)
			.addProperty("mFadeType", &hBj2Fade::mFadeType)
			.addProperty("mFadeMode", &hBj2Fade::mFadeMode)
			.addProperty("mFadeState", &hBj2Fade::mFadeState)
			.addProperty("mFadeColor", &hBj2Fade::mFadeColor)
			.addProperty("mFadeAlpha", &hBj2Fade::mFadeAlpha)
			.addProperty("mpTile", &hBj2Fade::mpTile)
			.addProperty("mTileNumW", &hBj2Fade::mTileNumW)
			.addProperty("mTileNumH", &hBj2Fade::mTileNumH)
		.endClass();
	}
#endif
};
static_assert(sizeof(hBj2Fade::mFadeCnt) == 4, "expected hBj2Fade::mFadeCnt to be size 4");
static_assert(sizeof(hBj2Fade::mFadeTime) == 4, "expected hBj2Fade::mFadeTime to be size 4");
static_assert(sizeof(hBj2Fade::mFadeType) == 4, "expected hBj2Fade::mFadeType to be size 4");
static_assert(sizeof(hBj2Fade::mFadeMode) == 4, "expected hBj2Fade::mFadeMode to be size 4");
static_assert(sizeof(hBj2Fade::mFadeState) == 4, "expected hBj2Fade::mFadeState to be size 4");
static_assert(sizeof(hBj2Fade::mFadeColor) == 4, "expected hBj2Fade::mFadeColor to be size 4");
static_assert(sizeof(hBj2Fade::mFadeAlpha) == 4, "expected hBj2Fade::mFadeAlpha to be size 4");
static_assert(sizeof(hBj2Fade::mpTile) == 4, "expected hBj2Fade::mpTile to be size 4");
static_assert(sizeof(hBj2Fade::mTileNumW) == 4, "expected hBj2Fade::mTileNumW to be size 4");
static_assert(sizeof(hBj2Fade::mTileNumH) == 4, "expected hBj2Fade::mTileNumH to be size 4");
static_assert(sizeof(hBj2Fade) == 0x28, "expected hBj2Fade to be size 0x28");

// [Structure] struct tagHRSAVEDATA_STG
struct tagHRSAVEDATA_STG
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData_0[164];

public:
	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "struct tagHRSAVEDATA_STG [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(tagHRSAVEDATA_STG& InObject)
	{
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagHRSAVEDATA_STG>("tagHRSAVEDATA_STG")
			.addFunction("__tostring", &tagHRSAVEDATA_STG::ToString)
			.addFunction("GetPtrAddr", &tagHRSAVEDATA_STG::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagHRSAVEDATA_STG) == 0xa4, "expected tagHRSAVEDATA_STG to be size 0xa4");

// enum BJ2LOCALTASK
enum BJ2LOCALTASK : uint32_t
{
	// <BJ2LOCALTASK_INIT = 0x0>
	BJ2LOCALTASK_INIT = 0,

	// <BJ2LOCALTASK_FADEWAIT = 0x1>
	BJ2LOCALTASK_FADEWAIT = 1,

	// <BJ2LOCALTASK_FADEOUT = 0x2>
	BJ2LOCALTASK_FADEOUT = 2,

	// <BJ2LOCALTASK_FADEOUTWAIT = 0x3>
	BJ2LOCALTASK_FADEOUTWAIT = 3,

	// <BJ2LOCALTASK_KEYWAIT = 0x4>
	BJ2LOCALTASK_KEYWAIT = 4,

	// <BJ2LOCALTASK_FADEIN = 0x5>
	BJ2LOCALTASK_FADEIN = 5,

	// <BJ2LOCALTASK_FADEINWAIT = 0x6>
	BJ2LOCALTASK_FADEINWAIT = 6,

	// <BJ2LOCALTASK_SELECTMOTIONWAIT = 0x7>
	BJ2LOCALTASK_SELECTMOTIONWAIT = 7,

	// <BJ2LOCALTASK_SELECTDIFF = 0x8>
	BJ2LOCALTASK_SELECTDIFF = 8,

	// <BJ2LOCALTASK_SELECTFADEIN = 0x9>
	BJ2LOCALTASK_SELECTFADEIN = 9,

	// <BJ2LOCALTASK_SELECTFADEINWAIT = 0xa>
	BJ2LOCALTASK_SELECTFADEINWAIT = 10,

	// <BJ2LOCAKTASK_END = 0xb>
	BJ2LOCAKTASK_END = 11,

	// <BJ2LOCALTASK_ENDWAIT = 0xc>
	BJ2LOCALTASK_ENDWAIT = 12

};

// enum STG2_STATE
enum STG2_STATE : uint32_t
{
	// <STG2_STATE_INIT = 0x0>
	STG2_STATE_INIT = 0,

	// <STG2_STATE_LOAD = 0x1>
	STG2_STATE_LOAD = 1,

	// <STG2_STATE_LOGO = 0x2>
	STG2_STATE_LOGO = 2,

	// <STG2_STATE_TITLE = 0x3>
	STG2_STATE_TITLE = 3,

	// <STG2_STATE_DEMO = 0x4>
	STG2_STATE_DEMO = 4,

	// <STG2_STATE_RANKING = 0x5>
	STG2_STATE_RANKING = 5,

	// <STG2_STATE_CHARSELECT = 0x6>
	STG2_STATE_CHARSELECT = 6,

	// <STG2_STATE_GAME = 0x7>
	STG2_STATE_GAME = 7,

	// <STG2_STATE_NAMEENTRY = 0x8>
	STG2_STATE_NAMEENTRY = 8,

	// <STG2_STATE_END = 0x9>
	STG2_STATE_END = 9

};

// [Structure] class hStg2
class hStg2
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <enum STG2_STATE mState, offset 0x4>
	enum STG2_STATE mState;

	// <enum BJ2LOCALTASK mLocalTask, offset 0x8>
	enum BJ2LOCALTASK mLocalTask;

	// <void (* pFrameProc)(hStg2* const this), offset 0xc>
	void (* pFrameProc)(hStg2* const ThisPtr);

	// <void (* pRenderProc)(hStg2* const this), offset 0x10>
	void (* pRenderProc)(hStg2* const ThisPtr);

	// <class ghmResGroup* mpResource, offset 0x14>
	class ghmResGroup* mpResource = nullptr;

	// <class hBj2ObjManager mManager, offset 0x18>
	class hBj2ObjManager mManager;

	// <class hBj2Stage* mpStage, offset 0x2c>
	class hBj2Stage* mpStage = nullptr;

	// <struct tagGHMR_TEX mBgTexture, offset 0x30>
	struct tagGHMR_TEX mBgTexture;

	// <class TGmf* mCharSelectStg, offset 0x58>
	class TGmf* mCharSelectStg = nullptr;

	// <class TGmf* mCharSelectBack, offset 0x5c>
	class TGmf* mCharSelectBack = nullptr;

	// <class TGan* mCharSelectAnm1, offset 0x60>
	class TGan* mCharSelectAnm1 = nullptr;

	// <class TGan* mCharSelectAnm2, offset 0x64>
	class TGan* mCharSelectAnm2 = nullptr;

	// <int32_t mPlayerNum, offset 0x68>
	int32_t mPlayerNum = 0;

	// <class hBj2Player* mPlayerModel, offset 0x6c>
	class hBj2Player* mPlayerModel = nullptr;

	// <int32_t mSelectPlayer, offset 0x70>
	int32_t mSelectPlayer = 0;

	// <int32_t mTimeTableNum, offset 0x74>
	int32_t mTimeTableNum = 0;

	// <struct hBj2TimeTable* mTimeTablePtr, offset 0x78>
	struct hBj2TimeTable* mTimeTablePtr = nullptr;

	// <enum BJ2_DIFFICULT mDifficult, offset 0x7c>
	enum BJ2_DIFFICULT mDifficult;

	// <int32_t mTitleCursor, offset 0x80>
	int32_t mTitleCursor = 0;

	// <int32_t mRanking, offset 0x84>
	int32_t mRanking = 0;

	// <int32_t mNowScore, offset 0x88>
	int32_t mNowScore = 0;

	// <int32_t mHighScore, offset 0x8c>
	int32_t mHighScore = 0;

	// <int32_t mBGMHandle, offset 0x90>
	int32_t mBGMHandle = 0;

	// <int32_t mBGMHandle2, offset 0x94>
	int32_t mBGMHandle2 = 0;

	// <int32_t mFadeWaitCnt, offset 0x98>
	int32_t mFadeWaitCnt = 0;

	// <float mFovy, offset 0x9c>
	float mFovy = 0;

	// <float mAspect, offset 0xa0>
	float mAspect = 0;

	// <float mN, offset 0xa4>
	float mN = 0;

	// <float mF, offset 0xa8>
	float mF = 0;

	// <int32_t mNameCursorX, offset 0xac>
	int32_t mNameCursorX = 0;

	// <int32_t mNameCursorY, offset 0xb0>
	int32_t mNameCursorY = 0;

	// <char mEntryName[0x4], offset 0xb4>
	char mEntryName[4];

	// <int32_t mSelNameNum, offset 0xb8>
	int32_t mSelNameNum = 0;

	// <int32_t mEntryScroller, offset 0xbc>
	int32_t mEntryScroller = 0;

	// <int32_t mBGMChangeFlag, offset 0xc0>
	int32_t mBGMChangeFlag = 0;

	// <int32_t mBGMVolTemp, offset 0xc4>
	int32_t mBGMVolTemp = 0;

	// <struct tagHRSAVEDATA_STG mScoreData, offset 0xc8>
	struct tagHRSAVEDATA_STG mScoreData;

	// <class rCamera mCamera, offset 0x16c>
	class rCamera mCamera;

	// <class hBj2Fade mFadeCtrl, offset 0x19c>
	class hBj2Fade mFadeCtrl;

	/// 1 Functions

	// [Function] void __convention("thiscall") hStg2::Load(class hStg2* const this, class ghmResGroup* arg2) [?Load@hStg2@@QAEXPAVghmResGroup@@@Z]
	typedef void(__thiscall* _Load_hStg2__QAEXPAVghmResGroup___Z)(class hStg2* const thisPtr, class ghmResGroup* arg2);
	void Load(class ghmResGroup* arg2)
	{
		_Load_hStg2__QAEXPAVghmResGroup___Z mFunc = (_Load_hStg2__QAEXPAVghmResGroup___Z)(GameModule + 0x695710);
		return mFunc(this, arg2);
	}
	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class hStg2 [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(hStg2& InObject)
	{
		mState = InObject.mState;
		mLocalTask = InObject.mLocalTask;
		mpResource = InObject.mpResource;
		mManager = InObject.mManager;
		mpStage = InObject.mpStage;
		mBgTexture = InObject.mBgTexture;
		mCharSelectStg = InObject.mCharSelectStg;
		mCharSelectBack = InObject.mCharSelectBack;
		mCharSelectAnm1 = InObject.mCharSelectAnm1;
		mCharSelectAnm2 = InObject.mCharSelectAnm2;
		mPlayerNum = InObject.mPlayerNum;
		mPlayerModel = InObject.mPlayerModel;
		mSelectPlayer = InObject.mSelectPlayer;
		mTimeTableNum = InObject.mTimeTableNum;
		mTimeTablePtr = InObject.mTimeTablePtr;
		mDifficult = InObject.mDifficult;
		mTitleCursor = InObject.mTitleCursor;
		mRanking = InObject.mRanking;
		mNowScore = InObject.mNowScore;
		mHighScore = InObject.mHighScore;
		mBGMHandle = InObject.mBGMHandle;
		mBGMHandle2 = InObject.mBGMHandle2;
		mFadeWaitCnt = InObject.mFadeWaitCnt;
		mFovy = InObject.mFovy;
		mAspect = InObject.mAspect;
		mN = InObject.mN;
		mF = InObject.mF;
		mNameCursorX = InObject.mNameCursorX;
		mNameCursorY = InObject.mNameCursorY;
		mSelNameNum = InObject.mSelNameNum;
		mEntryScroller = InObject.mEntryScroller;
		mBGMChangeFlag = InObject.mBGMChangeFlag;
		mBGMVolTemp = InObject.mBGMVolTemp;
		mScoreData = InObject.mScoreData;
		mCamera = InObject.mCamera;
		mFadeCtrl = InObject.mFadeCtrl;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<hStg2>("hStg2")
			.addFunction("__tostring", &hStg2::ToString)
			.addFunction("GetPtrAddr", &hStg2::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &hStg2::field_0)
			.addProperty("mState", &hStg2::mState)
			.addProperty("mLocalTask", &hStg2::mLocalTask)
			// delegates are not supported in LuaBridge
			//.addProperty("pFrameProc", &hStg2::pFrameProc)
			// delegates are not supported in LuaBridge
			//.addProperty("pRenderProc", &hStg2::pRenderProc)
			.addProperty("mpResource", &hStg2::mpResource)
			.addProperty("mManager", &hStg2::mManager)
			.addProperty("mpStage", &hStg2::mpStage)
			.addProperty("mBgTexture", &hStg2::mBgTexture)
			.addProperty("mCharSelectStg", &hStg2::mCharSelectStg)
			.addProperty("mCharSelectBack", &hStg2::mCharSelectBack)
			.addProperty("mCharSelectAnm1", &hStg2::mCharSelectAnm1)
			.addProperty("mCharSelectAnm2", &hStg2::mCharSelectAnm2)
			.addProperty("mPlayerNum", &hStg2::mPlayerNum)
			.addProperty("mPlayerModel", &hStg2::mPlayerModel)
			.addProperty("mSelectPlayer", &hStg2::mSelectPlayer)
			.addProperty("mTimeTableNum", &hStg2::mTimeTableNum)
			.addProperty("mTimeTablePtr", &hStg2::mTimeTablePtr)
			.addProperty("mDifficult", &hStg2::mDifficult)
			.addProperty("mTitleCursor", &hStg2::mTitleCursor)
			.addProperty("mRanking", &hStg2::mRanking)
			.addProperty("mNowScore", &hStg2::mNowScore)
			.addProperty("mHighScore", &hStg2::mHighScore)
			.addProperty("mBGMHandle", &hStg2::mBGMHandle)
			.addProperty("mBGMHandle2", &hStg2::mBGMHandle2)
			.addProperty("mFadeWaitCnt", &hStg2::mFadeWaitCnt)
			.addProperty("mFovy", &hStg2::mFovy)
			.addProperty("mAspect", &hStg2::mAspect)
			.addProperty("mN", &hStg2::mN)
			.addProperty("mF", &hStg2::mF)
			.addProperty("mNameCursorX", &hStg2::mNameCursorX)
			.addProperty("mNameCursorY", &hStg2::mNameCursorY)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mEntryName", &hStg2::mEntryName)
			.addProperty("mSelNameNum", &hStg2::mSelNameNum)
			.addProperty("mEntryScroller", &hStg2::mEntryScroller)
			.addProperty("mBGMChangeFlag", &hStg2::mBGMChangeFlag)
			.addProperty("mBGMVolTemp", &hStg2::mBGMVolTemp)
			.addProperty("mScoreData", &hStg2::mScoreData)
			.addProperty("mCamera", &hStg2::mCamera)
			.addProperty("mFadeCtrl", &hStg2::mFadeCtrl)
			.addFunction("Load", &hStg2::Load)
		.endClass();
	}
#endif
};
static_assert(sizeof(hStg2::field_0) == 4, "expected hStg2::field_0 to be size 4");
static_assert(sizeof(hStg2::mState) == 4, "expected hStg2::mState to be size 4");
static_assert(sizeof(hStg2::mLocalTask) == 4, "expected hStg2::mLocalTask to be size 4");
static_assert(sizeof(hStg2::pFrameProc) == 4, "expected hStg2::pFrameProc to be size 4");
static_assert(sizeof(hStg2::pRenderProc) == 4, "expected hStg2::pRenderProc to be size 4");
static_assert(sizeof(hStg2::mpResource) == 4, "expected hStg2::mpResource to be size 4");
static_assert(sizeof(hStg2::mManager) == 20, "expected hStg2::mManager to be size 20");
static_assert(sizeof(hStg2::mpStage) == 4, "expected hStg2::mpStage to be size 4");
static_assert(sizeof(hStg2::mBgTexture) == 40, "expected hStg2::mBgTexture to be size 40");
static_assert(sizeof(hStg2::mCharSelectStg) == 4, "expected hStg2::mCharSelectStg to be size 4");
static_assert(sizeof(hStg2::mCharSelectBack) == 4, "expected hStg2::mCharSelectBack to be size 4");
static_assert(sizeof(hStg2::mCharSelectAnm1) == 4, "expected hStg2::mCharSelectAnm1 to be size 4");
static_assert(sizeof(hStg2::mCharSelectAnm2) == 4, "expected hStg2::mCharSelectAnm2 to be size 4");
static_assert(sizeof(hStg2::mPlayerNum) == 4, "expected hStg2::mPlayerNum to be size 4");
static_assert(sizeof(hStg2::mPlayerModel) == 4, "expected hStg2::mPlayerModel to be size 4");
static_assert(sizeof(hStg2::mSelectPlayer) == 4, "expected hStg2::mSelectPlayer to be size 4");
static_assert(sizeof(hStg2::mTimeTableNum) == 4, "expected hStg2::mTimeTableNum to be size 4");
static_assert(sizeof(hStg2::mTimeTablePtr) == 4, "expected hStg2::mTimeTablePtr to be size 4");
static_assert(sizeof(hStg2::mDifficult) == 4, "expected hStg2::mDifficult to be size 4");
static_assert(sizeof(hStg2::mTitleCursor) == 4, "expected hStg2::mTitleCursor to be size 4");
static_assert(sizeof(hStg2::mRanking) == 4, "expected hStg2::mRanking to be size 4");
static_assert(sizeof(hStg2::mNowScore) == 4, "expected hStg2::mNowScore to be size 4");
static_assert(sizeof(hStg2::mHighScore) == 4, "expected hStg2::mHighScore to be size 4");
static_assert(sizeof(hStg2::mBGMHandle) == 4, "expected hStg2::mBGMHandle to be size 4");
static_assert(sizeof(hStg2::mBGMHandle2) == 4, "expected hStg2::mBGMHandle2 to be size 4");
static_assert(sizeof(hStg2::mFadeWaitCnt) == 4, "expected hStg2::mFadeWaitCnt to be size 4");
static_assert(sizeof(hStg2::mFovy) == 4, "expected hStg2::mFovy to be size 4");
static_assert(sizeof(hStg2::mAspect) == 4, "expected hStg2::mAspect to be size 4");
static_assert(sizeof(hStg2::mN) == 4, "expected hStg2::mN to be size 4");
static_assert(sizeof(hStg2::mF) == 4, "expected hStg2::mF to be size 4");
static_assert(sizeof(hStg2::mNameCursorX) == 4, "expected hStg2::mNameCursorX to be size 4");
static_assert(sizeof(hStg2::mNameCursorY) == 4, "expected hStg2::mNameCursorY to be size 4");
static_assert(sizeof(hStg2::mEntryName) == 4, "expected hStg2::mEntryName to be size 4");
static_assert(sizeof(hStg2::mSelNameNum) == 4, "expected hStg2::mSelNameNum to be size 4");
static_assert(sizeof(hStg2::mEntryScroller) == 4, "expected hStg2::mEntryScroller to be size 4");
static_assert(sizeof(hStg2::mBGMChangeFlag) == 4, "expected hStg2::mBGMChangeFlag to be size 4");
static_assert(sizeof(hStg2::mBGMVolTemp) == 4, "expected hStg2::mBGMVolTemp to be size 4");
static_assert(sizeof(hStg2::mScoreData) == 164, "expected hStg2::mScoreData to be size 164");
static_assert(sizeof(hStg2::mCamera) == 48, "expected hStg2::mCamera to be size 48");
static_assert(sizeof(hStg2::mFadeCtrl) == 40, "expected hStg2::mFadeCtrl to be size 40");
static_assert(sizeof(hStg2) == 0x1c4, "expected hStg2 to be size 0x1c4");

// [Structure] class Bj2Tile
class Bj2Tile
{
public:
	// enum Bj2Tile::TILE_FLAG
	enum TILE_FLAG : uint32_t
	{
		// <TILE_INIT = 0x0>
		TILE_INIT = 0,

		// <TILE_FADEIN = 0x1>
		TILE_FADEIN = 1,

		// <TILE_FADEWAIT = 0x2>
		TILE_FADEWAIT = 2,

		// <TILE_FADEOUT = 0x3>
		TILE_FADEOUT = 3,

		// <TILE_FADEEND = 0x4>
		TILE_FADEEND = 4

	};

	/// Struct member variables

	// <int32_t mWidth, offset 0x0>
	int32_t mWidth = 0;

	// <int32_t mHeight, offset 0x4>
	int32_t mHeight = 0;

	// <int32_t mCount, offset 0x8>
	int32_t mCount = 0;

	// <int32_t mMaxTime, offset 0xc>
	int32_t mMaxTime = 0;

	// <struct Vec mPos, offset 0x10>
	struct Vec mPos;

	// <struct tagGHMR_TEX* mpTex, offset 0x1c>
	struct tagGHMR_TEX* mpTex = nullptr;

	// <enum Bj2Tile::TILE_FLAG mFadeFlag, offset 0x20>
	enum Bj2Tile::TILE_FLAG mFadeFlag;

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class Bj2Tile [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(Bj2Tile& InObject)
	{
		mWidth = InObject.mWidth;
		mHeight = InObject.mHeight;
		mCount = InObject.mCount;
		mMaxTime = InObject.mMaxTime;
		mPos = InObject.mPos;
		mpTex = InObject.mpTex;
		mFadeFlag = InObject.mFadeFlag;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Bj2Tile>("Bj2Tile")
			.addFunction("__tostring", &Bj2Tile::ToString)
			.addFunction("GetPtrAddr", &Bj2Tile::GetPtrAddr)
			.addProperty("mWidth", &Bj2Tile::mWidth)
			.addProperty("mHeight", &Bj2Tile::mHeight)
			.addProperty("mCount", &Bj2Tile::mCount)
			.addProperty("mMaxTime", &Bj2Tile::mMaxTime)
			.addProperty("mPos", &Bj2Tile::mPos)
			.addProperty("mpTex", &Bj2Tile::mpTex)
			.addProperty("mFadeFlag", &Bj2Tile::mFadeFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(Bj2Tile::mWidth) == 4, "expected Bj2Tile::mWidth to be size 4");
static_assert(sizeof(Bj2Tile::mHeight) == 4, "expected Bj2Tile::mHeight to be size 4");
static_assert(sizeof(Bj2Tile::mCount) == 4, "expected Bj2Tile::mCount to be size 4");
static_assert(sizeof(Bj2Tile::mMaxTime) == 4, "expected Bj2Tile::mMaxTime to be size 4");
static_assert(sizeof(Bj2Tile::mPos) == 12, "expected Bj2Tile::mPos to be size 12");
static_assert(sizeof(Bj2Tile::mpTex) == 4, "expected Bj2Tile::mpTex to be size 4");
static_assert(sizeof(Bj2Tile::mFadeFlag) == 4, "expected Bj2Tile::mFadeFlag to be size 4");
static_assert(sizeof(Bj2Tile) == 0x24, "expected Bj2Tile to be size 0x24");

// [Structure] class ghmResAttr
class ghmResAttr
{
public:
	/// Struct member variables

	// <uint32_t mOffset, offset 0x0>
	uint32_t mOffset = 0;

	// <uint32_t mSize, offset 0x4>
	uint32_t mSize = 0;

	// <uint32_t mAttr, offset 0x8>
	uint32_t mAttr = 0;

	// <uint32_t mVersion, offset 0xc>
	uint32_t mVersion = 0;

	// <char const* mpResourceName, offset 0x10>
	char const* mpResourceName = nullptr;

	// <uint32_t mPad[0x3], offset 0x14>
	uint32_t mPad[3];

	/// 0 Functions

	/// Meta

	std::string ToString() const { std::stringstream stream; stream << "class ghmResAttr [0x" << std::hex << GetPtrAddr() << "]"; return stream.str(); }
	int GetPtrAddr() const { return (int)this; }
	void CopyFrom(ghmResAttr& InObject)
	{
		mOffset = InObject.mOffset;
		mSize = InObject.mSize;
		mAttr = InObject.mAttr;
		mVersion = InObject.mVersion;
		mpResourceName = InObject.mpResourceName;
	}
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmResAttr>("ghmResAttr")
			.addFunction("__tostring", &ghmResAttr::ToString)
			.addFunction("GetPtrAddr", &ghmResAttr::GetPtrAddr)
			.addProperty("mOffset", &ghmResAttr::mOffset)
			.addProperty("mSize", &ghmResAttr::mSize)
			.addProperty("mAttr", &ghmResAttr::mAttr)
			.addProperty("mVersion", &ghmResAttr::mVersion)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpResourceName", &ghmResAttr::mpResourceName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmResAttr::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmResAttr::mOffset) == 4, "expected ghmResAttr::mOffset to be size 4");
static_assert(sizeof(ghmResAttr::mSize) == 4, "expected ghmResAttr::mSize to be size 4");
static_assert(sizeof(ghmResAttr::mAttr) == 4, "expected ghmResAttr::mAttr to be size 4");
static_assert(sizeof(ghmResAttr::mVersion) == 4, "expected ghmResAttr::mVersion to be size 4");
static_assert(sizeof(ghmResAttr::mpResourceName) == 4, "expected ghmResAttr::mpResourceName to be size 4");
static_assert(sizeof(ghmResAttr::mPad) == 12, "expected ghmResAttr::mPad to be size 12");
static_assert(sizeof(ghmResAttr) == 0x20, "expected ghmResAttr to be size 0x20");

// Unsupported new operator
//void* ghmResGroup::operator new(uint32_t arg1, void* arg2)
// Unsupported destructor
//void __convention("thiscall") WGdl::~WGdl(class WGdl* const this)
// Unsupported constructor
//void __convention("thiscall") WGdl::WGdl(class WGdl* const this)
// Unsupported operator
//void `dynamic atexit destructor for 'gHrCamera''()
// Unsupported operator
//void `dynamic atexit destructor for 'mHRChara::mCharaAnchor''()
// Unsupported operator
//void `dynamic atexit destructor for 'HrMessage::m_TopNode''()
// Unsupported operator
//void `dynamic atexit destructor for 'mHRItem::mHRItemAnchor''()
// Unsupported operator
//void `dynamic atexit destructor for 'WGdl::mAnchor''()

#ifdef WITH_LUA
/// Lua binding

void BindLua_Exported(luabridge::Namespace& NS)
{
#ifdef LOG_INIT
	std::cout << "Binding 'struct Vec'" << std::endl;
#endif
	Vec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stPcSaveData'" << std::endl;
#endif
	stPcSaveData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stBtEffect'" << std::endl;
#endif
	stBtEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRBattle'" << std::endl;
#endif
	mHRBattle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMissionResult'" << std::endl;
#endif
	HrMissionResult::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CHrHUDDemoButton'" << std::endl;
#endif
	CHrHUDDemoButton::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrScreenStatusBalloon'" << std::endl;
#endif
	HrScreenStatusBalloon::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GXTexObj'" << std::endl;
#endif
	GXTexObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagGHMR_TEX'" << std::endl;
#endif
	tagGHMR_TEX::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrScreenStatusSlot'" << std::endl;
#endif
	HrScreenStatusSlot::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct Rectf'" << std::endl;
#endif
	Rectf::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct Vec2'" << std::endl;
#endif
	Vec2::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct hPOINT'" << std::endl;
#endif
	hPOINT::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CNYDrawStringBase'" << std::endl;
#endif
	CNYDrawStringBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class NYDrawString'" << std::endl;
#endif
	NYDrawString::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HrMap::DrawData'" << std::endl;
#endif
	HrMap::DrawData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMap'" << std::endl;
#endif
	HrMap::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class NYPhase'" << std::endl;
#endif
	NYPhase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CHrHUDBase'" << std::endl;
#endif
	CHrHUDBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CHrHUDMoney'" << std::endl;
#endif
	CHrHUDMoney::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CHrHUDTension'" << std::endl;
#endif
	CHrHUDTension::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrScreenStatus'" << std::endl;
#endif
	HrScreenStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrTask'" << std::endl;
#endif
	HrTask::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'union GXSamplerStuff'" << std::endl;
#endif
	GXSamplerStuff::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EE::RefObject'" << std::endl;
#endif
	EE::RefObject::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GXTexture::GXSpecs'" << std::endl;
#endif
	GXTexture::GXSpecs::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GXTexture'" << std::endl;
#endif
	GXTexture::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GtSimplMes'" << std::endl;
#endif
	GtSimplMes::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct DVDCommandBlock'" << std::endl;
#endif
	DVDCommandBlock::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct DVDFileInfo'" << std::endl;
#endif
	DVDFileInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmGcFile::ghmGcFileInfo'" << std::endl;
#endif
	ghmGcFile::ghmGcFileInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcFile'" << std::endl;
#endif
	ghmGcFile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct DVDDiskID'" << std::endl;
#endif
	DVDDiskID::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EE::IFile'" << std::endl;
#endif
	EE::IFile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct BATTLESIMPLMESS_SET'" << std::endl;
#endif
	BATTLESIMPLMESS_SET::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrEffectShutter'" << std::endl;
#endif
	HrEffectShutter::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfBase'" << std::endl;
#endif
	EfBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EfSmoke::SmokePrim'" << std::endl;
#endif
	EfSmoke::SmokePrim::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfSmoke'" << std::endl;
#endif
	EfSmoke::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CTimeRatioInterpolate'" << std::endl;
#endif
	CTimeRatioInterpolate::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'union uniSMflag'" << std::endl;
#endif
	uniSMflag::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stFade'" << std::endl;
#endif
	stFade::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CSpringInterpolate'" << std::endl;
#endif
	CSpringInterpolate::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CDoubleSpringInterpolate'" << std::endl;
#endif
	CDoubleSpringInterpolate::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CAmbientShadow'" << std::endl;
#endif
	CAmbientShadow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stCharaEffect'" << std::endl;
#endif
	stCharaEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class stCharaFileData'" << std::endl;
#endif
	stCharaFileData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmSegment'" << std::endl;
#endif
	ghmSegment::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmCapsule'" << std::endl;
#endif
	ghmCapsule::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcOctTreeNodeObj'" << std::endl;
#endif
	ghmGcOctTreeNodeObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObj'" << std::endl;
#endif
	ghmGcCollObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObjCapsule'" << std::endl;
#endif
	ghmGcCollObjCapsule::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WAnim'" << std::endl;
#endif
	WAnim::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WAnimF'" << std::endl;
#endif
	WAnimF::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stDamageInfo'" << std::endl;
#endif
	stDamageInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmTriangle'" << std::endl;
#endif
	ghmTriangle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmPlane'" << std::endl;
#endif
	ghmPlane::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObjHitResultObj'" << std::endl;
#endif
	ghmGcCollObjHitResultObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stVec'" << std::endl;
#endif
	stVec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct Quaternion'" << std::endl;
#endif
	Quaternion::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stCharaStatus'" << std::endl;
#endif
	stCharaStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmListObj'" << std::endl;
#endif
	ghmListObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct CharControlMotID'" << std::endl;
#endif
	CharControlMotID::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GXColor'" << std::endl;
#endif
	GXColor::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'union __m128'" << std::endl;
#endif
	__m128::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class vector4f'" << std::endl;
#endif
	vector4f::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class vector4x'" << std::endl;
#endif
	vector4x::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class tiVector'" << std::endl;
#endif
	tiVector::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::IBoneEffectModel'" << std::endl;
#endif
	mot::IBoneEffectModel::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::IBoneEffectModelPJ'" << std::endl;
#endif
	mot::IBoneEffectModelPJ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGmf::tagMAIN'" << std::endl;
#endif
	TGmf::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGmf'" << std::endl;
#endif
	TGmf::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class NYApproachToTargetVal'" << std::endl;
#endif
	NYApproachToTargetVal::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrBattleIcon::CHrHpGauge'" << std::endl;
#endif
	HrBattleIcon::CHrHpGauge::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrBattleIcon'" << std::endl;
#endif
	HrBattleIcon::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRChara'" << std::endl;
#endif
	mHRChara::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HROBJDummy'" << std::endl;
#endif
	HROBJDummy::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stTiger'" << std::endl;
#endif
	stTiger::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stHugWalk'" << std::endl;
#endif
	stHugWalk::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stPcEffect'" << std::endl;
#endif
	stPcEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stPcSndData'" << std::endl;
#endif
	stPcSndData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stDarkSideInfo'" << std::endl;
#endif
	stDarkSideInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stMiniDemo'" << std::endl;
#endif
	stMiniDemo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stPcStatus'" << std::endl;
#endif
	stPcStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRPc'" << std::endl;
#endif
	mHRPc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmAABB'" << std::endl;
#endif
	ghmAABB::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcOctTreeNode'" << std::endl;
#endif
	ghmGcOctTreeNode::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcOctTree'" << std::endl;
#endif
	ghmGcOctTree::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObjHitResult'" << std::endl;
#endif
	ghmGcCollObjHitResult::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclMaterialSpec'" << std::endl;
#endif
	WGclMaterialSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmResGroup'" << std::endl;
#endif
	ghmResGroup::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmResStrTable'" << std::endl;
#endif
	ghmResStrTable::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGanPlay::MAIN'" << std::endl;
#endif
	TGanPlay::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGanPlay'" << std::endl;
#endif
	TGanPlay::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGan::tagMAIN'" << std::endl;
#endif
	TGan::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGan'" << std::endl;
#endif
	TGan::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanSpec'" << std::endl;
#endif
	WGanSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanMaterialSpec'" << std::endl;
#endif
	WGanMaterialSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanFAnmSpec'" << std::endl;
#endif
	WGanFAnmSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct _WFAnmObjHeader'" << std::endl;
#endif
	_WFAnmObjHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct _WFAnmObjKeyListHeader'" << std::endl;
#endif
	_WFAnmObjKeyListHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanMaterialLayerSpec'" << std::endl;
#endif
	WGanMaterialLayerSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanNodeSpec'" << std::endl;
#endif
	WGanNodeSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGanPlayNode::MAIN'" << std::endl;
#endif
	TGanPlayNode::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGanPlayNode'" << std::endl;
#endif
	TGanPlayNode::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TFAnm::tagMAIN'" << std::endl;
#endif
	TFAnm::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TFAnm'" << std::endl;
#endif
	TFAnm::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGmfNode::tagMAIN'" << std::endl;
#endif
	TGmfNode::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGmfNode'" << std::endl;
#endif
	TGmfNode::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CViewClipObjSphere'" << std::endl;
#endif
	CViewClipObjSphere::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CViewClipObjBox'" << std::endl;
#endif
	CViewClipObjBox::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rPrimUnific'" << std::endl;
#endif
	rPrimUnific::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfDestortion'" << std::endl;
#endif
	EfDestortion::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGMFMESH'" << std::endl;
#endif
	TGMFMESH::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rAlphaAnime'" << std::endl;
#endif
	rAlphaAnime::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rAnimeCounter'" << std::endl;
#endif
	rAnimeCounter::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rST'" << std::endl;
#endif
	rST::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rColor'" << std::endl;
#endif
	rColor::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rPrimBase'" << std::endl;
#endif
	rPrimBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rTriangleList'" << std::endl;
#endif
	rTriangleList::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CVertexAnimation::CVertex'" << std::endl;
#endif
	CVertexAnimation::CVertex::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CVertexAnimation'" << std::endl;
#endif
	CVertexAnimation::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TFAnmObjF32_3::tagMAIN'" << std::endl;
#endif
	TFAnmObjF32_3::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TFAnmObjF32_3'" << std::endl;
#endif
	TFAnmObjF32_3::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'union _WFAnmVal'" << std::endl;
#endif
	_WFAnmVal::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TFAnmObj::tagGETA'" << std::endl;
#endif
	TFAnmObj::tagGETA::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TFAnmObj::tagMAIN'" << std::endl;
#endif
	TFAnmObj::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TFAnmObj'" << std::endl;
#endif
	TFAnmObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::IBoneEffectPJ'" << std::endl;
#endif
	mot::IBoneEffectPJ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraVibTiming'" << std::endl;
#endif
	CCameraVibTiming::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HRCHARAVOICE'" << std::endl;
#endif
	HRCHARAVOICE::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class gameUtil::CPlane'" << std::endl;
#endif
	gameUtil::CPlane::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CStickShadow'" << std::endl;
#endif
	CStickShadow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CharController'" << std::endl;
#endif
	CharController::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CObjectShadow'" << std::endl;
#endif
	CObjectShadow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stBikeEffect'" << std::endl;
#endif
	stBikeEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stBike'" << std::endl;
#endif
	stBike::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRBike'" << std::endl;
#endif
	mHRBike::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EventAreaCircle'" << std::endl;
#endif
	EventAreaCircle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptVariables'" << std::endl;
#endif
	ghmScriptVariables::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScript'" << std::endl;
#endif
	ghmScript::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptFunc'" << std::endl;
#endif
	ghmScriptFunc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrScriptFunc'" << std::endl;
#endif
	HrScriptFunc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptBase'" << std::endl;
#endif
	ghmScriptBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraCollision'" << std::endl;
#endif
	CCameraCollision::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkPjLib'" << std::endl;
#endif
	FkPjLib::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptFuncArgBase'" << std::endl;
#endif
	ghmScriptFuncArgBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmScriptObjectType'" << std::endl;
#endif
	ghmScriptObjectType::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptObject'" << std::endl;
#endif
	ghmScriptObject::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmString'" << std::endl;
#endif
	ghmString::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmScrHeader'" << std::endl;
#endif
	ghmScrHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmScrFuncHeader'" << std::endl;
#endif
	ghmScrFuncHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptProgFunc'" << std::endl;
#endif
	ghmScriptProgFunc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmScriptStackData'" << std::endl;
#endif
	ghmScriptStackData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptStack'" << std::endl;
#endif
	ghmScriptStack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptContext'" << std::endl;
#endif
	ghmScriptContext::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EveCorn'" << std::endl;
#endif
	EveCorn::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EventAreaCamera'" << std::endl;
#endif
	EventAreaCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EVENTAREACAMERA_DATA'" << std::endl;
#endif
	EVENTAREACAMERA_DATA::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectDriftMark'" << std::endl;
#endif
	EffectDriftMark::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectKeepSmoke'" << std::endl;
#endif
	EffectKeepSmoke::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rQuad'" << std::endl;
#endif
	rQuad::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectFixFire::Object'" << std::endl;
#endif
	EffectFixFire::Object::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectFixFire'" << std::endl;
#endif
	EffectFixFire::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectCloseContest'" << std::endl;
#endif
	EffectCloseContest::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EfLineSpark::LinePrim'" << std::endl;
#endif
	EfLineSpark::LinePrim::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfLineSpark'" << std::endl;
#endif
	EfLineSpark::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrOverLap'" << std::endl;
#endif
	HrOverLap::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CBgCtrl'" << std::endl;
#endif
	CBgCtrl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rSkyMap'" << std::endl;
#endif
	rSkyMap::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSpeedBlur'" << std::endl;
#endif
	EffectSpeedBlur::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rSkyMapMenu::ListParam'" << std::endl;
#endif
	rSkyMapMenu::ListParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rSkyMapMenu'" << std::endl;
#endif
	rSkyMapMenu::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HrStageDraw::MAIN'" << std::endl;
#endif
	HrStageDraw::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HrStageDraw::AREA'" << std::endl;
#endif
	HrStageDraw::AREA::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrStageDraw'" << std::endl;
#endif
	HrStageDraw::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HRSAVEDATA_DEBUNEKO'" << std::endl;
#endif
	HRSAVEDATA_DEBUNEKO::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJState'" << std::endl;
#endif
	PJState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_DownAttack'" << std::endl;
#endif
	ZkState_DownAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_AwayAfterAttack'" << std::endl;
#endif
	State_AwayAfterAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_CloseBeforeAttack'" << std::endl;
#endif
	State_CloseBeforeAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_StepInAttack'" << std::endl;
#endif
	State_StepInAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_DownDamage'" << std::endl;
#endif
	State_DownDamage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_TojoBaseState'" << std::endl;
#endif
	State_TojoBaseState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_LeadPcWayPointMove'" << std::endl;
#endif
	State_LeadPcWayPointMove::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_FixTurret'" << std::endl;
#endif
	State_FixTurret::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_WayPointMoveAfterPop'" << std::endl;
#endif
	State_WayPointMoveAfterPop::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Global'" << std::endl;
#endif
	State_Global::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Dying'" << std::endl;
#endif
	State_Dying::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_Knife_Evacuation'" << std::endl;
#endif
	ZkState_Knife_Evacuation::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_Knife_Defence'" << std::endl;
#endif
	ZkState_Knife_Defence::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Close'" << std::endl;
#endif
	State_Close::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_NoProc'" << std::endl;
#endif
	State_NoProc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Caution'" << std::endl;
#endif
	State_Caution::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_OutField'" << std::endl;
#endif
	State_OutField::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_GoToFightLine'" << std::endl;
#endif
	State_GoToFightLine::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_GetPcBehind'" << std::endl;
#endif
	State_GetPcBehind::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Debug'" << std::endl;
#endif
	State_Debug::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Guard'" << std::endl;
#endif
	State_Guard::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_RunAway'" << std::endl;
#endif
	State_RunAway::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Observ'" << std::endl;
#endif
	State_Observ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_PathFindToPc'" << std::endl;
#endif
	State_PathFindToPc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_UnderCtrl_Move'" << std::endl;
#endif
	State_UnderCtrl_Move::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_FatBase_Defence'" << std::endl;
#endif
	ZkState_FatBase_Defence::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_RoomRunner'" << std::endl;
#endif
	State_Tojo_RoomRunner::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_AeroBike'" << std::endl;
#endif
	State_Tojo_AeroBike::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_BreakCmnObj'" << std::endl;
#endif
	State_Tojo_BreakCmnObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_JumpOff'" << std::endl;
#endif
	State_Tojo_JumpOff::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Car'" << std::endl;
#endif
	State_Tojo_Car::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_RunAndTurnPc'" << std::endl;
#endif
	State_Tojo_RunAndTurnPc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Idle'" << std::endl;
#endif
	State_Idle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_AgainstWall'" << std::endl;
#endif
	State_Tojo_AgainstWall::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_LookAround'" << std::endl;
#endif
	State_Tojo_LookAround::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Stand'" << std::endl;
#endif
	State_Tojo_Stand::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Bench'" << std::endl;
#endif
	State_Tojo_Bench::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Sit'" << std::endl;
#endif
	State_Tojo_Sit::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_SuddenAttack'" << std::endl;
#endif
	State_Tojo_SuddenAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_ReleaseWaitIdle'" << std::endl;
#endif
	State_ReleaseWaitIdle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Base'" << std::endl;
#endif
	State_Scare_Base::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Kosinukasi'" << std::endl;
#endif
	State_Scare_Kosinukasi::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Run'" << std::endl;
#endif
	State_Scare_Run::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_WayPointMove'" << std::endl;
#endif
	State_WayPointMove::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Pressure'" << std::endl;
#endif
	State_Pressure::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_ThroughDamage'" << std::endl;
#endif
	State_ThroughDamage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Defence'" << std::endl;
#endif
	State_Defence::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Evacuate'" << std::endl;
#endif
	State_Evacuate::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_ComboAttack'" << std::endl;
#endif
	State_ComboAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Damage'" << std::endl;
#endif
	State_Damage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct CollInfo'" << std::endl;
#endif
	CollInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagHRTASKCHECK'" << std::endl;
#endif
	tagHRTASKCHECK::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ZkGuardParam'" << std::endl;
#endif
	ZkGuardParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ZkEvacuateParam'" << std::endl;
#endif
	ZkEvacuateParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkCounter'" << std::endl;
#endif
	FkCounter::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ZkSetDamageInfo'" << std::endl;
#endif
	ZkSetDamageInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Yotunbai'" << std::endl;
#endif
	State_Scare_Yotunbai::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Stand'" << std::endl;
#endif
	State_Scare_Stand::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_SideMove'" << std::endl;
#endif
	State_SideMove::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_RandomMove'" << std::endl;
#endif
	State_RandomMove::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_PerformIll'" << std::endl;
#endif
	State_PerformIll::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::ZakoInfo'" << std::endl;
#endif
	PJZAKO::ZakoInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::MotionInfo'" << std::endl;
#endif
	PJZAKO::MotionInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::TojoInfo'" << std::endl;
#endif
	PJZAKO::TojoInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::PcInfo'" << std::endl;
#endif
	PJZAKO::PcInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::DmgInfo'" << std::endl;
#endif
	PJZAKO::DmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::AiInfo'" << std::endl;
#endif
	PJZAKO::AiInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::EfDanmen'" << std::endl;
#endif
	PJZAKO::EfDanmen::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZAKO'" << std::endl;
#endif
	PJZAKO::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WGcl'" << std::endl;
#endif
	WGcl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class commonObj'" << std::endl;
#endif
	commonObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclSpec'" << std::endl;
#endif
	WGclSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclNodeSpec'" << std::endl;
#endif
	WGclNodeSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclNodeShapeMeshSpec'" << std::endl;
#endif
	WGclNodeShapeMeshSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclNodeShapeMeshBspNodeSpec'" << std::endl;
#endif
	WGclNodeShapeMeshBspNodeSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclNodeShapeTriangleSpec'" << std::endl;
#endif
	WGclNodeShapeTriangleSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcColl'" << std::endl;
#endif
	ghmGcColl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WGclNode'" << std::endl;
#endif
	WGclNode::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJStateMachine'" << std::endl;
#endif
	PJStateMachine::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectDanmenFlash'" << std::endl;
#endif
	EffectDanmenFlash::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectCutMark'" << std::endl;
#endif
	EffectCutMark::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectQuestion'" << std::endl;
#endif
	EffectQuestion::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZakoMotMng'" << std::endl;
#endif
	PJZakoMotMng::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PathPlanner'" << std::endl;
#endif
	PathPlanner::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkDynamicParam::DynamicParam'" << std::endl;
#endif
	FkDynamicParam::DynamicParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkDynamicParam'" << std::endl;
#endif
	FkDynamicParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkObstacleSensor'" << std::endl;
#endif
	FkObstacleSensor::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkBulletManager::stEfBullet'" << std::endl;
#endif
	FkBulletManager::stEfBullet::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkBulletManager::DmgInfo'" << std::endl;
#endif
	FkBulletManager::DmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkBulletManager'" << std::endl;
#endif
	FkBulletManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectFkTobiDoguBase::strHitCheck'" << std::endl;
#endif
	EffectFkTobiDoguBase::strHitCheck::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectFkTobiDoguBase::HitObjInfo'" << std::endl;
#endif
	EffectFkTobiDoguBase::HitObjInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectFkTobiDoguBase'" << std::endl;
#endif
	EffectFkTobiDoguBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rQuadEx'" << std::endl;
#endif
	rQuadEx::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class BoneStreamObj'" << std::endl;
#endif
	BoneStreamObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectGunTrack'" << std::endl;
#endif
	EffectGunTrack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CBoneEffectDamageData'" << std::endl;
#endif
	mot::CBoneEffectDamageData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJTateshi::HagaDmgInfo'" << std::endl;
#endif
	PJTateshi::HagaDmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJTateshi'" << std::endl;
#endif
	PJTateshi::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrCamera::CMotion'" << std::endl;
#endif
	HrCamera::CMotion::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HrCamera::MOVE2'" << std::endl;
#endif
	HrCamera::MOVE2::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HrCamera::MAIN::NORMAL'" << std::endl;
#endif
	HrCamera::MAIN::NORMAL::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HrCamera::MAIN::FREE'" << std::endl;
#endif
	HrCamera::MAIN::FREE::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HrCamera::MAIN::MOVE'" << std::endl;
#endif
	HrCamera::MAIN::MOVE::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HrCamera::MAIN'" << std::endl;
#endif
	HrCamera::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrCamera'" << std::endl;
#endif
	HrCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmSphere'" << std::endl;
#endif
	ghmSphere::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObjSphere'" << std::endl;
#endif
	ghmGcCollObjSphere::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct RailCameraHead'" << std::endl;
#endif
	RailCameraHead::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct RailPath'" << std::endl;
#endif
	RailPath::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct RailLink'" << std::endl;
#endif
	RailLink::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct RailTriangle'" << std::endl;
#endif
	RailTriangle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CustomColliderObj'" << std::endl;
#endif
	CustomColliderObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct KPADEXStatus::unnamed_type_fs'" << std::endl;
#endif
	KPADEXStatus::unnamed_type_fs::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct KPADEXStatus::unnamed_type_cl'" << std::endl;
#endif
	KPADEXStatus::unnamed_type_cl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct KPADEXStatus'" << std::endl;
#endif
	KPADEXStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct KPADStatus'" << std::endl;
#endif
	KPADStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRPad'" << std::endl;
#endif
	mHRPad::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CSpringInterpolate3D'" << std::endl;
#endif
	CSpringInterpolate3D::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CDoubleSpringInterpolate3D'" << std::endl;
#endif
	CDoubleSpringInterpolate3D::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CGameDataLink'" << std::endl;
#endif
	CGameDataLink::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CBoneEffectManager'" << std::endl;
#endif
	mot::CBoneEffectManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CBoneEffectPJ'" << std::endl;
#endif
	mot::CBoneEffectPJ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CGameData'" << std::endl;
#endif
	CGameData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CPackFileDataElement'" << std::endl;
#endif
	CPackFileDataElement::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CFileData'" << std::endl;
#endif
	CFileData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CPackFileData'" << std::endl;
#endif
	CPackFileData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CGameDataManager'" << std::endl;
#endif
	CGameDataManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::IBoneEffect'" << std::endl;
#endif
	mot::IBoneEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CIKManager'" << std::endl;
#endif
	mot::CIKManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CYuremonoManager'" << std::endl;
#endif
	mot::CYuremonoManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CLensFlare::CFlare'" << std::endl;
#endif
	CLensFlare::CFlare::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CLensFlare'" << std::endl;
#endif
	CLensFlare::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrKeyEvent'" << std::endl;
#endif
	HrKeyEvent::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrSkip'" << std::endl;
#endif
	HrSkip::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMiniDemo'" << std::endl;
#endif
	HrMiniDemo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMiniDemoObj'" << std::endl;
#endif
	HrMiniDemoObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMiniDemoSound'" << std::endl;
#endif
	HrMiniDemoSound::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRLockOnList'" << std::endl;
#endif
	mHRLockOnList::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class pcSNB'" << std::endl;
#endif
	pcSNB::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class pcHEN'" << std::endl;
#endif
	pcHEN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectEnemyDamage'" << std::endl;
#endif
	EffectEnemyDamage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stThrowInfo'" << std::endl;
#endif
	stThrowInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMessage'" << std::endl;
#endif
	HrMessage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcFont'" << std::endl;
#endif
	ghmGcFont::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GdlDialog'" << std::endl;
#endif
	GdlDialog::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GdlHeader'" << std::endl;
#endif
	GdlHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WGdl'" << std::endl;
#endif
	WGdl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GdlLines'" << std::endl;
#endif
	GdlLines::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GdlSentence'" << std::endl;
#endif
	GdlSentence::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class MessLines'" << std::endl;
#endif
	MessLines::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ACameraModeBase'" << std::endl;
#endif
	ACameraModeBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeLockOn'" << std::endl;
#endif
	CCameraModeLockOn::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrTalk'" << std::endl;
#endif
	HrTalk::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrSysMessage'" << std::endl;
#endif
	HrSysMessage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GFONT_MEMBER'" << std::endl;
#endif
	GFONT_MEMBER::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct SYSMsIcon'" << std::endl;
#endif
	SYSMsIcon::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRItem'" << std::endl;
#endif
	mHRItem::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZAKOBoneA'" << std::endl;
#endif
	PJZAKOBoneA::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZAKOBoneB'" << std::endl;
#endif
	PJZAKOBoneB::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_StrongGlobal'" << std::endl;
#endif
	State_StrongGlobal::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_ChainSaw_Global'" << std::endl;
#endif
	ZkState_ChainSaw_Global::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZAKOBoneC'" << std::endl;
#endif
	PJZAKOBoneC::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_FatTojo_EatPizza'" << std::endl;
#endif
	State_FatTojo_EatPizza::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZAKOBoneD'" << std::endl;
#endif
	PJZAKOBoneD::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBDeathState'" << std::endl;
#endif
	GLBDeathState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBWalkState'" << std::endl;
#endif
	GLBWalkState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBComboState'" << std::endl;
#endif
	GLBComboState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBIdleState'" << std::endl;
#endif
	GLBIdleState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBJampState'" << std::endl;
#endif
	GLBJampState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rSideScrollCamera'" << std::endl;
#endif
	rSideScrollCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBDamageState'" << std::endl;
#endif
	GLBDamageState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBGuardState'" << std::endl;
#endif
	GLBGuardState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBAirKickState'" << std::endl;
#endif
	GLBAirKickState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct pcGLB::DmgInfo'" << std::endl;
#endif
	pcGLB::DmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct pcGLB::TickCnt'" << std::endl;
#endif
	pcGLB::TickCnt::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class pcGLB'" << std::endl;
#endif
	pcGLB::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfRoboInterface'" << std::endl;
#endif
	EfRoboInterface::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CmDeathState'" << std::endl;
#endif
	CmDeathState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPDeathState'" << std::endl;
#endif
	SDPDeathState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPComboState'" << std::endl;
#endif
	SDPComboState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CmDamageState'" << std::endl;
#endif
	CmDamageState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPDamageState'" << std::endl;
#endif
	SDPDamageState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPBeamState'" << std::endl;
#endif
	SDPBeamState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CmIdleState'" << std::endl;
#endif
	CmIdleState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPIdleState'" << std::endl;
#endif
	SDPIdleState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::PcInfo'" << std::endl;
#endif
	bsBasic::PcInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::SurroundInfo'" << std::endl;
#endif
	bsBasic::SurroundInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::DistSense'" << std::endl;
#endif
	bsBasic::DistSense::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::TickCnt'" << std::endl;
#endif
	bsBasic::TickCnt::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::BattleParam'" << std::endl;
#endif
	bsBasic::BattleParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::DmgInfo'" << std::endl;
#endif
	bsBasic::DmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsBasic'" << std::endl;
#endif
	bsBasic::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPMoveState'" << std::endl;
#endif
	SDPMoveState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPGuardState'" << std::endl;
#endif
	SDPGuardState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsSDP'" << std::endl;
#endif
	bsSDP::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkTriangleList'" << std::endl;
#endif
	FkTriangleList::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectModelBeam'" << std::endl;
#endif
	EffectModelBeam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkVtx'" << std::endl;
#endif
	FkVtx::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfGeneralBeam'" << std::endl;
#endif
	EfGeneralBeam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rGlobalData'" << std::endl;
#endif
	rGlobalData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class JobMissionResult'" << std::endl;
#endif
	JobMissionResult::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJJMBase'" << std::endl;
#endif
	PJJMBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CMotionPlayer::CElement'" << std::endl;
#endif
	CMotionPlayer::CElement::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CMotionPlayer'" << std::endl;
#endif
	CMotionPlayer::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CNYShopNPCTalkBase'" << std::endl;
#endif
	CNYShopNPCTalkBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HRSAVEDATA_SHOP'" << std::endl;
#endif
	HRSAVEDATA_SHOP::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZAKOBoneFive'" << std::endl;
#endif
	PJZAKOBoneFive::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrScript'" << std::endl;
#endif
	HrScript::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EveObj'" << std::endl;
#endif
	EveObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMainMissionFax'" << std::endl;
#endif
	HrMainMissionFax::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraVibManager'" << std::endl;
#endif
	CCameraVibManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraBank'" << std::endl;
#endif
	CCameraBank::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeSubjective'" << std::endl;
#endif
	CCameraModeSubjective::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModePetitMovie'" << std::endl;
#endif
	CCameraModePetitMovie::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeCircle'" << std::endl;
#endif
	CCameraModeCircle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeDefaultAngle'" << std::endl;
#endif
	CCameraModeDefaultAngle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeFree'" << std::endl;
#endif
	CCameraModeFree::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeNormal'" << std::endl;
#endif
	CCameraModeNormal::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeReset'" << std::endl;
#endif
	CCameraModeReset::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraDistToLookAt'" << std::endl;
#endif
	CCameraDistToLookAt::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraFollowRot'" << std::endl;
#endif
	CCameraFollowRot::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraLookAtOffset'" << std::endl;
#endif
	CCameraLookAtOffset::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraLookAtBase'" << std::endl;
#endif
	CCameraLookAtBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraDefaultAngle'" << std::endl;
#endif
	CCameraDefaultAngle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraLockOnModeData'" << std::endl;
#endif
	CCameraLockOnModeData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraNormalModeData'" << std::endl;
#endif
	CCameraNormalModeData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeCommonData'" << std::endl;
#endif
	CCameraModeCommonData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraDataManager'" << std::endl;
#endif
	CCameraDataManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraAreaManager'" << std::endl;
#endif
	CCameraAreaManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class gameUtil::CPositionControl'" << std::endl;
#endif
	gameUtil::CPositionControl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraTarget'" << std::endl;
#endif
	CCameraTarget::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ti::CCamera'" << std::endl;
#endif
	ti::CCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CGameCamera'" << std::endl;
#endif
	CGameCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraman'" << std::endl;
#endif
	CCameraman::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrDemo'" << std::endl;
#endif
	HrDemo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HRDEMO_DATA'" << std::endl;
#endif
	HRDEMO_DATA::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSwordLaser'" << std::endl;
#endif
	EffectSwordLaser::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrDemoObj'" << std::endl;
#endif
	HrDemoObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrDemoMessage'" << std::endl;
#endif
	HrDemoMessage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hEffectManager'" << std::endl;
#endif
	hEffectManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMiniDemoEffect'" << std::endl;
#endif
	HrMiniDemoEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct STHrEffect'" << std::endl;
#endif
	STHrEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hEffPacket'" << std::endl;
#endif
	hEffPacket::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hEffect'" << std::endl;
#endif
	hEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hEffectLayer'" << std::endl;
#endif
	hEffectLayer::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct hEffectKey'" << std::endl;
#endif
	hEffectKey::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HCOLOR'" << std::endl;
#endif
	HCOLOR::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct hPerticleKey'" << std::endl;
#endif
	hPerticleKey::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hPerticle'" << std::endl;
#endif
	hPerticle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hAnimTex'" << std::endl;
#endif
	hAnimTex::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct hAnimChip'" << std::endl;
#endif
	hAnimChip::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMiniDemoModel'" << std::endl;
#endif
	HrMiniDemoModel::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGMFLIGHT'" << std::endl;
#endif
	TGMFLIGHT::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class Archive'" << std::endl;
#endif
	Archive::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagDARC_HEAD'" << std::endl;
#endif
	tagDARC_HEAD::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagDARC_FILETIME'" << std::endl;
#endif
	tagDARC_FILETIME::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagDARC_FILEHEAD'" << std::endl;
#endif
	tagDARC_FILEHEAD::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagDARC_DIRECTORY'" << std::endl;
#endif
	tagDARC_DIRECTORY::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class STG0202'" << std::endl;
#endif
	STG0202::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GTEX_UVSET'" << std::endl;
#endif
	GTEX_UVSET::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectBoneElect'" << std::endl;
#endif
	EffectBoneElect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectMetalElect'" << std::endl;
#endif
	EffectMetalElect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PjSave'" << std::endl;
#endif
	PjSave::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZakoCarBase'" << std::endl;
#endif
	PJZakoCarBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZakoCarVan'" << std::endl;
#endif
	PJZakoCarVan::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZakoCarSedan'" << std::endl;
#endif
	PJZakoCarSedan::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stRotDat'" << std::endl;
#endif
	stRotDat::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_HandGun_Shoot'" << std::endl;
#endif
	ZkState_HandGun_Shoot::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_SubMachingeGun_Shoot'" << std::endl;
#endif
	ZkState_SubMachingeGun_Shoot::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_SubMachineGunDying'" << std::endl;
#endif
	State_SubMachineGunDying::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Knife_SuddenAttack'" << std::endl;
#endif
	State_Tojo_Knife_SuddenAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkKnifeState_ThroughKnife'" << std::endl;
#endif
	ZkKnifeState_ThroughKnife::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZakoKnife'" << std::endl;
#endif
	PJZakoKnife::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_Kakuto_Hagaijime'" << std::endl;
#endif
	ZkState_Kakuto_Hagaijime::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_Kakuto_Global'" << std::endl;
#endif
	ZkState_Kakuto_Global::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_ChainSawComboAttack'" << std::endl;
#endif
	State_ChainSawComboAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_ChainSaw_Close'" << std::endl;
#endif
	ZkState_ChainSaw_Close::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsSKE'" << std::endl;
#endif
	bsSKE::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsLEZ'" << std::endl;
#endif
	bsLEZ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsCEW'" << std::endl;
#endif
	bsCEW::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsAST'" << std::endl;
#endif
	bsAST::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsRKT'" << std::endl;
#endif
	bsRKT::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0029'" << std::endl;
#endif
	PJOBJ0029::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0033'" << std::endl;
#endif
	PJOBJ0033::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EFFECTSIMPLEOBJ3PARAM'" << std::endl;
#endif
	EFFECTSIMPLEOBJ3PARAM::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EFFECTMODELFIREPARAM'" << std::endl;
#endif
	EFFECTMODELFIREPARAM::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectModelFire::MAIN'" << std::endl;
#endif
	EffectModelFire::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectModelFire'" << std::endl;
#endif
	EffectModelFire::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectSimpleObj3::MAIN'" << std::endl;
#endif
	EffectSimpleObj3::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectSimpleObj3::OBJECT'" << std::endl;
#endif
	EffectSimpleObj3::OBJECT::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSimpleObj3'" << std::endl;
#endif
	EffectSimpleObj3::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagTLIST'" << std::endl;
#endif
	tagTLIST::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0036'" << std::endl;
#endif
	PJOBJ0036::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0037'" << std::endl;
#endif
	PJOBJ0037::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0104'" << std::endl;
#endif
	PJOBJ0104::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0155'" << std::endl;
#endif
	PJOBJ0155::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0190'" << std::endl;
#endif
	PJOBJ0190::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJPTR'" << std::endl;
#endif
	PJPTR::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfSnow'" << std::endl;
#endif
	EfSnow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct NYPictData'" << std::endl;
#endif
	NYPictData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkDbgInfo_EventArea'" << std::endl;
#endif
	FkDbgInfo_EventArea::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkGlobalDBG::CommonObjSetInf'" << std::endl;
#endif
	FkGlobalDBG::CommonObjSetInf::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkGlobalDBG'" << std::endl;
#endif
	FkGlobalDBG::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectBloodSplash::MAIN'" << std::endl;
#endif
	EffectBloodSplash::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectBloodSplash'" << std::endl;
#endif
	EffectBloodSplash::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectSimpleObj2::MAIN'" << std::endl;
#endif
	EffectSimpleObj2::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectSimpleObj2::OBJECT'" << std::endl;
#endif
	EffectSimpleObj2::OBJECT::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSimpleObj2'" << std::endl;
#endif
	EffectSimpleObj2::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfBossDead'" << std::endl;
#endif
	EfBossDead::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfDeadString'" << std::endl;
#endif
	EfDeadString::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectDemo2D'" << std::endl;
#endif
	EffectDemo2D::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectFade'" << std::endl;
#endif
	EffectFade::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfSubtitles'" << std::endl;
#endif
	EfSubtitles::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSys'" << std::endl;
#endif
	EffectSys::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_UnderCtrl_Attack'" << std::endl;
#endif
	State_UnderCtrl_Attack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct NAGASU_MASU'" << std::endl;
#endif
	NAGASU_MASU::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PIPE_MASU'" << std::endl;
#endif
	PIPE_MASU::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJJMObjStatus'" << std::endl;
#endif
	PJJMObjStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJJMChar'" << std::endl;
#endif
	PJJMChar::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJJMPlumberItem'" << std::endl;
#endif
	PJJMPlumberItem::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJJMPlumberPc'" << std::endl;
#endif
	PJJMPlumberPc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SideMissionBase'" << std::endl;
#endif
	SideMissionBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectWaveBlow'" << std::endl;
#endif
	EffectWaveBlow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectPop'" << std::endl;
#endif
	EffectPop::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectMuzzle'" << std::endl;
#endif
	EffectMuzzle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSlashHit'" << std::endl;
#endif
	EffectSlashHit::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkBoss::GuardParam'" << std::endl;
#endif
	FkBoss::GuardParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkBoss'" << std::endl;
#endif
	FkBoss::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSlashTrack'" << std::endl;
#endif
	EffectSlashTrack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectBeamDragon'" << std::endl;
#endif
	EffectBeamDragon::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectGYNMissile'" << std::endl;
#endif
	EffectGYNMissile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectMoeMissile'" << std::endl;
#endif
	EffectMoeMissile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class NYMenuManager'" << std::endl;
#endif
	NYMenuManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class INYTrainingCallBack'" << std::endl;
#endif
	INYTrainingCallBack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CNYTrainingManager'" << std::endl;
#endif
	CNYTrainingManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJJobMissionManage'" << std::endl;
#endif
	PJJobMissionManage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJJMHarmfulInsect'" << std::endl;
#endif
	PJJMHarmfulInsect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJJMPlumber'" << std::endl;
#endif
	PJJMPlumber::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJJMResult'" << std::endl;
#endif
	PJJMResult::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hRECT'" << std::endl;
#endif
	hRECT::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUIObj'" << std::endl;
#endif
	hGUIObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUIWindow'" << std::endl;
#endif
	hGUIWindow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUISlideBar'" << std::endl;
#endif
	hGUISlideBar::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUIKeyFrame'" << std::endl;
#endif
	hGUIKeyFrame::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUIUVEditor'" << std::endl;
#endif
	hGUIUVEditor::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUIMenuWindow'" << std::endl;
#endif
	hGUIMenuWindow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUIColorPicker'" << std::endl;
#endif
	hGUIColorPicker::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUICursor'" << std::endl;
#endif
	hGUICursor::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUIManager'" << std::endl;
#endif
	hGUIManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rCamera'" << std::endl;
#endif
	rCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hEffectEdit'" << std::endl;
#endif
	hEffectEdit::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hEffMenu'" << std::endl;
#endif
	hEffMenu::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hGUIButton'" << std::endl;
#endif
	hGUIButton::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hBj2Stage'" << std::endl;
#endif
	hBj2Stage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hBj2Obj'" << std::endl;
#endif
	hBj2Obj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hBj2Model'" << std::endl;
#endif
	hBj2Model::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hBj2Player'" << std::endl;
#endif
	hBj2Player::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hBj2ObjManager'" << std::endl;
#endif
	hBj2ObjManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct hBj2TimeTable'" << std::endl;
#endif
	hBj2TimeTable::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hBj2Fade'" << std::endl;
#endif
	hBj2Fade::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagHRSAVEDATA_STG'" << std::endl;
#endif
	tagHRSAVEDATA_STG::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class hStg2'" << std::endl;
#endif
	hStg2::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class Bj2Tile'" << std::endl;
#endif
	Bj2Tile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmResAttr'" << std::endl;
#endif
	ghmResAttr::BindLua(NS);
}
#endif
