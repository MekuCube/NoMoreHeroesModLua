// Exporter by @MekuCube

#pragma once

/// Forward Declaration

struct stBtEffect;
struct Vec;
class mHRBattle;
class CTimeRatioInterpolate;
struct stFade;
class CSpringInterpolate;
class CDoubleSpringInterpolate;
class CAmbientShadow;
struct stCharaEffect;
class stCharaFileData;
class ghmSegment;
class ghmCapsule;
class ghmGcOctTreeNodeObj;
class ghmGcCollObj;
class ghmGcCollObjCapsule;
class WAnim;
class WAnimF;
struct stDamageInfo;
class ghmTriangle;
class ghmPlane;
class ghmGcCollObjHitResultObj;
struct stVec;
struct Quaternion;
struct stCharaStatus;
class ghmListObj;
struct CharControlMotID;
struct GXColor;
class vector4f;
class vector4x;
class tiVector;
namespace mot
{
	class IBoneEffectModel;
}
namespace mot
{
	class IBoneEffectModelPJ;
}
class TGmf;
class NYPhase;
class NYApproachToTargetVal;
class HrTask;
class HrBattleIcon;
class mHRChara;
class HROBJDummy;
struct stTiger;
struct stHugWalk;
struct stPcEffect;
struct stPcSndData;
struct stDarkSideInfo;
struct stPcSaveData;
struct stMiniDemo;
struct stPcStatus;
class mHRPc;
class ghmAABB;
class ghmGcOctTreeNode;
class ghmGcOctTree;
class ghmGcCollObjHitResult;
struct WGclMaterialSpec;
namespace EE
{
	template<typename T>
	class SmartPtr;
}
struct DVDCommandBlock;
struct DVDFileInfo;
class ghmGcFile;
struct DVDDiskID;
namespace EE
{
	class RefObject;
}
namespace EE
{
	class IFile;
}
class ghmResGroup;
class ghmResStrTable;
class TGanPlay;
class TGan;
struct WGanSpec;
struct WGanMaterialSpec;
struct WGanFAnmSpec;
struct _WFAnmObjHeader;
struct _WFAnmObjKeyListHeader;
struct WGanMaterialLayerSpec;
struct WGanNodeSpec;
class TGanPlayNode;
class TFAnm;
class TGmfNode;
class CViewClipObjSphere;
class CViewClipObjBox;
class rPrimUnific;
class EfBase;
class EfDestortion;
struct TGMFMESH;
struct GXTexObj;
struct tagGHMR_TEX;
class GXTexture;
struct rAlphaAnime;
struct rAnimeCounter;
struct rST;
struct rColor;
class rPrimBase;
class rTriangleList;
class CVertexAnimation;
class TFAnmObjF32_3;
class TFAnmObj;
namespace mot
{
	class IBoneEffectPJ;
}
class CCameraVibTiming;
struct HRCHARAVOICE;
namespace gameUtil
{
	class CPlane;
}
class CStickShadow;
class CharController;
class CObjectShadow;
struct stBikeEffect;
struct stBike;
class mHRBike;
class EventAreaCircle;
class ghmScriptVariables;
class ghmScript;
class ghmScriptFunc;
class HrScriptFunc;
class ghmScriptBase;
class CCameraCollision;
class FkPjLib;
class ghmScriptFuncArgBase;
struct ghmScriptObjectType;
class ghmScriptObject;
class ghmString;
struct ghmScrHeader;
struct ghmScrFuncHeader;
class ghmScriptProgFunc;
struct ghmScriptStackData;
class ghmScriptStack;
class ghmScriptContext;
class EveCorn;
class EventAreaCamera;
struct EVENTAREACAMERA_DATA;
class EffectDriftMark;
class EffectKeepSmoke;
class rQuad;
class EffectFixFire;
class HrOverLap;
class HrScreenStatus;
class HrEffectShutter;
class EfSmoke;
struct HRSAVEDATA_DEBUNEKO;
class WGcl;
class commonObj;
class CustomColliderObj;
struct WGclSpec;
struct WGclNodeSpec;
struct WGclNodeShapeMeshSpec;
struct WGclNodeShapeMeshBspNodeSpec;
struct WGclNodeShapeTriangleSpec;
class ghmGcColl;
class WGclNode;
class CSpringInterpolate3D;
class CDoubleSpringInterpolate3D;
namespace mot
{
	class CBoneEffectDamageData;
}
class CGameDataLink;
namespace mot
{
	class CBoneEffectManager;
}
namespace mot
{
	class CBoneEffectPJ;
}
class CGameData;
class CPackFileDataElement;
class CFileData;
class CPackFileData;
class CGameDataManager;
namespace mot
{
	class IBoneEffect;
}
namespace mot
{
	class CIKManager;
}
namespace mot
{
	class CYuremonoManager;
}
class mHRLockOnList;
class EffectEnemyDamage;
class HrMap;
struct stThrowInfo;
class HrMessage;
class ghmGcFont;
class WGdl;
struct GdlHeader;
struct GdlDialog;
struct GdlLines;
struct GdlSentence;
class ACameraModeBase;
class CCameraModeLockOn;
struct HRSAVEDATA_SHOP;
class CCameraVibManager;
class CCameraBank;
class CCameraModeSubjective;
class CCameraModePetitMovie;
class CCameraModeCircle;
class CCameraModeDefaultAngle;
class CCameraModeFree;
class CCameraModeNormal;
class CCameraModeReset;
class CCameraDistToLookAt;
class CCameraFollowRot;
class CCameraLookAtOffset;
class CCameraLookAtBase;
class CCameraDefaultAngle;
class CCameraLockOnModeData;
class CCameraNormalModeData;
class CCameraModeCommonData;
class CCameraDataManager;
class CCameraAreaManager;
namespace gameUtil
{
	class CPositionControl;
}
class CCameraTarget;
namespace ti
{
	class CCamera;
}
class CGameCamera;
class CCameraman;
class HrMiniDemoObj;
class HrMiniDemoModel;
class STG0202;
struct tagHRTASKCHECK;
class EffectBoneElect;
class BoneStreamObj;
class EffectMetalElect;
class EffectCutMark;
class PJTateshi;
class PJState;
class ZkState_DownAttack;
class State_AwayAfterAttack;
class State_CloseBeforeAttack;
class State_StepInAttack;
class State_DownDamage;
class State_TojoBaseState;
class State_LeadPcWayPointMove;
class State_FixTurret;
class State_WayPointMoveAfterPop;
class State_Tojo_RoomRunner;
class State_Tojo_AeroBike;
class State_Tojo_BreakCmnObj;
class State_Tojo_JumpOff;
class State_Tojo_Car;
class State_Tojo_RunAndTurnPc;
class State_Idle;
class State_Tojo_AgainstWall;
class State_Tojo_LookAround;
class State_Tojo_Stand;
class State_Tojo_Bench;
class State_Tojo_Sit;
class State_Tojo_SuddenAttack;
class State_ReleaseWaitIdle;
class State_Scare_Base;
class State_Scare_Kosinukasi;
class State_Scare_Run;
class State_WayPointMove;
class State_Pressure;
class State_ThroughDamage;
class State_Defence;
class State_Evacuate;
class State_ComboAttack;
class State_Damage;
struct CollInfo;
struct ZkGuardParam;
struct ZkEvacuateParam;
class FkCounter;
struct ZkSetDamageInfo;
class State_Scare_Yotunbai;
class State_Scare_Stand;
class State_RandomMove;
class State_PerformIll;
class PJZAKO;
class PJStateMachine;
class EffectDanmenFlash;
class EffectQuestion;
class PJZakoMotMng;
class PathPlanner;
class FkDynamicParam;
class FkObstacleSensor;
class FkBulletManager;
class EffectFkTobiDoguBase;
class rQuadEx;
class EffectGunTrack;
class pcSNB;
class State_Tojo_Knife_SuddenAttack;
class ZkKnifeState_ThroughKnife;
class PJZAKOBoneB;
class PJZakoKnife;
class bsSKE;
class bsLEZ;
class bsCEW;
class bsAST;
class bsRKT;
template<typename T>
class KrBaseState;
class GLBDeathState;
class GLBWalkState;
class GLBComboState;
class GLBIdleState;
class GLBJampState;
template<typename T1, int T2>
class KrStateMachine;
class rSideScrollCamera;
class GLBDamageState;
class GLBGuardState;
class GLBAirKickState;
class pcGLB;
class EfRoboInterface;
class EffectSpeedBlur;
class CmDeathState;
class SDPDeathState;
class SDPComboState;
class CmDamageState;
class SDPDamageState;
class SDPBeamState;
class CmIdleState;
class SDPIdleState;
class bsBasic;
class SDPMoveState;
class SDPGuardState;
class bsSDP;
class FkTriangleList;
class EffectModelBeam;
struct FkVtx;
class EfGeneralBeam;
class PJOBJ0029;
class PJOBJ0033;
struct EFFECTSIMPLEOBJ3PARAM;
struct EFFECTMODELFIREPARAM;
class EffectModelFire;
class EffectSimpleObj3;
struct tagTLIST;
class PJOBJ0036;
class PJOBJ0037;
class PJOBJ0104;
class PJOBJ0155;
class PJOBJ0190;
class PJPTR;
struct FkDbgInfo_EventArea;
class FkGlobalDBG;
class EffectBloodSplash;
class EffectSimpleObj2;
class EffectSlashHit;
class FkBoss;
class EffectSlashTrack;
class EffectBeamDragon;
class EffectGYNMissile;
class EffectMoeMissile;
class CMotionPlayer;

/// Full Declaration

// [Structure] struct stBtEffect
struct stBtEffect
{
public:
	// enum stBtEffect::SlowType
	enum SlowType : uint32_t
	{
		// <FinishInput = 0x0>
		FinishInput = 0,

		// <BossFinish = 0x1>
		BossFinish = 1

	};

	/// Struct member variables

	// <class HrScreenStatus* pScreenStatus, offset 0x0>
	class HrScreenStatus* pScreenStatus;

	// <class HrEffectShutter* pShutter, offset 0x4>
	class HrEffectShutter* pShutter;

	// <class EfSmoke* pSmoke, offset 0x8>
	class EfSmoke* pSmoke;

	// <int32_t slowMotTotalTick, offset 0xc>
	int32_t slowMotTotalTick;

	// <int32_t slowMotTick, offset 0x10>
	int32_t slowMotTick;

	// <enum stBtEffect::SlowType slowType, offset 0x14>
	enum stBtEffect::SlowType slowType;

	// <int32_t bulletSlowTick, offset 0x18>
	int32_t bulletSlowTick;

	// <int32_t bossBreakSlowTick, offset 0x1c>
	int32_t bossBreakSlowTick;

	std::string ToString() const { return "struct stBtEffect(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stBtEffect>("stBtEffect")
			.addFunction("__tostring", &stBtEffect::ToString)
			.addFunction("GetPtrAddr", &stBtEffect::GetPtrAddr)
			.addProperty("pScreenStatus", &stBtEffect::pScreenStatus)
			.addProperty("pShutter", &stBtEffect::pShutter)
			.addProperty("pSmoke", &stBtEffect::pSmoke)
			.addProperty("slowMotTotalTick", &stBtEffect::slowMotTotalTick)
			.addProperty("slowMotTick", &stBtEffect::slowMotTick)
			.addProperty("slowType", &stBtEffect::slowType)
			.addProperty("bulletSlowTick", &stBtEffect::bulletSlowTick)
			.addProperty("bossBreakSlowTick", &stBtEffect::bossBreakSlowTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(stBtEffect::pScreenStatus) == 4, "expected pScreenStatus to be size 4");
static_assert(sizeof(stBtEffect::pShutter) == 4, "expected pShutter to be size 4");
static_assert(sizeof(stBtEffect::pSmoke) == 4, "expected pSmoke to be size 4");
static_assert(sizeof(stBtEffect::slowMotTotalTick) == 4, "expected slowMotTotalTick to be size 4");
static_assert(sizeof(stBtEffect::slowMotTick) == 4, "expected slowMotTick to be size 4");
static_assert(sizeof(stBtEffect::slowType) == 4, "expected slowType to be size 4");
static_assert(sizeof(stBtEffect::bulletSlowTick) == 4, "expected bulletSlowTick to be size 4");
static_assert(sizeof(stBtEffect::bossBreakSlowTick) == 4, "expected bossBreakSlowTick to be size 4");
static_assert(sizeof(stBtEffect) == 32, "expected struct stBtEffect to be size 32");

// enum enPopReqType
enum enPopReqType : uint32_t
{
	// <ePopTypeDistance = 0x0>
	ePopTypeDistance = 0,

	// <ePopTypeAlways = 0x1>
	ePopTypeAlways = 1,

	// <ePopTypeOrder = 0x2>
	ePopTypeOrder = 2,

	// <ePopTypeOutOfCamera = 0x3>
	ePopTypeOutOfCamera = 3,

	// <ePopTypeMax = 0x4>
	ePopTypeMax = 4

};

// enum enCharaType
enum enCharaType : uint32_t
{
	// <eCharaTypeNone = 0x0>
	eCharaTypeNone = 0,

	// <eCharaTypePC = 0x1>
	eCharaTypePC = 1,

	// <CHARACTER_TYPE_ZAKO_BEGIN = 0x2>
	CHARACTER_TYPE_ZAKO_BEGIN = 2,

	// <eCharaTypeZKPipe = 0x3>
	eCharaTypeZKPipe = 3,

	// <eCharaTypeZKBat = 0x4>
	eCharaTypeZKBat = 4,

	// <eCharaTypeZKHandGun = 0x5>
	eCharaTypeZKHandGun = 5,

	// <eCharaTypeZKSubMachineGun = 0x6>
	eCharaTypeZKSubMachineGun = 6,

	// <eCharaTypeZKKnife = 0x7>
	eCharaTypeZKKnife = 7,

	// <eCharaTypeZKKakuto = 0x8>
	eCharaTypeZKKakuto = 8,

	// <eCharaTypeZKNihonto = 0x9>
	eCharaTypeZKNihonto = 9,

	// <eCharaTypeZKBeamKatana = 0xa>
	eCharaTypeZKBeamKatana = 10,

	// <eCharaTypeZKWarPick = 0xb>
	eCharaTypeZKWarPick = 11,

	// <eCharaTypeZKChainSaw = 0xc>
	eCharaTypeZKChainSaw = 12,

	// <eCharaTypeZKFiveNata = 0xd>
	eCharaTypeZKFiveNata = 13,

	// <eCharaTypeZKFiveHandGun = 0xe>
	eCharaTypeZKFiveHandGun = 14,

	// <eCharaTypeZKFiveMachineGun = 0xf>
	eCharaTypeZKFiveMachineGun = 15,

	// <CHARACTER_TYPE_ZAKO_END = 0x10>
	CHARACTER_TYPE_ZAKO_END = 16,

	// <CHARACTER_TYPE_BOSS_BEGIN = 0x11>
	CHARACTER_TYPE_BOSS_BEGIN = 17,

	// <eCharaTypeSKE = 0x12>
	eCharaTypeSKE = 18,

	// <eCharaTypeSPU = 0x13>
	eCharaTypeSPU = 19,

	// <eCharaTypeDSL = 0x14>
	eCharaTypeDSL = 20,

	// <eCharaTypeDSR = 0x15>
	eCharaTypeDSR = 21,

	// <eCharaTypeGSR = 0x16>
	eCharaTypeGSR = 22,

	// <eCharaTypePOP = 0x17>
	eCharaTypePOP = 23,

	// <eCharaTypeJPY = 0x18>
	eCharaTypeJPY = 24,

	// <eCharaTypeGYN = 0x19>
	eCharaTypeGYN = 25,

	// <eCharaTypeMGN = 0x1a>
	eCharaTypeMGN = 26,

	// <eCharaTypeMOE = 0x1b>
	eCharaTypeMOE = 27,

	// <eCharaTypeLEZ = 0x1c>
	eCharaTypeLEZ = 28,

	// <eCharaTypeCEW = 0x1d>
	eCharaTypeCEW = 29,

	// <eCharaTypeJBJA = 0x1e>
	eCharaTypeJBJA = 30,

	// <eCharaTypeJBJB = 0x1f>
	eCharaTypeJBJB = 31,

	// <eCharaTypeJBJC = 0x20>
	eCharaTypeJBJC = 32,

	// <eCharaTypeAST = 0x21>
	eCharaTypeAST = 33,

	// <eCharaTypeRKT = 0x22>
	eCharaTypeRKT = 34,

	// <eCharaTypeGLB = 0x23>
	eCharaTypeGLB = 35,

	// <eCharaTypeSDP = 0x24>
	eCharaTypeSDP = 36,

	// <eCharaTypeBIKJPY = 0x25>
	eCharaTypeBIKJPY = 37,

	// <CHARACTER_TYPE_BOSS_END = 0x26>
	CHARACTER_TYPE_BOSS_END = 38,

	// <eCharaTypePatroller = 0x27>
	eCharaTypePatroller = 39,

	// <eCharaTypeZKCar_Sedan = 0x28>
	eCharaTypeZKCar_Sedan = 40,

	// <eCharaTypeZKCar_Van = 0x29>
	eCharaTypeZKCar_Van = 41,

	// <eCharaTypePhotoCat = 0x2a>
	eCharaTypePhotoCat = 42,

	// <eCharaTypeFCA = 0x2b>
	eCharaTypeFCA = 43,

	// <eCharaTypeCommonNpc = 0x2c>
	eCharaTypeCommonNpc = 44,

	// <eCharaTypeScorpion = 0x2d>
	eCharaTypeScorpion = 45,

	// <eCharaTypeHelicopter = 0x2e>
	eCharaTypeHelicopter = 46,

	// <eCharaTypeCommonNpc_BUG = 0x2f>
	eCharaTypeCommonNpc_BUG = 47,

	// <eCharaTypeCommonNpc_PIPE = 0x30>
	eCharaTypeCommonNpc_PIPE = 48,

	// <eCharaTypeCommonNpc_COCONUT = 0x31>
	eCharaTypeCommonNpc_COCONUT = 49,

	// <eCharaTypeCommonNpc_DEBLI = 0x32>
	eCharaTypeCommonNpc_DEBLI = 50,

	// <eCharaTypeCommonNpc_PIZZA = 0x33>
	eCharaTypeCommonNpc_PIZZA = 51,

	// <eCharaTypeCommonNpc_TILE = 0x34>
	eCharaTypeCommonNpc_TILE = 52,

	// <eCharaTypeCommonNpc_STEAK = 0x35>
	eCharaTypeCommonNpc_STEAK = 53,

	// <eCharaTypeCommonNpc_SCORPION = 0x36>
	eCharaTypeCommonNpc_SCORPION = 54,

	// <eCharaTypeCommonNpc_CAR_BUG = 0x37>
	eCharaTypeCommonNpc_CAR_BUG = 55,

	// <eCharaTypeCommonNpc_CAR_PIPE = 0x38>
	eCharaTypeCommonNpc_CAR_PIPE = 56,

	// <eCharaTypeCommonNpc_CAR_COCONUT = 0x39>
	eCharaTypeCommonNpc_CAR_COCONUT = 57,

	// <eCharaTypeCommonNpc_CAR_DEBLI = 0x3a>
	eCharaTypeCommonNpc_CAR_DEBLI = 58,

	// <eCharaTypeCommonNpc_CAR_TILE = 0x3b>
	eCharaTypeCommonNpc_CAR_TILE = 59,

	// <eCharaTypeCommonNpc_CAR_STEAK = 0x3c>
	eCharaTypeCommonNpc_CAR_STEAK = 60,

	// <eCharaTypeCommonNpc_CAR_SCORPION = 0x3d>
	eCharaTypeCommonNpc_CAR_SCORPION = 61,

	// <eCharaTypeCmnObj = 0x3e8>
	eCharaTypeCmnObj = 1000,

	// <eCharaTypePlayerWeapon = 0x3e9>
	eCharaTypePlayerWeapon = 1001,

	// <eCustomColliderObject = 0x3ea>
	eCustomColliderObject = 1002

};

// enum eLightRefPriority
enum eLightRefPriority : uint32_t
{
	// <eLightRefPriority_MostHigh = 0x0>
	eLightRefPriority_MostHigh = 0,

	// <eLightRefPriority_PC_CUT = 0x1>
	eLightRefPriority_PC_CUT = 1,

	// <eLightRefPriority_GUARD = 0x2>
	eLightRefPriority_GUARD = 2,

	// <eLightRefPriority_MUZZLE_FLASH = 0x3>
	eLightRefPriority_MUZZLE_FLASH = 3,

	// <eLightRefPriority_Low = 0x4>
	eLightRefPriority_Low = 4

};

// [Structure] struct Vec
/// <summary>
/// 3D Vector (x, y, z). Y-up.
/// </summary>
struct Vec
{
public:
	/// Struct member variables

	// <float x, offset 0x0>
	float x;

	// <float y, offset 0x4>
	float y;

	// <float z, offset 0x8>
	float z;

	Vec() { x = 0; y = 0; z = 0; }
	Vec(float inX, float inY, float inZ) { x = inX; y = inY; z = inZ; }
	std::string ToString() const { return "struct Vec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Vec>("Vec")
			.addFunction("__tostring", &Vec::ToString)
			.addFunction("GetPtrAddr", &Vec::GetPtrAddr)
			.addProperty("x", &Vec::x)
			.addProperty("y", &Vec::y)
			.addProperty("z", &Vec::z)
			.addConstructor<void (*) (void)>()
			.addConstructor<void (*) (float, float, float)>()
			.addProperty("pitch", &Vec::x)
			.addProperty("yaw", &Vec::y)
			.addProperty("roll", &Vec::z)
		.endClass();
	}
#endif
};
static_assert(sizeof(Vec::x) == 4, "expected x to be size 4");
static_assert(sizeof(Vec::y) == 4, "expected y to be size 4");
static_assert(sizeof(Vec::z) == 4, "expected z to be size 4");
static_assert(sizeof(Vec) == 12, "expected struct Vec to be size 12");

// enum enBattleFrameProc
enum enBattleFrameProc : uint32_t
{
	// <eBtlFrameInit = 0x0>
	eBtlFrameInit = 0,

	// <eBtlFrameMain = 0x1>
	eBtlFrameMain = 1,

	// <eBtlFramePcTermWait = 0x2>
	eBtlFramePcTermWait = 2,

	// <eBtlFramePcInitWait = 0x3>
	eBtlFramePcInitWait = 3,

	// <eBtlFrameReleaseNpc = 0x4>
	eBtlFrameReleaseNpc = 4

};

// enum enPcKind
/// <summary>
/// Player character type (Travis, Shinobu, Henry)
/// </summary>
enum enPcKind : uint32_t
{
	// <ePcUndefined = 0xffffffffffffffff>
	ePcUndefined = UINT32_MAX,

	// <ePcTRV = 0x0>
	ePcTRV = 0,

	// <ePcSNB = 0x1>
	ePcSNB = 1,

	// <ePcHEN = 0x2>
	ePcHEN = 2,

	// <ePcKindMax = 0x3>
	ePcKindMax = 3

};

// [Structure] class mHRBattle
class mHRBattle
{
public:
	// [Function] class mHRPc* __convention("thiscall") mHRBattle::mGetPcPtr(class mHRBattle* const this) [?mGetPcPtr@mHRBattle@@QAEPAVmHRPc@@XZ]
	class mHRPc* mGetPcPtr()
	{
		typedef class mHRPc*(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9c010);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetSlowMotionTick(class mHRBattle* const this) [?mGetSlowMotionTick@mHRBattle@@QAEHXZ]
	int32_t mGetSlowMotionTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9cdf0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetBulletSlow(class mHRBattle* const this) [?mGetBulletSlow@mHRBattle@@QAEHXZ]
	int32_t mGetBulletSlow()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9ce00);
		return mFunc(this);
	}
	// [Function] struct stBtEffect* __convention("thiscall") mHRBattle::mGetBtEffect(class mHRBattle* const this) [?mGetBtEffect@mHRBattle@@QAEPAUstBtEffect@@XZ]
	struct stBtEffect* mGetBtEffect()
	{
		typedef struct stBtEffect*(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9ce10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetNpcAttackFlag(class mHRBattle* const this, uint8_t arg2) [?mSetNpcAttackFlag@mHRBattle@@QAEX_N@Z]
	void mSetNpcAttackFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x9ce20);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRBattle::mSetNpcAttackRate(class mHRBattle* const this, float arg2) [?mSetNpcAttackRate@mHRBattle@@QAEMM@Z]
	float mSetNpcAttackRate(float arg2)
	{
		typedef float(__thiscall* _Func)(class mHRBattle* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x9ce50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::SetNpcDatMax(class mHRBattle* const this, int32_t arg2) [?SetNpcDatMax@mHRBattle@@QAEXH@Z]
	void SetNpcDatMax(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x9ce90);
		return mFunc(this, arg2);
	}
	// [Function] class EfSmoke* __convention("thiscall") mHRBattle::GetSmokeEf(class mHRBattle* const this) [?GetSmokeEf@mHRBattle@@QAEPAVEfSmoke@@XZ]
	class EfSmoke* GetSmokeEf()
	{
		typedef class EfSmoke*(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9fbf0);
		return mFunc(this);
	}
	// [Function] enum enPcKind __convention("thiscall") mHRBattle::mGetPcKind(class mHRBattle* const this) [?mGetPcKind@mHRBattle@@QAE?AW4enPcKind@@XZ]
	enum enPcKind mGetPcKind()
	{
		typedef enum enPcKind(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2060);
		return mFunc(this);
	}
	// [Function] enum enBattleFrameProc __convention("thiscall") mHRBattle::mGetFrameProc(class mHRBattle* const this) [?mGetFrameProc@mHRBattle@@QAE?AW4enBattleFrameProc@@XZ]
	enum enBattleFrameProc mGetFrameProc()
	{
		typedef enum enBattleFrameProc(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2070);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraAngle(class mHRBattle* const this, float arg2) [?mSetCameraAngle@mHRBattle@@QAEXM@Z]
	void mSetCameraAngle(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2080);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCamMotFlag(class mHRBattle* const this, uint8_t arg2) [?mSetCamMotFlag@mHRBattle@@QAEX_N@Z]
	void mSetCamMotFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa20b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCamMotFlagNoUse(class mHRBattle* const this, uint8_t arg2) [?mSetCamMotFlagNoUse@mHRBattle@@QAEX_N@Z]
	void mSetCamMotFlagNoUse(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa20c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraAutoReturnDisEnable(class mHRBattle* const this, uint8_t arg2) [?mSetCameraAutoReturnDisEnable@mHRBattle@@QAEX_N@Z]
	void mSetCameraAutoReturnDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa20e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mClearKillNum(class mHRBattle* const this) [?mClearKillNum@mHRBattle@@QAEXXZ]
	void mClearKillNum()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2100);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetKillNum(class mHRBattle* const this) [?mGetKillNum@mHRBattle@@QAEHXZ]
	int32_t mGetKillNum()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2110);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetKillNum(class mHRBattle* const this, int32_t arg2) [?mSetKillNum@mHRBattle@@QAEXH@Z]
	void mSetKillNum(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2120);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::GetRevengeMissionZakoKillNum(class mHRBattle* const this) [?GetRevengeMissionZakoKillNum@mHRBattle@@QAEHXZ]
	int32_t GetRevengeMissionZakoKillNum()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2140);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::ClearRevengeMissionZakoKillNum(class mHRBattle* const this) [?ClearRevengeMissionZakoKillNum@mHRBattle@@QAEXXZ]
	void ClearRevengeMissionZakoKillNum()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2150);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetBattlePause(class mHRBattle* const this, uint8_t arg2) [?mSetBattlePause@mHRBattle@@QAEX_N@Z]
	void mSetBattlePause(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2160);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetDispStatusDisEnable(class mHRBattle* const this, uint8_t arg2) [?mSetDispStatusDisEnable@mHRBattle@@QAEX_N@Z]
	void mSetDispStatusDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2190);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetDispStatusDisEnable(class mHRBattle* const this) [?mGetDispStatusDisEnable@mHRBattle@@QAE_NXZ]
	uint8_t mGetDispStatusDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa21b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetChargeDamage(class mHRBattle* const this, uint8_t arg2) [?mSetChargeDamage@mHRBattle@@QAEX_N@Z]
	void mSetChargeDamage(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa21c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mClearTotalKillNum(class mHRBattle* const this) [?mClearTotalKillNum@mHRBattle@@QAEXXZ]
	void mClearTotalKillNum()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3860);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetTutoRun(class mHRBattle* const this) [?mGetTutoRun@mHRBattle@@QAE_NXZ]
	uint8_t mGetTutoRun()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3870);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSubRepopNum(class mHRBattle* const this, int32_t arg2) [?mSubRepopNum@mHRBattle@@QAEXH@Z]
	void mSubRepopNum(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4750);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetRepopTimer(class mHRBattle* const this, int32_t arg2, int32_t arg3) [?mSetRepopTimer@mHRBattle@@QAEXHH@Z]
	void mSetRepopTimer(int32_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0xa4770);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetNewGameDataRequest(class mHRBattle* const this) [?mGetNewGameDataRequest@mHRBattle@@QAE_NXZ]
	uint8_t mGetNewGameDataRequest()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5290);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetDontChangeTeppeiCamera(class mHRBattle* const this) [?mGetDontChangeTeppeiCamera@mHRBattle@@QAE_NXZ]
	uint8_t mGetDontChangeTeppeiCamera()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa52a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRBattle::mGetCameraProjection(class mHRBattle* const this) [?mGetCameraProjection@mHRBattle@@QAEMXZ]
	float mGetCameraProjection()
	{
		typedef float(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa52b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraMoveFlag(class mHRBattle* const this, uint8_t arg2) [?mSetCameraMoveFlag@mHRBattle@@QAEX_N@Z]
	void mSetCameraMoveFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa52c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetMotionCameraPos(class mHRBattle* const this, struct Vec* arg2) [?mSetMotionCameraPos@mHRBattle@@QAEXPAUVec@@@Z]
	void mSetMotionCameraPos(struct Vec* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, struct Vec* arg2);
		_Func mFunc = (_Func)(GameModule + 0xa52d0);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec* __convention("thiscall") mHRBattle::mGetMotionCameraPos(class mHRBattle* const this) [?mGetMotionCameraPos@mHRBattle@@QAEPAUVec@@XZ]
	struct Vec* mGetMotionCameraPos()
	{
		typedef struct Vec*(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa52e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetMotionCameraY(class mHRBattle* const this, float* arg2) [?mSetMotionCameraY@mHRBattle@@QAEXPAM@Z]
	void mSetMotionCameraY(float* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, float* arg2);
		_Func mFunc = (_Func)(GameModule + 0xa52f0);
		return mFunc(this, arg2);
	}
	// [Function] float* __convention("thiscall") mHRBattle::mGetMotionCameraY(class mHRBattle* const this) [?mGetMotionCameraY@mHRBattle@@QAEPAMXZ]
	// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetMotionCameraY()
	{
		typedef float*(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5300);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetBattlePause(class mHRBattle* const this) [?mGetBattlePause@mHRBattle@@QAE_NXZ]
	uint8_t mGetBattlePause()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5310);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetChargeDamage(class mHRBattle* const this) [?mGetChargeDamage@mHRBattle@@QAE_NXZ]
	uint8_t mGetChargeDamage()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5320);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetChangeCameraRailFlag(class mHRBattle* const this) [?mGetChangeCameraRailFlag@mHRBattle@@QAE_NXZ]
	uint8_t mGetChangeCameraRailFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa7a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRBattle::mGetCameraAngleX(class mHRBattle* const this) [?mGetCameraAngleX@mHRBattle@@QAEMXZ]
	float mGetCameraAngleX()
	{
		typedef float(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa7c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLockNavelPos(class mHRBattle* const this, uint8_t arg2) [?mSetLockNavelPos@mHRBattle@@QAEX_N@Z]
	void mSetLockNavelPos(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa7d0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetTotalKillNum(class mHRBattle* const this) [?mGetTotalKillNum@mHRBattle@@QAEHXZ]
	int32_t mGetTotalKillNum()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa7f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetTotalKillNum(class mHRBattle* const this, int32_t arg2) [?mSetTotalKillNum@mHRBattle@@QAEXH@Z]
	void mSetTotalKillNum(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa800);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetBossBreakSlow(class mHRBattle* const this) [?mGetBossBreakSlow@mHRBattle@@QAEHXZ]
	int32_t mGetBossBreakSlow()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaffb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetNpcAttackFlag(class mHRBattle* const this) [?mGetNpcAttackFlag@mHRBattle@@QAE_NXZ]
	uint8_t mGetNpcAttackFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xbade0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRBattle::mGetNpcAttackRate(class mHRBattle* const this) [?mGetNpcAttackRate@mHRBattle@@QAEMXZ]
	float mGetNpcAttackRate()
	{
		typedef float(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xbae00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::AddRevengeMissionZakoKillNum(class mHRBattle* const this) [?AddRevengeMissionZakoKillNum@mHRBattle@@QAEXXZ]
	void AddRevengeMissionZakoKillNum()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xbae10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::SetCameraMotionEndStop(class mHRBattle* const this, uint8_t arg2) [?SetCameraMotionEndStop@mHRBattle@@QAEX_N@Z]
	void SetCameraMotionEndStop(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xc1f40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::IsBgmEffect(class mHRBattle* const this) [?IsBgmEffect@mHRBattle@@QAE_NXZ]
	uint8_t IsBgmEffect()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xc64c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetDontChangeTeppeiCamera(class mHRBattle* const this, uint8_t arg2) [?mSetDontChangeTeppeiCamera@mHRBattle@@QAEX_N@Z]
	void mSetDontChangeTeppeiCamera(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xc8b00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::UpdateMassKillAchievement(class mHRBattle* const this) [?UpdateMassKillAchievement@mHRBattle@@AAEXXZ]
	void UpdateMassKillAchievement()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f38c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::UpdateMainScreenUI(class mHRBattle* const this) [?UpdateMainScreenUI@mHRBattle@@AAEXXZ]
	void UpdateMainScreenUI()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f39e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::BgmEffectProc(class mHRBattle* const this) [?BgmEffectProc@mHRBattle@@QAEXXZ]
	void BgmEffectProc()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f3cb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::SetBgmEffect(class mHRBattle* const this, float arg2, int32_t arg3) [?SetBgmEffect@mHRBattle@@QAEXMH@Z]
	void SetBgmEffect(float arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, float arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x3f3d00);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRBattle::GetNpc(class mHRBattle* const this, int32_t arg2) [?GetNpc@mHRBattle@@QAEPAVmHRChara@@H@Z]
	class mHRChara* GetNpc(int32_t arg2)
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f3d80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckPcLoaded4WepaponChange(class mHRBattle* const this) [?mCheckPcLoaded4WepaponChange@mHRBattle@@QAE_NXZ]
	uint8_t mCheckPcLoaded4WepaponChange()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f3dc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckBattleInit(class mHRBattle* const this) [?mCheckBattleInit@mHRBattle@@QAE_NXZ]
	uint8_t mCheckBattleInit()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f3e20);
		return mFunc(this);
	}
	// [Function] uint8_t mHRBattle::ChkToiletStage() [?ChkToiletStage@mHRBattle@@SA_NXZ]
	static uint8_t ChkToiletStage()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x3f3e30);
		return mFunc();
	}
	// [Function] uint8_t mHRBattle::ChkBikeStage() [?ChkBikeStage@mHRBattle@@SA_NXZ]
	static uint8_t ChkBikeStage()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x3f3e40);
		return mFunc();
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::GetPickUpGomiSubMissionResult(class mHRBattle* const this, int32_t arg2) [?GetPickUpGomiSubMissionResult@mHRBattle@@QAEHH@Z]
	int32_t GetPickUpGomiSubMissionResult(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f3e60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mAddKillNum(class mHRBattle* const this) [?mAddKillNum@mHRBattle@@QAEXXZ]
	void mAddKillNum()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f3e90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mSetNpcAppear(class mHRBattle* const this, int32_t arg2) [?mSetNpcAppear@mHRBattle@@QAE_NH@Z]
	uint8_t mSetNpcAppear(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f3fc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::FixRotationOfItem(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4) [?FixRotationOfItem@mHRBattle@@QAEXHAAUVec@@ABU2@@Z]
	void FixRotationOfItem(int32_t arg2, struct Vec& arg3, struct Vec& arg4)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4);
		_Func mFunc = (_Func)(GameModule + 0x3f4010);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRBattle::FixPositionOfItem(class mHRBattle* const this, int32_t arg2, struct Vec& arg3) [?FixPositionOfItem@mHRBattle@@QAEXHAAUVec@@@Z]
	void FixPositionOfItem(int32_t arg2, struct Vec& arg3)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3);
		_Func mFunc = (_Func)(GameModule + 0x3f40e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitCustomColliderObj(class mHRBattle* const this) [?mSetInitCustomColliderObj@mHRBattle@@QAEHXZ]
	int32_t mSetInitCustomColliderObj()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4390);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mSetInitCharaPos(class mHRBattle* const this, class mHRChara* arg2, struct Vec& arg3, struct Vec& arg4) [?mSetInitCharaPos@mHRBattle@@QAE_NPAVmHRChara@@ABUVec@@1@Z]
	uint8_t mSetInitCharaPos(class mHRChara* arg2, struct Vec& arg3, struct Vec& arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr, class mHRChara* arg2, struct Vec& arg3, struct Vec& arg4);
		_Func mFunc = (_Func)(GameModule + 0x3f4430);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckStatusDispOnlyBattery(class mHRBattle* const this) [?mCheckStatusDispOnlyBattery@mHRBattle@@QAE_NXZ]
	uint8_t mCheckStatusDispOnlyBattery()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4520);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckStatusDispWithoutBattery(class mHRBattle* const this) [?mCheckStatusDispWithoutBattery@mHRBattle@@QAE_NXZ]
	uint8_t mCheckStatusDispWithoutBattery()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4560);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckStatusDisp(class mHRBattle* const this) [?mCheckStatusDisp@mHRBattle@@QAE_NXZ]
	uint8_t mCheckStatusDisp()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4590);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mUndispMoney(class mHRBattle* const this) [?mUndispMoney@mHRBattle@@QAEXXZ]
	void mUndispMoney()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f45e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mDispMoney(class mHRBattle* const this) [?mDispMoney@mHRBattle@@QAEXXZ]
	void mDispMoney()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f45f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetDispPcStatus(class mHRBattle* const this) [?mGetDispPcStatus@mHRBattle@@QAE_NXZ]
	uint8_t mGetDispPcStatus()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4640);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mReleaseAllNpcWithoutCmnObj(class mHRBattle* const this) [?mReleaseAllNpcWithoutCmnObj@mHRBattle@@QAE_NXZ]
	uint8_t mReleaseAllNpcWithoutCmnObj()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4650);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetBulletSlowTick(class mHRBattle* const this, int32_t arg2) [?mSetBulletSlowTick@mHRBattle@@QAEXH@Z]
	void mSetBulletSlowTick(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f4750);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mResetBulletSlow(class mHRBattle* const this) [?mResetBulletSlow@mHRBattle@@QAEXXZ]
	void mResetBulletSlow()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4770);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mResetSlowMotion(class mHRBattle* const this) [?mResetSlowMotion@mHRBattle@@QAEXXZ]
	void mResetSlowMotion()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f47a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mLightReflectEfProc(class mHRBattle* const this) [?mLightReflectEfProc@mHRBattle@@QAEXXZ]
	void mLightReflectEfProc()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f47d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCheckSamePopNpcPosAsNpcDat(class mHRBattle* const this, struct Vec& arg2) [?mCheckSamePopNpcPosAsNpcDat@mHRBattle@@QAEXABUVec@@@Z]
	void mCheckSamePopNpcPosAsNpcDat(struct Vec& arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, struct Vec& arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f4910);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetEmptyNpcDatIndex(class mHRBattle* const this) [?mGetEmptyNpcDatIndex@mHRBattle@@QAEHXZ]
	int32_t mGetEmptyNpcDatIndex()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4920);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mRestorePcData4Lap(class mHRBattle* const this) [?mRestorePcData4Lap@mHRBattle@@QAEXXZ]
	void mRestorePcData4Lap()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4950);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mStorePcData4Lap(class mHRBattle* const this) [?mStorePcData4Lap@mHRBattle@@QAEXXZ]
	void mStorePcData4Lap()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4970);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCallPadProcess(class mHRBattle* const this) [?mCallPadProcess@mHRBattle@@QAEXXZ]
	void mCallPadProcess()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4d30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mClearNpcDat(class mHRBattle* const this, int32_t arg2) [?mClearNpcDat@mHRBattle@@QAEXH@Z]
	void mClearNpcDat(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f4d60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mEffectProc(class mHRBattle* const this) [?mEffectProc@mHRBattle@@QAEXXZ]
	void mEffectProc()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f4ea0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetPopNpc(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4) [?mSetPopNpc@mHRBattle@@QAEXHABUVec@@0@Z]
	void mSetPopNpc(int32_t arg2, struct Vec& arg3, struct Vec& arg4)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4);
		_Func mFunc = (_Func)(GameModule + 0x3f5140);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mTestNpcType(class mHRBattle* const this, class mHRChara* arg2) [?mTestNpcType@mHRBattle@@QAE_NPAVmHRChara@@@Z]
	uint8_t mTestNpcType(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f51b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetNpcEnterPattern(class mHRBattle* const this, int32_t arg2, int32_t arg3, struct Vec& arg4) [?mSetNpcEnterPattern@mHRBattle@@QAEXHHABUVec@@@Z]
	void mSetNpcEnterPattern(int32_t arg2, int32_t arg3, struct Vec& arg4)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, int32_t arg3, struct Vec& arg4);
		_Func mFunc = (_Func)(GameModule + 0x3f5210);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetShadowRate4CommonObject(class mHRBattle* const this, int32_t arg2, int32_t arg3) [?mSetShadowRate4CommonObject@mHRBattle@@QAEXHH@Z]
	void mSetShadowRate4CommonObject(int32_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x3f53a0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCreateNewNpc(class mHRBattle* const this, int32_t arg2, int32_t arg3) [?mCreateNewNpc@mHRBattle@@QAEXHH@Z]
	void mCreateNewNpc(int32_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x3f5410);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckNpcInitHp(class mHRBattle* const this, float* arg2) [?mCheckNpcInitHp@mHRBattle@@QAE_NPAM@Z]
	uint8_t mCheckNpcInitHp(float* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr, float* arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f7a30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCheckDeadNpc(class mHRBattle* const this) [?mCheckDeadNpc@mHRBattle@@QAEXXZ]
	void mCheckDeadNpc()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f7a50);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetEmptyNpcIndex(class mHRBattle* const this) [?mGetEmptyNpcIndex@mHRBattle@@QAEHXZ]
	int32_t mGetEmptyNpcIndex()
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f7af0);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") mHRBattle::mGetResourceNpcNum(class mHRBattle* const this) [?mGetResourceNpcNum@mHRBattle@@QAEIXZ]
	uint32_t mGetResourceNpcNum()
	{
		typedef uint32_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f7b10);
		return mFunc(this);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceZakoNpcMotion(class mHRBattle* const this, char* arg2) [?mGetResourceZakoNpcMotion@mHRBattle@@QAEPAXPAD@Z]
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceZakoNpcMotion(char* arg2)
	{
		typedef void*(__thiscall* _Func)(class mHRBattle* const thisPtr, char* arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f7bb0);
		mFunc(this, arg2);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceZakoCmnMotion(class mHRBattle* const this, int32_t arg2) [?mGetResourceZakoCmnMotion@mHRBattle@@QAEPAXH@Z]
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceZakoCmnMotion(int32_t arg2)
	{
		typedef void*(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f7cc0);
		mFunc(this, arg2);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceZakoWepMotion(class mHRBattle* const this, int32_t arg2) [?mGetResourceZakoWepMotion@mHRBattle@@QAEPAXH@Z]
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceZakoWepMotion(int32_t arg2)
	{
		typedef void*(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f7cf0);
		mFunc(this, arg2);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceNpc(class mHRBattle* const this, int32_t arg2, char const** arg3) [?mGetResourceNpc@mHRBattle@@QAEPAXHPAPBD@Z]
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceNpc(int32_t arg2, char const** arg3)
	{
		typedef void*(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, char const** arg3);
		_Func mFunc = (_Func)(GameModule + 0x3f7d90);
		mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::GetNpcDatIndexByCharPtr(class mHRBattle* const this, class mHRChara* arg2) [?GetNpcDatIndexByCharPtr@mHRBattle@@QAEHPAVmHRChara@@@Z]
	int32_t GetNpcDatIndexByCharPtr(class mHRChara* arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f7e70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraRotD(class mHRBattle* const this) [?mCameraRotD@mHRBattle@@QAEXXZ]
	void mCameraRotD()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f7ed0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraRotU(class mHRBattle* const this) [?mCameraRotU@mHRBattle@@QAEXXZ]
	void mCameraRotU()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f7f50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraRotR(class mHRBattle* const this) [?mCameraRotR@mHRBattle@@QAEXXZ]
	void mCameraRotR()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f7fd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraRotL(class mHRBattle* const this) [?mCameraRotL@mHRBattle@@QAEXXZ]
	void mCameraRotL()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f8080);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mCameraFrameProc(class mHRBattle* const this) [?mCameraFrameProc@mHRBattle@@QAEXXZ]
	void mCameraFrameProc()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f8130);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraOffset4Fps(class mHRBattle* const this, float arg2, float arg3, float arg4, int32_t arg5) [?mSetCameraOffset4Fps@mHRBattle@@QAEXMMMH@Z]
	void mSetCameraOffset4Fps(float arg2, float arg3, float arg4, int32_t arg5)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, float arg2, float arg3, float arg4, int32_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x3f8e40);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRBattle::mResetCameraOffset4Fps(class mHRBattle* const this, int32_t arg2) [?mResetCameraOffset4Fps@mHRBattle@@QAEXH@Z]
	void mResetCameraOffset4Fps(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f8f00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraOffset4En(class mHRBattle* const this, float arg2, float arg3, float arg4, int32_t arg5) [?mSetCameraOffset4En@mHRBattle@@QAEXMMMH@Z]
	void mSetCameraOffset4En(float arg2, float arg3, float arg4, int32_t arg5)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, float arg2, float arg3, float arg4, int32_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x3f8fd0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraOffset4Pc(class mHRBattle* const this, float arg2, float arg3, float arg4, int32_t arg5) [?mSetCameraOffset4Pc@mHRBattle@@QAEXMMMH@Z]
	void mSetCameraOffset4Pc(float arg2, float arg3, float arg4, int32_t arg5)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, float arg2, float arg3, float arg4, int32_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x3f9090);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLockOnCameraZoomIn(class mHRBattle* const this, int32_t arg2) [?mSetLockOnCameraZoomIn@mHRBattle@@QAEXH@Z]
	void mSetLockOnCameraZoomIn(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f9130);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLockOnCameraZoomOut(class mHRBattle* const this, int32_t arg2) [?mSetLockOnCameraZoomOut@mHRBattle@@QAEXH@Z]
	void mSetLockOnCameraZoomOut(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f91f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mResetLockOnCameraZoom(class mHRBattle* const this, int32_t arg2) [?mResetLockOnCameraZoom@mHRBattle@@QAEXH@Z]
	void mResetLockOnCameraZoom(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f92c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckUndispStatusStage(class mHRBattle* const this) [?mCheckUndispStatusStage@mHRBattle@@QAE_NXZ]
	uint8_t mCheckUndispStatusStage()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f9390);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetMoveInitCamera4MiniDemo(class mHRBattle* const this) [?mSetMoveInitCamera4MiniDemo@mHRBattle@@QAEXXZ]
	void mSetMoveInitCamera4MiniDemo()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f93a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLockOnCamera(class mHRBattle* const this) [?mSetLockOnCamera@mHRBattle@@QAEXXZ]
	void mSetLockOnCamera()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f9470);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mPcTerm(class mHRBattle* const this) [?mPcTerm@mHRBattle@@QAE_NXZ]
	uint8_t mPcTerm()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f9480);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mPcInit(class mHRBattle* const this) [?mPcInit@mHRBattle@@QAE_NXZ]
	uint8_t mPcInit()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f94e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mPopPcSaveData(class mHRBattle* const this) [?mPopPcSaveData@mHRBattle@@QAEXXZ]
	void mPopPcSaveData()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f9980);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mPushPcSaveData(class mHRBattle* const this) [?mPushPcSaveData@mHRBattle@@QAEXXZ]
	void mPushPcSaveData()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f99c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mInitStart(class mHRBattle* const this) [?mInitStart@mHRBattle@@QAEXXZ]
	void mInitStart()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3f99f0);
		return mFunc(this);
	}
	// [Function] void* __convention("thiscall") mHRBattle::mGetResourceCmnObj(class mHRBattle* const this, int32_t arg2) [?mGetResourceCmnObj@mHRBattle@@QAEPAXH@Z]
	// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetResourceCmnObj(int32_t arg2)
	{
		typedef void*(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3f9cb0);
		mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetLightReflecte(class mHRBattle* const this, struct Vec& arg2, float const arg3, uint32_t const arg4, int32_t const arg5, float const arg6, enum eLightRefPriority arg7) [?mSetLightReflecte@mHRBattle@@QAEXABUVec@@MIHMW4eLightRefPriority@@@Z]
	void mSetLightReflecte(struct Vec& arg2, float const arg3, uint32_t const arg4, int32_t const arg5, float const arg6, enum eLightRefPriority arg7)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, struct Vec& arg2, float const arg3, uint32_t const arg4, int32_t const arg5, float const arg6, enum eLightRefPriority arg7);
		_Func mFunc = (_Func)(GameModule + 0x3f9d50);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mInit(class mHRBattle* const this) [?mInit@mHRBattle@@QAE_NXZ]
	uint8_t mInit()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fa000);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mFrameProc(class mHRBattle* const this) [?mFrameProc@mHRBattle@@QAE_NXZ]
	uint8_t mFrameProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fa0a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetVisibleAll(class mHRBattle* const this, uint8_t arg2) [?mSetVisibleAll@mHRBattle@@QAEX_N@Z]
	void mSetVisibleAll(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fa310);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetOperateAll(class mHRBattle* const this, uint8_t arg2) [?mSetOperateAll@mHRBattle@@QAEX_N@Z]
	void mSetOperateAll(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fa370);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetNewGameDataRequest(class mHRBattle* const this, uint8_t arg2) [?mSetNewGameDataRequest@mHRBattle@@QAEX_N@Z]
	void mSetNewGameDataRequest(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fa3b0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mTerm(class mHRBattle* const this) [?mTerm@mHRBattle@@QAE_NXZ]
	uint8_t mTerm()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fa3d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mPostRenderProc(class mHRBattle* const this) [?mPostRenderProc@mHRBattle@@QAE_NXZ]
	uint8_t mPostRenderProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fa480);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::GetBowlingSubMissionResult(class mHRBattle* const this, int32_t arg2) [?GetBowlingSubMissionResult@mHRBattle@@QAEHH@Z]
	int32_t GetBowlingSubMissionResult(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fa4f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckPcLoaded(class mHRBattle* const this) [?mCheckPcLoaded@mHRBattle@@QAE_NXZ]
	uint8_t mCheckPcLoaded()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fa500);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mGetPcOperate(class mHRBattle* const this) [?mGetPcOperate@mHRBattle@@QAE_NXZ]
	uint8_t mGetPcOperate()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fa520);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetMoveInitCamera(class mHRBattle* const this, uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5) [?mSetMoveInitCamera@mHRBattle@@QAEX_N000@Z]
	void mSetMoveInitCamera(uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x3fa540);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRBattle::mInitStartMainMission(class mHRBattle* const this) [?mInitStartMainMission@mHRBattle@@QAEXXZ]
	void mInitStartMainMission()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fa6a0);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRBattle::mGetNpcPtr(class mHRBattle* const this, int32_t arg2) [?mGetNpcPtr@mHRBattle@@QAEPAVmHRChara@@H@Z]
	class mHRChara* mGetNpcPtr(int32_t arg2)
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fa6d0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, uint8_t arg8) [?mSetInitNpcDat@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@_N@Z]
	int32_t mSetInitNpcDat(int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, uint8_t arg8)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, uint8_t arg8);
		_Func mFunc = (_Func)(GameModule + 0x3fa710);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitObjDat(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4, uint8_t arg5, char const* arg6, class TGmfNode* arg7, int32_t arg8, int32_t arg9) [?mSetInitObjDat@mHRBattle@@QAEHHABUVec@@0_NPBDPBVTGmfNode@@HH@Z]
	int32_t mSetInitObjDat(int32_t arg2, struct Vec& arg3, struct Vec& arg4, uint8_t arg5, std::string arg6, class TGmfNode* arg7, int32_t arg8, int32_t arg9)
	{
		char const* arg6_c_str = arg6.c_str();
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4, uint8_t arg5, char const* arg6, class TGmfNode* arg7, int32_t arg8, int32_t arg9);
		_Func mFunc = (_Func)(GameModule + 0x3fa830);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6_c_str, arg7, arg8, arg9);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetPopType(class mHRBattle* const this, int32_t arg2, enum enPopReqType arg3) [?mSetPopType@mHRBattle@@QAEXHW4enPopReqType@@@Z]
	void mSetPopType(int32_t arg2, enum enPopReqType arg3)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum enPopReqType arg3);
		_Func mFunc = (_Func)(GameModule + 0x3fac90);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mSetPcKind(class mHRBattle* const this, enum enPcKind arg2, uint8_t arg3) [?mSetPcKind@mHRBattle@@QAE_NW4enPcKind@@_N@Z]
	uint8_t mSetPcKind(enum enPcKind arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr, enum enPcKind arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x3facc0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat2(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, uint8_t arg11) [?mSetInitNpcDat2@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMM_N@Z]
	int32_t mSetInitNpcDat2(int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, uint8_t arg11)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, uint8_t arg11);
		_Func mFunc = (_Func)(GameModule + 0x3fadc0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat3(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, uint8_t arg12) [?mSetInitNpcDat3@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMH_N@Z]
	int32_t mSetInitNpcDat3(int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, uint8_t arg12)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, uint8_t arg12);
		_Func mFunc = (_Func)(GameModule + 0x3faef0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat4(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13) [?mSetInitNpcDat4@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMHPAD_N@Z]
	int32_t mSetInitNpcDat4(int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13);
		_Func mFunc = (_Func)(GameModule + 0x3fb020);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat5(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15) [?mSetInitNpcDat5@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMHPAD_NMH@Z]
	int32_t mSetInitNpcDat5(int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15);
		_Func mFunc = (_Func)(GameModule + 0x3fb190);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat6(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16) [?mSetInitNpcDat6@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMHPAD_NMHH@Z]
	int32_t mSetInitNpcDat6(int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16);
		_Func mFunc = (_Func)(GameModule + 0x3fb310);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDat7(class mHRBattle* const this, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16) [?mSetInitNpcDat7@mHRBattle@@QAEHHW4enCharaType@@HABUVec@@1W4enPopReqType@@HMMHPAD_NMHH@Z]
	int32_t mSetInitNpcDat7(int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum enCharaType arg3, int32_t arg4, struct Vec& arg5, struct Vec& arg6, enum enPopReqType arg7, int32_t arg8, float arg9, float arg10, int32_t arg11, char* arg12, uint8_t arg13, float arg14, int32_t arg15, int32_t arg16);
		_Func mFunc = (_Func)(GameModule + 0x3fb4a0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDatObj095(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6) [?mSetInitNpcDatObj095@mHRBattle@@QAEHHABUVec@@0HH@Z]
	int32_t mSetInitNpcDatObj095(int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6);
		_Func mFunc = (_Func)(GameModule + 0x3fb630);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] void __convention("thiscall") mHRBattle::mDispPcStatus(class mHRBattle* const this) [?mDispPcStatus@mHRBattle@@QAEXXZ]
	void mDispPcStatus()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fb740);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mDispMiniMap(class mHRBattle* const this) [?mDispMiniMap@mHRBattle@@QAEXXZ]
	void mDispMiniMap()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fb750);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mUndispMiniMap(class mHRBattle* const this) [?mUndispMiniMap@mHRBattle@@QAEXXZ]
	void mUndispMiniMap()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fb7f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mDeleteNpc(class mHRBattle* const this, int32_t arg2) [?mDeleteNpc@mHRBattle@@QAE_NH@Z]
	uint8_t mDeleteNpc(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fb810);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::RequestMotionNoNpc(class mHRBattle* const this, enum enCharaType arg2, int32_t arg3, uint8_t arg4) [?RequestMotionNoNpc@mHRBattle@@QAE_NW4enCharaType@@H_N@Z]
	uint8_t RequestMotionNoNpc(enum enCharaType arg2, int32_t arg3, uint8_t arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr, enum enCharaType arg2, int32_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x3fb8b0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRBattle::mGetNpcPtrFromCharaType(class mHRBattle* const this, enum enCharaType arg2) [?mGetNpcPtrFromCharaType@mHRBattle@@QAEPAVmHRChara@@W4enCharaType@@@Z]
	class mHRChara* mGetNpcPtrFromCharaType(enum enCharaType arg2)
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRBattle* const thisPtr, enum enCharaType arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fb970);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetZakoNpcMotionProcessDisEnable(class mHRBattle* const this, uint8_t arg2) [?mSetZakoNpcMotionProcessDisEnable@mHRBattle@@QAEX_N@Z]
	void mSetZakoNpcMotionProcessDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fb9d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetAspectRate(class mHRBattle* const this, float arg2, int32_t arg3) [?mSetAspectRate@mHRBattle@@QAEXMH@Z]
	void mSetAspectRate(float arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, float arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x3fba20);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mCheckExistEnemy(class mHRBattle* const this) [?mCheckExistEnemy@mHRBattle@@QAE_NXZ]
	uint8_t mCheckExistEnemy()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fba60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mAllTestZakoDamage(class mHRBattle* const this, int32_t arg2) [?mAllTestZakoDamage@mHRBattle@@QAE_NH@Z]
	uint8_t mAllTestZakoDamage(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fbab0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mAllTestZakoTameDamage(class mHRBattle* const this) [?mAllTestZakoTameDamage@mHRBattle@@QAE_NXZ]
	uint8_t mAllTestZakoTameDamage()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fbb00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mAllEnemyDie(class mHRBattle* const this) [?mAllEnemyDie@mHRBattle@@QAE_NXZ]
	uint8_t mAllEnemyDie()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fbb20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mAllClearNpcData(class mHRBattle* const this) [?mAllClearNpcData@mHRBattle@@QAEXXZ]
	void mAllClearNpcData()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fbbb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetCameraProjection(class mHRBattle* const this, float arg2) [?mSetCameraProjection@mHRBattle@@QAEXM@Z]
	void mSetCameraProjection(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fbcb0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mGetObjNpcID(class mHRBattle* const this, int32_t arg2, char* arg3) [?mGetObjNpcID@mHRBattle@@QAEHHPAD@Z]
	int32_t mGetObjNpcID(int32_t arg2, char* arg3)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, char* arg3);
		_Func mFunc = (_Func)(GameModule + 0x3fbcf0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRBattle::mGetObjPtr(class mHRBattle* const this, int32_t arg2, char* arg3) [?mGetObjPtr@mHRBattle@@QAEPAVmHRChara@@HPAD@Z]
	class mHRChara* mGetObjPtr(int32_t arg2, char* arg3)
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, char* arg3);
		_Func mFunc = (_Func)(GameModule + 0x3fbd70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRBattle::mPopNpc(class mHRBattle* const this) [?mPopNpc@mHRBattle@@QAEXXZ]
	void mPopNpc()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fbe00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetSlowMotionTick(class mHRBattle* const this, int32_t arg2, enum stBtEffect::SlowType arg3) [?mSetSlowMotionTick@mHRBattle@@QAEXHW4SlowType@stBtEffect@@@Z]
	void mSetSlowMotionTick(int32_t arg2, enum stBtEffect::SlowType arg3)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, enum stBtEffect::SlowType arg3);
		_Func mFunc = (_Func)(GameModule + 0x3fca40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mReleaseAllEnemy(class mHRBattle* const this) [?mReleaseAllEnemy@mHRBattle@@QAE_NXZ]
	uint8_t mReleaseAllEnemy()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fca70);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRBattle::mSetInitNpcDatObj183(class mHRBattle* const this, int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6, uint8_t arg7, int32_t arg8) [?mSetInitNpcDatObj183@mHRBattle@@QAEHHABUVec@@0HH_NH@Z]
	int32_t mSetInitNpcDatObj183(int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6, uint8_t arg7, int32_t arg8)
	{
		typedef int32_t(__thiscall* _Func)(class mHRBattle* const thisPtr, int32_t arg2, struct Vec& arg3, struct Vec& arg4, int32_t arg5, int32_t arg6, uint8_t arg7, int32_t arg8);
		_Func mFunc = (_Func)(GameModule + 0x3fcb80);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mReleaseAllNpc(class mHRBattle* const this) [?mReleaseAllNpc@mHRBattle@@QAE_NXZ]
	uint8_t mReleaseAllNpc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fcca0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetDontAppearStatus(class mHRBattle* const this) [?mSetDontAppearStatus@mHRBattle@@QAEXXZ]
	void mSetDontAppearStatus()
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fcd70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRBattle::CameraMotionModeReset(class mHRBattle* const this, uint8_t arg2) [?CameraMotionModeReset@mHRBattle@@QAEX_N@Z]
	void CameraMotionModeReset(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fcd80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mSetPcOperate(class mHRBattle* const this, uint8_t arg2) [?mSetPcOperate@mHRBattle@@QAEX_N@Z]
	void mSetPcOperate(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fce10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRBattle::mUndispPcStatus(class mHRBattle* const this, uint8_t arg2) [?mUndispPcStatus@mHRBattle@@QAEX_N@Z]
	void mUndispPcStatus(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRBattle* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fce30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRBattle::mRenderProc(class mHRBattle* const this) [?mRenderProc@mHRBattle@@QAE_NXZ]
	uint8_t mRenderProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRBattle* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x3fce50);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRBattle::mGetNpcMotionSpd(class mHRBattle* const this, class mHRChara* arg2) [?mGetNpcMotionSpd@mHRBattle@@QAEMPAVmHRChara@@@Z]
	float mGetNpcMotionSpd(class mHRChara* arg2)
	{
		typedef float(__thiscall* _Func)(class mHRBattle* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x3fce60);
		return mFunc(this, arg2);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[146492];
public:

	std::string ToString() const { return "class mHRBattle(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRBattle>("mHRBattle")
			.addFunction("__tostring", &mHRBattle::ToString)
			.addFunction("GetPtrAddr", &mHRBattle::GetPtrAddr)
			.addFunction("mGetPcPtr", &mHRBattle::mGetPcPtr)
			.addFunction("mGetSlowMotionTick", &mHRBattle::mGetSlowMotionTick)
			.addFunction("mGetBulletSlow", &mHRBattle::mGetBulletSlow)
			.addFunction("mGetBtEffect", &mHRBattle::mGetBtEffect)
			.addFunction("mSetNpcAttackFlag", &mHRBattle::mSetNpcAttackFlag)
			.addFunction("mSetNpcAttackRate", &mHRBattle::mSetNpcAttackRate)
			.addFunction("SetNpcDatMax", &mHRBattle::SetNpcDatMax)
			.addFunction("GetSmokeEf", &mHRBattle::GetSmokeEf)
			.addFunction("mGetPcKind", &mHRBattle::mGetPcKind)
			.addFunction("mGetFrameProc", &mHRBattle::mGetFrameProc)
			.addFunction("mSetCameraAngle", &mHRBattle::mSetCameraAngle)
			.addFunction("mSetCamMotFlag", &mHRBattle::mSetCamMotFlag)
			.addFunction("mSetCamMotFlagNoUse", &mHRBattle::mSetCamMotFlagNoUse)
			.addFunction("mSetCameraAutoReturnDisEnable", &mHRBattle::mSetCameraAutoReturnDisEnable)
			.addFunction("mClearKillNum", &mHRBattle::mClearKillNum)
			.addFunction("mGetKillNum", &mHRBattle::mGetKillNum)
			.addFunction("mSetKillNum", &mHRBattle::mSetKillNum)
			.addFunction("GetRevengeMissionZakoKillNum", &mHRBattle::GetRevengeMissionZakoKillNum)
			.addFunction("ClearRevengeMissionZakoKillNum", &mHRBattle::ClearRevengeMissionZakoKillNum)
			.addFunction("mSetBattlePause", &mHRBattle::mSetBattlePause)
			.addFunction("mSetDispStatusDisEnable", &mHRBattle::mSetDispStatusDisEnable)
			.addFunction("mGetDispStatusDisEnable", &mHRBattle::mGetDispStatusDisEnable)
			.addFunction("mSetChargeDamage", &mHRBattle::mSetChargeDamage)
			.addFunction("mClearTotalKillNum", &mHRBattle::mClearTotalKillNum)
			.addFunction("mGetTutoRun", &mHRBattle::mGetTutoRun)
			.addFunction("mSubRepopNum", &mHRBattle::mSubRepopNum)
			.addFunction("mSetRepopTimer", &mHRBattle::mSetRepopTimer)
			.addFunction("mGetNewGameDataRequest", &mHRBattle::mGetNewGameDataRequest)
			.addFunction("mGetDontChangeTeppeiCamera", &mHRBattle::mGetDontChangeTeppeiCamera)
			.addFunction("mGetCameraProjection", &mHRBattle::mGetCameraProjection)
			.addFunction("mSetCameraMoveFlag", &mHRBattle::mSetCameraMoveFlag)
			.addFunction("mSetMotionCameraPos", &mHRBattle::mSetMotionCameraPos)
			.addFunction("mGetMotionCameraPos", &mHRBattle::mGetMotionCameraPos)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetMotionCameraY", &mHRBattle::mSetMotionCameraY)
			.addFunction("mGetMotionCameraY", &mHRBattle::mGetMotionCameraY)
			.addFunction("mGetBattlePause", &mHRBattle::mGetBattlePause)
			.addFunction("mGetChargeDamage", &mHRBattle::mGetChargeDamage)
			.addFunction("mGetChangeCameraRailFlag", &mHRBattle::mGetChangeCameraRailFlag)
			.addFunction("mGetCameraAngleX", &mHRBattle::mGetCameraAngleX)
			.addFunction("mSetLockNavelPos", &mHRBattle::mSetLockNavelPos)
			.addFunction("mGetTotalKillNum", &mHRBattle::mGetTotalKillNum)
			.addFunction("mSetTotalKillNum", &mHRBattle::mSetTotalKillNum)
			.addFunction("mGetBossBreakSlow", &mHRBattle::mGetBossBreakSlow)
			.addFunction("mGetNpcAttackFlag", &mHRBattle::mGetNpcAttackFlag)
			.addFunction("mGetNpcAttackRate", &mHRBattle::mGetNpcAttackRate)
			.addFunction("AddRevengeMissionZakoKillNum", &mHRBattle::AddRevengeMissionZakoKillNum)
			.addFunction("SetCameraMotionEndStop", &mHRBattle::SetCameraMotionEndStop)
			.addFunction("IsBgmEffect", &mHRBattle::IsBgmEffect)
			.addFunction("mSetDontChangeTeppeiCamera", &mHRBattle::mSetDontChangeTeppeiCamera)
			.addFunction("UpdateMassKillAchievement", &mHRBattle::UpdateMassKillAchievement)
			.addFunction("UpdateMainScreenUI", &mHRBattle::UpdateMainScreenUI)
			.addFunction("BgmEffectProc", &mHRBattle::BgmEffectProc)
			.addFunction("SetBgmEffect", &mHRBattle::SetBgmEffect)
			.addFunction("GetNpc", &mHRBattle::GetNpc)
			.addFunction("mCheckPcLoaded4WepaponChange", &mHRBattle::mCheckPcLoaded4WepaponChange)
			.addFunction("mCheckBattleInit", &mHRBattle::mCheckBattleInit)
			.addStaticFunction("ChkToiletStage", &mHRBattle::ChkToiletStage)
			.addStaticFunction("ChkBikeStage", &mHRBattle::ChkBikeStage)
			.addFunction("GetPickUpGomiSubMissionResult", &mHRBattle::GetPickUpGomiSubMissionResult)
			.addFunction("mAddKillNum", &mHRBattle::mAddKillNum)
			.addFunction("mSetNpcAppear", &mHRBattle::mSetNpcAppear)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("FixRotationOfItem", &mHRBattle::FixRotationOfItem)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("FixPositionOfItem", &mHRBattle::FixPositionOfItem)
			.addFunction("mSetInitCustomColliderObj", &mHRBattle::mSetInitCustomColliderObj)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitCharaPos", &mHRBattle::mSetInitCharaPos)
			.addFunction("mCheckStatusDispOnlyBattery", &mHRBattle::mCheckStatusDispOnlyBattery)
			.addFunction("mCheckStatusDispWithoutBattery", &mHRBattle::mCheckStatusDispWithoutBattery)
			.addFunction("mCheckStatusDisp", &mHRBattle::mCheckStatusDisp)
			.addFunction("mUndispMoney", &mHRBattle::mUndispMoney)
			.addFunction("mDispMoney", &mHRBattle::mDispMoney)
			.addFunction("mGetDispPcStatus", &mHRBattle::mGetDispPcStatus)
			.addFunction("mReleaseAllNpcWithoutCmnObj", &mHRBattle::mReleaseAllNpcWithoutCmnObj)
			.addFunction("mSetBulletSlowTick", &mHRBattle::mSetBulletSlowTick)
			.addFunction("mResetBulletSlow", &mHRBattle::mResetBulletSlow)
			.addFunction("mResetSlowMotion", &mHRBattle::mResetSlowMotion)
			.addFunction("mLightReflectEfProc", &mHRBattle::mLightReflectEfProc)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mCheckSamePopNpcPosAsNpcDat", &mHRBattle::mCheckSamePopNpcPosAsNpcDat)
			.addFunction("mGetEmptyNpcDatIndex", &mHRBattle::mGetEmptyNpcDatIndex)
			.addFunction("mRestorePcData4Lap", &mHRBattle::mRestorePcData4Lap)
			.addFunction("mStorePcData4Lap", &mHRBattle::mStorePcData4Lap)
			.addFunction("mCallPadProcess", &mHRBattle::mCallPadProcess)
			.addFunction("mClearNpcDat", &mHRBattle::mClearNpcDat)
			.addFunction("mEffectProc", &mHRBattle::mEffectProc)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetPopNpc", &mHRBattle::mSetPopNpc)
			.addFunction("mTestNpcType", &mHRBattle::mTestNpcType)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetNpcEnterPattern", &mHRBattle::mSetNpcEnterPattern)
			.addFunction("mSetShadowRate4CommonObject", &mHRBattle::mSetShadowRate4CommonObject)
			.addFunction("mCreateNewNpc", &mHRBattle::mCreateNewNpc)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mCheckNpcInitHp", &mHRBattle::mCheckNpcInitHp)
			.addFunction("mCheckDeadNpc", &mHRBattle::mCheckDeadNpc)
			.addFunction("mGetEmptyNpcIndex", &mHRBattle::mGetEmptyNpcIndex)
			.addFunction("mGetResourceNpcNum", &mHRBattle::mGetResourceNpcNum)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetResourceZakoNpcMotion", &mHRBattle::mGetResourceZakoNpcMotion)
			.addFunction("mGetResourceZakoCmnMotion", &mHRBattle::mGetResourceZakoCmnMotion)
			.addFunction("mGetResourceZakoWepMotion", &mHRBattle::mGetResourceZakoWepMotion)
			// Can't export pointer to native type 'char const**' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetResourceNpc", &mHRBattle::mGetResourceNpc)
			.addFunction("GetNpcDatIndexByCharPtr", &mHRBattle::GetNpcDatIndexByCharPtr)
			.addFunction("mCameraRotD", &mHRBattle::mCameraRotD)
			.addFunction("mCameraRotU", &mHRBattle::mCameraRotU)
			.addFunction("mCameraRotR", &mHRBattle::mCameraRotR)
			.addFunction("mCameraRotL", &mHRBattle::mCameraRotL)
			.addFunction("mCameraFrameProc", &mHRBattle::mCameraFrameProc)
			.addFunction("mSetCameraOffset4Fps", &mHRBattle::mSetCameraOffset4Fps)
			.addFunction("mResetCameraOffset4Fps", &mHRBattle::mResetCameraOffset4Fps)
			.addFunction("mSetCameraOffset4En", &mHRBattle::mSetCameraOffset4En)
			.addFunction("mSetCameraOffset4Pc", &mHRBattle::mSetCameraOffset4Pc)
			.addFunction("mSetLockOnCameraZoomIn", &mHRBattle::mSetLockOnCameraZoomIn)
			.addFunction("mSetLockOnCameraZoomOut", &mHRBattle::mSetLockOnCameraZoomOut)
			.addFunction("mResetLockOnCameraZoom", &mHRBattle::mResetLockOnCameraZoom)
			.addFunction("mCheckUndispStatusStage", &mHRBattle::mCheckUndispStatusStage)
			.addFunction("mSetMoveInitCamera4MiniDemo", &mHRBattle::mSetMoveInitCamera4MiniDemo)
			.addFunction("mSetLockOnCamera", &mHRBattle::mSetLockOnCamera)
			.addFunction("mPcTerm", &mHRBattle::mPcTerm)
			.addFunction("mPcInit", &mHRBattle::mPcInit)
			.addFunction("mPopPcSaveData", &mHRBattle::mPopPcSaveData)
			.addFunction("mPushPcSaveData", &mHRBattle::mPushPcSaveData)
			.addFunction("mInitStart", &mHRBattle::mInitStart)
			.addFunction("mGetResourceCmnObj", &mHRBattle::mGetResourceCmnObj)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetLightReflecte", &mHRBattle::mSetLightReflecte)
			.addFunction("mInit", &mHRBattle::mInit)
			.addFunction("mFrameProc", &mHRBattle::mFrameProc)
			.addFunction("mSetVisibleAll", &mHRBattle::mSetVisibleAll)
			.addFunction("mSetOperateAll", &mHRBattle::mSetOperateAll)
			.addFunction("mSetNewGameDataRequest", &mHRBattle::mSetNewGameDataRequest)
			.addFunction("mTerm", &mHRBattle::mTerm)
			.addFunction("mPostRenderProc", &mHRBattle::mPostRenderProc)
			.addFunction("GetBowlingSubMissionResult", &mHRBattle::GetBowlingSubMissionResult)
			.addFunction("mCheckPcLoaded", &mHRBattle::mCheckPcLoaded)
			.addFunction("mGetPcOperate", &mHRBattle::mGetPcOperate)
			.addFunction("mSetMoveInitCamera", &mHRBattle::mSetMoveInitCamera)
			.addFunction("mInitStartMainMission", &mHRBattle::mInitStartMainMission)
			.addFunction("mGetNpcPtr", &mHRBattle::mGetNpcPtr)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitNpcDat", &mHRBattle::mSetInitNpcDat)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetInitObjDat", &mHRBattle::mSetInitObjDat)
			.addFunction("mSetPopType", &mHRBattle::mSetPopType)
			.addFunction("mSetPcKind", &mHRBattle::mSetPcKind)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat2", &mHRBattle::mSetInitNpcDat2)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat3", &mHRBattle::mSetInitNpcDat3)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat4", &mHRBattle::mSetInitNpcDat4)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat5", &mHRBattle::mSetInitNpcDat5)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat6", &mHRBattle::mSetInitNpcDat6)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetInitNpcDat7", &mHRBattle::mSetInitNpcDat7)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitNpcDatObj095", &mHRBattle::mSetInitNpcDatObj095)
			.addFunction("mDispPcStatus", &mHRBattle::mDispPcStatus)
			.addFunction("mDispMiniMap", &mHRBattle::mDispMiniMap)
			.addFunction("mUndispMiniMap", &mHRBattle::mUndispMiniMap)
			.addFunction("mDeleteNpc", &mHRBattle::mDeleteNpc)
			.addFunction("RequestMotionNoNpc", &mHRBattle::RequestMotionNoNpc)
			.addFunction("mGetNpcPtrFromCharaType", &mHRBattle::mGetNpcPtrFromCharaType)
			.addFunction("mSetZakoNpcMotionProcessDisEnable", &mHRBattle::mSetZakoNpcMotionProcessDisEnable)
			.addFunction("mSetAspectRate", &mHRBattle::mSetAspectRate)
			.addFunction("mCheckExistEnemy", &mHRBattle::mCheckExistEnemy)
			.addFunction("mAllTestZakoDamage", &mHRBattle::mAllTestZakoDamage)
			.addFunction("mAllTestZakoTameDamage", &mHRBattle::mAllTestZakoTameDamage)
			.addFunction("mAllEnemyDie", &mHRBattle::mAllEnemyDie)
			.addFunction("mAllClearNpcData", &mHRBattle::mAllClearNpcData)
			.addFunction("mSetCameraProjection", &mHRBattle::mSetCameraProjection)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetObjNpcID", &mHRBattle::mGetObjNpcID)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetObjPtr", &mHRBattle::mGetObjPtr)
			.addFunction("mPopNpc", &mHRBattle::mPopNpc)
			.addFunction("mSetSlowMotionTick", &mHRBattle::mSetSlowMotionTick)
			.addFunction("mReleaseAllEnemy", &mHRBattle::mReleaseAllEnemy)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetInitNpcDatObj183", &mHRBattle::mSetInitNpcDatObj183)
			.addFunction("mReleaseAllNpc", &mHRBattle::mReleaseAllNpc)
			.addFunction("mSetDontAppearStatus", &mHRBattle::mSetDontAppearStatus)
			.addFunction("CameraMotionModeReset", &mHRBattle::CameraMotionModeReset)
			.addFunction("mSetPcOperate", &mHRBattle::mSetPcOperate)
			.addFunction("mUndispPcStatus", &mHRBattle::mUndispPcStatus)
			.addFunction("mRenderProc", &mHRBattle::mRenderProc)
			.addFunction("mGetNpcMotionSpd", &mHRBattle::mGetNpcMotionSpd)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRBattle) == 146492, "expected class mHRBattle to be size 146492");

// enum enPcAttackEffect
enum enPcAttackEffect : uint32_t
{
	// <eEfGuard = 0x0>
	eEfGuard = 0,

	// <eEfHitSword = 0x1>
	eEfHitSword = 1,

	// <eEfHitFight = 0x2>
	eEfHitFight = 2,

	// <eEfHitPiyori = 0x3>
	eEfHitPiyori = 3,

	// <eEfHitGuardBreak = 0x4>
	eEfHitGuardBreak = 4,

	// <eEfMax = 0x5>
	eEfMax = 5

};

// enum enThrowDir
enum enThrowDir : uint32_t
{
	// <enThrowDirF = 0x0>
	enThrowDirF = 0,

	// <enThrowDirB = 0x1>
	enThrowDirB = 1,

	// <enThrowDirLR = 0x2>
	enThrowDirLR = 2,

	// <enThrowDirH = 0x3>
	enThrowDirH = 3,

	// <enThrowDirMax = 0x4>
	enThrowDirMax = 4

};

// enum enScreenChangeStatus
enum enScreenChangeStatus : uint32_t
{
	// <ScreenChangeStatusStandby = 0x0>
	ScreenChangeStatusStandby = 0,

	// <ScreenChangeStatusFadeIn = 0x1>
	ScreenChangeStatusFadeIn = 1,

	// <ScreenChangeStatusFadeStandby = 0x2>
	ScreenChangeStatusFadeStandby = 2,

	// <ScreenChangeStatusFadeOut = 0x3>
	ScreenChangeStatusFadeOut = 3,

	// <ScreenChangeStatusMax = 0x4>
	ScreenChangeStatusMax = 4

};

// enum eEfDmgLevel
enum eEfDmgLevel : uint32_t
{
	// <eEfDmgLevel_UNKNOWN = 0xffffffffffffffff>
	eEfDmgLevel_UNKNOWN = UINT32_MAX,

	// <eEfDmgLevel_Small = 0x0>
	eEfDmgLevel_Small = 0,

	// <eEfDmgLevel_Big = 0x1>
	eEfDmgLevel_Big = 1,

	// <eEfDmgLevel_Slash = 0x2>
	eEfDmgLevel_Slash = 2,

	// <eEfDmgLevel_NUM = 0x3>
	eEfDmgLevel_NUM = 3

};

// enum enDownStatus
enum enDownStatus : uint32_t
{
	// <eDownFront = 0x0>
	eDownFront = 0,

	// <eDownBack = 0x1>
	eDownBack = 1,

	// <eDownMax = 0x2>
	eDownMax = 2

};

// enum enPcPose
enum enPcPose : uint32_t
{
	// <ePcPoseUpper = 0x0>
	ePcPoseUpper = 0,

	// <ePcPoseBottom = 0x1>
	ePcPoseBottom = 1,

	// <ePcPoseMax = 0x2>
	ePcPoseMax = 2

};

// enum enPcCmbKind
enum enPcCmbKind : uint32_t
{
	// <ePcAtkFghtCmbUp = 0x0>
	ePcAtkFghtCmbUp = 0,

	// <ePcAtkFghtCmbDw = 0x1>
	ePcAtkFghtCmbDw = 1,

	// <ePcAtkCmb01Up = 0x2>
	ePcAtkCmb01Up = 2,

	// <ePcAtkCmb01Btm = 0x3>
	ePcAtkCmb01Btm = 3,

	// <ePcAtkCmb02Up = 0x4>
	ePcAtkCmb02Up = 4,

	// <ePcAtkCmb02Btm = 0x5>
	ePcAtkCmb02Btm = 5,

	// <ePcAtkCmb03Up = 0x6>
	ePcAtkCmb03Up = 6,

	// <ePcAtkCmb03Btm = 0x7>
	ePcAtkCmb03Btm = 7,

	// <ePcAtkCmb04Up = 0x8>
	ePcAtkCmb04Up = 8,

	// <ePcAtkCmb04Btm = 0x9>
	ePcAtkCmb04Btm = 9,

	// <ePcAtkCmb01Dncng = 0xa>
	ePcAtkCmb01Dncng = 10,

	// <ePcAtkCmb02Dncng = 0xb>
	ePcAtkCmb02Dncng = 11,

	// <ePcAtkCmb03Dncng = 0xc>
	ePcAtkCmb03Dncng = 12,

	// <ePcAtkCmb04Dncng = 0xd>
	ePcAtkCmb04Dncng = 13,

	// <eSNBAtkCmb01Up = 0xe>
	eSNBAtkCmb01Up = 14,

	// <eSNBAtkCmb01Btm = 0xf>
	eSNBAtkCmb01Btm = 15,

	// <eHENAtkCmb01Up = 0x10>
	eHENAtkCmb01Up = 16,

	// <eHENAtkCmb01Btm = 0x11>
	eHENAtkCmb01Btm = 17,

	// <ePcAtkCmbKindMax = 0x12>
	ePcAtkCmbKindMax = 18

};

// enum enShakeDir
enum enShakeDir : uint32_t
{
	// <eShakeUp2Down = 0x0>
	eShakeUp2Down = 0,

	// <eShakeDown2Up = 0x1>
	eShakeDown2Up = 1,

	// <eShakeLeft2Right = 0x2>
	eShakeLeft2Right = 2,

	// <eShakeRight2Left = 0x3>
	eShakeRight2Left = 3,

	// <eShakeThrust = 0x4>
	eShakeThrust = 4,

	// <eShakePull = 0x5>
	eShakePull = 5,

	// <eShakeCross = 0x6>
	eShakeCross = 6,

	// <eShakeNone = 0x7>
	eShakeNone = 7

};

// enum enEqKind
enum enEqKind : uint32_t
{
	// <eEqWeaponR = 0x0>
	eEqWeaponR = 0,

	// <eEqSunglass = 0x1>
	eEqSunglass = 1,

	// <eEqJacket = 0x2>
	eEqJacket = 2,

	// <eEqShoes = 0x3>
	eEqShoes = 3,

	// <eEqPants = 0x4>
	eEqPants = 4,

	// <eEqBelt = 0x5>
	eEqBelt = 5,

	// <eEqTshirt = 0x6>
	eEqTshirt = 6,

	// <eEqWBand = 0x7>
	eEqWBand = 7,

	// <eEqWeaponL = 0x8>
	eEqWeaponL = 8,

	// <eEqKindMax = 0x9>
	eEqKindMax = 9

};

// [Structure] class CTimeRatioInterpolate
class CTimeRatioInterpolate
{
public:
	/// Struct member variables

	// <float m_fOneRatioTime, offset 0x0>
	float m_fOneRatioTime;

	// <float m_fRatio, offset 0x4>
	float m_fRatio;

	// <float m_fTimer, offset 0x8>
	float m_fTimer;

	std::string ToString() const { return "class CTimeRatioInterpolate(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CTimeRatioInterpolate>("CTimeRatioInterpolate")
			.addFunction("__tostring", &CTimeRatioInterpolate::ToString)
			.addFunction("GetPtrAddr", &CTimeRatioInterpolate::GetPtrAddr)
			.addProperty("m_fOneRatioTime", &CTimeRatioInterpolate::m_fOneRatioTime)
			.addProperty("m_fRatio", &CTimeRatioInterpolate::m_fRatio)
			.addProperty("m_fTimer", &CTimeRatioInterpolate::m_fTimer)
		.endClass();
	}
#endif
};
static_assert(sizeof(CTimeRatioInterpolate::m_fOneRatioTime) == 4, "expected m_fOneRatioTime to be size 4");
static_assert(sizeof(CTimeRatioInterpolate::m_fRatio) == 4, "expected m_fRatio to be size 4");
static_assert(sizeof(CTimeRatioInterpolate::m_fTimer) == 4, "expected m_fTimer to be size 4");
static_assert(sizeof(CTimeRatioInterpolate) == 12, "expected class CTimeRatioInterpolate to be size 12");

// enum enWepChangeProc
enum enWepChangeProc : uint32_t
{
	// <eWepChangeInit = 0x0>
	eWepChangeInit = 0,

	// <eWepChangeWait = 0x1>
	eWepChangeWait = 1,

	// <eWepChangeMax = 0x2>
	eWepChangeMax = 2

};

// [Structure] union uniSMflag
union uniSMflag
{
public:
	/// Struct member variables

	// <uint16_t smBaceActivSubMission, offset 0x0>
	uint16_t smBaceActivSubMission;

	std::string ToString() const { return "union uniSMflag(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<uniSMflag>("uniSMflag")
			.addFunction("__tostring", &uniSMflag::ToString)
			.addFunction("GetPtrAddr", &uniSMflag::GetPtrAddr)
			.addProperty("smBaceActivSubMission", &uniSMflag::smBaceActivSubMission)
		.endClass();
	}
#endif
};
static_assert(sizeof(uniSMflag::smBaceActivSubMission) == 2, "expected smBaceActivSubMission to be size 2");
static_assert(sizeof(uniSMflag) == 2, "expected union uniSMflag to be size 2");

// enum enScreenChangeKind
enum enScreenChangeKind : uint32_t
{
	// <eScreenChangeStencil = 0x0>
	eScreenChangeStencil = 0,

	// <eScreenChangeFade = 0x1>
	eScreenChangeFade = 1,

	// <eScreenChangeMax = 0x2>
	eScreenChangeMax = 2

};

// [Structure] struct stFade
struct stFade
{
public:
	/// Struct member variables

	// <enum enScreenChangeKind kind, offset 0x0>
	enum enScreenChangeKind kind;

	// <uint8_t requestStart, offset 0x4>
	uint8_t requestStart;

	// <uint8_t requestEnd, offset 0x5>
	uint8_t requestEnd;

	// <Unidentified data segment, offset 0x6>
private:
	char _UnidentifiedData3[2];

public:
	// <class HrOverLap* pOverLap, offset 0x8>
	class HrOverLap* pOverLap;

	std::string ToString() const { return "struct stFade(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stFade>("stFade")
			.addFunction("__tostring", &stFade::ToString)
			.addFunction("GetPtrAddr", &stFade::GetPtrAddr)
			.addProperty("kind", &stFade::kind)
			.addProperty("requestStart", &stFade::requestStart)
			.addProperty("requestEnd", &stFade::requestEnd)
			.addProperty("pOverLap", &stFade::pOverLap)
		.endClass();
	}
#endif
};
static_assert(sizeof(stFade::kind) == 4, "expected kind to be size 4");
static_assert(sizeof(stFade::requestStart) == 1, "expected requestStart to be size 1");
static_assert(sizeof(stFade::requestEnd) == 1, "expected requestEnd to be size 1");
static_assert(sizeof(stFade::pOverLap) == 4, "expected pOverLap to be size 4");
static_assert(sizeof(stFade) == 12, "expected struct stFade to be size 12");

// enum enCharaInitProc
enum enCharaInitProc : uint32_t
{
	// <eCharaInitProcPrepareForReadRsl = 0x0>
	eCharaInitProcPrepareForReadRsl = 0,

	// <eCharaInitProcReadRsl = 0x1>
	eCharaInitProcReadRsl = 1,

	// <eCharaInitProcReadRslWait = 0x2>
	eCharaInitProcReadRslWait = 2,

	// <eCharaInitProcPrepareForRsl = 0x3>
	eCharaInitProcPrepareForRsl = 3,

	// <eCharaInitProcFinish = 0x4>
	eCharaInitProcFinish = 4,

	// <eCharaInitProcMax = 0x5>
	eCharaInitProcMax = 5

};

// [Structure] class CSpringInterpolate
class CSpringInterpolate
{
public:
	/// Struct member variables

	// <float m_fSpringCoe, offset 0x0>
	float m_fSpringCoe;

	// <float m_fMaxVel, offset 0x4>
	float m_fMaxVel;

	// <float m_fMinVel, offset 0x8>
	float m_fMinVel;

	// <uint8_t m_bIsRadiInterp, offset 0xc>
	uint8_t m_bIsRadiInterp;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData4[3];

public:
	// <float m_fEpsilon, offset 0x10>
	float m_fEpsilon;

	// <float m_fValue, offset 0x14>
	float m_fValue;

	std::string ToString() const { return "class CSpringInterpolate(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CSpringInterpolate>("CSpringInterpolate")
			.addFunction("__tostring", &CSpringInterpolate::ToString)
			.addFunction("GetPtrAddr", &CSpringInterpolate::GetPtrAddr)
			.addProperty("m_fSpringCoe", &CSpringInterpolate::m_fSpringCoe)
			.addProperty("m_fMaxVel", &CSpringInterpolate::m_fMaxVel)
			.addProperty("m_fMinVel", &CSpringInterpolate::m_fMinVel)
			.addProperty("m_bIsRadiInterp", &CSpringInterpolate::m_bIsRadiInterp)
			.addProperty("m_fEpsilon", &CSpringInterpolate::m_fEpsilon)
			.addProperty("m_fValue", &CSpringInterpolate::m_fValue)
		.endClass();
	}
#endif
};
static_assert(sizeof(CSpringInterpolate::m_fSpringCoe) == 4, "expected m_fSpringCoe to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fMaxVel) == 4, "expected m_fMaxVel to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fMinVel) == 4, "expected m_fMinVel to be size 4");
static_assert(sizeof(CSpringInterpolate::m_bIsRadiInterp) == 1, "expected m_bIsRadiInterp to be size 1");
static_assert(sizeof(CSpringInterpolate::m_fEpsilon) == 4, "expected m_fEpsilon to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fValue) == 4, "expected m_fValue to be size 4");
static_assert(sizeof(CSpringInterpolate) == 24, "expected class CSpringInterpolate to be size 24");

// [Structure] class CDoubleSpringInterpolate
class CDoubleSpringInterpolate
{
public:
	/// Struct member variables

	// <class CSpringInterpolate m_inHopeInterp, offset 0x0>
	class CSpringInterpolate m_inHopeInterp;

	// <class CSpringInterpolate m_inCurInterp, offset 0x18>
	class CSpringInterpolate m_inCurInterp;

	std::string ToString() const { return "class CDoubleSpringInterpolate(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CDoubleSpringInterpolate>("CDoubleSpringInterpolate")
			.addFunction("__tostring", &CDoubleSpringInterpolate::ToString)
			.addFunction("GetPtrAddr", &CDoubleSpringInterpolate::GetPtrAddr)
			.addProperty("m_inHopeInterp", &CDoubleSpringInterpolate::m_inHopeInterp)
			.addProperty("m_inCurInterp", &CDoubleSpringInterpolate::m_inCurInterp)
		.endClass();
	}
#endif
};
static_assert(sizeof(CDoubleSpringInterpolate::m_inHopeInterp) == 24, "expected m_inHopeInterp to be size 24");
static_assert(sizeof(CDoubleSpringInterpolate::m_inCurInterp) == 24, "expected m_inCurInterp to be size 24");
static_assert(sizeof(CDoubleSpringInterpolate) == 48, "expected class CDoubleSpringInterpolate to be size 48");

// [Structure] class CAmbientShadow
class CAmbientShadow
{
public:
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inRatio, offset 0x0>
	class CDoubleSpringInterpolate m_inRatio;

	// <float m_fSetRatio, offset 0x30>
	float m_fSetRatio;

	// <class TGmf* m_pPreGmf, offset 0x34>
	class TGmf* m_pPreGmf;

	std::string ToString() const { return "class CAmbientShadow(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CAmbientShadow>("CAmbientShadow")
			.addFunction("__tostring", &CAmbientShadow::ToString)
			.addFunction("GetPtrAddr", &CAmbientShadow::GetPtrAddr)
			.addProperty("m_inRatio", &CAmbientShadow::m_inRatio)
			.addProperty("m_fSetRatio", &CAmbientShadow::m_fSetRatio)
			.addProperty("m_pPreGmf", &CAmbientShadow::m_pPreGmf)
		.endClass();
	}
#endif
};
static_assert(sizeof(CAmbientShadow::m_inRatio) == 48, "expected m_inRatio to be size 48");
static_assert(sizeof(CAmbientShadow::m_fSetRatio) == 4, "expected m_fSetRatio to be size 4");
static_assert(sizeof(CAmbientShadow::m_pPreGmf) == 4, "expected m_pPreGmf to be size 4");
static_assert(sizeof(CAmbientShadow) == 56, "expected class CAmbientShadow to be size 56");

// [Structure] struct stCharaEffect
struct stCharaEffect
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[292];
public:

	std::string ToString() const { return "struct stCharaEffect(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaEffect>("stCharaEffect")
			.addFunction("__tostring", &stCharaEffect::ToString)
			.addFunction("GetPtrAddr", &stCharaEffect::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(stCharaEffect) == 292, "expected struct stCharaEffect to be size 292");

// [Structure] class stCharaFileData
class stCharaFileData
{
public:
	/// Struct member variables

	// <class ghmGcFile* file, offset 0x0>
	class ghmGcFile* file;

	// <void* pData, offset 0x4>
	void* pData;

	// <class ghmResGroup* pRsl, offset 0x8>
	class ghmResGroup* pRsl;

	// <class TGmf* pGmf, offset 0xc>
	class TGmf* pGmf;

	// <class TGmf* pGmfDead, offset 0x10>
	class TGmf* pGmfDead;

	// <class TGmf* pGmfWepR, offset 0x14>
	class TGmf* pGmfWepR;

	// <class TGmf* pGmfWepL, offset 0x18>
	class TGmf* pGmfWepL;

	// <int16_t motionNumMax, offset 0x1c>
	int16_t motionNumMax;

	// <uint8_t readyDelete, offset 0x1e>
	uint8_t readyDelete;

	// <Unidentified data segment, offset 0x1f>
private:
	char _UnidentifiedData9[1];

public:
	// <int32_t sndFileHandle, offset 0x20>
	int32_t sndFileHandle;

	// <struct HRCHARAVOICE* pVoice, offset 0x24>
	struct HRCHARAVOICE* pVoice;

	// <char FileName[0x9], offset 0x28>
	char FileName[9];

	// <Unidentified data segment, offset 0x31>
private:
	char _UnidentifiedData12[3];

public:
	// <class TGan** pGan, offset 0x34>
	class TGan** pGan;

	std::string ToString() const { return "class stCharaFileData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaFileData>("stCharaFileData")
			.addFunction("__tostring", &stCharaFileData::ToString)
			.addFunction("GetPtrAddr", &stCharaFileData::GetPtrAddr)
			.addProperty("file", &stCharaFileData::file)
			// void type not supported in LuaBridge
			//.addProperty("pData", &stCharaFileData::pData)
			.addProperty("pRsl", &stCharaFileData::pRsl)
			.addProperty("pGmf", &stCharaFileData::pGmf)
			.addProperty("pGmfDead", &stCharaFileData::pGmfDead)
			.addProperty("pGmfWepR", &stCharaFileData::pGmfWepR)
			.addProperty("pGmfWepL", &stCharaFileData::pGmfWepL)
			.addProperty("motionNumMax", &stCharaFileData::motionNumMax)
			.addProperty("readyDelete", &stCharaFileData::readyDelete)
			.addProperty("sndFileHandle", &stCharaFileData::sndFileHandle)
			.addProperty("pVoice", &stCharaFileData::pVoice)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("FileName", &stCharaFileData::FileName)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("pGan", &stCharaFileData::pGan)
		.endClass();
	}
#endif
};
static_assert(sizeof(stCharaFileData::file) == 4, "expected file to be size 4");
static_assert(sizeof(stCharaFileData::pData) == 4, "expected pData to be size 4");
static_assert(sizeof(stCharaFileData::pRsl) == 4, "expected pRsl to be size 4");
static_assert(sizeof(stCharaFileData::pGmf) == 4, "expected pGmf to be size 4");
static_assert(sizeof(stCharaFileData::pGmfDead) == 4, "expected pGmfDead to be size 4");
static_assert(sizeof(stCharaFileData::pGmfWepR) == 4, "expected pGmfWepR to be size 4");
static_assert(sizeof(stCharaFileData::pGmfWepL) == 4, "expected pGmfWepL to be size 4");
static_assert(sizeof(stCharaFileData::motionNumMax) == 2, "expected motionNumMax to be size 2");
static_assert(sizeof(stCharaFileData::readyDelete) == 1, "expected readyDelete to be size 1");
static_assert(sizeof(stCharaFileData::sndFileHandle) == 4, "expected sndFileHandle to be size 4");
static_assert(sizeof(stCharaFileData::pVoice) == 4, "expected pVoice to be size 4");
static_assert(sizeof(stCharaFileData::FileName) == 9, "expected FileName to be size 9");
static_assert(sizeof(stCharaFileData::pGan) == 4, "expected pGan to be size 4");
static_assert(sizeof(stCharaFileData) == 56, "expected class stCharaFileData to be size 56");

// [Structure] class ghmSegment
class ghmSegment
{
public:
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mDir, offset 0xc>
	struct Vec mDir;

	// <float mExtent, offset 0x18>
	float mExtent;

	std::string ToString() const { return "class ghmSegment(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmSegment>("ghmSegment")
			.addFunction("__tostring", &ghmSegment::ToString)
			.addFunction("GetPtrAddr", &ghmSegment::GetPtrAddr)
			.addProperty("mCenter", &ghmSegment::mCenter)
			.addProperty("mDir", &ghmSegment::mDir)
			.addProperty("mExtent", &ghmSegment::mExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmSegment::mCenter) == 12, "expected mCenter to be size 12");
static_assert(sizeof(ghmSegment::mDir) == 12, "expected mDir to be size 12");
static_assert(sizeof(ghmSegment::mExtent) == 4, "expected mExtent to be size 4");
static_assert(sizeof(ghmSegment) == 28, "expected class ghmSegment to be size 28");

// [Structure] class ghmCapsule
class ghmCapsule
{
public:
	/// Struct member variables

	// <class ghmSegment mAxis, offset 0x0>
	class ghmSegment mAxis;

	// <float mRadius, offset 0x1c>
	float mRadius;

	std::string ToString() const { return "class ghmCapsule(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmCapsule>("ghmCapsule")
			.addFunction("__tostring", &ghmCapsule::ToString)
			.addFunction("GetPtrAddr", &ghmCapsule::GetPtrAddr)
			.addProperty("mAxis", &ghmCapsule::mAxis)
			.addProperty("mRadius", &ghmCapsule::mRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmCapsule::mAxis) == 28, "expected mAxis to be size 28");
static_assert(sizeof(ghmCapsule::mRadius) == 4, "expected mRadius to be size 4");
static_assert(sizeof(ghmCapsule) == 32, "expected class ghmCapsule to be size 32");

// [Structure] class ghmGcOctTreeNodeObj
class ghmGcOctTreeNodeObj
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x2], offset 0x0>
	void* (* field_0)[0x2];

	// <class ghmGcOctTreeNode* mpContainer, offset 0x4>
	class ghmGcOctTreeNode* mpContainer;

	// <ghmGcOctTreeNodeObj* mpNext, offset 0x8>
	ghmGcOctTreeNodeObj* mpNext;

	// <ghmGcOctTreeNodeObj* mpPrev, offset 0xc>
	ghmGcOctTreeNodeObj* mpPrev;

	// <uint32_t mUserData, offset 0x10>
	uint32_t mUserData;

	std::string ToString() const { return "class ghmGcOctTreeNodeObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTreeNodeObj>("ghmGcOctTreeNodeObj")
			.addFunction("__tostring", &ghmGcOctTreeNodeObj::ToString)
			.addFunction("GetPtrAddr", &ghmGcOctTreeNodeObj::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTreeNodeObj::field_0)
			.addProperty("mpContainer", &ghmGcOctTreeNodeObj::mpContainer)
			.addProperty("mpNext", &ghmGcOctTreeNodeObj::mpNext)
			.addProperty("mpPrev", &ghmGcOctTreeNodeObj::mpPrev)
			.addProperty("mUserData", &ghmGcOctTreeNodeObj::mUserData)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTreeNodeObj::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpContainer) == 4, "expected mpContainer to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mUserData) == 4, "expected mUserData to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj) == 20, "expected class ghmGcOctTreeNodeObj to be size 20");

// [Structure] class ghmGcCollObj
class ghmGcCollObj : public ghmGcOctTreeNodeObj
{
public:
	// enum ghmGcCollObj::Type
	enum Type : uint32_t
	{
		// <TYPE_TRIANGLE = 0x0>
		TYPE_TRIANGLE = 0,

		// <TYPE_SPHERE = 0x1>
		TYPE_SPHERE = 1,

		// <TYPE_AABB = 0x2>
		TYPE_AABB = 2,

		// <TYPE_OBB = 0x3>
		TYPE_OBB = 3,

		// <TYPE_CAPSULE = 0x4>
		TYPE_CAPSULE = 4,

		// <TYPE_USER = 0x5>
		TYPE_USER = 5,

		// <TYPE_INVALID = 0xffffffffffffffff>
		TYPE_INVALID = UINT32_MAX

	};

	/// Struct member variables

	// <class ghmGcOctTreeNodeObj field_0, offset 0x0>
	// class ghmGcOctTreeNodeObj Super;

	// <enum ghmGcCollObj::Type mObjType, offset 0x14>
	enum ghmGcCollObj::Type mObjType;

	// <uint32_t mGroup, offset 0x18>
	uint32_t mGroup;

	// <uint32_t mIgnoreGroup, offset 0x1c>
	uint32_t mIgnoreGroup;

	// <int32_t (* mpHitTestCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*), offset 0x20>
	int32_t (* mpHitTestCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*);

	// <int32_t (* mpHitCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*), offset 0x24>
	int32_t (* mpHitCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*);

	// <struct Vec mVelocity, offset 0x28>
	struct Vec mVelocity;

	// <uint32_t mFlag, offset 0x34>
	uint32_t mFlag;

	// <uint32_t mParam[0x2], offset 0x38>
	uint32_t mParam[2];

	std::string ToString() const { return "class ghmGcCollObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmGcCollObj, ghmGcOctTreeNodeObj>("ghmGcCollObj")
			.addFunction("__tostring", &ghmGcCollObj::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObj::GetPtrAddr)
			.addProperty("mObjType", &ghmGcCollObj::mObjType)
			.addProperty("mGroup", &ghmGcCollObj::mGroup)
			.addProperty("mIgnoreGroup", &ghmGcCollObj::mIgnoreGroup)
			// delegates are not supported in LuaBridge
			//.addProperty("mpHitTestCallback", &ghmGcCollObj::mpHitTestCallback)
			// delegates are not supported in LuaBridge
			//.addProperty("mpHitCallback", &ghmGcCollObj::mpHitCallback)
			.addProperty("mVelocity", &ghmGcCollObj::mVelocity)
			.addProperty("mFlag", &ghmGcCollObj::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mParam", &ghmGcCollObj::mParam)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObj::mObjType) == 4, "expected mObjType to be size 4");
static_assert(sizeof(ghmGcCollObj::mGroup) == 4, "expected mGroup to be size 4");
static_assert(sizeof(ghmGcCollObj::mIgnoreGroup) == 4, "expected mIgnoreGroup to be size 4");
static_assert(sizeof(ghmGcCollObj::mpHitTestCallback) == 4, "expected mpHitTestCallback to be size 4");
static_assert(sizeof(ghmGcCollObj::mpHitCallback) == 4, "expected mpHitCallback to be size 4");
static_assert(sizeof(ghmGcCollObj::mVelocity) == 12, "expected mVelocity to be size 12");
static_assert(sizeof(ghmGcCollObj::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmGcCollObj::mParam) == 8, "expected mParam to be size 8");
static_assert(sizeof(ghmGcCollObj) == 64, "expected class ghmGcCollObj to be size 64");

// [Structure] class ghmGcCollObjCapsule
class ghmGcCollObjCapsule : public ghmGcCollObj
{
public:
	/// Struct member variables

	// <class ghmGcCollObj field_0, offset 0x0>
	// class ghmGcCollObj Super;

	// <class ghmCapsule mShape, offset 0x40>
	class ghmCapsule mShape;

	std::string ToString() const { return "class ghmGcCollObjCapsule(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmGcCollObjCapsule, ghmGcCollObj>("ghmGcCollObjCapsule")
			.addFunction("__tostring", &ghmGcCollObjCapsule::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObjCapsule::GetPtrAddr)
			.addProperty("mShape", &ghmGcCollObjCapsule::mShape)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjCapsule::mShape) == 32, "expected mShape to be size 32");
static_assert(sizeof(ghmGcCollObjCapsule) == 96, "expected class ghmGcCollObjCapsule to be size 96");

// [Structure] class WAnim
class WAnim
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	std::string ToString() const { return "class WAnim(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WAnim>("WAnim")
			.addFunction("__tostring", &WAnim::ToString)
			.addFunction("GetPtrAddr", &WAnim::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &WAnim::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(WAnim::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(WAnim) == 4, "expected class WAnim to be size 4");

// [Structure] class WAnimF
class WAnimF : public WAnim
{
public:
	/// Struct member variables

	// <class WAnim field_0, offset 0x0>
	// class WAnim Super;

	// <float mCurValue, offset 0x4>
	float mCurValue;

	// <float mDstValue, offset 0x8>
	float mDstValue;

	// <float mSrcValue, offset 0xc>
	float mSrcValue;

	// <uint32_t mCount, offset 0x10>
	uint32_t mCount;

	// <uint32_t mTime, offset 0x14>
	uint32_t mTime;

	// <int32_t mIpType, offset 0x18>
	int32_t mIpType;

	// <float mMotionRate, offset 0x1c>
	float mMotionRate;

	std::string ToString() const { return "class WAnimF(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<WAnimF, WAnim>("WAnimF")
			.addFunction("__tostring", &WAnimF::ToString)
			.addFunction("GetPtrAddr", &WAnimF::GetPtrAddr)
			.addProperty("mCurValue", &WAnimF::mCurValue)
			.addProperty("mDstValue", &WAnimF::mDstValue)
			.addProperty("mSrcValue", &WAnimF::mSrcValue)
			.addProperty("mCount", &WAnimF::mCount)
			.addProperty("mTime", &WAnimF::mTime)
			.addProperty("mIpType", &WAnimF::mIpType)
			.addProperty("mMotionRate", &WAnimF::mMotionRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(WAnimF::mCurValue) == 4, "expected mCurValue to be size 4");
static_assert(sizeof(WAnimF::mDstValue) == 4, "expected mDstValue to be size 4");
static_assert(sizeof(WAnimF::mSrcValue) == 4, "expected mSrcValue to be size 4");
static_assert(sizeof(WAnimF::mCount) == 4, "expected mCount to be size 4");
static_assert(sizeof(WAnimF::mTime) == 4, "expected mTime to be size 4");
static_assert(sizeof(WAnimF::mIpType) == 4, "expected mIpType to be size 4");
static_assert(sizeof(WAnimF::mMotionRate) == 4, "expected mMotionRate to be size 4");
static_assert(sizeof(WAnimF) == 32, "expected class WAnimF to be size 32");

// [Structure] struct stDamageInfo
struct stDamageInfo
{
public:
	/// Struct member variables

	// <float dmg, offset 0x0>
	float dmg;

	// <int32_t dmgMot, offset 0x4>
	int32_t dmgMot;

	// <int32_t grdMot, offset 0x8>
	int32_t grdMot;

	// <int32_t atkMot, offset 0xc>
	int32_t atkMot;

	// <int32_t atkKind, offset 0x10>
	int32_t atkKind;

	// <float dmgDirec, offset 0x14>
	float dmgDirec;

	// <float nockBackSpd, offset 0x18>
	float nockBackSpd;

	// <float nockBackDst, offset 0x1c>
	float nockBackDst;

	// <struct Vec nockBackDir, offset 0x20>
	struct Vec nockBackDir;

	// <float nockBackMasatu, offset 0x2c>
	float nockBackMasatu;

	// <float upperPow, offset 0x30>
	float upperPow;

	// <float upperPowLast, offset 0x34>
	float upperPowLast;

	// <float upperPosY, offset 0x38>
	float upperPosY;

	// <float grav, offset 0x3c>
	float grav;

	// <uint8_t upper, offset 0x40>
	uint8_t upper;

	// <Unidentified data segment, offset 0x41>
private:
	char _UnidentifiedData15[3];

public:
	// <int32_t tick, offset 0x44>
	int32_t tick;

	// <class WAnimF fade, offset 0x48>
	class WAnimF fade;

	// <uint8_t m_PiyoRequest, offset 0x68>
	uint8_t m_PiyoRequest;

	// <uint8_t m_BikeDeadRequest, offset 0x69>
	uint8_t m_BikeDeadRequest;

	// <Unidentified data segment, offset 0x6a>
private:
	char _UnidentifiedData[2];
public:

	std::string ToString() const { return "struct stDamageInfo(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stDamageInfo>("stDamageInfo")
			.addFunction("__tostring", &stDamageInfo::ToString)
			.addFunction("GetPtrAddr", &stDamageInfo::GetPtrAddr)
			.addProperty("dmg", &stDamageInfo::dmg)
			.addProperty("dmgMot", &stDamageInfo::dmgMot)
			.addProperty("grdMot", &stDamageInfo::grdMot)
			.addProperty("atkMot", &stDamageInfo::atkMot)
			.addProperty("atkKind", &stDamageInfo::atkKind)
			.addProperty("dmgDirec", &stDamageInfo::dmgDirec)
			.addProperty("nockBackSpd", &stDamageInfo::nockBackSpd)
			.addProperty("nockBackDst", &stDamageInfo::nockBackDst)
			.addProperty("nockBackDir", &stDamageInfo::nockBackDir)
			.addProperty("nockBackMasatu", &stDamageInfo::nockBackMasatu)
			.addProperty("upperPow", &stDamageInfo::upperPow)
			.addProperty("upperPowLast", &stDamageInfo::upperPowLast)
			.addProperty("upperPosY", &stDamageInfo::upperPosY)
			.addProperty("grav", &stDamageInfo::grav)
			.addProperty("upper", &stDamageInfo::upper)
			.addProperty("tick", &stDamageInfo::tick)
			.addProperty("fade", &stDamageInfo::fade)
			.addProperty("m_PiyoRequest", &stDamageInfo::m_PiyoRequest)
			.addProperty("m_BikeDeadRequest", &stDamageInfo::m_BikeDeadRequest)
		.endClass();
	}
#endif
};
static_assert(sizeof(stDamageInfo::dmg) == 4, "expected dmg to be size 4");
static_assert(sizeof(stDamageInfo::dmgMot) == 4, "expected dmgMot to be size 4");
static_assert(sizeof(stDamageInfo::grdMot) == 4, "expected grdMot to be size 4");
static_assert(sizeof(stDamageInfo::atkMot) == 4, "expected atkMot to be size 4");
static_assert(sizeof(stDamageInfo::atkKind) == 4, "expected atkKind to be size 4");
static_assert(sizeof(stDamageInfo::dmgDirec) == 4, "expected dmgDirec to be size 4");
static_assert(sizeof(stDamageInfo::nockBackSpd) == 4, "expected nockBackSpd to be size 4");
static_assert(sizeof(stDamageInfo::nockBackDst) == 4, "expected nockBackDst to be size 4");
static_assert(sizeof(stDamageInfo::nockBackDir) == 12, "expected nockBackDir to be size 12");
static_assert(sizeof(stDamageInfo::nockBackMasatu) == 4, "expected nockBackMasatu to be size 4");
static_assert(sizeof(stDamageInfo::upperPow) == 4, "expected upperPow to be size 4");
static_assert(sizeof(stDamageInfo::upperPowLast) == 4, "expected upperPowLast to be size 4");
static_assert(sizeof(stDamageInfo::upperPosY) == 4, "expected upperPosY to be size 4");
static_assert(sizeof(stDamageInfo::grav) == 4, "expected grav to be size 4");
static_assert(sizeof(stDamageInfo::upper) == 1, "expected upper to be size 1");
static_assert(sizeof(stDamageInfo::tick) == 4, "expected tick to be size 4");
static_assert(sizeof(stDamageInfo::fade) == 32, "expected fade to be size 32");
static_assert(sizeof(stDamageInfo::m_PiyoRequest) == 1, "expected m_PiyoRequest to be size 1");
static_assert(sizeof(stDamageInfo::m_BikeDeadRequest) == 1, "expected m_BikeDeadRequest to be size 1");
static_assert(sizeof(stDamageInfo) == 108, "expected struct stDamageInfo to be size 108");

// [Structure] class ghmTriangle
class ghmTriangle
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[36];
public:

	std::string ToString() const { return "class ghmTriangle(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmTriangle>("ghmTriangle")
			.addFunction("__tostring", &ghmTriangle::ToString)
			.addFunction("GetPtrAddr", &ghmTriangle::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmTriangle) == 36, "expected class ghmTriangle to be size 36");

// [Structure] class ghmPlane
class ghmPlane
{
public:
	/// Struct member variables

	// <struct Vec mNormal, offset 0x0>
	struct Vec mNormal;

	// <float mDist, offset 0xc>
	float mDist;

	std::string ToString() const { return "class ghmPlane(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmPlane>("ghmPlane")
			.addFunction("__tostring", &ghmPlane::ToString)
			.addFunction("GetPtrAddr", &ghmPlane::GetPtrAddr)
			.addProperty("mNormal", &ghmPlane::mNormal)
			.addProperty("mDist", &ghmPlane::mDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmPlane::mNormal) == 12, "expected mNormal to be size 12");
static_assert(sizeof(ghmPlane::mDist) == 4, "expected mDist to be size 4");
static_assert(sizeof(ghmPlane) == 16, "expected class ghmPlane to be size 16");

// [Structure] class ghmGcCollObjHitResultObj
class ghmGcCollObjHitResultObj
{
public:
	/// Struct member variables

	// <class ghmPlane mPlane, offset 0x0>
	class ghmPlane mPlane;

	// <class ghmTriangle mTriangle, offset 0x10>
	class ghmTriangle mTriangle;

	// <struct Vec mPoint, offset 0x34>
	struct Vec mPoint;

	// <float mRate, offset 0x40>
	float mRate;

	// <uint32_t mAttr, offset 0x44>
	uint32_t mAttr;

	// <class ghmGcCollObj* mpObj, offset 0x48>
	class ghmGcCollObj* mpObj;

	std::string ToString() const { return "class ghmGcCollObjHitResultObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcCollObjHitResultObj>("ghmGcCollObjHitResultObj")
			.addFunction("__tostring", &ghmGcCollObjHitResultObj::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObjHitResultObj::GetPtrAddr)
			.addProperty("mPlane", &ghmGcCollObjHitResultObj::mPlane)
			.addProperty("mTriangle", &ghmGcCollObjHitResultObj::mTriangle)
			.addProperty("mPoint", &ghmGcCollObjHitResultObj::mPoint)
			.addProperty("mRate", &ghmGcCollObjHitResultObj::mRate)
			.addProperty("mAttr", &ghmGcCollObjHitResultObj::mAttr)
			.addProperty("mpObj", &ghmGcCollObjHitResultObj::mpObj)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjHitResultObj::mPlane) == 16, "expected mPlane to be size 16");
static_assert(sizeof(ghmGcCollObjHitResultObj::mTriangle) == 36, "expected mTriangle to be size 36");
static_assert(sizeof(ghmGcCollObjHitResultObj::mPoint) == 12, "expected mPoint to be size 12");
static_assert(sizeof(ghmGcCollObjHitResultObj::mRate) == 4, "expected mRate to be size 4");
static_assert(sizeof(ghmGcCollObjHitResultObj::mAttr) == 4, "expected mAttr to be size 4");
static_assert(sizeof(ghmGcCollObjHitResultObj::mpObj) == 4, "expected mpObj to be size 4");
static_assert(sizeof(ghmGcCollObjHitResultObj) == 76, "expected class ghmGcCollObjHitResultObj to be size 76");

// enum enCharaCondition
enum enCharaCondition : uint32_t
{
	// <eGood = 0x0>
	eGood = 0,

	// <eDamaging = 0x1>
	eDamaging = 1,

	// <eDying = 0x2>
	eDying = 2,

	// <eDead = 0x3>
	eDead = 3,

	// <eBossDead = 0x4>
	eBossDead = 4,

	// <eConditionInit = 0x5>
	eConditionInit = 5,

	// <eConditionMax = 0x6>
	eConditionMax = 6

};

// [Structure] struct stVec
struct stVec
{
public:
	/// Struct member variables

	// <class WAnimF x, offset 0x0>
	class WAnimF x;

	// <class WAnimF y, offset 0x20>
	class WAnimF y;

	// <class WAnimF z, offset 0x40>
	class WAnimF z;

	std::string ToString() const { return "struct stVec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stVec>("stVec")
			.addFunction("__tostring", &stVec::ToString)
			.addFunction("GetPtrAddr", &stVec::GetPtrAddr)
			.addProperty("x", &stVec::x)
			.addProperty("y", &stVec::y)
			.addProperty("z", &stVec::z)
		.endClass();
	}
#endif
};
static_assert(sizeof(stVec::x) == 32, "expected x to be size 32");
static_assert(sizeof(stVec::y) == 32, "expected y to be size 32");
static_assert(sizeof(stVec::z) == 32, "expected z to be size 32");
static_assert(sizeof(stVec) == 96, "expected struct stVec to be size 96");

// [Structure] struct Quaternion
struct Quaternion
{
public:
	/// Struct member variables

	// <float x, offset 0x0>
	float x;

	// <float y, offset 0x4>
	float y;

	// <float z, offset 0x8>
	float z;

	// <float w, offset 0xc>
	float w;

	std::string ToString() const { return "struct Quaternion(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Quaternion>("Quaternion")
			.addFunction("__tostring", &Quaternion::ToString)
			.addFunction("GetPtrAddr", &Quaternion::GetPtrAddr)
			.addProperty("x", &Quaternion::x)
			.addProperty("y", &Quaternion::y)
			.addProperty("z", &Quaternion::z)
			.addProperty("w", &Quaternion::w)
		.endClass();
	}
#endif
};
static_assert(sizeof(Quaternion::x) == 4, "expected x to be size 4");
static_assert(sizeof(Quaternion::y) == 4, "expected y to be size 4");
static_assert(sizeof(Quaternion::z) == 4, "expected z to be size 4");
static_assert(sizeof(Quaternion::w) == 4, "expected w to be size 4");
static_assert(sizeof(Quaternion) == 16, "expected struct Quaternion to be size 16");

// [Structure] struct stCharaStatus
/// <summary>
/// Contains position, rotation, hp, flags, etc
/// </summary>
struct stCharaStatus
{
public:
	/// Struct member variables

	// <int32_t resNo, offset 0x0>
	int32_t resNo;

	// <int32_t datNo, offset 0x4>
	int32_t datNo;

	// <enum enCharaType charaType, offset 0x8>
	enum enCharaType charaType;

	// <int16_t zakoWepType, offset 0xc>
	int16_t zakoWepType;

	// <Unidentified data segment, offset 0xe>
private:
	char _UnidentifiedData4[2];

public:
	// <float maxHp, offset 0x10>
	float maxHp;

	// <float hp, offset 0x14>
	float hp;

	// <int16_t money, offset 0x18>
	int16_t money;

	// <int16_t dropMoney, offset 0x1a>
	int16_t dropMoney;

	// <float tension, offset 0x1c>
	float tension;

	// <float hajikiCount, offset 0x20>
	float hajikiCount;

	// <uint8_t alwaysCheckHitColl, offset 0x24>
	uint8_t alwaysCheckHitColl;

	// <Unidentified data segment, offset 0x25>
private:
	char _UnidentifiedData11[3];

public:
	// <struct Vec pos, offset 0x28>
	struct Vec pos;

	// <struct Vec beforePos, offset 0x34>
	struct Vec beforePos;

	// <struct Vec oldPos, offset 0x40>
	struct Vec oldPos;

	// <struct Vec navelPos, offset 0x4c>
	struct Vec navelPos;

	// <struct Vec brainPos, offset 0x58>
	struct Vec brainPos;

	// <struct Vec rot, offset 0x64>
	struct Vec rot;

	// <struct Vec scale, offset 0x70>
	struct Vec scale;

	// <struct Quaternion qRot, offset 0x7c>
	struct Quaternion qRot;

	// <float movSpd, offset 0x8c>
	float movSpd;

	// <float hitSize, offset 0x90>
	float hitSize;

	// <float height, offset 0x94>
	float height;

	// <struct stVec aPos, offset 0x98>
	struct stVec aPos;

	// <struct stVec aRot, offset 0xf8>
	struct stVec aRot;

	// <int32_t enterPattern, offset 0x158>
	int32_t enterPattern;

	// <float reactionDist, offset 0x15c>
	float reactionDist;

	// <int32_t itemNo, offset 0x160>
	int32_t itemNo;

	// <int32_t mAiDefBasic, offset 0x164>
	int32_t mAiDefBasic;

	// <int32_t mAiDefCurrent, offset 0x168>
	int32_t mAiDefCurrent;

	// <int32_t mAiDefTick, offset 0x16c>
	int32_t mAiDefTick;

	// <int32_t mAiDefBaseTick, offset 0x170>
	int32_t mAiDefBaseTick;

	// <float mAiDamageCount, offset 0x174>
	float mAiDamageCount;

	// <char* pScriptProc, offset 0x178>
	char* pScriptProc;

	// <int32_t tsubazeriNum, offset 0x17c>
	int32_t tsubazeriNum;

	// <int32_t DamageAcceptFrame, offset 0x180>
	int32_t DamageAcceptFrame;

	// <int32_t motionNo, offset 0x184>
	int32_t motionNo;

	// <char motionBrendNum, offset 0x188>
	char motionBrendNum;

	// <Unidentified data segment, offset 0x189>
private:
	char _UnidentifiedData37[3];

public:
	// <float motSpd, offset 0x18c>
	float motSpd;

	// <float subMotSpd, offset 0x190>
	float subMotSpd;

	// <enum enCharaCondition condition, offset 0x194>
	enum enCharaCondition condition;

	// <class ghmGcCollObj* footHitResultObj, offset 0x198>
	class ghmGcCollObj* footHitResultObj;

	// <class ghmGcCollObjHitResult* footHitResult, offset 0x19c>
	class ghmGcCollObjHitResult* footHitResult;

	// <class ghmGcCollObjHitResultObj footHitResultObj2, offset 0x1a0>
	class ghmGcCollObjHitResultObj footHitResultObj2;

	// <class ghmGcCollObjHitResultObj HitWallObj, offset 0x1ec>
	class ghmGcCollObjHitResultObj HitWallObj;

	// <struct WGclMaterialSpec* hitWallMaterial, offset 0x238>
	struct WGclMaterialSpec* hitWallMaterial;

	// <struct Vec HitWallNormal, offset 0x23c>
	struct Vec HitWallNormal;

	// <struct stDamageInfo dmgInfo, offset 0x248>
	struct stDamageInfo dmgInfo;

	// <struct Vec mYukaNormal, offset 0x2b4>
	struct Vec mYukaNormal;

	// <int32_t mFootNumber, offset 0x2c0>
	int32_t mFootNumber;

	// <int32_t movTick, offset 0x2c4>
	int32_t movTick;

	// <int16_t hitNum, offset 0x2c8>
	int16_t hitNum;

	// <Unidentified data segment, offset 0x2ca>
private:
	char _UnidentifiedData51[2];

public:
	// <class ghmGcCollObjCapsule hitColl, offset 0x2cc>
	class ghmGcCollObjCapsule hitColl;

	// <int32_t mAiAtkLv, offset 0x32c>
	int32_t mAiAtkLv;

	// <int32_t mAiAtkClass, offset 0x330>
	int32_t mAiAtkClass;

	// <int16_t AtkAi[0xa], offset 0x334>
	int16_t AtkAi[10];

	// <int32_t renderSkipCounter, offset 0x348>
	int32_t renderSkipCounter;

	// <float renderSkipMotSpd, offset 0x34c>
	float renderSkipMotSpd;

	// <int32_t frameStop, offset 0x350>
	int32_t frameStop;

	// <float lockOnDistance, offset 0x354>
	float lockOnDistance;

	// <float lockOnDistanceHi, offset 0x358>
	float lockOnDistanceHi;

	// <float lockOnDistanceLow, offset 0x35c>
	float lockOnDistanceLow;

	// <float DrawYAdjust, offset 0x360>
	float DrawYAdjust;

	// <uint8_t bBloom, offset 0x364>
	uint8_t bBloom;

	// <uint8_t JumpBlockHit, offset 0x365>
	uint8_t JumpBlockHit;

	// <Unidentified data segment, offset 0x366>
private:
	char _UnidentifiedData64[2];

public:
	// <float AtkDisAdjust, offset 0x368>
	float AtkDisAdjust;

	// <float TubaFrmOffset, offset 0x36c>
	float TubaFrmOffset;

	// <int32_t motionNoNpc, offset 0x370>
	int32_t motionNoNpc;

	// <class WAnimF semiTransRate, offset 0x374>
	class WAnimF semiTransRate;

	// <uint32_t flag[0x2], offset 0x394>
	uint32_t flag[2];

	std::string ToString() const { return "struct stCharaStatus(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaStatus>("stCharaStatus")
			.addFunction("__tostring", &stCharaStatus::ToString)
			.addFunction("GetPtrAddr", &stCharaStatus::GetPtrAddr)
			.addProperty("resNo", &stCharaStatus::resNo)
			.addProperty("datNo", &stCharaStatus::datNo)
			.addProperty("charaType", &stCharaStatus::charaType)
			.addProperty("zakoWepType", &stCharaStatus::zakoWepType)
			.addProperty("maxHp", &stCharaStatus::maxHp)
			.addProperty("hp", &stCharaStatus::hp)
			.addProperty("money", &stCharaStatus::money)
			.addProperty("dropMoney", &stCharaStatus::dropMoney)
			.addProperty("tension", &stCharaStatus::tension)
			.addProperty("hajikiCount", &stCharaStatus::hajikiCount)
			.addProperty("alwaysCheckHitColl", &stCharaStatus::alwaysCheckHitColl)
			.addProperty("pos", &stCharaStatus::pos)
			.addProperty("beforePos", &stCharaStatus::beforePos)
			.addProperty("oldPos", &stCharaStatus::oldPos)
			.addProperty("navelPos", &stCharaStatus::navelPos)
			.addProperty("brainPos", &stCharaStatus::brainPos)
			.addProperty("rot", &stCharaStatus::rot)
			.addProperty("scale", &stCharaStatus::scale)
			.addProperty("qRot", &stCharaStatus::qRot)
			.addProperty("movSpd", &stCharaStatus::movSpd)
			.addProperty("hitSize", &stCharaStatus::hitSize)
			.addProperty("height", &stCharaStatus::height)
			.addProperty("aPos", &stCharaStatus::aPos)
			.addProperty("aRot", &stCharaStatus::aRot)
			.addProperty("enterPattern", &stCharaStatus::enterPattern)
			.addProperty("reactionDist", &stCharaStatus::reactionDist)
			.addProperty("itemNo", &stCharaStatus::itemNo)
			.addProperty("mAiDefBasic", &stCharaStatus::mAiDefBasic)
			.addProperty("mAiDefCurrent", &stCharaStatus::mAiDefCurrent)
			.addProperty("mAiDefTick", &stCharaStatus::mAiDefTick)
			.addProperty("mAiDefBaseTick", &stCharaStatus::mAiDefBaseTick)
			.addProperty("mAiDamageCount", &stCharaStatus::mAiDamageCount)
			// char* type not supported in LuaBridge
			//.addProperty("pScriptProc", &stCharaStatus::pScriptProc)
			.addProperty("tsubazeriNum", &stCharaStatus::tsubazeriNum)
			.addProperty("DamageAcceptFrame", &stCharaStatus::DamageAcceptFrame)
			.addProperty("motionNo", &stCharaStatus::motionNo)
			.addProperty("motionBrendNum", &stCharaStatus::motionBrendNum)
			.addProperty("motSpd", &stCharaStatus::motSpd)
			.addProperty("subMotSpd", &stCharaStatus::subMotSpd)
			.addProperty("condition", &stCharaStatus::condition)
			.addProperty("footHitResultObj", &stCharaStatus::footHitResultObj)
			.addProperty("footHitResult", &stCharaStatus::footHitResult)
			.addProperty("footHitResultObj2", &stCharaStatus::footHitResultObj2)
			.addProperty("HitWallObj", &stCharaStatus::HitWallObj)
			.addProperty("hitWallMaterial", &stCharaStatus::hitWallMaterial)
			.addProperty("HitWallNormal", &stCharaStatus::HitWallNormal)
			.addProperty("dmgInfo", &stCharaStatus::dmgInfo)
			.addProperty("mYukaNormal", &stCharaStatus::mYukaNormal)
			.addProperty("mFootNumber", &stCharaStatus::mFootNumber)
			.addProperty("movTick", &stCharaStatus::movTick)
			.addProperty("hitNum", &stCharaStatus::hitNum)
			.addProperty("hitColl", &stCharaStatus::hitColl)
			.addProperty("mAiAtkLv", &stCharaStatus::mAiAtkLv)
			.addProperty("mAiAtkClass", &stCharaStatus::mAiAtkClass)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("AtkAi", &stCharaStatus::AtkAi)
			.addProperty("renderSkipCounter", &stCharaStatus::renderSkipCounter)
			.addProperty("renderSkipMotSpd", &stCharaStatus::renderSkipMotSpd)
			.addProperty("frameStop", &stCharaStatus::frameStop)
			.addProperty("lockOnDistance", &stCharaStatus::lockOnDistance)
			.addProperty("lockOnDistanceHi", &stCharaStatus::lockOnDistanceHi)
			.addProperty("lockOnDistanceLow", &stCharaStatus::lockOnDistanceLow)
			.addProperty("DrawYAdjust", &stCharaStatus::DrawYAdjust)
			.addProperty("bBloom", &stCharaStatus::bBloom)
			.addProperty("JumpBlockHit", &stCharaStatus::JumpBlockHit)
			.addProperty("AtkDisAdjust", &stCharaStatus::AtkDisAdjust)
			.addProperty("TubaFrmOffset", &stCharaStatus::TubaFrmOffset)
			.addProperty("motionNoNpc", &stCharaStatus::motionNoNpc)
			.addProperty("semiTransRate", &stCharaStatus::semiTransRate)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("flag", &stCharaStatus::flag)
		.endClass();
	}
#endif
};
static_assert(sizeof(stCharaStatus::resNo) == 4, "expected resNo to be size 4");
static_assert(sizeof(stCharaStatus::datNo) == 4, "expected datNo to be size 4");
static_assert(sizeof(stCharaStatus::charaType) == 4, "expected charaType to be size 4");
static_assert(sizeof(stCharaStatus::zakoWepType) == 2, "expected zakoWepType to be size 2");
static_assert(sizeof(stCharaStatus::maxHp) == 4, "expected maxHp to be size 4");
static_assert(sizeof(stCharaStatus::hp) == 4, "expected hp to be size 4");
static_assert(sizeof(stCharaStatus::money) == 2, "expected money to be size 2");
static_assert(sizeof(stCharaStatus::dropMoney) == 2, "expected dropMoney to be size 2");
static_assert(sizeof(stCharaStatus::tension) == 4, "expected tension to be size 4");
static_assert(sizeof(stCharaStatus::hajikiCount) == 4, "expected hajikiCount to be size 4");
static_assert(sizeof(stCharaStatus::alwaysCheckHitColl) == 1, "expected alwaysCheckHitColl to be size 1");
static_assert(sizeof(stCharaStatus::pos) == 12, "expected pos to be size 12");
static_assert(sizeof(stCharaStatus::beforePos) == 12, "expected beforePos to be size 12");
static_assert(sizeof(stCharaStatus::oldPos) == 12, "expected oldPos to be size 12");
static_assert(sizeof(stCharaStatus::navelPos) == 12, "expected navelPos to be size 12");
static_assert(sizeof(stCharaStatus::brainPos) == 12, "expected brainPos to be size 12");
static_assert(sizeof(stCharaStatus::rot) == 12, "expected rot to be size 12");
static_assert(sizeof(stCharaStatus::scale) == 12, "expected scale to be size 12");
static_assert(sizeof(stCharaStatus::qRot) == 16, "expected qRot to be size 16");
static_assert(sizeof(stCharaStatus::movSpd) == 4, "expected movSpd to be size 4");
static_assert(sizeof(stCharaStatus::hitSize) == 4, "expected hitSize to be size 4");
static_assert(sizeof(stCharaStatus::height) == 4, "expected height to be size 4");
static_assert(sizeof(stCharaStatus::aPos) == 96, "expected aPos to be size 96");
static_assert(sizeof(stCharaStatus::aRot) == 96, "expected aRot to be size 96");
static_assert(sizeof(stCharaStatus::enterPattern) == 4, "expected enterPattern to be size 4");
static_assert(sizeof(stCharaStatus::reactionDist) == 4, "expected reactionDist to be size 4");
static_assert(sizeof(stCharaStatus::itemNo) == 4, "expected itemNo to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefBasic) == 4, "expected mAiDefBasic to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefCurrent) == 4, "expected mAiDefCurrent to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefTick) == 4, "expected mAiDefTick to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefBaseTick) == 4, "expected mAiDefBaseTick to be size 4");
static_assert(sizeof(stCharaStatus::mAiDamageCount) == 4, "expected mAiDamageCount to be size 4");
static_assert(sizeof(stCharaStatus::pScriptProc) == 4, "expected pScriptProc to be size 4");
static_assert(sizeof(stCharaStatus::tsubazeriNum) == 4, "expected tsubazeriNum to be size 4");
static_assert(sizeof(stCharaStatus::DamageAcceptFrame) == 4, "expected DamageAcceptFrame to be size 4");
static_assert(sizeof(stCharaStatus::motionNo) == 4, "expected motionNo to be size 4");
static_assert(sizeof(stCharaStatus::motionBrendNum) == 1, "expected motionBrendNum to be size 1");
static_assert(sizeof(stCharaStatus::motSpd) == 4, "expected motSpd to be size 4");
static_assert(sizeof(stCharaStatus::subMotSpd) == 4, "expected subMotSpd to be size 4");
static_assert(sizeof(stCharaStatus::condition) == 4, "expected condition to be size 4");
static_assert(sizeof(stCharaStatus::footHitResultObj) == 4, "expected footHitResultObj to be size 4");
static_assert(sizeof(stCharaStatus::footHitResult) == 4, "expected footHitResult to be size 4");
static_assert(sizeof(stCharaStatus::footHitResultObj2) == 76, "expected footHitResultObj2 to be size 76");
static_assert(sizeof(stCharaStatus::HitWallObj) == 76, "expected HitWallObj to be size 76");
static_assert(sizeof(stCharaStatus::hitWallMaterial) == 4, "expected hitWallMaterial to be size 4");
static_assert(sizeof(stCharaStatus::HitWallNormal) == 12, "expected HitWallNormal to be size 12");
static_assert(sizeof(stCharaStatus::dmgInfo) == 108, "expected dmgInfo to be size 108");
static_assert(sizeof(stCharaStatus::mYukaNormal) == 12, "expected mYukaNormal to be size 12");
static_assert(sizeof(stCharaStatus::mFootNumber) == 4, "expected mFootNumber to be size 4");
static_assert(sizeof(stCharaStatus::movTick) == 4, "expected movTick to be size 4");
static_assert(sizeof(stCharaStatus::hitNum) == 2, "expected hitNum to be size 2");
static_assert(sizeof(stCharaStatus::hitColl) == 96, "expected hitColl to be size 96");
static_assert(sizeof(stCharaStatus::mAiAtkLv) == 4, "expected mAiAtkLv to be size 4");
static_assert(sizeof(stCharaStatus::mAiAtkClass) == 4, "expected mAiAtkClass to be size 4");
static_assert(sizeof(stCharaStatus::AtkAi) == 20, "expected AtkAi to be size 20");
static_assert(sizeof(stCharaStatus::renderSkipCounter) == 4, "expected renderSkipCounter to be size 4");
static_assert(sizeof(stCharaStatus::renderSkipMotSpd) == 4, "expected renderSkipMotSpd to be size 4");
static_assert(sizeof(stCharaStatus::frameStop) == 4, "expected frameStop to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistance) == 4, "expected lockOnDistance to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistanceHi) == 4, "expected lockOnDistanceHi to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistanceLow) == 4, "expected lockOnDistanceLow to be size 4");
static_assert(sizeof(stCharaStatus::DrawYAdjust) == 4, "expected DrawYAdjust to be size 4");
static_assert(sizeof(stCharaStatus::bBloom) == 1, "expected bBloom to be size 1");
static_assert(sizeof(stCharaStatus::JumpBlockHit) == 1, "expected JumpBlockHit to be size 1");
static_assert(sizeof(stCharaStatus::AtkDisAdjust) == 4, "expected AtkDisAdjust to be size 4");
static_assert(sizeof(stCharaStatus::TubaFrmOffset) == 4, "expected TubaFrmOffset to be size 4");
static_assert(sizeof(stCharaStatus::motionNoNpc) == 4, "expected motionNoNpc to be size 4");
static_assert(sizeof(stCharaStatus::semiTransRate) == 32, "expected semiTransRate to be size 32");
static_assert(sizeof(stCharaStatus::flag) == 8, "expected flag to be size 8");
static_assert(sizeof(stCharaStatus) == 924, "expected struct stCharaStatus to be size 924");

// [Structure] class ghmListObj
/// <summary>
/// Linked list object (mpPrev and mpNext).
/// </summary>
class ghmListObj
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x6], offset 0x0>
	void* (* field_0)[0x6];

	// <ghmListObj* mpPrev, offset 0x4>
	ghmListObj* mpPrev;

	// <ghmListObj* mpNext, offset 0x8>
	ghmListObj* mpNext;

	// <int32_t mPriority, offset 0xc>
	int32_t mPriority;

	mHRChara* AsHRChara() const { return (mHRChara*)this; }
	std::string ToString() const { return "class ghmListObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmListObj>("ghmListObj")
			.addFunction("__tostring", &ghmListObj::ToString)
			.addFunction("GetPtrAddr", &ghmListObj::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmListObj::field_0)
			.addProperty("mpPrev", &ghmListObj::mpPrev)
			.addProperty("mpNext", &ghmListObj::mpNext)
			.addProperty("mPriority", &ghmListObj::mPriority)
			.addFunction("AsHRChara", &ghmListObj::AsHRChara)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmListObj::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmListObj::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(ghmListObj::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(ghmListObj::mPriority) == 4, "expected mPriority to be size 4");
static_assert(sizeof(ghmListObj) == 16, "expected class ghmListObj to be size 16");

// enum eUDLR
enum eUDLR : uint32_t
{
	// <eUp = 0x0>
	eUp = 0,

	// <eDown = 0x1>
	eDown = 1,

	// <eLeft = 0x2>
	eLeft = 2,

	// <eRight = 0x3>
	eRight = 3,

	// <eUDLRMax = 0x4>
	eUDLRMax = 4

};

// enum enWepLeftRight
enum enWepLeftRight : uint32_t
{
	// <eWepLeft = 0x0>
	eWepLeft = 0,

	// <eWepRight = 0x1>
	eWepRight = 1,

	// <eWepLeftRightMax = 0x2>
	eWepLeftRightMax = 2

};

// enum eDmgCallBackDmgType
enum eDmgCallBackDmgType : uint32_t
{
	// <eDmgCallBackDmgType_Cut = 0x0>
	eDmgCallBackDmgType_Cut = 0,

	// <eDmgCallBackDmgType_Through = 0x1>
	eDmgCallBackDmgType_Through = 1

};

// [Structure] struct CharControlMotID
struct CharControlMotID
{
public:
	/// Struct member variables

	// <int32_t WalkNeutral, offset 0x0>
	int32_t WalkNeutral;

	// <int32_t WalkFront, offset 0x4>
	int32_t WalkFront;

	// <int32_t WalkBack, offset 0x8>
	int32_t WalkBack;

	// <int32_t WalkSideLeft, offset 0xc>
	int32_t WalkSideLeft;

	// <int32_t WalkSideRight, offset 0x10>
	int32_t WalkSideRight;

	// <int32_t Run, offset 0x14>
	int32_t Run;

	// <int32_t EvacuateBack, offset 0x18>
	int32_t EvacuateBack;

	// <int32_t EvacuateLeft, offset 0x1c>
	int32_t EvacuateLeft;

	// <int32_t EvacuateRight, offset 0x20>
	int32_t EvacuateRight;

	std::string ToString() const { return "struct CharControlMotID(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CharControlMotID>("CharControlMotID")
			.addFunction("__tostring", &CharControlMotID::ToString)
			.addFunction("GetPtrAddr", &CharControlMotID::GetPtrAddr)
			.addProperty("WalkNeutral", &CharControlMotID::WalkNeutral)
			.addProperty("WalkFront", &CharControlMotID::WalkFront)
			.addProperty("WalkBack", &CharControlMotID::WalkBack)
			.addProperty("WalkSideLeft", &CharControlMotID::WalkSideLeft)
			.addProperty("WalkSideRight", &CharControlMotID::WalkSideRight)
			.addProperty("Run", &CharControlMotID::Run)
			.addProperty("EvacuateBack", &CharControlMotID::EvacuateBack)
			.addProperty("EvacuateLeft", &CharControlMotID::EvacuateLeft)
			.addProperty("EvacuateRight", &CharControlMotID::EvacuateRight)
		.endClass();
	}
#endif
};
static_assert(sizeof(CharControlMotID::WalkNeutral) == 4, "expected WalkNeutral to be size 4");
static_assert(sizeof(CharControlMotID::WalkFront) == 4, "expected WalkFront to be size 4");
static_assert(sizeof(CharControlMotID::WalkBack) == 4, "expected WalkBack to be size 4");
static_assert(sizeof(CharControlMotID::WalkSideLeft) == 4, "expected WalkSideLeft to be size 4");
static_assert(sizeof(CharControlMotID::WalkSideRight) == 4, "expected WalkSideRight to be size 4");
static_assert(sizeof(CharControlMotID::Run) == 4, "expected Run to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateBack) == 4, "expected EvacuateBack to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateLeft) == 4, "expected EvacuateLeft to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateRight) == 4, "expected EvacuateRight to be size 4");
static_assert(sizeof(CharControlMotID) == 36, "expected struct CharControlMotID to be size 36");

// [Structure] struct GXColor
struct GXColor
{
public:
	/// Struct member variables

	// <uint32_t PackedValue, offset 0x0>
	uint32_t PackedValue;

	std::string ToString() const { return "struct GXColor(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXColor>("GXColor")
			.addFunction("__tostring", &GXColor::ToString)
			.addFunction("GetPtrAddr", &GXColor::GetPtrAddr)
			.addProperty("PackedValue", &GXColor::PackedValue)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXColor::PackedValue) == 4, "expected PackedValue to be size 4");
static_assert(sizeof(GXColor) == 4, "expected struct GXColor to be size 4");

// [Structure] union __m128
union __m128
{
public:
	/// Struct member variables

	// <float m128_f32[0x4], offset 0x0>
	float m128_f32[4];

	std::string ToString() const { return "union __m128(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<__m128>("__m128")
			.addFunction("__tostring", &__m128::ToString)
			.addFunction("GetPtrAddr", &__m128::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m128_f32", &__m128::m128_f32)
		.endClass();
	}
#endif
};
static_assert(sizeof(__m128::m128_f32) == 16, "expected m128_f32 to be size 16");
static_assert(sizeof(__m128) == 16, "expected union __m128 to be size 16");

// [Structure] class vector4f
class vector4f
{
public:
	/// Struct member variables

	// <uint32_t u[0x4], offset 0x0>
	uint32_t u[4];

	std::string ToString() const { return "class vector4f(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<vector4f>("vector4f")
			.addFunction("__tostring", &vector4f::ToString)
			.addFunction("GetPtrAddr", &vector4f::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("u", &vector4f::u)
		.endClass();
	}
#endif
};
static_assert(sizeof(vector4f::u) == 16, "expected u to be size 16");
static_assert(sizeof(vector4f) == 16, "expected class vector4f to be size 16");

// [Structure] class vector4x
class vector4x
{
public:
	/// Struct member variables

	// <double sd[0x2], offset 0x0>
	double sd[2];

	std::string ToString() const { return "class vector4x(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<vector4x>("vector4x")
			.addFunction("__tostring", &vector4x::ToString)
			.addFunction("GetPtrAddr", &vector4x::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("sd", &vector4x::sd)
		.endClass();
	}
#endif
};
static_assert(sizeof(vector4x::sd) == 16, "expected sd to be size 16");
static_assert(sizeof(vector4x) == 16, "expected class vector4x to be size 16");

// [Structure] class tiVector
class tiVector
{
public:
	/// Struct member variables

	// <float x, offset 0x0>
	float x;

	// <float y, offset 0x4>
	float y;

	// <float z, offset 0x8>
	float z;

	// <float w, offset 0xc>
	float w;

	std::string ToString() const { return "class tiVector(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tiVector>("tiVector")
			.addFunction("__tostring", &tiVector::ToString)
			.addFunction("GetPtrAddr", &tiVector::GetPtrAddr)
			.addProperty("x", &tiVector::x)
			.addProperty("y", &tiVector::y)
			.addProperty("z", &tiVector::z)
			.addProperty("w", &tiVector::w)
		.endClass();
	}
#endif
};
static_assert(sizeof(tiVector::x) == 4, "expected x to be size 4");
static_assert(sizeof(tiVector::y) == 4, "expected y to be size 4");
static_assert(sizeof(tiVector::z) == 4, "expected z to be size 4");
static_assert(sizeof(tiVector::w) == 4, "expected w to be size 4");
static_assert(sizeof(tiVector) == 16, "expected class tiVector to be size 16");

// [Structure] class mot::IBoneEffectModel
namespace mot
{
	class IBoneEffectModel
	{
	public:
		/// Struct member variables

		// <void* (* field_0)[0x1f], offset 0x0>
		void* (* field_0)[0x1f];

		std::string ToString() const { return "class IBoneEffectModel(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::IBoneEffectModel>("mot_IBoneEffectModel")
				.addFunction("__tostring", &mot::IBoneEffectModel::ToString)
				.addFunction("GetPtrAddr", &mot::IBoneEffectModel::GetPtrAddr)
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &mot::IBoneEffectModel::field_0)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectModel::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(mot::IBoneEffectModel) == 4, "expected class mot::IBoneEffectModel to be size 4");

// [Structure] class mot::IBoneEffectModelPJ
namespace mot
{
	class IBoneEffectModelPJ : public mot::IBoneEffectModel
	{
	public:
		/// Struct member variables

		// <class mot::IBoneEffectModel field_0, offset 0x0>
		// class IBoneEffectModel Super;

		// <Unidentified data segment, offset 0x4>
	private:
		char _UnidentifiedData1[12];

	public:
		// <class tiVector m_inYureBonePosiOfst, offset 0x10>
		class tiVector m_inYureBonePosiOfst;

		std::string ToString() const { return "class IBoneEffectModelPJ(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.deriveClass<mot::IBoneEffectModelPJ, mot::IBoneEffectModel>("mot_IBoneEffectModelPJ")
				.addFunction("__tostring", &mot::IBoneEffectModelPJ::ToString)
				.addFunction("GetPtrAddr", &mot::IBoneEffectModelPJ::GetPtrAddr)
				.addProperty("m_inYureBonePosiOfst", &mot::IBoneEffectModelPJ::m_inYureBonePosiOfst)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectModelPJ::m_inYureBonePosiOfst) == 16, "expected m_inYureBonePosiOfst to be size 16");
static_assert(sizeof(mot::IBoneEffectModelPJ) == 32, "expected class mot::IBoneEffectModelPJ to be size 32");

// [Structure] class TGmf
class TGmf : public mot::IBoneEffectModelPJ
{
public:
	// [Structure] struct TGmf::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData[2284];
	public:

		std::string ToString() const { return "struct tagMAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGmf::tagMAIN>("TGmf_tagMAIN")
				.addFunction("__tostring", &TGmf::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TGmf::tagMAIN::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGmf::tagMAIN) == 2284, "expected struct TGmf::tagMAIN to be size 2284");

	/// Struct member variables

	// <class mot::IBoneEffectModelPJ field_0, offset 0x0>
	// class mot::IBoneEffectModelPJ Super;

	// <struct TGmf::tagMAIN dat, offset 0x20>
	struct TGmf::tagMAIN dat;

	// <uint8_t mUseLight, offset 0x90c>
	uint8_t mUseLight;

	// <Unidentified data segment, offset 0x90d>
private:
	char _UnidentifiedData3[3];

public:
	// <class TGanPlay* mpFrameInfoPlay, offset 0x910>
	class TGanPlay* mpFrameInfoPlay;

	// <class TGanPlayNode* mpFrameInfoNode, offset 0x914>
	class TGanPlayNode* mpFrameInfoNode;

	// <class TGanPlay* mpEffectInfoPlay, offset 0x918>
	class TGanPlay* mpEffectInfoPlay;

	// <class TGanPlayNode* mpSmokeParam1Node, offset 0x91c>
	class TGanPlayNode* mpSmokeParam1Node;

	// <class TGanPlayNode* mpSmokeParam2Node, offset 0x920>
	class TGanPlayNode* mpSmokeParam2Node;

	// <int32_t mHitFrameNum, offset 0x924>
	int32_t mHitFrameNum;

	// <int32_t mDmgMotNum, offset 0x928>
	int32_t mDmgMotNum;

	// <int32_t mGrdMotNum, offset 0x92c>
	int32_t mGrdMotNum;

	// <int32_t mNextGrdMotNum, offset 0x930>
	int32_t mNextGrdMotNum;

	// <int32_t mAtkDirec, offset 0x934>
	int32_t mAtkDirec;

	// <int32_t mEffectNum, offset 0x938>
	int32_t mEffectNum;

	// <float mIKBlendRate, offset 0x93c>
	float mIKBlendRate;

	// <float mSlowRate, offset 0x940>
	float mSlowRate;

	// <uint8_t mbDrawMirror, offset 0x944>
	uint8_t mbDrawMirror;

	// <uint8_t mbObj, offset 0x945>
	uint8_t mbObj;

	// <Unidentified data segment, offset 0x946>
private:
	char _UnidentifiedData18[2];

public:
	// <float m_fFadeAlpha, offset 0x948>
	float m_fFadeAlpha;

	// <class TGmfNode* m_pLocatorNode, offset 0x94c>
	class TGmfNode* m_pLocatorNode;

	// <int32_t m_nTotalModel, offset 0x950>
	int32_t m_nTotalModel;

	// <int32_t m_nCurModelIndex, offset 0x954>
	int32_t m_nCurModelIndex;

	// <class TGmfNode* m_pCurModelTopNode, offset 0x958>
	class TGmfNode* m_pCurModelTopNode;

	// <class TGmfNode* m_pBoneEffectTopNode, offset 0x95c>
	class TGmfNode* m_pBoneEffectTopNode;

	// <uint32_t m_bActedSetupRefMesh, offset 0x960>
	uint32_t m_bActedSetupRefMesh;

	// <uint32_t m_bActedRefreshRefMesh, offset 0x964>
	uint32_t m_bActedRefreshRefMesh;

	// <class mot::IBoneEffectPJ* m_pBoneEffect, offset 0x968>
	class mot::IBoneEffectPJ* m_pBoneEffect;

	// <uint8_t m_bActedBoneEffectInit, offset 0x96c>
	uint8_t m_bActedBoneEffectInit;

	// <uint8_t m_bActBoneEffectOnUpdate, offset 0x96d>
	uint8_t m_bActBoneEffectOnUpdate;

	// <Unidentified data segment, offset 0x96e>
private:
	char _UnidentifiedData29[2];

public:
	// <char const* m_sIDName, offset 0x970>
	char const* m_sIDName;

	// <int32_t m_nIDNum, offset 0x974>
	int32_t m_nIDNum;

	// <char const* m_sMotName, offset 0x978>
	char const* m_sMotName;

	// <int32_t m_nTotalCamVibTiming, offset 0x97c>
	int32_t m_nTotalCamVibTiming;

	// <class CCameraVibTiming* m_ainCamVibTiming, offset 0x980>
	class CCameraVibTiming* m_ainCamVibTiming;

	// <uint8_t m_bIsBootCamVib, offset 0x984>
	uint8_t m_bIsBootCamVib;

	// <Unidentified data segment, offset 0x985>
private:
	char _UnidentifiedData[11];
public:

	std::string ToString() const { return "class TGmf(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<TGmf, mot::IBoneEffectModelPJ>("TGmf")
			.addFunction("__tostring", &TGmf::ToString)
			.addFunction("GetPtrAddr", &TGmf::GetPtrAddr)
			.addProperty("dat", &TGmf::dat)
			.addProperty("mUseLight", &TGmf::mUseLight)
			.addProperty("mpFrameInfoPlay", &TGmf::mpFrameInfoPlay)
			.addProperty("mpFrameInfoNode", &TGmf::mpFrameInfoNode)
			.addProperty("mpEffectInfoPlay", &TGmf::mpEffectInfoPlay)
			.addProperty("mpSmokeParam1Node", &TGmf::mpSmokeParam1Node)
			.addProperty("mpSmokeParam2Node", &TGmf::mpSmokeParam2Node)
			.addProperty("mHitFrameNum", &TGmf::mHitFrameNum)
			.addProperty("mDmgMotNum", &TGmf::mDmgMotNum)
			.addProperty("mGrdMotNum", &TGmf::mGrdMotNum)
			.addProperty("mNextGrdMotNum", &TGmf::mNextGrdMotNum)
			.addProperty("mAtkDirec", &TGmf::mAtkDirec)
			.addProperty("mEffectNum", &TGmf::mEffectNum)
			.addProperty("mIKBlendRate", &TGmf::mIKBlendRate)
			.addProperty("mSlowRate", &TGmf::mSlowRate)
			.addProperty("mbDrawMirror", &TGmf::mbDrawMirror)
			.addProperty("mbObj", &TGmf::mbObj)
			.addProperty("m_fFadeAlpha", &TGmf::m_fFadeAlpha)
			.addProperty("m_pLocatorNode", &TGmf::m_pLocatorNode)
			.addProperty("m_nTotalModel", &TGmf::m_nTotalModel)
			.addProperty("m_nCurModelIndex", &TGmf::m_nCurModelIndex)
			.addProperty("m_pCurModelTopNode", &TGmf::m_pCurModelTopNode)
			.addProperty("m_pBoneEffectTopNode", &TGmf::m_pBoneEffectTopNode)
			.addProperty("m_bActedSetupRefMesh", &TGmf::m_bActedSetupRefMesh)
			.addProperty("m_bActedRefreshRefMesh", &TGmf::m_bActedRefreshRefMesh)
			.addProperty("m_pBoneEffect", &TGmf::m_pBoneEffect)
			.addProperty("m_bActedBoneEffectInit", &TGmf::m_bActedBoneEffectInit)
			.addProperty("m_bActBoneEffectOnUpdate", &TGmf::m_bActBoneEffectOnUpdate)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sIDName", &TGmf::m_sIDName)
			.addProperty("m_nIDNum", &TGmf::m_nIDNum)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sMotName", &TGmf::m_sMotName)
			.addProperty("m_nTotalCamVibTiming", &TGmf::m_nTotalCamVibTiming)
			.addProperty("m_ainCamVibTiming", &TGmf::m_ainCamVibTiming)
			.addProperty("m_bIsBootCamVib", &TGmf::m_bIsBootCamVib)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGmf::dat) == 2284, "expected dat to be size 2284");
static_assert(sizeof(TGmf::mUseLight) == 1, "expected mUseLight to be size 1");
static_assert(sizeof(TGmf::mpFrameInfoPlay) == 4, "expected mpFrameInfoPlay to be size 4");
static_assert(sizeof(TGmf::mpFrameInfoNode) == 4, "expected mpFrameInfoNode to be size 4");
static_assert(sizeof(TGmf::mpEffectInfoPlay) == 4, "expected mpEffectInfoPlay to be size 4");
static_assert(sizeof(TGmf::mpSmokeParam1Node) == 4, "expected mpSmokeParam1Node to be size 4");
static_assert(sizeof(TGmf::mpSmokeParam2Node) == 4, "expected mpSmokeParam2Node to be size 4");
static_assert(sizeof(TGmf::mHitFrameNum) == 4, "expected mHitFrameNum to be size 4");
static_assert(sizeof(TGmf::mDmgMotNum) == 4, "expected mDmgMotNum to be size 4");
static_assert(sizeof(TGmf::mGrdMotNum) == 4, "expected mGrdMotNum to be size 4");
static_assert(sizeof(TGmf::mNextGrdMotNum) == 4, "expected mNextGrdMotNum to be size 4");
static_assert(sizeof(TGmf::mAtkDirec) == 4, "expected mAtkDirec to be size 4");
static_assert(sizeof(TGmf::mEffectNum) == 4, "expected mEffectNum to be size 4");
static_assert(sizeof(TGmf::mIKBlendRate) == 4, "expected mIKBlendRate to be size 4");
static_assert(sizeof(TGmf::mSlowRate) == 4, "expected mSlowRate to be size 4");
static_assert(sizeof(TGmf::mbDrawMirror) == 1, "expected mbDrawMirror to be size 1");
static_assert(sizeof(TGmf::mbObj) == 1, "expected mbObj to be size 1");
static_assert(sizeof(TGmf::m_fFadeAlpha) == 4, "expected m_fFadeAlpha to be size 4");
static_assert(sizeof(TGmf::m_pLocatorNode) == 4, "expected m_pLocatorNode to be size 4");
static_assert(sizeof(TGmf::m_nTotalModel) == 4, "expected m_nTotalModel to be size 4");
static_assert(sizeof(TGmf::m_nCurModelIndex) == 4, "expected m_nCurModelIndex to be size 4");
static_assert(sizeof(TGmf::m_pCurModelTopNode) == 4, "expected m_pCurModelTopNode to be size 4");
static_assert(sizeof(TGmf::m_pBoneEffectTopNode) == 4, "expected m_pBoneEffectTopNode to be size 4");
static_assert(sizeof(TGmf::m_bActedSetupRefMesh) == 4, "expected m_bActedSetupRefMesh to be size 4");
static_assert(sizeof(TGmf::m_bActedRefreshRefMesh) == 4, "expected m_bActedRefreshRefMesh to be size 4");
static_assert(sizeof(TGmf::m_pBoneEffect) == 4, "expected m_pBoneEffect to be size 4");
static_assert(sizeof(TGmf::m_bActedBoneEffectInit) == 1, "expected m_bActedBoneEffectInit to be size 1");
static_assert(sizeof(TGmf::m_bActBoneEffectOnUpdate) == 1, "expected m_bActBoneEffectOnUpdate to be size 1");
static_assert(sizeof(TGmf::m_sIDName) == 4, "expected m_sIDName to be size 4");
static_assert(sizeof(TGmf::m_nIDNum) == 4, "expected m_nIDNum to be size 4");
static_assert(sizeof(TGmf::m_sMotName) == 4, "expected m_sMotName to be size 4");
static_assert(sizeof(TGmf::m_nTotalCamVibTiming) == 4, "expected m_nTotalCamVibTiming to be size 4");
static_assert(sizeof(TGmf::m_ainCamVibTiming) == 4, "expected m_ainCamVibTiming to be size 4");
static_assert(sizeof(TGmf::m_bIsBootCamVib) == 1, "expected m_bIsBootCamVib to be size 1");
static_assert(sizeof(TGmf) == 2448, "expected class TGmf to be size 2448");

// [Structure] class NYPhase
class NYPhase
{
public:
	/// Struct member variables

	// <int32_t m_phase, offset 0x0>
	int32_t m_phase;

	// <float m_frame, offset 0x4>
	float m_frame;

	// <float m_frameMax, offset 0x8>
	float m_frameMax;

	// <uint8_t m_useNext, offset 0xc>
	uint8_t m_useNext;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData4[3];

public:
	// <int32_t m_nextPhase, offset 0x10>
	int32_t m_nextPhase;

	// <float m_nextFrame, offset 0x14>
	float m_nextFrame;

	// <float m_nextFrameMax, offset 0x18>
	float m_nextFrameMax;

	std::string ToString() const { return "class NYPhase(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NYPhase>("NYPhase")
			.addFunction("__tostring", &NYPhase::ToString)
			.addFunction("GetPtrAddr", &NYPhase::GetPtrAddr)
			.addProperty("m_phase", &NYPhase::m_phase)
			.addProperty("m_frame", &NYPhase::m_frame)
			.addProperty("m_frameMax", &NYPhase::m_frameMax)
			.addProperty("m_useNext", &NYPhase::m_useNext)
			.addProperty("m_nextPhase", &NYPhase::m_nextPhase)
			.addProperty("m_nextFrame", &NYPhase::m_nextFrame)
			.addProperty("m_nextFrameMax", &NYPhase::m_nextFrameMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYPhase::m_phase) == 4, "expected m_phase to be size 4");
static_assert(sizeof(NYPhase::m_frame) == 4, "expected m_frame to be size 4");
static_assert(sizeof(NYPhase::m_frameMax) == 4, "expected m_frameMax to be size 4");
static_assert(sizeof(NYPhase::m_useNext) == 1, "expected m_useNext to be size 1");
static_assert(sizeof(NYPhase::m_nextPhase) == 4, "expected m_nextPhase to be size 4");
static_assert(sizeof(NYPhase::m_nextFrame) == 4, "expected m_nextFrame to be size 4");
static_assert(sizeof(NYPhase::m_nextFrameMax) == 4, "expected m_nextFrameMax to be size 4");
static_assert(sizeof(NYPhase) == 28, "expected class NYPhase to be size 28");

// [Structure] class NYApproachToTargetVal
class NYApproachToTargetVal
{
public:
	// enum NYApproachToTargetVal::CHANGE_TYPE
	enum CHANGE_TYPE : uint32_t
	{
		// <CHANGE_TYPE_INCREASED = 0x0>
		CHANGE_TYPE_INCREASED = 0,

		// <CHANGE_TYPE_DECREASED = 0x1>
		CHANGE_TYPE_DECREASED = 1,

		// <CHANGE_TYPE_APPROACHED = 0x2>
		CHANGE_TYPE_APPROACHED = 2,

		// <CHANGE_TYPE_NO_CHANGED = 0x3>
		CHANGE_TYPE_NO_CHANGED = 3

	};

	/// Struct member variables

	// <float m_val, offset 0x0>
	float m_val;

	// <float m_targetVal, offset 0x4>
	float m_targetVal;

	// <enum NYApproachToTargetVal::CHANGE_TYPE m_lastChangeType, offset 0x8>
	enum NYApproachToTargetVal::CHANGE_TYPE m_lastChangeType;

	std::string ToString() const { return "class NYApproachToTargetVal(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NYApproachToTargetVal>("NYApproachToTargetVal")
			.addFunction("__tostring", &NYApproachToTargetVal::ToString)
			.addFunction("GetPtrAddr", &NYApproachToTargetVal::GetPtrAddr)
			.addProperty("m_val", &NYApproachToTargetVal::m_val)
			.addProperty("m_targetVal", &NYApproachToTargetVal::m_targetVal)
			.addProperty("m_lastChangeType", &NYApproachToTargetVal::m_lastChangeType)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYApproachToTargetVal::m_val) == 4, "expected m_val to be size 4");
static_assert(sizeof(NYApproachToTargetVal::m_targetVal) == 4, "expected m_targetVal to be size 4");
static_assert(sizeof(NYApproachToTargetVal::m_lastChangeType) == 4, "expected m_lastChangeType to be size 4");
static_assert(sizeof(NYApproachToTargetVal) == 12, "expected class NYApproachToTargetVal to be size 12");

// [Structure] class HrTask
class HrTask
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[80];
public:

	std::string ToString() const { return "class HrTask(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrTask>("HrTask")
			.addFunction("__tostring", &HrTask::ToString)
			.addFunction("GetPtrAddr", &HrTask::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrTask) == 80, "expected class HrTask to be size 80");

// enum
enum : uint32_t
{
	// <E_CON_ACT_NONE = 0xffffffffffffffff>
	E_CON_ACT_NONE = UINT32_MAX,

	// <E_CON_ACT_FURIAGE = 0x0>
	E_CON_ACT_FURIAGE = 0,

	// <E_CON_ACT_UP = 0x1>
	E_CON_ACT_UP = 1,

	// <E_CON_ACT_DOWN = 0x2>
	E_CON_ACT_DOWN = 2,

	// <E_CON_ACT_PUSH = 0x3>
	E_CON_ACT_PUSH = 3,

	// <E_CON_ACT_PULL = 0x4>
	E_CON_ACT_PULL = 4,

	// <E_CON_ACT_RBLOW = 0x5>
	E_CON_ACT_RBLOW = 5,

	// <E_CON_ACT_LBLOW = 0x6>
	E_CON_ACT_LBLOW = 6,

	// <E_CON_ACT_ROTATE = 0x7>
	E_CON_ACT_ROTATE = 7,

	// <E_COM_ACT_CROSS = 0x8>
	E_COM_ACT_CROSS = 8

};

// [Structure] class HrBattleIcon
class HrBattleIcon : public HrTask
{
public:
	// enum HrBattleIcon::E_CON_ACT_ID
	enum E_CON_ACT_ID : uint32_t
	{
		// <E_CON_ACT_NONE = 0xffffffffffffffff>
		E_CON_ACT_NONE = UINT32_MAX,

		// <E_CON_ACT_FURIAGE = 0x0>
		E_CON_ACT_FURIAGE = 0,

		// <E_CON_ACT_UP = 0x1>
		E_CON_ACT_UP = 1,

		// <E_CON_ACT_DOWN = 0x2>
		E_CON_ACT_DOWN = 2,

		// <E_CON_ACT_PUSH = 0x3>
		E_CON_ACT_PUSH = 3,

		// <E_CON_ACT_PULL = 0x4>
		E_CON_ACT_PULL = 4,

		// <E_CON_ACT_RBLOW = 0x5>
		E_CON_ACT_RBLOW = 5,

		// <E_CON_ACT_LBLOW = 0x6>
		E_CON_ACT_LBLOW = 6,

		// <E_CON_ACT_ROTATE = 0x7>
		E_CON_ACT_ROTATE = 7,

		// <E_COM_ACT_CROSS = 0x8>
		E_COM_ACT_CROSS = 8

	};

	// enum HrBattleIcon::D_BICON_STAT
	enum D_BICON_STAT : uint32_t
	{
		// <D_BICON_NONE = 0x0>
		D_BICON_NONE = 0,

		// <D_BICON_MINI = 0x1>
		D_BICON_MINI = 1,

		// <D_BICON_MINI_TO_SKULL = 0x2>
		D_BICON_MINI_TO_SKULL = 2,

		// <D_BICON_SKULL_TO_MINI = 0x3>
		D_BICON_SKULL_TO_MINI = 3,

		// <D_BICON_SKULL = 0x4>
		D_BICON_SKULL = 4,

		// <D_BICON_TODOME_DO = 0x5>
		D_BICON_TODOME_DO = 5,

		// <D_BICON_TODOME_ED = 0x6>
		D_BICON_TODOME_ED = 6,

		// <D_BICON_CONTROLLER_ACT = 0x7>
		D_BICON_CONTROLLER_ACT = 7,

		// <D_BICON_TUBAZERI = 0x8>
		D_BICON_TUBAZERI = 8

	};

	// enum HrBattleIcon::D_TODOME_DIRECT
	enum D_TODOME_DIRECT : uint32_t
	{
		// <D_TODOME_RIGHT = 0x0>
		D_TODOME_RIGHT = 0,

		// <D_TODOME_DOWN = 0x1>
		D_TODOME_DOWN = 1,

		// <D_TODOME_LEFT = 0x2>
		D_TODOME_LEFT = 2,

		// <D_TODOME_UP = 0x3>
		D_TODOME_UP = 3,

		// <D_TODOME_360 = 0x4>
		D_TODOME_360 = 4,

		// <D_TODOME_2RIGHTDOWN = 0x5>
		D_TODOME_2RIGHTDOWN = 5,

		// <D_TODOME_2LEFTDOWN = 0x6>
		D_TODOME_2LEFTDOWN = 6

	};

	// [Structure] class HrBattleIcon::CHrHpGauge
	class CHrHpGauge
	{
	public:
		// [Function] void __convention("thiscall") HrBattleIcon::CHrHpGauge::Initialize(class HrBattleIcon::CHrHpGauge* const this, class mHRChara* arg2) [?Initialize@CHrHpGauge@HrBattleIcon@@QAEXPAVmHRChara@@@Z]
		void Initialize(class mHRChara* arg2)
		{
			typedef void(__thiscall* _Func)(class HrBattleIcon::CHrHpGauge* const thisPtr, class mHRChara* arg2);
			_Func mFunc = (_Func)(GameModule + 0x4ca550);
			return mFunc(this, arg2);
		}
		/// Struct member variables

		// <class NYPhase m_Phase, offset 0x0>
		class NYPhase m_Phase;

		// <void (* m_pPhaseProc[0x7][0x2])(HrBattleIcon::CHrHpGauge* const this), offset 0x1c>
		void (* m_pPhaseProc[0x7][0x2])(HrBattleIcon::CHrHpGauge* const ThisPtr);

		// <class mHRChara* m_pTargetChara, offset 0x54>
		class mHRChara* m_pTargetChara;

		// <int16_t const mc_Height, offset 0x58>
		int16_t mc_Height;

		// <int16_t const mc_FrameEdge_Width, offset 0x5a>
		int16_t mc_FrameEdge_Width;

		// <int16_t const mc_DrawOffsetY, offset 0x5c>
		int16_t mc_DrawOffsetY;

		// <Unidentified data segment, offset 0x5e>
	private:
		char _UnidentifiedData6[2];

	public:
		// <float m_DrawWidth, offset 0x60>
		float m_DrawWidth;

		// <float m_DrawHeight, offset 0x64>
		float m_DrawHeight;

		// <float m_DrawAlpha, offset 0x68>
		float m_DrawAlpha;

		// <float m_HpRate, offset 0x6c>
		float m_HpRate;

		// <int16_t m_SlashFadeCounter, offset 0x70>
		int16_t m_SlashFadeCounter;

		// <Unidentified data segment, offset 0x72>
	private:
		char _UnidentifiedData[2];
	public:

		std::string ToString() const { return "class CHrHpGauge(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<HrBattleIcon::CHrHpGauge>("HrBattleIcon_CHrHpGauge")
				.addFunction("__tostring", &HrBattleIcon::CHrHpGauge::ToString)
				.addFunction("GetPtrAddr", &HrBattleIcon::CHrHpGauge::GetPtrAddr)
				.addProperty("m_Phase", &HrBattleIcon::CHrHpGauge::m_Phase)
				// void type not supported in LuaBridge
				//.addProperty("m_pPhaseProc", &HrBattleIcon::CHrHpGauge::m_pPhaseProc)
				.addProperty("m_pTargetChara", &HrBattleIcon::CHrHpGauge::m_pTargetChara)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_Height", &HrBattleIcon::CHrHpGauge::mc_Height)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_FrameEdge_Width", &HrBattleIcon::CHrHpGauge::mc_FrameEdge_Width)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_DrawOffsetY", &HrBattleIcon::CHrHpGauge::mc_DrawOffsetY)
				.addProperty("m_DrawWidth", &HrBattleIcon::CHrHpGauge::m_DrawWidth)
				.addProperty("m_DrawHeight", &HrBattleIcon::CHrHpGauge::m_DrawHeight)
				.addProperty("m_DrawAlpha", &HrBattleIcon::CHrHpGauge::m_DrawAlpha)
				.addProperty("m_HpRate", &HrBattleIcon::CHrHpGauge::m_HpRate)
				.addProperty("m_SlashFadeCounter", &HrBattleIcon::CHrHpGauge::m_SlashFadeCounter)
				.addFunction("Initialize", &HrBattleIcon::CHrHpGauge::Initialize)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_Phase) == 28, "expected m_Phase to be size 28");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_pPhaseProc) == 56, "expected m_pPhaseProc to be size 56");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_pTargetChara) == 4, "expected m_pTargetChara to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_Height) == 2, "expected mc_Height to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_FrameEdge_Width) == 2, "expected mc_FrameEdge_Width to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_DrawOffsetY) == 2, "expected mc_DrawOffsetY to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawWidth) == 4, "expected m_DrawWidth to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawHeight) == 4, "expected m_DrawHeight to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawAlpha) == 4, "expected m_DrawAlpha to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_HpRate) == 4, "expected m_HpRate to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_SlashFadeCounter) == 2, "expected m_SlashFadeCounter to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge) == 116, "expected class HrBattleIcon::CHrHpGauge to be size 116");

	// [Function] void __convention("thiscall") HrBattleIcon::OnCharacterTerminate(class HrBattleIcon* const this, class mHRChara* arg2) [?OnCharacterTerminate@HrBattleIcon@@QAEXPAVmHRChara@@@Z]
	void OnCharacterTerminate(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class HrBattleIcon* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x4cdbf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrBattleIcon::Initialize(class HrBattleIcon* const this, class mHRChara* arg2, uint8_t arg3) [?Initialize@HrBattleIcon@@QAEXPAVmHRChara@@_N@Z]
	void Initialize(class mHRChara* arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class HrBattleIcon* const thisPtr, class mHRChara* arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x4ce4b0);
		return mFunc(this, arg2, arg3);
	}
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class NYApproachToTargetVal m_HPVal, offset 0x50>
	class NYApproachToTargetVal m_HPVal;

	// <float m_damagedCounter, offset 0x5c>
	float m_damagedCounter;

	// <enum HrBattleIcon::D_BICON_STAT m_IconStat, offset 0x60>
	enum HrBattleIcon::D_BICON_STAT m_IconStat;

	// <enum HrBattleIcon::D_BICON_STAT m_YoyakuIcon, offset 0x64>
	enum HrBattleIcon::D_BICON_STAT m_YoyakuIcon;

	// <float m_LockOnDist, offset 0x68>
	float m_LockOnDist;

	// <float m_LockOnCircleSize, offset 0x6c>
	float m_LockOnCircleSize;

	// <float m_BIcon_Block_Size, offset 0x70>
	float m_BIcon_Block_Size;

	// <uint8_t m_blockcolor[0x3], offset 0x74>
	uint8_t m_blockcolor[3];

	// <uint8_t m_ColorType, offset 0x77>
	uint8_t m_ColorType;

	// <enum m_ConActID[0x2], offset 0x78>
	uint32_t m_ConActID[2];

	// <int16_t m_ConActCount[0x2], offset 0x80>
	int16_t m_ConActCount[2];

	// <int16_t m_Counter, offset 0x84>
	int16_t m_Counter;

	// <int16_t m_DelCounter, offset 0x86>
	int16_t m_DelCounter;

	// <uint32_t m_Rotate_AnimCnt, offset 0x88>
	uint32_t m_Rotate_AnimCnt;

	// <struct Vec m_TmpJstVec, offset 0x8c>
	struct Vec m_TmpJstVec;

	// <int16_t m_PyokoCnt, offset 0x98>
	int16_t m_PyokoCnt;

	// <int16_t m_PyokoFlag, offset 0x9a>
	int16_t m_PyokoFlag;

	// <float m_PyokoRatio, offset 0x9c>
	float m_PyokoRatio;

	// <uint8_t m_PyokoAlpha, offset 0xa0>
	uint8_t m_PyokoAlpha;

	// <uint8_t m_DrawHitCmbFlag, offset 0xa1>
	uint8_t m_DrawHitCmbFlag;

	// <Unidentified data segment, offset 0xa2>
private:
	char _UnidentifiedData21[2];

public:
	// <float m_TsubaRatio[0x24], offset 0xa4>
	float m_TsubaRatio[36];

	// <struct Vec* m_pPosition[0x2], offset 0x134>
	struct Vec* m_pPosition[2];

	// <class mHRChara* m_pTargetChara, offset 0x13c>
	class mHRChara* m_pTargetChara;

	// <int16_t m_HpBerCounter, offset 0x140>
	int16_t m_HpBerCounter;

	// <int16_t m_LineCounter, offset 0x142>
	int16_t m_LineCounter;

	// <char m_MeterCounter, offset 0x144>
	char m_MeterCounter;

	// <Unidentified data segment, offset 0x145>
private:
	char _UnidentifiedData27[3];

public:
	// <float m_Tension[0x2], offset 0x148>
	float m_Tension[2];

	// <float m_TMeterRevPos[0x2], offset 0x150>
	float m_TMeterRevPos[2];

	// <int16_t m_GetMoney[0x2], offset 0x158>
	int16_t m_GetMoney[2];

	// <int16_t m_HitNum[0x2], offset 0x15c>
	int16_t m_HitNum[2];

	// <float m_HP[0x3], offset 0x160>
	float m_HP[3];

	// <int16_t m_SlashFadeCounter, offset 0x16c>
	int16_t m_SlashFadeCounter;

	// <int16_t m_BottanCounter[0x4], offset 0x16e>
	int16_t m_BottanCounter[4];

	// <int16_t m_TergetIconCount, offset 0x176>
	int16_t m_TergetIconCount;

	// <enum HrBattleIcon::D_TODOME_DIRECT m_Direct, offset 0x178>
	enum HrBattleIcon::D_TODOME_DIRECT m_Direct;

	// <int32_t m_Angle, offset 0x17c>
	int32_t m_Angle;

	// <int32_t m_Soundid, offset 0x180>
	int32_t m_Soundid;

	// <uint16_t flag, offset 0x184>
	uint16_t flag;

	// <uint8_t m_bDemo, offset 0x186>
	uint8_t m_bDemo;

	// <Unidentified data segment, offset 0x187>
private:
	char _UnidentifiedData40[1];

public:
	// <class HrBattleIcon::CHrHpGauge m_HpGauge, offset 0x188>
	class HrBattleIcon::CHrHpGauge m_HpGauge;

	// <int32_t m_SlashSEStatus, offset 0x1fc>
	int32_t m_SlashSEStatus;

	std::string ToString() const { return "class HrBattleIcon(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrBattleIcon, HrTask>("HrBattleIcon")
			.addFunction("__tostring", &HrBattleIcon::ToString)
			.addFunction("GetPtrAddr", &HrBattleIcon::GetPtrAddr)
			.addProperty("m_HPVal", &HrBattleIcon::m_HPVal)
			.addProperty("m_damagedCounter", &HrBattleIcon::m_damagedCounter)
			.addProperty("m_IconStat", &HrBattleIcon::m_IconStat)
			.addProperty("m_YoyakuIcon", &HrBattleIcon::m_YoyakuIcon)
			.addProperty("m_LockOnDist", &HrBattleIcon::m_LockOnDist)
			.addProperty("m_LockOnCircleSize", &HrBattleIcon::m_LockOnCircleSize)
			.addProperty("m_BIcon_Block_Size", &HrBattleIcon::m_BIcon_Block_Size)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_blockcolor", &HrBattleIcon::m_blockcolor)
			.addProperty("m_ColorType", &HrBattleIcon::m_ColorType)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_ConActID", &HrBattleIcon::m_ConActID)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_ConActCount", &HrBattleIcon::m_ConActCount)
			.addProperty("m_Counter", &HrBattleIcon::m_Counter)
			.addProperty("m_DelCounter", &HrBattleIcon::m_DelCounter)
			.addProperty("m_Rotate_AnimCnt", &HrBattleIcon::m_Rotate_AnimCnt)
			.addProperty("m_TmpJstVec", &HrBattleIcon::m_TmpJstVec)
			.addProperty("m_PyokoCnt", &HrBattleIcon::m_PyokoCnt)
			.addProperty("m_PyokoFlag", &HrBattleIcon::m_PyokoFlag)
			.addProperty("m_PyokoRatio", &HrBattleIcon::m_PyokoRatio)
			.addProperty("m_PyokoAlpha", &HrBattleIcon::m_PyokoAlpha)
			.addProperty("m_DrawHitCmbFlag", &HrBattleIcon::m_DrawHitCmbFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_TsubaRatio", &HrBattleIcon::m_TsubaRatio)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pPosition", &HrBattleIcon::m_pPosition)
			.addProperty("m_pTargetChara", &HrBattleIcon::m_pTargetChara)
			.addProperty("m_HpBerCounter", &HrBattleIcon::m_HpBerCounter)
			.addProperty("m_LineCounter", &HrBattleIcon::m_LineCounter)
			.addProperty("m_MeterCounter", &HrBattleIcon::m_MeterCounter)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_Tension", &HrBattleIcon::m_Tension)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_TMeterRevPos", &HrBattleIcon::m_TMeterRevPos)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_GetMoney", &HrBattleIcon::m_GetMoney)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_HitNum", &HrBattleIcon::m_HitNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_HP", &HrBattleIcon::m_HP)
			.addProperty("m_SlashFadeCounter", &HrBattleIcon::m_SlashFadeCounter)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_BottanCounter", &HrBattleIcon::m_BottanCounter)
			.addProperty("m_TergetIconCount", &HrBattleIcon::m_TergetIconCount)
			.addProperty("m_Direct", &HrBattleIcon::m_Direct)
			.addProperty("m_Angle", &HrBattleIcon::m_Angle)
			.addProperty("m_Soundid", &HrBattleIcon::m_Soundid)
			.addProperty("flag", &HrBattleIcon::flag)
			.addProperty("m_bDemo", &HrBattleIcon::m_bDemo)
			.addProperty("m_HpGauge", &HrBattleIcon::m_HpGauge)
			.addProperty("m_SlashSEStatus", &HrBattleIcon::m_SlashSEStatus)
			.addFunction("OnCharacterTerminate", &HrBattleIcon::OnCharacterTerminate)
			.addFunction("Initialize", &HrBattleIcon::Initialize)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrBattleIcon::m_HPVal) == 12, "expected m_HPVal to be size 12");
static_assert(sizeof(HrBattleIcon::m_damagedCounter) == 4, "expected m_damagedCounter to be size 4");
static_assert(sizeof(HrBattleIcon::m_IconStat) == 4, "expected m_IconStat to be size 4");
static_assert(sizeof(HrBattleIcon::m_YoyakuIcon) == 4, "expected m_YoyakuIcon to be size 4");
static_assert(sizeof(HrBattleIcon::m_LockOnDist) == 4, "expected m_LockOnDist to be size 4");
static_assert(sizeof(HrBattleIcon::m_LockOnCircleSize) == 4, "expected m_LockOnCircleSize to be size 4");
static_assert(sizeof(HrBattleIcon::m_BIcon_Block_Size) == 4, "expected m_BIcon_Block_Size to be size 4");
static_assert(sizeof(HrBattleIcon::m_blockcolor) == 3, "expected m_blockcolor to be size 3");
static_assert(sizeof(HrBattleIcon::m_ColorType) == 1, "expected m_ColorType to be size 1");
static_assert(sizeof(HrBattleIcon::m_ConActID) == 8, "expected m_ConActID to be size 8");
static_assert(sizeof(HrBattleIcon::m_ConActCount) == 4, "expected m_ConActCount to be size 4");
static_assert(sizeof(HrBattleIcon::m_Counter) == 2, "expected m_Counter to be size 2");
static_assert(sizeof(HrBattleIcon::m_DelCounter) == 2, "expected m_DelCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_Rotate_AnimCnt) == 4, "expected m_Rotate_AnimCnt to be size 4");
static_assert(sizeof(HrBattleIcon::m_TmpJstVec) == 12, "expected m_TmpJstVec to be size 12");
static_assert(sizeof(HrBattleIcon::m_PyokoCnt) == 2, "expected m_PyokoCnt to be size 2");
static_assert(sizeof(HrBattleIcon::m_PyokoFlag) == 2, "expected m_PyokoFlag to be size 2");
static_assert(sizeof(HrBattleIcon::m_PyokoRatio) == 4, "expected m_PyokoRatio to be size 4");
static_assert(sizeof(HrBattleIcon::m_PyokoAlpha) == 1, "expected m_PyokoAlpha to be size 1");
static_assert(sizeof(HrBattleIcon::m_DrawHitCmbFlag) == 1, "expected m_DrawHitCmbFlag to be size 1");
static_assert(sizeof(HrBattleIcon::m_TsubaRatio) == 144, "expected m_TsubaRatio to be size 144");
static_assert(sizeof(HrBattleIcon::m_pPosition) == 8, "expected m_pPosition to be size 8");
static_assert(sizeof(HrBattleIcon::m_pTargetChara) == 4, "expected m_pTargetChara to be size 4");
static_assert(sizeof(HrBattleIcon::m_HpBerCounter) == 2, "expected m_HpBerCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_LineCounter) == 2, "expected m_LineCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_MeterCounter) == 1, "expected m_MeterCounter to be size 1");
static_assert(sizeof(HrBattleIcon::m_Tension) == 8, "expected m_Tension to be size 8");
static_assert(sizeof(HrBattleIcon::m_TMeterRevPos) == 8, "expected m_TMeterRevPos to be size 8");
static_assert(sizeof(HrBattleIcon::m_GetMoney) == 4, "expected m_GetMoney to be size 4");
static_assert(sizeof(HrBattleIcon::m_HitNum) == 4, "expected m_HitNum to be size 4");
static_assert(sizeof(HrBattleIcon::m_HP) == 12, "expected m_HP to be size 12");
static_assert(sizeof(HrBattleIcon::m_SlashFadeCounter) == 2, "expected m_SlashFadeCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_BottanCounter) == 8, "expected m_BottanCounter to be size 8");
static_assert(sizeof(HrBattleIcon::m_TergetIconCount) == 2, "expected m_TergetIconCount to be size 2");
static_assert(sizeof(HrBattleIcon::m_Direct) == 4, "expected m_Direct to be size 4");
static_assert(sizeof(HrBattleIcon::m_Angle) == 4, "expected m_Angle to be size 4");
static_assert(sizeof(HrBattleIcon::m_Soundid) == 4, "expected m_Soundid to be size 4");
static_assert(sizeof(HrBattleIcon::flag) == 2, "expected flag to be size 2");
static_assert(sizeof(HrBattleIcon::m_bDemo) == 1, "expected m_bDemo to be size 1");
static_assert(sizeof(HrBattleIcon::m_HpGauge) == 116, "expected m_HpGauge to be size 116");
static_assert(sizeof(HrBattleIcon::m_SlashSEStatus) == 4, "expected m_SlashSEStatus to be size 4");
static_assert(sizeof(HrBattleIcon) == 512, "expected class HrBattleIcon to be size 512");

// [Structure] class mHRChara
/// <summary>
/// Base character (Travis, enemies, etc)
/// </summary>
class mHRChara : public ghmListObj
{
public:
	// [Function] enum enCharaType __convention("thiscall") mHRChara::mGetCharaType(class mHRChara* const this) [?mGetCharaType@mHRChara@@QBE?AW4enCharaType@@XZ]
	enum enCharaType mGetCharaType()
	{
		typedef enum enCharaType(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9f060);
		return mFunc(this);
	}
	// [Function] uint8_t mHRChara::isCharacterTypeZako(enum enCharaType arg1) [?isCharacterTypeZako@mHRChara@@SA_NW4enCharaType@@@Z]
	static uint8_t isCharacterTypeZako(enum enCharaType arg1)
	{
		typedef uint8_t(__fastcall* _Func)(enum enCharaType arg1);
		_Func mFunc = (_Func)(GameModule + 0xa2c60);
		return mFunc(arg1);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestZako(class mHRChara* const this) [?mTestZako@mHRChara@@QBE_NXZ]
	uint8_t mTestZako()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2c70);
		return mFunc(this);
	}
	// [Function] uint8_t mHRChara::isCharacterTypeBoss(enum enCharaType arg1) [?isCharacterTypeBoss@mHRChara@@SA_NW4enCharaType@@@Z]
	static uint8_t isCharacterTypeBoss(enum enCharaType arg1)
	{
		typedef uint8_t(__fastcall* _Func)(enum enCharaType arg1);
		_Func mFunc = (_Func)(GameModule + 0xa2c80);
		return mFunc(arg1);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestBoss(class mHRChara* const this) [?mTestBoss@mHRChara@@QBE_NXZ]
	uint8_t mTestBoss()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2c90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestEnemy(class mHRChara* const this) [?mTestEnemy@mHRChara@@QBE_NXZ]
	uint8_t mTestEnemy()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2ca0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetItemNo(class mHRChara* const this, int32_t arg2) [?mSetItemNo@mHRChara@@QAEXH@Z]
	void mSetItemNo(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2cc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetLockOnNoCheckColl(class mHRChara* const this, uint8_t arg2) [?mSetLockOnNoCheckColl@mHRChara@@QAEX_N@Z]
	void mSetLockOnNoCheckColl(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2cd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetLockOnDistanceLow(class mHRChara* const this, float arg2) [?mSetLockOnDistanceLow@mHRChara@@QAEXM@Z]
	void mSetLockOnDistanceLow(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2ce0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetLockOnDistanceHi(class mHRChara* const this, float arg2) [?mSetLockOnDistanceHi@mHRChara@@QAEXM@Z]
	void mSetLockOnDistanceHi(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2cf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetLockOnDistance(class mHRChara* const this, float arg2) [?mSetLockOnDistance@mHRChara@@QAEXM@Z]
	void mSetLockOnDistance(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2d00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCanLockOn(class mHRChara* const this, uint8_t arg2) [?mSetCanLockOn@mHRChara@@QAEX_N@Z]
	void mSetCanLockOn(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2d10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDisableDameged(class mHRChara* const this, uint8_t arg2) [?mSetDisableDameged@mHRChara@@QAEX_N@Z]
	void mSetDisableDameged(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2d30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetDisableDameged(class mHRChara* const this) [?mGetDisableDameged@mHRChara@@QAE_NXZ]
	uint8_t mGetDisableDameged()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2d50);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetMaxHp(class mHRChara* const this) [?mGetMaxHp@mHRChara@@QAEMXZ]
	float mGetMaxHp()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2d60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mUndispTgtIcn(class mHRChara* const this) [?mUndispTgtIcn@mHRChara@@QAE_NXZ]
	uint8_t mUndispTgtIcn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2d70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mDispTgtIcn(class mHRChara* const this) [?mDispTgtIcn@mHRChara@@QAE_NXZ]
	uint8_t mDispTgtIcn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2df0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetHp(class mHRChara* const this) [?mGetHp@mHRChara@@QAEMXZ]
	float mGetHp()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2e30);
		return mFunc(this);
	}
	// [Function] enum enCharaCondition __convention("thiscall") mHRChara::mGetCondition(class mHRChara* const this) [?mGetCondition@mHRChara@@QBE?AW4enCharaCondition@@XZ]
	enum enCharaCondition mGetCondition()
	{
		typedef enum enCharaCondition(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2fd0);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRChara::mGetNext(class mHRChara* const this) [?mGetNext@mHRChara@@QAEPAV1@XZ]
	class mHRChara* mGetNext()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa2fe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetHp(class mHRChara* const this, float arg2) [?mSetHp@mHRChara@@QAEXM@Z]
	void mSetHp(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa2ff0);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* mHRChara::mGetTop() [?mGetTop@mHRChara@@SAPAV1@XZ]
	static class mHRChara* mGetTop()
	{
		typedef class mHRChara*(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0xa3020);
		return mFunc();
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetRot(class mHRChara* const this) [?mGetRot@mHRChara@@QAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetRot()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3030);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCharaPause(class mHRChara* const this, uint8_t arg2) [?mSetCharaPause@mHRChara@@QAEX_N@Z]
	void mSetCharaPause(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa3150);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetRotY(class mHRChara* const this) [?mGetRotY@mHRChara@@QAEMXZ]
	float mGetRotY()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3180);
		return mFunc(this);
	}
	// [Function] struct WGclMaterialSpec* __convention("thiscall") mHRChara::GetGroundTouchMaterial(class mHRChara* const this) [?GetGroundTouchMaterial@mHRChara@@QBEPAUWGclMaterialSpec@@XZ]
	struct WGclMaterialSpec* GetGroundTouchMaterial()
	{
		typedef struct WGclMaterialSpec*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3190);
		return mFunc(this);
	}
	// [Function] struct stCharaStatus* __convention("thiscall") mHRChara::mGetStatusPtr(class mHRChara* const this) [?mGetStatusPtr@mHRChara@@QAEPAUstCharaStatus@@XZ]
	struct stCharaStatus* mGetStatusPtr()
	{
		typedef struct stCharaStatus*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3260);
		return mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetPos(class mHRChara* const this) [?mGetPos@mHRChara@@QAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetPos()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3280);
		mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetMotionNo(class mHRChara* const this) [?mGetMotionNo@mHRChara@@QBEHXZ]
	int32_t mGetMotionNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3290);
		return mFunc(this);
	}
	// [Function] char* __convention("thiscall") mHRChara::mGetFileName(class mHRChara* const this) [?mGetFileName@mHRChara@@QAEPADXZ]
	// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetFileName()
	{
		typedef char*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3ac0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsTubaAngleCorrect(class mHRChara* const this) [?IsTubaAngleCorrect@mHRChara@@UAE_NXZ]
	uint8_t IsTubaAngleCorrect()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa48f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::getMiraretaiPosition(class mHRChara* const this, struct Vec* arg2) [?getMiraretaiPosition@mHRChara@@UBE_NPAUVec@@@Z]
	uint8_t getMiraretaiPosition(struct Vec* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec* arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4900);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isHopeInterestMe(class mHRChara* const this) [?isHopeInterestMe@mHRChara@@UBE_NXZ]
	uint8_t isHopeInterestMe()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4910);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsWatchPc(class mHRChara* const this) [?IsWatchPc@mHRChara@@UAE_NXZ]
	uint8_t IsWatchPc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4920);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsUseRotMov(class mHRChara* const this) [?IsUseRotMov@mHRChara@@UAE_NXZ]
	uint8_t IsUseRotMov()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4930);
		return mFunc(this);
	}
	// [Function] char const* __convention("thiscall") mHRChara::getCurMotionName(class mHRChara* const this) [?getCurMotionName@mHRChara@@UBEPBDXZ]
	// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
	void getCurMotionName()
	{
		typedef char const*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4940);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestRunMotion(class mHRChara* const this) [?mTestRunMotion@mHRChara@@UAE_NXZ]
	uint8_t mTestRunMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4970);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mZakoDieOut(class mHRChara* const this) [?mZakoDieOut@mHRChara@@UAE_NXZ]
	uint8_t mZakoDieOut()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4980);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCreateLoseSight(class mHRChara* const this) [?mCreateLoseSight@mHRChara@@UAE_NXZ]
	uint8_t mCreateLoseSight()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4990);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckDamageMotion(class mHRChara* const this) [?mCheckDamageMotion@mHRChara@@UAE_NXZ]
	uint8_t mCheckDamageMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa49a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckEnterMotion(class mHRChara* const this) [?mCheckEnterMotion@mHRChara@@UAE_NXZ]
	uint8_t mCheckEnterMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa49b0);
		return mFunc(this);
	}
	// [Function] class TGan* __convention("thiscall") mHRChara::mpGetGan(class mHRChara* const this, int32_t arg2) [?mpGetGan@mHRChara@@UBEPBVTGan@@H@Z]
	class TGan* mpGetGan(int32_t arg2)
	{
		typedef class TGan*(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa49c0);
		return mFunc(this, arg2);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetCurResourceGmfPtr(class mHRChara* const this) [?mGetCurResourceGmfPtr@mHRChara@@UAEPAVTGmf@@XZ]
	class TGmf* mGetCurResourceGmfPtr()
	{
		typedef class TGmf*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa49d0);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfWepLPtr(class mHRChara* const this) [?mGetResourceGmfWepLPtr@mHRChara@@UAEPAVTGmf@@XZ]
	class TGmf* mGetResourceGmfWepLPtr()
	{
		typedef class TGmf*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4a00);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfWepRPtr(class mHRChara* const this) [?mGetResourceGmfWepRPtr@mHRChara@@UAEPAVTGmf@@XZ]
	class TGmf* mGetResourceGmfWepRPtr()
	{
		typedef class TGmf*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4a10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetResourceGmfPtr(class mHRChara* const this, class TGmf* arg2, char* arg3) [?mSetResourceGmfPtr@mHRChara@@UAEXPAVTGmf@@PAD@Z]
	void mSetResourceGmfPtr(class TGmf* arg2, char* arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class TGmf* arg2, char* arg3);
		_Func mFunc = (_Func)(GameModule + 0xa4a20);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfDeadPtr(class mHRChara* const this) [?mGetResourceGmfDeadPtr@mHRChara@@UBEPBVTGmf@@XZ]
	class TGmf* mGetResourceGmfDeadPtr()
	{
		typedef class TGmf*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4a60);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfPtr(class mHRChara* const this) [?mGetResourceGmfPtr@mHRChara@@UBEPBVTGmf@@XZ]
	class TGmf* mGetResourceGmfPtr()
	{
		typedef class TGmf*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4a80);
		return mFunc(this);
	}
	// [Function] class ghmGcCollObjCapsule* __convention("thiscall") mHRChara::mGetCollPtr(class mHRChara* const this) [?mGetCollPtr@mHRChara@@UAEPAVghmGcCollObjCapsule@@XZ]
	class ghmGcCollObjCapsule* mGetCollPtr()
	{
		typedef class ghmGcCollObjCapsule*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4aa0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSethitOidashiDisEnable(class mHRChara* const this, uint8_t arg2) [?mSethitOidashiDisEnable@mHRChara@@UAEX_N@Z]
	void mSethitOidashiDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4ab0);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetBrainPos(class mHRChara* const this) [?mGetBrainPos@mHRChara@@UAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetBrainPos()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4ae0);
		mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetHitPos(class mHRChara* const this) [?mGetHitPos@mHRChara@@UAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetHitPos()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4af0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetMirrorModel(class mHRChara* const this) [?mGetMirrorModel@mHRChara@@UAE_NXZ]
	uint8_t mGetMirrorModel()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4b00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetVisibleDist(class mHRChara* const this) [?mGetVisibleDist@mHRChara@@UAE_NXZ]
	uint8_t mGetVisibleDist()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4b10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCondition(class mHRChara* const this, enum enCharaCondition arg2) [?mSetCondition@mHRChara@@UAEXW4enCharaCondition@@@Z]
	void mSetCondition(enum enCharaCondition arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, enum enCharaCondition arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4b20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetSubMotionSpd(class mHRChara* const this, float arg2) [?mSetSubMotionSpd@mHRChara@@UAEXM@Z]
	void mSetSubMotionSpd(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4b30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheck4tsunbai(class mHRChara* const this) [?mCheck4tsunbai@mHRChara@@UAE_NXZ]
	uint8_t mCheck4tsunbai()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4b50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckSquat(class mHRChara* const this) [?mCheckSquat@mHRChara@@UAE_NXZ]
	uint8_t mCheckSquat()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4b60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mGetThrowMotNo(class mHRChara* const this, int32_t* arg2, int32_t* arg3) [?mGetThrowMotNo@mHRChara@@UAEXPAH0@Z]
	void mGetThrowMotNo(int32_t* arg2, int32_t* arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t* arg2, int32_t* arg3);
		_Func mFunc = (_Func)(GameModule + 0xa4b70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetTsubazeriMotionID(class mHRChara* const this) [?mGetTsubazeriMotionID@mHRChara@@UAEHXZ]
	int32_t mGetTsubazeriMotionID()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4b90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mTsubazeriDifficultyClear(class mHRChara* const this) [?mTsubazeriDifficultyClear@mHRChara@@UAEXXZ]
	void mTsubazeriDifficultyClear()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4ba0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mTsubazeriDifficultyUp(class mHRChara* const this) [?mTsubazeriDifficultyUp@mHRChara@@UAEXXZ]
	void mTsubazeriDifficultyUp()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4bb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsTubaPosAdjust(class mHRChara* const this) [?IsTubaPosAdjust@mHRChara@@UAE_NXZ]
	uint8_t IsTubaPosAdjust()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4bc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckGuard(class mHRChara* const this) [?mCheckGuard@mHRChara@@UAE_NXZ]
	uint8_t mCheckGuard()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4bd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckAttack(class mHRChara* const this) [?mCheckAttack@mHRChara@@UBE_NXZ]
	uint8_t mCheckAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4be0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSubTension(class mHRChara* const this, float arg2) [?mSubTension@mHRChara@@UAEXM@Z]
	void mSubTension(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4bf0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mAddTension(class mHRChara* const this, float arg2) [?mAddTension@mHRChara@@UAEXM@Z]
	void mAddTension(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4c30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetTension(class mHRChara* const this, float arg2) [?mSetTension@mHRChara@@UAEXM@Z]
	void mSetTension(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4c70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mResetTension(class mHRChara* const this) [?mResetTension@mHRChara@@UAEXXZ]
	void mResetTension()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4cb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMovSpd(class mHRChara* const this, float arg2) [?mSetMovSpd@mHRChara@@UAEXM@Z]
	void mSetMovSpd(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4cc0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::UnderControllAttack_A(class mHRChara* const this) [?UnderControllAttack_A@mHRChara@@UAE_NXZ]
	uint8_t UnderControllAttack_A()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4ce0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::UnderControllComboAttack(class mHRChara* const this) [?UnderControllComboAttack@mHRChara@@UAE_NXZ]
	uint8_t UnderControllComboAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4cf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::ExitUnderControl(class mHRChara* const this) [?ExitUnderControl@mHRChara@@UAEXXZ]
	void ExitUnderControl()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4d00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::EnterUnderControl(class mHRChara* const this) [?EnterUnderControl@mHRChara@@UAEXXZ]
	void EnterUnderControl()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4d10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPostRenderProc(class mHRChara* const this) [?mPostRenderProc@mHRChara@@UAE_NXZ]
	uint8_t mPostRenderProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4d20);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::getViewClipBoxPositionOffsetY(class mHRChara* const this) [?getViewClipBoxPositionOffsetY@mHRChara@@MBEMXZ]
	float getViewClipBoxPositionOffsetY()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4d30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::getViewClipBoxHalfLengthXYZ(class mHRChara* const this, struct Vec* arg2) [?getViewClipBoxHalfLengthXYZ@mHRChara@@MBEXPAUVec@@@Z]
	void getViewClipBoxHalfLengthXYZ(struct Vec* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec* arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4d40);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetResNo(class mHRChara* const this) [?mGetResNo@mHRChara@@QBEHXZ]
	int32_t mGetResNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4d60);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetDropMoney(class mHRChara* const this) [?mGetDropMoney@mHRChara@@QBEHXZ]
	int32_t mGetDropMoney()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4d70);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetItemNo(class mHRChara* const this) [?mGetItemNo@mHRChara@@QBEHXZ]
	int32_t mGetItemNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4d80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::setLocatorNode(class mHRChara* const this, class TGmfNode* arg2) [?setLocatorNode@mHRChara@@UAEXPBVTGmfNode@@@Z]
	void setLocatorNode(class TGmfNode* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class TGmfNode* arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4da0);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetHpRate(class mHRChara* const this) [?mGetHpRate@mHRChara@@QBEMXZ]
	float mGetHpRate()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4f00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSubHp(class mHRChara* const this, float arg2) [?mSubHp@mHRChara@@QAEXM@Z]
	void mSubHp(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa4f10);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetHitSize(class mHRChara* const this) [?mGetHitSize@mHRChara@@QAEMXZ]
	float mGetHitSize()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4f60);
		return mFunc(this);
	}
	// [Function] enum enCharaInitProc __convention("thiscall") mHRChara::mGetInitProc(class mHRChara* const this) [?mGetInitProc@mHRChara@@QAE?AW4enCharaInitProc@@XZ]
	enum enCharaInitProc mGetInitProc()
	{
		typedef enum enCharaInitProc(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4f70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isCrashBreak(class mHRChara* const this) [?isCrashBreak@mHRChara@@UBE_NXZ]
	uint8_t isCrashBreak()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4fd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCharaHit(class mHRChara* const this, uint8_t arg2) [?mSetCharaHit@mHRChara@@QAEX_N@Z]
	void mSetCharaHit(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5120);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetDmgAtkMot(class mHRChara* const this) [?mGetDmgAtkMot@mHRChara@@QAEHXZ]
	int32_t mGetDmgAtkMot()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5a80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMotionProcessDisEnable(class mHRChara* const this, uint8_t arg2) [?mSetMotionProcessDisEnable@mHRChara@@QAEX_N@Z]
	void mSetMotionProcessDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5a90);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetMotionSpd(class mHRChara* const this) [?mGetMotionSpd@mHRChara@@QAEMXZ]
	float mGetMotionSpd()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5ae0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetStageHitDisEnable(class mHRChara* const this, uint8_t arg2) [?mSetStageHitDisEnable@mHRChara@@QAEX_N@Z]
	void mSetStageHitDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5af0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsFootShadowDraw(class mHRChara* const this) [?IsFootShadowDraw@mHRChara@@QBE_NXZ]
	uint8_t IsFootShadowDraw()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5b30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetFootShadowDraw(class mHRChara* const this, uint8_t arg2) [?SetFootShadowDraw@mHRChara@@QAEX_N@Z]
	void SetFootShadowDraw(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5b40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMotionNoNpc(class mHRChara* const this, int32_t arg2) [?mSetMotionNoNpc@mHRChara@@QAEXH@Z]
	void mSetMotionNoNpc(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5b50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCallScriptProc(class mHRChara* const this, char* arg2) [?mSetCallScriptProc@mHRChara@@QAEXPAD@Z]
	void mSetCallScriptProc(char* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, char* arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5b60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDropMoney(class mHRChara* const this, int32_t arg2) [?mSetDropMoney@mHRChara@@QAEXH@Z]
	void mSetDropMoney(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5b70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetReactionDist(class mHRChara* const this, float arg2) [?mSetReactionDist@mHRChara@@QAEXM@Z]
	void mSetReactionDist(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5b80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetEnterPattern(class mHRChara* const this, int32_t arg2) [?mSetEnterPattern@mHRChara@@QAEXH@Z]
	void mSetEnterPattern(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5b90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDatNo(class mHRChara* const this, int32_t arg2) [?mSetDatNo@mHRChara@@QAEXH@Z]
	void mSetDatNo(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5ba0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetResNo(class mHRChara* const this, int32_t arg2) [?mSetResNo@mHRChara@@QAEXH@Z]
	void mSetResNo(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetCharaType(class mHRChara* const this, enum enCharaType arg2) [?mSetCharaType@mHRChara@@QAEXW4enCharaType@@@Z]
	void mSetCharaType(enum enCharaType arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, enum enCharaType arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5bc0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetDatNo(class mHRChara* const this) [?mGetDatNo@mHRChara@@QBEHXZ]
	int32_t mGetDatNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5bd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetResourceDeleteFlag(class mHRChara* const this) [?mGetResourceDeleteFlag@mHRChara@@QAE_NXZ]
	uint8_t mGetResourceDeleteFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5be0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetDmgUpperPosY(class mHRChara* const this) [?mGetDmgUpperPosY@mHRChara@@QAEMXZ]
	float mGetDmgUpperPosY()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5c00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetDmgUpper(class mHRChara* const this) [?mGetDmgUpper@mHRChara@@QAE_NXZ]
	uint8_t mGetDmgUpper()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5c10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetResourceDeleteFlag(class mHRChara* const this, uint8_t arg2) [?mSetResourceDeleteFlag@mHRChara@@QAEX_N@Z]
	void mSetResourceDeleteFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa5c50);
		return mFunc(this, arg2);
	}
	// [Function] class ghmPlane& __convention("thiscall") mHRChara::getLatestGroundTouchPlane(class mHRChara* const this) [?getLatestGroundTouchPlane@mHRChara@@QBEABVghmPlane@@XZ]
	// Can't export & pointer 'class ghmPlane&' [TypeClass.PointerTypeClass] in LuaBridge
	void getLatestGroundTouchPlane()
	{
		typedef class ghmPlane&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa89d0);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mUndispBtlIcn(class mHRChara* const this) [?mUndispBtlIcn@mHRChara@@QAEXXZ]
	void mUndispBtlIcn()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa94a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnFinishDemo(class mHRChara* const this, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4) [?mChgBtlIcnFinishDemo@mHRChara@@QAEXW4E_CON_ACT_ID@HrBattleIcon@@0_N@Z]
	void mChgBtlIcnFinishDemo(enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0xa94d0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnTb(class mHRChara* const this) [?mChgBtlIcnTb@mHRChara@@QAEXXZ]
	void mChgBtlIcnTb()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa9510);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetDrawYAdjust(class mHRChara* const this, float arg2) [?SetDrawYAdjust@mHRChara@@QAEXM@Z]
	void SetDrawYAdjust(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa9af0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDemoCtrl(class mHRChara* const this, uint8_t arg2) [?mSetDemoCtrl@mHRChara@@QAEX_N@Z]
	void mSetDemoCtrl(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa9b10);
		return mFunc(this, arg2);
	}
	// [Function] uint64_t __convention("thiscall") mHRChara::mGetDemoCtrl(class mHRChara* const this) [?mGetDemoCtrl@mHRChara@@QAE_KXZ]
	uint64_t mGetDemoCtrl()
	{
		typedef uint64_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa9b90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isAcceptDistanceDelete(class mHRChara* const this) [?isAcceptDistanceDelete@mHRChara@@UAE_NXZ]
	uint8_t isAcceptDistanceDelete()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xab940);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetStageHitDisEnableReq(class mHRChara* const this, uint8_t arg2) [?mSetStageHitDisEnableReq@mHRChara@@QAEX_N@Z]
	void mSetStageHitDisEnableReq(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xab950);
		return mFunc(this, arg2);
	}
	// [Function] struct stCharaEffect* __convention("thiscall") mHRChara::mGetEffectStPtr(class mHRChara* const this) [?mGetEffectStPtr@mHRChara@@QAEPAUstCharaEffect@@XZ]
	struct stCharaEffect* mGetEffectStPtr()
	{
		typedef struct stCharaEffect*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xab960);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::setBlackBodyEffect(class mHRChara* const this, class EffectEnemyDamage* arg2) [?setBlackBodyEffect@mHRChara@@QAEXPAVEffectEnemyDamage@@@Z]
	void setBlackBodyEffect(class EffectEnemyDamage* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class EffectEnemyDamage* arg2);
		_Func mFunc = (_Func)(GameModule + 0xab970);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetNavelPos(class mHRChara* const this) [?mGetNavelPos@mHRChara@@UAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetNavelPos()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xab980);
		mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDamageAcceptFrame(class mHRChara* const this, int32_t arg2) [?mSetDamageAcceptFrame@mHRChara@@QAEXH@Z]
	void mSetDamageAcceptFrame(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xab990);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetAlwaysCheckHitColl(class mHRChara* const this, uint8_t arg2) [?mSetAlwaysCheckHitColl@mHRChara@@QAEX_N@Z]
	void mSetAlwaysCheckHitColl(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xab9a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetLockOnNoCheckColl(class mHRChara* const this) [?mGetLockOnNoCheckColl@mHRChara@@QAE_NXZ]
	uint8_t mGetLockOnNoCheckColl()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaba30);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetLockOnDistanceLow(class mHRChara* const this) [?mGetLockOnDistanceLow@mHRChara@@QAEMXZ]
	float mGetLockOnDistanceLow()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaba40);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetLockOnDistanceHi(class mHRChara* const this) [?mGetLockOnDistanceHi@mHRChara@@QAEMXZ]
	float mGetLockOnDistanceHi()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaba50);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetLockOnDistance(class mHRChara* const this) [?mGetLockOnDistance@mHRChara@@QAEMXZ]
	float mGetLockOnDistance()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaba60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetAliveBtlIcn(class mHRChara* const this) [?mGetAliveBtlIcn@mHRChara@@QAE_NXZ]
	uint8_t mGetAliveBtlIcn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaba70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnFinish(class mHRChara* const this, enum HrBattleIcon::D_TODOME_DIRECT arg2) [?mChgBtlIcnFinish@mHRChara@@QAEXW4D_TODOME_DIRECT@HrBattleIcon@@@Z]
	void mChgBtlIcnFinish(enum HrBattleIcon::D_TODOME_DIRECT arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, enum HrBattleIcon::D_TODOME_DIRECT arg2);
		_Func mFunc = (_Func)(GameModule + 0xaba80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetSlowBlow(class mHRChara* const this, uint8_t arg2) [?mSetSlowBlow@mHRChara@@QAEX_N@Z]
	void mSetSlowBlow(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabac0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetInputFinishReq(class mHRChara* const this, uint8_t arg2) [?mSetInputFinishReq@mHRChara@@QAEX_N@Z]
	void mSetInputFinishReq(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabad0);
		return mFunc(this, arg2);
	}
	// [Function] class TGan* __convention("thiscall") mHRChara::mGetResourceGanPtr(class mHRChara* const this, int32_t arg2) [?mGetResourceGanPtr@mHRChara@@QAEPAVTGan@@H@Z]
	class TGan* mGetResourceGanPtr(int32_t arg2)
	{
		typedef class TGan*(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabaf0);
		return mFunc(this, arg2);
	}
	// [Function] int16_t __convention("thiscall") mHRChara::mGetMoney(class mHRChara* const this) [?mGetMoney@mHRChara@@QAEFXZ]
	int16_t mGetMoney()
	{
		typedef int16_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabb00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMoney(class mHRChara* const this, int16_t arg2) [?mSetMoney@mHRChara@@QAEXF@Z]
	void mSetMoney(int16_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int16_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabb10);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetInputFinishReq(class mHRChara* const this) [?mGetInputFinishReq@mHRChara@@QAE_NXZ]
	uint8_t mGetInputFinishReq()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabb20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mAddMoney(class mHRChara* const this, int16_t arg2) [?mAddMoney@mHRChara@@QAEXF@Z]
	void mAddMoney(int16_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int16_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabb30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetInvincibleMotion(class mHRChara* const this, int32_t arg2, int32_t arg3) [?mSetInvincibleMotion@mHRChara@@QAEXHH@Z]
	void mSetInvincibleMotion(int32_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0xabb40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mResetInvincibleMotion(class mHRChara* const this) [?mResetInvincibleMotion@mHRChara@@QAEXXZ]
	void mResetInvincibleMotion()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabb60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCanGetHitByMotion(class mHRChara* const this, int32_t arg2) [?mCanGetHitByMotion@mHRChara@@QBE_NH@Z]
	uint8_t mCanGetHitByMotion(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabb80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mDispAtkHitIcn(class mHRChara* const this) [?mDispAtkHitIcn@mHRChara@@QAE_NXZ]
	uint8_t mDispAtkHitIcn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabbb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetDontStandUp(class mHRChara* const this) [?mGetDontStandUp@mHRChara@@QAE_NXZ]
	uint8_t mGetDontStandUp()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabbd0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::GetTubaFrmOffset(class mHRChara* const this) [?GetTubaFrmOffset@mHRChara@@QAEMXZ]
	float GetTubaFrmOffset()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabbe0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::GetAtkDisAdjust(class mHRChara* const this) [?GetAtkDisAdjust@mHRChara@@QAEMXZ]
	float GetAtkDisAdjust()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabbf0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetLoseTsubazeriFlag(class mHRChara* const this) [?mGetLoseTsubazeriFlag@mHRChara@@QAE_NXZ]
	uint8_t mGetLoseTsubazeriFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabc00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetSuccessThrow(class mHRChara* const this, uint8_t arg2) [?mSetSuccessThrow@mHRChara@@QAEX_N@Z]
	void mSetSuccessThrow(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabc10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetRotYA(class mHRChara* const this, float arg2) [?mSetRotYA@mHRChara@@QAEXM@Z]
	void mSetRotYA(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xabc40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDontStandUp(class mHRChara* const this, uint8_t arg2) [?mSetDontStandUp@mHRChara@@QAEX_N@Z]
	void mSetDontStandUp(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabc50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDmgGrav(class mHRChara* const this, float arg2) [?mSetDmgGrav@mHRChara@@QAEXM@Z]
	void mSetDmgGrav(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xabc80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnSml(class mHRChara* const this, uint8_t arg2) [?mChgBtlIcnSml@mHRChara@@QAEX_N@Z]
	void mChgBtlIcnSml(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xabc90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mChgBtlIcnBig(class mHRChara* const this) [?mChgBtlIcnBig@mHRChara@@QAEXXZ]
	void mChgBtlIcnBig()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabe10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetCharaHit(class mHRChara* const this) [?mGetCharaHit@mHRChara@@QAE_NXZ]
	uint8_t mGetCharaHit()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabf20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetCanLockOn(class mHRChara* const this) [?mGetCanLockOn@mHRChara@@QAE_NXZ]
	uint8_t mGetCanLockOn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabf30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGethitOidashiDisEnable(class mHRChara* const this) [?mGethitOidashiDisEnable@mHRChara@@QAE_NXZ]
	uint8_t mGethitOidashiDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabf40);
		return mFunc(this);
	}
	// [Function] enum HrBattleIcon::D_BICON_STAT __convention("thiscall") mHRChara::mGetBtlIcnStatus(class mHRChara* const this) [?mGetBtlIcnStatus@mHRChara@@QAE?AW4D_BICON_STAT@HrBattleIcon@@XZ]
	enum HrBattleIcon::D_BICON_STAT mGetBtlIcnStatus()
	{
		typedef enum HrBattleIcon::D_BICON_STAT(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabf60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetWepVisible(class mHRChara* const this) [?mGetWepVisible@mHRChara@@QAE_NXZ]
	uint8_t mGetWepVisible()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xabf90);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetMotionBrendNum(class mHRChara* const this) [?mGetMotionBrendNum@mHRChara@@QAEHXZ]
	int32_t mGetMotionBrendNum()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xac020);
		return mFunc(this);
	}
	// [Function] int16_t __convention("thiscall") mHRChara::mGetAiValue(class mHRChara* const this, int32_t arg2) [?mGetAiValue@mHRChara@@QAEFH@Z]
	int16_t mGetAiValue(int32_t arg2)
	{
		typedef int16_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xac030);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mResetPosA(class mHRChara* const this) [?mResetPosA@mHRChara@@QAEXXZ]
	void mResetPosA()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xac040);
		return mFunc(this);
	}
	// [Function] class ghmPlane& __convention("thiscall") mHRChara::getEasyShadowProjectionPlane(class mHRChara* const this) [?getEasyShadowProjectionPlane@mHRChara@@QBEABVghmPlane@@XZ]
	// Can't export & pointer 'class ghmPlane&' [TypeClass.PointerTypeClass] in LuaBridge
	void getEasyShadowProjectionPlane()
	{
		typedef class ghmPlane&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xac0d0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isInterestTarget(class mHRChara* const this) [?isInterestTarget@mHRChara@@QBE_NXZ]
	uint8_t isInterestTarget()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xac100);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMotionSpd(class mHRChara* const this, float arg2) [?mSetMotionSpd@mHRChara@@QAEXM@Z]
	void mSetMotionSpd(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xac140);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetWepEffectVisible(class mHRChara* const this) [?mGetWepEffectVisible@mHRChara@@QAE_NXZ]
	uint8_t mGetWepEffectVisible()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xac150);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetVisible(class mHRChara* const this) [?mGetVisible@mHRChara@@QAE_NXZ]
	uint8_t mGetVisible()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xac1a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetTension(class mHRChara* const this) [?mGetTension@mHRChara@@QAEMXZ]
	float mGetTension()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xac270);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetMiniMapRender(class mHRChara* const this) [?mGetMiniMapRender@mHRChara@@QBE_NXZ]
	uint8_t mGetMiniMapRender()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xacfb0);
		return mFunc(this);
	}
	// [Function] class ghmResGroup* __convention("thiscall") mHRChara::mGetResourceRslPtr(class mHRChara* const this) [?mGetResourceRslPtr@mHRChara@@QAEPAVghmResGroup@@XZ]
	class ghmResGroup* mGetResourceRslPtr()
	{
		typedef class ghmResGroup*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xad5f0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::getFootNumber(class mHRChara* const this) [?getFootNumber@mHRChara@@QBEHXZ]
	int32_t getFootNumber()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xada50);
		return mFunc(this);
	}
	// [Function] char* __convention("thiscall") mHRChara::mGetCallScriptProc(class mHRChara* const this) [?mGetCallScriptProc@mHRChara@@QAEPADXZ]
	// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetCallScriptProc()
	{
		typedef char*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb03a0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetMotionProcessDisEnable(class mHRChara* const this) [?mGetMotionProcessDisEnable@mHRChara@@QBE_NXZ]
	uint8_t mGetMotionProcessDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb03b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsBloom(class mHRChara* const this) [?IsBloom@mHRChara@@QAE_NXZ]
	uint8_t IsBloom()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb03c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetTermAll(class mHRChara* const this, uint8_t arg2) [?SetTermAll@mHRChara@@QAEX_N@Z]
	void SetTermAll(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xb03d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::SetKnockBackSpd(class mHRChara* const this, float arg2) [?SetKnockBackSpd@mHRChara@@QAEXM@Z]
	void SetKnockBackSpd(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xb0430);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::GetKnockBackSpd(class mHRChara* const this) [?GetKnockBackSpd@mHRChara@@QAEMXZ]
	float GetKnockBackSpd()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb0440);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetStageHitDisEnable(class mHRChara* const this) [?mGetStageHitDisEnable@mHRChara@@QAE_NXZ]
	uint8_t mGetStageHitDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb0450);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetStartSplitFlameFlag(class mHRChara* const this) [?mGetStartSplitFlameFlag@mHRChara@@QBE_NXZ]
	uint8_t mGetStartSplitFlameFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb04b0);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRChara::getBoneEffectGmf(class mHRChara* const this) [?getBoneEffectGmf@mHRChara@@AAEPAVTGmf@@XZ]
	class TGmf* getBoneEffectGmf()
	{
		typedef class TGmf*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb04c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetStartSplitFlameFlag(class mHRChara* const this, uint8_t arg2) [?mSetStartSplitFlameFlag@mHRChara@@QAEX_N@Z]
	void mSetStartSplitFlameFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xb04e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetCharaPause(class mHRChara* const this) [?mGetCharaPause@mHRChara@@QBE_NXZ]
	uint8_t mGetCharaPause()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb05a0);
		return mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetBeforePos(class mHRChara* const this) [?mGetBeforePos@mHRChara@@QAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetBeforePos()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb9640);
		mFunc(this);
	}
	// [Function] int16_t __convention("thiscall") mHRChara::mGetZakoWepType(class mHRChara* const this) [?mGetZakoWepType@mHRChara@@QBEFXZ]
	int16_t mGetZakoWepType()
	{
		typedef int16_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb9900);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetFootHitResultObj2(class mHRChara* const this, class ghmGcCollObjHitResultObj& arg2) [?mSetFootHitResultObj2@mHRChara@@QAEXABVghmGcCollObjHitResultObj@@@Z]
	void mSetFootHitResultObj2(class ghmGcCollObjHitResultObj& arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class ghmGcCollObjHitResultObj& arg2);
		_Func mFunc = (_Func)(GameModule + 0xba010);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDmgUpperPow(class mHRChara* const this, float arg2) [?mSetDmgUpperPow@mHRChara@@QAEXM@Z]
	void mSetDmgUpperPow(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xba060);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mAddHp(class mHRChara* const this, float arg2) [?mAddHp@mHRChara@@QAEXM@Z]
	void mAddHp(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xba980);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetSubMotionSpd(class mHRChara* const this) [?mGetSubMotionSpd@mHRChara@@QAEMXZ]
	float mGetSubMotionSpd()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xbd0b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetZakoWepType(class mHRChara* const this, int16_t arg2) [?mSetZakoWepType@mHRChara@@QAEXF@Z]
	void mSetZakoWepType(int16_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int16_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xbd120);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetHitSize(class mHRChara* const this, float arg2) [?mSetHitSize@mHRChara@@QAEXM@Z]
	void mSetHitSize(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xbd4a0);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetReactionDist(class mHRChara* const this) [?mGetReactionDist@mHRChara@@QBEMXZ]
	float mGetReactionDist()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xc0260);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMiniMapRender(class mHRChara* const this, uint8_t arg2) [?mSetMiniMapRender@mHRChara@@QAEX_N@Z]
	void mSetMiniMapRender(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xc0270);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec __convention("thiscall") mHRChara::GetKnockBackDir(class mHRChara* const this) [?GetKnockBackDir@mHRChara@@QAE?AUVec@@XZ]
	struct Vec GetKnockBackDir()
	{
		typedef struct Vec(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xc7970);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRChara::mGetMotionNoNpc(class mHRChara* const this) [?mGetMotionNoNpc@mHRChara@@QAEHXZ]
	int32_t mGetMotionNoNpc()
	{
		typedef int32_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xc97e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetNormalClip(class mHRChara* const this, uint8_t arg2) [?SetNormalClip@mHRChara@@QAEX_N@Z]
	void SetNormalClip(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xce050);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") mHRChara::mGetOldPos(class mHRChara* const this) [?mGetOldPos@mHRChara@@QAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetOldPos()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xd4ae0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetSuccessThrow(class mHRChara* const this) [?mGetSuccessThrow@mHRChara@@QAE_NXZ]
	uint8_t mGetSuccessThrow()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xd8b90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDmgUpperPosY(class mHRChara* const this, float const arg2) [?mSetDmgUpperPosY@mHRChara@@QAEXM@Z]
	void mSetDmgUpperPosY(float const arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float const arg2);
		_Func mFunc = (_Func)(GameModule + 0xe34c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::SetDeleteReq(class mHRChara* const this) [?SetDeleteReq@mHRChara@@QAEXXZ]
	void SetDeleteReq()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46dcf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::getShootPosiAndYaw(class mHRChara* const this, struct Vec* arg2, float* arg3, class TGmf& arg4, char const* arg5) [?getShootPosiAndYaw@mHRChara@@QBEXPAUVec@@PAMABVTGmf@@PBD@Z]
	void getShootPosiAndYaw(struct Vec* arg2, float* arg3, class TGmf& arg4, std::string arg5)
	{
		char const* arg5_c_str = arg5.c_str();
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec* arg2, float* arg3, class TGmf& arg4, char const* arg5);
		_Func mFunc = (_Func)(GameModule + 0x46dd10);
		return mFunc(this, arg2, arg3, arg4, arg5_c_str);
	}
	// [Function] void __convention("thiscall") mHRChara::setHomingPositionFromAI(class mHRChara* const this, struct Vec& arg2) [?setHomingPositionFromAI@mHRChara@@QAEXABUVec@@@Z]
	void setHomingPositionFromAI(struct Vec& arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec& arg2);
		_Func mFunc = (_Func)(GameModule + 0x46de70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::setHomingActFlagFromAI(class mHRChara* const this, uint8_t const arg2) [?setHomingActFlagFromAI@mHRChara@@QAEX_N@Z]
	void setHomingActFlagFromAI(uint8_t const arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t const arg2);
		_Func mFunc = (_Func)(GameModule + 0x46dea0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isHoming(class mHRChara* const this) [?isHoming@mHRChara@@QBE_NXZ]
	uint8_t isHoming()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46ded0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::setInterestUseBoneNumFromAI(class mHRChara* const this, int32_t const arg2) [?setInterestUseBoneNumFromAI@mHRChara@@QAEXH@Z]
	void setInterestUseBoneNumFromAI(int32_t const arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t const arg2);
		_Func mFunc = (_Func)(GameModule + 0x46def0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::isInteresting(class mHRChara* const this) [?isInteresting@mHRChara@@QBE_NXZ]
	uint8_t isInteresting()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46df20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::addDamageToYuremono(class mHRChara* const this, float const arg2, struct Vec& arg3) [?addDamageToYuremono@mHRChara@@QAEXMABUVec@@@Z]
	void addDamageToYuremono(float const arg2, struct Vec& arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float const arg2, struct Vec& arg3);
		_Func mFunc = (_Func)(GameModule + 0x46df40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mot::IBoneEffectPJ* __convention("thiscall") mHRChara::getBoneEffect(class mHRChara* const this) [?getBoneEffect@mHRChara@@IAEPAVIBoneEffectPJ@mot@@XZ]
	class mot::IBoneEffectPJ* getBoneEffect()
	{
		typedef class mot::IBoneEffectPJ*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46df80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mSetHajikiCheck(class mHRChara* const this, float arg2) [?mSetHajikiCheck@mHRChara@@QAE_NM@Z]
	uint8_t mSetHajikiCheck(float arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x46dfa0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckDamageAccept(class mHRChara* const this) [?mCheckDamageAccept@mHRChara@@QAE_NXZ]
	uint8_t mCheckDamageAccept()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46dfc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestZakoDown(class mHRChara* const this) [?mTestZakoDown@mHRChara@@QAE_NXZ]
	uint8_t mTestZakoDown()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46dfd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestPiyoRequest(class mHRChara* const this) [?mTestPiyoRequest@mHRChara@@QAE_NXZ]
	uint8_t mTestPiyoRequest()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e000);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetPiyoriHeight(class mHRChara* const this) [?mGetPiyoriHeight@mHRChara@@QAEMXZ]
	float mGetPiyoriHeight()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e010);
		return mFunc(this);
	}
	// [Function] class mHRChara* mHRChara::mGetCharaPtr(int32_t arg1) [?mGetCharaPtr@mHRChara@@SAPAV1@H@Z]
	static class mHRChara* mGetCharaPtr(int32_t arg1)
	{
		typedef class mHRChara*(__fastcall* _Func)(int32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x46e100);
		return mFunc(arg1);
	}
	// [Function] void mHRChara::mRenderGmf(void* arg1) [?mRenderGmf@mHRChara@@SAXPAX@Z]
	static void mRenderGmf(void* arg1)
	{
		typedef void(__fastcall* _Func)(void* arg1);
		_Func mFunc = (_Func)(GameModule + 0x46e120);
		return mFunc(arg1);
	}
	// [Function] int32_t mHRChara::debugDispCharaInfo() [?debugDispCharaInfo@mHRChara@@SAXXZ]
	static int32_t debugDispCharaInfo()
	{
		typedef int32_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x46e140);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mTermAllZakoMotion() [?mTermAllZakoMotion@mHRChara@@SA_NXZ]
	static uint8_t mTermAllZakoMotion()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x46e150);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mInitAllNpc() [?mInitAllNpc@mHRChara@@SA_NXZ]
	static uint8_t mInitAllNpc()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x46e3a0);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::mCreateBloodSplash(class mHRChara* const this, class TGmfNode* arg2, float arg3, struct tagHRTASKCHECK* arg4) [?mCreateBloodSplash@mHRChara@@QAEXPAVTGmfNode@@MPAUtagHRTASKCHECK@@@Z]
	void mCreateBloodSplash(class TGmfNode* arg2, float arg3, struct tagHRTASKCHECK* arg4)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class TGmfNode* arg2, float arg3, struct tagHRTASKCHECK* arg4);
		_Func mFunc = (_Func)(GameModule + 0x46e3e0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRChara::mBloodSplashProc(class mHRChara* const this) [?mBloodSplashProc@mHRChara@@QAEXXZ]
	void mBloodSplashProc()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e440);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::AddBoneElectPtrToList(class mHRChara* const this, class EffectBoneElect* arg2) [?AddBoneElectPtrToList@mHRChara@@QAEXPAVEffectBoneElect@@@Z]
	void AddBoneElectPtrToList(class EffectBoneElect* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class EffectBoneElect* arg2);
		_Func mFunc = (_Func)(GameModule + 0x46e4e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::ReleaseBoneElect(class mHRChara* const this) [?ReleaseBoneElect@mHRChara@@QAE_NXZ]
	uint8_t ReleaseBoneElect()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e520);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsEmtpyBoneElectList(class mHRChara* const this) [?IsEmtpyBoneElectList@mHRChara@@QAE_NXZ]
	uint8_t IsEmtpyBoneElectList()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e600);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::DeleteBoneElectFromList(class mHRChara* const this, class EffectBoneElect* arg2) [?DeleteBoneElectFromList@mHRChara@@QAEXPAVEffectBoneElect@@@Z]
	void DeleteBoneElectFromList(class EffectBoneElect* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class EffectBoneElect* arg2);
		_Func mFunc = (_Func)(GameModule + 0x46e620);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::AddCutmarkPtrToList(class mHRChara* const this, class EffectCutMark* arg2) [?AddCutmarkPtrToList@mHRChara@@QAEXPAVEffectCutMark@@@Z]
	void AddCutmarkPtrToList(class EffectCutMark* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class EffectCutMark* arg2);
		_Func mFunc = (_Func)(GameModule + 0x46e660);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsEmtpyCutmarkList(class mHRChara* const this) [?IsEmtpyCutmarkList@mHRChara@@QAE_NXZ]
	uint8_t IsEmtpyCutmarkList()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e6a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::DeleteCutmarkFromList(class mHRChara* const this, class EffectCutMark* arg2) [?DeleteCutmarkFromList@mHRChara@@QAEXPAVEffectCutMark@@@Z]
	void DeleteCutmarkFromList(class EffectCutMark* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class EffectCutMark* arg2);
		_Func mFunc = (_Func)(GameModule + 0x46e6c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::SetPowerFlash(class mHRChara* const this, int32_t arg2, struct GXColor arg3) [?SetPowerFlash@mHRChara@@QAE_NHUGXColor@@@Z]
	uint8_t SetPowerFlash(int32_t arg2, struct GXColor arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, struct GXColor arg3);
		_Func mFunc = (_Func)(GameModule + 0x46e700);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::SetNoGuardEffect(class mHRChara* const this) [?SetNoGuardEffect@mHRChara@@QAE_NXZ]
	uint8_t SetNoGuardEffect()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e820);
		return mFunc(this);
	}
	// [Function] uint8_t mHRChara::mCheckAtkAllNpc() [?mCheckAtkAllNpc@mHRChara@@SA_NXZ]
	static uint8_t mCheckAtkAllNpc()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x46e840);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mCheckCanAtk() [?mCheckCanAtk@mHRChara@@SA_NXZ]
	static uint8_t mCheckCanAtk()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x46e870);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::mCallBeforeRenderProc(class mHRChara* const this) [?mCallBeforeRenderProc@mHRChara@@QAEXXZ]
	void mCallBeforeRenderProc()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e8a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanHit(class mHRChara* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mCheckCanHit@mHRChara@@UAE_NH_N0@Z]
	uint8_t mCheckCanHit(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x46e8b0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRChara::CreateFootSmokeEffect(class mHRChara* const this) [?CreateFootSmokeEffect@mHRChara@@QAEXXZ]
	/// <summary>
	/// Creates a dust effect at character feet.
	/// </summary>
	void CreateFootSmokeEffect()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46e8c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::KnockBackProc(class mHRChara* const this) [?KnockBackProc@mHRChara@@QAEXXZ]
	void KnockBackProc()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46ea20);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::GetKnockBackRatio(class mHRChara* const this) [?GetKnockBackRatio@mHRChara@@QAEMXZ]
	float GetKnockBackRatio()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46eb30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mSetDamage(class mHRChara* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@mHRChara@@UAE_NMHHHMHMMPAV1@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x46eba0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] void __convention("thiscall") mHRChara::mInitDamageMotInfo(class mHRChara* const this) [?mInitDamageMotInfo@mHRChara@@QAEXXZ]
	void mInitDamageMotInfo()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46ebb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mChangeDefAi(class mHRChara* const this, uint8_t arg2, uint8_t arg3) [?mChangeDefAi@mHRChara@@QAE_N_N0@Z]
	uint8_t mChangeDefAi(uint8_t arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x46ebe0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDefAI(class mHRChara* const this, uint8_t arg2) [?mSetDefAI@mHRChara@@QAEX_N@Z]
	void mSetDefAI(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x46ec60);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCallFrameProc(class mHRChara* const this) [?mCheckCallFrameProc@mHRChara@@QAE_NXZ]
	uint8_t mCheckCallFrameProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46ecb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsNowUnderControl(class mHRChara* const this) [?IsNowUnderControl@mHRChara@@QAE_NXZ]
	uint8_t IsNowUnderControl()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46ed60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::RegistUnderControlAtkFuncPtr(class mHRChara* const this) [?RegistUnderControlAtkFuncPtr@mHRChara@@QAEXXZ]
	void RegistUnderControlAtkFuncPtr()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46ed70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::RegistUnderControlMotID(class mHRChara* const this, struct CharControlMotID& arg2) [?RegistUnderControlMotID@mHRChara@@QAEXABUCharControlMotID@@@Z]
	void RegistUnderControlMotID(struct CharControlMotID& arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct CharControlMotID& arg2);
		_Func mFunc = (_Func)(GameModule + 0x46ed80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::SetUnderControlFlag(class mHRChara* const this, uint8_t arg2) [?SetUnderControlFlag@mHRChara@@QAEX_N@Z]
	void SetUnderControlFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x46edb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::DrawDebugCollision(class mHRChara* const this) [?DrawDebugCollision@mHRChara@@IAEXXZ]
	void DrawDebugCollision()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46edf0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mRenderProc(class mHRChara* const this) [?mRenderProc@mHRChara@@UAE_NXZ]
	uint8_t mRenderProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46ee00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::postSetupMatrix(class mHRChara* const this) [?postSetupMatrix@mHRChara@@AAEXXZ]
	void postSetupMatrix()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46ef90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::preSetupMatrix(class mHRChara* const this) [?preSetupMatrix@mHRChara@@AAEXXZ]
	void preSetupMatrix()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46f000);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mFootSmokeEffect(class mHRChara* const this) [?mFootSmokeEffect@mHRChara@@QAEXXZ]
	void mFootSmokeEffect()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46f1f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mPosAnimationProc(class mHRChara* const this) [?mPosAnimationProc@mHRChara@@QAEXXZ]
	void mPosAnimationProc()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46f590);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPostFrameProc(class mHRChara* const this) [?mPostFrameProc@mHRChara@@UAE_NXZ]
	uint8_t mPostFrameProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46f6b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mFrameProc(class mHRChara* const this) [?mFrameProc@mHRChara@@UAE_NXZ]
	uint8_t mFrameProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46f860);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mInit(class mHRChara* const this) [?mInit@mHRChara@@UAE_NXZ]
	uint8_t mInit()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46f870);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetRotA(class mHRChara* const this, struct Vec& arg2, uint32_t const arg3) [?mSetRotA@mHRChara@@QAEXABUVec@@I@Z]
	void mSetRotA(struct Vec& arg2, uint32_t const arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec& arg2, uint32_t const arg3);
		_Func mFunc = (_Func)(GameModule + 0x46fd30);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetWepEffectVisibleInstant(class mHRChara* const this, uint8_t arg2) [?mSetWepEffectVisibleInstant@mHRChara@@QAEX_N@Z]
	void mSetWepEffectVisibleInstant(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x46fda0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSubFrameStop(class mHRChara* const this) [?mSubFrameStop@mHRChara@@QAEXXZ]
	void mSubFrameStop()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x46fe70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPlayMotionMov(class mHRChara* const this, int32_t arg2, float arg3, float arg4, float arg5, uint8_t arg6) [?mPlayMotionMov@mHRChara@@QAE_NHMMM_N@Z]
	uint8_t mPlayMotionMov(int32_t arg2, float arg3, float arg4, float arg5, uint8_t arg6)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, float arg3, float arg4, float arg5, uint8_t arg6);
		_Func mFunc = (_Func)(GameModule + 0x46ff00);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestMotion(class mHRChara* const this, int32_t arg2) [?mTestMotion@mHRChara@@QAE_NH@Z]
	uint8_t mTestMotion(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x470000);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDifficultyMotionSpeed(class mHRChara* const this, float arg2) [?mSetDifficultyMotionSpeed@mHRChara@@QAEXM@Z]
	void mSetDifficultyMotionSpeed(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x470030);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* mHRChara::getCharaByGM2FileName(char const* arg1) [?getCharaByGM2FileName@mHRChara@@SAPAV1@PBD@Z]
	static class mHRChara* getCharaByGM2FileName(std::string arg1)
	{
		char const* arg1_c_str = arg1.c_str();
		typedef class mHRChara*(__fastcall* _Func)(char const* arg1);
		_Func mFunc = (_Func)(GameModule + 0x470040);
		return mFunc(arg1_c_str);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetDeath(class mHRChara* const this) [?mSetDeath@mHRChara@@QAEXXZ]
	void mSetDeath()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4700a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mDamageCallBackForScript(class mHRChara* const this, int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4, int32_t arg5) [?mDamageCallBackForScript@mHRChara@@QAEXH_NW4eDmgCallBackDmgType@@H@Z]
	void mDamageCallBackForScript(int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4, int32_t arg5)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4, int32_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x4700c0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetMotionPlay(class mHRChara* const this) [?mGetMotionPlay@mHRChara@@QAE_NXZ]
	uint8_t mGetMotionPlay()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x470140);
		return mFunc(this);
	}
	// [Function] class mHRChara* mHRChara::mGetAliveResourceCharaPtr(enum enCharaType arg1, uint32_t arg2) [?mGetAliveResourceCharaPtr@mHRChara@@SAPAV1@W4enCharaType@@I@Z]
	static class mHRChara* mGetAliveResourceCharaPtr(enum enCharaType arg1, uint32_t arg2)
	{
		typedef class mHRChara*(__fastcall* _Func)(enum enCharaType arg1, uint32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x470150);
		return mFunc(arg1, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::ReleaseCutmark(class mHRChara* const this) [?ReleaseCutmark@mHRChara@@QAE_NXZ]
	uint8_t ReleaseCutmark()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x470180);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestPiyori(class mHRChara* const this) [?mTestPiyori@mHRChara@@QBE_NXZ]
	uint8_t mTestPiyori()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x470260);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") mHRChara::mGetMotionTotalTick(class mHRChara* const this, int32_t arg2) [?mGetMotionTotalTick@mHRChara@@QAEIH@Z]
	uint32_t mGetMotionTotalTick(int32_t arg2)
	{
		typedef uint32_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x470270);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::setInterestPositionFromAI(class mHRChara* const this, struct Vec& arg2) [?setInterestPositionFromAI@mHRChara@@QAEXABUVec@@@Z]
	void setInterestPositionFromAI(struct Vec& arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec& arg2);
		_Func mFunc = (_Func)(GameModule + 0x4702f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::setInterestActFlagFromAI(class mHRChara* const this, uint8_t const arg2) [?setInterestActFlagFromAI@mHRChara@@QAEX_N@Z]
	void setInterestActFlagFromAI(uint8_t const arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t const arg2);
		_Func mFunc = (_Func)(GameModule + 0x470320);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mGetWepTopPos(class mHRChara* const this, struct Vec* arg2, enum enWepLeftRight arg3) [?mGetWepTopPos@mHRChara@@QAE_NPAUVec@@W4enWepLeftRight@@@Z]
	uint8_t mGetWepTopPos(struct Vec* arg2, enum enWepLeftRight arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec* arg2, enum enWepLeftRight arg3);
		_Func mFunc = (_Func)(GameModule + 0x470350);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mInitDamageStatus(class mHRChara* const this) [?mInitDamageStatus@mHRChara@@QAEXXZ]
	void mInitDamageStatus()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x470390);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPostFrameCommonProc1(class mHRChara* const this) [?mPostFrameCommonProc1@mHRChara@@UAE_NXZ]
	uint8_t mPostFrameCommonProc1()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x470450);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPostFrameCommonProc2(class mHRChara* const this) [?mPostFrameCommonProc2@mHRChara@@UAE_NXZ]
	uint8_t mPostFrameCommonProc2()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x470e10);
		return mFunc(this);
	}
	// [Function] class mot::CBoneEffectDamageData* __convention("thiscall") mHRChara::getBoneEffectDamageData(class mHRChara* const this) [?getBoneEffectDamageData@mHRChara@@IAEPAVCBoneEffectDamageData@mot@@XZ]
	class mot::CBoneEffectDamageData* getBoneEffectDamageData()
	{
		typedef class mot::CBoneEffectDamageData*(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x471850);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::SetKnockBack(class mHRChara* const this, float arg2, struct Vec& arg3, float arg4) [?SetKnockBack@mHRChara@@QAEXMABUVec@@M@Z]
	void SetKnockBack(float arg2, struct Vec& arg3, float arg4)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2, struct Vec& arg3, float arg4);
		_Func mFunc = (_Func)(GameModule + 0x471870);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::CheckWallCrashAndDamageProc(class mHRChara* const this, int32_t const arg2, int32_t const arg3) [?CheckWallCrashAndDamageProc@mHRChara@@QAE_NHH@Z]
	uint8_t CheckWallCrashAndDamageProc(int32_t const arg2, int32_t const arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t const arg2, int32_t const arg3);
		_Func mFunc = (_Func)(GameModule + 0x471ae0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mSetHpBarVisible(class mHRChara* const this, uint8_t arg2) [?mSetHpBarVisible@mHRChara@@QAE_N_N@Z]
	uint8_t mSetHpBarVisible(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x471db0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetPosA(class mHRChara* const this, struct Vec& arg2, uint32_t const arg3, int32_t const arg4) [?mSetPosA@mHRChara@@QAEXABUVec@@IH@Z]
	void mSetPosA(struct Vec& arg2, uint32_t const arg3, int32_t const arg4)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec& arg2, uint32_t const arg3, int32_t const arg4);
		_Func mFunc = (_Func)(GameModule + 0x471e10);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mSetSimpleHpBarVisible(class mHRChara* const this, uint8_t arg2) [?mSetSimpleHpBarVisible@mHRChara@@QAE_N_N@Z]
	uint8_t mSetSimpleHpBarVisible(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x471f20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mPlayCamMotFromCharMot(class mHRChara* const this, int32_t arg2, int32_t arg3, uint8_t arg4, uint8_t arg5, uint8_t arg6) [?mPlayCamMotFromCharMot@mHRChara@@QAEXHH_N00@Z]
	void mPlayCamMotFromCharMot(int32_t arg2, int32_t arg3, uint8_t arg4, uint8_t arg5, uint8_t arg6)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3, uint8_t arg4, uint8_t arg5, uint8_t arg6);
		_Func mFunc = (_Func)(GameModule + 0x471f80);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] void __convention("thiscall") mHRChara::checkDeleteBlackBodyEffect(class mHRChara* const this) [?checkDeleteBlackBodyEffect@mHRChara@@QAEXXZ]
	void checkDeleteBlackBodyEffect()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4722c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetHitCounter(class mHRChara* const this) [?mSetHitCounter@mHRChara@@QAEXXZ]
	void mSetHitCounter()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4722e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mReleaseBloodSplash(class mHRChara* const this, uint8_t arg2) [?mReleaseBloodSplash@mHRChara@@QAE_N_N@Z]
	uint8_t mReleaseBloodSplash(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x472310);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPreFrameProc(class mHRChara* const this) [?mPreFrameProc@mHRChara@@UAE_NXZ]
	uint8_t mPreFrameProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x472370);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPreRenderProc(class mHRChara* const this) [?mPreRenderProc@mHRChara@@UAE_NXZ]
	uint8_t mPreRenderProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x472510);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mDetouchMotionBrend(class mHRChara* const this) [?mDetouchMotionBrend@mHRChara@@QAEXXZ]
	void mDetouchMotionBrend()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x472540);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mReleaseDemoBtleIcn(class mHRChara* const this) [?mReleaseDemoBtleIcn@mHRChara@@QAEXXZ]
	void mReleaseDemoBtleIcn()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4725b0);
		return mFunc(this);
	}
	// [Function] uint8_t mHRChara::isThisCharaExist(class mHRChara* arg1) [?isThisCharaExist@mHRChara@@SA_NPBV1@@Z]
	static uint8_t isThisCharaExist(class mHRChara* arg1)
	{
		typedef uint8_t(__fastcall* _Func)(class mHRChara* arg1);
		_Func mFunc = (_Func)(GameModule + 0x4725d0);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRChara::mTermAllNpc() [?mTermAllNpc@mHRChara@@SA_NXZ]
	static uint8_t mTermAllNpc()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x472600);
		return mFunc();
	}
	// [Function] int32_t mHRChara::mGetPopZakoNum() [?mGetPopZakoNum@mHRChara@@SAHXZ]
	static int32_t mGetPopZakoNum()
	{
		typedef int32_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x472670);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::mDeleteDispChara(class mHRChara* const this) [?mDeleteDispChara@mHRChara@@QAEXXZ]
	void mDeleteDispChara()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4726a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetAiDef(class mHRChara* const this, int32_t arg2) [?mSetAiDef@mHRChara@@QAEXH@Z]
	void mSetAiDef(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4726d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::setFootShadowDrawFlag(class mHRChara* const this, uint8_t const arg2) [?setFootShadowDrawFlag@mHRChara@@QAEX_N@Z]
	void setFootShadowDrawFlag(uint8_t const arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t const arg2);
		_Func mFunc = (_Func)(GameModule + 0x4726f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t mHRChara::mFrameProcAll() [?mFrameProcAll@mHRChara@@SA_NXZ]
	static uint8_t mFrameProcAll()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x472810);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mRenderProcAll(uint8_t arg1) [?mRenderProcAll@mHRChara@@SA_N_N@Z]
	static uint8_t mRenderProcAll(uint8_t arg1)
	{
		typedef uint8_t(__fastcall* _Func)(uint8_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x472a40);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRChara::mPostRenderProcAll() [?mPostRenderProcAll@mHRChara@@SA_NXZ]
	static uint8_t mPostRenderProcAll()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x472ba0);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mTermAllNpcWithoutCmnObj() [?mTermAllNpcWithoutCmnObj@mHRChara@@SA_NXZ]
	static uint8_t mTermAllNpcWithoutCmnObj()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x472c10);
		return mFunc();
	}
	// [Function] uint8_t mHRChara::mTermAllEnemyNpc() [?mTermAllEnemyNpc@mHRChara@@SA_NXZ]
	static uint8_t mTermAllEnemyNpc()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x472c80);
		return mFunc();
	}
	// [Function] class mHRChara* mHRChara::mGetNpcTop() [?mGetNpcTop@mHRChara@@SAPAV1@XZ]
	static class mHRChara* mGetNpcTop()
	{
		typedef class mHRChara*(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x472cf0);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::SetFileName(class mHRChara* const this, char const* arg2) [?SetFileName@mHRChara@@QAEXPBD@Z]
	void SetFileName(std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, char const* arg2);
		_Func mFunc = (_Func)(GameModule + 0x473620);
		return mFunc(this, arg2_c_str);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMaxHp(class mHRChara* const this, float arg2) [?mSetMaxHp@mHRChara@@QAEXM@Z]
	void mSetMaxHp(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x473640);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTerm(class mHRChara* const this) [?mTerm@mHRChara@@UAE_NXZ]
	uint8_t mTerm()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x473660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetPos(class mHRChara* const this, struct Vec& arg2, uint8_t arg3, float arg4) [?mSetPos@mHRChara@@UAEXABUVec@@_NM@Z]
	void mSetPos(struct Vec& arg2, uint8_t arg3, float arg4)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec& arg2, uint8_t arg3, float arg4);
		_Func mFunc = (_Func)(GameModule + 0x473940);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetRot(class mHRChara* const this, struct Vec& arg2) [?mSetRot@mHRChara@@UAEXABUVec@@@Z]
	void mSetRot(struct Vec& arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec& arg2);
		_Func mFunc = (_Func)(GameModule + 0x473a30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetScale(class mHRChara* const this, struct Vec& arg2) [?mSetScale@mHRChara@@UAEXABUVec@@@Z]
	void mSetScale(struct Vec& arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec& arg2);
		_Func mFunc = (_Func)(GameModule + 0x473ac0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mHitCheck(class mHRChara* const this, class mHRChara* arg2) [?mHitCheck@mHRChara@@UAE_NPAV1@@Z]
	uint8_t mHitCheck(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x473b20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mMotionSpeedControl(class mHRChara* const this) [?mMotionSpeedControl@mHRChara@@QAEXXZ]
	void mMotionSpeedControl()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x473f60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mCallMotionProc(class mHRChara* const this) [?mCallMotionProc@mHRChara@@QAEXXZ]
	void mCallMotionProc()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x474290);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPlayMotion(class mHRChara* const this, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6) [?mPlayMotion@mHRChara@@UAE_NH_NH0M@Z]
	uint8_t mPlayMotion(int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6);
		_Func mFunc = (_Func)(GameModule + 0x474400);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] void __convention("thiscall") mHRChara::mCallMoneyDrop(class mHRChara* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mCallMoneyDrop@mHRChara@@QAEXH_N0@Z]
	void mCallMoneyDrop(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x474550);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mAttachWep(class mHRChara* const this, class TGmf* arg2, enum eUDLR arg3, char* arg4) [?mAttachWep@mHRChara@@UAE_NPAVTGmf@@W4eUDLR@@PAD@Z]
	uint8_t mAttachWep(class TGmf* arg2, enum eUDLR arg3, char* arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, class TGmf* arg2, enum eUDLR arg3, char* arg4);
		_Func mFunc = (_Func)(GameModule + 0x4745d0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mDetachWep(class mHRChara* const this, enum eUDLR arg2, char* arg3) [?mDetachWep@mHRChara@@UAE_NW4eUDLR@@PAD@Z]
	uint8_t mDetachWep(enum eUDLR arg2, char* arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, enum eUDLR arg2, char* arg3);
		_Func mFunc = (_Func)(GameModule + 0x474880);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mSemitransparentProcess(class mHRChara* const this) [?mSemitransparentProcess@mHRChara@@UAEXXZ]
	void mSemitransparentProcess()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x474980);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mUpdateAtkColl(class mHRChara* const this) [?mUpdateAtkColl@mHRChara@@UAEXXZ]
	void mUpdateAtkColl()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x474c50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mRenderShadowProc(class mHRChara* const this) [?mRenderShadowProc@mHRChara@@UAEXXZ]
	void mRenderShadowProc()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x474e50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mRefreshFloorPosition(class mHRChara* const this, float arg2, uint8_t arg3) [?mRefreshFloorPosition@mHRChara@@UAE_NM_N@Z]
	uint8_t mRefreshFloorPosition(float arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x474f70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mDamageProc(class mHRChara* const this) [?mDamageProc@mHRChara@@UAE_NXZ]
	uint8_t mDamageProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x475080);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mRestoreDamage(class mHRChara* const this, int32_t arg2, float arg3) [?mRestoreDamage@mHRChara@@UAEXHM@Z]
	void mRestoreDamage(int32_t arg2, float arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, float arg3);
		_Func mFunc = (_Func)(GameModule + 0x475090);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanAttack(class mHRChara* const this) [?mCheckCanAttack@mHRChara@@UAE_NXZ]
	uint8_t mCheckCanAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4750f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mGetTsubazeriaiPos(class mHRChara* const this, struct Vec* arg2) [?mGetTsubazeriaiPos@mHRChara@@UAEXPAUVec@@@Z]
	void mGetTsubazeriaiPos(struct Vec* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec* arg2);
		_Func mFunc = (_Func)(GameModule + 0x475100);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetPcTsubaOuterMot(class mHRChara* const this) [?mSetPcTsubaOuterMot@mHRChara@@UAEXXZ]
	void mSetPcTsubaOuterMot()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x475120);
		return mFunc(this);
	}
	// [Function] struct Vec __convention("thiscall") mHRChara::GetTsubaEffectPos(class mHRChara* const this) [?GetTsubaEffectPos@mHRChara@@UAE?AUVec@@XZ]
	struct Vec GetTsubaEffectPos()
	{
		typedef struct Vec(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x475140);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanCatch(class mHRChara* const this) [?mCheckCanCatch@mHRChara@@UAE_NXZ]
	uint8_t mCheckCanCatch()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x475270);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanThrow(class mHRChara* const this) [?mCheckCanThrow@mHRChara@@UAE_NXZ]
	uint8_t mCheckCanThrow()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x475280);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mPlayThrownMotion(class mHRChara* const this, int32_t arg2, int32_t arg3) [?mPlayThrownMotion@mHRChara@@UAEXHH@Z]
	void mPlayThrownMotion(int32_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x475290);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPlayMotionBlend(class mHRChara* const this, class TGan** arg2, char arg3) [?mPlayMotionBlend@mHRChara@@UAE_NPAPAVTGan@@C@Z]
	uint8_t mPlayMotionBlend(class TGan** arg2, char arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, class TGan** arg2, char arg3);
		_Func mFunc = (_Func)(GameModule + 0x4754e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mBossDeadCommonProcess(class mHRChara* const this) [?mBossDeadCommonProcess@mHRChara@@UAEXXZ]
	void mBossDeadCommonProcess()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4758f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckCanLockOn(class mHRChara* const this) [?mCheckCanLockOn@mHRChara@@UAE_NXZ]
	uint8_t mCheckCanLockOn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x475910);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::getLockOnCursorBasePosition(class mHRChara* const this, struct Vec* arg2) [?getLockOnCursorBasePosition@mHRChara@@UBE_NPAUVec@@@Z]
	uint8_t getLockOnCursorBasePosition(struct Vec* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec* arg2);
		_Func mFunc = (_Func)(GameModule + 0x475920);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetVisible(class mHRChara* const this, uint8_t arg2) [?mSetVisible@mHRChara@@UAEX_N@Z]
	void mSetVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x475a30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetWepVisible(class mHRChara* const this, uint8_t arg2) [?mSetWepVisible@mHRChara@@UAEX_N@Z]
	void mSetWepVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x475a60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetWepEffectVisible(class mHRChara* const this, uint8_t arg2) [?mSetWepEffectVisible@mHRChara@@UAEX_N@Z]
	void mSetWepEffectVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x475ae0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetVisibleDist(class mHRChara* const this, uint8_t arg2) [?mSetVisibleDist@mHRChara@@UAEX_N@Z]
	void mSetVisibleDist(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x475b90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mEffectInit(class mHRChara* const this) [?mEffectInit@mHRChara@@UAEXXZ]
	void mEffectInit()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x475bb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetMirrorModel(class mHRChara* const this, uint8_t arg2) [?mSetMirrorModel@mHRChara@@UAEX_N@Z]
	void mSetMirrorModel(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x475bc0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetAiAtk(class mHRChara* const this, int32_t arg2, int32_t arg3) [?mSetAiAtk@mHRChara@@UAEXHH@Z]
	void mSetAiAtk(int32_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x475c00);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mSetWarpPos(class mHRChara* const this, struct Vec& arg2, uint8_t arg3) [?mSetWarpPos@mHRChara@@UAEXABUVec@@_N@Z]
	void mSetWarpPos(struct Vec& arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, struct Vec& arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x475c40);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mHitCheckStage(class mHRChara* const this, class ghmGcCollObjCapsule* arg2, struct Vec* arg3, struct Vec* arg4, struct Vec* arg5, struct Vec* arg6, class ghmGcCollObj** arg7, class ghmGcCollObjHitResult** arg8, class ghmGcCollObjHitResultObj* arg9, struct WGclMaterialSpec** arg10, uint8_t* arg11, uint8_t arg12, float arg13) [?mHitCheckStage@mHRChara@@UAE_NPAVghmGcCollObjCapsule@@PAUVec@@111PAPAVghmGcCollObj@@PAPAVghmGcCollObjHitResult@@PAVghmGcCollObjHitResultObj@@PAPAUWGclMaterialSpec@@PA_N_NM@Z]
	uint8_t mHitCheckStage(class ghmGcCollObjCapsule* arg2, struct Vec* arg3, struct Vec* arg4, struct Vec* arg5, struct Vec* arg6, class ghmGcCollObj** arg7, class ghmGcCollObjHitResult** arg8, class ghmGcCollObjHitResultObj* arg9, struct WGclMaterialSpec** arg10, uint8_t* arg11, uint8_t arg12, float arg13)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, class ghmGcCollObjCapsule* arg2, struct Vec* arg3, struct Vec* arg4, struct Vec* arg5, struct Vec* arg6, class ghmGcCollObj** arg7, class ghmGcCollObjHitResult** arg8, class ghmGcCollObjHitResultObj* arg9, struct WGclMaterialSpec** arg10, uint8_t* arg11, uint8_t arg12, float arg13);
		_Func mFunc = (_Func)(GameModule + 0x475cc0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
	}
	// [Function] class TGan** __convention("thiscall") mHRChara::mppGetGan(class mHRChara* const this, int32_t arg2) [?mppGetGan@mHRChara@@UAEPAPAVTGan@@H@Z]
	// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
	void mppGetGan(int32_t arg2)
	{
		typedef class TGan**(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4779c0);
		mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mRequestBloodSplash(class mHRChara* const this, char* arg2, int32_t arg3) [?mRequestBloodSplash@mHRChara@@UAE_NPADH@Z]
	uint8_t mRequestBloodSplash(char* arg2, int32_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, char* arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x4779e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRChara::mCallKillPcProcess(class mHRChara* const this) [?mCallKillPcProcess@mHRChara@@UAEXXZ]
	void mCallKillPcProcess()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477a90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckComboing(class mHRChara* const this) [?mCheckComboing@mHRChara@@UAE_NXZ]
	uint8_t mCheckComboing()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477aa0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetAttackTableValue(class mHRChara* const this, int32_t arg2, int32_t arg3) [?mGetAttackTableValue@mHRChara@@UAEMHH@Z]
	float mGetAttackTableValue(int32_t arg2, int32_t arg3)
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x477ab0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] float __convention("thiscall") mHRChara::mGetAttackDirection(class mHRChara* const this) [?mGetAttackDirection@mHRChara@@UAEMXZ]
	float mGetAttackDirection()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477ac0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTestLowDmg(class mHRChara* const this) [?mTestLowDmg@mHRChara@@UAE_NXZ]
	uint8_t mTestLowDmg()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477ad0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCreatePiyori(class mHRChara* const this) [?mCreatePiyori@mHRChara@@UAE_NXZ]
	/// <summary>
	/// Creates a stun star effect above the character's head.
	/// </summary>
	uint8_t mCreatePiyori()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477ae0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mTermPiyori(class mHRChara* const this) [?mTermPiyori@mHRChara@@UAE_NXZ]
	uint8_t mTermPiyori()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477b50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mPiyoriProc(class mHRChara* const this) [?mPiyoriProc@mHRChara@@UAE_NXZ]
	uint8_t mPiyoriProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477b80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsMultiStep(class mHRChara* const this) [?IsMultiStep@mHRChara@@UAE_NXZ]
	uint8_t IsMultiStep()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477be0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::IsDownAttack(class mHRChara* const this) [?IsDownAttack@mHRChara@@UAE_NXZ]
	uint8_t IsDownAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477bf0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::getFootShadowWidthHalf(class mHRChara* const this) [?getFootShadowWidthHalf@mHRChara@@UBEMXZ]
	float getFootShadowWidthHalf()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477c00);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::getFootShadowDepthPlus(class mHRChara* const this) [?getFootShadowDepthPlus@mHRChara@@UBEMXZ]
	float getFootShadowDepthPlus()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477c10);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRChara::getFootShadowDepthMinus(class mHRChara* const this) [?getFootShadowDepthMinus@mHRChara@@UBEMXZ]
	float getFootShadowDepthMinus()
	{
		typedef float(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477c20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::OnStageUnload(class mHRChara* const this) [?OnStageUnload@mHRChara@@UAEXXZ]
	void OnStageUnload()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477c30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRChara::setFootGroundTouchActFlagFromAI(class mHRChara* const this, uint8_t const arg2) [?setFootGroundTouchActFlagFromAI@mHRChara@@QAEX_N@Z]
	void setFootGroundTouchActFlagFromAI(uint8_t const arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, uint8_t const arg2);
		_Func mFunc = (_Func)(GameModule + 0x477c60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRChara::mPlayCamMot(class mHRChara* const this, class TGan* arg2, int32_t arg3, uint8_t arg4, struct Vec* arg5, float* arg6, uint8_t arg7) [?mPlayCamMot@mHRChara@@QAEXPAVTGan@@H_NPAUVec@@PAM1@Z]
	void mPlayCamMot(class TGan* arg2, int32_t arg3, uint8_t arg4, struct Vec* arg5, float* arg6, uint8_t arg7)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, class TGan* arg2, int32_t arg3, uint8_t arg4, struct Vec* arg5, float* arg6, uint8_t arg7);
		_Func mFunc = (_Func)(GameModule + 0x477c90);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	// [Function] void __convention("thiscall") mHRChara::mStopCamMotFromCharMot(class mHRChara* const this) [?mStopCamMotFromCharMot@mHRChara@@QAEXXZ]
	void mStopCamMotFromCharMot()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x477e20);
		return mFunc(this);
	}
	// [Function] uint8_t mHRChara::mRenderShadowProcAll() [?mRenderShadowProcAll@mHRChara@@SA_NXZ]
	static uint8_t mRenderShadowProcAll()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x477e60);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRChara::mSetRotY(class mHRChara* const this, float arg2) [?mSetRotY@mHRChara@@QAEXM@Z]
	void mSetRotY(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x478050);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRChara::mCheckSegmentHitStage(class mHRChara* const this, int64_t arg2, int32_t, float arg4, uint8_t arg5, float* arg6, struct Vec* arg7) [?mCheckSegmentHitStage@mHRChara@@QAE_NUVec@@0M_NPAMPAU2@@Z]
	uint8_t mCheckSegmentHitStage(int64_t arg2, int32_t arg3, float arg4, uint8_t arg5, float* arg6, struct Vec* arg7)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRChara* const thisPtr, int64_t arg2, int32_t arg3, float arg4, uint8_t arg5, float* arg6, struct Vec* arg7);
		_Func mFunc = (_Func)(GameModule + 0x4780c0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	// [Function] void __convention("thiscall") mHRChara::mEraseDispChara(class mHRChara* const this) [?mEraseDispChara@mHRChara@@QAEXXZ]
	void mEraseDispChara()
	{
		typedef void(__thiscall* _Func)(class mHRChara* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x478340);
		return mFunc(this);
	}
	// [Function] class mHRChara* mHRChara::mAllSearchPiyoZako() [?mAllSearchPiyoZako@mHRChara@@SAPAV1@XZ]
	static class mHRChara* mAllSearchPiyoZako()
	{
		typedef class mHRChara*(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x4783a0);
		return mFunc();
	}
	// [Function] void mHRChara::OnStageUnloadAll() [?OnStageUnloadAll@mHRChara@@SAXXZ]
	static void OnStageUnloadAll()
	{
		typedef void(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x4783e0);
		return mFunc();
	}
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct stCharaStatus mStatus, offset 0x10>
	struct stCharaStatus mStatus;

	// <class stCharaFileData mResource, offset 0x3ac>
	class stCharaFileData mResource;

	// <struct stCharaEffect mEffect, offset 0x3e4>
	struct stCharaEffect mEffect;

	// <class CAmbientShadow m_inAmbientShadow, offset 0x508>
	class CAmbientShadow m_inAmbientShadow;

	// <class CStlVector<CStickShadow> m_ainFootShadow, offset 0x540>
	class std::vector<CStickShadow> m_ainFootShadow;

	// <enum enCharaInitProc mInitProc, offset 0x54c>
	enum enCharaInitProc mInitProc;

	// <class CharController* m_pCharController, offset 0x550>
	class CharController* m_pCharController;

	// <class ghmTriangle mWepColl, offset 0x554>
	class ghmTriangle mWepColl;

	// <int32_t motionInvincibilityFrames, offset 0x578>
	int32_t motionInvincibilityFrames;

	// <int32_t invincibileMotion, offset 0x57c>
	int32_t invincibileMotion;

	std::string ToString() const { return "class mHRChara(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<mHRChara, ghmListObj>("mHRChara")
			.addFunction("__tostring", &mHRChara::ToString)
			.addFunction("GetPtrAddr", &mHRChara::GetPtrAddr)
			.addProperty("mStatus", &mHRChara::mStatus)
			.addProperty("mResource", &mHRChara::mResource)
			.addProperty("mEffect", &mHRChara::mEffect)
			.addProperty("m_inAmbientShadow", &mHRChara::m_inAmbientShadow)
			.addProperty("m_ainFootShadow", &mHRChara::m_ainFootShadow)
			.addProperty("mInitProc", &mHRChara::mInitProc)
			.addProperty("m_pCharController", &mHRChara::m_pCharController)
			.addProperty("mWepColl", &mHRChara::mWepColl)
			.addProperty("motionInvincibilityFrames", &mHRChara::motionInvincibilityFrames)
			.addProperty("invincibileMotion", &mHRChara::invincibileMotion)
			.addFunction("mGetCharaType", &mHRChara::mGetCharaType)
			.addStaticFunction("isCharacterTypeZako", &mHRChara::isCharacterTypeZako)
			.addFunction("mTestZako", &mHRChara::mTestZako)
			.addStaticFunction("isCharacterTypeBoss", &mHRChara::isCharacterTypeBoss)
			.addFunction("mTestBoss", &mHRChara::mTestBoss)
			.addFunction("mTestEnemy", &mHRChara::mTestEnemy)
			.addFunction("mSetItemNo", &mHRChara::mSetItemNo)
			.addFunction("mSetLockOnNoCheckColl", &mHRChara::mSetLockOnNoCheckColl)
			.addFunction("mSetLockOnDistanceLow", &mHRChara::mSetLockOnDistanceLow)
			.addFunction("mSetLockOnDistanceHi", &mHRChara::mSetLockOnDistanceHi)
			.addFunction("mSetLockOnDistance", &mHRChara::mSetLockOnDistance)
			.addFunction("mSetCanLockOn", &mHRChara::mSetCanLockOn)
			.addFunction("mSetDisableDameged", &mHRChara::mSetDisableDameged)
			.addFunction("mGetDisableDameged", &mHRChara::mGetDisableDameged)
			.addFunction("mGetMaxHp", &mHRChara::mGetMaxHp)
			.addFunction("mUndispTgtIcn", &mHRChara::mUndispTgtIcn)
			.addFunction("mDispTgtIcn", &mHRChara::mDispTgtIcn)
			.addFunction("mGetHp", &mHRChara::mGetHp)
			.addFunction("mGetCondition", &mHRChara::mGetCondition)
			.addFunction("mGetNext", &mHRChara::mGetNext)
			.addFunction("mSetHp", &mHRChara::mSetHp)
			.addStaticFunction("mGetTop", &mHRChara::mGetTop)
			.addFunction("mGetRot", &mHRChara::mGetRot)
			.addFunction("mSetCharaPause", &mHRChara::mSetCharaPause)
			.addFunction("mGetRotY", &mHRChara::mGetRotY)
			.addFunction("GetGroundTouchMaterial", &mHRChara::GetGroundTouchMaterial)
			.addFunction("mGetStatusPtr", &mHRChara::mGetStatusPtr)
			.addFunction("mGetPos", &mHRChara::mGetPos)
			.addFunction("mGetMotionNo", &mHRChara::mGetMotionNo)
			.addFunction("mGetFileName", &mHRChara::mGetFileName)
			.addFunction("IsTubaAngleCorrect", &mHRChara::IsTubaAngleCorrect)
			.addFunction("getMiraretaiPosition", &mHRChara::getMiraretaiPosition)
			.addFunction("isHopeInterestMe", &mHRChara::isHopeInterestMe)
			.addFunction("IsWatchPc", &mHRChara::IsWatchPc)
			.addFunction("IsUseRotMov", &mHRChara::IsUseRotMov)
			.addFunction("getCurMotionName", &mHRChara::getCurMotionName)
			.addFunction("mTestRunMotion", &mHRChara::mTestRunMotion)
			.addFunction("mZakoDieOut", &mHRChara::mZakoDieOut)
			.addFunction("mCreateLoseSight", &mHRChara::mCreateLoseSight)
			.addFunction("mCheckDamageMotion", &mHRChara::mCheckDamageMotion)
			.addFunction("mCheckEnterMotion", &mHRChara::mCheckEnterMotion)
			.addFunction("mpGetGan", &mHRChara::mpGetGan)
			.addFunction("mGetCurResourceGmfPtr", &mHRChara::mGetCurResourceGmfPtr)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mGetCurResourceGmfPtr", &mHRChara::mGetCurResourceGmfPtr)
			.addFunction("mGetResourceGmfWepLPtr", &mHRChara::mGetResourceGmfWepLPtr)
			.addFunction("mGetResourceGmfWepRPtr", &mHRChara::mGetResourceGmfWepRPtr)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetResourceGmfPtr", &mHRChara::mSetResourceGmfPtr)
			.addFunction("mGetResourceGmfDeadPtr", &mHRChara::mGetResourceGmfDeadPtr)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mGetResourceGmfDeadPtr", &mHRChara::mGetResourceGmfDeadPtr)
			.addFunction("mGetResourceGmfPtr", &mHRChara::mGetResourceGmfPtr)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mGetResourceGmfPtr", &mHRChara::mGetResourceGmfPtr)
			.addFunction("mGetCollPtr", &mHRChara::mGetCollPtr)
			.addFunction("mSethitOidashiDisEnable", &mHRChara::mSethitOidashiDisEnable)
			.addFunction("mGetBrainPos", &mHRChara::mGetBrainPos)
			.addFunction("mGetHitPos", &mHRChara::mGetHitPos)
			.addFunction("mGetMirrorModel", &mHRChara::mGetMirrorModel)
			.addFunction("mGetVisibleDist", &mHRChara::mGetVisibleDist)
			.addFunction("mSetCondition", &mHRChara::mSetCondition)
			.addFunction("mSetSubMotionSpd", &mHRChara::mSetSubMotionSpd)
			.addFunction("mCheck4tsunbai", &mHRChara::mCheck4tsunbai)
			.addFunction("mCheckSquat", &mHRChara::mCheckSquat)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetThrowMotNo", &mHRChara::mGetThrowMotNo)
			.addFunction("mGetTsubazeriMotionID", &mHRChara::mGetTsubazeriMotionID)
			.addFunction("mTsubazeriDifficultyClear", &mHRChara::mTsubazeriDifficultyClear)
			.addFunction("mTsubazeriDifficultyUp", &mHRChara::mTsubazeriDifficultyUp)
			.addFunction("IsTubaPosAdjust", &mHRChara::IsTubaPosAdjust)
			.addFunction("mCheckGuard", &mHRChara::mCheckGuard)
			.addFunction("mCheckAttack", &mHRChara::mCheckAttack)
			.addFunction("mSubTension", &mHRChara::mSubTension)
			.addFunction("mAddTension", &mHRChara::mAddTension)
			.addFunction("mSetTension", &mHRChara::mSetTension)
			.addFunction("mResetTension", &mHRChara::mResetTension)
			.addFunction("mSetMovSpd", &mHRChara::mSetMovSpd)
			.addFunction("UnderControllAttack_A", &mHRChara::UnderControllAttack_A)
			.addFunction("UnderControllComboAttack", &mHRChara::UnderControllComboAttack)
			.addFunction("ExitUnderControl", &mHRChara::ExitUnderControl)
			.addFunction("EnterUnderControl", &mHRChara::EnterUnderControl)
			.addFunction("mPostRenderProc", &mHRChara::mPostRenderProc)
			.addFunction("getViewClipBoxPositionOffsetY", &mHRChara::getViewClipBoxPositionOffsetY)
			.addFunction("getViewClipBoxHalfLengthXYZ", &mHRChara::getViewClipBoxHalfLengthXYZ)
			.addFunction("mGetResNo", &mHRChara::mGetResNo)
			.addFunction("mGetDropMoney", &mHRChara::mGetDropMoney)
			.addFunction("mGetItemNo", &mHRChara::mGetItemNo)
			.addFunction("setLocatorNode", &mHRChara::setLocatorNode)
			.addFunction("mGetHpRate", &mHRChara::mGetHpRate)
			.addFunction("mSubHp", &mHRChara::mSubHp)
			.addFunction("mGetHitSize", &mHRChara::mGetHitSize)
			.addFunction("mGetInitProc", &mHRChara::mGetInitProc)
			.addFunction("isCrashBreak", &mHRChara::isCrashBreak)
			.addFunction("mSetCharaHit", &mHRChara::mSetCharaHit)
			.addFunction("mGetDmgAtkMot", &mHRChara::mGetDmgAtkMot)
			.addFunction("mSetMotionProcessDisEnable", &mHRChara::mSetMotionProcessDisEnable)
			.addFunction("mGetMotionSpd", &mHRChara::mGetMotionSpd)
			.addFunction("mSetStageHitDisEnable", &mHRChara::mSetStageHitDisEnable)
			.addFunction("IsFootShadowDraw", &mHRChara::IsFootShadowDraw)
			.addFunction("SetFootShadowDraw", &mHRChara::SetFootShadowDraw)
			.addFunction("mSetMotionNoNpc", &mHRChara::mSetMotionNoNpc)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetCallScriptProc", &mHRChara::mSetCallScriptProc)
			.addFunction("mSetDropMoney", &mHRChara::mSetDropMoney)
			.addFunction("mSetReactionDist", &mHRChara::mSetReactionDist)
			.addFunction("mSetEnterPattern", &mHRChara::mSetEnterPattern)
			.addFunction("mSetDatNo", &mHRChara::mSetDatNo)
			.addFunction("mSetResNo", &mHRChara::mSetResNo)
			.addFunction("mSetCharaType", &mHRChara::mSetCharaType)
			.addFunction("mGetDatNo", &mHRChara::mGetDatNo)
			.addFunction("mGetResourceDeleteFlag", &mHRChara::mGetResourceDeleteFlag)
			.addFunction("mGetDmgUpperPosY", &mHRChara::mGetDmgUpperPosY)
			.addFunction("mGetDmgUpper", &mHRChara::mGetDmgUpper)
			.addFunction("mSetResourceDeleteFlag", &mHRChara::mSetResourceDeleteFlag)
			.addFunction("getLatestGroundTouchPlane", &mHRChara::getLatestGroundTouchPlane)
			.addFunction("mUndispBtlIcn", &mHRChara::mUndispBtlIcn)
			.addFunction("mChgBtlIcnFinishDemo", &mHRChara::mChgBtlIcnFinishDemo)
			.addFunction("mChgBtlIcnTb", &mHRChara::mChgBtlIcnTb)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mChgBtlIcnFinishDemo", &mHRChara::mChgBtlIcnFinishDemo)
			.addFunction("SetDrawYAdjust", &mHRChara::SetDrawYAdjust)
			.addFunction("mSetDemoCtrl", &mHRChara::mSetDemoCtrl)
			.addFunction("mGetDemoCtrl", &mHRChara::mGetDemoCtrl)
			.addFunction("isAcceptDistanceDelete", &mHRChara::isAcceptDistanceDelete)
			.addFunction("mSetStageHitDisEnableReq", &mHRChara::mSetStageHitDisEnableReq)
			.addFunction("mGetEffectStPtr", &mHRChara::mGetEffectStPtr)
			.addFunction("setBlackBodyEffect", &mHRChara::setBlackBodyEffect)
			.addFunction("mGetNavelPos", &mHRChara::mGetNavelPos)
			.addFunction("mSetDamageAcceptFrame", &mHRChara::mSetDamageAcceptFrame)
			.addFunction("mSetAlwaysCheckHitColl", &mHRChara::mSetAlwaysCheckHitColl)
			.addFunction("mGetLockOnNoCheckColl", &mHRChara::mGetLockOnNoCheckColl)
			.addFunction("mGetLockOnDistanceLow", &mHRChara::mGetLockOnDistanceLow)
			.addFunction("mGetLockOnDistanceHi", &mHRChara::mGetLockOnDistanceHi)
			.addFunction("mGetLockOnDistance", &mHRChara::mGetLockOnDistance)
			.addFunction("mGetAliveBtlIcn", &mHRChara::mGetAliveBtlIcn)
			.addFunction("mChgBtlIcnFinish", &mHRChara::mChgBtlIcnFinish)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mChgBtlIcnFinish", &mHRChara::mChgBtlIcnFinish)
			.addFunction("mSetSlowBlow", &mHRChara::mSetSlowBlow)
			.addFunction("mSetInputFinishReq", &mHRChara::mSetInputFinishReq)
			.addFunction("mGetResourceGanPtr", &mHRChara::mGetResourceGanPtr)
			.addFunction("mGetMoney", &mHRChara::mGetMoney)
			.addFunction("mSetMoney", &mHRChara::mSetMoney)
			.addFunction("mGetInputFinishReq", &mHRChara::mGetInputFinishReq)
			.addFunction("mAddMoney", &mHRChara::mAddMoney)
			.addFunction("mSetInvincibleMotion", &mHRChara::mSetInvincibleMotion)
			.addFunction("mResetInvincibleMotion", &mHRChara::mResetInvincibleMotion)
			.addFunction("mCanGetHitByMotion", &mHRChara::mCanGetHitByMotion)
			.addFunction("mDispAtkHitIcn", &mHRChara::mDispAtkHitIcn)
			.addFunction("mGetDontStandUp", &mHRChara::mGetDontStandUp)
			.addFunction("GetTubaFrmOffset", &mHRChara::GetTubaFrmOffset)
			.addFunction("GetAtkDisAdjust", &mHRChara::GetAtkDisAdjust)
			.addFunction("mGetLoseTsubazeriFlag", &mHRChara::mGetLoseTsubazeriFlag)
			.addFunction("mSetSuccessThrow", &mHRChara::mSetSuccessThrow)
			.addFunction("mSetRotYA", &mHRChara::mSetRotYA)
			.addFunction("mSetDontStandUp", &mHRChara::mSetDontStandUp)
			.addFunction("mSetDmgGrav", &mHRChara::mSetDmgGrav)
			.addFunction("mChgBtlIcnSml", &mHRChara::mChgBtlIcnSml)
			.addFunction("mChgBtlIcnBig", &mHRChara::mChgBtlIcnBig)
			.addFunction("mGetCharaHit", &mHRChara::mGetCharaHit)
			.addFunction("mGetCanLockOn", &mHRChara::mGetCanLockOn)
			.addFunction("mGethitOidashiDisEnable", &mHRChara::mGethitOidashiDisEnable)
			.addFunction("mGetBtlIcnStatus", &mHRChara::mGetBtlIcnStatus)
			.addFunction("mGetWepVisible", &mHRChara::mGetWepVisible)
			.addFunction("mGetMotionBrendNum", &mHRChara::mGetMotionBrendNum)
			.addFunction("mGetAiValue", &mHRChara::mGetAiValue)
			.addFunction("mResetPosA", &mHRChara::mResetPosA)
			.addFunction("getEasyShadowProjectionPlane", &mHRChara::getEasyShadowProjectionPlane)
			.addFunction("isInterestTarget", &mHRChara::isInterestTarget)
			.addFunction("mSetMotionSpd", &mHRChara::mSetMotionSpd)
			.addFunction("mGetWepEffectVisible", &mHRChara::mGetWepEffectVisible)
			.addFunction("mGetVisible", &mHRChara::mGetVisible)
			.addFunction("mGetTension", &mHRChara::mGetTension)
			.addFunction("mGetMiniMapRender", &mHRChara::mGetMiniMapRender)
			.addFunction("mGetResourceRslPtr", &mHRChara::mGetResourceRslPtr)
			.addFunction("getFootNumber", &mHRChara::getFootNumber)
			.addFunction("mGetCallScriptProc", &mHRChara::mGetCallScriptProc)
			.addFunction("mGetMotionProcessDisEnable", &mHRChara::mGetMotionProcessDisEnable)
			.addFunction("IsBloom", &mHRChara::IsBloom)
			.addFunction("SetTermAll", &mHRChara::SetTermAll)
			.addFunction("SetKnockBackSpd", &mHRChara::SetKnockBackSpd)
			.addFunction("GetKnockBackSpd", &mHRChara::GetKnockBackSpd)
			.addFunction("mGetStageHitDisEnable", &mHRChara::mGetStageHitDisEnable)
			.addFunction("mGetStartSplitFlameFlag", &mHRChara::mGetStartSplitFlameFlag)
			.addFunction("getBoneEffectGmf", &mHRChara::getBoneEffectGmf)
			.addFunction("mSetStartSplitFlameFlag", &mHRChara::mSetStartSplitFlameFlag)
			.addFunction("mGetCharaPause", &mHRChara::mGetCharaPause)
			.addFunction("mGetBeforePos", &mHRChara::mGetBeforePos)
			.addFunction("mGetZakoWepType", &mHRChara::mGetZakoWepType)
			// Can't export & pointer 'class ghmGcCollObjHitResultObj&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetFootHitResultObj2", &mHRChara::mSetFootHitResultObj2)
			.addFunction("mSetDmgUpperPow", &mHRChara::mSetDmgUpperPow)
			.addFunction("mAddHp", &mHRChara::mAddHp)
			.addFunction("mGetSubMotionSpd", &mHRChara::mGetSubMotionSpd)
			.addFunction("mSetZakoWepType", &mHRChara::mSetZakoWepType)
			.addFunction("mSetHitSize", &mHRChara::mSetHitSize)
			.addFunction("mGetReactionDist", &mHRChara::mGetReactionDist)
			.addFunction("mSetMiniMapRender", &mHRChara::mSetMiniMapRender)
			.addFunction("GetKnockBackDir", &mHRChara::GetKnockBackDir)
			.addFunction("mGetMotionNoNpc", &mHRChara::mGetMotionNoNpc)
			.addFunction("SetNormalClip", &mHRChara::SetNormalClip)
			.addFunction("mGetOldPos", &mHRChara::mGetOldPos)
			.addFunction("mGetSuccessThrow", &mHRChara::mGetSuccessThrow)
			.addFunction("mSetDmgUpperPosY", &mHRChara::mSetDmgUpperPosY)
			.addFunction("SetDeleteReq", &mHRChara::SetDeleteReq)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("getShootPosiAndYaw", &mHRChara::getShootPosiAndYaw)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("setHomingPositionFromAI", &mHRChara::setHomingPositionFromAI)
			.addFunction("setHomingActFlagFromAI", &mHRChara::setHomingActFlagFromAI)
			.addFunction("isHoming", &mHRChara::isHoming)
			.addFunction("setInterestUseBoneNumFromAI", &mHRChara::setInterestUseBoneNumFromAI)
			.addFunction("isInteresting", &mHRChara::isInteresting)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("addDamageToYuremono", &mHRChara::addDamageToYuremono)
			.addFunction("getBoneEffect", &mHRChara::getBoneEffect)
			.addFunction("mSetHajikiCheck", &mHRChara::mSetHajikiCheck)
			.addFunction("mCheckDamageAccept", &mHRChara::mCheckDamageAccept)
			.addFunction("mTestZakoDown", &mHRChara::mTestZakoDown)
			.addFunction("mTestPiyoRequest", &mHRChara::mTestPiyoRequest)
			.addFunction("mGetPiyoriHeight", &mHRChara::mGetPiyoriHeight)
			.addStaticFunction("mGetCharaPtr", &mHRChara::mGetCharaPtr)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("mRenderGmf", &mHRChara::mRenderGmf)
			.addStaticFunction("debugDispCharaInfo", &mHRChara::debugDispCharaInfo)
			.addStaticFunction("mTermAllZakoMotion", &mHRChara::mTermAllZakoMotion)
			.addStaticFunction("mInitAllNpc", &mHRChara::mInitAllNpc)
			.addFunction("mCreateBloodSplash", &mHRChara::mCreateBloodSplash)
			.addFunction("mBloodSplashProc", &mHRChara::mBloodSplashProc)
			.addFunction("AddBoneElectPtrToList", &mHRChara::AddBoneElectPtrToList)
			.addFunction("ReleaseBoneElect", &mHRChara::ReleaseBoneElect)
			.addFunction("IsEmtpyBoneElectList", &mHRChara::IsEmtpyBoneElectList)
			.addFunction("DeleteBoneElectFromList", &mHRChara::DeleteBoneElectFromList)
			.addFunction("AddCutmarkPtrToList", &mHRChara::AddCutmarkPtrToList)
			.addFunction("IsEmtpyCutmarkList", &mHRChara::IsEmtpyCutmarkList)
			.addFunction("DeleteCutmarkFromList", &mHRChara::DeleteCutmarkFromList)
			.addFunction("SetPowerFlash", &mHRChara::SetPowerFlash)
			.addFunction("SetNoGuardEffect", &mHRChara::SetNoGuardEffect)
			.addStaticFunction("mCheckAtkAllNpc", &mHRChara::mCheckAtkAllNpc)
			.addStaticFunction("mCheckCanAtk", &mHRChara::mCheckCanAtk)
			.addFunction("mCallBeforeRenderProc", &mHRChara::mCallBeforeRenderProc)
			.addFunction("mCheckCanHit", &mHRChara::mCheckCanHit)
			.addFunction("CreateFootSmokeEffect", &mHRChara::CreateFootSmokeEffect)
			.addFunction("KnockBackProc", &mHRChara::KnockBackProc)
			.addFunction("GetKnockBackRatio", &mHRChara::GetKnockBackRatio)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &mHRChara::mSetDamage)
			.addFunction("mInitDamageMotInfo", &mHRChara::mInitDamageMotInfo)
			.addFunction("mChangeDefAi", &mHRChara::mChangeDefAi)
			.addFunction("mSetDefAI", &mHRChara::mSetDefAI)
			.addFunction("mCheckCallFrameProc", &mHRChara::mCheckCallFrameProc)
			.addFunction("IsNowUnderControl", &mHRChara::IsNowUnderControl)
			.addFunction("RegistUnderControlAtkFuncPtr", &mHRChara::RegistUnderControlAtkFuncPtr)
			// Can't export & pointer 'struct CharControlMotID&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("RegistUnderControlMotID", &mHRChara::RegistUnderControlMotID)
			.addFunction("SetUnderControlFlag", &mHRChara::SetUnderControlFlag)
			.addFunction("DrawDebugCollision", &mHRChara::DrawDebugCollision)
			.addFunction("mRenderProc", &mHRChara::mRenderProc)
			.addFunction("postSetupMatrix", &mHRChara::postSetupMatrix)
			.addFunction("preSetupMatrix", &mHRChara::preSetupMatrix)
			.addFunction("mFootSmokeEffect", &mHRChara::mFootSmokeEffect)
			.addFunction("mPosAnimationProc", &mHRChara::mPosAnimationProc)
			.addFunction("mPostFrameProc", &mHRChara::mPostFrameProc)
			.addFunction("mFrameProc", &mHRChara::mFrameProc)
			.addFunction("mInit", &mHRChara::mInit)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetRotA", &mHRChara::mSetRotA)
			.addFunction("mSetWepEffectVisibleInstant", &mHRChara::mSetWepEffectVisibleInstant)
			.addFunction("mSubFrameStop", &mHRChara::mSubFrameStop)
			.addFunction("mPlayMotionMov", &mHRChara::mPlayMotionMov)
			.addFunction("mTestMotion", &mHRChara::mTestMotion)
			.addFunction("mSetDifficultyMotionSpeed", &mHRChara::mSetDifficultyMotionSpeed)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("getCharaByGM2FileName", &mHRChara::getCharaByGM2FileName)
			.addFunction("mSetDeath", &mHRChara::mSetDeath)
			.addFunction("mDamageCallBackForScript", &mHRChara::mDamageCallBackForScript)
			.addFunction("mGetMotionPlay", &mHRChara::mGetMotionPlay)
			.addStaticFunction("mGetAliveResourceCharaPtr", &mHRChara::mGetAliveResourceCharaPtr)
			.addFunction("ReleaseCutmark", &mHRChara::ReleaseCutmark)
			.addFunction("mTestPiyori", &mHRChara::mTestPiyori)
			.addFunction("mGetMotionTotalTick", &mHRChara::mGetMotionTotalTick)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("setInterestPositionFromAI", &mHRChara::setInterestPositionFromAI)
			.addFunction("setInterestActFlagFromAI", &mHRChara::setInterestActFlagFromAI)
			.addFunction("mGetWepTopPos", &mHRChara::mGetWepTopPos)
			.addFunction("mInitDamageStatus", &mHRChara::mInitDamageStatus)
			.addFunction("mPostFrameCommonProc1", &mHRChara::mPostFrameCommonProc1)
			.addFunction("mPostFrameCommonProc2", &mHRChara::mPostFrameCommonProc2)
			.addFunction("getBoneEffectDamageData", &mHRChara::getBoneEffectDamageData)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetKnockBack", &mHRChara::SetKnockBack)
			.addFunction("CheckWallCrashAndDamageProc", &mHRChara::CheckWallCrashAndDamageProc)
			.addFunction("mSetHpBarVisible", &mHRChara::mSetHpBarVisible)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetPosA", &mHRChara::mSetPosA)
			.addFunction("mSetSimpleHpBarVisible", &mHRChara::mSetSimpleHpBarVisible)
			.addFunction("mPlayCamMotFromCharMot", &mHRChara::mPlayCamMotFromCharMot)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mPlayMotionMov", &mHRChara::mPlayMotionMov)
			.addFunction("checkDeleteBlackBodyEffect", &mHRChara::checkDeleteBlackBodyEffect)
			.addFunction("mSetHitCounter", &mHRChara::mSetHitCounter)
			.addFunction("mReleaseBloodSplash", &mHRChara::mReleaseBloodSplash)
			.addFunction("mPreFrameProc", &mHRChara::mPreFrameProc)
			.addFunction("mPreRenderProc", &mHRChara::mPreRenderProc)
			.addFunction("mDetouchMotionBrend", &mHRChara::mDetouchMotionBrend)
			.addFunction("mReleaseDemoBtleIcn", &mHRChara::mReleaseDemoBtleIcn)
			.addStaticFunction("isThisCharaExist", &mHRChara::isThisCharaExist)
			.addStaticFunction("mTermAllNpc", &mHRChara::mTermAllNpc)
			.addStaticFunction("mGetPopZakoNum", &mHRChara::mGetPopZakoNum)
			.addFunction("mDeleteDispChara", &mHRChara::mDeleteDispChara)
			.addFunction("mSetAiDef", &mHRChara::mSetAiDef)
			.addFunction("setFootShadowDrawFlag", &mHRChara::setFootShadowDrawFlag)
			.addStaticFunction("mFrameProcAll", &mHRChara::mFrameProcAll)
			.addStaticFunction("mRenderProcAll", &mHRChara::mRenderProcAll)
			.addStaticFunction("mPostRenderProcAll", &mHRChara::mPostRenderProcAll)
			.addStaticFunction("mTermAllNpcWithoutCmnObj", &mHRChara::mTermAllNpcWithoutCmnObj)
			.addStaticFunction("mTermAllEnemyNpc", &mHRChara::mTermAllEnemyNpc)
			.addStaticFunction("mGetNpcTop", &mHRChara::mGetNpcTop)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetFileName", &mHRChara::SetFileName)
			.addFunction("mSetMaxHp", &mHRChara::mSetMaxHp)
			.addFunction("mTerm", &mHRChara::mTerm)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetPos", &mHRChara::mSetPos)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetRot", &mHRChara::mSetRot)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetScale", &mHRChara::mSetScale)
			.addFunction("mHitCheck", &mHRChara::mHitCheck)
			.addFunction("mMotionSpeedControl", &mHRChara::mMotionSpeedControl)
			.addFunction("mCallMotionProc", &mHRChara::mCallMotionProc)
			.addFunction("mPlayMotion", &mHRChara::mPlayMotion)
			.addFunction("mCallMoneyDrop", &mHRChara::mCallMoneyDrop)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mAttachWep", &mHRChara::mAttachWep)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mDetachWep", &mHRChara::mDetachWep)
			.addFunction("mSemitransparentProcess", &mHRChara::mSemitransparentProcess)
			.addFunction("mUpdateAtkColl", &mHRChara::mUpdateAtkColl)
			.addFunction("mRenderShadowProc", &mHRChara::mRenderShadowProc)
			.addFunction("mRefreshFloorPosition", &mHRChara::mRefreshFloorPosition)
			.addFunction("mDamageProc", &mHRChara::mDamageProc)
			.addFunction("mRestoreDamage", &mHRChara::mRestoreDamage)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mCheckAttack", &mHRChara::mCheckAttack)
			.addFunction("mCheckCanAttack", &mHRChara::mCheckCanAttack)
			.addFunction("mGetTsubazeriaiPos", &mHRChara::mGetTsubazeriaiPos)
			.addFunction("mSetPcTsubaOuterMot", &mHRChara::mSetPcTsubaOuterMot)
			.addFunction("GetTsubaEffectPos", &mHRChara::GetTsubaEffectPos)
			.addFunction("mCheckCanCatch", &mHRChara::mCheckCanCatch)
			.addFunction("mCheckCanThrow", &mHRChara::mCheckCanThrow)
			.addFunction("mPlayThrownMotion", &mHRChara::mPlayThrownMotion)
			// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mPlayMotionBlend", &mHRChara::mPlayMotionBlend)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mPlayMotionBlend", &mHRChara::mPlayMotionBlend)
			.addFunction("mBossDeadCommonProcess", &mHRChara::mBossDeadCommonProcess)
			.addFunction("mCheckCanLockOn", &mHRChara::mCheckCanLockOn)
			.addFunction("getLockOnCursorBasePosition", &mHRChara::getLockOnCursorBasePosition)
			.addFunction("mSetVisible", &mHRChara::mSetVisible)
			.addFunction("mSetWepVisible", &mHRChara::mSetWepVisible)
			.addFunction("mSetWepEffectVisible", &mHRChara::mSetWepEffectVisible)
			.addFunction("mSetVisibleDist", &mHRChara::mSetVisibleDist)
			.addFunction("mEffectInit", &mHRChara::mEffectInit)
			.addFunction("mSetMirrorModel", &mHRChara::mSetMirrorModel)
			.addFunction("mSetAiAtk", &mHRChara::mSetAiAtk)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetWarpPos", &mHRChara::mSetWarpPos)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mHitCheckStage", &mHRChara::mHitCheckStage)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mpGetGan", &mHRChara::mpGetGan)
			.addFunction("mppGetGan", &mHRChara::mppGetGan)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mRequestBloodSplash", &mHRChara::mRequestBloodSplash)
			.addFunction("mCallKillPcProcess", &mHRChara::mCallKillPcProcess)
			.addFunction("mCheckComboing", &mHRChara::mCheckComboing)
			.addFunction("mGetAttackTableValue", &mHRChara::mGetAttackTableValue)
			.addFunction("mGetAttackDirection", &mHRChara::mGetAttackDirection)
			.addFunction("mTestLowDmg", &mHRChara::mTestLowDmg)
			.addFunction("mCreatePiyori", &mHRChara::mCreatePiyori)
			.addFunction("mTermPiyori", &mHRChara::mTermPiyori)
			.addFunction("mPiyoriProc", &mHRChara::mPiyoriProc)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mSetDamageAcceptFrame", &mHRChara::mSetDamageAcceptFrame)
			.addFunction("IsMultiStep", &mHRChara::IsMultiStep)
			.addFunction("IsDownAttack", &mHRChara::IsDownAttack)
			.addFunction("getFootShadowWidthHalf", &mHRChara::getFootShadowWidthHalf)
			.addFunction("getFootShadowDepthPlus", &mHRChara::getFootShadowDepthPlus)
			.addFunction("getFootShadowDepthMinus", &mHRChara::getFootShadowDepthMinus)
			.addFunction("OnStageUnload", &mHRChara::OnStageUnload)
			.addFunction("setFootGroundTouchActFlagFromAI", &mHRChara::setFootGroundTouchActFlagFromAI)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mPlayCamMot", &mHRChara::mPlayCamMot)
			.addFunction("mStopCamMotFromCharMot", &mHRChara::mStopCamMotFromCharMot)
			.addStaticFunction("mRenderShadowProcAll", &mHRChara::mRenderShadowProcAll)
			.addFunction("mSetRotY", &mHRChara::mSetRotY)
			// Can't export pointer to native type 'float*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mCheckSegmentHitStage", &mHRChara::mCheckSegmentHitStage)
			.addFunction("mEraseDispChara", &mHRChara::mEraseDispChara)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("mGetCharaPtr", &mHRChara::mGetCharaPtr)
			.addStaticFunction("mAllSearchPiyoZako", &mHRChara::mAllSearchPiyoZako)
			.addStaticFunction("OnStageUnloadAll", &mHRChara::OnStageUnloadAll)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRChara::mStatus) == 924, "expected mStatus to be size 924");
static_assert(sizeof(mHRChara::mResource) == 56, "expected mResource to be size 56");
static_assert(sizeof(mHRChara::mEffect) == 292, "expected mEffect to be size 292");
static_assert(sizeof(mHRChara::m_inAmbientShadow) == 56, "expected m_inAmbientShadow to be size 56");
static_assert(sizeof(mHRChara::m_ainFootShadow) == 12, "expected m_ainFootShadow to be size 12");
static_assert(sizeof(mHRChara::mInitProc) == 4, "expected mInitProc to be size 4");
static_assert(sizeof(mHRChara::m_pCharController) == 4, "expected m_pCharController to be size 4");
static_assert(sizeof(mHRChara::mWepColl) == 36, "expected mWepColl to be size 36");
static_assert(sizeof(mHRChara::motionInvincibilityFrames) == 4, "expected motionInvincibilityFrames to be size 4");
static_assert(sizeof(mHRChara::invincibileMotion) == 4, "expected invincibileMotion to be size 4");
static_assert(sizeof(mHRChara) == 1408, "expected class mHRChara to be size 1408");

// [Structure] class HROBJDummy
class HROBJDummy : public mHRChara
{
public:
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	std::string ToString() const { return "class HROBJDummy(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HROBJDummy, mHRChara>("HROBJDummy")
			.addFunction("__tostring", &HROBJDummy::ToString)
			.addFunction("GetPtrAddr", &HROBJDummy::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(HROBJDummy) == 1408, "expected class HROBJDummy to be size 1408");

// [Structure] struct stTiger
struct stTiger
{
public:
	/// Struct member variables

	// <uint8_t visible, offset 0x0>
	uint8_t visible;

	// <Unidentified data segment, offset 0x1>
private:
	char _UnidentifiedData1[3];

public:
	// <class TGmf* pGmf, offset 0x4>
	class TGmf* pGmf;

	// <class TGan* pGan[0x8], offset 0x8>
	class TGan* pGan[8];

	// <int32_t motNo, offset 0x28>
	int32_t motNo;

	// <char const* motName, offset 0x2c>
	char const* motName;

	// <uint8_t dispPc, offset 0x30>
	uint8_t dispPc;

	// <uint8_t dispTiger, offset 0x31>
	uint8_t dispTiger;

	// <Unidentified data segment, offset 0x32>
private:
	char _UnidentifiedData7[2];

public:
	// <struct Vec startPos, offset 0x34>
	struct Vec startPos;

	// <class CStlVector<CStickShadow> m_ainFootShadow, offset 0x40>
	class std::vector<CStickShadow> m_ainFootShadow;

	// <int32_t endFadeTick, offset 0x4c>
	int32_t endFadeTick;

	std::string ToString() const { return "struct stTiger(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stTiger>("stTiger")
			.addFunction("__tostring", &stTiger::ToString)
			.addFunction("GetPtrAddr", &stTiger::GetPtrAddr)
			.addProperty("visible", &stTiger::visible)
			.addProperty("pGmf", &stTiger::pGmf)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pGan", &stTiger::pGan)
			.addProperty("motNo", &stTiger::motNo)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("motName", &stTiger::motName)
			.addProperty("dispPc", &stTiger::dispPc)
			.addProperty("dispTiger", &stTiger::dispTiger)
			.addProperty("startPos", &stTiger::startPos)
			.addProperty("m_ainFootShadow", &stTiger::m_ainFootShadow)
			.addProperty("endFadeTick", &stTiger::endFadeTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(stTiger::visible) == 1, "expected visible to be size 1");
static_assert(sizeof(stTiger::pGmf) == 4, "expected pGmf to be size 4");
static_assert(sizeof(stTiger::pGan) == 32, "expected pGan to be size 32");
static_assert(sizeof(stTiger::motNo) == 4, "expected motNo to be size 4");
static_assert(sizeof(stTiger::motName) == 4, "expected motName to be size 4");
static_assert(sizeof(stTiger::dispPc) == 1, "expected dispPc to be size 1");
static_assert(sizeof(stTiger::dispTiger) == 1, "expected dispTiger to be size 1");
static_assert(sizeof(stTiger::startPos) == 12, "expected startPos to be size 12");
static_assert(sizeof(stTiger::m_ainFootShadow) == 12, "expected m_ainFootShadow to be size 12");
static_assert(sizeof(stTiger::endFadeTick) == 4, "expected endFadeTick to be size 4");
static_assert(sizeof(stTiger) == 80, "expected struct stTiger to be size 80");

// [Structure] struct stHugWalk
struct stHugWalk
{
public:
	/// Struct member variables

	// <class TGmf* pGmf, offset 0x0>
	class TGmf* pGmf;

	// <class TGan* pGan[0x6], offset 0x4>
	class TGan* pGan[6];

	// <int32_t motNo, offset 0x1c>
	int32_t motNo;

	std::string ToString() const { return "struct stHugWalk(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stHugWalk>("stHugWalk")
			.addFunction("__tostring", &stHugWalk::ToString)
			.addFunction("GetPtrAddr", &stHugWalk::GetPtrAddr)
			.addProperty("pGmf", &stHugWalk::pGmf)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pGan", &stHugWalk::pGan)
			.addProperty("motNo", &stHugWalk::motNo)
		.endClass();
	}
#endif
};
static_assert(sizeof(stHugWalk::pGmf) == 4, "expected pGmf to be size 4");
static_assert(sizeof(stHugWalk::pGan) == 24, "expected pGan to be size 24");
static_assert(sizeof(stHugWalk::motNo) == 4, "expected motNo to be size 4");
static_assert(sizeof(stHugWalk) == 32, "expected struct stHugWalk to be size 32");

// [Structure] struct stPcEffect
struct stPcEffect
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[656];
public:

	std::string ToString() const { return "struct stPcEffect(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcEffect>("stPcEffect")
			.addFunction("__tostring", &stPcEffect::ToString)
			.addFunction("GetPtrAddr", &stPcEffect::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcEffect) == 656, "expected struct stPcEffect to be size 656");

// enum enPcInputMode
enum enPcInputMode : uint32_t
{
	// <ePcInputIdle = 0x0>
	ePcInputIdle = 0,

	// <ePcInputCamera = 0x1>
	ePcInputCamera = 1,

	// <ePcInputMove = 0x2>
	ePcInputMove = 2,

	// <ePcInputBattleMove = 0x3>
	ePcInputBattleMove = 3,

	// <ePcInputBattleIdle = 0x4>
	ePcInputBattleIdle = 4,

	// <ePcInputBike = 0x5>
	ePcInputBike = 5,

	// <ePcInputMenu = 0x6>
	ePcInputMenu = 6,

	// <ePcInputDamage = 0x7>
	ePcInputDamage = 7,

	// <ePcInputTiger = 0x8>
	ePcInputTiger = 8,

	// <ePcInputJump = 0x9>
	ePcInputJump = 9,

	// <ePcInputDash = 0xa>
	ePcInputDash = 10,

	// <ePcInputDigHole = 0xb>
	ePcInputDigHole = 11,

	// <ePcInputWepChange = 0xc>
	ePcInputWepChange = 12,

	// <ePcInputDeadFukki = 0xd>
	ePcInputDeadFukki = 13,

	// <ePcInputMax = 0xe>
	ePcInputMax = 14

};

// enum enSeReadProc
enum enSeReadProc : uint32_t
{
	// <eSeRead = 0x0>
	eSeRead = 0,

	// <eSeReadWait = 0x1>
	eSeReadWait = 1,

	// <eSeReadMax = 0x2>
	eSeReadMax = 2

};

// [Structure] struct stPcSndData
struct stPcSndData
{
public:
	/// Struct member variables

	// <int32_t seHdlLightsavorReady, offset 0x0>
	int32_t seHdlLightsavorReady;

	// <float seVolLightsavorReady, offset 0x4>
	float seVolLightsavorReady;

	// <uint8_t seDontPlaySeAgainLSReady, offset 0x8>
	uint8_t seDontPlaySeAgainLSReady;

	// <Unidentified data segment, offset 0x9>
private:
	char _UnidentifiedData3[3];

public:
	// <int32_t seHdlSlow, offset 0xc>
	int32_t seHdlSlow;

	// <float oldBgmVol, offset 0x10>
	float oldBgmVol;

	// <int32_t oldBgmHdl, offset 0x14>
	int32_t oldBgmHdl;

	// <int32_t oldBgmNo, offset 0x18>
	int32_t oldBgmNo;

	// <int32_t nowBgmHdl, offset 0x1c>
	int32_t nowBgmHdl;

	// <enum enSeReadProc seReadProc, offset 0x20>
	enum enSeReadProc seReadProc;

	// <class WAnimF pitchBgm, offset 0x24>
	class WAnimF pitchBgm;

	// <uint32_t oldFinishBgmVol, offset 0x44>
	uint32_t oldFinishBgmVol;

	// <uint32_t oldFinishSeVol, offset 0x48>
	uint32_t oldFinishSeVol;

	// <int32_t seHdlCharge, offset 0x4c>
	int32_t seHdlCharge;

	// <class WAnimF pitchCharge, offset 0x50>
	class WAnimF pitchCharge;

	// <int32_t seHdlChargeMax, offset 0x70>
	int32_t seHdlChargeMax;

	// <class WAnimF pitchChargeMax, offset 0x74>
	class WAnimF pitchChargeMax;

	// <int32_t seHdlAlarm, offset 0x94>
	int32_t seHdlAlarm;

	// <int32_t seHdlTel, offset 0x98>
	int32_t seHdlTel;

	// <int32_t seHdlDsBreath, offset 0x9c>
	int32_t seHdlDsBreath;

	// <int32_t seHdlTsubazeri, offset 0xa0>
	int32_t seHdlTsubazeri;

	// <int32_t seHdlSNBElecDmg, offset 0xa4>
	int32_t seHdlSNBElecDmg;

	// <int32_t seHdlPoison, offset 0xa8>
	int32_t seHdlPoison;

	// <uint8_t playBackAttackSe, offset 0xac>
	uint8_t playBackAttackSe;

	// <uint8_t playBackAttackPullSe, offset 0xad>
	uint8_t playBackAttackPullSe;

	// <Unidentified data segment, offset 0xae>
private:
	char _UnidentifiedData[2];
public:

	std::string ToString() const { return "struct stPcSndData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcSndData>("stPcSndData")
			.addFunction("__tostring", &stPcSndData::ToString)
			.addFunction("GetPtrAddr", &stPcSndData::GetPtrAddr)
			.addProperty("seHdlLightsavorReady", &stPcSndData::seHdlLightsavorReady)
			.addProperty("seVolLightsavorReady", &stPcSndData::seVolLightsavorReady)
			.addProperty("seDontPlaySeAgainLSReady", &stPcSndData::seDontPlaySeAgainLSReady)
			.addProperty("seHdlSlow", &stPcSndData::seHdlSlow)
			.addProperty("oldBgmVol", &stPcSndData::oldBgmVol)
			.addProperty("oldBgmHdl", &stPcSndData::oldBgmHdl)
			.addProperty("oldBgmNo", &stPcSndData::oldBgmNo)
			.addProperty("nowBgmHdl", &stPcSndData::nowBgmHdl)
			.addProperty("seReadProc", &stPcSndData::seReadProc)
			.addProperty("pitchBgm", &stPcSndData::pitchBgm)
			.addProperty("oldFinishBgmVol", &stPcSndData::oldFinishBgmVol)
			.addProperty("oldFinishSeVol", &stPcSndData::oldFinishSeVol)
			.addProperty("seHdlCharge", &stPcSndData::seHdlCharge)
			.addProperty("pitchCharge", &stPcSndData::pitchCharge)
			.addProperty("seHdlChargeMax", &stPcSndData::seHdlChargeMax)
			.addProperty("pitchChargeMax", &stPcSndData::pitchChargeMax)
			.addProperty("seHdlAlarm", &stPcSndData::seHdlAlarm)
			.addProperty("seHdlTel", &stPcSndData::seHdlTel)
			.addProperty("seHdlDsBreath", &stPcSndData::seHdlDsBreath)
			.addProperty("seHdlTsubazeri", &stPcSndData::seHdlTsubazeri)
			.addProperty("seHdlSNBElecDmg", &stPcSndData::seHdlSNBElecDmg)
			.addProperty("seHdlPoison", &stPcSndData::seHdlPoison)
			.addProperty("playBackAttackSe", &stPcSndData::playBackAttackSe)
			.addProperty("playBackAttackPullSe", &stPcSndData::playBackAttackPullSe)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcSndData::seHdlLightsavorReady) == 4, "expected seHdlLightsavorReady to be size 4");
static_assert(sizeof(stPcSndData::seVolLightsavorReady) == 4, "expected seVolLightsavorReady to be size 4");
static_assert(sizeof(stPcSndData::seDontPlaySeAgainLSReady) == 1, "expected seDontPlaySeAgainLSReady to be size 1");
static_assert(sizeof(stPcSndData::seHdlSlow) == 4, "expected seHdlSlow to be size 4");
static_assert(sizeof(stPcSndData::oldBgmVol) == 4, "expected oldBgmVol to be size 4");
static_assert(sizeof(stPcSndData::oldBgmHdl) == 4, "expected oldBgmHdl to be size 4");
static_assert(sizeof(stPcSndData::oldBgmNo) == 4, "expected oldBgmNo to be size 4");
static_assert(sizeof(stPcSndData::nowBgmHdl) == 4, "expected nowBgmHdl to be size 4");
static_assert(sizeof(stPcSndData::seReadProc) == 4, "expected seReadProc to be size 4");
static_assert(sizeof(stPcSndData::pitchBgm) == 32, "expected pitchBgm to be size 32");
static_assert(sizeof(stPcSndData::oldFinishBgmVol) == 4, "expected oldFinishBgmVol to be size 4");
static_assert(sizeof(stPcSndData::oldFinishSeVol) == 4, "expected oldFinishSeVol to be size 4");
static_assert(sizeof(stPcSndData::seHdlCharge) == 4, "expected seHdlCharge to be size 4");
static_assert(sizeof(stPcSndData::pitchCharge) == 32, "expected pitchCharge to be size 32");
static_assert(sizeof(stPcSndData::seHdlChargeMax) == 4, "expected seHdlChargeMax to be size 4");
static_assert(sizeof(stPcSndData::pitchChargeMax) == 32, "expected pitchChargeMax to be size 32");
static_assert(sizeof(stPcSndData::seHdlAlarm) == 4, "expected seHdlAlarm to be size 4");
static_assert(sizeof(stPcSndData::seHdlTel) == 4, "expected seHdlTel to be size 4");
static_assert(sizeof(stPcSndData::seHdlDsBreath) == 4, "expected seHdlDsBreath to be size 4");
static_assert(sizeof(stPcSndData::seHdlTsubazeri) == 4, "expected seHdlTsubazeri to be size 4");
static_assert(sizeof(stPcSndData::seHdlSNBElecDmg) == 4, "expected seHdlSNBElecDmg to be size 4");
static_assert(sizeof(stPcSndData::seHdlPoison) == 4, "expected seHdlPoison to be size 4");
static_assert(sizeof(stPcSndData::playBackAttackSe) == 1, "expected playBackAttackSe to be size 1");
static_assert(sizeof(stPcSndData::playBackAttackPullSe) == 1, "expected playBackAttackPullSe to be size 1");
static_assert(sizeof(stPcSndData) == 176, "expected struct stPcSndData to be size 176");

// [Structure] struct stDarkSideInfo
struct stDarkSideInfo
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[52];
public:

	std::string ToString() const { return "struct stDarkSideInfo(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stDarkSideInfo>("stDarkSideInfo")
			.addFunction("__tostring", &stDarkSideInfo::ToString)
			.addFunction("GetPtrAddr", &stDarkSideInfo::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(stDarkSideInfo) == 52, "expected struct stDarkSideInfo to be size 52");

// [Structure] struct stPcSaveData
struct stPcSaveData
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[1636];
public:

	std::string ToString() const { return "struct stPcSaveData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcSaveData>("stPcSaveData")
			.addFunction("__tostring", &stPcSaveData::ToString)
			.addFunction("GetPtrAddr", &stPcSaveData::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcSaveData) == 1636, "expected struct stPcSaveData to be size 1636");

// [Structure] struct stMiniDemo
struct stMiniDemo
{
public:
	/// Struct member variables

	// <uint8_t play, offset 0x0>
	uint8_t play;

	// <uint8_t pauseStart, offset 0x1>
	uint8_t pauseStart;

	// <uint8_t fadeInPermission, offset 0x2>
	uint8_t fadeInPermission;

	// <Unidentified data segment, offset 0x3>
private:
	char _UnidentifiedData3[1];

public:
	// <int32_t warpWaitFrame, offset 0x4>
	int32_t warpWaitFrame;

	// <int32_t warpTargetIndex, offset 0x8>
	int32_t warpTargetIndex;

	std::string ToString() const { return "struct stMiniDemo(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stMiniDemo>("stMiniDemo")
			.addFunction("__tostring", &stMiniDemo::ToString)
			.addFunction("GetPtrAddr", &stMiniDemo::GetPtrAddr)
			.addProperty("play", &stMiniDemo::play)
			.addProperty("pauseStart", &stMiniDemo::pauseStart)
			.addProperty("fadeInPermission", &stMiniDemo::fadeInPermission)
			.addProperty("warpWaitFrame", &stMiniDemo::warpWaitFrame)
			.addProperty("warpTargetIndex", &stMiniDemo::warpTargetIndex)
		.endClass();
	}
#endif
};
static_assert(sizeof(stMiniDemo::play) == 1, "expected play to be size 1");
static_assert(sizeof(stMiniDemo::pauseStart) == 1, "expected pauseStart to be size 1");
static_assert(sizeof(stMiniDemo::fadeInPermission) == 1, "expected fadeInPermission to be size 1");
static_assert(sizeof(stMiniDemo::warpWaitFrame) == 4, "expected warpWaitFrame to be size 4");
static_assert(sizeof(stMiniDemo::warpTargetIndex) == 4, "expected warpTargetIndex to be size 4");
static_assert(sizeof(stMiniDemo) == 12, "expected struct stMiniDemo to be size 12");

// [Structure] struct stPcStatus
struct stPcStatus
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[2308];
public:

	std::string ToString() const { return "struct stPcStatus(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcStatus>("stPcStatus")
			.addFunction("__tostring", &stPcStatus::ToString)
			.addFunction("GetPtrAddr", &stPcStatus::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcStatus) == 2308, "expected struct stPcStatus to be size 2308");

// [Structure] class mHRPc
/// <summary>
/// Player character (Travis)
/// </summary>
class mHRPc : public mHRChara
{
public:
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetEventWalk(class mHRPc* const this) [?mGetEventWalk@mHRPc@@QAE_NXZ]
	uint8_t mGetEventWalk()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9ccd0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetDarkSideTick(class mHRPc* const this) [?mGetDarkSideTick@mHRPc@@QBEHXZ]
	int32_t mGetDarkSideTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9cce0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::isFireDarkSideModeActive(class mHRPc* const this) [?isFireDarkSideModeActive@mHRPc@@QAE_NXZ]
	uint8_t isFireDarkSideModeActive()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x9fbe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTsubaDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetTsubaDisEnable@mHRPc@@QAEX_N@Z]
	void mSetTsubaDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1b00);
		return mFunc(this, arg2);
	}
	// [Function] enum enPcInputMode __convention("thiscall") mHRPc::mGetInputMode(class mHRPc* const this) [?mGetInputMode@mHRPc@@QAE?AW4enPcInputMode@@XZ]
	enum enPcInputMode mGetInputMode()
	{
		typedef enum enPcInputMode(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1b10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPcMoney(class mHRPc* const this, int32_t arg2) [?mSetPcMoney@mHRPc@@QAEXH@Z]
	void mSetPcMoney(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1b20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSubPcMoney(class mHRPc* const this, int32_t arg2) [?mSubPcMoney@mHRPc@@QAEXH@Z]
	void mSubPcMoney(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1b50);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetPcMoney(class mHRPc* const this) [?mGetPcMoney@mHRPc@@QAEHXZ]
	int32_t mGetPcMoney()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1b90);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetEquipID(class mHRPc* const this, enum enEqKind arg2) [?mGetEquipID@mHRPc@@QAEHW4enEqKind@@@Z]
	int32_t mGetEquipID(enum enEqKind arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, enum enEqKind arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1ba0);
		return mFunc(this, arg2);
	}
	// [Function] class TGmf* __convention("thiscall") mHRPc::mGetEquipGmfPtr(class mHRPc* const this, enum enEqKind arg2) [?mGetEquipGmfPtr@mHRPc@@QAEPAVTGmf@@W4enEqKind@@@Z]
	class TGmf* mGetEquipGmfPtr(enum enEqKind arg2)
	{
		typedef class TGmf*(__thiscall* _Func)(class mHRPc* const thisPtr, enum enEqKind arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1bc0);
		return mFunc(this, arg2);
	}
	// [Function] class mHRBike* __convention("thiscall") mHRPc::mGetBikePtr(class mHRPc* const this) [?mGetBikePtr@mHRPc@@QAEPAVmHRBike@@XZ]
	class mHRBike* mGetBikePtr()
	{
		typedef class mHRBike*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1be0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBgmNo4Load(class mHRPc* const this, int32_t arg2) [?mSetBgmNo4Load@mHRPc@@QAEXH@Z]
	void mSetBgmNo4Load(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1bf0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDemoBattou(class mHRPc* const this) [?mCheckDemoBattou@mHRPc@@QAE_NXZ]
	uint8_t mCheckDemoBattou()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1c00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDemoNoutou(class mHRPc* const this) [?mCheckDemoNoutou@mHRPc@@QAE_NXZ]
	uint8_t mCheckDemoNoutou()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1c10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetThrowModeOnly(class mHRPc* const this, uint8_t arg2) [?mSetThrowModeOnly@mHRPc@@QAEX_N@Z]
	void mSetThrowModeOnly(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1c20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSlashModeOnly(class mHRPc* const this, uint8_t arg2) [?mSetSlashModeOnly@mHRPc@@QAEX_N@Z]
	void mSetSlashModeOnly(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1c30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCatchModeDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetCatchModeDisEnable@mHRPc@@QAEX_N@Z]
	void mSetCatchModeDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1c40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetFightTameDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetFightTameDisEnable@mHRPc@@QAEX_N@Z]
	void mSetFightTameDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1c50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSlashTameDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetSlashTameDisEnable@mHRPc@@QAEX_N@Z]
	void mSetSlashTameDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1c60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDownAttackDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetDownAttackDisEnable@mHRPc@@QAEX_N@Z]
	void mSetDownAttackDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1c70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDigDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetDigDisEnable@mHRPc@@QAEX_N@Z]
	void mSetDigDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1c80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDigDisEnable4SM(class mHRPc* const this) [?mGetDigDisEnable4SM@mHRPc@@QAE_NXZ]
	uint8_t mGetDigDisEnable4SM()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1c90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearSubMissionflag(class mHRPc* const this) [?mClearSubMissionflag@mHRPc@@QAEXXZ]
	void mClearSubMissionflag()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1ca0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSubMissionActivflag(class mHRPc* const this, int32_t arg2) [?mSetSubMissionActivflag@mHRPc@@QAEXH@Z]
	void mSetSubMissionActivflag(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1cb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSkillCatch(class mHRPc* const this, int32_t arg2) [?mSetSkillCatch@mHRPc@@QAEXH@Z]
	void mSetSkillCatch(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1cd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAtkMode(class mHRPc* const this, uint8_t arg2) [?mSetAtkMode@mHRPc@@QAEX_N@Z]
	void mSetAtkMode(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1cf0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAtkMode(class mHRPc* const this) [?mGetAtkMode@mHRPc@@QAE_NXZ]
	uint8_t mGetAtkMode()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1d00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetEqWepLaser(class mHRPc* const this) [?mGetEqWepLaser@mHRPc@@QAE_NXZ]
	uint8_t mGetEqWepLaser()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1d10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAlwaysEmptyBattery(class mHRPc* const this, uint8_t arg2) [?mSetAlwaysEmptyBattery@mHRPc@@QAEX_N@Z]
	void mSetAlwaysEmptyBattery(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1d20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCantChargeBattery(class mHRPc* const this, uint8_t arg2) [?mSetCantChargeBattery@mHRPc@@QAEX_N@Z]
	void mSetCantChargeBattery(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1d30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontSemitrans(class mHRPc* const this, uint8_t arg2) [?mSetDontSemitrans@mHRPc@@QAEX_N@Z]
	void mSetDontSemitrans(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1d40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCantCallBikeFlag(class mHRPc* const this, uint8_t arg2) [?mSetCantCallBikeFlag@mHRPc@@QAEX_N@Z]
	void mSetCantCallBikeFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1d50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLostBikeFlag(class mHRPc* const this, uint8_t arg2) [?mSetLostBikeFlag@mHRPc@@QAEX_N@Z]
	void mSetLostBikeFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1d60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetMaxCombo(class mHRPc* const this) [?mResetMaxCombo@mHRPc@@QAEXXZ]
	void mResetMaxCombo()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1d70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDigToolFlag(class mHRPc* const this) [?mGetDigToolFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetDigToolFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1d80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPuppetMode(class mHRPc* const this, uint8_t arg2) [?mSetPuppetMode@mHRPc@@QAEX_N@Z]
	void mSetPuppetMode(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1d90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetUseWeaponEffect(class mHRPc* const this, uint8_t arg2) [?mSetUseWeaponEffect@mHRPc@@QAEX_N@Z]
	void mSetUseWeaponEffect(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1da0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTodomePrepareMode(class mHRPc* const this) [?mGetTodomePrepareMode@mHRPc@@QAE_NXZ]
	uint8_t mGetTodomePrepareMode()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1db0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearTodomePrepareMode(class mHRPc* const this) [?mClearTodomePrepareMode@mHRPc@@QAEXXZ]
	void mClearTodomePrepareMode()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1dc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetThrowPrepareMode(class mHRPc* const this) [?mGetThrowPrepareMode@mHRPc@@QAE_NXZ]
	uint8_t mGetThrowPrepareMode()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1dd0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetThrowInputResult(class mHRPc* const this) [?mGetThrowInputResult@mHRPc@@QAEHXZ]
	int32_t mGetThrowInputResult()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1de0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetShadowDepth(class mHRPc* const this, uint8_t arg2) [?mSetShadowDepth@mHRPc@@QAEXE@Z]
	void mSetShadowDepth(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1df0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanSlotCry(class mHRPc* const this, uint8_t arg2) [?mSetBanSlotCry@mHRPc@@QAEX_N@Z]
	void mSetBanSlotCry(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanSlotBel(class mHRPc* const this, uint8_t arg2) [?mSetBanSlotBel@mHRPc@@QAEX_N@Z]
	void mSetBanSlotBel(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanSlotBar(class mHRPc* const this, uint8_t arg2) [?mSetBanSlotBar@mHRPc@@QAEX_N@Z]
	void mSetBanSlotBar(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanSlot777(class mHRPc* const this, uint8_t arg2) [?mSetBanSlot777@mHRPc@@QAEX_N@Z]
	void mSetBanSlot777(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDeadSubmission(class mHRPc* const this, uint8_t arg2) [?mSetDeadSubmission@mHRPc@@QAEX_N@Z]
	void mSetDeadSubmission(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontSubBattery(class mHRPc* const this, uint8_t arg2) [?mSetDontSubBattery@mHRPc@@QAEX_N@Z]
	void mSetDontSubBattery(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAutoSubBatteryDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetAutoSubBatteryDisEnable@mHRPc@@QAEX_N@Z]
	void mSetAutoSubBatteryDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetJustGuardDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetJustGuardDisEnable@mHRPc@@QAEX_N@Z]
	void mSetJustGuardDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e70);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDashAtkDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetDashAtkDisEnable@mHRPc@@QAEX_N@Z]
	void mSetDashAtkDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetJustEscapeDisEnable(class mHRPc* const this, uint8_t arg2) [?mSetJustEscapeDisEnable@mHRPc@@QAEX_N@Z]
	void mSetJustEscapeDisEnable(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1e90);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetTsubaNpc(class mHRPc* const this) [?mGetTsubaNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mGetTsubaNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1ea0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOperate(class mHRPc* const this, uint8_t arg2) [?mSetOperate@mHRPc@@QAEX_N@Z]
	void mSetOperate(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1eb0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetOperate(class mHRPc* const this) [?mGetOperate@mHRPc@@QBE_NXZ]
	uint8_t mGetOperate()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1ec0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCameraOperate(class mHRPc* const this, uint8_t arg2) [?mSetCameraOperate@mHRPc@@QAEX_N@Z]
	void mSetCameraOperate(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1ed0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckStageChangeTermEnd(class mHRPc* const this) [?mCheckStageChangeTermEnd@mHRPc@@QAE_NXZ]
	uint8_t mCheckStageChangeTermEnd()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1ee0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDeadFlag(class mHRPc* const this) [?mGetDeadFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetDeadFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1ef0);
		return mFunc(this);
	}
	// [Function] struct HRSAVEDATA_DEBUNEKO* __convention("thiscall") mHRPc::mGetDebuNekoDataPtr(class mHRPc* const this) [?mGetDebuNekoDataPtr@mHRPc@@QAEPAUHRSAVEDATA_DEBUNEKO@@XZ]
	struct HRSAVEDATA_DEBUNEKO* mGetDebuNekoDataPtr()
	{
		typedef struct HRSAVEDATA_DEBUNEKO*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1f00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPauseAllFlag(class mHRPc* const this, uint8_t arg2) [?mSetPauseAllFlag@mHRPc@@QAEX_N@Z]
	void mSetPauseAllFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1f10);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCancelSetPadOffset(class mHRPc* const this, uint8_t arg2) [?mSetCancelSetPadOffset@mHRPc@@QAEX_N@Z]
	void mSetCancelSetPadOffset(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1f20);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetChangeEquipFromScript(class mHRPc* const this, uint8_t arg2) [?mSetChangeEquipFromScript@mHRPc@@QAEX_N@Z]
	void mSetChangeEquipFromScript(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1f30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetForceLoseTsubazeri(class mHRPc* const this, uint8_t arg2) [?mSetForceLoseTsubazeri@mHRPc@@QAEX_N@Z]
	void mSetForceLoseTsubazeri(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa1f40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDeadFukki(class mHRPc* const this) [?mCheckDeadFukki@mHRPc@@QAE_NXZ]
	uint8_t mCheckDeadFukki()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa1f50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionFromDatPtrExt(class mHRPc* const this, class TGan* arg2, char const* arg3, uint8_t arg4, int32_t arg5, uint8_t arg6, float arg7) [?mPlayMotionFromDatPtrExt@mHRPc@@QAE_NPAVTGan@@PBD_NH2M@Z]
	uint8_t mPlayMotionFromDatPtrExt(class TGan* arg2, std::string arg3, uint8_t arg4, int32_t arg5, uint8_t arg6, float arg7)
	{
		char const* arg3_c_str = arg3.c_str();
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class TGan* arg2, char const* arg3, uint8_t arg4, int32_t arg5, uint8_t arg6, float arg7);
		_Func mFunc = (_Func)(GameModule + 0xa32a0);
		return mFunc(this, arg2, arg3_c_str, arg4, arg5, arg6, arg7);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPcPower(class mHRPc* const this, float arg2) [?mSetPcPower@mHRPc@@QAEXM@Z]
	void mSetPcPower(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xa32f0);
		return mFunc(this, arg2);
	}
	// [Function] struct tagGHMR_TEX* __convention("thiscall") mHRPc::mGetEquipTexPtr(class mHRPc* const this, enum enEqKind arg2) [?mGetEquipTexPtr@mHRPc@@QAEPAUtagGHMR_TEX@@W4enEqKind@@@Z]
	struct tagGHMR_TEX* mGetEquipTexPtr(enum enEqKind arg2)
	{
		typedef struct tagGHMR_TEX*(__thiscall* _Func)(class mHRPc* const thisPtr, enum enEqKind arg2);
		_Func mFunc = (_Func)(GameModule + 0xa3300);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetRestartBGM(class mHRPc* const this) [?mSetRestartBGM@mHRPc@@QAEXXZ]
	void mSetRestartBGM()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3310);
		return mFunc(this);
	}
	// [Function] union uniSMflag* __convention("thiscall") mHRPc::mGetSubMissionflag(class mHRPc* const this) [?mGetSubMissionflag@mHRPc@@QAEPATuniSMflag@@XZ]
	union uniSMflag* mGetSubMissionflag()
	{
		typedef union uniSMflag*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3320);
		return mFunc(this);
	}
	// [Function] void mHRPc::mSetDisplayMiniMapFlag(uint8_t arg1) [?mSetDisplayMiniMapFlag@mHRPc@@SAX_N@Z]
	static void mSetDisplayMiniMapFlag(uint8_t arg1)
	{
		typedef void(__fastcall* _Func)(uint8_t arg1);
		_Func mFunc = (_Func)(GameModule + 0xa3330);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRPc::mGetDisplayMiniMapFlag() [?mGetDisplayMiniMapFlag@mHRPc@@SA_NXZ]
	static uint8_t mGetDisplayMiniMapFlag()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0xa3340);
		return mFunc();
	}
	// [Function] void mHRPc::mSetCameraXReverseControlFlag(uint8_t arg1) [?mSetCameraXReverseControlFlag@mHRPc@@SAX_N@Z]
	static void mSetCameraXReverseControlFlag(uint8_t arg1)
	{
		typedef void(__fastcall* _Func)(uint8_t arg1);
		_Func mFunc = (_Func)(GameModule + 0xa3350);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRPc::mGetCameraXReverseControlFlag() [?mGetCameraXReverseControlFlag@mHRPc@@SA_NXZ]
	static uint8_t mGetCameraXReverseControlFlag()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0xa3360);
		return mFunc();
	}
	// [Function] void mHRPc::mSetCameraYReverseControlFlag(uint8_t arg1) [?mSetCameraYReverseControlFlag@mHRPc@@SAX_N@Z]
	static void mSetCameraYReverseControlFlag(uint8_t arg1)
	{
		typedef void(__fastcall* _Func)(uint8_t arg1);
		_Func mFunc = (_Func)(GameModule + 0xa3370);
		return mFunc(arg1);
	}
	// [Function] uint8_t mHRPc::mGetCameraYReverseControlFlag() [?mGetCameraYReverseControlFlag@mHRPc@@SA_NXZ]
	static uint8_t mGetCameraYReverseControlFlag()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0xa3380);
		return mFunc();
	}
	// [Function] void __convention("thiscall") mHRPc::mAddClearNum(class mHRPc* const this) [?mAddClearNum@mHRPc@@QAEXXZ]
	void mAddClearNum()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa3390);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDeadSubmission(class mHRPc* const this) [?mGetDeadSubmission@mHRPc@@QAE_NXZ]
	uint8_t mGetDeadSubmission()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa33a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckStatusMenuDisp(class mHRPc* const this) [?mCheckStatusMenuDisp@mHRPc@@QAE_NXZ]
	uint8_t mCheckStatusMenuDisp()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa4740);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetMotionNo(class mHRPc* const this, int32_t arg2) [?mSetMotionNo@mHRPc@@QAEXH@Z]
	void mSetMotionNo(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa51b0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAtkPauseTime(class mHRPc* const this) [?mGetAtkPauseTime@mHRPc@@QAEHXZ]
	int32_t mGetAtkPauseTime()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa51c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDecAtkPauseTime(class mHRPc* const this) [?mDecAtkPauseTime@mHRPc@@QAEXXZ]
	void mDecAtkPauseTime()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa51e0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetWait1Frame(class mHRPc* const this) [?mGetWait1Frame@mHRPc@@QAEHXZ]
	int32_t mGetWait1Frame()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5200);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDecWait1Frame(class mHRPc* const this) [?mDecWait1Frame@mHRPc@@QAEXXZ]
	void mDecWait1Frame()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5210);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestPlayMiniDemoForSantDestroy(class mHRPc* const this) [?mTestPlayMiniDemoForSantDestroy@mHRPc@@QAE_NXZ]
	uint8_t mTestPlayMiniDemoForSantDestroy()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5220);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetHugWalk(class mHRPc* const this) [?mGetHugWalk@mHRPc@@QAE_NXZ]
	uint8_t mGetHugWalk()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5230);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetReceiveDamage(class mHRPc* const this) [?mResetReceiveDamage@mHRPc@@QAEXXZ]
	void mResetReceiveDamage()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5240);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBikeSight(class mHRPc* const this) [?mGetBikeSight@mHRPc@@QAEEXZ]
	uint8_t mGetBikeSight()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5250);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDontChangeBikeCamera(class mHRPc* const this) [?mGetDontChangeBikeCamera@mHRPc@@QAE_NXZ]
	uint8_t mGetDontChangeBikeCamera()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5260);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCameraOperate(class mHRPc* const this) [?mGetCameraOperate@mHRPc@@QAE_NXZ]
	uint8_t mGetCameraOperate()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5270);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPauseAllFlag(class mHRPc* const this) [?mGetPauseAllFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetPauseAllFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5280);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::isBeginFinishAttack(class mHRPc* const this) [?isBeginFinishAttack@mHRPc@@QBE_NXZ]
	uint8_t isBeginFinishAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa5cd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestTiger(class mHRPc* const this) [?mTestTiger@mHRPc@@QAE_NXZ]
	uint8_t mTestTiger()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa95b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetMenuDisEnableFrame(class mHRPc* const this, int32_t arg2) [?mSetMenuDisEnableFrame@mHRPc@@QAEXH@Z]
	void mSetMenuDisEnableFrame(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa95c0);
		return mFunc(this, arg2);
	}
	// [Function] enum enShakeDir __convention("thiscall") mHRPc::mGetNeedShakeDir(class mHRPc* const this) [?mGetNeedShakeDir@mHRPc@@QAE?AW4enShakeDir@@XZ]
	enum enShakeDir mGetNeedShakeDir()
	{
		typedef enum enShakeDir(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa9fc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepMotionNo(class mHRPc* const this, int32_t arg2) [?mSetWepMotionNo@mHRPc@@QAEXH@Z]
	void mSetWepMotionNo(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa9fd0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetWepMotionNo(class mHRPc* const this) [?mGetWepMotionNo@mHRPc@@QAEHXZ]
	int32_t mGetWepMotionNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xa9fe0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBikeVisible(class mHRPc* const this, uint8_t arg2) [?mSetBikeVisible@mHRPc@@QAEX_N@Z]
	void mSetBikeVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xa9ff0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetNowBuf(class mHRPc* const this, int32_t arg2) [?mGetNowBuf@mHRPc@@QAEHH@Z]
	int32_t mGetNowBuf(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa000);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetTexNowBuf(class mHRPc* const this, int32_t arg2) [?mGetTexNowBuf@mHRPc@@QAEHH@Z]
	int32_t mGetTexNowBuf(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa020);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckSNBElecDamage(class mHRPc* const this) [?mCheckSNBElecDamage@mHRPc@@QAE_NXZ]
	uint8_t mCheckSNBElecDamage()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa040);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckIntoTsubazeriai(class mHRPc* const this) [?mCheckIntoTsubazeriai@mHRPc@@UAE_NXZ]
	uint8_t mCheckIntoTsubazeriai()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa050);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayMotTsubaszeriai(class mHRPc* const this) [?mPlayMotTsubaszeriai@mHRPc@@UAEXXZ]
	void mPlayMotTsubaszeriai()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa060);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTsubazeriai(class mHRPc* const this) [?mCheckTsubazeriai@mHRPc@@UAE_NXZ]
	uint8_t mCheckTsubazeriai()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa070);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mWinTsubazeriai(class mHRPc* const this) [?mWinTsubazeriai@mHRPc@@UAEXXZ]
	void mWinTsubazeriai()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa080);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mLoseTsubazeriai(class mHRPc* const this) [?mLoseTsubazeriai@mHRPc@@UAEXXZ]
	void mLoseTsubazeriai()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa090);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTsubaOuterMotion(class mHRPc* const this) [?mGetTsubaOuterMotion@mHRPc@@QAE_NXZ]
	uint8_t mGetTsubaOuterMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa0a0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetTsubaOuterMotionNo(class mHRPc* const this) [?mGetTsubaOuterMotionNo@mHRPc@@QAEHXZ]
	int32_t mGetTsubaOuterMotionNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa0b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTsubaDisEnable(class mHRPc* const this) [?mGetTsubaDisEnable@mHRPc@@QAE_NXZ]
	uint8_t mGetTsubaDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa0c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTsubaEffectVisible(class mHRPc* const this, uint8_t arg2) [?mSetTsubaEffectVisible@mHRPc@@QAEX_N@Z]
	void mSetTsubaEffectVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa0d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTsubaEffectVisible(class mHRPc* const this) [?mGetTsubaEffectVisible@mHRPc@@QAE_NXZ]
	uint8_t mGetTsubaEffectVisible()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa0e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLockOn(class mHRPc* const this) [?mCheckLockOn@mHRPc@@QAE_NXZ]
	uint8_t mCheckLockOn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa0f0);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetLockOnNpc(class mHRPc* const this) [?mGetLockOnNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mGetLockOnNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa100);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAtkPauseTime(class mHRPc* const this, int32_t arg2) [?mSetAtkPauseTime@mHRPc@@QAEXH@Z]
	void mSetAtkPauseTime(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa110);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCmbKind(class mHRPc* const this, enum enPcCmbKind arg2) [?mSetCmbKind@mHRPc@@QAEXW4enPcCmbKind@@@Z]
	void mSetCmbKind(enum enPcCmbKind arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, enum enPcCmbKind arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa130);
		return mFunc(this, arg2);
	}
	// [Function] enum enPcCmbKind __convention("thiscall") mHRPc::mGetCmbKind(class mHRPc* const this) [?mGetCmbKind@mHRPc@@QAE?AW4enPcCmbKind@@XZ]
	enum enPcCmbKind mGetCmbKind()
	{
		typedef enum enPcCmbKind(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa140);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetLockOnThroughWall(class mHRPc* const this) [?mGetLockOnThroughWall@mHRPc@@QAE_NXZ]
	uint8_t mGetLockOnThroughWall()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa150);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetThrowModeOnly(class mHRPc* const this) [?mGetThrowModeOnly@mHRPc@@QAE_NXZ]
	uint8_t mGetThrowModeOnly()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa160);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCatchModeDisEnable(class mHRPc* const this) [?mGetCatchModeDisEnable@mHRPc@@QAE_NXZ]
	uint8_t mGetCatchModeDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa170);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDownAttackDisEnable(class mHRPc* const this) [?mGetDownAttackDisEnable@mHRPc@@QAE_NXZ]
	uint8_t mGetDownAttackDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa180);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDigDisEnable(class mHRPc* const this) [?mGetDigDisEnable@mHRPc@@QAE_NXZ]
	uint8_t mGetDigDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa190);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDigDisEnable4SM(class mHRPc* const this, uint8_t arg2) [?mSetDigDisEnable4SM@mHRPc@@QAEX_N@Z]
	void mSetDigDisEnable4SM(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa1a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetSkillCatch(class mHRPc* const this, int32_t arg2) [?mGetSkillCatch@mHRPc@@QAE_NH@Z]
	uint8_t mGetSkillCatch(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa1b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSkillK7(class mHRPc* const this, int32_t arg2) [?mSetSkillK7@mHRPc@@QAEXH@Z]
	void mSetSkillK7(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa1d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetSkillK7(class mHRPc* const this, int32_t arg2) [?mGetSkillK7@mHRPc@@QAE_NH@Z]
	uint8_t mGetSkillK7(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa1f0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPcBtlPose(class mHRPc* const this, enum enPcPose arg2) [?mSetPcBtlPose@mHRPc@@QAEXW4enPcPose@@@Z]
	void mSetPcBtlPose(enum enPcPose arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, enum enPcPose arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa200);
		return mFunc(this, arg2);
	}
	// [Function] enum enPcPose __convention("thiscall") mHRPc::mGetPcBtlPose(class mHRPc* const this) [?mGetPcBtlPose@mHRPc@@QAE?AW4enPcPose@@XZ]
	enum enPcPose mGetPcBtlPose()
	{
		typedef enum enPcPose(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa210);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetEqWepLaser(class mHRPc* const this, uint8_t arg2) [?mSetEqWepLaser@mHRPc@@QAEX_N@Z]
	void mSetEqWepLaser(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa220);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetElectroShockWalk(class mHRPc* const this) [?mGetElectroShockWalk@mHRPc@@QAE_NXZ]
	uint8_t mGetElectroShockWalk()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa230);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPoisonWalk(class mHRPc* const this) [?mGetPoisonWalk@mHRPc@@QAE_NXZ]
	uint8_t mGetPoisonWalk()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa240);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCantDispLaserEffect(class mHRPc* const this) [?mGetCantDispLaserEffect@mHRPc@@QAE_NXZ]
	uint8_t mGetCantDispLaserEffect()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa250);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepChangeUnVisible(class mHRPc* const this, uint8_t arg2) [?mSetWepChangeUnVisible@mHRPc@@QAEX_N@Z]
	void mSetWepChangeUnVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa260);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAtkHitAbsoluteFlag(class mHRPc* const this, uint8_t arg2) [?mSetAtkHitAbsoluteFlag@mHRPc@@QAEX_N@Z]
	void mSetAtkHitAbsoluteFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa270);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAtkHitAbsoluteFlag(class mHRPc* const this) [?mGetAtkHitAbsoluteFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetAtkHitAbsoluteFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa280);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAttackHitToRollEscepe(class mHRPc* const this, uint8_t arg2) [?mSetAttackHitToRollEscepe@mHRPc@@QAEX_N@Z]
	void mSetAttackHitToRollEscepe(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa290);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAttackHitToRollEscepe(class mHRPc* const this) [?mGetAttackHitToRollEscepe@mHRPc@@QAE_NXZ]
	uint8_t mGetAttackHitToRollEscepe()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa2a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPuppetMode(class mHRPc* const this) [?mGetPuppetMode@mHRPc@@QAE_NXZ]
	uint8_t mGetPuppetMode()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa2b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetUseWeaponEffect(class mHRPc* const this) [?mGetUseWeaponEffect@mHRPc@@QAE_NXZ]
	uint8_t mGetUseWeaponEffect()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa2c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLastAttackNpc(class mHRPc* const this, class mHRChara* arg2) [?mSetLastAttackNpc@mHRPc@@QAEXPAVmHRChara@@@Z]
	void mSetLastAttackNpc(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa2d0);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetLastAttackNpc(class mHRPc* const this) [?mGetLastAttackNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mGetLastAttackNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa2e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAttackFromBackNpc(class mHRPc* const this, class mHRChara* arg2) [?mSetAttackFromBackNpc@mHRPc@@QAEXPAVmHRChara@@@Z]
	void mSetAttackFromBackNpc(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa2f0);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetAttackFromBackNpc(class mHRPc* const this) [?mGetAttackFromBackNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mGetAttackFromBackNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa300);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetFinishBonusFlag(class mHRPc* const this) [?mGetFinishBonusFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetFinishBonusFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa310);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanRollEscape(class mHRPc* const this, uint8_t arg2) [?mSetBanRollEscape@mHRPc@@QAEX_N@Z]
	void mSetBanRollEscape(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa320);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanJump(class mHRPc* const this, uint8_t arg2) [?mSetBanJump@mHRPc@@QAEX_N@Z]
	void mSetBanJump(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa330);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanPiyori(class mHRPc* const this, uint8_t arg2) [?mSetBanPiyori@mHRPc@@QAEX_N@Z]
	void mSetBanPiyori(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa340);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanDeadFukki(class mHRPc* const this, uint8_t arg2) [?mSetBanDeadFukki@mHRPc@@QAEX_N@Z]
	void mSetBanDeadFukki(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa350);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanJustGuard(class mHRPc* const this, uint8_t arg2) [?mSetBanJustGuard@mHRPc@@QAEX_N@Z]
	void mSetBanJustGuard(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa360);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBanWinTsubazeri(class mHRPc* const this, uint8_t arg2) [?mSetBanWinTsubazeri@mHRPc@@QAEX_N@Z]
	void mSetBanWinTsubazeri(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa370);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanSlotCry(class mHRPc* const this) [?mGetBanSlotCry@mHRPc@@QAE_NXZ]
	uint8_t mGetBanSlotCry()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa380);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanSlotBel(class mHRPc* const this) [?mGetBanSlotBel@mHRPc@@QAE_NXZ]
	uint8_t mGetBanSlotBel()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa390);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanSlotBar(class mHRPc* const this) [?mGetBanSlotBar@mHRPc@@QAE_NXZ]
	uint8_t mGetBanSlotBar()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa3a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanSlot777(class mHRPc* const this) [?mGetBanSlot777@mHRPc@@QAE_NXZ]
	uint8_t mGetBanSlot777()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa3b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanJump(class mHRPc* const this) [?mGetBanJump@mHRPc@@QAE_NXZ]
	uint8_t mGetBanJump()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa3c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanPiyori(class mHRPc* const this) [?mGetBanPiyori@mHRPc@@QAE_NXZ]
	uint8_t mGetBanPiyori()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa3d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanDeadFukki(class mHRPc* const this) [?mGetBanDeadFukki@mHRPc@@QAE_NXZ]
	uint8_t mGetBanDeadFukki()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa3e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanJustGuard(class mHRPc* const this) [?mGetBanJustGuard@mHRPc@@QAE_NXZ]
	uint8_t mGetBanJustGuard()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa3f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanWinTsubazeri(class mHRPc* const this) [?mGetBanWinTsubazeri@mHRPc@@QAE_NXZ]
	uint8_t mGetBanWinTsubazeri()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa400);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetWepStick(class mHRPc* const this) [?mGetWepStick@mHRPc@@QAE_NXZ]
	uint8_t mGetWepStick()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa410);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDontSubBattery(class mHRPc* const this) [?mGetDontSubBattery@mHRPc@@QAE_NXZ]
	uint8_t mGetDontSubBattery()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa420);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAutoSubBatteryDisEnable(class mHRPc* const this) [?mGetAutoSubBatteryDisEnable@mHRPc@@QAE_NXZ]
	uint8_t mGetAutoSubBatteryDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa430);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetJustGuardDisEnable(class mHRPc* const this) [?mGetJustGuardDisEnable@mHRPc@@QAE_NXZ]
	uint8_t mGetJustGuardDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa440);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDashAtkExec(class mHRPc* const this, uint8_t arg2) [?mSetDashAtkExec@mHRPc@@QAEX_N@Z]
	void mSetDashAtkExec(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa450);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDashAtkExec(class mHRPc* const this) [?mGetDashAtkExec@mHRPc@@QAE_NXZ]
	uint8_t mGetDashAtkExec()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa460);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetJustEscapeDisEnable(class mHRPc* const this) [?mGetJustEscapeDisEnable@mHRPc@@QAE_NXZ]
	uint8_t mGetJustEscapeDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa470);
		return mFunc(this);
	}
	// [Function] struct tagGHMR_TEX* __convention("thiscall") mHRPc::mGetFpsCursorPtr(class mHRPc* const this) [?mGetFpsCursorPtr@mHRPc@@QAEPAUtagGHMR_TEX@@XZ]
	struct tagGHMR_TEX* mGetFpsCursorPtr()
	{
		typedef struct tagGHMR_TEX*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa480);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontRestoreMotion(class mHRPc* const this, uint8_t arg2) [?mSetDontRestoreMotion@mHRPc@@QAEX_N@Z]
	void mSetDontRestoreMotion(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa490);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDontRestoreMotion(class mHRPc* const this) [?mGetDontRestoreMotion@mHRPc@@QAE_NXZ]
	uint8_t mGetDontRestoreMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa4a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBikeClash2battou(class mHRPc* const this, uint8_t arg2) [?mSetBikeClash2battou@mHRPc@@QAEX_N@Z]
	void mSetBikeClash2battou(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa4b0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetRotInterpolate(class mHRPc* const this, float arg2) [?mSetRotInterpolate@mHRPc@@QAEXM@Z]
	void mSetRotInterpolate(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa4c0);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetRotInterpolateDefault(class mHRPc* const this) [?mGetRotInterpolateDefault@mHRPc@@UAEMXZ]
	float mGetRotInterpolateDefault()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa4d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetHiTension(class mHRPc* const this) [?mGetHiTension@mHRPc@@QAE_NXZ]
	uint8_t mGetHiTension()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa4e0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mTestDancingCombo(class mHRPc* const this) [?mTestDancingCombo@mHRPc@@QAEHXZ]
	int32_t mTestDancingCombo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa4f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestBullet(class mHRPc* const this) [?mTestBullet@mHRPc@@QAE_NXZ]
	uint8_t mTestBullet()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa500);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestFire(class mHRPc* const this) [?mTestFire@mHRPc@@QAE_NXZ]
	uint8_t mTestFire()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa510);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTest360(class mHRPc* const this) [?mTest360@mHRPc@@QAE_NXZ]
	uint8_t mTest360()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa520);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTigerVisible(class mHRPc* const this, uint8_t arg2) [?mSetTigerVisible@mHRPc@@QAEX_N@Z]
	void mSetTigerVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa530);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetTigerVisible(class mHRPc* const this) [?mGetTigerVisible@mHRPc@@QAE_NXZ]
	uint8_t mGetTigerVisible()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa540);
		return mFunc(this);
	}
	// [Function] class ghmTriangle* __convention("thiscall") mHRPc::mGetRightWepTrianglePtr(class mHRPc* const this) [?mGetRightWepTrianglePtr@mHRPc@@QAEPAVghmTriangle@@XZ]
	class ghmTriangle* mGetRightWepTrianglePtr()
	{
		typedef class ghmTriangle*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa550);
		return mFunc(this);
	}
	// [Function] class ghmTriangle* __convention("thiscall") mHRPc::mGetWepTrianglePtr(class mHRPc* const this) [?mGetWepTrianglePtr@mHRPc@@QAEPAVghmTriangle@@XZ]
	class ghmTriangle* mGetWepTrianglePtr()
	{
		typedef class ghmTriangle*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa560);
		return mFunc(this);
	}
	// [Function] class TGmf* __convention("thiscall") mHRPc::mGetResourceGmfPtr(class mHRPc* const this) [?mGetResourceGmfPtr@mHRPc@@UAEPAVTGmf@@XZ]
	class TGmf* mGetResourceGmfPtr()
	{
		typedef class TGmf*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa570);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPauseNpcFlag(class mHRPc* const this, uint8_t arg2) [?mSetPauseNpcFlag@mHRPc@@QAEX_N@Z]
	void mSetPauseNpcFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa590);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPauseNpcFlag(class mHRPc* const this) [?mGetPauseNpcFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetPauseNpcFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa5a0);
		return mFunc(this);
	}
	// [Function] char const* __convention("thiscall") mHRPc::getCurTigerMotionName(class mHRPc* const this) [?getCurTigerMotionName@mHRPc@@QBEPBDXZ]
	// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
	void getCurTigerMotionName()
	{
		typedef char const*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa5b0);
		mFunc(this);
	}
	// [Function] char const* __convention("thiscall") mHRPc::getCurMotionName(class mHRPc* const this) [?getCurMotionName@mHRPc@@UBEPBDXZ]
	// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
	void getCurMotionName()
	{
		typedef char const*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa5c0);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::isOutResourceMotion(class mHRPc* const this) [?isOutResourceMotion@mHRPc@@QBE_NXZ]
	uint8_t isOutResourceMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa5d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCancelSetPadOffset(class mHRPc* const this) [?mGetCancelSetPadOffset@mHRPc@@QAE_NXZ]
	uint8_t mGetCancelSetPadOffset()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa5f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetChangeEquipFromScript(class mHRPc* const this) [?mGetChangeEquipFromScript@mHRPc@@QAE_NXZ]
	uint8_t mGetChangeEquipFromScript()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa600);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetNoBatteryThrow(class mHRPc* const this, uint8_t arg2) [?mSetNoBatteryThrow@mHRPc@@QAEX_N@Z]
	void mSetNoBatteryThrow(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa610);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetNoBatteryThrow(class mHRPc* const this) [?mGetNoBatteryThrow@mHRPc@@QAE_NXZ]
	uint8_t mGetNoBatteryThrow()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa620);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetChangeWeaponEffectVisible(class mHRPc* const this, uint8_t arg2) [?mSetChangeWeaponEffectVisible@mHRPc@@QAEX_N@Z]
	void mSetChangeWeaponEffectVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa630);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetChangeWeaponEffectVisible(class mHRPc* const this) [?mGetChangeWeaponEffectVisible@mHRPc@@QAE_NXZ]
	uint8_t mGetChangeWeaponEffectVisible()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa640);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLockOnNockDown(class mHRPc* const this, uint8_t arg2) [?mSetLockOnNockDown@mHRPc@@QAEX_N@Z]
	void mSetLockOnNockDown(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa650);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetLockOnNockDown(class mHRPc* const this) [?mGetLockOnNockDown@mHRPc@@QAE_NXZ]
	uint8_t mGetLockOnNockDown()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAttackHajiki(class mHRPc* const this, uint8_t arg2) [?mSetAttackHajiki@mHRPc@@QAEX_N@Z]
	void mSetAttackHajiki(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa670);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetAttackHajiki(class mHRPc* const this) [?mGetAttackHajiki@mHRPc@@QAE_NXZ]
	uint8_t mGetAttackHajiki()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa680);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontPlayLoseTsubazeriMotion(class mHRPc* const this, uint8_t arg2) [?mSetDontPlayLoseTsubazeriMotion@mHRPc@@QAEX_N@Z]
	void mSetDontPlayLoseTsubazeriMotion(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa690);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDontPlayLoseTsubazeriMotion(class mHRPc* const this) [?mGetDontPlayLoseTsubazeriMotion@mHRPc@@QAE_NXZ]
	uint8_t mGetDontPlayLoseTsubazeriMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa6a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetNoWearJacket(class mHRPc* const this) [?mGetNoWearJacket@mHRPc@@QAE_NXZ]
	uint8_t mGetNoWearJacket()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa6b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDispChangeWeaponIcon(class mHRPc* const this, uint8_t arg2) [?mSetDispChangeWeaponIcon@mHRPc@@QAEX_N@Z]
	void mSetDispChangeWeaponIcon(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa6c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDispChangeWeaponIcon(class mHRPc* const this) [?mGetDispChangeWeaponIcon@mHRPc@@QAE_NXZ]
	uint8_t mGetDispChangeWeaponIcon()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa6d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetStandUpAttack(class mHRPc* const this, uint8_t arg2) [?mSetStandUpAttack@mHRPc@@QAEX_N@Z]
	void mSetStandUpAttack(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa6e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetStandUpAttack(class mHRPc* const this) [?mGetStandUpAttack@mHRPc@@QAE_NXZ]
	uint8_t mGetStandUpAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa6f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPushingBatteryChargeButton(class mHRPc* const this, uint8_t arg2) [?mSetPushingBatteryChargeButton@mHRPc@@QAEX_N@Z]
	void mSetPushingBatteryChargeButton(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa700);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPushingBatteryChargeButton(class mHRPc* const this) [?mGetPushingBatteryChargeButton@mHRPc@@QAE_NXZ]
	uint8_t mGetPushingBatteryChargeButton()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa710);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetHitBigConsumeBattertAttack(class mHRPc* const this, uint8_t arg2) [?mSetHitBigConsumeBattertAttack@mHRPc@@QAEX_N@Z]
	void mSetHitBigConsumeBattertAttack(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa720);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetHitBigConsumeBattertAttack(class mHRPc* const this) [?mGetHitBigConsumeBattertAttack@mHRPc@@QAE_NXZ]
	uint8_t mGetHitBigConsumeBattertAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa730);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetStartThrowSlow(class mHRPc* const this, uint8_t arg2) [?mSetStartThrowSlow@mHRPc@@QAEX_N@Z]
	void mSetStartThrowSlow(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa740);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetStartThrowSlow(class mHRPc* const this) [?mGetStartThrowSlow@mHRPc@@QAE_NXZ]
	uint8_t mGetStartThrowSlow()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa750);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetForceLoseTsubazeri(class mHRPc* const this) [?mGetForceLoseTsubazeri@mHRPc@@QAE_NXZ]
	uint8_t mGetForceLoseTsubazeri()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa760);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetEqWepID(class mHRPc* const this) [?mGetEqWepID@mHRPc@@QAEHXZ]
	int32_t mGetEqWepID()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaa770);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetWepCmbExtend(class mHRPc* const this, int32_t arg2) [?mGetWepCmbExtend@mHRPc@@QAE_NH@Z]
	uint8_t mGetWepCmbExtend(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaa780);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDeadMotionPlayFlag(class mHRPc* const this, uint8_t arg2) [?mSetDeadMotionPlayFlag@mHRPc@@QAEX_N@Z]
	void mSetDeadMotionPlayFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xadc30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::getNPCInterestPosition(class mHRPc* const this, struct Vec* arg2) [?getNPCInterestPosition@mHRPc@@QBEXPAUVec@@@Z]
	void getNPCInterestPosition(struct Vec* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, struct Vec* arg2);
		_Func mFunc = (_Func)(GameModule + 0xae390);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetStammina(class mHRPc* const this) [?mGetStammina@mHRPc@@QAEMXZ]
	float mGetStammina()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaf9f0);
		return mFunc(this);
	}
	// [Function] struct stPcStatus* __convention("thiscall") mHRPc::mGetPcStatusPtr(class mHRPc* const this) [?mGetPcStatusPtr@mHRPc@@QAEPAUstPcStatus@@XZ]
	struct stPcStatus* mGetPcStatusPtr()
	{
		typedef struct stPcStatus*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaff30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBikeVisible(class mHRPc* const this) [?mGetBikeVisible@mHRPc@@QAE_NXZ]
	uint8_t mGetBikeVisible()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaff40);
		return mFunc(this);
	}
	// [Function] char __convention("thiscall") mHRPc::mGetFinishNpcNum(class mHRPc* const this) [?mGetFinishNpcNum@mHRPc@@QAECXZ]
	char mGetFinishNpcNum()
	{
		typedef char(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaff50);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetLockOnDummyPtr(class mHRPc* const this) [?mGetLockOnDummyPtr@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mGetLockOnDummyPtr()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaff60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCallMotionProcess(class mHRPc* const this) [?mGetCallMotionProcess@mHRPc@@QAE_NXZ]
	uint8_t mGetCallMotionProcess()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaff70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDeadBossNum(class mHRPc* const this, uint32_t arg2) [?mSetDeadBossNum@mHRPc@@QAEXI@Z]
	void mSetDeadBossNum(uint32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xaff80);
		return mFunc(this, arg2);
	}
	// [Function] struct stThrowInfo* __convention("thiscall") mHRPc::mGetThrowInfoPtr(class mHRPc* const this) [?mGetThrowInfoPtr@mHRPc@@QAEPAUstThrowInfo@@XZ]
	struct stThrowInfo* mGetThrowInfoPtr()
	{
		typedef struct stThrowInfo*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaff90);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mGetCatchNpc(class mHRPc* const this) [?mGetCatchNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mGetCatchNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaffa0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishAttackJustBeforeHitSlow(class mHRPc* const this) [?mCheckFinishAttackJustBeforeHitSlow@mHRPc@@QAE_NXZ]
	uint8_t mCheckFinishAttackJustBeforeHitSlow()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb51e0);
		return mFunc(this);
	}
	// [Function] struct stPcEffect* __convention("thiscall") mHRPc::mGetPcEffectPtr(class mHRPc* const this) [?mGetPcEffectPtr@mHRPc@@QAEPAUstPcEffect@@XZ]
	struct stPcEffect* mGetPcEffectPtr()
	{
		typedef struct stPcEffect*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb9b80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCallBikeFlag(class mHRPc* const this) [?mGetCallBikeFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetCallBikeFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb9b90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetLostBikeFlag(class mHRPc* const this) [?mGetLostBikeFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetLostBikeFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb9ba0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBikeSight(class mHRPc* const this, uint8_t arg2) [?mSetBikeSight@mHRPc@@QAEXE@Z]
	void mSetBikeSight(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xb9bb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDontChangeBikeCamera(class mHRPc* const this, uint8_t arg2) [?mSetDontChangeBikeCamera@mHRPc@@QAEXE@Z]
	void mSetDontChangeBikeCamera(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xb9bc0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetOnlyMove(class mHRPc* const this) [?mGetOnlyMove@mHRPc@@QAE_NXZ]
	uint8_t mGetOnlyMove()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb9be0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDeadPauseFlag(class mHRPc* const this) [?mGetDeadPauseFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetDeadPauseFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xba080);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTameMax(class mHRPc* const this) [?mCheckTameMax@mHRPc@@QAE_NXZ]
	uint8_t mCheckTameMax()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xba6b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestHitFinishAttack(class mHRPc* const this) [?mTestHitFinishAttack@mHRPc@@QAE_NXZ]
	uint8_t mTestHitFinishAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xba6c0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetFinishJudgeFrame(class mHRPc* const this) [?mGetFinishJudgeFrame@mHRPc@@QAEHXZ]
	int32_t mGetFinishJudgeFrame()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xbadc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCmbNum(class mHRPc* const this) [?mGetCmbNum@mHRPc@@QAEEXZ]
	uint8_t mGetCmbNum()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xbadd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOnlyFlagBattouDemo(class mHRPc* const this, uint8_t arg2) [?mSetOnlyFlagBattouDemo@mHRPc@@QAEX_N@Z]
	void mSetOnlyFlagBattouDemo(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xbfc80);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOnlyFlagNoutouDemo(class mHRPc* const this, uint8_t arg2) [?mSetOnlyFlagNoutouDemo@mHRPc@@QAEX_N@Z]
	void mSetOnlyFlagNoutouDemo(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xbfc90);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLockOnThroughWall(class mHRPc* const this, uint8_t arg2) [?mSetLockOnThroughWall@mHRPc@@QAEX_N@Z]
	void mSetLockOnThroughWall(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0xc2fd0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mIsDoingFinishMotion(class mHRPc* const this) [?mIsDoingFinishMotion@mHRPc@@QBE_NXZ]
	uint8_t mIsDoingFinishMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xcdb80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetSlashModeOnly(class mHRPc* const this) [?mGetSlashModeOnly@mHRPc@@QAE_NXZ]
	uint8_t mGetSlashModeOnly()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xcdb90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetBanRollEscape(class mHRPc* const this) [?mGetBanRollEscape@mHRPc@@QAE_NXZ]
	uint8_t mGetBanRollEscape()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xcdba0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetDashAtkDisEnable(class mHRPc* const this) [?mGetDashAtkDisEnable@mHRPc@@QAE_NXZ]
	uint8_t mGetDashAtkDisEnable()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xcdbb0);
		return mFunc(this);
	}
	// [Function] struct HRSAVEDATA_SHOP* __convention("thiscall") mHRPc::mGetShopDataPtr(class mHRPc* const this) [?mGetShopDataPtr@mHRPc@@QAEPAUHRSAVEDATA_SHOP@@XZ]
	struct HRSAVEDATA_SHOP* mGetShopDataPtr()
	{
		typedef struct HRSAVEDATA_SHOP*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xd0500);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetCatchTick(class mHRPc* const this) [?mGetCatchTick@mHRPc@@QAEHXZ]
	int32_t mGetCatchTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xd8a50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockAllMoves(class mHRPc* const this) [?UnlockAllMoves@mHRPc@@AAEXXZ]
	void UnlockAllMoves()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41a030);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockAllUpgrades(class mHRPc* const this) [?UnlockAllUpgrades@mHRPc@@AAEXXZ]
	void UnlockAllUpgrades()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41a060);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockAllPcUpgrades(class mHRPc* const this) [?UnlockAllPcUpgrades@mHRPc@@AAEXXZ]
	void UnlockAllPcUpgrades()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41a200);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::SwitchToMainWeapon(class mHRPc* const this) [?SwitchToMainWeapon@mHRPc@@AAEXXZ]
	void SwitchToMainWeapon()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41a220);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockAllWeapons(class mHRPc* const this) [?UnlockAllWeapons@mHRPc@@AAEXXZ]
	void UnlockAllWeapons()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41a270);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::SubPcNowEquipBatteryRatio(class mHRPc* const this, float const arg2) [?SubPcNowEquipBatteryRatio@mHRPc@@QAEXM@Z]
	void SubPcNowEquipBatteryRatio(float const arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float const arg2);
		_Func mFunc = (_Func)(GameModule + 0x41a380);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::isAcceptCameraFollowRotation(class mHRPc* const this) [?isAcceptCameraFollowRotation@mHRPc@@QAE_NXZ]
	uint8_t isAcceptCameraFollowRotation()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41a3e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestCanDownAttack(class mHRPc* const this, class mHRChara* arg2) [?mTestCanDownAttack@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mTestCanDownAttack(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41a400);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestRunWeaponEffect(class mHRPc* const this, int32_t arg2) [?mTestRunWeaponEffect@mHRPc@@QAE_NH@Z]
	uint8_t mTestRunWeaponEffect(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41a440);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mFloorEventProc(class mHRPc* const this) [?mFloorEventProc@mHRPc@@QAEXXZ]
	void mFloorEventProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41a550);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallClearProcessBeforeEvent(class mHRPc* const this) [?mCallClearProcessBeforeEvent@mHRPc@@QAEXXZ]
	void mCallClearProcessBeforeEvent()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41aa70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetSlowMotion(class mHRPc* const this) [?mGetSlowMotion@mHRPc@@QAE_NXZ]
	uint8_t mGetSlowMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41ab40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSlowMotionProc(class mHRPc* const this) [?mSlowMotionProc@mHRPc@@QAE_NXZ]
	uint8_t mSlowMotionProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41ab60);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mSlowMotionSystem(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mSlowMotionSystem@mHRPc@@QAEHHH@Z]
	int32_t mSlowMotionSystem(int32_t arg2, int32_t arg3)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x41abc0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mDeadProc(class mHRPc* const this, uint8_t arg2) [?mDeadProc@mHRPc@@QAEX_N@Z]
	void mDeadProc(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41ac40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::IncSwingCount(class mHRPc* const this) [?IncSwingCount@mHRPc@@QAEXXZ]
	void IncSwingCount()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41af90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::TestStoreBikePosForSM(class mHRPc* const this) [?TestStoreBikePosForSM@mHRPc@@QAE_NXZ]
	uint8_t TestStoreBikePosForSM()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41afa0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::ReStoreBikePosForSM(class mHRPc* const this) [?ReStoreBikePosForSM@mHRPc@@QAEXXZ]
	void ReStoreBikePosForSM()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41afb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDigHoleProc(class mHRPc* const this) [?mDigHoleProc@mHRPc@@QAE_NXZ]
	uint8_t mDigHoleProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41b040);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestDigHoleAction(class mHRPc* const this) [?mTestDigHoleAction@mHRPc@@QAE_NXZ]
	uint8_t mTestDigHoleAction()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41b1d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::PcInputMove(class mHRPc* const this) [?PcInputMove@mHRPc@@QAE_NXZ]
	uint8_t PcInputMove()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41b1e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::PcInputIdleProc(class mHRPc* const this) [?PcInputIdleProc@mHRPc@@QAE_NXZ]
	uint8_t PcInputIdleProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41b410);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestCatchZako(class mHRPc* const this) [?mTestCatchZako@mHRPc@@QAE_NXZ]
	uint8_t mTestCatchZako()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41b7c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mRestore1stChBGM(class mHRPc* const this, uint8_t arg2) [?mRestore1stChBGM@mHRPc@@QAEX_N@Z]
	void mRestore1stChBGM(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41b7e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlay2ndChBGM(class mHRPc* const this, int32_t arg2, float arg3, uint8_t arg4) [?mPlay2ndChBGM@mHRPc@@QAEXHM_N@Z]
	void mPlay2ndChBGM(int32_t arg2, float arg3, uint8_t arg4)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, float arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x41b870);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetSmokeColor(class mHRPc* const this, struct GXColor* arg2) [?mGetSmokeColor@mHRPc@@QAEXPAUGXColor@@@Z]
	void mGetSmokeColor(struct GXColor* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, struct GXColor* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41b8e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mExitBatteryCharge(class mHRPc* const this) [?mExitBatteryCharge@mHRPc@@QAEXXZ]
	void mExitBatteryCharge()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41b960);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mHitCheckNpc(class mHRPc* const this) [?mHitCheckNpc@mHRPc@@QAE_NXZ]
	uint8_t mHitCheckNpc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41b980);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCherryFlag(class mHRPc* const this, uint8_t arg2) [?mSetCherryFlag@mHRPc@@QAEX_N@Z]
	void mSetCherryFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41bb30);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBossThrow(class mHRPc* const this, enum enCharaType arg2) [?mCheckBossThrow@mHRPc@@QAE_NW4enCharaType@@@Z]
	uint8_t mCheckBossThrow(enum enCharaType arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, enum enCharaType arg2);
		_Func mFunc = (_Func)(GameModule + 0x41bb40);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetJustGuardJudgeTick(class mHRPc* const this) [?mGetJustGuardJudgeTick@mHRPc@@QAEHXZ]
	int32_t mGetJustGuardJudgeTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41bc30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanFight(class mHRPc* const this) [?mCheckCanFight@mHRPc@@QAE_NXZ]
	uint8_t mCheckCanFight()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41bc70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearBomStockNum(class mHRPc* const this) [?mClearBomStockNum@mHRPc@@QAEXXZ]
	void mClearBomStockNum()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41bcb0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetSpecialAttackRestTick(class mHRPc* const this) [?mGetSpecialAttackRestTick@mHRPc@@QAEHXZ]
	int32_t mGetSpecialAttackRestTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41bcc0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetEmptyShinkuWaveIndex(class mHRPc* const this) [?mGetEmptyShinkuWaveIndex@mHRPc@@QAEHXZ]
	int32_t mGetEmptyShinkuWaveIndex()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41bcd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCreateShinkuWave(class mHRPc* const this) [?mCreateShinkuWave@mHRPc@@QAEXXZ]
	void mCreateShinkuWave()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41bcf0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallEffectBlur(class mHRPc* const this, int32_t arg2, float arg3, float arg4, int32_t arg5) [?mCallEffectBlur@mHRPc@@QAEXHMMH@Z]
	void mCallEffectBlur(int32_t arg2, float arg3, float arg4, int32_t arg5)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, float arg3, float arg4, int32_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x41beb0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLaserTrack(class mHRPc* const this, uint8_t arg2, int32_t arg3, int32_t arg4) [?mSetLaserTrack@mHRPc@@QAEX_NHH@Z]
	void mSetLaserTrack(uint8_t arg2, int32_t arg3, int32_t arg4)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, int32_t arg3, int32_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x41bf30);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLaserScale(class mHRPc* const this, float arg2) [?mSetLaserScale@mHRPc@@QAEXM@Z]
	void mSetLaserScale(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x41c120);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLaserLogValid(class mHRPc* const this, uint8_t arg2) [?mSetLaserLogValid@mHRPc@@QAEX_N@Z]
	void mSetLaserLogValid(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41c150);
		return mFunc(this, arg2);
	}
	// [Function] uint32_t __convention("thiscall") mHRPc::mGetLaserColor(class mHRPc* const this) [?mGetLaserColor@mHRPc@@QAEIXZ]
	uint32_t mGetLaserColor()
	{
		typedef uint32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c1a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLaserColor(class mHRPc* const this, uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5) [?mSetLaserColor@mHRPc@@QAEXEEEE@Z]
	void mSetLaserColor(uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3, uint8_t arg4, uint8_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x41c210);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRPc::mCreateLaserEffect(class mHRPc* const this, int32_t arg2) [?mCreateLaserEffect@mHRPc@@QAEXH@Z]
	void mCreateLaserEffect(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41c270);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mDeleteChargeEffect(class mHRPc* const this, int32_t arg2) [?mDeleteChargeEffect@mHRPc@@QAEXH@Z]
	void mDeleteChargeEffect(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41c540);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mCreateChargeEffect(class mHRPc* const this, int32_t arg2) [?mCreateChargeEffect@mHRPc@@QAEXH@Z]
	void mCreateChargeEffect(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41c570);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBigWeapon(class mHRPc* const this) [?mCheckBigWeapon@mHRPc@@QAE_NXZ]
	uint8_t mCheckBigWeapon()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c620);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDigToolFlag(class mHRPc* const this, uint8_t arg2) [?mSetDigToolFlag@mHRPc@@QAEX_N@Z]
	void mSetDigToolFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41c630);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearMMSMInit(class mHRPc* const this) [?mClearMMSMInit@mHRPc@@QAEXXZ]
	void mClearMMSMInit()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c660);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBikePos2Motel(class mHRPc* const this) [?mSetBikePos2Motel@mHRPc@@QAEXXZ]
	void mSetBikePos2Motel()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c6d0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetStopRenderCounter(class mHRPc* const this) [?mGetStopRenderCounter@mHRPc@@QAEHXZ]
	int32_t mGetStopRenderCounter()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c700);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetStopRenderCounter(class mHRPc* const this) [?mSetStopRenderCounter@mHRPc@@QAEXXZ]
	void mSetStopRenderCounter()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c720);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") mHRPc::mGetLightSideNum(class mHRPc* const this) [?mGetLightSideNum@mHRPc@@QAEIXZ]
	uint32_t mGetLightSideNum()
	{
		typedef uint32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c730);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetReceiveDamage(class mHRPc* const this) [?mGetReceiveDamage@mHRPc@@QAEMXZ]
	float mGetReceiveDamage()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c760);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetMaxCombo(class mHRPc* const this) [?mGetMaxCombo@mHRPc@@QAEEXZ]
	uint8_t mGetMaxCombo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c780);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDown(class mHRPc* const this, enum enDownStatus arg2, uint8_t arg3) [?mSetDown@mHRPc@@QAEXW4enDownStatus@@_N@Z]
	void mSetDown(enum enDownStatus arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, enum enDownStatus arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x41c790);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCallBikeFlag(class mHRPc* const this, uint8_t arg2) [?mSetCallBikeFlag@mHRPc@@QAEX_N@Z]
	void mSetCallBikeFlag(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41c810);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetFireMan(class mHRPc* const this, float arg2) [?mSetFireMan@mHRPc@@QAEXM@Z]
	void mSetFireMan(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x41c950);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetDarkSideUseNum(class mHRPc* const this) [?mGetDarkSideUseNum@mHRPc@@QAEHXZ]
	int32_t mGetDarkSideUseNum()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c9d0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetLightSideRate(class mHRPc* const this) [?mGetLightSideRate@mHRPc@@QAEMXZ]
	float mGetLightSideRate()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41c9e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallSwordCutDmgEffect(class mHRPc* const this, class ghmTriangle* arg2, uint32_t const arg3) [?mCallSwordCutDmgEffect@mHRPc@@QAE_NPBVghmTriangle@@I@Z]
	uint8_t mCallSwordCutDmgEffect(class ghmTriangle* arg2, uint32_t const arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class ghmTriangle* arg2, uint32_t const arg3);
		_Func mFunc = (_Func)(GameModule + 0x41ca00);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallBeamCutDmgEffect(class mHRPc* const this, class ghmTriangle* arg2, uint32_t const arg3) [?mCallBeamCutDmgEffect@mHRPc@@QAE_NPBVghmTriangle@@I@Z]
	uint8_t mCallBeamCutDmgEffect(class ghmTriangle* arg2, uint32_t const arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class ghmTriangle* arg2, uint32_t const arg3);
		_Func mFunc = (_Func)(GameModule + 0x41cec0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallFightAttackDmgEffect(class mHRPc* const this, class mHRChara* arg2) [?mCallFightAttackDmgEffect@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mCallFightAttackDmgEffect(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41d3d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallElectDmgEffect(class mHRPc* const this) [?mCallElectDmgEffect@mHRPc@@QAE_NXZ]
	uint8_t mCallElectDmgEffect()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41d4f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallNormalAttackEffect(class mHRPc* const this, class mHRChara* arg2) [?mCallNormalAttackEffect@mHRPc@@QAEXPAVmHRChara@@@Z]
	void mCallNormalAttackEffect(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41d7d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::IsCenteringHoseiCutmark(class mHRPc* const this) [?IsCenteringHoseiCutmark@mHRPc@@QAE_NXZ]
	uint8_t IsCenteringHoseiCutmark()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41dd90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::CreateCutMarkEffect(class mHRPc* const this, class mHRChara* arg2, enum eEfDmgLevel arg3) [?CreateCutMarkEffect@mHRPc@@QAEXPAVmHRChara@@W4eEfDmgLevel@@@Z]
	void CreateCutMarkEffect(class mHRChara* arg2, enum eEfDmgLevel arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2, enum eEfDmgLevel arg3);
		_Func mFunc = (_Func)(GameModule + 0x41ddc0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::CreateGuardBreakEffect(class mHRPc* const this) [?CreateGuardBreakEffect@mHRPc@@QAEXXZ]
	/// <summary>
	/// Creates a spark effect at character torso / head.
	/// </summary>
	void CreateGuardBreakEffect()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41dfc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSePlayChargeAttack(class mHRPc* const this, class mHRChara* arg2) [?mSePlayChargeAttack@mHRPc@@QAEXPAVmHRChara@@@Z]
	void mSePlayChargeAttack(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41e010);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallFinishAttackEffect(class mHRPc* const this, class mHRChara* arg2) [?mCallFinishAttackEffect@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mCallFinishAttackEffect(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41e090);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCreateHugGan(class mHRPc* const this, char* arg2, int32_t arg3) [?mCreateHugGan@mHRPc@@QAE_NPADH@Z]
	uint8_t mCreateHugGan(char* arg2, int32_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, char* arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x41e0b0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayHugMotion(class mHRPc* const this, int32_t arg2, float arg3) [?mPlayHugMotion@mHRPc@@QAEXHM@Z]
	void mPlayHugMotion(int32_t arg2, float arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, float arg3);
		_Func mFunc = (_Func)(GameModule + 0x41e1e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPoisonWalk(class mHRPc* const this, uint8_t arg2) [?mSetPoisonWalk@mHRPc@@QAEX_N@Z]
	void mSetPoisonWalk(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41e370);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetElectroShockBGMPitch(class mHRPc* const this) [?mSetElectroShockBGMPitch@mHRPc@@QAEXXZ]
	void mSetElectroShockBGMPitch()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41e550);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckReadEndAtkMot(class mHRPc* const this) [?mCheckReadEndAtkMot@mHRPc@@QAE_NXZ]
	uint8_t mCheckReadEndAtkMot()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41e5b0);
		return mFunc(this);
	}
	// [Function] enum enPcPose __convention("thiscall") mHRPc::mGetPcBtlPoseNowMotion(class mHRPc* const this, int32_t arg2) [?mGetPcBtlPoseNowMotion@mHRPc@@QAE?AW4enPcPose@@H@Z]
	enum enPcPose mGetPcBtlPoseNowMotion(int32_t arg2)
	{
		typedef enum enPcPose(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41e5c0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishNpc(class mHRPc* const this, class mHRChara* arg2) [?mCheckFinishNpc@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mCheckFinishNpc(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41e830);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetHitEffectPos(class mHRPc* const this, struct Vec* arg2) [?mGetHitEffectPos@mHRPc@@QAEXPAUVec@@@Z]
	void mGetHitEffectPos(struct Vec* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, struct Vec* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41e860);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetNoutou(class mHRPc* const this, uint8_t arg2) [?mSetNoutou@mHRPc@@UAEX_N@Z]
	void mSetNoutou(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41e9d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBattou(class mHRPc* const this, uint8_t arg2) [?mSetBattou@mHRPc@@UAEX_N@Z]
	void mSetBattou(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41eb40);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetBikeNitro(class mHRPc* const this) [?mGetBikeNitro@mHRPc@@QAEMXZ]
	float mGetBikeNitro()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41ed10);
		return mFunc(this);
	}
	// [Function] struct Vec& __convention("thiscall") mHRPc::mGetBikeRot(class mHRPc* const this) [?mGetBikeRot@mHRPc@@QAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetBikeRot()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41ed30);
		mFunc(this);
	}
	// [Function] char __convention("thiscall") mHRPc::mGetEquipDurabilityMax(class mHRPc* const this, int32_t arg2) [?mGetEquipDurabilityMax@mHRPc@@QAECH@Z]
	char mGetEquipDurabilityMax(int32_t arg2)
	{
		typedef char(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41ed40);
		return mFunc(this, arg2);
	}
	// [Function] char __convention("thiscall") mHRPc::mGetEquipDurability(class mHRPc* const this, int32_t arg2) [?mGetEquipDurability@mHRPc@@QAECH@Z]
	char mGetEquipDurability(int32_t arg2)
	{
		typedef char(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41ed50);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetOnlyEquip(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mSetOnlyEquip@mHRPc@@QAE_NH_N@Z]
	uint8_t mSetOnlyEquip(int32_t arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x41ed60);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mChangeWeapon4Debug(class mHRPc* const this, int32_t arg2) [?mChangeWeapon4Debug@mHRPc@@QAEXH@Z]
	void mChangeWeapon4Debug(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41ede0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mChangeEquipID2KindIndex(class mHRPc* const this, int32_t arg2) [?mChangeEquipID2KindIndex@mHRPc@@QAEHH@Z]
	int32_t mChangeEquipID2KindIndex(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41ee20);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetLockerIndex(class mHRPc* const this, int32_t arg2) [?mGetLockerIndex@mHRPc@@QAEHH@Z]
	int32_t mGetLockerIndex(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41ee40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDelLocker(class mHRPc* const this, int32_t arg2) [?mDelLocker@mHRPc@@QAE_NH@Z]
	uint8_t mDelLocker(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41ee70);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetDamageRate(class mHRPc* const this) [?mGetDamageRate@mHRPc@@QAEMXZ]
	float mGetDamageRate()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41eeb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepCmbExtend(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mSetWepCmbExtend@mHRPc@@QAEXH_N@Z]
	void mSetWepCmbExtend(int32_t arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x41eef0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetWepPower(class mHRPc* const this, int32_t arg2) [?mGetWepPower@mHRPc@@QAEMH@Z]
	float mGetWepPower(int32_t arg2)
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41ef60);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepPower(class mHRPc* const this, int32_t arg2, float arg3) [?mSetWepPower@mHRPc@@QAEXHM@Z]
	void mSetWepPower(int32_t arg2, float arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, float arg3);
		_Func mFunc = (_Func)(GameModule + 0x41ef70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDelWep(class mHRPc* const this, int32_t arg2) [?mDelWep@mHRPc@@QAE_NH@Z]
	uint8_t mDelWep(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x41efa0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAddWep(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mAddWep@mHRPc@@QAE_NHH@Z]
	uint8_t mAddWep(int32_t arg2, int32_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x41efb0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mMissCatch(class mHRPc* const this) [?mMissCatch@mHRPc@@QAEXXZ]
	void mMissCatch()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41efd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayThrowMissMotion(class mHRPc* const this) [?mPlayThrowMissMotion@mHRPc@@QAEXXZ]
	void mPlayThrowMissMotion()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41f2a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDispThrowInput(class mHRPc* const this) [?mDispThrowInput@mHRPc@@QAEXXZ]
	void mDispThrowInput()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41f3e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartThrowInput(class mHRPc* const this) [?mStartThrowInput@mHRPc@@QAEXXZ]
	void mStartThrowInput()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41f740);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAdjustHitWallPosition(class mHRPc* const this, struct Vec* arg2) [?mAdjustHitWallPosition@mHRPc@@QAE_NPAUVec@@@Z]
	uint8_t mAdjustHitWallPosition(struct Vec* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, struct Vec* arg2);
		_Func mFunc = (_Func)(GameModule + 0x41f840);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mStartThrowSNB(class mHRPc* const this) [?mStartThrowSNB@mHRPc@@QAE_NXZ]
	uint8_t mStartThrowSNB()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x41fd90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mFrameProcChangeScreen(class mHRPc* const this) [?mFrameProcChangeScreen@mHRPc@@QAEXXZ]
	void mFrameProcChangeScreen()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x420160);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMiniDemoForWarpPosSantDestroy(class mHRPc* const this) [?mPlayMiniDemoForWarpPosSantDestroy@mHRPc@@QAE_NXZ]
	uint8_t mPlayMiniDemoForWarpPosSantDestroy()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x420460);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetAfterWarpPosForSantDestroy(class mHRPc* const this) [?mSetAfterWarpPosForSantDestroy@mHRPc@@QAEXXZ]
	void mSetAfterWarpPosForSantDestroy()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4205d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestEndWarpPosForSantDestroy(class mHRPc* const this) [?mTestEndWarpPosForSantDestroy@mHRPc@@QAE_NXZ]
	uint8_t mTestEndWarpPosForSantDestroy()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x420790);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetWarpPosForSantDestroy(class mHRPc* const this, int32_t arg2) [?mSetWarpPosForSantDestroy@mHRPc@@QAE_NH@Z]
	uint8_t mSetWarpPosForSantDestroy(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4207c0);
		return mFunc(this, arg2);
	}
	// [Function] enum enScreenChangeStatus __convention("thiscall") mHRPc::mGetChangeScreenStatus(class mHRPc* const this) [?mGetChangeScreenStatus@mHRPc@@QAE?AW4enScreenChangeStatus@@XZ]
	enum enScreenChangeStatus mGetChangeScreenStatus()
	{
		typedef enum enScreenChangeStatus(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x420920);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mEndChangeScreen(class mHRPc* const this, int32_t arg2) [?mEndChangeScreen@mHRPc@@QAE_NH@Z]
	uint8_t mEndChangeScreen(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4209a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mStartChangeScreen(class mHRPc* const this, enum enScreenChangeKind arg2, int32_t arg3) [?mStartChangeScreen@mHRPc@@QAE_NW4enScreenChangeKind@@H@Z]
	uint8_t mStartChangeScreen(enum enScreenChangeKind arg2, int32_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, enum enScreenChangeKind arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x420a10);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBatteryMax(class mHRPc* const this, int16_t arg2, int32_t arg3) [?mSetBatteryMax@mHRPc@@QAEXFH@Z]
	void mSetBatteryMax(int16_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int16_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x420af0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetBatteryRatio(class mHRPc* const this, int32_t arg2) [?mGetBatteryRatio@mHRPc@@QAEMH@Z]
	float mGetBatteryRatio(int32_t arg2)
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x420b30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSubBattery(class mHRPc* const this, int32_t arg2) [?mSubBattery@mHRPc@@QAEXH@Z]
	void mSubBattery(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x420ba0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mAddBattery(class mHRPc* const this, int32_t arg2) [?mAddBattery@mHRPc@@QAEXH@Z]
	void mAddBattery(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x420ca0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mRecoverNoutouWeaponBattery(class mHRPc* const this, int32_t arg2) [?mRecoverNoutouWeaponBattery@mHRPc@@QAEXH@Z]
	void mRecoverNoutouWeaponBattery(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x420db0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionEscape(class mHRPc* const this, int32_t arg2) [?mPlayMotionEscape@mHRPc@@QAE_NH@Z]
	uint8_t mPlayMotionEscape(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x420e70);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetInputGuardSlide(class mHRPc* const this) [?mGetInputGuardSlide@mHRPc@@QAE_NXZ]
	uint8_t mGetInputGuardSlide()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x420f90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestLeftGuard(class mHRPc* const this) [?mTestLeftGuard@mHRPc@@QAE_NXZ]
	uint8_t mTestLeftGuard()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4210c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestRightGuard(class mHRPc* const this) [?mTestRightGuard@mHRPc@@QAE_NXZ]
	uint8_t mTestRightGuard()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421110);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestUpGuard(class mHRPc* const this) [?mTestUpGuard@mHRPc@@QAE_NXZ]
	uint8_t mTestUpGuard()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421160);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetInputTurn(class mHRPc* const this) [?mGetInputTurn@mHRPc@@QAE_NXZ]
	uint8_t mGetInputTurn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4211a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetAttackTimingFrame(class mHRPc* const this, int32_t arg2) [?mGetAttackTimingFrame@mHRPc@@QAEMH@Z]
	float mGetAttackTimingFrame(int32_t arg2)
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x421420);
		return mFunc(this, arg2);
	}
	// [Function] class ghmTriangle* __convention("thiscall") mHRPc::mGetLeftWepTrianglePtr(class mHRPc* const this) [?mGetLeftWepTrianglePtr@mHRPc@@QAEPAVghmTriangle@@XZ]
	class ghmTriangle* mGetLeftWepTrianglePtr()
	{
		typedef class ghmTriangle*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421450);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetExtraComboMotionNo(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mGetExtraComboMotionNo@mHRPc@@UAEHHH@Z]
	int32_t mGetExtraComboMotionNo(int32_t arg2, int32_t arg3)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x421470);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetNormalComboMotionNo(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mGetNormalComboMotionNo@mHRPc@@UAEHHH@Z]
	int32_t mGetNormalComboMotionNo(int32_t arg2, int32_t arg3)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x421490);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetComboKind(class mHRPc* const this) [?mSetComboKind@mHRPc@@UAEXXZ]
	void mSetComboKind()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4214b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mReturnIdleMove(class mHRPc* const this) [?mReturnIdleMove@mHRPc@@QAEXXZ]
	void mReturnIdleMove()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421620);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDashProc(class mHRPc* const this) [?mDashProc@mHRPc@@UAE_NXZ]
	uint8_t mDashProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421760);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDashStartProc(class mHRPc* const this) [?mDashStartProc@mHRPc@@UAEXXZ]
	void mDashStartProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421770);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mForceLanding(class mHRPc* const this) [?mForceLanding@mHRPc@@UAEXXZ]
	void mForceLanding()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421780);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckJumpAttack(class mHRPc* const this) [?mCheckJumpAttack@mHRPc@@UAE_NXZ]
	uint8_t mCheckJumpAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421790);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckJump(class mHRPc* const this) [?mCheckJump@mHRPc@@UAE_NXZ]
	uint8_t mCheckJump()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4217b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mJumpProc(class mHRPc* const this) [?mJumpProc@mHRPc@@UAE_NXZ]
	uint8_t mJumpProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4217c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCheckRouletteAbility(class mHRPc* const this) [?mCheckRouletteAbility@mHRPc@@QAEXXZ]
	void mCheckRouletteAbility()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4217d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPreStartProcessSpecialMode(class mHRPc* const this) [?mPreStartProcessSpecialMode@mHRPc@@QAEXXZ]
	void mPreStartProcessSpecialMode()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421ac0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClear360(class mHRPc* const this) [?mClear360@mHRPc@@QAEXXZ]
	void mClear360()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421b40);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearFire(class mHRPc* const this) [?mClearFire@mHRPc@@QAEXXZ]
	void mClearFire()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421bb0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mClearTiger(class mHRPc* const this) [?mClearTiger@mHRPc@@QAE_NXZ]
	uint8_t mClearTiger()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421bc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearDancingCombo(class mHRPc* const this) [?mClearDancingCombo@mHRPc@@QAEXXZ]
	void mClearDancingCombo()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421cb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearRapidFinish(class mHRPc* const this) [?mClearRapidFinish@mHRPc@@QAEXXZ]
	void mClearRapidFinish()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421d50);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearBullet(class mHRPc* const this) [?mClearBullet@mHRPc@@QAEXXZ]
	void mClearBullet()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421dd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartDarkSide(class mHRPc* const this) [?mStartDarkSide@mHRPc@@QAEXXZ]
	void mStartDarkSide()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421df0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStart360(class mHRPc* const this) [?mStart360@mHRPc@@QAEXXZ]
	void mStart360()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x421fd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartFire(class mHRPc* const this) [?mStartFire@mHRPc@@QAEXXZ]
	void mStartFire()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x422020);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartTiger(class mHRPc* const this) [?mStartTiger@mHRPc@@QAEXXZ]
	void mStartTiger()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x422040);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartDancingCombo(class mHRPc* const this) [?mStartDancingCombo@mHRPc@@QAEXXZ]
	void mStartDancingCombo()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x422150);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartRapidFinish(class mHRPc* const this) [?mStartRapidFinish@mHRPc@@QAEXXZ]
	void mStartRapidFinish()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x422270);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartBullet(class mHRPc* const this) [?mStartBullet@mHRPc@@QAEXXZ]
	void mStartBullet()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x422290);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTigerAttack(class mHRPc* const this) [?mCheckTigerAttack@mHRPc@@QAE_NXZ]
	uint8_t mCheckTigerAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4222c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTermTiger(class mHRPc* const this) [?mTermTiger@mHRPc@@QAE_NXZ]
	uint8_t mTermTiger()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4222e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTigerAttackProc(class mHRPc* const this) [?mTigerAttackProc@mHRPc@@QAEXXZ]
	void mTigerAttackProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4223a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTigerProc(class mHRPc* const this) [?mTigerProc@mHRPc@@QAEXXZ]
	void mTigerProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4229c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTigerAttackInput(class mHRPc* const this) [?mTigerAttackInput@mHRPc@@QAE_NXZ]
	uint8_t mTigerAttackInput()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x422d80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTigerPadInputProc(class mHRPc* const this) [?mTigerPadInputProc@mHRPc@@QAEXXZ]
	void mTigerPadInputProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x422ea0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallTigerSetupMatrix(class mHRPc* const this, float arg2) [?mCallTigerSetupMatrix@mHRPc@@QAEXM@Z]
	void mCallTigerSetupMatrix(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x4230e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallTigerMotionProcess(class mHRPc* const this) [?mCallTigerMotionProcess@mHRPc@@QAEXXZ]
	void mCallTigerMotionProcess()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423200);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateTigerPos(class mHRPc* const this) [?mUpdateTigerPos@mHRPc@@QAEXXZ]
	void mUpdateTigerPos()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423230);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayTigerMotion(class mHRPc* const this, int32_t arg2, uint8_t arg3, float arg4) [?mPlayTigerMotion@mHRPc@@QAE_NH_NM@Z]
	uint8_t mPlayTigerMotion(int32_t arg2, uint8_t arg3, float arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, float arg4);
		_Func mFunc = (_Func)(GameModule + 0x4232a0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearRapidFinishTarget(class mHRPc* const this) [?mClearRapidFinishTarget@mHRPc@@QAEXXZ]
	void mClearRapidFinishTarget()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423360);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetRapidFinishTarget(class mHRPc* const this) [?mSetRapidFinishTarget@mHRPc@@QAEXXZ]
	void mSetRapidFinishTarget()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4233d0);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchRapidFinishNpc(class mHRPc* const this) [?mSearchRapidFinishNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mSearchRapidFinishNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4235b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckResistRapidFinishNpc(class mHRPc* const this, class mHRChara* arg2) [?mCheckResistRapidFinishNpc@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mCheckResistRapidFinishNpc(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x423740);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetRapidFinishNpc(class mHRPc* const this, class mHRChara* arg2) [?mSetRapidFinishNpc@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mSetRapidFinishNpc(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x423770);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGet360Tick(class mHRPc* const this) [?mGet360Tick@mHRPc@@QAEHXZ]
	int32_t mGet360Tick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423800);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetFireTick(class mHRPc* const this) [?mGetFireTick@mHRPc@@QAEHXZ]
	int32_t mGetFireTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423820);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetTigerTick(class mHRPc* const this) [?mGetTigerTick@mHRPc@@QAEHXZ]
	int32_t mGetTigerTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423840);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetDancingComboTick(class mHRPc* const this) [?mGetDancingComboTick@mHRPc@@QAEHXZ]
	int32_t mGetDancingComboTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423860);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetRapidFinishTick(class mHRPc* const this) [?mGetRapidFinishTick@mHRPc@@QAEHXZ]
	int32_t mGetRapidFinishTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423880);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBulletTick(class mHRPc* const this) [?mGetBulletTick@mHRPc@@QAEHXZ]
	int32_t mGetBulletTick()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4238a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetRotInterpolate(class mHRPc* const this) [?mGetRotInterpolate@mHRPc@@QAEMXZ]
	float mGetRotInterpolate()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4238c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckChargeMax(class mHRPc* const this) [?mCheckChargeMax@mHRPc@@QAE_NXZ]
	uint8_t mCheckChargeMax()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423930);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInputBatteryCharge(class mHRPc* const this) [?mCheckInputBatteryCharge@mHRPc@@UAE_NXZ]
	uint8_t mCheckInputBatteryCharge()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423940);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInputGuard(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mCheckInputGuard@mHRPc@@QAE_N_N0@Z]
	uint8_t mCheckInputGuard(uint8_t arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x423a10);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::checkAndUpdateWeaponLength(class mHRPc* const this, class TGmf* arg2) [?checkAndUpdateWeaponLength@mHRPc@@QAEXPAVTGmf@@@Z]
	void checkAndUpdateWeaponLength(class TGmf* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class TGmf* arg2);
		_Func mFunc = (_Func)(GameModule + 0x423a40);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallWepMotionProc(class mHRPc* const this) [?mCallWepMotionProc@mHRPc@@QAEXXZ]
	void mCallWepMotionProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423c60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepMotionRate(class mHRPc* const this, float arg2, int32_t arg3) [?mSetWepMotionRate@mHRPc@@QAEXMH@Z]
	void mSetWepMotionRate(float arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x423cd0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayWepMotion(class mHRPc* const this, int32_t arg2, uint8_t arg3, float arg4, int32_t arg5) [?mPlayWepMotion@mHRPc@@QAEXH_NMH@Z]
	void mPlayWepMotion(int32_t arg2, uint8_t arg3, float arg4, int32_t arg5)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, float arg4, int32_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x423ce0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWeaponLength(class mHRPc* const this) [?mSetWeaponLength@mHRPc@@QAEXXZ]
	void mSetWeaponLength()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423d80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mResumeEasyDemo(class mHRPc* const this) [?mResumeEasyDemo@mHRPc@@QAE_NXZ]
	uint8_t mResumeEasyDemo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423e80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayEasyDemo(class mHRPc* const this, int32_t arg2, int32_t arg3, uint8_t arg4) [?mPlayEasyDemo@mHRPc@@QAE_NHH_N@Z]
	uint8_t mPlayEasyDemo(int32_t arg2, int32_t arg3, uint8_t arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x423ea0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayNoutouDemo(class mHRPc* const this) [?mPlayNoutouDemo@mHRPc@@QAE_NXZ]
	uint8_t mPlayNoutouDemo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x423f80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayBattouDemo(class mHRPc* const this) [?mPlayBattouDemo@mHRPc@@QAE_NXZ]
	uint8_t mPlayBattouDemo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4241d0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBattouEndMotion(class mHRPc* const this) [?mGetBattouEndMotion@mHRPc@@QAEHXZ]
	int32_t mGetBattouEndMotion()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4248b0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBattouLoopMotion(class mHRPc* const this) [?mGetBattouLoopMotion@mHRPc@@QAEHXZ]
	int32_t mGetBattouLoopMotion()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x424910);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetCmbNumMax(class mHRPc* const this) [?mGetCmbNumMax@mHRPc@@QAEEXZ]
	uint8_t mGetCmbNumMax()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x424970);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateLockOnDummyLocate(class mHRPc* const this) [?mUpdateLockOnDummyLocate@mHRPc@@QAEXXZ]
	void mUpdateLockOnDummyLocate()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4249c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLockOnDummyAtOutOfRange(class mHRPc* const this) [?mSetLockOnDummyAtOutOfRange@mHRPc@@QAEXXZ]
	void mSetLockOnDummyAtOutOfRange()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x424a60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateWatchNpc(class mHRPc* const this) [?mUpdateWatchNpc@mHRPc@@QAEXXZ]
	void mUpdateWatchNpc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x424b60);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateLockOnTarget(class mHRPc* const this) [?mUpdateLockOnTarget@mHRPc@@QAEXXZ]
	void mUpdateLockOnTarget()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x424c00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateLockOnList(class mHRPc* const this, uint8_t arg2) [?mUpdateLockOnList@mHRPc@@QAEX_N@Z]
	void mUpdateLockOnList(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4250e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mRotate2LockOnTarget(class mHRPc* const this) [?mRotate2LockOnTarget@mHRPc@@QAEXXZ]
	void mRotate2LockOnTarget()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4256a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetLockOn(class mHRPc* const this) [?mSetLockOn@mHRPc@@QAEXXZ]
	void mSetLockOn()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4257b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLockOnDummy(class mHRPc* const this) [?mCheckLockOnDummy@mHRPc@@QAE_NXZ]
	uint8_t mCheckLockOnDummy()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x425800);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mInitLockOn(class mHRPc* const this) [?mInitLockOn@mHRPc@@QAEXXZ]
	void mInitLockOn()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x425820);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDarkSideSonicProc(class mHRPc* const this) [?mDarkSideSonicProc@mHRPc@@QAEXXZ]
	void mDarkSideSonicProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x425920);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::bootGuardLightFlashEffect(class mHRPc* const this, struct Vec& arg2) [?bootGuardLightFlashEffect@mHRPc@@QAEXABUVec@@@Z]
	void bootGuardLightFlashEffect(struct Vec& arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, struct Vec& arg2);
		_Func mFunc = (_Func)(GameModule + 0x425bd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::LaserScaleProc(class mHRPc* const this) [?LaserScaleProc@mHRPc@@QAEXXZ]
	void LaserScaleProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x425c00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mEffectProc(class mHRPc* const this) [?mEffectProc@mHRPc@@UAEXXZ]
	void mEffectProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x425d20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestBeamKatanaShowyEffect(class mHRPc* const this) [?mTestBeamKatanaShowyEffect@mHRPc@@QAE_NXZ]
	uint8_t mTestBeamKatanaShowyEffect()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4274f0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetCatchDistance(class mHRPc* const this) [?mGetCatchDistance@mHRPc@@QAEMXZ]
	float mGetCatchDistance()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x427520);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetMotionSpeed(class mHRPc* const this) [?mGetMotionSpeed@mHRPc@@QAEMXZ]
	float mGetMotionSpeed()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x427530);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetFinishMotionSpeed(class mHRPc* const this) [?mSetFinishMotionSpeed@mHRPc@@QAEXXZ]
	void mSetFinishMotionSpeed()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4275e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTargetObject(class mHRPc* const this, class mHRChara* arg2) [?mCheckTargetObject@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mCheckTargetObject(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x427d40);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchAttackTargetNpc(class mHRPc* const this, float arg2, uint8_t arg3) [?mSearchAttackTargetNpc@mHRPc@@QAEPAVmHRChara@@M_N@Z]
	class mHRChara* mSearchAttackTargetNpc(float arg2, uint8_t arg3)
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x427d50);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchDarkSideWarpTargetNpc(class mHRPc* const this) [?mSearchDarkSideWarpTargetNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mSearchDarkSideWarpTargetNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x427f00);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchNearNpc(class mHRPc* const this, float arg2) [?mSearchNearNpc@mHRPc@@QAEPAVmHRChara@@M@Z]
	class mHRChara* mSearchNearNpc(float arg2)
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x428080);
		return mFunc(this, arg2);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mLookAttackTargetNpc(class mHRPc* const this) [?mLookAttackTargetNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mLookAttackTargetNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x428160);
		return mFunc(this);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mLockNearNpc(class mHRPc* const this, float arg2, class mHRChara* arg3) [?mLockNearNpc@mHRPc@@QAEPAVmHRChara@@MPAV2@@Z]
	class mHRChara* mLockNearNpc(float arg2, class mHRChara* arg3)
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2, class mHRChara* arg3);
		_Func mFunc = (_Func)(GameModule + 0x428350);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mLockNearCatchNpc(class mHRPc* const this, float arg2, uint8_t arg3) [?mLockNearCatchNpc@mHRPc@@QAEPAVmHRChara@@M_N@Z]
	class mHRChara* mLockNearCatchNpc(float arg2, uint8_t arg3)
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x4283b0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mAddKillNpcCombo(class mHRPc* const this, class mHRChara* arg2) [?mAddKillNpcCombo@mHRPc@@QAEXPAVmHRChara@@@Z]
	void mAddKillNpcCombo(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x428510);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mIntiFinishNpc(class mHRPc* const this, uint8_t arg2) [?mIntiFinishNpc@mHRPc@@QAEX_N@Z]
	void mIntiFinishNpc(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x428540);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDarkSideTarget(class mHRPc* const this) [?mSetDarkSideTarget@mHRPc@@QAEXXZ]
	void mSetDarkSideTarget()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4286c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mInputDarkSideSuccess(class mHRPc* const this) [?mInputDarkSideSuccess@mHRPc@@QAEXXZ]
	void mInputDarkSideSuccess()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x428860);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPcMoveFrontOfNpc4DarkSideMode(class mHRPc* const this, class mHRChara* arg2) [?mPcMoveFrontOfNpc4DarkSideMode@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mPcMoveFrontOfNpc4DarkSideMode(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x428870);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPcMoveFrontOfNpc(class mHRPc* const this, class mHRChara* arg2, uint8_t arg3, int32_t arg4) [?mPcMoveFrontOfNpc@mHRPc@@QAE_NPAVmHRChara@@_NH@Z]
	uint8_t mPcMoveFrontOfNpc(class mHRChara* arg2, uint8_t arg3, int32_t arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2, uint8_t arg3, int32_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x428880);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class mHRChara* __convention("thiscall") mHRPc::mSearchNextNpc(class mHRPc* const this) [?mSearchNextNpc@mHRPc@@QAEPAVmHRChara@@XZ]
	class mHRChara* mSearchNextNpc()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x428aa0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishMode(class mHRPc* const this, class mHRChara* arg2) [?mCheckFinishMode@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mCheckFinishMode(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x428c00);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mPrepareInputFinish(class mHRPc* const this, class mHRChara* arg2) [?mPrepareInputFinish@mHRPc@@QAEXPAVmHRChara@@@Z]
	void mPrepareInputFinish(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x428d30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetIntoTsubazeriai(class mHRPc* const this, class mHRChara* arg2) [?mSetIntoTsubazeriai@mHRPc@@QAEXPAVmHRChara@@@Z]
	void mSetIntoTsubazeriai(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x429140);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSePlayUpperAttack(class mHRPc* const this) [?mSePlayUpperAttack@mHRPc@@QAEXXZ]
	void mSePlayUpperAttack()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x429500);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTameAttckProc(class mHRPc* const this) [?mTameAttckProc@mHRPc@@QAE_NXZ]
	uint8_t mTameAttckProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x429590);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mJoyuuLight(class mHRPc* const this, uint8_t arg2) [?mJoyuuLight@mHRPc@@QAEX_N@Z]
	void mJoyuuLight(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4295a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSlotResult(class mHRPc* const this, int16_t arg2) [?mSlotResult@mHRPc@@QAE_NF@Z]
	uint8_t mSlotResult(int16_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int16_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x429a60);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAttackHitCheck(class mHRPc* const this) [?mAttackHitCheck@mHRPc@@QAE_NXZ]
	uint8_t mAttackHitCheck()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x429e90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAttackProc(class mHRPc* const this) [?mAttackProc@mHRPc@@UAE_NXZ]
	uint8_t mAttackProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x42c990);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mFailedInputFinishProcessForVsBoss(class mHRPc* const this) [?mFailedInputFinishProcessForVsBoss@mHRPc@@QAEXXZ]
	void mFailedInputFinishProcessForVsBoss()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x42f740);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSpecialFightAttackProc(class mHRPc* const this) [?mSpecialFightAttackProc@mHRPc@@QAE_NXZ]
	uint8_t mSpecialFightAttackProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x42f7b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckComboAttackInput(class mHRPc* const this) [?mCheckComboAttackInput@mHRPc@@QAE_NXZ]
	uint8_t mCheckComboAttackInput()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x42fbd0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTrvStartDownAttack(class mHRPc* const this, class mHRChara* arg2) [?mTrvStartDownAttack@mHRPc@@QAEXPAVmHRChara@@@Z]
	void mTrvStartDownAttack(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x430160);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartFightAttack(class mHRPc* const this) [?mStartFightAttack@mHRPc@@QAEXXZ]
	void mStartFightAttack()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4304e0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAttackMotionStartFrame30fps(class mHRPc* const this, int32_t arg2) [?mGetAttackMotionStartFrame30fps@mHRPc@@QAEHH@Z]
	int32_t mGetAttackMotionStartFrame30fps(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x430560);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanCatchNpc(class mHRPc* const this, uint8_t arg2) [?mCheckCanCatchNpc@mHRPc@@QAE_N_N@Z]
	uint8_t mCheckCanCatchNpc(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4305a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetSEPlayShakeInputSuccess(class mHRPc* const this) [?mSetSEPlayShakeInputSuccess@mHRPc@@QAEXXZ]
	void mSetSEPlayShakeInputSuccess()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4305f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayFinishMotion(class mHRPc* const this) [?mPlayFinishMotion@mHRPc@@QAEXXZ]
	void mPlayFinishMotion()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x430610);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSuccessFinishInput(class mHRPc* const this) [?mSuccessFinishInput@mHRPc@@QAEXXZ]
	void mSuccessFinishInput()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x430680);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mFinishMotionFrameKetaAge(class mHRPc* const this) [?mFinishMotionFrameKetaAge@mHRPc@@QAEXXZ]
	void mFinishMotionFrameKetaAge()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x430a00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayNunchackAttackMotion(class mHRPc* const this) [?mPlayNunchackAttackMotion@mHRPc@@QAEXXZ]
	void mPlayNunchackAttackMotion()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x430a10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearNpcDamageInfo(class mHRPc* const this) [?mClearNpcDamageInfo@mHRPc@@QAEXXZ]
	void mClearNpcDamageInfo()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x430ba0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetHjkDir(class mHRPc* const this) [?mGetHjkDir@mHRPc@@QAEHXZ]
	int32_t mGetHjkDir()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x430bd0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetFinishAtkMotNo(class mHRPc* const this) [?mGetFinishAtkMotNo@mHRPc@@QAEHXZ]
	int32_t mGetFinishAtkMotNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x430c70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSearchThrow(class mHRPc* const this, int32_t arg2, int32_t* arg3) [?mSearchThrow@mHRPc@@QAE_NHPAH@Z]
	uint8_t mSearchThrow(int32_t arg2, int32_t* arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, int32_t* arg3);
		_Func mFunc = (_Func)(GameModule + 0x430e50);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetPcThrowMotNo(class mHRPc* const this, enum enThrowDir arg2, class mHRChara* arg3, int32_t* arg4) [?mGetPcThrowMotNo@mHRPc@@QAEHW4enThrowDir@@PAVmHRChara@@PAH@Z]
	int32_t mGetPcThrowMotNo(enum enThrowDir arg2, class mHRChara* arg3, int32_t* arg4)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, enum enThrowDir arg2, class mHRChara* arg3, int32_t* arg4);
		_Func mFunc = (_Func)(GameModule + 0x430e80);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetThrowDamageMotion(class mHRPc* const this, class mHRChara* arg2, int32_t* arg3) [?mGetThrowDamageMotion@mHRPc@@QAEHPAVmHRChara@@PAH@Z]
	int32_t mGetThrowDamageMotion(class mHRChara* arg2, int32_t* arg3)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2, int32_t* arg3);
		_Func mFunc = (_Func)(GameModule + 0x431500);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetPcThrowMotNo4ZakoB(class mHRPc* const this, int32_t* arg2) [?mGetPcThrowMotNo4ZakoB@mHRPc@@QAEHPAH@Z]
	int32_t mGetPcThrowMotNo4ZakoB(int32_t* arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t* arg2);
		_Func mFunc = (_Func)(GameModule + 0x4316a0);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetPcThrowMotNo4ZakoF(class mHRPc* const this, int32_t* arg2) [?mGetPcThrowMotNo4ZakoF@mHRPc@@QAEHPAH@Z]
	int32_t mGetPcThrowMotNo4ZakoF(int32_t* arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t* arg2);
		_Func mFunc = (_Func)(GameModule + 0x431820);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckThrowSpace(class mHRPc* const this, struct Vec arg2) [?mCheckThrowSpace@mHRPc@@QAE_NUVec@@@Z]
	uint8_t mCheckThrowSpace(struct Vec arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, struct Vec arg2);
		_Func mFunc = (_Func)(GameModule + 0x431970);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetDownAtkMotNo(class mHRPc* const this) [?mGetDownAtkMotNo@mHRPc@@QAEHXZ]
	int32_t mGetDownAtkMotNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x431a90);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetNextAtkMotNo(class mHRPc* const this) [?mGetNextAtkMotNo@mHRPc@@QAEHXZ]
	int32_t mGetNextAtkMotNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x431ae0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mAttackRestoreProc(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mAttackRestoreProc@mHRPc@@QAEX_N0@Z]
	void mAttackRestoreProc(uint8_t arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x431b20);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mAttackStoreProc(class mHRPc* const this, uint8_t arg2) [?mAttackStoreProc@mHRPc@@QAEX_N@Z]
	void mAttackStoreProc(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x431fd0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetCombo(class mHRPc* const this) [?mResetCombo@mHRPc@@QAEXXZ]
	void mResetCombo()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x432060);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mChangeWep(class mHRPc* const this) [?mChangeWep@mHRPc@@QAE_NXZ]
	uint8_t mChangeWep()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4320e0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mWepSeReleaseRequest(class mHRPc* const this) [?mWepSeReleaseRequest@mHRPc@@QAE_NXZ]
	uint8_t mWepSeReleaseRequest()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x432160);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mInitWepStatus(class mHRPc* const this) [?mInitWepStatus@mHRPc@@QAEXXZ]
	void mInitWepStatus()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4321b0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetWepIndex(class mHRPc* const this, int32_t arg2) [?mGetWepIndex@mHRPc@@QAEHH@Z]
	int32_t mGetWepIndex(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x432250);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAtkNo(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mGetAtkNo@mHRPc@@QAEHH_N@Z]
	int32_t mGetAtkNo(int32_t arg2, uint8_t arg3)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x432280);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSideStepProc(class mHRPc* const this, int32_t arg2, int32_t arg3) [?mSideStepProc@mHRPc@@QAE_NHH@Z]
	uint8_t mSideStepProc(int32_t arg2, int32_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x4330a0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetRollEscMotNo(class mHRPc* const this, int32_t arg2) [?mGetRollEscMotNo@mHRPc@@UAEHH@Z]
	int32_t mGetRollEscMotNo(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4332f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mMoveProc(class mHRPc* const this, float arg2, uint8_t arg3, uint8_t arg4) [?mMoveProc@mHRPc@@QAE_NM_N0@Z]
	uint8_t mMoveProc(float arg2, uint8_t arg3, uint8_t arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2, uint8_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x433340);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetPcWillDirectRotY(class mHRPc* const this) [?mGetPcWillDirectRotY@mHRPc@@QAEMXZ]
	float mGetPcWillDirectRotY()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434250);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetRunSpeed(class mHRPc* const this) [?mGetRunSpeed@mHRPc@@QAEMXZ]
	float mGetRunSpeed()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4343a0);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetWalkSpeed(class mHRPc* const this) [?mGetWalkSpeed@mHRPc@@QAEMXZ]
	float mGetWalkSpeed()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4343b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mMoveCommon(class mHRPc* const this) [?mMoveCommon@mHRPc@@QAEXXZ]
	void mMoveCommon()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4343c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mLockOnMoveProc(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mLockOnMoveProc@mHRPc@@QAE_NUVec@@_N@Z]
	uint8_t mLockOnMoveProc(int32_t arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x4343d0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mUpdateAtkColl(class mHRPc* const this) [?mUpdateAtkColl@mHRPc@@UAEXXZ]
	void mUpdateAtkColl()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434550);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartChargeEffect(class mHRPc* const this) [?mStartChargeEffect@mHRPc@@QAEXXZ]
	void mStartChargeEffect()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434830);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPreResetChargeAttack(class mHRPc* const this) [?mPreResetChargeAttack@mHRPc@@QAEXXZ]
	void mPreResetChargeAttack()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434900);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLastTarget(class mHRPc* const this, class mHRChara* arg2) [?mCheckLastTarget@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mCheckLastTarget(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x434a90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBDash(class mHRPc* const this, int32_t arg2) [?mCheckBDash@mHRPc@@QAE_NH@Z]
	uint8_t mCheckBDash(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x434aa0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckChangeWeapon(class mHRPc* const this, int32_t arg2) [?mCheckChangeWeapon@mHRPc@@QAE_NH@Z]
	uint8_t mCheckChangeWeapon(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x434ac0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckWakeUpZako(class mHRPc* const this, int32_t arg2) [?mCheckWakeUpZako@mHRPc@@QAE_NH@Z]
	uint8_t mCheckWakeUpZako(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x434ae0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckSchool3RapidAttack(class mHRPc* const this) [?mCheckSchool3RapidAttack@mHRPc@@QAE_NXZ]
	uint8_t mCheckSchool3RapidAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434af0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBackAttack(class mHRPc* const this, int32_t arg2) [?mCheckBackAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckBackAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x434b40);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mCheckInputDirection4Pc(class mHRPc* const this) [?mCheckInputDirection4Pc@mHRPc@@QAEHXZ]
	int32_t mCheckInputDirection4Pc()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434b50);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckThrowInput(class mHRPc* const this) [?mCheckThrowInput@mHRPc@@QAE_NXZ]
	uint8_t mCheckThrowInput()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434d90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInputCombo(class mHRPc* const this) [?mCheckInputCombo@mHRPc@@QAE_NXZ]
	uint8_t mCheckInputCombo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434dc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFollowThorough(class mHRPc* const this) [?mCheckFollowThorough@mHRPc@@QAE_NXZ]
	uint8_t mCheckFollowThorough()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x434de0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckSantDash(class mHRPc* const this, int32_t arg2) [?mCheckSantDash@mHRPc@@QAE_NH@Z]
	uint8_t mCheckSantDash(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x434e90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNormalAttack(class mHRPc* const this, int32_t arg2) [?mCheckNormalAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckNormalAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x434ea0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNormalDashAttack(class mHRPc* const this, int32_t arg2) [?mCheckNormalDashAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckNormalDashAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4350f0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheck777Bomb(class mHRPc* const this, int32_t arg2) [?mCheck777Bomb@mHRPc@@QAE_NH@Z]
	uint8_t mCheck777Bomb(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435100);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheck777BombStart(class mHRPc* const this, int32_t arg2) [?mCheck777BombStart@mHRPc@@QAE_NH@Z]
	uint8_t mCheck777BombStart(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435110);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckIdling(class mHRPc* const this, int32_t arg2) [?mCheckIdling@mHRPc@@QAE_NH@Z]
	uint8_t mCheckIdling(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435120);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckIdlingMotion(class mHRPc* const this, int32_t arg2) [?mCheckIdlingMotion@mHRPc@@QAE_NH@Z]
	uint8_t mCheckIdlingMotion(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435170);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckRollEscape(class mHRPc* const this, int32_t arg2) [?mCheckRollEscape@mHRPc@@UAE_NH@Z]
	uint8_t mCheckRollEscape(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4351d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGuard(class mHRPc* const this) [?mCheckGuard@mHRPc@@UAE_NXZ]
	uint8_t mCheckGuard()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4351f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckChargeUpDown(class mHRPc* const this, int32_t arg2) [?mCheckChargeUpDown@mHRPc@@QAE_NH@Z]
	uint8_t mCheckChargeUpDown(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4357b0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCharge(class mHRPc* const this, uint8_t arg2) [?mCheckCharge@mHRPc@@UAE_N_N@Z]
	uint8_t mCheckCharge(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435860);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanCancelLastCombo(class mHRPc* const this) [?mCheckCanCancelLastCombo@mHRPc@@QAE_NXZ]
	uint8_t mCheckCanCancelLastCombo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x435980);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLastCombo(class mHRPc* const this) [?mCheckLastCombo@mHRPc@@QAE_NXZ]
	uint8_t mCheckLastCombo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4359b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckStrongComboAttack(class mHRPc* const this) [?mCheckStrongComboAttack@mHRPc@@QAE_NXZ]
	uint8_t mCheckStrongComboAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x435a10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckPiyoriComboAttack(class mHRPc* const this) [?mCheckPiyoriComboAttack@mHRPc@@QAE_NXZ]
	uint8_t mCheckPiyoriComboAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x435a30);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNockBack(class mHRPc* const this, int32_t arg2) [?mCheckNockBack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckNockBack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435a50);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDown2StandUp(class mHRPc* const this, int32_t arg2) [?mCheckDown2StandUp@mHRPc@@QAE_NH@Z]
	uint8_t mCheckDown2StandUp(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435a90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDown(class mHRPc* const this, int32_t arg2) [?mCheckDown@mHRPc@@QAE_NH@Z]
	uint8_t mCheckDown(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435ac0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBlowStatus(class mHRPc* const this) [?mCheckBlowStatus@mHRPc@@QAE_NXZ]
	uint8_t mCheckBlowStatus()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x435b00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBombAttack(class mHRPc* const this, int32_t arg2) [?mCheckBombAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckBombAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435b90);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckJumpThrustAttack(class mHRPc* const this, int32_t arg2) [?mCheckJumpThrustAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckJumpThrustAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435ba0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckChargeAttack(class mHRPc* const this, int32_t arg2) [?mCheckChargeAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckChargeAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435bb0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNunchackAttack(class mHRPc* const this, int32_t arg2) [?mCheckNunchackAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckNunchackAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435d50);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckRangeAttack(class mHRPc* const this, int32_t arg2) [?mCheckRangeAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckRangeAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435d80);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckThrowBeforeAttack(class mHRPc* const this, int32_t arg2) [?mCheckThrowBeforeAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckThrowBeforeAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435db0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCatchMiss(class mHRPc* const this, int32_t arg2) [?mCheckCatchMiss@mHRPc@@QAE_NH@Z]
	uint8_t mCheckCatchMiss(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x435dd0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mStartCatchAttack(class mHRPc* const this, class mHRChara* arg2) [?mStartCatchAttack@mHRPc@@QAE_NPAVmHRChara@@@Z]
	uint8_t mStartCatchAttack(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x435e10);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDownAttack(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mCheckDownAttack@mHRPc@@QAE_NH_N@Z]
	uint8_t mCheckDownAttack(int32_t arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x435f70);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFightCmbAttack(class mHRPc* const this) [?mCheckFightCmbAttack@mHRPc@@QAE_NXZ]
	uint8_t mCheckFightCmbAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4360c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCityFightAttack(class mHRPc* const this, int32_t arg2) [?mCheckCityFightAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckCityFightAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4360e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanAttack(class mHRPc* const this) [?mCheckCanAttack@mHRPc@@UAE_NXZ]
	uint8_t mCheckCanAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4360f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckAttackHit(class mHRPc* const this) [?mCheckAttackHit@mHRPc@@UAE_NXZ]
	uint8_t mCheckAttackHit()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436400);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckAttack(class mHRPc* const this) [?mCheckAttack@mHRPc@@UAE_NXZ]
	uint8_t mCheckAttack()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436580);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetHajikareWait(class mHRPc* const this) [?mSetHajikareWait@mHRPc@@QAEXXZ]
	void mSetHajikareWait()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436660);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckHajikareWait(class mHRPc* const this) [?mCheckHajikareWait@mHRPc@@QAE_NXZ]
	uint8_t mCheckHajikareWait()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4366d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetGuardWait(class mHRPc* const this, float arg2) [?mSetGuardWait@mHRPc@@QAEXM@Z]
	void mSetGuardWait(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x4366e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGuardWait(class mHRPc* const this, int32_t arg2) [?mCheckGuardWait@mHRPc@@QAE_NH@Z]
	uint8_t mCheckGuardWait(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x436720);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckHajikare(class mHRPc* const this) [?mCheckHajikare@mHRPc@@QAE_NXZ]
	uint8_t mCheckHajikare()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436750);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGuardMotion(class mHRPc* const this, uint8_t arg2) [?mCheckGuardMotion@mHRPc@@UAE_N_N@Z]
	uint8_t mCheckGuardMotion(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x436790);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mCheckRestorePadOffset(class mHRPc* const this) [?mCheckRestorePadOffset@mHRPc@@QAEXXZ]
	void mCheckRestorePadOffset()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436820);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetPadOffset(class mHRPc* const this) [?mResetPadOffset@mHRPc@@QAEXXZ]
	void mResetPadOffset()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436a20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetNeedShakeDir(class mHRPc* const this) [?mSetNeedShakeDir@mHRPc@@QAEXXZ]
	void mSetNeedShakeDir()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436a90);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckContinueCombo(class mHRPc* const this) [?mCheckContinueCombo@mHRPc@@QAE_NXZ]
	uint8_t mCheckContinueCombo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436ba0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckAtkUpper(class mHRPc* const this) [?mCheckAtkUpper@mHRPc@@QAE_NXZ]
	uint8_t mCheckAtkUpper()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436d10);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetChargeMotionNo(class mHRPc* const this) [?mGetChargeMotionNo@mHRPc@@QAEHXZ]
	int32_t mGetChargeMotionNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x436d30);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetUpChargeAttackMotionNo(class mHRPc* const this) [?mGetUpChargeAttackMotionNo@mHRPc@@QAEHXZ]
	int32_t mGetUpChargeAttackMotionNo()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4370c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetCatch(class mHRPc* const this) [?mResetCatch@mHRPc@@QAEXXZ]
	void mResetCatch()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x437110);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTsubaOuterMotion(class mHRPc* const this, uint8_t arg2, int32_t arg3) [?mSetTsubaOuterMotion@mHRPc@@QAEX_NH@Z]
	void mSetTsubaOuterMotion(uint8_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x4371e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetTsubaDat(class mHRPc* const this, int32_t arg2, uint8_t arg3) [?mSetTsubaDat@mHRPc@@QAEXHE@Z]
	void mSetTsubaDat(int32_t arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x437210);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mTsubazeriaiProc(class mHRPc* const this) [?mTsubazeriaiProc@mHRPc@@QAEXXZ]
	void mTsubazeriaiProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4372f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGuardDamageProc(class mHRPc* const this) [?mGuardDamageProc@mHRPc@@QAE_NXZ]
	uint8_t mGuardDamageProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4378a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mDamageProc(class mHRPc* const this) [?mDamageProc@mHRPc@@UAE_NXZ]
	uint8_t mDamageProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x437c10);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetAttackDistance(class mHRPc* const this) [?mGetAttackDistance@mHRPc@@QAEMXZ]
	float mGetAttackDistance()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x437c20);
		return mFunc(this);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetAttackDirection(class mHRPc* const this) [?mGetAttackDirection@mHRPc@@UAEMXZ]
	float mGetAttackDirection()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x437c60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestRunMotion(class mHRPc* const this) [?mTestRunMotion@mHRPc@@UAE_NXZ]
	uint8_t mTestRunMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x437ca0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDamageMotion(class mHRPc* const this) [?mCheckDamageMotion@mHRPc@@UAE_NXZ]
	uint8_t mCheckDamageMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x437d10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanHit(class mHRPc* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mCheckCanHit@mHRPc@@UAE_NH_N0@Z]
	uint8_t mCheckCanHit(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x437d90);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mHitCheck(class mHRPc* const this, class mHRChara* arg2) [?mHitCheck@mHRPc@@UAE_NPAVmHRChara@@@Z]
	uint8_t mHitCheck(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x438070);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetElectricDamage(class mHRPc* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, int32_t arg11) [?mSetElectricDamage@mHRPc@@QAE_NMHHHMHMMPAVmHRChara@@H@Z]
	uint8_t mSetElectricDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, int32_t arg11)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, int32_t arg11);
		_Func mFunc = (_Func)(GameModule + 0x4382a0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetDamage(class mHRPc* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@mHRPc@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x438330);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mJudgeJustGuardInput(class mHRPc* const this) [?mJudgeJustGuardInput@mHRPc@@QAE_NXZ]
	uint8_t mJudgeJustGuardInput()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4398f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mJudgePiyori(class mHRPc* const this, float arg2) [?mJudgePiyori@mHRPc@@QAE_NM@Z]
	uint8_t mJudgePiyori(float arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x439940);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mConvertGuardMotion(class mHRPc* const this, int32_t arg2, class mHRChara* arg3) [?mConvertGuardMotion@mHRPc@@QAEHHPAVmHRChara@@@Z]
	int32_t mConvertGuardMotion(int32_t arg2, class mHRChara* arg3)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, class mHRChara* arg3);
		_Func mFunc = (_Func)(GameModule + 0x439ab0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetDamageIK(class mHRPc* const this, class mHRChara* arg2, uint8_t arg3) [?mSetDamageIK@mHRPc@@QAEXPAVmHRChara@@_N@Z]
	void mSetDamageIK(class mHRChara* arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, class mHRChara* arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x439f90);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckAutoGuard(class mHRPc* const this) [?mCheckAutoGuard@mHRPc@@QAE_NXZ]
	uint8_t mCheckAutoGuard()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x439fd0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanGuard(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mCheckCanGuard@mHRPc@@QAE_N_N0@Z]
	uint8_t mCheckCanGuard(uint8_t arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x43a010);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBtlCommonMotNo(class mHRPc* const this, int32_t arg2) [?mGetBtlCommonMotNo@mHRPc@@UAEHH@Z]
	int32_t mGetBtlCommonMotNo(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43a160);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepEffectVisible(class mHRPc* const this, uint8_t arg2) [?mSetWepEffectVisible@mHRPc@@UAEX_N@Z]
	void mSetWepEffectVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43a1d0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepVisible(class mHRPc* const this, uint8_t arg2) [?mSetWepVisible@mHRPc@@UAEX_N@Z]
	void mSetWepVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43a350);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetVisible(class mHRPc* const this, uint8_t arg2) [?mSetVisible@mHRPc@@UAEX_N@Z]
	void mSetVisible(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43a460);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCamera2TrvBack(class mHRPc* const this) [?mSetCamera2TrvBack@mHRPc@@QAEXXZ]
	void mSetCamera2TrvBack()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43a4a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetCameraInit(class mHRPc* const this) [?mSetCameraInit@mHRPc@@QAEXXZ]
	void mSetCameraInit()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43a4c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallCameraInit(class mHRPc* const this) [?mCallCameraInit@mHRPc@@QAEXXZ]
	void mCallCameraInit()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43a520);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCameraInitProcess(class mHRPc* const this) [?mCameraInitProcess@mHRPc@@QAEXXZ]
	void mCameraInitProcess()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43a550);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallTsubaBrendMotPorc(class mHRPc* const this, int32_t arg2, char arg3) [?mCallTsubaBrendMotPorc@mHRPc@@QAEXHC@Z]
	void mCallTsubaBrendMotPorc(int32_t arg2, char arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, char arg3);
		_Func mFunc = (_Func)(GameModule + 0x43a620);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallCulcBrendRate(class mHRPc* const this, uint8_t arg2) [?mCallCulcBrendRate@mHRPc@@QAEX_N@Z]
	void mCallCulcBrendRate(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43b3f0);
		return mFunc(this, arg2);
	}
	// [Function] class ghmGcCollObjCapsule* __convention("thiscall") mHRPc::mGetCollPtr(class mHRPc* const this) [?mGetCollPtr@mHRPc@@UAEPAVghmGcCollObjCapsule@@XZ]
	class ghmGcCollObjCapsule* mGetCollPtr()
	{
		typedef class ghmGcCollObjCapsule*(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43b560);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mBossDeadCommonProcess(class mHRPc* const this) [?mBossDeadCommonProcess@mHRPc@@UAEXXZ]
	void mBossDeadCommonProcess()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43b5b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayBattleIdolMotion(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mPlayBattleIdolMotion@mHRPc@@QAE_N_N0@Z]
	uint8_t mPlayBattleIdolMotion(uint8_t arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x43b5e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetValueAtPlayMotion(class mHRPc* const this) [?mResetValueAtPlayMotion@mHRPc@@QAEXXZ]
	void mResetValueAtPlayMotion()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43b650);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionBlend(class mHRPc* const this, class TGan** arg2, char arg3) [?mPlayMotionBlend@mHRPc@@UAE_NPAPAVTGan@@C@Z]
	uint8_t mPlayMotionBlend(class TGan** arg2, char arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class TGan** arg2, char arg3);
		_Func mFunc = (_Func)(GameModule + 0x43b680);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotion(class mHRPc* const this, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6) [?mPlayMotion@mHRPc@@UAE_NH_NH0M@Z]
	uint8_t mPlayMotion(int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6);
		_Func mFunc = (_Func)(GameModule + 0x43b810);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] class TGan** __convention("thiscall") mHRPc::mGetAtkMotPPtr(class mHRPc* const this, int32_t arg2) [?mGetAtkMotPPtr@mHRPc@@QAEPAPAVTGan@@H@Z]
	// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetAtkMotPPtr(int32_t arg2)
	{
		typedef class TGan**(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43c300);
		mFunc(this, arg2);
	}
	// [Function] class TGan* __convention("thiscall") mHRPc::mGetAtkMotPtr(class mHRPc* const this, int32_t arg2) [?mGetAtkMotPtr@mHRPc@@QAEPAVTGan@@H@Z]
	class TGan* mGetAtkMotPtr(int32_t arg2)
	{
		typedef class TGan*(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43c3e0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mRequestReadAtkMot(class mHRPc* const this) [?mRequestReadAtkMot@mHRPc@@QAE_NXZ]
	uint8_t mRequestReadAtkMot()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43c4b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mReleaseAtkMot(class mHRPc* const this) [?mReleaseAtkMot@mHRPc@@QAE_NXZ]
	uint8_t mReleaseAtkMot()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43c520);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNeedModelRead(class mHRPc* const this, int32_t arg2) [?mCheckNeedModelRead@mHRPc@@QAE_NH@Z]
	uint8_t mCheckNeedModelRead(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43c570);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mChangeTShirtModel(class mHRPc* const this, int32_t arg2) [?mChangeTShirtModel@mHRPc@@QAE_NH@Z]
	uint8_t mChangeTShirtModel(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43c850);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetNoWearJacket(class mHRPc* const this, uint8_t arg2) [?mSetNoWearJacket@mHRPc@@QAE_N_N@Z]
	uint8_t mSetNoWearJacket(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43c990);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mControlDispWestWeapon(class mHRPc* const this, int32_t arg2, char* arg3) [?mControlDispWestWeapon@mHRPc@@QAEXHPAD@Z]
	void mControlDispWestWeapon(int32_t arg2, char* arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, char* arg3);
		_Func mFunc = (_Func)(GameModule + 0x43c9e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mDetachWeapon(class mHRPc* const this, int32_t arg2) [?mDetachWeapon@mHRPc@@QAEXH@Z]
	void mDetachWeapon(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43caa0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mAttachWeapon(class mHRPc* const this, int32_t arg2) [?mAttachWeapon@mHRPc@@QAEXH@Z]
	void mAttachWeapon(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43cb10);
		return mFunc(this, arg2);
	}
	// [Function] void mHRPc::mRenderFpsCursor(void* arg1) [?mRenderFpsCursor@mHRPc@@SAXPAX@Z]
	static void mRenderFpsCursor(void* arg1)
	{
		typedef void(__fastcall* _Func)(void* arg1);
		_Func mFunc = (_Func)(GameModule + 0x43cc10);
		return mFunc(arg1);
	}
	// [Function] void __convention("thiscall") mHRPc::mAddTension(class mHRPc* const this, float arg2) [?mAddTension@mHRPc@@UAEXM@Z]
	void mAddTension(float arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x43cca0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWarpPos(class mHRPc* const this, struct Vec& arg2, uint8_t arg3) [?mSetWarpPos@mHRPc@@UAEXABUVec@@_N@Z]
	void mSetWarpPos(struct Vec& arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, struct Vec& arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x43cd20);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mRenderShadowProc(class mHRPc* const this) [?mRenderShadowProc@mHRPc@@UAEXXZ]
	void mRenderShadowProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43cdc0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPostRenderProc(class mHRPc* const this) [?mPostRenderProc@mHRPc@@UAE_NXZ]
	uint8_t mPostRenderProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43ce80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mRenderProc(class mHRPc* const this) [?mRenderProc@mHRPc@@UAE_NXZ]
	uint8_t mRenderProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43ce90);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSemitransparentProcess(class mHRPc* const this) [?mSemitransparentProcess@mHRPc@@UAEXXZ]
	void mSemitransparentProcess()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43cf80);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPostFrameCommonProc2(class mHRPc* const this) [?mPostFrameCommonProc2@mHRPc@@UAE_NXZ]
	uint8_t mPostFrameCommonProc2()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43d3c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPostFrameProc(class mHRPc* const this) [?mPostFrameProc@mHRPc@@UAE_NXZ]
	uint8_t mPostFrameProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43d5c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPcRestoreDamage(class mHRPc* const this, uint8_t arg2) [?mPcRestoreDamage@mHRPc@@QAE_N_N@Z]
	uint8_t mPcRestoreDamage(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43d5e0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::checkAndPlayCameraBankMotion(class mHRPc* const this) [?checkAndPlayCameraBankMotion@mHRPc@@AAEXXZ]
	void checkAndPlayCameraBankMotion()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43d750);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::checkAndBootStageHitEffect(class mHRPc* const this) [?checkAndBootStageHitEffect@mHRPc@@AAEXXZ]
	void checkAndBootStageHitEffect()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43d760);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::onUpdateIK(class mHRPc* const this) [?onUpdateIK@mHRPc@@AAEXXZ]
	void onUpdateIK()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43da20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDamageElectroShockProc(class mHRPc* const this) [?mDamageElectroShockProc@mHRPc@@QAEXXZ]
	void mDamageElectroShockProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43de30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mDamageDownLeverGachaProc(class mHRPc* const this) [?mDamageDownLeverGachaProc@mHRPc@@QAEXXZ]
	void mDamageDownLeverGachaProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43df10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSpecialWalkProc(class mHRPc* const this) [?mSpecialWalkProc@mHRPc@@QAEXXZ]
	void mSpecialWalkProc()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43e340);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckHaveWep(class mHRPc* const this, int32_t arg2) [?mCheckHaveWep@mHRPc@@QAE_NH@Z]
	uint8_t mCheckHaveWep(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x43e9d0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mChangeWeaponProcess(class mHRPc* const this) [?mChangeWeaponProcess@mHRPc@@QAE_NXZ]
	uint8_t mChangeWeaponProcess()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43ea30);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::TryChangeWeapon(class mHRPc* const this) [?TryChangeWeapon@mHRPc@@AAEXXZ]
	void TryChangeWeapon()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43ee70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStartChangeWeapon(class mHRPc* const this) [?mStartChangeWeapon@mHRPc@@QAEXXZ]
	/// <summary>
	/// Makes Travis put away his weapon... and then immediately pull it out again.
	/// </summary>
	void mStartChangeWeapon()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43f1f0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mFrameProc(class mHRPc* const this) [?mFrameProc@mHRPc@@UAE_NXZ]
	uint8_t mFrameProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x43f290);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOffGroundIk(class mHRPc* const this) [?mSetOffGroundIk@mHRPc@@QAEXXZ]
	void mSetOffGroundIk()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x442bc0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mInitData(class mHRPc* const this) [?mInitData@mHRPc@@QAEXXZ]
	void mInitData()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x442c00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mEffectInit(class mHRPc* const this) [?mEffectInit@mHRPc@@UAEXXZ]
	void mEffectInit()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x442c10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTerm(class mHRPc* const this) [?mTerm@mHRPc@@UAE_NXZ]
	uint8_t mTerm()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x442d00);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mInit(class mHRPc* const this) [?mInit@mHRPc@@UAE_NXZ]
	uint8_t mInit()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4433d0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCanOperate(class mHRPc* const this) [?mCheckCanOperate@mHRPc@@QAE_NXZ]
	uint8_t mCheckCanOperate()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x443b70);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetOutsidePlayMotion(class mHRPc* const this) [?mSetOutsidePlayMotion@mHRPc@@QAEXXZ]
	void mSetOutsidePlayMotion()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x443ca0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetEquipTextureName(class mHRPc* const this, char* arg2, int32_t arg3) [?mGetEquipTextureName@mHRPc@@QAEXPADH@Z]
	void mGetEquipTextureName(char* arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, char* arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x443cb0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mGetEquipModelName(class mHRPc* const this, char* arg2, int32_t arg3, uint8_t arg4) [?mGetEquipModelName@mHRPc@@QAEXPADH_N@Z]
	void mGetEquipModelName(char* arg2, int32_t arg3, uint8_t arg4)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, char* arg2, int32_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x443d30);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mTermWarpPosForSantDestroy(class mHRPc* const this) [?mTermWarpPosForSantDestroy@mHRPc@@QAEXXZ]
	void mTermWarpPosForSantDestroy()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x445240);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSubDarkSideTick(class mHRPc* const this) [?mSubDarkSideTick@mHRPc@@QAEXXZ]
	void mSubDarkSideTick()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x445440);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mEquipProc(class mHRPc* const this) [?mEquipProc@mHRPc@@QAE_NXZ]
	uint8_t mEquipProc()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x445470);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBeforeAttackHit(class mHRPc* const this) [?mCheckBeforeAttackHit@mHRPc@@QAE_NXZ]
	uint8_t mCheckBeforeAttackHit()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x446450);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckPcReadEndWithoutWeapon(class mHRPc* const this) [?mCheckPcReadEndWithoutWeapon@mHRPc@@QAE_NXZ]
	uint8_t mCheckPcReadEndWithoutWeapon()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4464b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFightAttack(class mHRPc* const this, int32_t arg2) [?mCheckFightAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckFightAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x446500);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckCatchAttack(class mHRPc* const this, int32_t arg2) [?mCheckCatchAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckCatchAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x446570);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallAttackEffect(class mHRPc* const this, enum enPcAttackEffect arg2, class mHRChara* arg3, uint8_t arg4, struct Vec* arg5) [?mCallAttackEffect@mHRPc@@QAE_NW4enPcAttackEffect@@PAVmHRChara@@_NPAUVec@@@Z]
	uint8_t mCallAttackEffect(enum enPcAttackEffect arg2, class mHRChara* arg3, uint8_t arg4, struct Vec* arg5)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, enum enPcAttackEffect arg2, class mHRChara* arg3, uint8_t arg4, struct Vec* arg5);
		_Func mFunc = (_Func)(GameModule + 0x4465c0);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::SetPcSpeedBlurOff(class mHRPc* const this) [?SetPcSpeedBlurOff@mHRPc@@QAE_NXZ]
	uint8_t SetPcSpeedBlurOff()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x446e20);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mStopLightSabelSound(class mHRPc* const this, uint8_t arg2) [?mStopLightSabelSound@mHRPc@@QAEX_N@Z]
	void mStopLightSabelSound(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x446e40);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetPcPower(class mHRPc* const this) [?mGetPcPower@mHRPc@@QAEMXZ]
	float mGetPcPower()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x446e80);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mRestorePcData(class mHRPc* const this, struct stPcSaveData* arg2) [?mRestorePcData@mHRPc@@QAEXPAUstPcSaveData@@@Z]
	void mRestorePcData(struct stPcSaveData* arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, struct stPcSaveData* arg2);
		_Func mFunc = (_Func)(GameModule + 0x446eb0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::UnlockEverythingForDeathmatch(class mHRPc* const this) [?UnlockEverythingForDeathmatch@mHRPc@@QAEXXZ]
	void UnlockEverythingForDeathmatch()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4473e0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetDeadFlag(class mHRPc* const this) [?mResetDeadFlag@mHRPc@@QAEXXZ]
	void mResetDeadFlag()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x447580);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBatteryMaxAllWeapon(class mHRPc* const this) [?mSetBatteryMaxAllWeapon@mHRPc@@QAEXXZ]
	void mSetBatteryMaxAllWeapon()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4475c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mPlayLightSabelSound(class mHRPc* const this) [?mPlayLightSabelSound@mHRPc@@QAEXXZ]
	void mPlayLightSabelSound()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x447600);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::TurnOffLaserEffectOnPlayer(class mHRPc* const this) [?TurnOffLaserEffectOnPlayer@mHRPc@@QAEXXZ]
	void TurnOffLaserEffectOnPlayer()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x447710);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearBossInit(class mHRPc* const this) [?mClearBossInit@mHRPc@@QAEXXZ]
	void mClearBossInit()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4477a0);
		return mFunc(this);
	}
	// [Function] struct stPcSaveData* __convention("thiscall") mHRPc::mGetPcSaveData(class mHRPc* const this, uint8_t arg2, struct stPcSaveData* arg3) [?mGetPcSaveData@mHRPc@@QAEPAUstPcSaveData@@_NPAU2@@Z]
	struct stPcSaveData* mGetPcSaveData(uint8_t arg2, struct stPcSaveData* arg3)
	{
		typedef struct stPcSaveData*(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, struct stPcSaveData* arg3);
		_Func mFunc = (_Func)(GameModule + 0x447820);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::TestStorePcPosForSM(class mHRPc* const this) [?TestStorePcPosForSM@mHRPc@@QAE_NXZ]
	uint8_t TestStorePcPosForSM()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x447c10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::ReStorePcPosForSM(class mHRPc* const this) [?ReStorePcPosForSM@mHRPc@@QAEXXZ]
	void ReStorePcPosForSM()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x447c20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckIntoStatusScreen(class mHRPc* const this) [?mCheckIntoStatusScreen@mHRPc@@QAE_NXZ]
	uint8_t mCheckIntoStatusScreen()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x447d40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mPlayMotionFromDatPtr(class mHRPc* const this, class TGan* arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6) [?mPlayMotionFromDatPtr@mHRPc@@QAE_NPAVTGan@@_NH1M@Z]
	uint8_t mPlayMotionFromDatPtr(class TGan* arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class TGan* arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6);
		_Func mFunc = (_Func)(GameModule + 0x447d60);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishAttack(class mHRPc* const this, int32_t arg2) [?mCheckFinishAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckFinishAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4480b0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTsubazering(class mHRPc* const this, int32_t arg2) [?mCheckTsubazering@mHRPc@@QAE_NH@Z]
	uint8_t mCheckTsubazering(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4481d0);
		return mFunc(this, arg2);
	}
	// [Function] struct Vec& __convention("thiscall") mHRPc::mGetBikePos(class mHRPc* const this) [?mGetBikePos@mHRPc@@QAEAAUVec@@XZ]
	// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
	void mGetBikePos()
	{
		typedef struct Vec&(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448240);
		mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestBikeRide(class mHRPc* const this) [?mTestBikeRide@mHRPc@@QAE_NXZ]
	uint8_t mTestBikeRide()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448250);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetPadOffset(class mHRPc* const this) [?mSetPadOffset@mHRPc@@QAEXXZ]
	void mSetPadOffset()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4482a0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckNeutral(class mHRPc* const this, uint8_t arg2) [?mCheckNeutral@mHRPc@@QAE_N_N@Z]
	uint8_t mCheckNeutral(uint8_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x448440);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mIsPlayMotion(class mHRPc* const this) [?mIsPlayMotion@mHRPc@@QAE_NXZ]
	uint8_t mIsPlayMotion()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448480);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckBatteryCharge(class mHRPc* const this, int32_t arg2) [?mCheckBatteryCharge@mHRPc@@QAE_NH@Z]
	uint8_t mCheckBatteryCharge(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x4484a0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInitCamera(class mHRPc* const this) [?mCheckInitCamera@mHRPc@@QAE_NXZ]
	uint8_t mCheckInitCamera()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448510);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDead(class mHRPc* const this, int32_t arg2) [?mCheckDead@mHRPc@@QAE_NH@Z]
	uint8_t mCheckDead(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x448520);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearDarkSide(class mHRPc* const this) [?mClearDarkSide@mHRPc@@QAEXXZ]
	void mClearDarkSide()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448540);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mExitChargeBattery4FixCamera(class mHRPc* const this) [?mExitChargeBattery4FixCamera@mHRPc@@QAEXXZ]
	void mExitChargeBattery4FixCamera()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448950);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::StorePcPosForSM(class mHRPc* const this, struct Vec& arg2, struct Vec& arg3) [?StorePcPosForSM@mHRPc@@QAEXABUVec@@0@Z]
	void StorePcPosForSM(struct Vec& arg2, struct Vec& arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, struct Vec& arg2, struct Vec& arg3);
		_Func mFunc = (_Func)(GameModule + 0x448a10);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckEquipReadEnd(class mHRPc* const this) [?mCheckEquipReadEnd@mHRPc@@QAE_NXZ]
	uint8_t mCheckEquipReadEnd()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448b40);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestBattouDemo(class mHRPc* const this) [?mTestBattouDemo@mHRPc@@QAE_NXZ]
	uint8_t mTestBattouDemo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448b70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAddLocker(class mHRPc* const this, int32_t arg2, int16_t arg3, float arg4, uint8_t arg5) [?mAddLocker@mHRPc@@QAE_NHFM_N@Z]
	uint8_t mAddLocker(int32_t arg2, int16_t arg3, float arg4, uint8_t arg5)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, int16_t arg3, float arg4, uint8_t arg5);
		_Func mFunc = (_Func)(GameModule + 0x448b80);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mChkLocker(class mHRPc* const this, int32_t arg2) [?mChkLocker@mHRPc@@QAE_NH@Z]
	uint8_t mChkLocker(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x448bf0);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetEquip(class mHRPc* const this, int32_t arg2, uint8_t arg3, uint8_t arg4) [?mSetEquip@mHRPc@@QAE_NH_N0@Z]
	uint8_t mSetEquip(int32_t arg2, uint8_t arg3, uint8_t arg4)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, uint8_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x448c20);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") mHRPc::mControlDispWestWeapons(class mHRPc* const this) [?mControlDispWestWeapons@mHRPc@@QAEXXZ]
	void mControlDispWestWeapons()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448e60);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckStageChangeInitEnd(class mHRPc* const this) [?mCheckStageChangeInitEnd@mHRPc@@QAE_NXZ]
	uint8_t mCheckStageChangeInitEnd()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x448ed0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetElectroShockWalk(class mHRPc* const this, uint8_t arg2) [?mSetElectroShockWalk@mHRPc@@QAEX_N@Z]
	void mSetElectroShockWalk(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x448ee0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetHugWalk(class mHRPc* const this, uint8_t arg2) [?mSetHugWalk@mHRPc@@QAEX_N@Z]
	void mSetHugWalk(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449020);
		return mFunc(this, arg2);
	}
	// [Function] float __convention("thiscall") mHRPc::mGetBikeSpd(class mHRPc* const this) [?mGetBikeSpd@mHRPc@@QAEMXZ]
	float mGetBikeSpd()
	{
		typedef float(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449210);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetFireMan(class mHRPc* const this) [?mResetFireMan@mHRPc@@QAEXXZ]
	void mResetFireMan()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449240);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetChargeAttack(class mHRPc* const this) [?mResetChargeAttack@mHRPc@@QAEXXZ]
	void mResetChargeAttack()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449290);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mResetFPCamera(class mHRPc* const this) [?mResetFPCamera@mHRPc@@QAEXXZ]
	void mResetFPCamera()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449300);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckDarkSideMode(class mHRPc* const this) [?mCheckDarkSideMode@mHRPc@@QAE_NXZ]
	uint8_t mCheckDarkSideMode()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449370);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mAttachObj(class mHRPc* const this, class TGmf* arg2, char* arg3, class TGmf* arg4, char* arg5) [?mAttachObj@mHRPc@@QAE_NPAVTGmf@@PAD01@Z]
	uint8_t mAttachObj(class TGmf* arg2, char* arg3, class TGmf* arg4, char* arg5)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, class TGmf* arg2, char* arg3, class TGmf* arg4, char* arg5);
		_Func mFunc = (_Func)(GameModule + 0x449380);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") mHRPc::mRestoreSubMissionWeapon(class mHRPc* const this) [?mRestoreSubMissionWeapon@mHRPc@@QAEXXZ]
	void mRestoreSubMissionWeapon()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4493f0);
		return mFunc(this);
	}
	// [Function] int16_t __convention("thiscall") mHRPc::mGetBattery(class mHRPc* const this, int32_t arg2) [?mGetBattery@mHRPc@@QAEFH@Z]
	int16_t mGetBattery(int32_t arg2)
	{
		typedef int16_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449400);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetBatteryMax(class mHRPc* const this, int32_t arg2) [?mGetBatteryMax@mHRPc@@QAEHH@Z]
	int32_t mGetBatteryMax(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449440);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetBattery(class mHRPc* const this, int16_t arg2, int32_t arg3) [?mSetBattery@mHRPc@@QAEXFH@Z]
	void mSetBattery(int16_t arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int16_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x449480);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::StoreBikePosForSM(class mHRPc* const this) [?StoreBikePosForSM@mHRPc@@QAE_NXZ]
	uint8_t StoreBikePosForSM()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449560);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetBikePos(class mHRPc* const this, int32_t, float arg3) [?mSetBikePos@mHRPc@@QAE_NUVec@@M@Z]
	uint8_t mSetBikePos(int32_t arg2, float arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2, float arg3);
		_Func mFunc = (_Func)(GameModule + 0x4495d0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetBikeRot(class mHRPc* const this, struct Vec arg2) [?mSetBikeRot@mHRPc@@QAE_NUVec@@@Z]
	uint8_t mSetBikeRot(struct Vec arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, struct Vec arg2);
		_Func mFunc = (_Func)(GameModule + 0x4496a0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") mHRPc::mAddPcMoney(class mHRPc* const this, int32_t arg2) [?mAddPcMoney@mHRPc@@QAEXH@Z]
	void mAddPcMoney(int32_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449710);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mSetBikeJumpForSubMission(class mHRPc* const this, uint8_t arg2) [?mSetBikeJumpForSubMission@mHRPc@@QAEH_N@Z]
	int32_t mSetBikeJumpForSubMission(uint8_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449750);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCallDemoBattou(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mCallDemoBattou@mHRPc@@QAE_N_N0@Z]
	uint8_t mCallDemoBattou(uint8_t arg2, uint8_t arg3)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x449950);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mTestPauseBattouDemo(class mHRPc* const this) [?mTestPauseBattouDemo@mHRPc@@QAE_NXZ]
	uint8_t mTestPauseBattouDemo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4499b0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mResumeBattouDemo(class mHRPc* const this) [?mResumeBattouDemo@mHRPc@@QAE_NXZ]
	uint8_t mResumeBattouDemo()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4499c0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCallDemoNoutou(class mHRPc* const this) [?mCallDemoNoutou@mHRPc@@QAEXXZ]
	void mCallDemoNoutou()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4499f0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mCancelBattouNoutouDemo(class mHRPc* const this) [?mCancelBattouNoutouDemo@mHRPc@@QAEXXZ]
	void mCancelBattouNoutouDemo()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449af0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mRestorePlayMotionFromDatPtr(class mHRPc* const this, uint8_t arg2) [?mRestorePlayMotionFromDatPtr@mHRPc@@QAEX_N@Z]
	void mRestorePlayMotionFromDatPtr(uint8_t arg2)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449b30);
		return mFunc(this, arg2);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::mGetAtkScl(class mHRPc* const this) [?mGetAtkScl@mHRPc@@QAEHXZ]
	int32_t mGetAtkScl()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449ca0);
		return mFunc(this);
	}
	// [Function] int32_t __convention("thiscall") mHRPc::GetSwingCount(class mHRPc* const this) [?GetSwingCount@mHRPc@@QAEHXZ]
	int32_t GetSwingCount()
	{
		typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449d00);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::ClearSwingCount(class mHRPc* const this) [?ClearSwingCount@mHRPc@@QAEXXZ]
	void ClearSwingCount()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449d10);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckLockOnEnemy(class mHRPc* const this) [?mCheckLockOnEnemy@mHRPc@@QAE_NXZ]
	uint8_t mCheckLockOnEnemy()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449d20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckThrowAttack(class mHRPc* const this, int32_t arg2) [?mCheckThrowAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckThrowAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449d40);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGetAllWeapon(class mHRPc* const this) [?mCheckGetAllWeapon@mHRPc@@QAE_NXZ]
	uint8_t mCheckGetAllWeapon()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449da0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckGuardSlide(class mHRPc* const this, int32_t arg2) [?mCheckGuardSlide@mHRPc@@QAE_NH@Z]
	uint8_t mCheckGuardSlide(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449e50);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTsubaAttack(class mHRPc* const this, int32_t arg2) [?mCheckTsubaAttack@mHRPc@@QAE_NH@Z]
	uint8_t mCheckTsubaAttack(int32_t arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x449e70);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckSuccessInputFinish(class mHRPc* const this) [?mCheckSuccessInputFinish@mHRPc@@QAE_NXZ]
	uint8_t mCheckSuccessInputFinish()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449eb0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetInputMode(class mHRPc* const this, enum enPcInputMode arg2, uint8_t arg3) [?mSetInputMode@mHRPc@@QAEXW4enPcInputMode@@_N@Z]
	void mSetInputMode(enum enPcInputMode arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, enum enPcInputMode arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x449ec0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckInputMove(class mHRPc* const this) [?mCheckInputMove@mHRPc@@QAE_NXZ]
	uint8_t mCheckInputMove()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x449f20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mSetEquipMk3(class mHRPc* const this) [?mSetEquipMk3@mHRPc@@QAE_NXZ]
	uint8_t mSetEquipMk3()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44a060);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckTrvReadEnd(class mHRPc* const this) [?mCheckTrvReadEnd@mHRPc@@QAE_NXZ]
	uint8_t mCheckTrvReadEnd()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44a0a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepBattou(class mHRPc* const this) [?mSetWepBattou@mHRPc@@QAEXXZ]
	void mSetWepBattou()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44a100);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetWepNoutou(class mHRPc* const this) [?mSetWepNoutou@mHRPc@@QAEXXZ]
	void mSetWepNoutou()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44a1c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mGetPauseFlag(class mHRPc* const this) [?mGetPauseFlag@mHRPc@@QAE_NXZ]
	uint8_t mGetPauseFlag()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44a260);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") mHRPc::mCheckFinishAttackAndCantLockOn(class mHRPc* const this) [?mCheckFinishAttackAndCantLockOn@mHRPc@@QAE_NXZ]
	uint8_t mCheckFinishAttackAndCantLockOn()
	{
		typedef uint8_t(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44a2b0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mTremStageChange(class mHRPc* const this) [?mTremStageChange@mHRPc@@QAEXXZ]
	void mTremStageChange()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44a2d0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mSetEventWalk(class mHRPc* const this, uint8_t arg2, uint8_t arg3) [?mSetEventWalk@mHRPc@@QAEX_N0@Z]
	void mSetEventWalk(uint8_t arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr, uint8_t arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x44a9f0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") mHRPc::mInitStageChange(class mHRPc* const this) [?mInitStageChange@mHRPc@@QAEXXZ]
	void mInitStageChange()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44aa40);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") mHRPc::mClearGameFlag(class mHRPc* const this) [?mClearGameFlag@mHRPc@@QAEXXZ]
	void mClearGameFlag()
	{
		typedef void(__thiscall* _Func)(class mHRPc* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x44b240);
		return mFunc(this);
	}
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <int32_t mEscapeActionInit, offset 0x580>
	int32_t mEscapeActionInit;

	// <struct stPcStatus mPcStatus, offset 0x584>
	struct stPcStatus mPcStatus;

	// <struct stMiniDemo mMiniDemo, offset 0xe88>
	struct stMiniDemo mMiniDemo;

	// <struct stPcSaveData mPcSaveData, offset 0xe94>
	struct stPcSaveData mPcSaveData;

	// <struct stDarkSideInfo mDarkSideInfo, offset 0x14f8>
	struct stDarkSideInfo mDarkSideInfo;

	// <class mHRBike* mpBike, offset 0x152c>
	class mHRBike* mpBike;

	// <struct stPcSndData mSnd, offset 0x1530>
	struct stPcSndData mSnd;

	// <enum enPcInputMode mInputMode, offset 0x15e0>
	enum enPcInputMode mInputMode;

	// <enum enPcInputMode mInputModeOld, offset 0x15e4>
	enum enPcInputMode mInputModeOld;

	// <enum enPcInputMode mInputModeBefore, offset 0x15e8>
	enum enPcInputMode mInputModeBefore;

	// <uint8_t mPauseAll, offset 0x15ec>
	uint8_t mPauseAll;

	// <uint8_t mPauseNpc, offset 0x15ed>
	uint8_t mPauseNpc;

	// <uint8_t mOperate, offset 0x15ee>
	uint8_t mOperate;

	// <uint8_t mOnlyMove, offset 0x15ef>
	uint8_t mOnlyMove;

	// <uint8_t mMotSpdAdj, offset 0x15f0>
	uint8_t mMotSpdAdj;

	// <uint8_t mDead, offset 0x15f1>
	uint8_t mDead;

	// <uint8_t mDeadPause, offset 0x15f2>
	uint8_t mDeadPause;

	// <uint8_t mCameraOperate, offset 0x15f3>
	uint8_t mCameraOperate;

	// <uint8_t mBattouDemoRequest, offset 0x15f4>
	uint8_t mBattouDemoRequest;

	// <uint8_t mStageChangeInitEnd, offset 0x15f5>
	uint8_t mStageChangeInitEnd;

	// <uint8_t mStageChangeTermEnd, offset 0x15f6>
	uint8_t mStageChangeTermEnd;

	// <uint8_t mStageChangeMuteki, offset 0x15f7>
	uint8_t mStageChangeMuteki;

	// <uint8_t mBanStatusScreen, offset 0x15f8>
	uint8_t mBanStatusScreen;

	// <Unidentified data segment, offset 0x15f9>
private:
	char _UnidentifiedData24[3];

public:
	// <int32_t mAtkPauseTime, offset 0x15fc>
	int32_t mAtkPauseTime;

	// <int32_t mStopRenderFrameNum, offset 0x1600>
	int32_t mStopRenderFrameNum;

	// <int32_t mWait1Frame, offset 0x1604>
	int32_t mWait1Frame;

	// <struct stPcEffect mPcEffect, offset 0x1608>
	struct stPcEffect mPcEffect;

	// <struct stHugWalk mPcHug, offset 0x1898>
	struct stHugWalk mPcHug;

	// <struct stTiger mTiger, offset 0x18b8>
	struct stTiger mTiger;

	// <struct Vec mLockOnPos, offset 0x1908>
	struct Vec mLockOnPos;

	// <class mHRChara* mpLockOnNpc, offset 0x1914>
	class mHRChara* mpLockOnNpc;

	// <class mHRChara* mpTsubaNpc, offset 0x1918>
	class mHRChara* mpTsubaNpc;

	// <class mHRChara* mpCatchNpc, offset 0x191c>
	class mHRChara* mpCatchNpc;

	// <class mHRChara* mpCatchReserveNpc, offset 0x1920>
	class mHRChara* mpCatchReserveNpc;

	// <class mHRChara* mpEscapeNpc, offset 0x1924>
	class mHRChara* mpEscapeNpc;

	// <class mHRChara* mpInitFinishNpc, offset 0x1928>
	class mHRChara* mpInitFinishNpc;

	// <class mHRChara* mpNextFinishNpc, offset 0x192c>
	class mHRChara* mpNextFinishNpc;

	// <class mHRChara* mpFinishNpc[0x8], offset 0x1930>
	class mHRChara* mpFinishNpc[8];

	// <class mHRChara* mpFinishReserveNpc, offset 0x1950>
	class mHRChara* mpFinishReserveNpc;

	// <class mHRChara* mpDSTargetNpc, offset 0x1954>
	class mHRChara* mpDSTargetNpc;

	// <class mHRChara* mpDwnAtkNpc, offset 0x1958>
	class mHRChara* mpDwnAtkNpc;

	// <class mHRChara* mpLastAtkNpc, offset 0x195c>
	class mHRChara* mpLastAtkNpc;

	// <class mHRChara* mpAttackFromBackNpc, offset 0x1960>
	class mHRChara* mpAttackFromBackNpc;

	// <class HROBJDummy mLockOnDummy, offset 0x1964>
	class HROBJDummy mLockOnDummy;

	// <uint8_t mSavehitOidashiDisEnable, offset 0x1ee4>
	uint8_t mSavehitOidashiDisEnable;

	// <Unidentified data segment, offset 0x1ee5>
private:
	char _UnidentifiedData46[3];

public:
	// <int32_t mSlowMotionSytemMotNo, offset 0x1ee8>
	int32_t mSlowMotionSytemMotNo;

	// <int32_t mSlowMotionSytemButton, offset 0x1eec>
	int32_t mSlowMotionSytemButton;

	// <class ghmTriangle mWepCollL, offset 0x1ef0>
	class ghmTriangle mWepCollL;

	// <class ghmTriangle* m_pAttackHitTriangle, offset 0x1f14>
	class ghmTriangle* m_pAttackHitTriangle;

	// <struct stFade mFade, offset 0x1f18>
	struct stFade mFade;

	// <union uniSMflag mSubMissionflag, offset 0x1f24>
	union uniSMflag mSubMissionflag;

	// <uint8_t mSubMissionPcPosStoreFlag, offset 0x1f26>
	uint8_t mSubMissionPcPosStoreFlag;

	// <Unidentified data segment, offset 0x1f27>
private:
	char _UnidentifiedData53[1];

public:
	// <struct Vec mSubMissionStorePos, offset 0x1f28>
	struct Vec mSubMissionStorePos;

	// <struct Vec mSubMissionStoreRot, offset 0x1f34>
	struct Vec mSubMissionStoreRot;

	// <uint8_t mSubMissionBikePosStoreFlag, offset 0x1f40>
	uint8_t mSubMissionBikePosStoreFlag;

	// <Unidentified data segment, offset 0x1f41>
private:
	char _UnidentifiedData56[3];

public:
	// <struct Vec mSubMissionStoreBikePos, offset 0x1f44>
	struct Vec mSubMissionStoreBikePos;

	// <struct Vec mSubMissionStoreBikeRot, offset 0x1f50>
	struct Vec mSubMissionStoreBikeRot;

	// <class EventAreaCamera* mpSubMissionJumpCameraHandle, offset 0x1f5c>
	class EventAreaCamera* mpSubMissionJumpCameraHandle;

	// <int32_t mDisEnableBtlPoseCalc, offset 0x1f60>
	int32_t mDisEnableBtlPoseCalc;

	// <uint8_t mTamePush, offset 0x1f64>
	uint8_t mTamePush;

	// <uint8_t mTameMax, offset 0x1f65>
	uint8_t mTameMax;

	// <uint8_t mTameSe, offset 0x1f66>
	uint8_t mTameSe;

	// <Unidentified data segment, offset 0x1f67>
private:
	char _UnidentifiedData63[1];

public:
	// <int32_t mDigAction, offset 0x1f68>
	int32_t mDigAction;

	// <enum enWepChangeProc mChangeWepProc, offset 0x1f6c>
	enum enWepChangeProc mChangeWepProc;

	// <int32_t mChangeWepKind, offset 0x1f70>
	int32_t mChangeWepKind;

	// <int32_t mMenuDisEnableFrame, offset 0x1f74>
	int32_t mMenuDisEnableFrame;

	// <char const* m_sMotName, offset 0x1f78>
	char const* m_sMotName;

	// <char const* m_sPreMotName, offset 0x1f7c>
	char const* m_sPreMotName;

	// <char m_sOutMotName[0x10], offset 0x1f80>
	char m_sOutMotName[16];

	// <uint8_t m_bIsBootStageHitEffect, offset 0x1f90>
	uint8_t m_bIsBootStageHitEffect;

	// <Unidentified data segment, offset 0x1f91>
private:
	char _UnidentifiedData71[3];

public:
	// <struct Vec m_inPreWeaponTopPosi, offset 0x1f94>
	struct Vec m_inPreWeaponTopPosi;

	// <uint8_t m_bIsPreTigerVisible, offset 0x1fa0>
	uint8_t m_bIsPreTigerVisible;

	// <uint8_t m_bIsPreFinishAttack, offset 0x1fa1>
	uint8_t m_bIsPreFinishAttack;

	// <uint8_t m_bIsBeginFinishAttack, offset 0x1fa2>
	uint8_t m_bIsBeginFinishAttack;

	// <uint8_t m_bIsPlayCamBankMotion, offset 0x1fa3>
	uint8_t m_bIsPlayCamBankMotion;

	// <class CTimeRatioInterpolate m_inWeaponLengthRatio, offset 0x1fa4>
	class CTimeRatioInterpolate m_inWeaponLengthRatio;

	std::string ToString() const { return "class mHRPc(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<mHRPc, mHRChara>("mHRPc")
			.addFunction("__tostring", &mHRPc::ToString)
			.addFunction("GetPtrAddr", &mHRPc::GetPtrAddr)
			.addProperty("mEscapeActionInit", &mHRPc::mEscapeActionInit)
			.addProperty("mPcStatus", &mHRPc::mPcStatus)
			.addProperty("mMiniDemo", &mHRPc::mMiniDemo)
			.addProperty("mPcSaveData", &mHRPc::mPcSaveData)
			.addProperty("mDarkSideInfo", &mHRPc::mDarkSideInfo)
			.addProperty("mpBike", &mHRPc::mpBike)
			.addProperty("mSnd", &mHRPc::mSnd)
			.addProperty("mInputMode", &mHRPc::mInputMode)
			.addProperty("mInputModeOld", &mHRPc::mInputModeOld)
			.addProperty("mInputModeBefore", &mHRPc::mInputModeBefore)
			.addProperty("mPauseAll", &mHRPc::mPauseAll)
			.addProperty("mPauseNpc", &mHRPc::mPauseNpc)
			.addProperty("mOperate", &mHRPc::mOperate)
			.addProperty("mOnlyMove", &mHRPc::mOnlyMove)
			.addProperty("mMotSpdAdj", &mHRPc::mMotSpdAdj)
			.addProperty("mDead", &mHRPc::mDead)
			.addProperty("mDeadPause", &mHRPc::mDeadPause)
			.addProperty("mCameraOperate", &mHRPc::mCameraOperate)
			.addProperty("mBattouDemoRequest", &mHRPc::mBattouDemoRequest)
			.addProperty("mStageChangeInitEnd", &mHRPc::mStageChangeInitEnd)
			.addProperty("mStageChangeTermEnd", &mHRPc::mStageChangeTermEnd)
			.addProperty("mStageChangeMuteki", &mHRPc::mStageChangeMuteki)
			.addProperty("mBanStatusScreen", &mHRPc::mBanStatusScreen)
			.addProperty("mAtkPauseTime", &mHRPc::mAtkPauseTime)
			.addProperty("mStopRenderFrameNum", &mHRPc::mStopRenderFrameNum)
			.addProperty("mWait1Frame", &mHRPc::mWait1Frame)
			.addProperty("mPcEffect", &mHRPc::mPcEffect)
			.addProperty("mPcHug", &mHRPc::mPcHug)
			.addProperty("mTiger", &mHRPc::mTiger)
			.addProperty("mLockOnPos", &mHRPc::mLockOnPos)
			.addProperty("mpLockOnNpc", &mHRPc::mpLockOnNpc)
			.addProperty("mpTsubaNpc", &mHRPc::mpTsubaNpc)
			.addProperty("mpCatchNpc", &mHRPc::mpCatchNpc)
			.addProperty("mpCatchReserveNpc", &mHRPc::mpCatchReserveNpc)
			.addProperty("mpEscapeNpc", &mHRPc::mpEscapeNpc)
			.addProperty("mpInitFinishNpc", &mHRPc::mpInitFinishNpc)
			.addProperty("mpNextFinishNpc", &mHRPc::mpNextFinishNpc)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpFinishNpc", &mHRPc::mpFinishNpc)
			.addProperty("mpFinishReserveNpc", &mHRPc::mpFinishReserveNpc)
			.addProperty("mpDSTargetNpc", &mHRPc::mpDSTargetNpc)
			.addProperty("mpDwnAtkNpc", &mHRPc::mpDwnAtkNpc)
			.addProperty("mpLastAtkNpc", &mHRPc::mpLastAtkNpc)
			.addProperty("mpAttackFromBackNpc", &mHRPc::mpAttackFromBackNpc)
			.addProperty("mLockOnDummy", &mHRPc::mLockOnDummy)
			.addProperty("mSavehitOidashiDisEnable", &mHRPc::mSavehitOidashiDisEnable)
			.addProperty("mSlowMotionSytemMotNo", &mHRPc::mSlowMotionSytemMotNo)
			.addProperty("mSlowMotionSytemButton", &mHRPc::mSlowMotionSytemButton)
			.addProperty("mWepCollL", &mHRPc::mWepCollL)
			.addProperty("m_pAttackHitTriangle", &mHRPc::m_pAttackHitTriangle)
			.addProperty("mFade", &mHRPc::mFade)
			.addProperty("mSubMissionflag", &mHRPc::mSubMissionflag)
			.addProperty("mSubMissionPcPosStoreFlag", &mHRPc::mSubMissionPcPosStoreFlag)
			.addProperty("mSubMissionStorePos", &mHRPc::mSubMissionStorePos)
			.addProperty("mSubMissionStoreRot", &mHRPc::mSubMissionStoreRot)
			.addProperty("mSubMissionBikePosStoreFlag", &mHRPc::mSubMissionBikePosStoreFlag)
			.addProperty("mSubMissionStoreBikePos", &mHRPc::mSubMissionStoreBikePos)
			.addProperty("mSubMissionStoreBikeRot", &mHRPc::mSubMissionStoreBikeRot)
			.addProperty("mpSubMissionJumpCameraHandle", &mHRPc::mpSubMissionJumpCameraHandle)
			.addProperty("mDisEnableBtlPoseCalc", &mHRPc::mDisEnableBtlPoseCalc)
			.addProperty("mTamePush", &mHRPc::mTamePush)
			.addProperty("mTameMax", &mHRPc::mTameMax)
			.addProperty("mTameSe", &mHRPc::mTameSe)
			.addProperty("mDigAction", &mHRPc::mDigAction)
			.addProperty("mChangeWepProc", &mHRPc::mChangeWepProc)
			.addProperty("mChangeWepKind", &mHRPc::mChangeWepKind)
			.addProperty("mMenuDisEnableFrame", &mHRPc::mMenuDisEnableFrame)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sMotName", &mHRPc::m_sMotName)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sPreMotName", &mHRPc::m_sPreMotName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_sOutMotName", &mHRPc::m_sOutMotName)
			.addProperty("m_bIsBootStageHitEffect", &mHRPc::m_bIsBootStageHitEffect)
			.addProperty("m_inPreWeaponTopPosi", &mHRPc::m_inPreWeaponTopPosi)
			.addProperty("m_bIsPreTigerVisible", &mHRPc::m_bIsPreTigerVisible)
			.addProperty("m_bIsPreFinishAttack", &mHRPc::m_bIsPreFinishAttack)
			.addProperty("m_bIsBeginFinishAttack", &mHRPc::m_bIsBeginFinishAttack)
			.addProperty("m_bIsPlayCamBankMotion", &mHRPc::m_bIsPlayCamBankMotion)
			.addProperty("m_inWeaponLengthRatio", &mHRPc::m_inWeaponLengthRatio)
			.addFunction("mGetEventWalk", &mHRPc::mGetEventWalk)
			.addFunction("mGetDarkSideTick", &mHRPc::mGetDarkSideTick)
			.addFunction("isFireDarkSideModeActive", &mHRPc::isFireDarkSideModeActive)
			.addFunction("mSetTsubaDisEnable", &mHRPc::mSetTsubaDisEnable)
			.addFunction("mGetInputMode", &mHRPc::mGetInputMode)
			.addFunction("mSetPcMoney", &mHRPc::mSetPcMoney)
			.addFunction("mSubPcMoney", &mHRPc::mSubPcMoney)
			.addFunction("mGetPcMoney", &mHRPc::mGetPcMoney)
			.addFunction("mGetEquipID", &mHRPc::mGetEquipID)
			.addFunction("mGetEquipGmfPtr", &mHRPc::mGetEquipGmfPtr)
			.addFunction("mGetBikePtr", &mHRPc::mGetBikePtr)
			.addFunction("mSetBgmNo4Load", &mHRPc::mSetBgmNo4Load)
			.addFunction("mCheckDemoBattou", &mHRPc::mCheckDemoBattou)
			.addFunction("mCheckDemoNoutou", &mHRPc::mCheckDemoNoutou)
			.addFunction("mSetThrowModeOnly", &mHRPc::mSetThrowModeOnly)
			.addFunction("mSetSlashModeOnly", &mHRPc::mSetSlashModeOnly)
			.addFunction("mSetCatchModeDisEnable", &mHRPc::mSetCatchModeDisEnable)
			.addFunction("mSetFightTameDisEnable", &mHRPc::mSetFightTameDisEnable)
			.addFunction("mSetSlashTameDisEnable", &mHRPc::mSetSlashTameDisEnable)
			.addFunction("mSetDownAttackDisEnable", &mHRPc::mSetDownAttackDisEnable)
			.addFunction("mSetDigDisEnable", &mHRPc::mSetDigDisEnable)
			.addFunction("mGetDigDisEnable4SM", &mHRPc::mGetDigDisEnable4SM)
			.addFunction("mClearSubMissionflag", &mHRPc::mClearSubMissionflag)
			.addFunction("mSetSubMissionActivflag", &mHRPc::mSetSubMissionActivflag)
			.addFunction("mSetSkillCatch", &mHRPc::mSetSkillCatch)
			.addFunction("mSetAtkMode", &mHRPc::mSetAtkMode)
			.addFunction("mGetAtkMode", &mHRPc::mGetAtkMode)
			.addFunction("mGetEqWepLaser", &mHRPc::mGetEqWepLaser)
			.addFunction("mSetAlwaysEmptyBattery", &mHRPc::mSetAlwaysEmptyBattery)
			.addFunction("mSetCantChargeBattery", &mHRPc::mSetCantChargeBattery)
			.addFunction("mSetDontSemitrans", &mHRPc::mSetDontSemitrans)
			.addFunction("mSetCantCallBikeFlag", &mHRPc::mSetCantCallBikeFlag)
			.addFunction("mSetLostBikeFlag", &mHRPc::mSetLostBikeFlag)
			.addFunction("mResetMaxCombo", &mHRPc::mResetMaxCombo)
			.addFunction("mGetDigToolFlag", &mHRPc::mGetDigToolFlag)
			.addFunction("mSetPuppetMode", &mHRPc::mSetPuppetMode)
			.addFunction("mSetUseWeaponEffect", &mHRPc::mSetUseWeaponEffect)
			.addFunction("mGetTodomePrepareMode", &mHRPc::mGetTodomePrepareMode)
			.addFunction("mClearTodomePrepareMode", &mHRPc::mClearTodomePrepareMode)
			.addFunction("mGetThrowPrepareMode", &mHRPc::mGetThrowPrepareMode)
			.addFunction("mGetThrowInputResult", &mHRPc::mGetThrowInputResult)
			.addFunction("mSetShadowDepth", &mHRPc::mSetShadowDepth)
			.addFunction("mSetBanSlotCry", &mHRPc::mSetBanSlotCry)
			.addFunction("mSetBanSlotBel", &mHRPc::mSetBanSlotBel)
			.addFunction("mSetBanSlotBar", &mHRPc::mSetBanSlotBar)
			.addFunction("mSetBanSlot777", &mHRPc::mSetBanSlot777)
			.addFunction("mSetDeadSubmission", &mHRPc::mSetDeadSubmission)
			.addFunction("mSetDontSubBattery", &mHRPc::mSetDontSubBattery)
			.addFunction("mSetAutoSubBatteryDisEnable", &mHRPc::mSetAutoSubBatteryDisEnable)
			.addFunction("mSetJustGuardDisEnable", &mHRPc::mSetJustGuardDisEnable)
			.addFunction("mSetDashAtkDisEnable", &mHRPc::mSetDashAtkDisEnable)
			.addFunction("mSetJustEscapeDisEnable", &mHRPc::mSetJustEscapeDisEnable)
			.addFunction("mGetTsubaNpc", &mHRPc::mGetTsubaNpc)
			.addFunction("mSetOperate", &mHRPc::mSetOperate)
			.addFunction("mGetOperate", &mHRPc::mGetOperate)
			.addFunction("mSetCameraOperate", &mHRPc::mSetCameraOperate)
			.addFunction("mCheckStageChangeTermEnd", &mHRPc::mCheckStageChangeTermEnd)
			.addFunction("mGetDeadFlag", &mHRPc::mGetDeadFlag)
			.addFunction("mGetDebuNekoDataPtr", &mHRPc::mGetDebuNekoDataPtr)
			.addFunction("mSetPauseAllFlag", &mHRPc::mSetPauseAllFlag)
			.addFunction("mSetCancelSetPadOffset", &mHRPc::mSetCancelSetPadOffset)
			.addFunction("mSetChangeEquipFromScript", &mHRPc::mSetChangeEquipFromScript)
			.addFunction("mSetForceLoseTsubazeri", &mHRPc::mSetForceLoseTsubazeri)
			.addFunction("mCheckDeadFukki", &mHRPc::mCheckDeadFukki)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mPlayMotionFromDatPtrExt", &mHRPc::mPlayMotionFromDatPtrExt)
			.addFunction("mSetPcPower", &mHRPc::mSetPcPower)
			.addFunction("mGetEquipTexPtr", &mHRPc::mGetEquipTexPtr)
			.addFunction("mSetRestartBGM", &mHRPc::mSetRestartBGM)
			.addFunction("mGetSubMissionflag", &mHRPc::mGetSubMissionflag)
			.addStaticFunction("mSetDisplayMiniMapFlag", &mHRPc::mSetDisplayMiniMapFlag)
			.addStaticFunction("mGetDisplayMiniMapFlag", &mHRPc::mGetDisplayMiniMapFlag)
			.addStaticFunction("mSetCameraXReverseControlFlag", &mHRPc::mSetCameraXReverseControlFlag)
			.addStaticFunction("mGetCameraXReverseControlFlag", &mHRPc::mGetCameraXReverseControlFlag)
			.addStaticFunction("mSetCameraYReverseControlFlag", &mHRPc::mSetCameraYReverseControlFlag)
			.addStaticFunction("mGetCameraYReverseControlFlag", &mHRPc::mGetCameraYReverseControlFlag)
			.addFunction("mAddClearNum", &mHRPc::mAddClearNum)
			.addFunction("mGetDeadSubmission", &mHRPc::mGetDeadSubmission)
			.addFunction("mCheckStatusMenuDisp", &mHRPc::mCheckStatusMenuDisp)
			.addFunction("mSetMotionNo", &mHRPc::mSetMotionNo)
			.addFunction("mGetAtkPauseTime", &mHRPc::mGetAtkPauseTime)
			.addFunction("mDecAtkPauseTime", &mHRPc::mDecAtkPauseTime)
			.addFunction("mGetWait1Frame", &mHRPc::mGetWait1Frame)
			.addFunction("mDecWait1Frame", &mHRPc::mDecWait1Frame)
			.addFunction("mTestPlayMiniDemoForSantDestroy", &mHRPc::mTestPlayMiniDemoForSantDestroy)
			.addFunction("mGetHugWalk", &mHRPc::mGetHugWalk)
			.addFunction("mResetReceiveDamage", &mHRPc::mResetReceiveDamage)
			.addFunction("mGetBikeSight", &mHRPc::mGetBikeSight)
			.addFunction("mGetDontChangeBikeCamera", &mHRPc::mGetDontChangeBikeCamera)
			.addFunction("mGetCameraOperate", &mHRPc::mGetCameraOperate)
			.addFunction("mGetPauseAllFlag", &mHRPc::mGetPauseAllFlag)
			.addFunction("isBeginFinishAttack", &mHRPc::isBeginFinishAttack)
			.addFunction("mTestTiger", &mHRPc::mTestTiger)
			.addFunction("mSetMenuDisEnableFrame", &mHRPc::mSetMenuDisEnableFrame)
			.addFunction("mGetNeedShakeDir", &mHRPc::mGetNeedShakeDir)
			.addFunction("mSetWepMotionNo", &mHRPc::mSetWepMotionNo)
			.addFunction("mGetWepMotionNo", &mHRPc::mGetWepMotionNo)
			.addFunction("mSetBikeVisible", &mHRPc::mSetBikeVisible)
			.addFunction("mGetNowBuf", &mHRPc::mGetNowBuf)
			.addFunction("mGetTexNowBuf", &mHRPc::mGetTexNowBuf)
			.addFunction("mCheckSNBElecDamage", &mHRPc::mCheckSNBElecDamage)
			.addFunction("mCheckIntoTsubazeriai", &mHRPc::mCheckIntoTsubazeriai)
			.addFunction("mPlayMotTsubaszeriai", &mHRPc::mPlayMotTsubaszeriai)
			.addFunction("mCheckTsubazeriai", &mHRPc::mCheckTsubazeriai)
			.addFunction("mWinTsubazeriai", &mHRPc::mWinTsubazeriai)
			.addFunction("mLoseTsubazeriai", &mHRPc::mLoseTsubazeriai)
			.addFunction("mGetTsubaOuterMotion", &mHRPc::mGetTsubaOuterMotion)
			.addFunction("mGetTsubaOuterMotionNo", &mHRPc::mGetTsubaOuterMotionNo)
			.addFunction("mGetTsubaDisEnable", &mHRPc::mGetTsubaDisEnable)
			.addFunction("mSetTsubaEffectVisible", &mHRPc::mSetTsubaEffectVisible)
			.addFunction("mGetTsubaEffectVisible", &mHRPc::mGetTsubaEffectVisible)
			.addFunction("mCheckLockOn", &mHRPc::mCheckLockOn)
			.addFunction("mGetLockOnNpc", &mHRPc::mGetLockOnNpc)
			.addFunction("mSetAtkPauseTime", &mHRPc::mSetAtkPauseTime)
			.addFunction("mSetCmbKind", &mHRPc::mSetCmbKind)
			.addFunction("mGetCmbKind", &mHRPc::mGetCmbKind)
			.addFunction("mGetLockOnThroughWall", &mHRPc::mGetLockOnThroughWall)
			.addFunction("mGetThrowModeOnly", &mHRPc::mGetThrowModeOnly)
			.addFunction("mGetCatchModeDisEnable", &mHRPc::mGetCatchModeDisEnable)
			.addFunction("mGetDownAttackDisEnable", &mHRPc::mGetDownAttackDisEnable)
			.addFunction("mGetDigDisEnable", &mHRPc::mGetDigDisEnable)
			.addFunction("mSetDigDisEnable4SM", &mHRPc::mSetDigDisEnable4SM)
			.addFunction("mGetSkillCatch", &mHRPc::mGetSkillCatch)
			.addFunction("mSetSkillK7", &mHRPc::mSetSkillK7)
			.addFunction("mGetSkillK7", &mHRPc::mGetSkillK7)
			.addFunction("mSetPcBtlPose", &mHRPc::mSetPcBtlPose)
			.addFunction("mGetPcBtlPose", &mHRPc::mGetPcBtlPose)
			.addFunction("mSetEqWepLaser", &mHRPc::mSetEqWepLaser)
			.addFunction("mGetElectroShockWalk", &mHRPc::mGetElectroShockWalk)
			.addFunction("mGetPoisonWalk", &mHRPc::mGetPoisonWalk)
			.addFunction("mGetCantDispLaserEffect", &mHRPc::mGetCantDispLaserEffect)
			.addFunction("mSetWepChangeUnVisible", &mHRPc::mSetWepChangeUnVisible)
			.addFunction("mSetAtkHitAbsoluteFlag", &mHRPc::mSetAtkHitAbsoluteFlag)
			.addFunction("mGetAtkHitAbsoluteFlag", &mHRPc::mGetAtkHitAbsoluteFlag)
			.addFunction("mSetAttackHitToRollEscepe", &mHRPc::mSetAttackHitToRollEscepe)
			.addFunction("mGetAttackHitToRollEscepe", &mHRPc::mGetAttackHitToRollEscepe)
			.addFunction("mGetPuppetMode", &mHRPc::mGetPuppetMode)
			.addFunction("mGetUseWeaponEffect", &mHRPc::mGetUseWeaponEffect)
			.addFunction("mSetLastAttackNpc", &mHRPc::mSetLastAttackNpc)
			.addFunction("mGetLastAttackNpc", &mHRPc::mGetLastAttackNpc)
			.addFunction("mSetAttackFromBackNpc", &mHRPc::mSetAttackFromBackNpc)
			.addFunction("mGetAttackFromBackNpc", &mHRPc::mGetAttackFromBackNpc)
			.addFunction("mGetFinishBonusFlag", &mHRPc::mGetFinishBonusFlag)
			.addFunction("mSetBanRollEscape", &mHRPc::mSetBanRollEscape)
			.addFunction("mSetBanJump", &mHRPc::mSetBanJump)
			.addFunction("mSetBanPiyori", &mHRPc::mSetBanPiyori)
			.addFunction("mSetBanDeadFukki", &mHRPc::mSetBanDeadFukki)
			.addFunction("mSetBanJustGuard", &mHRPc::mSetBanJustGuard)
			.addFunction("mSetBanWinTsubazeri", &mHRPc::mSetBanWinTsubazeri)
			.addFunction("mGetBanSlotCry", &mHRPc::mGetBanSlotCry)
			.addFunction("mGetBanSlotBel", &mHRPc::mGetBanSlotBel)
			.addFunction("mGetBanSlotBar", &mHRPc::mGetBanSlotBar)
			.addFunction("mGetBanSlot777", &mHRPc::mGetBanSlot777)
			.addFunction("mGetBanJump", &mHRPc::mGetBanJump)
			.addFunction("mGetBanPiyori", &mHRPc::mGetBanPiyori)
			.addFunction("mGetBanDeadFukki", &mHRPc::mGetBanDeadFukki)
			.addFunction("mGetBanJustGuard", &mHRPc::mGetBanJustGuard)
			.addFunction("mGetBanWinTsubazeri", &mHRPc::mGetBanWinTsubazeri)
			.addFunction("mGetWepStick", &mHRPc::mGetWepStick)
			.addFunction("mGetDontSubBattery", &mHRPc::mGetDontSubBattery)
			.addFunction("mGetAutoSubBatteryDisEnable", &mHRPc::mGetAutoSubBatteryDisEnable)
			.addFunction("mGetJustGuardDisEnable", &mHRPc::mGetJustGuardDisEnable)
			.addFunction("mSetDashAtkExec", &mHRPc::mSetDashAtkExec)
			.addFunction("mGetDashAtkExec", &mHRPc::mGetDashAtkExec)
			.addFunction("mGetJustEscapeDisEnable", &mHRPc::mGetJustEscapeDisEnable)
			.addFunction("mGetFpsCursorPtr", &mHRPc::mGetFpsCursorPtr)
			.addFunction("mSetDontRestoreMotion", &mHRPc::mSetDontRestoreMotion)
			.addFunction("mGetDontRestoreMotion", &mHRPc::mGetDontRestoreMotion)
			.addFunction("mSetBikeClash2battou", &mHRPc::mSetBikeClash2battou)
			.addFunction("mSetRotInterpolate", &mHRPc::mSetRotInterpolate)
			.addFunction("mGetRotInterpolateDefault", &mHRPc::mGetRotInterpolateDefault)
			.addFunction("mGetHiTension", &mHRPc::mGetHiTension)
			.addFunction("mTestDancingCombo", &mHRPc::mTestDancingCombo)
			.addFunction("mTestBullet", &mHRPc::mTestBullet)
			.addFunction("mTestFire", &mHRPc::mTestFire)
			.addFunction("mTest360", &mHRPc::mTest360)
			.addFunction("mSetTigerVisible", &mHRPc::mSetTigerVisible)
			.addFunction("mGetTigerVisible", &mHRPc::mGetTigerVisible)
			.addFunction("mGetRightWepTrianglePtr", &mHRPc::mGetRightWepTrianglePtr)
			.addFunction("mGetWepTrianglePtr", &mHRPc::mGetWepTrianglePtr)
			.addFunction("mGetResourceGmfPtr", &mHRPc::mGetResourceGmfPtr)
			.addFunction("mSetPauseNpcFlag", &mHRPc::mSetPauseNpcFlag)
			.addFunction("mGetPauseNpcFlag", &mHRPc::mGetPauseNpcFlag)
			.addFunction("getCurTigerMotionName", &mHRPc::getCurTigerMotionName)
			.addFunction("getCurMotionName", &mHRPc::getCurMotionName)
			.addFunction("isOutResourceMotion", &mHRPc::isOutResourceMotion)
			.addFunction("mGetCancelSetPadOffset", &mHRPc::mGetCancelSetPadOffset)
			.addFunction("mGetChangeEquipFromScript", &mHRPc::mGetChangeEquipFromScript)
			.addFunction("mSetNoBatteryThrow", &mHRPc::mSetNoBatteryThrow)
			.addFunction("mGetNoBatteryThrow", &mHRPc::mGetNoBatteryThrow)
			.addFunction("mSetChangeWeaponEffectVisible", &mHRPc::mSetChangeWeaponEffectVisible)
			.addFunction("mGetChangeWeaponEffectVisible", &mHRPc::mGetChangeWeaponEffectVisible)
			.addFunction("mSetLockOnNockDown", &mHRPc::mSetLockOnNockDown)
			.addFunction("mGetLockOnNockDown", &mHRPc::mGetLockOnNockDown)
			.addFunction("mSetAttackHajiki", &mHRPc::mSetAttackHajiki)
			.addFunction("mGetAttackHajiki", &mHRPc::mGetAttackHajiki)
			.addFunction("mSetDontPlayLoseTsubazeriMotion", &mHRPc::mSetDontPlayLoseTsubazeriMotion)
			.addFunction("mGetDontPlayLoseTsubazeriMotion", &mHRPc::mGetDontPlayLoseTsubazeriMotion)
			.addFunction("mGetNoWearJacket", &mHRPc::mGetNoWearJacket)
			.addFunction("mSetDispChangeWeaponIcon", &mHRPc::mSetDispChangeWeaponIcon)
			.addFunction("mGetDispChangeWeaponIcon", &mHRPc::mGetDispChangeWeaponIcon)
			.addFunction("mSetStandUpAttack", &mHRPc::mSetStandUpAttack)
			.addFunction("mGetStandUpAttack", &mHRPc::mGetStandUpAttack)
			.addFunction("mSetPushingBatteryChargeButton", &mHRPc::mSetPushingBatteryChargeButton)
			.addFunction("mGetPushingBatteryChargeButton", &mHRPc::mGetPushingBatteryChargeButton)
			.addFunction("mSetHitBigConsumeBattertAttack", &mHRPc::mSetHitBigConsumeBattertAttack)
			.addFunction("mGetHitBigConsumeBattertAttack", &mHRPc::mGetHitBigConsumeBattertAttack)
			.addFunction("mSetStartThrowSlow", &mHRPc::mSetStartThrowSlow)
			.addFunction("mGetStartThrowSlow", &mHRPc::mGetStartThrowSlow)
			.addFunction("mGetForceLoseTsubazeri", &mHRPc::mGetForceLoseTsubazeri)
			.addFunction("mGetEqWepID", &mHRPc::mGetEqWepID)
			.addFunction("mGetWepCmbExtend", &mHRPc::mGetWepCmbExtend)
			.addFunction("mSetDeadMotionPlayFlag", &mHRPc::mSetDeadMotionPlayFlag)
			.addFunction("getNPCInterestPosition", &mHRPc::getNPCInterestPosition)
			.addFunction("mGetStammina", &mHRPc::mGetStammina)
			.addFunction("mGetPcStatusPtr", &mHRPc::mGetPcStatusPtr)
			.addFunction("mGetBikeVisible", &mHRPc::mGetBikeVisible)
			.addFunction("mGetFinishNpcNum", &mHRPc::mGetFinishNpcNum)
			.addFunction("mGetLockOnDummyPtr", &mHRPc::mGetLockOnDummyPtr)
			.addFunction("mGetCallMotionProcess", &mHRPc::mGetCallMotionProcess)
			.addFunction("mSetDeadBossNum", &mHRPc::mSetDeadBossNum)
			.addFunction("mGetThrowInfoPtr", &mHRPc::mGetThrowInfoPtr)
			.addFunction("mGetCatchNpc", &mHRPc::mGetCatchNpc)
			.addFunction("mCheckFinishAttackJustBeforeHitSlow", &mHRPc::mCheckFinishAttackJustBeforeHitSlow)
			.addFunction("mGetPcEffectPtr", &mHRPc::mGetPcEffectPtr)
			.addFunction("mGetCallBikeFlag", &mHRPc::mGetCallBikeFlag)
			.addFunction("mGetLostBikeFlag", &mHRPc::mGetLostBikeFlag)
			.addFunction("mSetBikeSight", &mHRPc::mSetBikeSight)
			.addFunction("mSetDontChangeBikeCamera", &mHRPc::mSetDontChangeBikeCamera)
			.addFunction("mGetOnlyMove", &mHRPc::mGetOnlyMove)
			.addFunction("mGetDeadPauseFlag", &mHRPc::mGetDeadPauseFlag)
			.addFunction("mCheckTameMax", &mHRPc::mCheckTameMax)
			.addFunction("mTestHitFinishAttack", &mHRPc::mTestHitFinishAttack)
			.addFunction("mGetFinishJudgeFrame", &mHRPc::mGetFinishJudgeFrame)
			.addFunction("mGetCmbNum", &mHRPc::mGetCmbNum)
			.addFunction("mSetOnlyFlagBattouDemo", &mHRPc::mSetOnlyFlagBattouDemo)
			.addFunction("mSetOnlyFlagNoutouDemo", &mHRPc::mSetOnlyFlagNoutouDemo)
			.addFunction("mSetLockOnThroughWall", &mHRPc::mSetLockOnThroughWall)
			.addFunction("mIsDoingFinishMotion", &mHRPc::mIsDoingFinishMotion)
			.addFunction("mGetSlashModeOnly", &mHRPc::mGetSlashModeOnly)
			.addFunction("mGetBanRollEscape", &mHRPc::mGetBanRollEscape)
			.addFunction("mGetDashAtkDisEnable", &mHRPc::mGetDashAtkDisEnable)
			.addFunction("mGetShopDataPtr", &mHRPc::mGetShopDataPtr)
			.addFunction("mGetCatchTick", &mHRPc::mGetCatchTick)
			.addFunction("UnlockAllMoves", &mHRPc::UnlockAllMoves)
			.addFunction("UnlockAllUpgrades", &mHRPc::UnlockAllUpgrades)
			.addFunction("UnlockAllPcUpgrades", &mHRPc::UnlockAllPcUpgrades)
			.addFunction("SwitchToMainWeapon", &mHRPc::SwitchToMainWeapon)
			.addFunction("UnlockAllWeapons", &mHRPc::UnlockAllWeapons)
			.addFunction("SubPcNowEquipBatteryRatio", &mHRPc::SubPcNowEquipBatteryRatio)
			.addFunction("isAcceptCameraFollowRotation", &mHRPc::isAcceptCameraFollowRotation)
			.addFunction("mTestCanDownAttack", &mHRPc::mTestCanDownAttack)
			.addFunction("mTestRunWeaponEffect", &mHRPc::mTestRunWeaponEffect)
			.addFunction("mFloorEventProc", &mHRPc::mFloorEventProc)
			.addFunction("mCallClearProcessBeforeEvent", &mHRPc::mCallClearProcessBeforeEvent)
			.addFunction("mGetSlowMotion", &mHRPc::mGetSlowMotion)
			.addFunction("mSlowMotionProc", &mHRPc::mSlowMotionProc)
			.addFunction("mSlowMotionSystem", &mHRPc::mSlowMotionSystem)
			.addFunction("mDeadProc", &mHRPc::mDeadProc)
			.addFunction("IncSwingCount", &mHRPc::IncSwingCount)
			.addFunction("TestStoreBikePosForSM", &mHRPc::TestStoreBikePosForSM)
			.addFunction("ReStoreBikePosForSM", &mHRPc::ReStoreBikePosForSM)
			.addFunction("mDigHoleProc", &mHRPc::mDigHoleProc)
			.addFunction("mTestDigHoleAction", &mHRPc::mTestDigHoleAction)
			.addFunction("PcInputMove", &mHRPc::PcInputMove)
			.addFunction("PcInputIdleProc", &mHRPc::PcInputIdleProc)
			.addFunction("mTestCatchZako", &mHRPc::mTestCatchZako)
			.addFunction("mRestore1stChBGM", &mHRPc::mRestore1stChBGM)
			.addFunction("mPlay2ndChBGM", &mHRPc::mPlay2ndChBGM)
			.addFunction("mGetSmokeColor", &mHRPc::mGetSmokeColor)
			.addFunction("mExitBatteryCharge", &mHRPc::mExitBatteryCharge)
			.addFunction("mHitCheckNpc", &mHRPc::mHitCheckNpc)
			.addFunction("mSetCherryFlag", &mHRPc::mSetCherryFlag)
			.addFunction("mCheckBossThrow", &mHRPc::mCheckBossThrow)
			.addFunction("mGetJustGuardJudgeTick", &mHRPc::mGetJustGuardJudgeTick)
			.addFunction("mCheckCanFight", &mHRPc::mCheckCanFight)
			.addFunction("mClearBomStockNum", &mHRPc::mClearBomStockNum)
			.addFunction("mGetSpecialAttackRestTick", &mHRPc::mGetSpecialAttackRestTick)
			.addFunction("mGetEmptyShinkuWaveIndex", &mHRPc::mGetEmptyShinkuWaveIndex)
			.addFunction("mCreateShinkuWave", &mHRPc::mCreateShinkuWave)
			.addFunction("mCallEffectBlur", &mHRPc::mCallEffectBlur)
			.addFunction("mSetLaserTrack", &mHRPc::mSetLaserTrack)
			.addFunction("mSetLaserScale", &mHRPc::mSetLaserScale)
			.addFunction("mSetLaserLogValid", &mHRPc::mSetLaserLogValid)
			.addFunction("mGetLaserColor", &mHRPc::mGetLaserColor)
			.addFunction("mSetLaserColor", &mHRPc::mSetLaserColor)
			.addFunction("mCreateLaserEffect", &mHRPc::mCreateLaserEffect)
			.addFunction("mDeleteChargeEffect", &mHRPc::mDeleteChargeEffect)
			.addFunction("mCreateChargeEffect", &mHRPc::mCreateChargeEffect)
			.addFunction("mCheckBigWeapon", &mHRPc::mCheckBigWeapon)
			.addFunction("mSetDigToolFlag", &mHRPc::mSetDigToolFlag)
			.addFunction("mClearMMSMInit", &mHRPc::mClearMMSMInit)
			.addFunction("mSetBikePos2Motel", &mHRPc::mSetBikePos2Motel)
			.addFunction("mGetStopRenderCounter", &mHRPc::mGetStopRenderCounter)
			.addFunction("mSetStopRenderCounter", &mHRPc::mSetStopRenderCounter)
			.addFunction("mGetLightSideNum", &mHRPc::mGetLightSideNum)
			.addFunction("mGetReceiveDamage", &mHRPc::mGetReceiveDamage)
			.addFunction("mGetMaxCombo", &mHRPc::mGetMaxCombo)
			.addFunction("mSetDown", &mHRPc::mSetDown)
			.addFunction("mSetCallBikeFlag", &mHRPc::mSetCallBikeFlag)
			.addFunction("mSetFireMan", &mHRPc::mSetFireMan)
			.addFunction("mGetDarkSideUseNum", &mHRPc::mGetDarkSideUseNum)
			.addFunction("mGetLightSideRate", &mHRPc::mGetLightSideRate)
			.addFunction("mCallSwordCutDmgEffect", &mHRPc::mCallSwordCutDmgEffect)
			.addFunction("mCallBeamCutDmgEffect", &mHRPc::mCallBeamCutDmgEffect)
			.addFunction("mCallFightAttackDmgEffect", &mHRPc::mCallFightAttackDmgEffect)
			.addFunction("mCallElectDmgEffect", &mHRPc::mCallElectDmgEffect)
			.addFunction("mCallNormalAttackEffect", &mHRPc::mCallNormalAttackEffect)
			.addFunction("IsCenteringHoseiCutmark", &mHRPc::IsCenteringHoseiCutmark)
			.addFunction("CreateCutMarkEffect", &mHRPc::CreateCutMarkEffect)
			.addFunction("CreateGuardBreakEffect", &mHRPc::CreateGuardBreakEffect)
			.addFunction("mSePlayChargeAttack", &mHRPc::mSePlayChargeAttack)
			.addFunction("mCallFinishAttackEffect", &mHRPc::mCallFinishAttackEffect)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mCreateHugGan", &mHRPc::mCreateHugGan)
			.addFunction("mPlayHugMotion", &mHRPc::mPlayHugMotion)
			.addFunction("mSetPoisonWalk", &mHRPc::mSetPoisonWalk)
			.addFunction("mSetElectroShockBGMPitch", &mHRPc::mSetElectroShockBGMPitch)
			.addFunction("mCheckReadEndAtkMot", &mHRPc::mCheckReadEndAtkMot)
			.addFunction("mGetPcBtlPoseNowMotion", &mHRPc::mGetPcBtlPoseNowMotion)
			.addFunction("mCheckFinishNpc", &mHRPc::mCheckFinishNpc)
			.addFunction("mGetHitEffectPos", &mHRPc::mGetHitEffectPos)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mGetHitEffectPos", &mHRPc::mGetHitEffectPos)
			.addFunction("mSetNoutou", &mHRPc::mSetNoutou)
			.addFunction("mSetBattou", &mHRPc::mSetBattou)
			.addFunction("mGetBikeNitro", &mHRPc::mGetBikeNitro)
			.addFunction("mGetBikeRot", &mHRPc::mGetBikeRot)
			.addFunction("mGetEquipDurabilityMax", &mHRPc::mGetEquipDurabilityMax)
			.addFunction("mGetEquipDurability", &mHRPc::mGetEquipDurability)
			.addFunction("mSetOnlyEquip", &mHRPc::mSetOnlyEquip)
			.addFunction("mChangeWeapon4Debug", &mHRPc::mChangeWeapon4Debug)
			.addFunction("mChangeEquipID2KindIndex", &mHRPc::mChangeEquipID2KindIndex)
			.addFunction("mGetLockerIndex", &mHRPc::mGetLockerIndex)
			.addFunction("mDelLocker", &mHRPc::mDelLocker)
			.addFunction("mGetDamageRate", &mHRPc::mGetDamageRate)
			.addFunction("mSetWepCmbExtend", &mHRPc::mSetWepCmbExtend)
			.addFunction("mGetWepPower", &mHRPc::mGetWepPower)
			.addFunction("mSetWepPower", &mHRPc::mSetWepPower)
			.addFunction("mDelWep", &mHRPc::mDelWep)
			.addFunction("mAddWep", &mHRPc::mAddWep)
			.addFunction("mMissCatch", &mHRPc::mMissCatch)
			.addFunction("mPlayThrowMissMotion", &mHRPc::mPlayThrowMissMotion)
			.addFunction("mDispThrowInput", &mHRPc::mDispThrowInput)
			.addFunction("mStartThrowInput", &mHRPc::mStartThrowInput)
			.addFunction("mAdjustHitWallPosition", &mHRPc::mAdjustHitWallPosition)
			.addFunction("mStartThrowSNB", &mHRPc::mStartThrowSNB)
			.addFunction("mFrameProcChangeScreen", &mHRPc::mFrameProcChangeScreen)
			.addFunction("mPlayMiniDemoForWarpPosSantDestroy", &mHRPc::mPlayMiniDemoForWarpPosSantDestroy)
			.addFunction("mSetAfterWarpPosForSantDestroy", &mHRPc::mSetAfterWarpPosForSantDestroy)
			.addFunction("mTestEndWarpPosForSantDestroy", &mHRPc::mTestEndWarpPosForSantDestroy)
			.addFunction("mSetWarpPosForSantDestroy", &mHRPc::mSetWarpPosForSantDestroy)
			.addFunction("mGetChangeScreenStatus", &mHRPc::mGetChangeScreenStatus)
			.addFunction("mEndChangeScreen", &mHRPc::mEndChangeScreen)
			.addFunction("mStartChangeScreen", &mHRPc::mStartChangeScreen)
			.addFunction("mSetBatteryMax", &mHRPc::mSetBatteryMax)
			.addFunction("mGetBatteryRatio", &mHRPc::mGetBatteryRatio)
			.addFunction("mSubBattery", &mHRPc::mSubBattery)
			.addFunction("mAddBattery", &mHRPc::mAddBattery)
			.addFunction("mRecoverNoutouWeaponBattery", &mHRPc::mRecoverNoutouWeaponBattery)
			.addFunction("mPlayMotionEscape", &mHRPc::mPlayMotionEscape)
			.addFunction("mGetInputGuardSlide", &mHRPc::mGetInputGuardSlide)
			.addFunction("mTestLeftGuard", &mHRPc::mTestLeftGuard)
			.addFunction("mTestRightGuard", &mHRPc::mTestRightGuard)
			.addFunction("mTestUpGuard", &mHRPc::mTestUpGuard)
			.addFunction("mGetInputTurn", &mHRPc::mGetInputTurn)
			.addFunction("mGetAttackTimingFrame", &mHRPc::mGetAttackTimingFrame)
			.addFunction("mGetLeftWepTrianglePtr", &mHRPc::mGetLeftWepTrianglePtr)
			.addFunction("mGetExtraComboMotionNo", &mHRPc::mGetExtraComboMotionNo)
			.addFunction("mGetNormalComboMotionNo", &mHRPc::mGetNormalComboMotionNo)
			.addFunction("mSetComboKind", &mHRPc::mSetComboKind)
			.addFunction("mReturnIdleMove", &mHRPc::mReturnIdleMove)
			.addFunction("mDashProc", &mHRPc::mDashProc)
			.addFunction("mDashStartProc", &mHRPc::mDashStartProc)
			.addFunction("mForceLanding", &mHRPc::mForceLanding)
			.addFunction("mCheckJumpAttack", &mHRPc::mCheckJumpAttack)
			.addFunction("mCheckJump", &mHRPc::mCheckJump)
			.addFunction("mJumpProc", &mHRPc::mJumpProc)
			.addFunction("mCheckRouletteAbility", &mHRPc::mCheckRouletteAbility)
			.addFunction("mPreStartProcessSpecialMode", &mHRPc::mPreStartProcessSpecialMode)
			.addFunction("mClear360", &mHRPc::mClear360)
			.addFunction("mClearFire", &mHRPc::mClearFire)
			.addFunction("mClearTiger", &mHRPc::mClearTiger)
			.addFunction("mClearDancingCombo", &mHRPc::mClearDancingCombo)
			.addFunction("mClearRapidFinish", &mHRPc::mClearRapidFinish)
			.addFunction("mClearBullet", &mHRPc::mClearBullet)
			.addFunction("mStartDarkSide", &mHRPc::mStartDarkSide)
			.addFunction("mStart360", &mHRPc::mStart360)
			.addFunction("mStartFire", &mHRPc::mStartFire)
			.addFunction("mStartTiger", &mHRPc::mStartTiger)
			.addFunction("mStartDancingCombo", &mHRPc::mStartDancingCombo)
			.addFunction("mStartRapidFinish", &mHRPc::mStartRapidFinish)
			.addFunction("mStartBullet", &mHRPc::mStartBullet)
			.addFunction("mCheckTigerAttack", &mHRPc::mCheckTigerAttack)
			.addFunction("mTermTiger", &mHRPc::mTermTiger)
			.addFunction("mTigerAttackProc", &mHRPc::mTigerAttackProc)
			.addFunction("mTigerProc", &mHRPc::mTigerProc)
			.addFunction("mTigerAttackInput", &mHRPc::mTigerAttackInput)
			.addFunction("mTigerPadInputProc", &mHRPc::mTigerPadInputProc)
			.addFunction("mCallTigerSetupMatrix", &mHRPc::mCallTigerSetupMatrix)
			.addFunction("mCallTigerMotionProcess", &mHRPc::mCallTigerMotionProcess)
			.addFunction("mUpdateTigerPos", &mHRPc::mUpdateTigerPos)
			.addFunction("mPlayTigerMotion", &mHRPc::mPlayTigerMotion)
			.addFunction("mClearRapidFinishTarget", &mHRPc::mClearRapidFinishTarget)
			.addFunction("mSetRapidFinishTarget", &mHRPc::mSetRapidFinishTarget)
			.addFunction("mSearchRapidFinishNpc", &mHRPc::mSearchRapidFinishNpc)
			.addFunction("mCheckResistRapidFinishNpc", &mHRPc::mCheckResistRapidFinishNpc)
			.addFunction("mSetRapidFinishNpc", &mHRPc::mSetRapidFinishNpc)
			.addFunction("mGet360Tick", &mHRPc::mGet360Tick)
			.addFunction("mGetFireTick", &mHRPc::mGetFireTick)
			.addFunction("mGetTigerTick", &mHRPc::mGetTigerTick)
			.addFunction("mGetDancingComboTick", &mHRPc::mGetDancingComboTick)
			.addFunction("mGetRapidFinishTick", &mHRPc::mGetRapidFinishTick)
			.addFunction("mGetBulletTick", &mHRPc::mGetBulletTick)
			.addFunction("mGetRotInterpolate", &mHRPc::mGetRotInterpolate)
			.addFunction("mCheckChargeMax", &mHRPc::mCheckChargeMax)
			.addFunction("mCheckInputBatteryCharge", &mHRPc::mCheckInputBatteryCharge)
			.addFunction("mCheckInputGuard", &mHRPc::mCheckInputGuard)
			.addFunction("checkAndUpdateWeaponLength", &mHRPc::checkAndUpdateWeaponLength)
			.addFunction("mCallWepMotionProc", &mHRPc::mCallWepMotionProc)
			.addFunction("mSetWepMotionRate", &mHRPc::mSetWepMotionRate)
			.addFunction("mPlayWepMotion", &mHRPc::mPlayWepMotion)
			.addFunction("mSetWeaponLength", &mHRPc::mSetWeaponLength)
			.addFunction("mResumeEasyDemo", &mHRPc::mResumeEasyDemo)
			.addFunction("mPlayEasyDemo", &mHRPc::mPlayEasyDemo)
			.addFunction("mPlayNoutouDemo", &mHRPc::mPlayNoutouDemo)
			.addFunction("mPlayBattouDemo", &mHRPc::mPlayBattouDemo)
			.addFunction("mGetBattouEndMotion", &mHRPc::mGetBattouEndMotion)
			.addFunction("mGetBattouLoopMotion", &mHRPc::mGetBattouLoopMotion)
			.addFunction("mGetCmbNumMax", &mHRPc::mGetCmbNumMax)
			.addFunction("mUpdateLockOnDummyLocate", &mHRPc::mUpdateLockOnDummyLocate)
			.addFunction("mSetLockOnDummyAtOutOfRange", &mHRPc::mSetLockOnDummyAtOutOfRange)
			.addFunction("mUpdateWatchNpc", &mHRPc::mUpdateWatchNpc)
			.addFunction("mUpdateLockOnTarget", &mHRPc::mUpdateLockOnTarget)
			.addFunction("mUpdateLockOnList", &mHRPc::mUpdateLockOnList)
			.addFunction("mRotate2LockOnTarget", &mHRPc::mRotate2LockOnTarget)
			.addFunction("mSetLockOn", &mHRPc::mSetLockOn)
			.addFunction("mCheckLockOnDummy", &mHRPc::mCheckLockOnDummy)
			.addFunction("mInitLockOn", &mHRPc::mInitLockOn)
			.addFunction("mDarkSideSonicProc", &mHRPc::mDarkSideSonicProc)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("bootGuardLightFlashEffect", &mHRPc::bootGuardLightFlashEffect)
			.addFunction("LaserScaleProc", &mHRPc::LaserScaleProc)
			.addFunction("mEffectProc", &mHRPc::mEffectProc)
			.addFunction("mTestBeamKatanaShowyEffect", &mHRPc::mTestBeamKatanaShowyEffect)
			.addFunction("mGetCatchDistance", &mHRPc::mGetCatchDistance)
			.addFunction("mGetMotionSpeed", &mHRPc::mGetMotionSpeed)
			.addFunction("mSetFinishMotionSpeed", &mHRPc::mSetFinishMotionSpeed)
			.addFunction("mCheckTargetObject", &mHRPc::mCheckTargetObject)
			.addFunction("mSearchAttackTargetNpc", &mHRPc::mSearchAttackTargetNpc)
			.addFunction("mSearchDarkSideWarpTargetNpc", &mHRPc::mSearchDarkSideWarpTargetNpc)
			.addFunction("mSearchNearNpc", &mHRPc::mSearchNearNpc)
			.addFunction("mLookAttackTargetNpc", &mHRPc::mLookAttackTargetNpc)
			.addFunction("mLockNearNpc", &mHRPc::mLockNearNpc)
			.addFunction("mLockNearCatchNpc", &mHRPc::mLockNearCatchNpc)
			.addFunction("mAddKillNpcCombo", &mHRPc::mAddKillNpcCombo)
			.addFunction("mIntiFinishNpc", &mHRPc::mIntiFinishNpc)
			.addFunction("mSetDarkSideTarget", &mHRPc::mSetDarkSideTarget)
			.addFunction("mInputDarkSideSuccess", &mHRPc::mInputDarkSideSuccess)
			.addFunction("mPcMoveFrontOfNpc4DarkSideMode", &mHRPc::mPcMoveFrontOfNpc4DarkSideMode)
			.addFunction("mPcMoveFrontOfNpc", &mHRPc::mPcMoveFrontOfNpc)
			.addFunction("mSearchNextNpc", &mHRPc::mSearchNextNpc)
			.addFunction("mCheckFinishMode", &mHRPc::mCheckFinishMode)
			.addFunction("mPrepareInputFinish", &mHRPc::mPrepareInputFinish)
			.addFunction("mSetIntoTsubazeriai", &mHRPc::mSetIntoTsubazeriai)
			.addFunction("mSePlayUpperAttack", &mHRPc::mSePlayUpperAttack)
			.addFunction("mTameAttckProc", &mHRPc::mTameAttckProc)
			.addFunction("mJoyuuLight", &mHRPc::mJoyuuLight)
			.addFunction("mSlotResult", &mHRPc::mSlotResult)
			.addFunction("mAttackHitCheck", &mHRPc::mAttackHitCheck)
			.addFunction("mAttackProc", &mHRPc::mAttackProc)
			.addFunction("mFailedInputFinishProcessForVsBoss", &mHRPc::mFailedInputFinishProcessForVsBoss)
			.addFunction("mSpecialFightAttackProc", &mHRPc::mSpecialFightAttackProc)
			.addFunction("mCheckComboAttackInput", &mHRPc::mCheckComboAttackInput)
			.addFunction("mTrvStartDownAttack", &mHRPc::mTrvStartDownAttack)
			.addFunction("mStartFightAttack", &mHRPc::mStartFightAttack)
			.addFunction("mGetAttackMotionStartFrame30fps", &mHRPc::mGetAttackMotionStartFrame30fps)
			.addFunction("mCheckCanCatchNpc", &mHRPc::mCheckCanCatchNpc)
			.addFunction("mSetSEPlayShakeInputSuccess", &mHRPc::mSetSEPlayShakeInputSuccess)
			.addFunction("mPlayFinishMotion", &mHRPc::mPlayFinishMotion)
			.addFunction("mSuccessFinishInput", &mHRPc::mSuccessFinishInput)
			.addFunction("mFinishMotionFrameKetaAge", &mHRPc::mFinishMotionFrameKetaAge)
			.addFunction("mPlayNunchackAttackMotion", &mHRPc::mPlayNunchackAttackMotion)
			.addFunction("mClearNpcDamageInfo", &mHRPc::mClearNpcDamageInfo)
			.addFunction("mGetHjkDir", &mHRPc::mGetHjkDir)
			.addFunction("mGetFinishAtkMotNo", &mHRPc::mGetFinishAtkMotNo)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSearchThrow", &mHRPc::mSearchThrow)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetPcThrowMotNo", &mHRPc::mGetPcThrowMotNo)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetThrowDamageMotion", &mHRPc::mGetThrowDamageMotion)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetPcThrowMotNo4ZakoB", &mHRPc::mGetPcThrowMotNo4ZakoB)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetPcThrowMotNo4ZakoF", &mHRPc::mGetPcThrowMotNo4ZakoF)
			.addFunction("mCheckThrowSpace", &mHRPc::mCheckThrowSpace)
			.addFunction("mGetDownAtkMotNo", &mHRPc::mGetDownAtkMotNo)
			.addFunction("mGetNextAtkMotNo", &mHRPc::mGetNextAtkMotNo)
			.addFunction("mAttackRestoreProc", &mHRPc::mAttackRestoreProc)
			.addFunction("mAttackStoreProc", &mHRPc::mAttackStoreProc)
			.addFunction("mResetCombo", &mHRPc::mResetCombo)
			.addFunction("mChangeWep", &mHRPc::mChangeWep)
			.addFunction("mWepSeReleaseRequest", &mHRPc::mWepSeReleaseRequest)
			.addFunction("mInitWepStatus", &mHRPc::mInitWepStatus)
			.addFunction("mGetWepIndex", &mHRPc::mGetWepIndex)
			.addFunction("mGetAtkNo", &mHRPc::mGetAtkNo)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mGetAtkNo", &mHRPc::mGetAtkNo)
			.addFunction("mSideStepProc", &mHRPc::mSideStepProc)
			.addFunction("mGetRollEscMotNo", &mHRPc::mGetRollEscMotNo)
			.addFunction("mMoveProc", &mHRPc::mMoveProc)
			.addFunction("mGetPcWillDirectRotY", &mHRPc::mGetPcWillDirectRotY)
			.addFunction("mGetRunSpeed", &mHRPc::mGetRunSpeed)
			.addFunction("mGetWalkSpeed", &mHRPc::mGetWalkSpeed)
			.addFunction("mMoveCommon", &mHRPc::mMoveCommon)
			.addFunction("mLockOnMoveProc", &mHRPc::mLockOnMoveProc)
			.addFunction("mUpdateAtkColl", &mHRPc::mUpdateAtkColl)
			.addFunction("mStartChargeEffect", &mHRPc::mStartChargeEffect)
			.addFunction("mPreResetChargeAttack", &mHRPc::mPreResetChargeAttack)
			.addFunction("mCheckLastTarget", &mHRPc::mCheckLastTarget)
			.addFunction("mCheckBDash", &mHRPc::mCheckBDash)
			.addFunction("mCheckChangeWeapon", &mHRPc::mCheckChangeWeapon)
			.addFunction("mCheckWakeUpZako", &mHRPc::mCheckWakeUpZako)
			.addFunction("mCheckSchool3RapidAttack", &mHRPc::mCheckSchool3RapidAttack)
			.addFunction("mCheckBackAttack", &mHRPc::mCheckBackAttack)
			.addFunction("mCheckInputDirection4Pc", &mHRPc::mCheckInputDirection4Pc)
			.addFunction("mCheckThrowInput", &mHRPc::mCheckThrowInput)
			.addFunction("mCheckInputCombo", &mHRPc::mCheckInputCombo)
			.addFunction("mCheckFollowThorough", &mHRPc::mCheckFollowThorough)
			.addFunction("mCheckSantDash", &mHRPc::mCheckSantDash)
			.addFunction("mCheckNormalAttack", &mHRPc::mCheckNormalAttack)
			.addFunction("mCheckNormalDashAttack", &mHRPc::mCheckNormalDashAttack)
			.addFunction("mCheck777Bomb", &mHRPc::mCheck777Bomb)
			.addFunction("mCheck777BombStart", &mHRPc::mCheck777BombStart)
			.addFunction("mCheckIdling", &mHRPc::mCheckIdling)
			.addFunction("mCheckIdlingMotion", &mHRPc::mCheckIdlingMotion)
			.addFunction("mCheckRollEscape", &mHRPc::mCheckRollEscape)
			.addFunction("mCheckGuard", &mHRPc::mCheckGuard)
			.addFunction("mCheckChargeUpDown", &mHRPc::mCheckChargeUpDown)
			.addFunction("mCheckCharge", &mHRPc::mCheckCharge)
			.addFunction("mCheckCanCancelLastCombo", &mHRPc::mCheckCanCancelLastCombo)
			.addFunction("mCheckLastCombo", &mHRPc::mCheckLastCombo)
			.addFunction("mCheckStrongComboAttack", &mHRPc::mCheckStrongComboAttack)
			.addFunction("mCheckPiyoriComboAttack", &mHRPc::mCheckPiyoriComboAttack)
			.addFunction("mCheckNockBack", &mHRPc::mCheckNockBack)
			.addFunction("mCheckDown2StandUp", &mHRPc::mCheckDown2StandUp)
			.addFunction("mCheckDown", &mHRPc::mCheckDown)
			.addFunction("mCheckBlowStatus", &mHRPc::mCheckBlowStatus)
			.addFunction("mCheckBombAttack", &mHRPc::mCheckBombAttack)
			.addFunction("mCheckJumpThrustAttack", &mHRPc::mCheckJumpThrustAttack)
			.addFunction("mCheckChargeAttack", &mHRPc::mCheckChargeAttack)
			.addFunction("mCheckNunchackAttack", &mHRPc::mCheckNunchackAttack)
			.addFunction("mCheckRangeAttack", &mHRPc::mCheckRangeAttack)
			.addFunction("mCheckThrowBeforeAttack", &mHRPc::mCheckThrowBeforeAttack)
			.addFunction("mCheckCatchMiss", &mHRPc::mCheckCatchMiss)
			.addFunction("mStartCatchAttack", &mHRPc::mStartCatchAttack)
			.addFunction("mCheckDownAttack", &mHRPc::mCheckDownAttack)
			.addFunction("mCheckFightCmbAttack", &mHRPc::mCheckFightCmbAttack)
			.addFunction("mCheckCityFightAttack", &mHRPc::mCheckCityFightAttack)
			.addFunction("mCheckCanAttack", &mHRPc::mCheckCanAttack)
			.addFunction("mCheckAttackHit", &mHRPc::mCheckAttackHit)
			.addFunction("mCheckAttack", &mHRPc::mCheckAttack)
			.addFunction("mSetHajikareWait", &mHRPc::mSetHajikareWait)
			.addFunction("mCheckHajikareWait", &mHRPc::mCheckHajikareWait)
			.addFunction("mSetGuardWait", &mHRPc::mSetGuardWait)
			.addFunction("mCheckGuardWait", &mHRPc::mCheckGuardWait)
			.addFunction("mCheckHajikare", &mHRPc::mCheckHajikare)
			.addFunction("mCheckGuardMotion", &mHRPc::mCheckGuardMotion)
			.addFunction("mCheckRestorePadOffset", &mHRPc::mCheckRestorePadOffset)
			.addFunction("mResetPadOffset", &mHRPc::mResetPadOffset)
			.addFunction("mSetNeedShakeDir", &mHRPc::mSetNeedShakeDir)
			.addFunction("mCheckContinueCombo", &mHRPc::mCheckContinueCombo)
			.addFunction("mCheckAtkUpper", &mHRPc::mCheckAtkUpper)
			.addFunction("mGetChargeMotionNo", &mHRPc::mGetChargeMotionNo)
			.addFunction("mGetUpChargeAttackMotionNo", &mHRPc::mGetUpChargeAttackMotionNo)
			.addFunction("mResetCatch", &mHRPc::mResetCatch)
			.addFunction("mSetTsubaOuterMotion", &mHRPc::mSetTsubaOuterMotion)
			.addFunction("mSetTsubaDat", &mHRPc::mSetTsubaDat)
			.addFunction("mTsubazeriaiProc", &mHRPc::mTsubazeriaiProc)
			.addFunction("mGuardDamageProc", &mHRPc::mGuardDamageProc)
			.addFunction("mDamageProc", &mHRPc::mDamageProc)
			.addFunction("mGetAttackDistance", &mHRPc::mGetAttackDistance)
			.addFunction("mGetAttackDirection", &mHRPc::mGetAttackDirection)
			.addFunction("mTestRunMotion", &mHRPc::mTestRunMotion)
			.addFunction("mCheckDamageMotion", &mHRPc::mCheckDamageMotion)
			.addFunction("mCheckCanHit", &mHRPc::mCheckCanHit)
			.addFunction("mHitCheck", &mHRPc::mHitCheck)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetElectricDamage", &mHRPc::mSetElectricDamage)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &mHRPc::mSetDamage)
			.addFunction("mJudgeJustGuardInput", &mHRPc::mJudgeJustGuardInput)
			.addFunction("mJudgePiyori", &mHRPc::mJudgePiyori)
			.addFunction("mConvertGuardMotion", &mHRPc::mConvertGuardMotion)
			.addFunction("mSetDamageIK", &mHRPc::mSetDamageIK)
			.addFunction("mCheckAutoGuard", &mHRPc::mCheckAutoGuard)
			.addFunction("mCheckCanGuard", &mHRPc::mCheckCanGuard)
			.addFunction("mGetBtlCommonMotNo", &mHRPc::mGetBtlCommonMotNo)
			.addFunction("mSetWepEffectVisible", &mHRPc::mSetWepEffectVisible)
			.addFunction("mSetWepVisible", &mHRPc::mSetWepVisible)
			.addFunction("mSetVisible", &mHRPc::mSetVisible)
			.addFunction("mSetCamera2TrvBack", &mHRPc::mSetCamera2TrvBack)
			.addFunction("mSetCameraInit", &mHRPc::mSetCameraInit)
			.addFunction("mCallCameraInit", &mHRPc::mCallCameraInit)
			.addFunction("mCameraInitProcess", &mHRPc::mCameraInitProcess)
			.addFunction("mCallTsubaBrendMotPorc", &mHRPc::mCallTsubaBrendMotPorc)
			.addFunction("mCallCulcBrendRate", &mHRPc::mCallCulcBrendRate)
			.addFunction("mGetCollPtr", &mHRPc::mGetCollPtr)
			.addFunction("mBossDeadCommonProcess", &mHRPc::mBossDeadCommonProcess)
			.addFunction("mPlayBattleIdolMotion", &mHRPc::mPlayBattleIdolMotion)
			.addFunction("mResetValueAtPlayMotion", &mHRPc::mResetValueAtPlayMotion)
			// Can't export pointer to pointer 'class TGan**' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mPlayMotionBlend", &mHRPc::mPlayMotionBlend)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mPlayMotionBlend", &mHRPc::mPlayMotionBlend)
			.addFunction("mPlayMotion", &mHRPc::mPlayMotion)
			.addFunction("mGetAtkMotPPtr", &mHRPc::mGetAtkMotPPtr)
			.addFunction("mGetAtkMotPtr", &mHRPc::mGetAtkMotPtr)
			.addFunction("mRequestReadAtkMot", &mHRPc::mRequestReadAtkMot)
			.addFunction("mReleaseAtkMot", &mHRPc::mReleaseAtkMot)
			.addFunction("mCheckNeedModelRead", &mHRPc::mCheckNeedModelRead)
			.addFunction("mChangeTShirtModel", &mHRPc::mChangeTShirtModel)
			.addFunction("mSetNoWearJacket", &mHRPc::mSetNoWearJacket)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mControlDispWestWeapon", &mHRPc::mControlDispWestWeapon)
			.addFunction("mDetachWeapon", &mHRPc::mDetachWeapon)
			.addFunction("mAttachWeapon", &mHRPc::mAttachWeapon)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("mRenderFpsCursor", &mHRPc::mRenderFpsCursor)
			.addFunction("mAddTension", &mHRPc::mAddTension)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetWarpPos", &mHRPc::mSetWarpPos)
			.addFunction("mRenderShadowProc", &mHRPc::mRenderShadowProc)
			.addFunction("mPostRenderProc", &mHRPc::mPostRenderProc)
			.addFunction("mRenderProc", &mHRPc::mRenderProc)
			.addFunction("mSemitransparentProcess", &mHRPc::mSemitransparentProcess)
			.addFunction("mPostFrameCommonProc2", &mHRPc::mPostFrameCommonProc2)
			.addFunction("mPostFrameProc", &mHRPc::mPostFrameProc)
			.addFunction("mPcRestoreDamage", &mHRPc::mPcRestoreDamage)
			.addFunction("checkAndPlayCameraBankMotion", &mHRPc::checkAndPlayCameraBankMotion)
			.addFunction("checkAndBootStageHitEffect", &mHRPc::checkAndBootStageHitEffect)
			.addFunction("onUpdateIK", &mHRPc::onUpdateIK)
			.addFunction("mDamageElectroShockProc", &mHRPc::mDamageElectroShockProc)
			.addFunction("mDamageDownLeverGachaProc", &mHRPc::mDamageDownLeverGachaProc)
			.addFunction("mSpecialWalkProc", &mHRPc::mSpecialWalkProc)
			.addFunction("mCheckHaveWep", &mHRPc::mCheckHaveWep)
			.addFunction("mChangeWeaponProcess", &mHRPc::mChangeWeaponProcess)
			.addFunction("TryChangeWeapon", &mHRPc::TryChangeWeapon)
			.addFunction("mStartChangeWeapon", &mHRPc::mStartChangeWeapon)
			.addFunction("mFrameProc", &mHRPc::mFrameProc)
			.addFunction("mSetOffGroundIk", &mHRPc::mSetOffGroundIk)
			.addFunction("mInitData", &mHRPc::mInitData)
			.addFunction("mEffectInit", &mHRPc::mEffectInit)
			.addFunction("mTerm", &mHRPc::mTerm)
			.addFunction("mInit", &mHRPc::mInit)
			.addFunction("mCheckCanOperate", &mHRPc::mCheckCanOperate)
			.addFunction("mSetOutsidePlayMotion", &mHRPc::mSetOutsidePlayMotion)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetEquipTextureName", &mHRPc::mGetEquipTextureName)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mGetEquipModelName", &mHRPc::mGetEquipModelName)
			.addFunction("mTermWarpPosForSantDestroy", &mHRPc::mTermWarpPosForSantDestroy)
			.addFunction("mSubDarkSideTick", &mHRPc::mSubDarkSideTick)
			.addFunction("mEquipProc", &mHRPc::mEquipProc)
			.addFunction("mCheckBeforeAttackHit", &mHRPc::mCheckBeforeAttackHit)
			.addFunction("mCheckPcReadEndWithoutWeapon", &mHRPc::mCheckPcReadEndWithoutWeapon)
			.addFunction("mCheckFightAttack", &mHRPc::mCheckFightAttack)
			.addFunction("mCheckCatchAttack", &mHRPc::mCheckCatchAttack)
			.addFunction("mCallAttackEffect", &mHRPc::mCallAttackEffect)
			.addFunction("SetPcSpeedBlurOff", &mHRPc::SetPcSpeedBlurOff)
			.addFunction("mStopLightSabelSound", &mHRPc::mStopLightSabelSound)
			.addFunction("mGetPcPower", &mHRPc::mGetPcPower)
			.addFunction("mRestorePcData", &mHRPc::mRestorePcData)
			.addFunction("UnlockEverythingForDeathmatch", &mHRPc::UnlockEverythingForDeathmatch)
			.addFunction("mResetDeadFlag", &mHRPc::mResetDeadFlag)
			.addFunction("mSetBatteryMaxAllWeapon", &mHRPc::mSetBatteryMaxAllWeapon)
			.addFunction("mPlayLightSabelSound", &mHRPc::mPlayLightSabelSound)
			.addFunction("TurnOffLaserEffectOnPlayer", &mHRPc::TurnOffLaserEffectOnPlayer)
			.addFunction("mClearBossInit", &mHRPc::mClearBossInit)
			.addFunction("mGetPcSaveData", &mHRPc::mGetPcSaveData)
			.addFunction("TestStorePcPosForSM", &mHRPc::TestStorePcPosForSM)
			.addFunction("ReStorePcPosForSM", &mHRPc::ReStorePcPosForSM)
			.addFunction("mCheckIntoStatusScreen", &mHRPc::mCheckIntoStatusScreen)
			.addFunction("mPlayMotionFromDatPtr", &mHRPc::mPlayMotionFromDatPtr)
			.addFunction("mCheckFinishAttack", &mHRPc::mCheckFinishAttack)
			.addFunction("mCheckTsubazering", &mHRPc::mCheckTsubazering)
			.addFunction("mGetBikePos", &mHRPc::mGetBikePos)
			.addFunction("mTestBikeRide", &mHRPc::mTestBikeRide)
			.addFunction("mSetPadOffset", &mHRPc::mSetPadOffset)
			.addFunction("mCheckNeutral", &mHRPc::mCheckNeutral)
			.addFunction("mIsPlayMotion", &mHRPc::mIsPlayMotion)
			.addFunction("mCheckBatteryCharge", &mHRPc::mCheckBatteryCharge)
			.addFunction("mCheckInitCamera", &mHRPc::mCheckInitCamera)
			.addFunction("mCheckDead", &mHRPc::mCheckDead)
			.addFunction("mClearDarkSide", &mHRPc::mClearDarkSide)
			.addFunction("mExitChargeBattery4FixCamera", &mHRPc::mExitChargeBattery4FixCamera)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("StorePcPosForSM", &mHRPc::StorePcPosForSM)
			.addFunction("mCheckEquipReadEnd", &mHRPc::mCheckEquipReadEnd)
			.addFunction("mTestBattouDemo", &mHRPc::mTestBattouDemo)
			.addFunction("mAddLocker", &mHRPc::mAddLocker)
			.addFunction("mChkLocker", &mHRPc::mChkLocker)
			.addFunction("mSetEquip", &mHRPc::mSetEquip)
			.addFunction("mControlDispWestWeapons", &mHRPc::mControlDispWestWeapons)
			.addFunction("mCheckStageChangeInitEnd", &mHRPc::mCheckStageChangeInitEnd)
			.addFunction("mSetElectroShockWalk", &mHRPc::mSetElectroShockWalk)
			.addFunction("mSetHugWalk", &mHRPc::mSetHugWalk)
			.addFunction("mGetBikeSpd", &mHRPc::mGetBikeSpd)
			.addFunction("mResetFireMan", &mHRPc::mResetFireMan)
			.addFunction("mResetChargeAttack", &mHRPc::mResetChargeAttack)
			.addFunction("mResetFPCamera", &mHRPc::mResetFPCamera)
			.addFunction("mCheckDarkSideMode", &mHRPc::mCheckDarkSideMode)
			// Can't export pointer to native type 'char*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mAttachObj", &mHRPc::mAttachObj)
			.addFunction("mRestoreSubMissionWeapon", &mHRPc::mRestoreSubMissionWeapon)
			.addFunction("mGetBattery", &mHRPc::mGetBattery)
			.addFunction("mGetBatteryMax", &mHRPc::mGetBatteryMax)
			.addFunction("mSetBattery", &mHRPc::mSetBattery)
			// Function overloading not supported in LuaBridge.
			//.addFunction("StorePcPosForSM", &mHRPc::StorePcPosForSM)
			.addFunction("StoreBikePosForSM", &mHRPc::StoreBikePosForSM)
			.addFunction("mSetBikePos", &mHRPc::mSetBikePos)
			.addFunction("mSetBikeRot", &mHRPc::mSetBikeRot)
			.addFunction("mAddPcMoney", &mHRPc::mAddPcMoney)
			.addFunction("mSetBikeJumpForSubMission", &mHRPc::mSetBikeJumpForSubMission)
			.addFunction("mCallDemoBattou", &mHRPc::mCallDemoBattou)
			.addFunction("mTestPauseBattouDemo", &mHRPc::mTestPauseBattouDemo)
			.addFunction("mResumeBattouDemo", &mHRPc::mResumeBattouDemo)
			.addFunction("mCallDemoNoutou", &mHRPc::mCallDemoNoutou)
			.addFunction("mCancelBattouNoutouDemo", &mHRPc::mCancelBattouNoutouDemo)
			.addFunction("mRestorePlayMotionFromDatPtr", &mHRPc::mRestorePlayMotionFromDatPtr)
			.addFunction("mGetAtkScl", &mHRPc::mGetAtkScl)
			.addFunction("GetSwingCount", &mHRPc::GetSwingCount)
			.addFunction("ClearSwingCount", &mHRPc::ClearSwingCount)
			.addFunction("mCheckLockOnEnemy", &mHRPc::mCheckLockOnEnemy)
			.addFunction("mCheckThrowAttack", &mHRPc::mCheckThrowAttack)
			.addFunction("mCheckGetAllWeapon", &mHRPc::mCheckGetAllWeapon)
			.addFunction("mCheckGuardSlide", &mHRPc::mCheckGuardSlide)
			.addFunction("mCheckTsubaAttack", &mHRPc::mCheckTsubaAttack)
			.addFunction("mCheckSuccessInputFinish", &mHRPc::mCheckSuccessInputFinish)
			.addFunction("mSetInputMode", &mHRPc::mSetInputMode)
			.addFunction("mCheckInputMove", &mHRPc::mCheckInputMove)
			.addFunction("mSetEquipMk3", &mHRPc::mSetEquipMk3)
			.addFunction("mCheckTrvReadEnd", &mHRPc::mCheckTrvReadEnd)
			.addFunction("mSetWepBattou", &mHRPc::mSetWepBattou)
			.addFunction("mSetWepNoutou", &mHRPc::mSetWepNoutou)
			.addFunction("mGetPauseFlag", &mHRPc::mGetPauseFlag)
			.addFunction("mCheckFinishAttackAndCantLockOn", &mHRPc::mCheckFinishAttackAndCantLockOn)
			.addFunction("mTremStageChange", &mHRPc::mTremStageChange)
			.addFunction("mSetEventWalk", &mHRPc::mSetEventWalk)
			.addFunction("mInitStageChange", &mHRPc::mInitStageChange)
			.addFunction("mClearGameFlag", &mHRPc::mClearGameFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRPc::mEscapeActionInit) == 4, "expected mEscapeActionInit to be size 4");
static_assert(sizeof(mHRPc::mPcStatus) == 2308, "expected mPcStatus to be size 2308");
static_assert(sizeof(mHRPc::mMiniDemo) == 12, "expected mMiniDemo to be size 12");
static_assert(sizeof(mHRPc::mPcSaveData) == 1636, "expected mPcSaveData to be size 1636");
static_assert(sizeof(mHRPc::mDarkSideInfo) == 52, "expected mDarkSideInfo to be size 52");
static_assert(sizeof(mHRPc::mpBike) == 4, "expected mpBike to be size 4");
static_assert(sizeof(mHRPc::mSnd) == 176, "expected mSnd to be size 176");
static_assert(sizeof(mHRPc::mInputMode) == 4, "expected mInputMode to be size 4");
static_assert(sizeof(mHRPc::mInputModeOld) == 4, "expected mInputModeOld to be size 4");
static_assert(sizeof(mHRPc::mInputModeBefore) == 4, "expected mInputModeBefore to be size 4");
static_assert(sizeof(mHRPc::mPauseAll) == 1, "expected mPauseAll to be size 1");
static_assert(sizeof(mHRPc::mPauseNpc) == 1, "expected mPauseNpc to be size 1");
static_assert(sizeof(mHRPc::mOperate) == 1, "expected mOperate to be size 1");
static_assert(sizeof(mHRPc::mOnlyMove) == 1, "expected mOnlyMove to be size 1");
static_assert(sizeof(mHRPc::mMotSpdAdj) == 1, "expected mMotSpdAdj to be size 1");
static_assert(sizeof(mHRPc::mDead) == 1, "expected mDead to be size 1");
static_assert(sizeof(mHRPc::mDeadPause) == 1, "expected mDeadPause to be size 1");
static_assert(sizeof(mHRPc::mCameraOperate) == 1, "expected mCameraOperate to be size 1");
static_assert(sizeof(mHRPc::mBattouDemoRequest) == 1, "expected mBattouDemoRequest to be size 1");
static_assert(sizeof(mHRPc::mStageChangeInitEnd) == 1, "expected mStageChangeInitEnd to be size 1");
static_assert(sizeof(mHRPc::mStageChangeTermEnd) == 1, "expected mStageChangeTermEnd to be size 1");
static_assert(sizeof(mHRPc::mStageChangeMuteki) == 1, "expected mStageChangeMuteki to be size 1");
static_assert(sizeof(mHRPc::mBanStatusScreen) == 1, "expected mBanStatusScreen to be size 1");
static_assert(sizeof(mHRPc::mAtkPauseTime) == 4, "expected mAtkPauseTime to be size 4");
static_assert(sizeof(mHRPc::mStopRenderFrameNum) == 4, "expected mStopRenderFrameNum to be size 4");
static_assert(sizeof(mHRPc::mWait1Frame) == 4, "expected mWait1Frame to be size 4");
static_assert(sizeof(mHRPc::mPcEffect) == 656, "expected mPcEffect to be size 656");
static_assert(sizeof(mHRPc::mPcHug) == 32, "expected mPcHug to be size 32");
static_assert(sizeof(mHRPc::mTiger) == 80, "expected mTiger to be size 80");
static_assert(sizeof(mHRPc::mLockOnPos) == 12, "expected mLockOnPos to be size 12");
static_assert(sizeof(mHRPc::mpLockOnNpc) == 4, "expected mpLockOnNpc to be size 4");
static_assert(sizeof(mHRPc::mpTsubaNpc) == 4, "expected mpTsubaNpc to be size 4");
static_assert(sizeof(mHRPc::mpCatchNpc) == 4, "expected mpCatchNpc to be size 4");
static_assert(sizeof(mHRPc::mpCatchReserveNpc) == 4, "expected mpCatchReserveNpc to be size 4");
static_assert(sizeof(mHRPc::mpEscapeNpc) == 4, "expected mpEscapeNpc to be size 4");
static_assert(sizeof(mHRPc::mpInitFinishNpc) == 4, "expected mpInitFinishNpc to be size 4");
static_assert(sizeof(mHRPc::mpNextFinishNpc) == 4, "expected mpNextFinishNpc to be size 4");
static_assert(sizeof(mHRPc::mpFinishNpc) == 32, "expected mpFinishNpc to be size 32");
static_assert(sizeof(mHRPc::mpFinishReserveNpc) == 4, "expected mpFinishReserveNpc to be size 4");
static_assert(sizeof(mHRPc::mpDSTargetNpc) == 4, "expected mpDSTargetNpc to be size 4");
static_assert(sizeof(mHRPc::mpDwnAtkNpc) == 4, "expected mpDwnAtkNpc to be size 4");
static_assert(sizeof(mHRPc::mpLastAtkNpc) == 4, "expected mpLastAtkNpc to be size 4");
static_assert(sizeof(mHRPc::mpAttackFromBackNpc) == 4, "expected mpAttackFromBackNpc to be size 4");
static_assert(sizeof(mHRPc::mLockOnDummy) == 1408, "expected mLockOnDummy to be size 1408");
static_assert(sizeof(mHRPc::mSavehitOidashiDisEnable) == 1, "expected mSavehitOidashiDisEnable to be size 1");
static_assert(sizeof(mHRPc::mSlowMotionSytemMotNo) == 4, "expected mSlowMotionSytemMotNo to be size 4");
static_assert(sizeof(mHRPc::mSlowMotionSytemButton) == 4, "expected mSlowMotionSytemButton to be size 4");
static_assert(sizeof(mHRPc::mWepCollL) == 36, "expected mWepCollL to be size 36");
static_assert(sizeof(mHRPc::m_pAttackHitTriangle) == 4, "expected m_pAttackHitTriangle to be size 4");
static_assert(sizeof(mHRPc::mFade) == 12, "expected mFade to be size 12");
static_assert(sizeof(mHRPc::mSubMissionflag) == 2, "expected mSubMissionflag to be size 2");
static_assert(sizeof(mHRPc::mSubMissionPcPosStoreFlag) == 1, "expected mSubMissionPcPosStoreFlag to be size 1");
static_assert(sizeof(mHRPc::mSubMissionStorePos) == 12, "expected mSubMissionStorePos to be size 12");
static_assert(sizeof(mHRPc::mSubMissionStoreRot) == 12, "expected mSubMissionStoreRot to be size 12");
static_assert(sizeof(mHRPc::mSubMissionBikePosStoreFlag) == 1, "expected mSubMissionBikePosStoreFlag to be size 1");
static_assert(sizeof(mHRPc::mSubMissionStoreBikePos) == 12, "expected mSubMissionStoreBikePos to be size 12");
static_assert(sizeof(mHRPc::mSubMissionStoreBikeRot) == 12, "expected mSubMissionStoreBikeRot to be size 12");
static_assert(sizeof(mHRPc::mpSubMissionJumpCameraHandle) == 4, "expected mpSubMissionJumpCameraHandle to be size 4");
static_assert(sizeof(mHRPc::mDisEnableBtlPoseCalc) == 4, "expected mDisEnableBtlPoseCalc to be size 4");
static_assert(sizeof(mHRPc::mTamePush) == 1, "expected mTamePush to be size 1");
static_assert(sizeof(mHRPc::mTameMax) == 1, "expected mTameMax to be size 1");
static_assert(sizeof(mHRPc::mTameSe) == 1, "expected mTameSe to be size 1");
static_assert(sizeof(mHRPc::mDigAction) == 4, "expected mDigAction to be size 4");
static_assert(sizeof(mHRPc::mChangeWepProc) == 4, "expected mChangeWepProc to be size 4");
static_assert(sizeof(mHRPc::mChangeWepKind) == 4, "expected mChangeWepKind to be size 4");
static_assert(sizeof(mHRPc::mMenuDisEnableFrame) == 4, "expected mMenuDisEnableFrame to be size 4");
static_assert(sizeof(mHRPc::m_sMotName) == 4, "expected m_sMotName to be size 4");
static_assert(sizeof(mHRPc::m_sPreMotName) == 4, "expected m_sPreMotName to be size 4");
static_assert(sizeof(mHRPc::m_sOutMotName) == 16, "expected m_sOutMotName to be size 16");
static_assert(sizeof(mHRPc::m_bIsBootStageHitEffect) == 1, "expected m_bIsBootStageHitEffect to be size 1");
static_assert(sizeof(mHRPc::m_inPreWeaponTopPosi) == 12, "expected m_inPreWeaponTopPosi to be size 12");
static_assert(sizeof(mHRPc::m_bIsPreTigerVisible) == 1, "expected m_bIsPreTigerVisible to be size 1");
static_assert(sizeof(mHRPc::m_bIsPreFinishAttack) == 1, "expected m_bIsPreFinishAttack to be size 1");
static_assert(sizeof(mHRPc::m_bIsBeginFinishAttack) == 1, "expected m_bIsBeginFinishAttack to be size 1");
static_assert(sizeof(mHRPc::m_bIsPlayCamBankMotion) == 1, "expected m_bIsPlayCamBankMotion to be size 1");
static_assert(sizeof(mHRPc::m_inWeaponLengthRatio) == 12, "expected m_inWeaponLengthRatio to be size 12");
static_assert(sizeof(mHRPc) == 8112, "expected class mHRPc to be size 8112");

// [Structure] class ghmAABB
class ghmAABB
{
public:
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mExtent, offset 0xc>
	struct Vec mExtent;

	std::string ToString() const { return "class ghmAABB(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmAABB>("ghmAABB")
			.addFunction("__tostring", &ghmAABB::ToString)
			.addFunction("GetPtrAddr", &ghmAABB::GetPtrAddr)
			.addProperty("mCenter", &ghmAABB::mCenter)
			.addProperty("mExtent", &ghmAABB::mExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmAABB::mCenter) == 12, "expected mCenter to be size 12");
static_assert(sizeof(ghmAABB::mExtent) == 12, "expected mExtent to be size 12");
static_assert(sizeof(ghmAABB) == 24, "expected class ghmAABB to be size 24");

// [Structure] class ghmGcOctTreeNode
class ghmGcOctTreeNode
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class ghmGcOctTree* mpContainer, offset 0x4>
	class ghmGcOctTree* mpContainer;

	// <int32_t mDepthLevel, offset 0x8>
	int32_t mDepthLevel;

	// <int32_t mKey, offset 0xc>
	int32_t mKey;

	// <ghmGcOctTreeNode* mpParent, offset 0x10>
	ghmGcOctTreeNode* mpParent;

	// <ghmGcOctTreeNode* mpChildL[0x8], offset 0x14>
	ghmGcOctTreeNode* mpChildL[8];

	// <int32_t mNextKey[0x6], offset 0x34>
	int32_t mNextKey[6];

	// <class ghmGcOctTreeNodeObj* mpObjTop, offset 0x4c>
	class ghmGcOctTreeNodeObj* mpObjTop;

	// <class ghmAABB mShape, offset 0x50>
	class ghmAABB mShape;

	// <uint32_t mVisible, offset 0x68>
	uint32_t mVisible;

	std::string ToString() const { return "class ghmGcOctTreeNode(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTreeNode>("ghmGcOctTreeNode")
			.addFunction("__tostring", &ghmGcOctTreeNode::ToString)
			.addFunction("GetPtrAddr", &ghmGcOctTreeNode::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTreeNode::field_0)
			.addProperty("mpContainer", &ghmGcOctTreeNode::mpContainer)
			.addProperty("mDepthLevel", &ghmGcOctTreeNode::mDepthLevel)
			.addProperty("mKey", &ghmGcOctTreeNode::mKey)
			.addProperty("mpParent", &ghmGcOctTreeNode::mpParent)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpChildL", &ghmGcOctTreeNode::mpChildL)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mNextKey", &ghmGcOctTreeNode::mNextKey)
			.addProperty("mpObjTop", &ghmGcOctTreeNode::mpObjTop)
			.addProperty("mShape", &ghmGcOctTreeNode::mShape)
			.addProperty("mVisible", &ghmGcOctTreeNode::mVisible)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTreeNode::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpContainer) == 4, "expected mpContainer to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mDepthLevel) == 4, "expected mDepthLevel to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mKey) == 4, "expected mKey to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpParent) == 4, "expected mpParent to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpChildL) == 32, "expected mpChildL to be size 32");
static_assert(sizeof(ghmGcOctTreeNode::mNextKey) == 24, "expected mNextKey to be size 24");
static_assert(sizeof(ghmGcOctTreeNode::mpObjTop) == 4, "expected mpObjTop to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mShape) == 24, "expected mShape to be size 24");
static_assert(sizeof(ghmGcOctTreeNode::mVisible) == 4, "expected mVisible to be size 4");
static_assert(sizeof(ghmGcOctTreeNode) == 108, "expected class ghmGcOctTreeNode to be size 108");

// [Structure] class ghmGcOctTree
class ghmGcOctTree
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <int32_t mMaxDepthLevel, offset 0x4>
	int32_t mMaxDepthLevel;

	// <class ghmGcOctTreeNode* mpRootNode, offset 0x8>
	class ghmGcOctTreeNode* mpRootNode;

	std::string ToString() const { return "class ghmGcOctTree(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTree>("ghmGcOctTree")
			.addFunction("__tostring", &ghmGcOctTree::ToString)
			.addFunction("GetPtrAddr", &ghmGcOctTree::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTree::field_0)
			.addProperty("mMaxDepthLevel", &ghmGcOctTree::mMaxDepthLevel)
			.addProperty("mpRootNode", &ghmGcOctTree::mpRootNode)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTree::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmGcOctTree::mMaxDepthLevel) == 4, "expected mMaxDepthLevel to be size 4");
static_assert(sizeof(ghmGcOctTree::mpRootNode) == 4, "expected mpRootNode to be size 4");
static_assert(sizeof(ghmGcOctTree) == 12, "expected class ghmGcOctTree to be size 12");

// [Structure] class ghmGcCollObjHitResult
class ghmGcCollObjHitResult
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[48];
public:

	std::string ToString() const { return "class ghmGcCollObjHitResult(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcCollObjHitResult>("ghmGcCollObjHitResult")
			.addFunction("__tostring", &ghmGcCollObjHitResult::ToString)
			.addFunction("GetPtrAddr", &ghmGcCollObjHitResult::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjHitResult) == 48, "expected class ghmGcCollObjHitResult to be size 48");

// [Structure] struct WGclMaterialSpec
struct WGclMaterialSpec
{
public:
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mEnable, offset 0x8>
	uint32_t mEnable;

	// <uint32_t mPad[0x5], offset 0xc>
	uint32_t mPad[5];

	std::string ToString() const { return "struct WGclMaterialSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclMaterialSpec>("WGclMaterialSpec")
			.addFunction("__tostring", &WGclMaterialSpec::ToString)
			.addFunction("GetPtrAddr", &WGclMaterialSpec::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclMaterialSpec::mIDStr)
			.addProperty("mEnable", &WGclMaterialSpec::mEnable)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclMaterialSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclMaterialSpec::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGclMaterialSpec::mEnable) == 4, "expected mEnable to be size 4");
static_assert(sizeof(WGclMaterialSpec::mPad) == 20, "expected mPad to be size 20");
static_assert(sizeof(WGclMaterialSpec) == 32, "expected struct WGclMaterialSpec to be size 32");

// [Structure] class EE::SmartPtr<EE::IFile>
namespace EE
{
	template<typename T>
	class SmartPtr
	{
	public:
		/// Struct member variables

		// <class EE::IFile* m_pObject, offset 0x0>
		class IFile* m_pObject;

		std::string ToString() const { return "class SmartPtr(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
		// Exporting templated types to Lua currently not supported.
		// static void BindLua(luabridge::Namespace& NS)
	};
}
static_assert(sizeof(EE::SmartPtr<EE::IFile>::m_pObject) == 4, "expected m_pObject to be size 4");
static_assert(sizeof(EE::SmartPtr<EE::IFile>) == 4, "expected class EE::SmartPtr<EE::IFile> to be size 4");

// [Structure] struct DVDCommandBlock
struct DVDCommandBlock
{
public:
	/// Struct member variables

	// <DVDCommandBlock* next, offset 0x0>
	DVDCommandBlock* next;

	// <DVDCommandBlock* prev, offset 0x4>
	DVDCommandBlock* prev;

	// <uint32_t command, offset 0x8>
	uint32_t command;

	// <int32_t volatile state, offset 0xc>
	int32_t volatile state;

	// <uint32_t offset, offset 0x10>
	uint32_t offset;

	// <uint32_t length, offset 0x14>
	uint32_t length;

	// <void* addr, offset 0x18>
	void* addr;

	// <uint32_t currTransferSize, offset 0x1c>
	uint32_t currTransferSize;

	// <uint32_t transferredSize, offset 0x20>
	uint32_t transferredSize;

	// <struct DVDDiskID* id, offset 0x24>
	struct DVDDiskID* id;

	// <void (* callback)(int32_t, DVDCommandBlock*), offset 0x28>
	void (* callback)(int32_t, DVDCommandBlock*);

	// <void* userData, offset 0x2c>
	void* userData;

	std::string ToString() const { return "struct DVDCommandBlock(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDCommandBlock>("DVDCommandBlock")
			.addFunction("__tostring", &DVDCommandBlock::ToString)
			.addFunction("GetPtrAddr", &DVDCommandBlock::GetPtrAddr)
			.addProperty("next", &DVDCommandBlock::next)
			.addProperty("prev", &DVDCommandBlock::prev)
			.addProperty("command", &DVDCommandBlock::command)
			// volatile not supported in LuaBridge and needs a getter
			//.addProperty("state", &DVDCommandBlock::state)
			.addProperty("offset", &DVDCommandBlock::offset)
			.addProperty("length", &DVDCommandBlock::length)
			// void type not supported in LuaBridge
			//.addProperty("addr", &DVDCommandBlock::addr)
			.addProperty("currTransferSize", &DVDCommandBlock::currTransferSize)
			.addProperty("transferredSize", &DVDCommandBlock::transferredSize)
			.addProperty("id", &DVDCommandBlock::id)
			// delegates are not supported in LuaBridge
			//.addProperty("callback", &DVDCommandBlock::callback)
			// void type not supported in LuaBridge
			//.addProperty("userData", &DVDCommandBlock::userData)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDCommandBlock::next) == 4, "expected next to be size 4");
static_assert(sizeof(DVDCommandBlock::prev) == 4, "expected prev to be size 4");
static_assert(sizeof(DVDCommandBlock::command) == 4, "expected command to be size 4");
static_assert(sizeof(DVDCommandBlock::state) == 4, "expected state to be size 4");
static_assert(sizeof(DVDCommandBlock::offset) == 4, "expected offset to be size 4");
static_assert(sizeof(DVDCommandBlock::length) == 4, "expected length to be size 4");
static_assert(sizeof(DVDCommandBlock::addr) == 4, "expected addr to be size 4");
static_assert(sizeof(DVDCommandBlock::currTransferSize) == 4, "expected currTransferSize to be size 4");
static_assert(sizeof(DVDCommandBlock::transferredSize) == 4, "expected transferredSize to be size 4");
static_assert(sizeof(DVDCommandBlock::id) == 4, "expected id to be size 4");
static_assert(sizeof(DVDCommandBlock::callback) == 4, "expected callback to be size 4");
static_assert(sizeof(DVDCommandBlock::userData) == 4, "expected userData to be size 4");
static_assert(sizeof(DVDCommandBlock) == 48, "expected struct DVDCommandBlock to be size 48");

// [Structure] struct DVDFileInfo
struct DVDFileInfo
{
public:
	/// Struct member variables

	// <struct DVDCommandBlock cb, offset 0x0>
	struct DVDCommandBlock cb;

	// <uint32_t startAddr, offset 0x30>
	uint32_t startAddr;

	// <uint32_t length, offset 0x34>
	uint32_t length;

	// <void (* callback)(int32_t, DVDFileInfo*), offset 0x38>
	void (* callback)(int32_t, DVDFileInfo*);

	// <class EE::SmartPtr<EE::IFile> file, offset 0x3c>
	class EE::SmartPtr<EE::IFile> file;

	std::string ToString() const { return "struct DVDFileInfo(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDFileInfo>("DVDFileInfo")
			.addFunction("__tostring", &DVDFileInfo::ToString)
			.addFunction("GetPtrAddr", &DVDFileInfo::GetPtrAddr)
			.addProperty("cb", &DVDFileInfo::cb)
			.addProperty("startAddr", &DVDFileInfo::startAddr)
			.addProperty("length", &DVDFileInfo::length)
			// delegates are not supported in LuaBridge
			//.addProperty("callback", &DVDFileInfo::callback)
			.addProperty("file", &DVDFileInfo::file)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDFileInfo::cb) == 48, "expected cb to be size 48");
static_assert(sizeof(DVDFileInfo::startAddr) == 4, "expected startAddr to be size 4");
static_assert(sizeof(DVDFileInfo::length) == 4, "expected length to be size 4");
static_assert(sizeof(DVDFileInfo::callback) == 4, "expected callback to be size 4");
static_assert(sizeof(DVDFileInfo::file) == 4, "expected file to be size 4");
static_assert(sizeof(DVDFileInfo) == 64, "expected struct DVDFileInfo to be size 64");

// [Structure] class ghmGcFile
class ghmGcFile
{
public:
	// enum ghmGcFile::ghmGcFileState
	enum ghmGcFileState : uint32_t
	{
		// <READFINISH = 0x1>
		READFINISH = 1,

		// <CANCELED = 0x1>
		CANCELED = 1,

		// <CLOSED = 0x0>
		CLOSED = 0,

		// <OPENED = 0x1>
		OPENED = 1,

		// <READ = 0x2>
		READ = 2,

		// <READRETRY = 0x3>
		READRETRY = 3

	};

	// [Structure] struct ghmGcFile::ghmGcFileInfo
	struct ghmGcFileInfo
	{
	public:
		/// Struct member variables

		// <struct DVDFileInfo mFileInfo, offset 0x0>
		struct DVDFileInfo mFileInfo;

		// <int32_t mOffset, offset 0x40>
		int32_t mOffset;

		// <int32_t mLength, offset 0x44>
		int32_t mLength;

		// <int32_t mRequestNo, offset 0x48>
		int32_t mRequestNo;

		// <int32_t volatile mReadStatus, offset 0x4c>
		int32_t volatile mReadStatus;

		// <int32_t volatile mReadResult, offset 0x50>
		int32_t volatile mReadResult;

		// <enum ghmGcFile::ghmGcFileState mState, offset 0x54>
		enum ghmGcFileState mState;

		// <uint8_t mDivRead, offset 0x58>
		uint8_t mDivRead;

		// <Unidentified data segment, offset 0x59>
	private:
		char _UnidentifiedData8[3];

	public:
		// <int32_t mTotalReadLength, offset 0x5c>
		int32_t mTotalReadLength;

		// <int32_t mOneReadLength, offset 0x60>
		int32_t mOneReadLength;

		// <int32_t mReadOffset, offset 0x64>
		int32_t mReadOffset;

		// <void* mpBuffer, offset 0x68>
		void* mpBuffer;

		// <int32_t mReadCount, offset 0x6c>
		int32_t mReadCount;

		// <int32_t mDivNum, offset 0x70>
		int32_t mDivNum;

		std::string ToString() const { return "struct ghmGcFileInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<ghmGcFile::ghmGcFileInfo>("ghmGcFile_ghmGcFileInfo")
				.addFunction("__tostring", &ghmGcFile::ghmGcFileInfo::ToString)
				.addFunction("GetPtrAddr", &ghmGcFile::ghmGcFileInfo::GetPtrAddr)
				.addProperty("mFileInfo", &ghmGcFile::ghmGcFileInfo::mFileInfo)
				.addProperty("mOffset", &ghmGcFile::ghmGcFileInfo::mOffset)
				.addProperty("mLength", &ghmGcFile::ghmGcFileInfo::mLength)
				.addProperty("mRequestNo", &ghmGcFile::ghmGcFileInfo::mRequestNo)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("mReadStatus", &ghmGcFile::ghmGcFileInfo::mReadStatus)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("mReadResult", &ghmGcFile::ghmGcFileInfo::mReadResult)
				.addProperty("mState", &ghmGcFile::ghmGcFileInfo::mState)
				.addProperty("mDivRead", &ghmGcFile::ghmGcFileInfo::mDivRead)
				.addProperty("mTotalReadLength", &ghmGcFile::ghmGcFileInfo::mTotalReadLength)
				.addProperty("mOneReadLength", &ghmGcFile::ghmGcFileInfo::mOneReadLength)
				.addProperty("mReadOffset", &ghmGcFile::ghmGcFileInfo::mReadOffset)
				// void type not supported in LuaBridge
				//.addProperty("mpBuffer", &ghmGcFile::ghmGcFileInfo::mpBuffer)
				.addProperty("mReadCount", &ghmGcFile::ghmGcFileInfo::mReadCount)
				.addProperty("mDivNum", &ghmGcFile::ghmGcFileInfo::mDivNum)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mFileInfo) == 64, "expected mFileInfo to be size 64");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mOffset) == 4, "expected mOffset to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mLength) == 4, "expected mLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mRequestNo) == 4, "expected mRequestNo to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadStatus) == 4, "expected mReadStatus to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadResult) == 4, "expected mReadResult to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mState) == 4, "expected mState to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mDivRead) == 1, "expected mDivRead to be size 1");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mTotalReadLength) == 4, "expected mTotalReadLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mOneReadLength) == 4, "expected mOneReadLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadOffset) == 4, "expected mReadOffset to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mpBuffer) == 4, "expected mpBuffer to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadCount) == 4, "expected mReadCount to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mDivNum) == 4, "expected mDivNum to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo) == 116, "expected struct ghmGcFile::ghmGcFileInfo to be size 116");

	/// Struct member variables

	// <struct ghmGcFile::ghmGcFileInfo mInfo, offset 0x0>
	struct ghmGcFile::ghmGcFileInfo mInfo;

	// <ghmGcFile* mpPrev, offset 0x74>
	ghmGcFile* mpPrev;

	// <ghmGcFile* mpNext, offset 0x78>
	ghmGcFile* mpNext;

	// <char mFileName[0x40], offset 0x7c>
	char mFileName[64];

	std::string ToString() const { return "class ghmGcFile(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcFile>("ghmGcFile")
			.addFunction("__tostring", &ghmGcFile::ToString)
			.addFunction("GetPtrAddr", &ghmGcFile::GetPtrAddr)
			.addProperty("mInfo", &ghmGcFile::mInfo)
			.addProperty("mpPrev", &ghmGcFile::mpPrev)
			.addProperty("mpNext", &ghmGcFile::mpNext)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mFileName", &ghmGcFile::mFileName)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcFile::mInfo) == 116, "expected mInfo to be size 116");
static_assert(sizeof(ghmGcFile::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(ghmGcFile::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(ghmGcFile::mFileName) == 64, "expected mFileName to be size 64");
static_assert(sizeof(ghmGcFile) == 188, "expected class ghmGcFile to be size 188");

// [Structure] struct DVDDiskID
struct DVDDiskID
{
public:
	/// Struct member variables

	// <char gameName[0x4], offset 0x0>
	char gameName[4];

	// <char company[0x2], offset 0x4>
	char company[2];

	// <uint8_t diskNumber, offset 0x6>
	uint8_t diskNumber;

	// <uint8_t gameVersion, offset 0x7>
	uint8_t gameVersion;

	// <uint8_t streaming, offset 0x8>
	uint8_t streaming;

	// <uint8_t streamingBufSize, offset 0x9>
	uint8_t streamingBufSize;

	// <uint8_t padding[0xe], offset 0xa>
	uint8_t padding[14];

	// <uint32_t rvlMagic, offset 0x18>
	uint32_t rvlMagic;

	// <uint32_t gcMagic, offset 0x1c>
	uint32_t gcMagic;

	std::string ToString() const { return "struct DVDDiskID(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDDiskID>("DVDDiskID")
			.addFunction("__tostring", &DVDDiskID::ToString)
			.addFunction("GetPtrAddr", &DVDDiskID::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("gameName", &DVDDiskID::gameName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("company", &DVDDiskID::company)
			.addProperty("diskNumber", &DVDDiskID::diskNumber)
			.addProperty("gameVersion", &DVDDiskID::gameVersion)
			.addProperty("streaming", &DVDDiskID::streaming)
			.addProperty("streamingBufSize", &DVDDiskID::streamingBufSize)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("padding", &DVDDiskID::padding)
			.addProperty("rvlMagic", &DVDDiskID::rvlMagic)
			.addProperty("gcMagic", &DVDDiskID::gcMagic)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDDiskID::gameName) == 4, "expected gameName to be size 4");
static_assert(sizeof(DVDDiskID::company) == 2, "expected company to be size 2");
static_assert(sizeof(DVDDiskID::diskNumber) == 1, "expected diskNumber to be size 1");
static_assert(sizeof(DVDDiskID::gameVersion) == 1, "expected gameVersion to be size 1");
static_assert(sizeof(DVDDiskID::streaming) == 1, "expected streaming to be size 1");
static_assert(sizeof(DVDDiskID::streamingBufSize) == 1, "expected streamingBufSize to be size 1");
static_assert(sizeof(DVDDiskID::padding) == 14, "expected padding to be size 14");
static_assert(sizeof(DVDDiskID::rvlMagic) == 4, "expected rvlMagic to be size 4");
static_assert(sizeof(DVDDiskID::gcMagic) == 4, "expected gcMagic to be size 4");
static_assert(sizeof(DVDDiskID) == 32, "expected struct DVDDiskID to be size 32");

// [Structure] class EE::RefObject
namespace EE
{
	class RefObject
	{
	public:
		/// Struct member variables

		// <void* (* field_0)[0x1], offset 0x0>
		void* (* field_0)[0x1];

		// <int32_t volatile refCount, offset 0x4>
		int32_t volatile refCount;

		std::string ToString() const { return "class RefObject(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EE::RefObject>("EE_RefObject")
				.addFunction("__tostring", &EE::RefObject::ToString)
				.addFunction("GetPtrAddr", &EE::RefObject::GetPtrAddr)
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &EE::RefObject::field_0)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("refCount", &EE::RefObject::refCount)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(EE::RefObject::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(EE::RefObject::refCount) == 4, "expected refCount to be size 4");
static_assert(sizeof(EE::RefObject) == 8, "expected class EE::RefObject to be size 8");

// [Structure] class EE::IFile
namespace EE
{
	class IFile : public EE::RefObject
	{
	public:
		/// Struct member variables

		// <class EE::RefObject field_0, offset 0x0>
		// class RefObject Super;

		// <class EE::String name, offset 0x8>
		class String name;

		// <uint8_t endianSwap, offset 0x14>
		uint8_t endianSwap;

		// <Unidentified data segment, offset 0x15>
	private:
		char _UnidentifiedData[3];
	public:

		std::string ToString() const { return "class IFile(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.deriveClass<EE::IFile, EE::RefObject>("EE_IFile")
				.addFunction("__tostring", &EE::IFile::ToString)
				.addFunction("GetPtrAddr", &EE::IFile::GetPtrAddr)
				.addProperty("name", &EE::IFile::name)
				.addProperty("endianSwap", &EE::IFile::endianSwap)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(EE::IFile::name) == 12, "expected name to be size 12");
static_assert(sizeof(EE::IFile::endianSwap) == 1, "expected endianSwap to be size 1");
static_assert(sizeof(EE::IFile) == 24, "expected class EE::IFile to be size 24");

// [Structure] class ghmResGroup
class ghmResGroup
{
public:
	/// Struct member variables

	// <uint32_t mMagicNo, offset 0x0>
	uint32_t mMagicNo;

	// <uint32_t mResourceNum, offset 0x4>
	uint32_t mResourceNum;

	// <uint32_t mAttrOffset, offset 0x8>
	uint32_t mAttrOffset;

	// <uint32_t mVersion, offset 0xc>
	uint32_t mVersion;

	// <class ghmResStrTable* mpStrTablePtr, offset 0x10>
	class ghmResStrTable* mpStrTablePtr;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag;

	// <uint32_t mPad[0x3], offset 0x18>
	uint32_t mPad[3];

	std::string ToString() const { return "class ghmResGroup(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmResGroup>("ghmResGroup")
			.addFunction("__tostring", &ghmResGroup::ToString)
			.addFunction("GetPtrAddr", &ghmResGroup::GetPtrAddr)
			.addProperty("mMagicNo", &ghmResGroup::mMagicNo)
			.addProperty("mResourceNum", &ghmResGroup::mResourceNum)
			.addProperty("mAttrOffset", &ghmResGroup::mAttrOffset)
			.addProperty("mVersion", &ghmResGroup::mVersion)
			.addProperty("mpStrTablePtr", &ghmResGroup::mpStrTablePtr)
			.addProperty("mFlag", &ghmResGroup::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmResGroup::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmResGroup::mMagicNo) == 4, "expected mMagicNo to be size 4");
static_assert(sizeof(ghmResGroup::mResourceNum) == 4, "expected mResourceNum to be size 4");
static_assert(sizeof(ghmResGroup::mAttrOffset) == 4, "expected mAttrOffset to be size 4");
static_assert(sizeof(ghmResGroup::mVersion) == 4, "expected mVersion to be size 4");
static_assert(sizeof(ghmResGroup::mpStrTablePtr) == 4, "expected mpStrTablePtr to be size 4");
static_assert(sizeof(ghmResGroup::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmResGroup::mPad) == 12, "expected mPad to be size 12");
static_assert(sizeof(ghmResGroup) == 36, "expected class ghmResGroup to be size 36");

// [Structure] class ghmResStrTable
class ghmResStrTable
{
public:
	/// Struct member variables

	// <uint32_t mNum, offset 0x0>
	uint32_t mNum;

	// <char const** mppStrings, offset 0x4>
	char const** mppStrings;

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint32_t mPad[0x1], offset 0xc>
	uint32_t mPad[1];

	std::string ToString() const { return "class ghmResStrTable(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmResStrTable>("ghmResStrTable")
			.addFunction("__tostring", &ghmResStrTable::ToString)
			.addFunction("GetPtrAddr", &ghmResStrTable::GetPtrAddr)
			.addProperty("mNum", &ghmResStrTable::mNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppStrings", &ghmResStrTable::mppStrings)
			.addProperty("mFlag", &ghmResStrTable::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmResStrTable::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmResStrTable::mNum) == 4, "expected mNum to be size 4");
static_assert(sizeof(ghmResStrTable::mppStrings) == 4, "expected mppStrings to be size 4");
static_assert(sizeof(ghmResStrTable::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmResStrTable::mPad) == 4, "expected mPad to be size 4");
static_assert(sizeof(ghmResStrTable) == 16, "expected class ghmResStrTable to be size 16");

// [Structure] class TGanPlay
class TGanPlay
{
public:
	// [Structure] struct TGanPlay::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <class TGan* pGan, offset 0x0>
		class TGan* pGan;

		// <class TGanPlayNode* pTopNode, offset 0x4>
		class TGanPlayNode* pTopNode;

		// <class TFAnm* pFAnm, offset 0x8>
		class TFAnm* pFAnm;

		// <int32_t FAnmNum, offset 0xc>
		int32_t FAnmNum;

		// <class TGanPlayNode* pNode, offset 0x10>
		class TGanPlayNode* pNode;

		// <int32_t NodeNum, offset 0x14>
		int32_t NodeNum;

		// <uint8_t Loop, offset 0x18>
		uint8_t Loop;

		// <uint8_t PlayTyokugoFlag, offset 0x19>
		uint8_t PlayTyokugoFlag;

		// <uint8_t PlayFlag, offset 0x1a>
		uint8_t PlayFlag;

		// <Unidentified data segment, offset 0x1b>
	private:
		char _UnidentifiedData9[1];

	public:
		// <float PlayTick, offset 0x1c>
		float PlayTick;

		// <float Rate, offset 0x20>
		float Rate;

		std::string ToString() const { return "struct MAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGanPlay::MAIN>("TGanPlay_MAIN")
				.addFunction("__tostring", &TGanPlay::MAIN::ToString)
				.addFunction("GetPtrAddr", &TGanPlay::MAIN::GetPtrAddr)
				.addProperty("pGan", &TGanPlay::MAIN::pGan)
				.addProperty("pTopNode", &TGanPlay::MAIN::pTopNode)
				.addProperty("pFAnm", &TGanPlay::MAIN::pFAnm)
				.addProperty("FAnmNum", &TGanPlay::MAIN::FAnmNum)
				.addProperty("pNode", &TGanPlay::MAIN::pNode)
				.addProperty("NodeNum", &TGanPlay::MAIN::NodeNum)
				.addProperty("Loop", &TGanPlay::MAIN::Loop)
				.addProperty("PlayTyokugoFlag", &TGanPlay::MAIN::PlayTyokugoFlag)
				.addProperty("PlayFlag", &TGanPlay::MAIN::PlayFlag)
				.addProperty("PlayTick", &TGanPlay::MAIN::PlayTick)
				.addProperty("Rate", &TGanPlay::MAIN::Rate)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGanPlay::MAIN::pGan) == 4, "expected pGan to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pTopNode) == 4, "expected pTopNode to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pFAnm) == 4, "expected pFAnm to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::FAnmNum) == 4, "expected FAnmNum to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pNode) == 4, "expected pNode to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::NodeNum) == 4, "expected NodeNum to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::Loop) == 1, "expected Loop to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayTyokugoFlag) == 1, "expected PlayTyokugoFlag to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayFlag) == 1, "expected PlayFlag to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayTick) == 4, "expected PlayTick to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::Rate) == 4, "expected Rate to be size 4");
	static_assert(sizeof(TGanPlay::MAIN) == 36, "expected struct TGanPlay::MAIN to be size 36");

	/// Struct member variables

	// <struct TGanPlay::MAIN dat, offset 0x0>
	struct TGanPlay::MAIN dat;

	std::string ToString() const { return "class TGanPlay(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGanPlay>("TGanPlay")
			.addFunction("__tostring", &TGanPlay::ToString)
			.addFunction("GetPtrAddr", &TGanPlay::GetPtrAddr)
			.addProperty("dat", &TGanPlay::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGanPlay::dat) == 36, "expected dat to be size 36");
static_assert(sizeof(TGanPlay) == 36, "expected class TGanPlay to be size 36");

// enum TGAN_STATE
enum TGAN_STATE : uint32_t
{
	// <TGAN_STATE_INIT = 0x0>
	TGAN_STATE_INIT = 0,

	// <TGAN_STATE_STANDBY = 0x1>
	TGAN_STATE_STANDBY = 1,

	// <TGAN_STATE_ERROR = 0x2>
	TGAN_STATE_ERROR = 2

};

// [Structure] class TGan
class TGan
{
public:
	// [Structure] struct TGan::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <uint8_t ProcessBlock, offset 0x0>
		uint8_t ProcessBlock;

		// <uint8_t XYZLS16WKFlag, offset 0x1>
		uint8_t XYZLS16WKFlag;

		// <Unidentified data segment, offset 0x2>
	private:
		char _UnidentifiedData2[2];

	public:
		// <enum TGAN_STATE State, offset 0x4>
		enum TGAN_STATE State;

		// <struct WGanSpec* pSpec, offset 0x8>
		struct WGanSpec* pSpec;

		// <int32_t TimingSoundDataIndex, offset 0xc>
		int32_t TimingSoundDataIndex;

		std::string ToString() const { return "struct tagMAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGan::tagMAIN>("TGan_tagMAIN")
				.addFunction("__tostring", &TGan::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TGan::tagMAIN::GetPtrAddr)
				.addProperty("ProcessBlock", &TGan::tagMAIN::ProcessBlock)
				.addProperty("XYZLS16WKFlag", &TGan::tagMAIN::XYZLS16WKFlag)
				.addProperty("State", &TGan::tagMAIN::State)
				.addProperty("pSpec", &TGan::tagMAIN::pSpec)
				.addProperty("TimingSoundDataIndex", &TGan::tagMAIN::TimingSoundDataIndex)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGan::tagMAIN::ProcessBlock) == 1, "expected ProcessBlock to be size 1");
	static_assert(sizeof(TGan::tagMAIN::XYZLS16WKFlag) == 1, "expected XYZLS16WKFlag to be size 1");
	static_assert(sizeof(TGan::tagMAIN::State) == 4, "expected State to be size 4");
	static_assert(sizeof(TGan::tagMAIN::pSpec) == 4, "expected pSpec to be size 4");
	static_assert(sizeof(TGan::tagMAIN::TimingSoundDataIndex) == 4, "expected TimingSoundDataIndex to be size 4");
	static_assert(sizeof(TGan::tagMAIN) == 16, "expected struct TGan::tagMAIN to be size 16");

	/// Struct member variables

	// <struct TGan::tagMAIN dat, offset 0x0>
	struct TGan::tagMAIN dat;

	std::string ToString() const { return "class TGan(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGan>("TGan")
			.addFunction("__tostring", &TGan::ToString)
			.addFunction("GetPtrAddr", &TGan::GetPtrAddr)
			.addProperty("dat", &TGan::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGan::dat) == 16, "expected dat to be size 16");
static_assert(sizeof(TGan) == 16, "expected class TGan to be size 16");

// [Structure] struct WGanSpec
struct WGanSpec
{
public:
	/// Struct member variables

	// <uint32_t mID, offset 0x0>
	uint32_t mID;

	// <uint32_t mVersion, offset 0x4>
	uint32_t mVersion;

	// <uint32_t mStartTick, offset 0x8>
	uint32_t mStartTick;

	// <uint32_t mEndTick, offset 0xc>
	uint32_t mEndTick;

	// <uint32_t mFlag, offset 0x10>
	uint32_t mFlag;

	// <uint16_t mNodeCount, offset 0x14>
	uint16_t mNodeCount;

	// <uint16_t mMaterialCount, offset 0x16>
	uint16_t mMaterialCount;

	// <uint16_t mPad0[0x2], offset 0x18>
	uint16_t mPad0[2];

	// <struct WGanMaterialSpec* mpTopMaterial, offset 0x1c>
	struct WGanMaterialSpec* mpTopMaterial;

	// <struct WGanNodeSpec* mpTopNode, offset 0x20>
	struct WGanNodeSpec* mpTopNode;

	// <uint32_t mPad1[0x3], offset 0x24>
	uint32_t mPad1[3];

	std::string ToString() const { return "struct WGanSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanSpec>("WGanSpec")
			.addFunction("__tostring", &WGanSpec::ToString)
			.addFunction("GetPtrAddr", &WGanSpec::GetPtrAddr)
			.addProperty("mID", &WGanSpec::mID)
			.addProperty("mVersion", &WGanSpec::mVersion)
			.addProperty("mStartTick", &WGanSpec::mStartTick)
			.addProperty("mEndTick", &WGanSpec::mEndTick)
			.addProperty("mFlag", &WGanSpec::mFlag)
			.addProperty("mNodeCount", &WGanSpec::mNodeCount)
			.addProperty("mMaterialCount", &WGanSpec::mMaterialCount)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad0", &WGanSpec::mPad0)
			.addProperty("mpTopMaterial", &WGanSpec::mpTopMaterial)
			.addProperty("mpTopNode", &WGanSpec::mpTopNode)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanSpec::mID) == 4, "expected mID to be size 4");
static_assert(sizeof(WGanSpec::mVersion) == 4, "expected mVersion to be size 4");
static_assert(sizeof(WGanSpec::mStartTick) == 4, "expected mStartTick to be size 4");
static_assert(sizeof(WGanSpec::mEndTick) == 4, "expected mEndTick to be size 4");
static_assert(sizeof(WGanSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGanSpec::mNodeCount) == 2, "expected mNodeCount to be size 2");
static_assert(sizeof(WGanSpec::mMaterialCount) == 2, "expected mMaterialCount to be size 2");
static_assert(sizeof(WGanSpec::mPad0) == 4, "expected mPad0 to be size 4");
static_assert(sizeof(WGanSpec::mpTopMaterial) == 4, "expected mpTopMaterial to be size 4");
static_assert(sizeof(WGanSpec::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(WGanSpec::mPad1) == 12, "expected mPad1 to be size 12");
static_assert(sizeof(WGanSpec) == 48, "expected struct WGanSpec to be size 48");

// [Structure] struct WGanMaterialSpec
struct WGanMaterialSpec
{
public:
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint32_t mPad0, offset 0xc>
	uint32_t mPad0;

	// <WGanMaterialSpec* mpPrev, offset 0x10>
	WGanMaterialSpec* mpPrev;

	// <WGanMaterialSpec* mpNext, offset 0x14>
	WGanMaterialSpec* mpNext;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0x18>
	struct WGanFAnmSpec* mpFAnmSpec;

	// <struct WGanMaterialLayerSpec* mpTopLayer, offset 0x1c>
	struct WGanMaterialLayerSpec* mpTopLayer;

	// <uint32_t mPad1[0x4], offset 0x20>
	uint32_t mPad1[4];

	std::string ToString() const { return "struct WGanMaterialSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanMaterialSpec>("WGanMaterialSpec")
			.addFunction("__tostring", &WGanMaterialSpec::ToString)
			.addFunction("GetPtrAddr", &WGanMaterialSpec::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGanMaterialSpec::mIDStr)
			.addProperty("mFlag", &WGanMaterialSpec::mFlag)
			.addProperty("mPad0", &WGanMaterialSpec::mPad0)
			.addProperty("mpPrev", &WGanMaterialSpec::mpPrev)
			.addProperty("mpNext", &WGanMaterialSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanMaterialSpec::mpFAnmSpec)
			.addProperty("mpTopLayer", &WGanMaterialSpec::mpTopLayer)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanMaterialSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanMaterialSpec::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGanMaterialSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGanMaterialSpec::mPad0) == 4, "expected mPad0 to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpFAnmSpec) == 4, "expected mpFAnmSpec to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpTopLayer) == 4, "expected mpTopLayer to be size 4");
static_assert(sizeof(WGanMaterialSpec::mPad1) == 16, "expected mPad1 to be size 16");
static_assert(sizeof(WGanMaterialSpec) == 48, "expected struct WGanMaterialSpec to be size 48");

// [Structure] struct WGanFAnmSpec
struct WGanFAnmSpec
{
public:
	/// Struct member variables

	// <uint16_t mFlag, offset 0x0>
	uint16_t mFlag;

	// <uint16_t mTFlag, offset 0x2>
	uint16_t mTFlag;

	// <uint32_t mStartTick, offset 0x4>
	uint32_t mStartTick;

	// <uint32_t mEndTick, offset 0x8>
	uint32_t mEndTick;

	// <uint32_t mHeaderCount, offset 0xc>
	uint32_t mHeaderCount;

	// <uint32_t mPad[0x3], offset 0x10>
	uint32_t mPad[3];

	// <struct _WFAnmObjHeader** mppHeader, offset 0x1c>
	struct _WFAnmObjHeader** mppHeader;

	std::string ToString() const { return "struct WGanFAnmSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanFAnmSpec>("WGanFAnmSpec")
			.addFunction("__tostring", &WGanFAnmSpec::ToString)
			.addFunction("GetPtrAddr", &WGanFAnmSpec::GetPtrAddr)
			.addProperty("mFlag", &WGanFAnmSpec::mFlag)
			.addProperty("mTFlag", &WGanFAnmSpec::mTFlag)
			.addProperty("mStartTick", &WGanFAnmSpec::mStartTick)
			.addProperty("mEndTick", &WGanFAnmSpec::mEndTick)
			.addProperty("mHeaderCount", &WGanFAnmSpec::mHeaderCount)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGanFAnmSpec::mPad)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppHeader", &WGanFAnmSpec::mppHeader)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanFAnmSpec::mFlag) == 2, "expected mFlag to be size 2");
static_assert(sizeof(WGanFAnmSpec::mTFlag) == 2, "expected mTFlag to be size 2");
static_assert(sizeof(WGanFAnmSpec::mStartTick) == 4, "expected mStartTick to be size 4");
static_assert(sizeof(WGanFAnmSpec::mEndTick) == 4, "expected mEndTick to be size 4");
static_assert(sizeof(WGanFAnmSpec::mHeaderCount) == 4, "expected mHeaderCount to be size 4");
static_assert(sizeof(WGanFAnmSpec::mPad) == 12, "expected mPad to be size 12");
static_assert(sizeof(WGanFAnmSpec::mppHeader) == 4, "expected mppHeader to be size 4");
static_assert(sizeof(WGanFAnmSpec) == 32, "expected struct WGanFAnmSpec to be size 32");

// [Structure] struct _WFAnmObjHeader
struct _WFAnmObjHeader
{
public:
	/// Struct member variables

	// <uint16_t mKeyListCount, offset 0x0>
	uint16_t mKeyListCount;

	// <uint16_t mType, offset 0x2>
	uint16_t mType;

	// <uint32_t mPad, offset 0x4>
	uint32_t mPad;

	// <struct _WFAnmObjKeyListHeader* mpListHeader[0x1], offset 0x8>
	struct _WFAnmObjKeyListHeader* mpListHeader[1];

	std::string ToString() const { return "struct _WFAnmObjHeader(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmObjHeader>("_WFAnmObjHeader")
			.addFunction("__tostring", &_WFAnmObjHeader::ToString)
			.addFunction("GetPtrAddr", &_WFAnmObjHeader::GetPtrAddr)
			.addProperty("mKeyListCount", &_WFAnmObjHeader::mKeyListCount)
			.addProperty("mType", &_WFAnmObjHeader::mType)
			.addProperty("mPad", &_WFAnmObjHeader::mPad)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpListHeader", &_WFAnmObjHeader::mpListHeader)
		.endClass();
	}
#endif
};
static_assert(sizeof(_WFAnmObjHeader::mKeyListCount) == 2, "expected mKeyListCount to be size 2");
static_assert(sizeof(_WFAnmObjHeader::mType) == 2, "expected mType to be size 2");
static_assert(sizeof(_WFAnmObjHeader::mPad) == 4, "expected mPad to be size 4");
static_assert(sizeof(_WFAnmObjHeader::mpListHeader) == 4, "expected mpListHeader to be size 4");
static_assert(sizeof(_WFAnmObjHeader) == 12, "expected struct _WFAnmObjHeader to be size 12");

// [Structure] struct _WFAnmObjKeyListHeader
struct _WFAnmObjKeyListHeader
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[20];
public:

	std::string ToString() const { return "struct _WFAnmObjKeyListHeader(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmObjKeyListHeader>("_WFAnmObjKeyListHeader")
			.addFunction("__tostring", &_WFAnmObjKeyListHeader::ToString)
			.addFunction("GetPtrAddr", &_WFAnmObjKeyListHeader::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(_WFAnmObjKeyListHeader) == 20, "expected struct _WFAnmObjKeyListHeader to be size 20");

// [Structure] struct WGanMaterialLayerSpec
struct WGanMaterialLayerSpec
{
public:
	/// Struct member variables

	// <uint32_t mFlag, offset 0x0>
	uint32_t mFlag;

	// <WGanMaterialLayerSpec* mpPrev, offset 0x4>
	WGanMaterialLayerSpec* mpPrev;

	// <WGanMaterialLayerSpec* mpNext, offset 0x8>
	WGanMaterialLayerSpec* mpNext;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0xc>
	struct WGanFAnmSpec* mpFAnmSpec;

	// <uint32_t mPad[0x4], offset 0x10>
	uint32_t mPad[4];

	std::string ToString() const { return "struct WGanMaterialLayerSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanMaterialLayerSpec>("WGanMaterialLayerSpec")
			.addFunction("__tostring", &WGanMaterialLayerSpec::ToString)
			.addFunction("GetPtrAddr", &WGanMaterialLayerSpec::GetPtrAddr)
			.addProperty("mFlag", &WGanMaterialLayerSpec::mFlag)
			.addProperty("mpPrev", &WGanMaterialLayerSpec::mpPrev)
			.addProperty("mpNext", &WGanMaterialLayerSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanMaterialLayerSpec::mpFAnmSpec)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGanMaterialLayerSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanMaterialLayerSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpFAnmSpec) == 4, "expected mpFAnmSpec to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mPad) == 16, "expected mPad to be size 16");
static_assert(sizeof(WGanMaterialLayerSpec) == 32, "expected struct WGanMaterialLayerSpec to be size 32");

// [Structure] struct WGanNodeSpec
struct WGanNodeSpec
{
public:
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint32_t mPad0, offset 0xc>
	uint32_t mPad0;

	// <WGanNodeSpec* mpParent, offset 0x10>
	WGanNodeSpec* mpParent;

	// <WGanNodeSpec* mpChild, offset 0x14>
	WGanNodeSpec* mpChild;

	// <WGanNodeSpec* mpPrev, offset 0x18>
	WGanNodeSpec* mpPrev;

	// <WGanNodeSpec* mpNext, offset 0x1c>
	WGanNodeSpec* mpNext;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0x20>
	struct WGanFAnmSpec* mpFAnmSpec;

	// <uint32_t mPad1[0x3], offset 0x24>
	uint32_t mPad1[3];

	std::string ToString() const { return "struct WGanNodeSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanNodeSpec>("WGanNodeSpec")
			.addFunction("__tostring", &WGanNodeSpec::ToString)
			.addFunction("GetPtrAddr", &WGanNodeSpec::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGanNodeSpec::mIDStr)
			.addProperty("mFlag", &WGanNodeSpec::mFlag)
			.addProperty("mPad0", &WGanNodeSpec::mPad0)
			.addProperty("mpParent", &WGanNodeSpec::mpParent)
			.addProperty("mpChild", &WGanNodeSpec::mpChild)
			.addProperty("mpPrev", &WGanNodeSpec::mpPrev)
			.addProperty("mpNext", &WGanNodeSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanNodeSpec::mpFAnmSpec)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanNodeSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanNodeSpec::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGanNodeSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGanNodeSpec::mPad0) == 4, "expected mPad0 to be size 4");
static_assert(sizeof(WGanNodeSpec::mpParent) == 4, "expected mpParent to be size 4");
static_assert(sizeof(WGanNodeSpec::mpChild) == 4, "expected mpChild to be size 4");
static_assert(sizeof(WGanNodeSpec::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGanNodeSpec::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGanNodeSpec::mpFAnmSpec) == 4, "expected mpFAnmSpec to be size 4");
static_assert(sizeof(WGanNodeSpec::mPad1) == 12, "expected mPad1 to be size 12");
static_assert(sizeof(WGanNodeSpec) == 48, "expected struct WGanNodeSpec to be size 48");

// [Structure] class TGanPlayNode
class TGanPlayNode
{
public:
	// [Structure] struct TGanPlayNode::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <uint8_t ValidAnm, offset 0x0>
		uint8_t ValidAnm;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData1[3];

	public:
		// <class TFAnm* pAnm, offset 0x4>
		class TFAnm* pAnm;

		// <struct WGanNodeSpec* pSpec, offset 0x8>
		struct WGanNodeSpec* pSpec;

		// <class TGanPlay* pGanPlay, offset 0xc>
		class TGanPlay* pGanPlay;

		// <class TGanPlayNode* pNext, offset 0x10>
		class TGanPlayNode* pNext;

		// <class TGanPlayNode* pPrev, offset 0x14>
		class TGanPlayNode* pPrev;

		// <class TGanPlayNode* pChild, offset 0x18>
		class TGanPlayNode* pChild;

		// <class TGanPlayNode* pParent, offset 0x1c>
		class TGanPlayNode* pParent;

		std::string ToString() const { return "struct MAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGanPlayNode::MAIN>("TGanPlayNode_MAIN")
				.addFunction("__tostring", &TGanPlayNode::MAIN::ToString)
				.addFunction("GetPtrAddr", &TGanPlayNode::MAIN::GetPtrAddr)
				.addProperty("ValidAnm", &TGanPlayNode::MAIN::ValidAnm)
				.addProperty("pAnm", &TGanPlayNode::MAIN::pAnm)
				.addProperty("pSpec", &TGanPlayNode::MAIN::pSpec)
				.addProperty("pGanPlay", &TGanPlayNode::MAIN::pGanPlay)
				.addProperty("pNext", &TGanPlayNode::MAIN::pNext)
				.addProperty("pPrev", &TGanPlayNode::MAIN::pPrev)
				.addProperty("pChild", &TGanPlayNode::MAIN::pChild)
				.addProperty("pParent", &TGanPlayNode::MAIN::pParent)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGanPlayNode::MAIN::ValidAnm) == 1, "expected ValidAnm to be size 1");
	static_assert(sizeof(TGanPlayNode::MAIN::pAnm) == 4, "expected pAnm to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pSpec) == 4, "expected pSpec to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pGanPlay) == 4, "expected pGanPlay to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pNext) == 4, "expected pNext to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pPrev) == 4, "expected pPrev to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pChild) == 4, "expected pChild to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pParent) == 4, "expected pParent to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN) == 32, "expected struct TGanPlayNode::MAIN to be size 32");

	/// Struct member variables

	// <struct TGanPlayNode::MAIN dat, offset 0x0>
	struct TGanPlayNode::MAIN dat;

	std::string ToString() const { return "class TGanPlayNode(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGanPlayNode>("TGanPlayNode")
			.addFunction("__tostring", &TGanPlayNode::ToString)
			.addFunction("GetPtrAddr", &TGanPlayNode::GetPtrAddr)
			.addProperty("dat", &TGanPlayNode::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGanPlayNode::dat) == 32, "expected dat to be size 32");
static_assert(sizeof(TGanPlayNode) == 32, "expected class TGanPlayNode to be size 32");

// [Structure] class TFAnm
class TFAnm
{
public:
	// [Structure] struct TFAnm::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <class TGmfNode* pGmfNode, offset 0x0>
		class TGmfNode* pGmfNode;

		// <class TFAnmObjF32_3* pAnmObj3, offset 0x4>
		class TFAnmObjF32_3* pAnmObj3;

		// <int32_t AnmObj3Num, offset 0x8>
		int32_t AnmObj3Num;

		// <class TFAnmObj* pAnmObj, offset 0xc>
		class TFAnmObj* pAnmObj;

		// <int32_t AnmObjNum, offset 0x10>
		int32_t AnmObjNum;

		// <float Rate, offset 0x14>
		float Rate;

		// <uint32_t Flag, offset 0x18>
		uint32_t Flag;

		// <float PlayTick, offset 0x1c>
		float PlayTick;

		// <float StartTick, offset 0x20>
		float StartTick;

		// <float EndTick, offset 0x24>
		float EndTick;

		std::string ToString() const { return "struct tagMAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TFAnm::tagMAIN>("TFAnm_tagMAIN")
				.addFunction("__tostring", &TFAnm::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TFAnm::tagMAIN::GetPtrAddr)
				.addProperty("pGmfNode", &TFAnm::tagMAIN::pGmfNode)
				.addProperty("pAnmObj3", &TFAnm::tagMAIN::pAnmObj3)
				.addProperty("AnmObj3Num", &TFAnm::tagMAIN::AnmObj3Num)
				.addProperty("pAnmObj", &TFAnm::tagMAIN::pAnmObj)
				.addProperty("AnmObjNum", &TFAnm::tagMAIN::AnmObjNum)
				.addProperty("Rate", &TFAnm::tagMAIN::Rate)
				.addProperty("Flag", &TFAnm::tagMAIN::Flag)
				.addProperty("PlayTick", &TFAnm::tagMAIN::PlayTick)
				.addProperty("StartTick", &TFAnm::tagMAIN::StartTick)
				.addProperty("EndTick", &TFAnm::tagMAIN::EndTick)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnm::tagMAIN::pGmfNode) == 4, "expected pGmfNode to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::pAnmObj3) == 4, "expected pAnmObj3 to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::AnmObj3Num) == 4, "expected AnmObj3Num to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::pAnmObj) == 4, "expected pAnmObj to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::AnmObjNum) == 4, "expected AnmObjNum to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::Rate) == 4, "expected Rate to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::Flag) == 4, "expected Flag to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::PlayTick) == 4, "expected PlayTick to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::StartTick) == 4, "expected StartTick to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::EndTick) == 4, "expected EndTick to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN) == 40, "expected struct TFAnm::tagMAIN to be size 40");

	/// Struct member variables

	// <struct TFAnm::tagMAIN dat, offset 0x0>
	struct TFAnm::tagMAIN dat;

	std::string ToString() const { return "class TFAnm(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnm>("TFAnm")
			.addFunction("__tostring", &TFAnm::ToString)
			.addFunction("GetPtrAddr", &TFAnm::GetPtrAddr)
			.addProperty("dat", &TFAnm::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnm::dat) == 40, "expected dat to be size 40");
static_assert(sizeof(TFAnm) == 40, "expected class TFAnm to be size 40");

// [Structure] class TGmfNode
class TGmfNode
{
public:
	// [Structure] struct TGmfNode::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData[244];
	public:

		std::string ToString() const { return "struct tagMAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGmfNode::tagMAIN>("TGmfNode_tagMAIN")
				.addFunction("__tostring", &TGmfNode::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TGmfNode::tagMAIN::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGmfNode::tagMAIN) == 244, "expected struct TGmfNode::tagMAIN to be size 244");

	/// Struct member variables

	// <struct TGmfNode::tagMAIN dat, offset 0x0>
	struct TGmfNode::tagMAIN dat;

	// <uint8_t m_bIsAlwaysSetupMatrix, offset 0xf4>
	uint8_t m_bIsAlwaysSetupMatrix;

	// <Unidentified data segment, offset 0xf5>
private:
	char _UnidentifiedData2[3];

public:
	// <int32_t m_nPolyNum, offset 0xf8>
	int32_t m_nPolyNum;

	// <float m_inLocalMat[0x3][0x4], offset 0xfc>
	float m_inLocalMat[3][4];

	// <class CViewClipObjSphere* m_pViewClipObjSphere, offset 0x12c>
	class CViewClipObjSphere* m_pViewClipObjSphere;

	// <class CViewClipObjBox* m_pViewClipObjBox, offset 0x130>
	class CViewClipObjBox* m_pViewClipObjBox;

	// <float m_fClipDistSqu, offset 0x134>
	float m_fClipDistSqu;

	// <float m_inPreWorldMatMtx[0x3][0x4], offset 0x138>
	float m_inPreWorldMatMtx[3][4];

	// <class EfDestortion* mpDestortion, offset 0x168>
	class EfDestortion* mpDestortion;

	// <class CVertexAnimation* m_pVertexAnime, offset 0x16c>
	class CVertexAnimation* m_pVertexAnime;

	std::string ToString() const { return "class TGmfNode(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGmfNode>("TGmfNode")
			.addFunction("__tostring", &TGmfNode::ToString)
			.addFunction("GetPtrAddr", &TGmfNode::GetPtrAddr)
			.addProperty("dat", &TGmfNode::dat)
			.addProperty("m_bIsAlwaysSetupMatrix", &TGmfNode::m_bIsAlwaysSetupMatrix)
			.addProperty("m_nPolyNum", &TGmfNode::m_nPolyNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_inLocalMat", &TGmfNode::m_inLocalMat)
			.addProperty("m_pViewClipObjSphere", &TGmfNode::m_pViewClipObjSphere)
			.addProperty("m_pViewClipObjBox", &TGmfNode::m_pViewClipObjBox)
			.addProperty("m_fClipDistSqu", &TGmfNode::m_fClipDistSqu)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_inPreWorldMatMtx", &TGmfNode::m_inPreWorldMatMtx)
			.addProperty("mpDestortion", &TGmfNode::mpDestortion)
			.addProperty("m_pVertexAnime", &TGmfNode::m_pVertexAnime)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGmfNode::dat) == 244, "expected dat to be size 244");
static_assert(sizeof(TGmfNode::m_bIsAlwaysSetupMatrix) == 1, "expected m_bIsAlwaysSetupMatrix to be size 1");
static_assert(sizeof(TGmfNode::m_nPolyNum) == 4, "expected m_nPolyNum to be size 4");
static_assert(sizeof(TGmfNode::m_inLocalMat) == 48, "expected m_inLocalMat to be size 48");
static_assert(sizeof(TGmfNode::m_pViewClipObjSphere) == 4, "expected m_pViewClipObjSphere to be size 4");
static_assert(sizeof(TGmfNode::m_pViewClipObjBox) == 4, "expected m_pViewClipObjBox to be size 4");
static_assert(sizeof(TGmfNode::m_fClipDistSqu) == 4, "expected m_fClipDistSqu to be size 4");
static_assert(sizeof(TGmfNode::m_inPreWorldMatMtx) == 48, "expected m_inPreWorldMatMtx to be size 48");
static_assert(sizeof(TGmfNode::mpDestortion) == 4, "expected mpDestortion to be size 4");
static_assert(sizeof(TGmfNode::m_pVertexAnime) == 4, "expected m_pVertexAnime to be size 4");
static_assert(sizeof(TGmfNode) == 368, "expected class TGmfNode to be size 368");

// [Structure] class CViewClipObjSphere
class CViewClipObjSphere
{
public:
	/// Struct member variables

	// <class tiVector m_inPosi, offset 0x0>
	class tiVector m_inPosi;

	// <float m_fRadius, offset 0x10>
	float m_fRadius;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData[12];
public:

	std::string ToString() const { return "class CViewClipObjSphere(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CViewClipObjSphere>("CViewClipObjSphere")
			.addFunction("__tostring", &CViewClipObjSphere::ToString)
			.addFunction("GetPtrAddr", &CViewClipObjSphere::GetPtrAddr)
			.addProperty("m_inPosi", &CViewClipObjSphere::m_inPosi)
			.addProperty("m_fRadius", &CViewClipObjSphere::m_fRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(CViewClipObjSphere::m_inPosi) == 16, "expected m_inPosi to be size 16");
static_assert(sizeof(CViewClipObjSphere::m_fRadius) == 4, "expected m_fRadius to be size 4");
static_assert(sizeof(CViewClipObjSphere) == 32, "expected class CViewClipObjSphere to be size 32");

// [Structure] class CViewClipObjBox
class CViewClipObjBox
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[64];
public:

	std::string ToString() const { return "class CViewClipObjBox(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CViewClipObjBox>("CViewClipObjBox")
			.addFunction("__tostring", &CViewClipObjBox::ToString)
			.addFunction("GetPtrAddr", &CViewClipObjBox::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CViewClipObjBox) == 64, "expected class CViewClipObjBox to be size 64");

// enum GHMR_PRIMTYPE
enum GHMR_PRIMTYPE : uint32_t
{
	// <GHMR_PRIMTYPE_POINTLIST = 0x0>
	GHMR_PRIMTYPE_POINTLIST = 0,

	// <GHMR_PRIMTYPE_LINELIST = 0x1>
	GHMR_PRIMTYPE_LINELIST = 1,

	// <GHMR_PRIMTYPE_LINESTRIP = 0x2>
	GHMR_PRIMTYPE_LINESTRIP = 2,

	// <GHMR_PRIMTYPE_TRIANGLELIST = 0x3>
	GHMR_PRIMTYPE_TRIANGLELIST = 3,

	// <GHMR_PRIMTYPE_TRIANGLESTRIP = 0x4>
	GHMR_PRIMTYPE_TRIANGLESTRIP = 4,

	// <GHMR_PRIMTYPE_TRIANGLEFAN = 0x5>
	GHMR_PRIMTYPE_TRIANGLEFAN = 5,

	// <GHMR_PRIMTYPE_QUADLIST = 0x6>
	GHMR_PRIMTYPE_QUADLIST = 6

};

// enum GHMR_PROJECT
enum GHMR_PROJECT : uint32_t
{
	// <GHMR_PROJECT_PERS = 0x0>
	GHMR_PROJECT_PERS = 0,

	// <GHMR_PROJECT_ORTHO = 0x1>
	GHMR_PROJECT_ORTHO = 1,

	// <GHMR_PROJECT_NUM = 0x2>
	GHMR_PROJECT_NUM = 2

};

// [Structure] class rPrimUnific
class rPrimUnific
{
public:
	/// Struct member variables

	// <class rPrimBase* m_pListTop, offset 0x0>
	class rPrimBase* m_pListTop;

	// <class rPrimBase* m_pListEnd, offset 0x4>
	class rPrimBase* m_pListEnd;

	// <enum GHMR_PROJECT m_ProjectMode, offset 0x8>
	enum GHMR_PROJECT m_ProjectMode;

	// <enum GHMR_PRIMTYPE m_PrimType, offset 0xc>
	enum GHMR_PRIMTYPE m_PrimType;

	// <uint32_t m_PrimNum, offset 0x10>
	uint32_t m_PrimNum;

	// <struct tagGHMR_TEX* m_pTex, offset 0x14>
	struct tagGHMR_TEX* m_pTex;

	// <struct tagGHMR_TEX* m_pMultiTex, offset 0x18>
	struct tagGHMR_TEX* m_pMultiTex;

	// <uint32_t m_BitFlag, offset 0x1c>
	uint32_t m_BitFlag;

	std::string ToString() const { return "class rPrimUnific(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rPrimUnific>("rPrimUnific")
			.addFunction("__tostring", &rPrimUnific::ToString)
			.addFunction("GetPtrAddr", &rPrimUnific::GetPtrAddr)
			.addProperty("m_pListTop", &rPrimUnific::m_pListTop)
			.addProperty("m_pListEnd", &rPrimUnific::m_pListEnd)
			.addProperty("m_ProjectMode", &rPrimUnific::m_ProjectMode)
			.addProperty("m_PrimType", &rPrimUnific::m_PrimType)
			.addProperty("m_PrimNum", &rPrimUnific::m_PrimNum)
			.addProperty("m_pTex", &rPrimUnific::m_pTex)
			.addProperty("m_pMultiTex", &rPrimUnific::m_pMultiTex)
			.addProperty("m_BitFlag", &rPrimUnific::m_BitFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(rPrimUnific::m_pListTop) == 4, "expected m_pListTop to be size 4");
static_assert(sizeof(rPrimUnific::m_pListEnd) == 4, "expected m_pListEnd to be size 4");
static_assert(sizeof(rPrimUnific::m_ProjectMode) == 4, "expected m_ProjectMode to be size 4");
static_assert(sizeof(rPrimUnific::m_PrimType) == 4, "expected m_PrimType to be size 4");
static_assert(sizeof(rPrimUnific::m_PrimNum) == 4, "expected m_PrimNum to be size 4");
static_assert(sizeof(rPrimUnific::m_pTex) == 4, "expected m_pTex to be size 4");
static_assert(sizeof(rPrimUnific::m_pMultiTex) == 4, "expected m_pMultiTex to be size 4");
static_assert(sizeof(rPrimUnific::m_BitFlag) == 4, "expected m_BitFlag to be size 4");
static_assert(sizeof(rPrimUnific) == 32, "expected class rPrimUnific to be size 32");

// [Structure] class EfBase
class EfBase
{
public:
	/// Struct member variables

	// <uint8_t mBitFlag, offset 0x0>
	uint8_t mBitFlag;

	// <Unidentified data segment, offset 0x1>
private:
	char _UnidentifiedData1[3];

public:
	// <uint32_t mTick, offset 0x4>
	uint32_t mTick;

	// <uint32_t mBefFrameTick, offset 0x8>
	uint32_t mBefFrameTick;

	// <float mRate, offset 0xc>
	float mRate;

	// <uint32_t mSelectParam, offset 0x10>
	uint32_t mSelectParam;

	// <uint32_t mKeyWait, offset 0x14>
	uint32_t mKeyWait;

	std::string ToString() const { return "class EfBase(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfBase>("EfBase")
			.addFunction("__tostring", &EfBase::ToString)
			.addFunction("GetPtrAddr", &EfBase::GetPtrAddr)
			.addProperty("mBitFlag", &EfBase::mBitFlag)
			.addProperty("mTick", &EfBase::mTick)
			.addProperty("mBefFrameTick", &EfBase::mBefFrameTick)
			.addProperty("mRate", &EfBase::mRate)
			.addProperty("mSelectParam", &EfBase::mSelectParam)
			.addProperty("mKeyWait", &EfBase::mKeyWait)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfBase::mBitFlag) == 1, "expected mBitFlag to be size 1");
static_assert(sizeof(EfBase::mTick) == 4, "expected mTick to be size 4");
static_assert(sizeof(EfBase::mBefFrameTick) == 4, "expected mBefFrameTick to be size 4");
static_assert(sizeof(EfBase::mRate) == 4, "expected mRate to be size 4");
static_assert(sizeof(EfBase::mSelectParam) == 4, "expected mSelectParam to be size 4");
static_assert(sizeof(EfBase::mKeyWait) == 4, "expected mKeyWait to be size 4");
static_assert(sizeof(EfBase) == 24, "expected class EfBase to be size 24");

// [Structure] class EfDestortion
class EfDestortion : public HrTask
{
public:
	// enum EfDestortion::UV_Type
	enum UV_Type : uint32_t
	{
		// <UV_Sin = 0x1>
		UV_Sin = 1,

		// <UV_Rand = 0x2>
		UV_Rand = 2

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <class TGmfNode* mpNode, offset 0x68>
	class TGmfNode* mpNode;

	// <struct TGMFMESH** mppMeshList, offset 0x6c>
	struct TGMFMESH** mppMeshList;

	// <uint32_t mTriangleNum, offset 0x70>
	uint32_t mTriangleNum;

	// <float mScreenWidthInv, offset 0x74>
	float mScreenWidthInv;

	// <float mAmplitude, offset 0x78>
	float mAmplitude;

	// <enum EfDestortion::UV_Type mType, offset 0x7c>
	enum EfDestortion::UV_Type mType;

	// <uint8_t* mpRandIdxAry, offset 0x80>
	uint8_t* mpRandIdxAry;

	// <class rTriangleList* mpTriangleAry, offset 0x84>
	class rTriangleList* mpTriangleAry;

	// <class rPrimUnific mTriangleUni, offset 0x88>
	class rPrimUnific mTriangleUni;

	// <uint8_t mbRenderWait, offset 0xa8>
	uint8_t mbRenderWait;

	// <Unidentified data segment, offset 0xa9>
private:
	char _UnidentifiedData12[3];

public:
	// <float mSinCnt[0x64], offset 0xac>
	float mSinCnt[100];

	std::string ToString() const { return "class EfDestortion(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfDestortion, HrTask>("EfDestortion")
			.addFunction("__tostring", &EfDestortion::ToString)
			.addFunction("GetPtrAddr", &EfDestortion::GetPtrAddr)
			.addProperty("field_50", &EfDestortion::field_50)
			.addProperty("mpNode", &EfDestortion::mpNode)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppMeshList", &EfDestortion::mppMeshList)
			.addProperty("mTriangleNum", &EfDestortion::mTriangleNum)
			.addProperty("mScreenWidthInv", &EfDestortion::mScreenWidthInv)
			.addProperty("mAmplitude", &EfDestortion::mAmplitude)
			.addProperty("mType", &EfDestortion::mType)
			// native pointer type (uint8_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpRandIdxAry", &EfDestortion::mpRandIdxAry)
			.addProperty("mpTriangleAry", &EfDestortion::mpTriangleAry)
			.addProperty("mTriangleUni", &EfDestortion::mTriangleUni)
			.addProperty("mbRenderWait", &EfDestortion::mbRenderWait)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mSinCnt", &EfDestortion::mSinCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfDestortion::field_50) == 24, "expected field_50 to be size 24");
static_assert(sizeof(EfDestortion::mpNode) == 4, "expected mpNode to be size 4");
static_assert(sizeof(EfDestortion::mppMeshList) == 4, "expected mppMeshList to be size 4");
static_assert(sizeof(EfDestortion::mTriangleNum) == 4, "expected mTriangleNum to be size 4");
static_assert(sizeof(EfDestortion::mScreenWidthInv) == 4, "expected mScreenWidthInv to be size 4");
static_assert(sizeof(EfDestortion::mAmplitude) == 4, "expected mAmplitude to be size 4");
static_assert(sizeof(EfDestortion::mType) == 4, "expected mType to be size 4");
static_assert(sizeof(EfDestortion::mpRandIdxAry) == 4, "expected mpRandIdxAry to be size 4");
static_assert(sizeof(EfDestortion::mpTriangleAry) == 4, "expected mpTriangleAry to be size 4");
static_assert(sizeof(EfDestortion::mTriangleUni) == 32, "expected mTriangleUni to be size 32");
static_assert(sizeof(EfDestortion::mbRenderWait) == 1, "expected mbRenderWait to be size 1");
static_assert(sizeof(EfDestortion::mSinCnt) == 400, "expected mSinCnt to be size 400");
static_assert(sizeof(EfDestortion) == 572, "expected class EfDestortion to be size 572");

// [Structure] struct TGMFMESH
struct TGMFMESH
{
public:
	/// Struct member variables

	// <class TGmfNode* pNode, offset 0x0>
	class TGmfNode* pNode;

	// <struct tagGHMR_TEX* pTex, offset 0x4>
	struct tagGHMR_TEX* pTex;

	// <int32_t VertexNum, offset 0x8>
	int32_t VertexNum;

	// <int32_t PolyNum, offset 0xc>
	int32_t PolyNum;

	// <uint32_t VertexSize, offset 0x10>
	uint32_t VertexSize;

	// <uint32_t TransVertexSize, offset 0x14>
	uint32_t TransVertexSize;

	// <uint8_t HaveNormal, offset 0x18>
	uint8_t HaveNormal;

	// <uint8_t HaveColor, offset 0x19>
	uint8_t HaveColor;

	// <uint8_t HaveUV, offset 0x1a>
	uint8_t HaveUV;

	// <uint8_t Transform, offset 0x1b>
	uint8_t Transform;

	// <float TransMat[0x8][0x3][0x4], offset 0x1c>
	float TransMat[8][3][4];

	// <void* Vertex, offset 0x19c>
	void* Vertex;

	// <void* TransVertex, offset 0x1a0>
	void* TransVertex;

	// <uint32_t* PolyList, offset 0x1a4>
	uint32_t* PolyList;

	std::string ToString() const { return "struct TGMFMESH(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGMFMESH>("TGMFMESH")
			.addFunction("__tostring", &TGMFMESH::ToString)
			.addFunction("GetPtrAddr", &TGMFMESH::GetPtrAddr)
			.addProperty("pNode", &TGMFMESH::pNode)
			.addProperty("pTex", &TGMFMESH::pTex)
			.addProperty("VertexNum", &TGMFMESH::VertexNum)
			.addProperty("PolyNum", &TGMFMESH::PolyNum)
			.addProperty("VertexSize", &TGMFMESH::VertexSize)
			.addProperty("TransVertexSize", &TGMFMESH::TransVertexSize)
			.addProperty("HaveNormal", &TGMFMESH::HaveNormal)
			.addProperty("HaveColor", &TGMFMESH::HaveColor)
			.addProperty("HaveUV", &TGMFMESH::HaveUV)
			.addProperty("Transform", &TGMFMESH::Transform)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("TransMat", &TGMFMESH::TransMat)
			// void type not supported in LuaBridge
			//.addProperty("Vertex", &TGMFMESH::Vertex)
			// void type not supported in LuaBridge
			//.addProperty("TransVertex", &TGMFMESH::TransVertex)
			// native pointer type (uint32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("PolyList", &TGMFMESH::PolyList)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGMFMESH::pNode) == 4, "expected pNode to be size 4");
static_assert(sizeof(TGMFMESH::pTex) == 4, "expected pTex to be size 4");
static_assert(sizeof(TGMFMESH::VertexNum) == 4, "expected VertexNum to be size 4");
static_assert(sizeof(TGMFMESH::PolyNum) == 4, "expected PolyNum to be size 4");
static_assert(sizeof(TGMFMESH::VertexSize) == 4, "expected VertexSize to be size 4");
static_assert(sizeof(TGMFMESH::TransVertexSize) == 4, "expected TransVertexSize to be size 4");
static_assert(sizeof(TGMFMESH::HaveNormal) == 1, "expected HaveNormal to be size 1");
static_assert(sizeof(TGMFMESH::HaveColor) == 1, "expected HaveColor to be size 1");
static_assert(sizeof(TGMFMESH::HaveUV) == 1, "expected HaveUV to be size 1");
static_assert(sizeof(TGMFMESH::Transform) == 1, "expected Transform to be size 1");
static_assert(sizeof(TGMFMESH::TransMat) == 384, "expected TransMat to be size 384");
static_assert(sizeof(TGMFMESH::Vertex) == 4, "expected Vertex to be size 4");
static_assert(sizeof(TGMFMESH::TransVertex) == 4, "expected TransVertex to be size 4");
static_assert(sizeof(TGMFMESH::PolyList) == 4, "expected PolyList to be size 4");
static_assert(sizeof(TGMFMESH) == 424, "expected struct TGMFMESH to be size 424");

// enum GHMR_TEXDOT_ASPECT
enum GHMR_TEXDOT_ASPECT : uint32_t
{
	// <GHMR_TEXDOT_ASPECT_1x1 = 0x0>
	GHMR_TEXDOT_ASPECT_1x1 = 0,

	// <GHMR_TEXDOT_ASPECT_CANCEL = 0x1>
	GHMR_TEXDOT_ASPECT_CANCEL = 1

};

// enum _GXTexFmt
enum _GXTexFmt : uint32_t
{
	// <GX_TF_I4 = 0x0>
	GX_TF_I4 = 0,

	// <GX_TF_I8 = 0x1>
	GX_TF_I8 = 1,

	// <GX_TF_IA4 = 0x2>
	GX_TF_IA4 = 2,

	// <GX_TF_IA8 = 0x3>
	GX_TF_IA8 = 3,

	// <GX_TF_RGB565 = 0x4>
	GX_TF_RGB565 = 4,

	// <GX_TF_RGB5A3 = 0x5>
	GX_TF_RGB5A3 = 5,

	// <GX_TF_RGBA8 = 0x6>
	GX_TF_RGBA8 = 6,

	// <GX_TF_CMPR = 0xe>
	GX_TF_CMPR = 14,

	// <GX_CTF_R4 = 0x20>
	GX_CTF_R4 = 32,

	// <GX_CTF_RA4 = 0x22>
	GX_CTF_RA4 = 34,

	// <GX_CTF_RA8 = 0x23>
	GX_CTF_RA8 = 35,

	// <GX_CTF_YUVA8 = 0x26>
	GX_CTF_YUVA8 = 38,

	// <GX_CTF_A8 = 0x27>
	GX_CTF_A8 = 39,

	// <GX_CTF_R8 = 0x28>
	GX_CTF_R8 = 40,

	// <GX_CTF_G8 = 0x29>
	GX_CTF_G8 = 41,

	// <GX_CTF_B8 = 0x2a>
	GX_CTF_B8 = 42,

	// <GX_CTF_RG8 = 0x2b>
	GX_CTF_RG8 = 43,

	// <GX_CTF_GB8 = 0x2c>
	GX_CTF_GB8 = 44,

	// <GX_TF_Z8 = 0x11>
	GX_TF_Z8 = 17,

	// <GX_TF_Z16 = 0x13>
	GX_TF_Z16 = 19,

	// <GX_TF_Z24X8 = 0x16>
	GX_TF_Z24X8 = 22,

	// <GX_CTF_Z4 = 0x30>
	GX_CTF_Z4 = 48,

	// <GX_CTF_Z8M = 0x39>
	GX_CTF_Z8M = 57,

	// <GX_CTF_Z8L = 0x3a>
	GX_CTF_Z8L = 58,

	// <GX_CTF_Z16L = 0x3c>
	GX_CTF_Z16L = 60,

	// <GX_TF_A8 = 0x27>
	GX_TF_A8 = 39

};

// enum GHMR_TEXFILTER
enum GHMR_TEXFILTER : uint32_t
{
	// <GHMR_TEXFILTER_NEAR = 0x0>
	GHMR_TEXFILTER_NEAR = 0,

	// <GHMR_TEXFILTER_LINEAR = 0x1>
	GHMR_TEXFILTER_LINEAR = 1

};

// enum GHMR_TEXADDRESS
enum GHMR_TEXADDRESS : uint32_t
{
	// <GHMR_TEXADDRESS_CLAMP = 0x0>
	GHMR_TEXADDRESS_CLAMP = 0,

	// <GHMR_TEXADDRESS_REPEAT = 0x1>
	GHMR_TEXADDRESS_REPEAT = 1,

	// <GHMR_TEXADDRESS_MIRROR = 0x2>
	GHMR_TEXADDRESS_MIRROR = 2,

	// <GHMR_TEXADDRESS_REPEAT_FORCED = 0x3>
	GHMR_TEXADDRESS_REPEAT_FORCED = 3,

	// <GHMR_TEXADDRESS_MIRROR_FORCED = 0x4>
	GHMR_TEXADDRESS_MIRROR_FORCED = 4

};

// [Structure] struct GXTexObj
struct GXTexObj
{
public:
	/// Struct member variables

	// <class GXTexture* pTex, offset 0x0>
	class GXTexture* pTex;

	std::string ToString() const { return "struct GXTexObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXTexObj>("GXTexObj")
			.addFunction("__tostring", &GXTexObj::ToString)
			.addFunction("GetPtrAddr", &GXTexObj::GetPtrAddr)
			.addProperty("pTex", &GXTexObj::pTex)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXTexObj::pTex) == 4, "expected pTex to be size 4");
static_assert(sizeof(GXTexObj) == 4, "expected struct GXTexObj to be size 4");

// [Structure] struct tagGHMR_TEX
struct tagGHMR_TEX
{
public:
	/// Struct member variables

	// <uint8_t TMEFlag, offset 0x0>
	uint8_t TMEFlag;

	// <uint8_t AlphaFlag, offset 0x1>
	uint8_t AlphaFlag;

	// <uint8_t ImageBufferFreeFlag, offset 0x2>
	uint8_t ImageBufferFreeFlag;

	// <Unidentified data segment, offset 0x3>
private:
	char _UnidentifiedData3[1];

public:
	// <void* FileImage, offset 0x4>
	void* FileImage;

	// <void* ImageBuffer, offset 0x8>
	void* ImageBuffer;

	// <uint16_t Width, offset 0xc>
	uint16_t Width;

	// <uint16_t Height, offset 0xe>
	uint16_t Height;

	// <struct GXTexObj TexObj, offset 0x10>
	struct GXTexObj TexObj;

	// <enum GHMR_TEXADDRESS AddressMode, offset 0x14>
	enum GHMR_TEXADDRESS AddressMode;

	// <enum GHMR_TEXFILTER FilterMode, offset 0x18>
	enum GHMR_TEXFILTER FilterMode;

	// <enum _GXTexFmt GetScreenImageFormat, offset 0x1c>
	enum _GXTexFmt GetScreenImageFormat;

	// <int32_t ImageSize, offset 0x20>
	int32_t ImageSize;

	// <enum GHMR_TEXDOT_ASPECT Aspect, offset 0x24>
	enum GHMR_TEXDOT_ASPECT Aspect;

	std::string ToString() const { return "struct tagGHMR_TEX(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagGHMR_TEX>("tagGHMR_TEX")
			.addFunction("__tostring", &tagGHMR_TEX::ToString)
			.addFunction("GetPtrAddr", &tagGHMR_TEX::GetPtrAddr)
			.addProperty("TMEFlag", &tagGHMR_TEX::TMEFlag)
			.addProperty("AlphaFlag", &tagGHMR_TEX::AlphaFlag)
			.addProperty("ImageBufferFreeFlag", &tagGHMR_TEX::ImageBufferFreeFlag)
			// void type not supported in LuaBridge
			//.addProperty("FileImage", &tagGHMR_TEX::FileImage)
			// void type not supported in LuaBridge
			//.addProperty("ImageBuffer", &tagGHMR_TEX::ImageBuffer)
			.addProperty("Width", &tagGHMR_TEX::Width)
			.addProperty("Height", &tagGHMR_TEX::Height)
			.addProperty("TexObj", &tagGHMR_TEX::TexObj)
			.addProperty("AddressMode", &tagGHMR_TEX::AddressMode)
			.addProperty("FilterMode", &tagGHMR_TEX::FilterMode)
			.addProperty("GetScreenImageFormat", &tagGHMR_TEX::GetScreenImageFormat)
			.addProperty("ImageSize", &tagGHMR_TEX::ImageSize)
			.addProperty("Aspect", &tagGHMR_TEX::Aspect)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagGHMR_TEX::TMEFlag) == 1, "expected TMEFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::AlphaFlag) == 1, "expected AlphaFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::ImageBufferFreeFlag) == 1, "expected ImageBufferFreeFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::FileImage) == 4, "expected FileImage to be size 4");
static_assert(sizeof(tagGHMR_TEX::ImageBuffer) == 4, "expected ImageBuffer to be size 4");
static_assert(sizeof(tagGHMR_TEX::Width) == 2, "expected Width to be size 2");
static_assert(sizeof(tagGHMR_TEX::Height) == 2, "expected Height to be size 2");
static_assert(sizeof(tagGHMR_TEX::TexObj) == 4, "expected TexObj to be size 4");
static_assert(sizeof(tagGHMR_TEX::AddressMode) == 4, "expected AddressMode to be size 4");
static_assert(sizeof(tagGHMR_TEX::FilterMode) == 4, "expected FilterMode to be size 4");
static_assert(sizeof(tagGHMR_TEX::GetScreenImageFormat) == 4, "expected GetScreenImageFormat to be size 4");
static_assert(sizeof(tagGHMR_TEX::ImageSize) == 4, "expected ImageSize to be size 4");
static_assert(sizeof(tagGHMR_TEX::Aspect) == 4, "expected Aspect to be size 4");
static_assert(sizeof(tagGHMR_TEX) == 40, "expected struct tagGHMR_TEX to be size 40");

// [Structure] union GXSamplerStuff
union GXSamplerStuff
{
public:
	/// Struct member variables

	// <uint32_t wrapS, offset 0x0>
	uint32_t wrapS;

	std::string ToString() const { return "union GXSamplerStuff(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXSamplerStuff>("GXSamplerStuff")
			.addFunction("__tostring", &GXSamplerStuff::ToString)
			.addFunction("GetPtrAddr", &GXSamplerStuff::GetPtrAddr)
			.addProperty("wrapS", &GXSamplerStuff::wrapS)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXSamplerStuff::wrapS) == 4, "expected wrapS to be size 4");
static_assert(sizeof(GXSamplerStuff) == 4, "expected union GXSamplerStuff to be size 4");

// [Structure] class GXTexture
class GXTexture : public EE::RefObject
{
public:
	// [Structure] struct GXTexture::GXSpecs
	struct GXSpecs
	{
	public:
		/// Struct member variables

		// <uint16_t width, offset 0x0>
		uint16_t width;

		// <uint16_t height, offset 0x2>
		uint16_t height;

		// <uint16_t rtWidth, offset 0x4>
		uint16_t rtWidth;

		// <uint16_t rtHeight, offset 0x6>
		uint16_t rtHeight;

		// <enum _GXTexFmt format, offset 0x8>
		enum _GXTexFmt format;

		// <uint8_t mipmap, offset 0xc>
		uint8_t mipmap;

		// <uint8_t bias_clamp, offset 0xd>
		uint8_t bias_clamp;

		// <uint8_t do_edge_lod, offset 0xe>
		uint8_t do_edge_lod;

		// <Unidentified data segment, offset 0xf>
	private:
		char _UnidentifiedData8[1];

	public:
		// <uint32_t hash, offset 0x10>
		uint32_t hash;

		std::string ToString() const { return "struct GXSpecs(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<GXTexture::GXSpecs>("GXTexture_GXSpecs")
				.addFunction("__tostring", &GXTexture::GXSpecs::ToString)
				.addFunction("GetPtrAddr", &GXTexture::GXSpecs::GetPtrAddr)
				.addProperty("width", &GXTexture::GXSpecs::width)
				.addProperty("height", &GXTexture::GXSpecs::height)
				.addProperty("rtWidth", &GXTexture::GXSpecs::rtWidth)
				.addProperty("rtHeight", &GXTexture::GXSpecs::rtHeight)
				.addProperty("format", &GXTexture::GXSpecs::format)
				.addProperty("mipmap", &GXTexture::GXSpecs::mipmap)
				.addProperty("bias_clamp", &GXTexture::GXSpecs::bias_clamp)
				.addProperty("do_edge_lod", &GXTexture::GXSpecs::do_edge_lod)
				.addProperty("hash", &GXTexture::GXSpecs::hash)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(GXTexture::GXSpecs::width) == 2, "expected width to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::height) == 2, "expected height to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::rtWidth) == 2, "expected rtWidth to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::rtHeight) == 2, "expected rtHeight to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::format) == 4, "expected format to be size 4");
	static_assert(sizeof(GXTexture::GXSpecs::mipmap) == 1, "expected mipmap to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::bias_clamp) == 1, "expected bias_clamp to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::do_edge_lod) == 1, "expected do_edge_lod to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::hash) == 4, "expected hash to be size 4");
	static_assert(sizeof(GXTexture::GXSpecs) == 20, "expected struct GXTexture::GXSpecs to be size 20");

	/// Struct member variables

	// <class EE::RefObject field_0, offset 0x0>
	// class EE::RefObject Super;

	// <uint32_t marker, offset 0x8>
	uint32_t marker;

	// <union GXSamplerStuff sampler, offset 0xc>
	union GXSamplerStuff sampler;

	// <class EE::SmartPtr<ID3D11ShaderResourceView> textureView, offset 0x10>
	class EE::SmartPtr<ID3D11ShaderResourceView> textureView;

	// <uint32_t textureViewId, offset 0x14>
	uint32_t textureViewId;

	// <struct GXTexture::GXSpecs gxSpecs, offset 0x18>
	struct GXTexture::GXSpecs gxSpecs;

	// <class EE::SmartPtr<ID3D11Texture2D> texture, offset 0x2c>
	class EE::SmartPtr<ID3D11Texture2D> texture;

	// <class EE::SmartPtr<ID3D11RenderTargetView> renderTargetView, offset 0x30>
	class EE::SmartPtr<ID3D11RenderTargetView> renderTargetView;

	// <class EE::SmartPtr<ID3D11DepthStencilView> depthStencilView, offset 0x34>
	class EE::SmartPtr<ID3D11DepthStencilView> depthStencilView;

	// <class EE::SmartPtr<ID3D11Texture2D> stagingTex, offset 0x38>
	class EE::SmartPtr<ID3D11Texture2D> stagingTex;

	// <struct D3D11_MAPPED_SUBRESOURCE stagingTexMap, offset 0x3c>
	struct D3D11_MAPPED_SUBRESOURCE stagingTexMap;

	// <struct EE::OptListNode<GXTexture *> renderTargetListNode, offset 0x48>
	struct EE::OptListNode<GXTexture *> renderTargetListNode;

	std::string ToString() const { return "class GXTexture(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<GXTexture, EE::RefObject>("GXTexture")
			.addFunction("__tostring", &GXTexture::ToString)
			.addFunction("GetPtrAddr", &GXTexture::GetPtrAddr)
			.addProperty("marker", &GXTexture::marker)
			.addProperty("sampler", &GXTexture::sampler)
			.addProperty("textureView", &GXTexture::textureView)
			.addProperty("textureViewId", &GXTexture::textureViewId)
			.addProperty("gxSpecs", &GXTexture::gxSpecs)
			.addProperty("texture", &GXTexture::texture)
			.addProperty("renderTargetView", &GXTexture::renderTargetView)
			.addProperty("depthStencilView", &GXTexture::depthStencilView)
			.addProperty("stagingTex", &GXTexture::stagingTex)
			.addProperty("stagingTexMap", &GXTexture::stagingTexMap)
			.addProperty("renderTargetListNode", &GXTexture::renderTargetListNode)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXTexture::marker) == 4, "expected marker to be size 4");
static_assert(sizeof(GXTexture::sampler) == 4, "expected sampler to be size 4");
static_assert(sizeof(GXTexture::textureView) == 4, "expected textureView to be size 4");
static_assert(sizeof(GXTexture::textureViewId) == 4, "expected textureViewId to be size 4");
static_assert(sizeof(GXTexture::gxSpecs) == 20, "expected gxSpecs to be size 20");
static_assert(sizeof(GXTexture::texture) == 4, "expected texture to be size 4");
static_assert(sizeof(GXTexture::renderTargetView) == 4, "expected renderTargetView to be size 4");
static_assert(sizeof(GXTexture::depthStencilView) == 4, "expected depthStencilView to be size 4");
static_assert(sizeof(GXTexture::stagingTex) == 4, "expected stagingTex to be size 4");
static_assert(sizeof(GXTexture::stagingTexMap) == 12, "expected stagingTexMap to be size 12");
static_assert(sizeof(GXTexture::renderTargetListNode) == 12, "expected renderTargetListNode to be size 12");
static_assert(sizeof(GXTexture) == 84, "expected class GXTexture to be size 84");

// [Structure] struct rAlphaAnime
struct rAlphaAnime
{
public:
	/// Struct member variables

	// <float Add, offset 0x0>
	float Add;

	// <float Target, offset 0x4>
	float Target;

	std::string ToString() const { return "struct rAlphaAnime(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rAlphaAnime>("rAlphaAnime")
			.addFunction("__tostring", &rAlphaAnime::ToString)
			.addFunction("GetPtrAddr", &rAlphaAnime::GetPtrAddr)
			.addProperty("Add", &rAlphaAnime::Add)
			.addProperty("Target", &rAlphaAnime::Target)
		.endClass();
	}
#endif
};
static_assert(sizeof(rAlphaAnime::Add) == 4, "expected Add to be size 4");
static_assert(sizeof(rAlphaAnime::Target) == 4, "expected Target to be size 4");
static_assert(sizeof(rAlphaAnime) == 8, "expected struct rAlphaAnime to be size 8");

// [Structure] struct rAnimeCounter
struct rAnimeCounter
{
public:
	/// Struct member variables

	// <uint16_t Count, offset 0x0>
	uint16_t Count;

	// <uint16_t Frame, offset 0x2>
	uint16_t Frame;

	std::string ToString() const { return "struct rAnimeCounter(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rAnimeCounter>("rAnimeCounter")
			.addFunction("__tostring", &rAnimeCounter::ToString)
			.addFunction("GetPtrAddr", &rAnimeCounter::GetPtrAddr)
			.addProperty("Count", &rAnimeCounter::Count)
			.addProperty("Frame", &rAnimeCounter::Frame)
		.endClass();
	}
#endif
};
static_assert(sizeof(rAnimeCounter::Count) == 2, "expected Count to be size 2");
static_assert(sizeof(rAnimeCounter::Frame) == 2, "expected Frame to be size 2");
static_assert(sizeof(rAnimeCounter) == 4, "expected struct rAnimeCounter to be size 4");

// [Structure] struct rST
struct rST
{
public:
	/// Struct member variables

	// <float s, offset 0x0>
	float s;

	// <float t, offset 0x4>
	float t;

	std::string ToString() const { return "struct rST(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rST>("rST")
			.addFunction("__tostring", &rST::ToString)
			.addFunction("GetPtrAddr", &rST::GetPtrAddr)
			.addProperty("s", &rST::s)
			.addProperty("t", &rST::t)
		.endClass();
	}
#endif
};
static_assert(sizeof(rST::s) == 4, "expected s to be size 4");
static_assert(sizeof(rST::t) == 4, "expected t to be size 4");
static_assert(sizeof(rST) == 8, "expected struct rST to be size 8");

// [Structure] struct rColor
struct rColor
{
public:
	/// Struct member variables

	// <float r, offset 0x0>
	float r;

	// <float g, offset 0x4>
	float g;

	// <float b, offset 0x8>
	float b;

	// <float a, offset 0xc>
	float a;

	std::string ToString() const { return "struct rColor(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rColor>("rColor")
			.addFunction("__tostring", &rColor::ToString)
			.addFunction("GetPtrAddr", &rColor::GetPtrAddr)
			.addProperty("r", &rColor::r)
			.addProperty("g", &rColor::g)
			.addProperty("b", &rColor::b)
			.addProperty("a", &rColor::a)
		.endClass();
	}
#endif
};
static_assert(sizeof(rColor::r) == 4, "expected r to be size 4");
static_assert(sizeof(rColor::g) == 4, "expected g to be size 4");
static_assert(sizeof(rColor::b) == 4, "expected b to be size 4");
static_assert(sizeof(rColor::a) == 4, "expected a to be size 4");
static_assert(sizeof(rColor) == 16, "expected struct rColor to be size 16");

// [Structure] class rPrimBase
class rPrimBase
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x3], offset 0x0>
	void* (* field_0)[0x3];

	// <uint32_t m_BitFlag, offset 0x4>
	uint32_t m_BitFlag;

	// <rPrimBase* m_pPrev, offset 0x8>
	rPrimBase* m_pPrev;

	// <rPrimBase* m_pNext, offset 0xc>
	rPrimBase* m_pNext;

	std::string ToString() const { return "class rPrimBase(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rPrimBase>("rPrimBase")
			.addFunction("__tostring", &rPrimBase::ToString)
			.addFunction("GetPtrAddr", &rPrimBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &rPrimBase::field_0)
			.addProperty("m_BitFlag", &rPrimBase::m_BitFlag)
			.addProperty("m_pPrev", &rPrimBase::m_pPrev)
			.addProperty("m_pNext", &rPrimBase::m_pNext)
		.endClass();
	}
#endif
};
static_assert(sizeof(rPrimBase::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(rPrimBase::m_BitFlag) == 4, "expected m_BitFlag to be size 4");
static_assert(sizeof(rPrimBase::m_pPrev) == 4, "expected m_pPrev to be size 4");
static_assert(sizeof(rPrimBase::m_pNext) == 4, "expected m_pNext to be size 4");
static_assert(sizeof(rPrimBase) == 16, "expected class rPrimBase to be size 16");

// [Structure] class rTriangleList
class rTriangleList : public rPrimBase
{
public:
	/// Struct member variables

	// <class rPrimBase field_0, offset 0x0>
	// class rPrimBase Super;

	// <struct Vec m_Position, offset 0x10>
	struct Vec m_Position;

	// <struct rColor m_Color, offset 0x1c>
	struct rColor m_Color;

	// <struct rST m_ST, offset 0x2c>
	struct rST m_ST;

	// <struct rAnimeCounter m_AnimeCounter, offset 0x34>
	struct rAnimeCounter m_AnimeCounter;

	// <struct rAlphaAnime m_ColorAnime, offset 0x38>
	struct rAlphaAnime m_ColorAnime;

	std::string ToString() const { return "class rTriangleList(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<rTriangleList, rPrimBase>("rTriangleList")
			.addFunction("__tostring", &rTriangleList::ToString)
			.addFunction("GetPtrAddr", &rTriangleList::GetPtrAddr)
			.addProperty("m_Position", &rTriangleList::m_Position)
			.addProperty("m_Color", &rTriangleList::m_Color)
			.addProperty("m_ST", &rTriangleList::m_ST)
			.addProperty("m_AnimeCounter", &rTriangleList::m_AnimeCounter)
			.addProperty("m_ColorAnime", &rTriangleList::m_ColorAnime)
		.endClass();
	}
#endif
};
static_assert(sizeof(rTriangleList::m_Position) == 12, "expected m_Position to be size 12");
static_assert(sizeof(rTriangleList::m_Color) == 16, "expected m_Color to be size 16");
static_assert(sizeof(rTriangleList::m_ST) == 8, "expected m_ST to be size 8");
static_assert(sizeof(rTriangleList::m_AnimeCounter) == 4, "expected m_AnimeCounter to be size 4");
static_assert(sizeof(rTriangleList::m_ColorAnime) == 8, "expected m_ColorAnime to be size 8");
static_assert(sizeof(rTriangleList) == 64, "expected class rTriangleList to be size 64");

// [Structure] class CVertexAnimation
class CVertexAnimation
{
public:
	// [Structure] class CVertexAnimation::CVertex
	class CVertex
	{
	public:
		/// Struct member variables

		// <int32_t m_nPosiIndex, offset 0x0>
		int32_t m_nPosiIndex;

		// <float m_fCenter, offset 0x4>
		float m_fCenter;

		// <int32_t m_nSinIndex, offset 0x8>
		int32_t m_nSinIndex;

		std::string ToString() const { return "class CVertex(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CVertexAnimation::CVertex>("CVertexAnimation_CVertex")
				.addFunction("__tostring", &CVertexAnimation::CVertex::ToString)
				.addFunction("GetPtrAddr", &CVertexAnimation::CVertex::GetPtrAddr)
				.addProperty("m_nPosiIndex", &CVertexAnimation::CVertex::m_nPosiIndex)
				.addProperty("m_fCenter", &CVertexAnimation::CVertex::m_fCenter)
				.addProperty("m_nSinIndex", &CVertexAnimation::CVertex::m_nSinIndex)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(CVertexAnimation::CVertex::m_nPosiIndex) == 4, "expected m_nPosiIndex to be size 4");
	static_assert(sizeof(CVertexAnimation::CVertex::m_fCenter) == 4, "expected m_fCenter to be size 4");
	static_assert(sizeof(CVertexAnimation::CVertex::m_nSinIndex) == 4, "expected m_nSinIndex to be size 4");
	static_assert(sizeof(CVertexAnimation::CVertex) == 12, "expected class CVertexAnimation::CVertex to be size 12");

	/// Struct member variables

	// <uint8_t* m_pbyNewMem, offset 0x0>
	uint8_t* m_pbyNewMem;

	// <uint8_t* m_abyNodePosiBuf[0x2], offset 0x4>
	uint8_t* m_abyNodePosiBuf[2];

	// <uint32_t m_nBufSize, offset 0xc>
	uint32_t m_nBufSize;

	// <class CStlVector<CVertexAnimation::CVertex> m_ainVertex, offset 0x10>
	class std::vector<CVertexAnimation::CVertex> m_ainVertex;

	// <float m_fOfstMax, offset 0x1c>
	float m_fOfstMax;

	std::string ToString() const { return "class CVertexAnimation(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CVertexAnimation>("CVertexAnimation")
			.addFunction("__tostring", &CVertexAnimation::ToString)
			.addFunction("GetPtrAddr", &CVertexAnimation::GetPtrAddr)
			// native pointer type (uint8_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pbyNewMem", &CVertexAnimation::m_pbyNewMem)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_abyNodePosiBuf", &CVertexAnimation::m_abyNodePosiBuf)
			.addProperty("m_nBufSize", &CVertexAnimation::m_nBufSize)
			.addProperty("m_ainVertex", &CVertexAnimation::m_ainVertex)
			.addProperty("m_fOfstMax", &CVertexAnimation::m_fOfstMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(CVertexAnimation::m_pbyNewMem) == 4, "expected m_pbyNewMem to be size 4");
static_assert(sizeof(CVertexAnimation::m_abyNodePosiBuf) == 8, "expected m_abyNodePosiBuf to be size 8");
static_assert(sizeof(CVertexAnimation::m_nBufSize) == 4, "expected m_nBufSize to be size 4");
static_assert(sizeof(CVertexAnimation::m_ainVertex) == 12, "expected m_ainVertex to be size 12");
static_assert(sizeof(CVertexAnimation::m_fOfstMax) == 4, "expected m_fOfstMax to be size 4");
static_assert(sizeof(CVertexAnimation) == 32, "expected class CVertexAnimation to be size 32");

// [Structure] class TFAnmObjF32_3
class TFAnmObjF32_3
{
public:
	// [Structure] struct TFAnmObjF32_3::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData[360];
	public:

		std::string ToString() const { return "struct tagMAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TFAnmObjF32_3::tagMAIN>("TFAnmObjF32_3_tagMAIN")
				.addFunction("__tostring", &TFAnmObjF32_3::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TFAnmObjF32_3::tagMAIN::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnmObjF32_3::tagMAIN) == 360, "expected struct TFAnmObjF32_3::tagMAIN to be size 360");

	/// Struct member variables

	// <struct TFAnmObjF32_3::tagMAIN dat, offset 0x0>
	struct TFAnmObjF32_3::tagMAIN dat;

	std::string ToString() const { return "class TFAnmObjF32_3(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnmObjF32_3>("TFAnmObjF32_3")
			.addFunction("__tostring", &TFAnmObjF32_3::ToString)
			.addFunction("GetPtrAddr", &TFAnmObjF32_3::GetPtrAddr)
			.addProperty("dat", &TFAnmObjF32_3::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnmObjF32_3::dat) == 360, "expected dat to be size 360");
static_assert(sizeof(TFAnmObjF32_3) == 360, "expected class TFAnmObjF32_3 to be size 360");

// [Structure] union _WFAnmVal
union _WFAnmVal
{
public:
	/// Struct member variables

	// <float mFVal, offset 0x0>
	float mFVal;

	std::string ToString() const { return "union _WFAnmVal(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmVal>("_WFAnmVal")
			.addFunction("__tostring", &_WFAnmVal::ToString)
			.addFunction("GetPtrAddr", &_WFAnmVal::GetPtrAddr)
			.addProperty("mFVal", &_WFAnmVal::mFVal)
		.endClass();
	}
#endif
};
static_assert(sizeof(_WFAnmVal::mFVal) == 4, "expected mFVal to be size 4");
static_assert(sizeof(_WFAnmVal) == 4, "expected union _WFAnmVal to be size 4");

// enum TFANMOBJDATATYPE
enum TFANMOBJDATATYPE : uint32_t
{
	// <TFANMOBJDATATYPE_NONE = 0x0>
	TFANMOBJDATATYPE_NONE = 0,

	// <TFANMOBJDATATYPE_FLOAT = 0x1>
	TFANMOBJDATATYPE_FLOAT = 1,

	// <TFANMOBJDATATYPE_ROT = 0x2>
	TFANMOBJDATATYPE_ROT = 2,

	// <TFANMOBJDATATYPE_BOOL = 0x3>
	TFANMOBJDATATYPE_BOOL = 3,

	// <TFANMOBJDATATYPE_COLOR = 0x4>
	TFANMOBJDATATYPE_COLOR = 4,

	// <TFANMOBJDATATYPE_INT = 0x5>
	TFANMOBJDATATYPE_INT = 5,

	// <TFANMOBJDATATYPE_CALLBACK = 0x6>
	TFANMOBJDATATYPE_CALLBACK = 6,

	// <TFANMOBJDATATYPE_XYZ_POS = 0x7>
	TFANMOBJDATATYPE_XYZ_POS = 7,

	// <TFANMOBJDATATYPE_XYZ_ROT = 0x8>
	TFANMOBJDATATYPE_XYZ_ROT = 8

};

// [Structure] class TFAnmObj
class TFAnmObj
{
public:
	// [Structure] struct TFAnmObj::tagGETA
	struct tagGETA
	{
	public:
		/// Struct member variables

		// <float Value, offset 0x0>
		float Value;

		// <float Wait, offset 0x4>
		float Wait;

		// <float LockWait, offset 0x8>
		float LockWait;

		// <float InSlope, offset 0xc>
		float InSlope;

		// <float OutSlope, offset 0x10>
		float OutSlope;

		std::string ToString() const { return "struct tagGETA(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TFAnmObj::tagGETA>("TFAnmObj_tagGETA")
				.addFunction("__tostring", &TFAnmObj::tagGETA::ToString)
				.addFunction("GetPtrAddr", &TFAnmObj::tagGETA::GetPtrAddr)
				.addProperty("Value", &TFAnmObj::tagGETA::Value)
				.addProperty("Wait", &TFAnmObj::tagGETA::Wait)
				.addProperty("LockWait", &TFAnmObj::tagGETA::LockWait)
				.addProperty("InSlope", &TFAnmObj::tagGETA::InSlope)
				.addProperty("OutSlope", &TFAnmObj::tagGETA::OutSlope)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnmObj::tagGETA::Value) == 4, "expected Value to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::Wait) == 4, "expected Wait to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::LockWait) == 4, "expected LockWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::InSlope) == 4, "expected InSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::OutSlope) == 4, "expected OutSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA) == 20, "expected struct TFAnmObj::tagGETA to be size 20");

	// [Structure] struct TFAnmObj::tagMAIN
	struct tagMAIN
	{
	public:
		/// Struct member variables

		// <struct _WFAnmObjHeader* pAnmData, offset 0x0>
		struct _WFAnmObjHeader* pAnmData;

		// <enum TFANMOBJDATATYPE DataType, offset 0x4>
		enum TFANMOBJDATATYPE DataType;

		// <void* pData, offset 0x8>
		void* pData;

		// <void (* pCallback)(union _WFAnmVal*, void*), offset 0xc>
		void (* pCallback)(union _WFAnmVal*, void*);

		// <union _WFAnmVal NowValue, offset 0x10>
		union _WFAnmVal NowValue;

		// <uint32_t Flag, offset 0x14>
		uint32_t Flag;

		// <uint8_t NextType, offset 0x18>
		uint8_t NextType;

		// <uint8_t PrevType, offset 0x19>
		uint8_t PrevType;

		// <uint16_t KeyCount, offset 0x1a>
		uint16_t KeyCount;

		// <uint16_t KeyCountMax, offset 0x1c>
		uint16_t KeyCountMax;

		// <uint16_t KeyListCount, offset 0x1e>
		uint16_t KeyListCount;

		// <float Tick, offset 0x20>
		float Tick;

		// <float NextWait, offset 0x24>
		float NextWait;

		// <float PrevWait, offset 0x28>
		float PrevWait;

		// <void* pNextKey, offset 0x2c>
		void* pNextKey;

		// <void* pPrevKey, offset 0x30>
		void* pPrevKey;

		// <float NextValue, offset 0x34>
		float NextValue;

		// <float PrevValue, offset 0x38>
		float PrevValue;

		// <float NextSlope, offset 0x3c>
		float NextSlope;

		// <float PrevSlope, offset 0x40>
		float PrevSlope;

		// <struct TFAnmObj::tagGETA NextGeta, offset 0x44>
		struct tagGETA NextGeta;

		// <struct TFAnmObj::tagGETA PrevGeta, offset 0x58>
		struct tagGETA PrevGeta;

		// <struct _WFAnmObjKeyListHeader* pNowKeyListHeader, offset 0x6c>
		struct _WFAnmObjKeyListHeader* pNowKeyListHeader;

		// <struct TFAnmObj::tagGETA NowKeyGeta, offset 0x70>
		struct tagGETA NowKeyGeta;

		// <uint32_t NowKeyTypeSize, offset 0x84>
		uint32_t NowKeyTypeSize;

		// <void* pNowKey, offset 0x88>
		void* pNowKey;

		std::string ToString() const { return "struct tagMAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TFAnmObj::tagMAIN>("TFAnmObj_tagMAIN")
				.addFunction("__tostring", &TFAnmObj::tagMAIN::ToString)
				.addFunction("GetPtrAddr", &TFAnmObj::tagMAIN::GetPtrAddr)
				.addProperty("pAnmData", &TFAnmObj::tagMAIN::pAnmData)
				.addProperty("DataType", &TFAnmObj::tagMAIN::DataType)
				// void type not supported in LuaBridge
				//.addProperty("pData", &TFAnmObj::tagMAIN::pData)
				// delegates are not supported in LuaBridge
				//.addProperty("pCallback", &TFAnmObj::tagMAIN::pCallback)
				.addProperty("NowValue", &TFAnmObj::tagMAIN::NowValue)
				.addProperty("Flag", &TFAnmObj::tagMAIN::Flag)
				.addProperty("NextType", &TFAnmObj::tagMAIN::NextType)
				.addProperty("PrevType", &TFAnmObj::tagMAIN::PrevType)
				.addProperty("KeyCount", &TFAnmObj::tagMAIN::KeyCount)
				.addProperty("KeyCountMax", &TFAnmObj::tagMAIN::KeyCountMax)
				.addProperty("KeyListCount", &TFAnmObj::tagMAIN::KeyListCount)
				.addProperty("Tick", &TFAnmObj::tagMAIN::Tick)
				.addProperty("NextWait", &TFAnmObj::tagMAIN::NextWait)
				.addProperty("PrevWait", &TFAnmObj::tagMAIN::PrevWait)
				// void type not supported in LuaBridge
				//.addProperty("pNextKey", &TFAnmObj::tagMAIN::pNextKey)
				// void type not supported in LuaBridge
				//.addProperty("pPrevKey", &TFAnmObj::tagMAIN::pPrevKey)
				.addProperty("NextValue", &TFAnmObj::tagMAIN::NextValue)
				.addProperty("PrevValue", &TFAnmObj::tagMAIN::PrevValue)
				.addProperty("NextSlope", &TFAnmObj::tagMAIN::NextSlope)
				.addProperty("PrevSlope", &TFAnmObj::tagMAIN::PrevSlope)
				.addProperty("NextGeta", &TFAnmObj::tagMAIN::NextGeta)
				.addProperty("PrevGeta", &TFAnmObj::tagMAIN::PrevGeta)
				.addProperty("pNowKeyListHeader", &TFAnmObj::tagMAIN::pNowKeyListHeader)
				.addProperty("NowKeyGeta", &TFAnmObj::tagMAIN::NowKeyGeta)
				.addProperty("NowKeyTypeSize", &TFAnmObj::tagMAIN::NowKeyTypeSize)
				// void type not supported in LuaBridge
				//.addProperty("pNowKey", &TFAnmObj::tagMAIN::pNowKey)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnmObj::tagMAIN::pAnmData) == 4, "expected pAnmData to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::DataType) == 4, "expected DataType to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pData) == 4, "expected pData to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pCallback) == 4, "expected pCallback to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowValue) == 4, "expected NowValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::Flag) == 4, "expected Flag to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextType) == 1, "expected NextType to be size 1");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevType) == 1, "expected PrevType to be size 1");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyCount) == 2, "expected KeyCount to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyCountMax) == 2, "expected KeyCountMax to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyListCount) == 2, "expected KeyListCount to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::Tick) == 4, "expected Tick to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextWait) == 4, "expected NextWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevWait) == 4, "expected PrevWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNextKey) == 4, "expected pNextKey to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pPrevKey) == 4, "expected pPrevKey to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextValue) == 4, "expected NextValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevValue) == 4, "expected PrevValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextSlope) == 4, "expected NextSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevSlope) == 4, "expected PrevSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextGeta) == 20, "expected NextGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevGeta) == 20, "expected PrevGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNowKeyListHeader) == 4, "expected pNowKeyListHeader to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowKeyGeta) == 20, "expected NowKeyGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowKeyTypeSize) == 4, "expected NowKeyTypeSize to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNowKey) == 4, "expected pNowKey to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN) == 140, "expected struct TFAnmObj::tagMAIN to be size 140");

	/// Struct member variables

	// <struct TFAnmObj::tagMAIN dat, offset 0x0>
	struct TFAnmObj::tagMAIN dat;

	std::string ToString() const { return "class TFAnmObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnmObj>("TFAnmObj")
			.addFunction("__tostring", &TFAnmObj::ToString)
			.addFunction("GetPtrAddr", &TFAnmObj::GetPtrAddr)
			.addProperty("dat", &TFAnmObj::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnmObj::dat) == 140, "expected dat to be size 140");
static_assert(sizeof(TFAnmObj) == 140, "expected class TFAnmObj to be size 140");

// [Structure] class mot::IBoneEffectPJ
namespace mot
{
	class IBoneEffectPJ
	{
	public:
		/// Struct member variables

		// <void* (* field_0)[0x17], offset 0x0>
		void* (* field_0)[0x17];

		std::string ToString() const { return "class IBoneEffectPJ(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::IBoneEffectPJ>("mot_IBoneEffectPJ")
				.addFunction("__tostring", &mot::IBoneEffectPJ::ToString)
				.addFunction("GetPtrAddr", &mot::IBoneEffectPJ::GetPtrAddr)
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &mot::IBoneEffectPJ::field_0)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectPJ::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(mot::IBoneEffectPJ) == 4, "expected class mot::IBoneEffectPJ to be size 4");

// enum ECameraVibAnimeType
enum ECameraVibAnimeType : uint32_t
{
	// <CAMERA_VIB_ANIME_TYPE_DAMAGE_HIT = 0x0>
	CAMERA_VIB_ANIME_TYPE_DAMAGE_HIT = 0,

	// <CAMERA_VIB_ANIME_TYPE_DAMAGE_FALL = 0x1>
	CAMERA_VIB_ANIME_TYPE_DAMAGE_FALL = 1,

	// <CAMERA_VIB_ANIME_TYPE_QUAKE = 0x2>
	CAMERA_VIB_ANIME_TYPE_QUAKE = 2,

	// <CAMERA_VIB_ANIME_TYPE_ATTACK = 0x3>
	CAMERA_VIB_ANIME_TYPE_ATTACK = 3,

	// <CAMERA_VIB_ANIME_TYPE_ATTACK_SIDE = 0x4>
	CAMERA_VIB_ANIME_TYPE_ATTACK_SIDE = 4,

	// <CAMERA_VIB_ANIME_TYPE_EXPLOSION = 0x5>
	CAMERA_VIB_ANIME_TYPE_EXPLOSION = 5,

	// <CAMERA_VIB_ANIME_TYPE_EXPLOSION_LONG = 0x6>
	CAMERA_VIB_ANIME_TYPE_EXPLOSION_LONG = 6,

	// <CAMERA_VIB_ANIME_TYPE_SHOCK = 0x7>
	CAMERA_VIB_ANIME_TYPE_SHOCK = 7,

	// <CAMERA_VIB_ANIME_TYPE_SHOCK_SIDE = 0x8>
	CAMERA_VIB_ANIME_TYPE_SHOCK_SIDE = 8,

	// <CAMERA_VIB_ANIME_TYPE_FILM_NOISE = 0x9>
	CAMERA_VIB_ANIME_TYPE_FILM_NOISE = 9,

	// <CAMERA_VIB_ANIME_TYPE_FILM_NOISE2 = 0xa>
	CAMERA_VIB_ANIME_TYPE_FILM_NOISE2 = 10,

	// <CAMERA_VIB_ANIME_TYPE_WIND_PRESS_SIDE = 0xb>
	CAMERA_VIB_ANIME_TYPE_WIND_PRESS_SIDE = 11,

	// <CAMERA_VIB_ANIME_TYPE_CRASH = 0xc>
	CAMERA_VIB_ANIME_TYPE_CRASH = 12,

	// <CAMERA_VIB_ANIME_TYPE_TURN_BANK = 0xd>
	CAMERA_VIB_ANIME_TYPE_TURN_BANK = 13,

	// <TOTAL_CAMERA_VIB_ANIME_TYPE = 0xe>
	TOTAL_CAMERA_VIB_ANIME_TYPE = 14

};

// [Structure] class CCameraVibTiming
class CCameraVibTiming
{
public:
	// [Function] class CCameraVibTiming* CCameraVibTiming::getTable(int32_t* arg1, class mHRChara& arg2) [?getTable@CCameraVibTiming@@SAPBV1@PAHABVmHRChara@@@Z]
	static class CCameraVibTiming* getTable(int32_t* arg1, class mHRChara& arg2)
	{
		typedef class CCameraVibTiming*(__fastcall* _Func)(int32_t* arg1, class mHRChara& arg2);
		_Func mFunc = (_Func)(GameModule + 0x567740);
		return mFunc(arg1, arg2);
	}
	/// Struct member variables

	// <char const* m_sMotName, offset 0x0>
	char const* m_sMotName;

	// <float m_fMotFrame, offset 0x4>
	float m_fMotFrame;

	// <enum ECameraVibAnimeType m_eAnimeType, offset 0x8>
	enum ECameraVibAnimeType m_eAnimeType;

	// <float m_fAnimeScale, offset 0xc>
	float m_fAnimeScale;

	std::string ToString() const { return "class CCameraVibTiming(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraVibTiming>("CCameraVibTiming")
			.addFunction("__tostring", &CCameraVibTiming::ToString)
			.addFunction("GetPtrAddr", &CCameraVibTiming::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sMotName", &CCameraVibTiming::m_sMotName)
			.addProperty("m_fMotFrame", &CCameraVibTiming::m_fMotFrame)
			.addProperty("m_eAnimeType", &CCameraVibTiming::m_eAnimeType)
			.addProperty("m_fAnimeScale", &CCameraVibTiming::m_fAnimeScale)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("getTable", &CCameraVibTiming::getTable)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraVibTiming::m_sMotName) == 4, "expected m_sMotName to be size 4");
static_assert(sizeof(CCameraVibTiming::m_fMotFrame) == 4, "expected m_fMotFrame to be size 4");
static_assert(sizeof(CCameraVibTiming::m_eAnimeType) == 4, "expected m_eAnimeType to be size 4");
static_assert(sizeof(CCameraVibTiming::m_fAnimeScale) == 4, "expected m_fAnimeScale to be size 4");
static_assert(sizeof(CCameraVibTiming) == 16, "expected class CCameraVibTiming to be size 16");

// enum eENVOICE
enum eENVOICE : uint32_t
{
	// <eENVOICE_A = 0x0>
	eENVOICE_A = 0,

	// <eENVOICE_B = 0x5>
	eENVOICE_B = 5,

	// <eENVOICE_C = 0xa>
	eENVOICE_C = 10,

	// <eENVOICE_D = 0xf>
	eENVOICE_D = 15

};

// [Structure] struct HRCHARAVOICE
struct HRCHARAVOICE
{
public:
	/// Struct member variables

	// <char const* pFileName, offset 0x0>
	char const* pFileName;

	// <enum eENVOICE Voice, offset 0x4>
	enum eENVOICE Voice;

	// <uint32_t FileNameLength, offset 0x8>
	uint32_t FileNameLength;

	std::string ToString() const { return "struct HRCHARAVOICE(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HRCHARAVOICE>("HRCHARAVOICE")
			.addFunction("__tostring", &HRCHARAVOICE::ToString)
			.addFunction("GetPtrAddr", &HRCHARAVOICE::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("pFileName", &HRCHARAVOICE::pFileName)
			.addProperty("Voice", &HRCHARAVOICE::Voice)
			.addProperty("FileNameLength", &HRCHARAVOICE::FileNameLength)
		.endClass();
	}
#endif
};
static_assert(sizeof(HRCHARAVOICE::pFileName) == 4, "expected pFileName to be size 4");
static_assert(sizeof(HRCHARAVOICE::Voice) == 4, "expected Voice to be size 4");
static_assert(sizeof(HRCHARAVOICE::FileNameLength) == 4, "expected FileNameLength to be size 4");
static_assert(sizeof(HRCHARAVOICE) == 12, "expected struct HRCHARAVOICE to be size 12");

// [Structure] class gameUtil::CPlane
namespace gameUtil
{
	class CPlane
	{
	public:
		/// Struct member variables

		// <class tiVector m_inABCD, offset 0x0>
		class tiVector m_inABCD;

		std::string ToString() const { return "class CPlane(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<gameUtil::CPlane>("gameUtil_CPlane")
				.addFunction("__tostring", &gameUtil::CPlane::ToString)
				.addFunction("GetPtrAddr", &gameUtil::CPlane::GetPtrAddr)
				.addProperty("m_inABCD", &gameUtil::CPlane::m_inABCD)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(gameUtil::CPlane::m_inABCD) == 16, "expected m_inABCD to be size 16");
static_assert(sizeof(gameUtil::CPlane) == 16, "expected class gameUtil::CPlane to be size 16");

// [Structure] class CStickShadow
class CStickShadow
{
public:
	/// Struct member variables

	// <class gameUtil::CPlane m_inProjPlane, offset 0x0>
	class gameUtil::CPlane m_inProjPlane;

	// <int32_t m_nBoneID, offset 0x10>
	int32_t m_nBoneID;

	// <float m_fWidthHalf, offset 0x14>
	float m_fWidthHalf;

	// <float m_fDepthPlus, offset 0x18>
	float m_fDepthPlus;

	// <float m_fDepthMinus, offset 0x1c>
	float m_fDepthMinus;

	// <float m_fAlphaMaxDist, offset 0x20>
	float m_fAlphaMaxDist;

	// <float m_fAlphaMinDist, offset 0x24>
	float m_fAlphaMinDist;

	// <Unidentified data segment, offset 0x28>
private:
	char _UnidentifiedData[8];
public:

	std::string ToString() const { return "class CStickShadow(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CStickShadow>("CStickShadow")
			.addFunction("__tostring", &CStickShadow::ToString)
			.addFunction("GetPtrAddr", &CStickShadow::GetPtrAddr)
			.addProperty("m_inProjPlane", &CStickShadow::m_inProjPlane)
			.addProperty("m_nBoneID", &CStickShadow::m_nBoneID)
			.addProperty("m_fWidthHalf", &CStickShadow::m_fWidthHalf)
			.addProperty("m_fDepthPlus", &CStickShadow::m_fDepthPlus)
			.addProperty("m_fDepthMinus", &CStickShadow::m_fDepthMinus)
			.addProperty("m_fAlphaMaxDist", &CStickShadow::m_fAlphaMaxDist)
			.addProperty("m_fAlphaMinDist", &CStickShadow::m_fAlphaMinDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(CStickShadow::m_inProjPlane) == 16, "expected m_inProjPlane to be size 16");
static_assert(sizeof(CStickShadow::m_nBoneID) == 4, "expected m_nBoneID to be size 4");
static_assert(sizeof(CStickShadow::m_fWidthHalf) == 4, "expected m_fWidthHalf to be size 4");
static_assert(sizeof(CStickShadow::m_fDepthPlus) == 4, "expected m_fDepthPlus to be size 4");
static_assert(sizeof(CStickShadow::m_fDepthMinus) == 4, "expected m_fDepthMinus to be size 4");
static_assert(sizeof(CStickShadow::m_fAlphaMaxDist) == 4, "expected m_fAlphaMaxDist to be size 4");
static_assert(sizeof(CStickShadow::m_fAlphaMinDist) == 4, "expected m_fAlphaMinDist to be size 4");
static_assert(sizeof(CStickShadow) == 48, "expected class CStickShadow to be size 48");

// [Structure] class CharController
class CharController
{
public:
	// enum CharController::eChrCntrlMoveMode
	enum eChrCntrlMoveMode : uint32_t
	{
		// <eChrCntrlMoveMode_WalkSideLeft = 0x0>
		eChrCntrlMoveMode_WalkSideLeft = 0,

		// <eChrCntrlMoveMode_WalkSideRight = 0x1>
		eChrCntrlMoveMode_WalkSideRight = 1,

		// <eChrCntrlMoveMode_WalkForward = 0x2>
		eChrCntrlMoveMode_WalkForward = 2,

		// <eChrCntrlMoveMode_WalkBack = 0x3>
		eChrCntrlMoveMode_WalkBack = 3,

		// <eChrCntrlMoveMode_RunForward = 0x4>
		eChrCntrlMoveMode_RunForward = 4,

		// <eChrCntrlMoveMode_Idle = 0x5>
		eChrCntrlMoveMode_Idle = 5,

		// <eChrCntrlMoveMode_NumMax = 0x6>
		eChrCntrlMoveMode_NumMax = 6

	};

	/// Struct member variables

	// <uint8_t m_boNowUnderControl, offset 0x0>
	uint8_t m_boNowUnderControl;

	// <uint8_t m_boEnableControl, offset 0x1>
	uint8_t m_boEnableControl;

	// <Unidentified data segment, offset 0x2>
private:
	char _UnidentifiedData2[2];

public:
	// <class mHRChara* m_pOwnerChar, offset 0x4>
	class mHRChara* m_pOwnerChar;

	// <struct CharControlMotID m_RegMotID, offset 0x8>
	struct CharControlMotID m_RegMotID;

	// <uint8_t m_boRegistMove, offset 0x2c>
	uint8_t m_boRegistMove;

	// <uint8_t m_boRegistAttack, offset 0x2d>
	uint8_t m_boRegistAttack;

	// <uint8_t m_boLockon, offset 0x2e>
	uint8_t m_boLockon;

	// <Unidentified data segment, offset 0x2f>
private:
	char _UnidentifiedData7[1];

public:
	// <struct Vec m_PcDirection, offset 0x30>
	struct Vec m_PcDirection;

	// <struct Vec m_MoveVec, offset 0x3c>
	struct Vec m_MoveVec;

	// <struct Vec m_VecStickL, offset 0x48>
	struct Vec m_VecStickL;

	// <float m_fStickInpRatio, offset 0x54>
	float m_fStickInpRatio;

	// <enum CharController::eChrCntrlMoveMode m_MoveMode, offset 0x58>
	enum CharController::eChrCntrlMoveMode m_MoveMode;

	std::string ToString() const { return "class CharController(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CharController>("CharController")
			.addFunction("__tostring", &CharController::ToString)
			.addFunction("GetPtrAddr", &CharController::GetPtrAddr)
			.addProperty("m_boNowUnderControl", &CharController::m_boNowUnderControl)
			.addProperty("m_boEnableControl", &CharController::m_boEnableControl)
			.addProperty("m_pOwnerChar", &CharController::m_pOwnerChar)
			.addProperty("m_RegMotID", &CharController::m_RegMotID)
			.addProperty("m_boRegistMove", &CharController::m_boRegistMove)
			.addProperty("m_boRegistAttack", &CharController::m_boRegistAttack)
			.addProperty("m_boLockon", &CharController::m_boLockon)
			.addProperty("m_PcDirection", &CharController::m_PcDirection)
			.addProperty("m_MoveVec", &CharController::m_MoveVec)
			.addProperty("m_VecStickL", &CharController::m_VecStickL)
			.addProperty("m_fStickInpRatio", &CharController::m_fStickInpRatio)
			.addProperty("m_MoveMode", &CharController::m_MoveMode)
		.endClass();
	}
#endif
};
static_assert(sizeof(CharController::m_boNowUnderControl) == 1, "expected m_boNowUnderControl to be size 1");
static_assert(sizeof(CharController::m_boEnableControl) == 1, "expected m_boEnableControl to be size 1");
static_assert(sizeof(CharController::m_pOwnerChar) == 4, "expected m_pOwnerChar to be size 4");
static_assert(sizeof(CharController::m_RegMotID) == 36, "expected m_RegMotID to be size 36");
static_assert(sizeof(CharController::m_boRegistMove) == 1, "expected m_boRegistMove to be size 1");
static_assert(sizeof(CharController::m_boRegistAttack) == 1, "expected m_boRegistAttack to be size 1");
static_assert(sizeof(CharController::m_boLockon) == 1, "expected m_boLockon to be size 1");
static_assert(sizeof(CharController::m_PcDirection) == 12, "expected m_PcDirection to be size 12");
static_assert(sizeof(CharController::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(CharController::m_VecStickL) == 12, "expected m_VecStickL to be size 12");
static_assert(sizeof(CharController::m_fStickInpRatio) == 4, "expected m_fStickInpRatio to be size 4");
static_assert(sizeof(CharController::m_MoveMode) == 4, "expected m_MoveMode to be size 4");
static_assert(sizeof(CharController) == 92, "expected class CharController to be size 92");

// [Structure] class CObjectShadow
class CObjectShadow
{
public:
	/// Struct member variables

	// <struct tagGHMR_TEX m_inUpTex, offset 0x0>
	struct tagGHMR_TEX m_inUpTex;

	// <struct tagGHMR_TEX m_inSideTex, offset 0x28>
	struct tagGHMR_TEX m_inSideTex;

	// <float m_fGroundOfst, offset 0x50>
	float m_fGroundOfst;

	// <float m_fUpWidthHalf, offset 0x54>
	float m_fUpWidthHalf;

	// <float m_fSideWidthHalfMax, offset 0x58>
	float m_fSideWidthHalfMax;

	// <float m_fSideWidthHalfMin, offset 0x5c>
	float m_fSideWidthHalfMin;

	// <float m_fDepthPlus, offset 0x60>
	float m_fDepthPlus;

	// <float m_fDepthMinus, offset 0x64>
	float m_fDepthMinus;

	// <float m_fDepthOfstMax, offset 0x68>
	float m_fDepthOfstMax;

	// <float m_fAlphaMulCoe, offset 0x6c>
	float m_fAlphaMulCoe;

	std::string ToString() const { return "class CObjectShadow(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CObjectShadow>("CObjectShadow")
			.addFunction("__tostring", &CObjectShadow::ToString)
			.addFunction("GetPtrAddr", &CObjectShadow::GetPtrAddr)
			.addProperty("m_inUpTex", &CObjectShadow::m_inUpTex)
			.addProperty("m_inSideTex", &CObjectShadow::m_inSideTex)
			.addProperty("m_fGroundOfst", &CObjectShadow::m_fGroundOfst)
			.addProperty("m_fUpWidthHalf", &CObjectShadow::m_fUpWidthHalf)
			.addProperty("m_fSideWidthHalfMax", &CObjectShadow::m_fSideWidthHalfMax)
			.addProperty("m_fSideWidthHalfMin", &CObjectShadow::m_fSideWidthHalfMin)
			.addProperty("m_fDepthPlus", &CObjectShadow::m_fDepthPlus)
			.addProperty("m_fDepthMinus", &CObjectShadow::m_fDepthMinus)
			.addProperty("m_fDepthOfstMax", &CObjectShadow::m_fDepthOfstMax)
			.addProperty("m_fAlphaMulCoe", &CObjectShadow::m_fAlphaMulCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CObjectShadow::m_inUpTex) == 40, "expected m_inUpTex to be size 40");
static_assert(sizeof(CObjectShadow::m_inSideTex) == 40, "expected m_inSideTex to be size 40");
static_assert(sizeof(CObjectShadow::m_fGroundOfst) == 4, "expected m_fGroundOfst to be size 4");
static_assert(sizeof(CObjectShadow::m_fUpWidthHalf) == 4, "expected m_fUpWidthHalf to be size 4");
static_assert(sizeof(CObjectShadow::m_fSideWidthHalfMax) == 4, "expected m_fSideWidthHalfMax to be size 4");
static_assert(sizeof(CObjectShadow::m_fSideWidthHalfMin) == 4, "expected m_fSideWidthHalfMin to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthPlus) == 4, "expected m_fDepthPlus to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthMinus) == 4, "expected m_fDepthMinus to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthOfstMax) == 4, "expected m_fDepthOfstMax to be size 4");
static_assert(sizeof(CObjectShadow::m_fAlphaMulCoe) == 4, "expected m_fAlphaMulCoe to be size 4");
static_assert(sizeof(CObjectShadow) == 112, "expected class CObjectShadow to be size 112");

// [Structure] struct stBikeEffect
struct stBikeEffect
{
public:
	/// Struct member variables

	// <class EffectDriftMark* pDriftMark, offset 0x0>
	class EffectDriftMark* pDriftMark;

	// <class EffectKeepSmoke* pKeepSmoke, offset 0x4>
	class EffectKeepSmoke* pKeepSmoke;

	// <struct Vec posTireOldL, offset 0x8>
	struct Vec posTireOldL;

	// <struct Vec posTireOldR, offset 0x14>
	struct Vec posTireOldR;

	// <class EffectFixFire* pFixFire[0x2], offset 0x20>
	class EffectFixFire* pFixFire[2];

	std::string ToString() const { return "struct stBikeEffect(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stBikeEffect>("stBikeEffect")
			.addFunction("__tostring", &stBikeEffect::ToString)
			.addFunction("GetPtrAddr", &stBikeEffect::GetPtrAddr)
			.addProperty("pDriftMark", &stBikeEffect::pDriftMark)
			.addProperty("pKeepSmoke", &stBikeEffect::pKeepSmoke)
			.addProperty("posTireOldL", &stBikeEffect::posTireOldL)
			.addProperty("posTireOldR", &stBikeEffect::posTireOldR)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pFixFire", &stBikeEffect::pFixFire)
		.endClass();
	}
#endif
};
static_assert(sizeof(stBikeEffect::pDriftMark) == 4, "expected pDriftMark to be size 4");
static_assert(sizeof(stBikeEffect::pKeepSmoke) == 4, "expected pKeepSmoke to be size 4");
static_assert(sizeof(stBikeEffect::posTireOldL) == 12, "expected posTireOldL to be size 12");
static_assert(sizeof(stBikeEffect::posTireOldR) == 12, "expected posTireOldR to be size 12");
static_assert(sizeof(stBikeEffect::pFixFire) == 8, "expected pFixFire to be size 8");
static_assert(sizeof(stBikeEffect) == 40, "expected struct stBikeEffect to be size 40");

// enum enBikeSpinDir
enum enBikeSpinDir : uint32_t
{
	// <eBikeSpinL = 0x0>
	eBikeSpinL = 0,

	// <eBikeSpinR = 0x1>
	eBikeSpinR = 1,

	// <eBikeSpinMax = 0x2>
	eBikeSpinMax = 2

};

// enum enBikeFallProc
enum enBikeFallProc : uint32_t
{
	// <eBikeFallSetMotel = 0x0>
	eBikeFallSetMotel = 0,

	// <eBikeFallWaitAreaLoad = 0x1>
	eBikeFallWaitAreaLoad = 1,

	// <eBikeFallMax = 0x2>
	eBikeFallMax = 2

};

// enum enBikeProc
enum enBikeProc : uint32_t
{
	// <eBikeStopIdle = 0x0>
	eBikeStopIdle = 0,

	// <eBikeTrvRiding = 0x1>
	eBikeTrvRiding = 1,

	// <eBikeTrvIdle = 0x2>
	eBikeTrvIdle = 2,

	// <eBikeRun = 0x3>
	eBikeRun = 3,

	// <eBikeBack = 0x4>
	eBikeBack = 4,

	// <eBikeQStart = 0x5>
	eBikeQStart = 5,

	// <eBikeQStartWait = 0x6>
	eBikeQStartWait = 6,

	// <eBikeQBreak = 0x7>
	eBikeQBreak = 7,

	// <eBikeSpin = 0x8>
	eBikeSpin = 8,

	// <eBikeClash = 0x9>
	eBikeClash = 9,

	// <eBikePcClash2Stand = 0xa>
	eBikePcClash2Stand = 10,

	// <eBikeClash2Stand = 0xb>
	eBikeClash2Stand = 11,

	// <eBikeWaitStand = 0xc>
	eBikeWaitStand = 12,

	// <eBikeTrvGetOff = 0xd>
	eBikeTrvGetOff = 13,

	// <eBikeDamege = 0xe>
	eBikeDamege = 14,

	// <eBikeDead = 0xf>
	eBikeDead = 15,

	// <eBikeAccel = 0x10>
	eBikeAccel = 16,

	// <eBikeFall = 0x11>
	eBikeFall = 17,

	// <eBikeWaitSetMotel = 0x12>
	eBikeWaitSetMotel = 18,

	// <eBikeMax = 0x13>
	eBikeMax = 19

};

// [Structure] struct stBike
struct stBike
{
public:
	/// Struct member variables

	// <class TGmf* pGmf, offset 0x0>
	class TGmf* pGmf;

	// <class TGan** pGan, offset 0x4>
	class TGan** pGan;

	// <enum enBikeProc process, offset 0x8>
	enum enBikeProc process;

	// <enum enBikeFallProc fallProcess, offset 0xc>
	enum enBikeFallProc fallProcess;

	// <int32_t motionNo, offset 0x10>
	int32_t motionNo;

	// <int32_t motionNumMax, offset 0x14>
	int32_t motionNumMax;

	// <int32_t motionBrendNum, offset 0x18>
	int32_t motionBrendNum;

	// <int32_t restoreMotionNo, offset 0x1c>
	int32_t restoreMotionNo;

	// <float rotPerf, offset 0x20>
	float rotPerf;

	// <float spdU, offset 0x24>
	float spdU;

	// <float spdV, offset 0x28>
	float spdV;

	// <float angSpd, offset 0x2c>
	float angSpd;

	// <float prevAngSpd, offset 0x30>
	float prevAngSpd;

	// <float forceU, offset 0x34>
	float forceU;

	// <float forceV, offset 0x38>
	float forceV;

	// <int32_t gripState, offset 0x3c>
	int32_t gripState;

	// <int32_t timerSlipTrigger, offset 0x40>
	int32_t timerSlipTrigger;

	// <int32_t timerMaxSlipTrigger, offset 0x44>
	int32_t timerMaxSlipTrigger;

	// <float slipRate, offset 0x48>
	float slipRate;

	// <float slipAngle, offset 0x4c>
	float slipAngle;

	// <float accelRate, offset 0x50>
	float accelRate;

	// <float brakeRate, offset 0x54>
	float brakeRate;

	// <float rudderAng, offset 0x58>
	float rudderAng;

	// <float length, offset 0x5c>
	float length;

	// <int32_t hitTame, offset 0x60>
	int32_t hitTame;

	// <struct Vec externForce, offset 0x64>
	struct Vec externForce;

	// <float posYF, offset 0x70>
	float posYF;

	// <float posYB, offset 0x74>
	float posYB;

	// <struct Vec pos, offset 0x78>
	struct Vec pos;

	// <struct Vec beforePos, offset 0x84>
	struct Vec beforePos;

	// <struct Vec beforePosF, offset 0x90>
	struct Vec beforePosF;

	// <struct Vec beforePosB, offset 0x9c>
	struct Vec beforePosB;

	// <struct Vec moveTempPos, offset 0xa8>
	struct Vec moveTempPos;

	// <struct Vec moveTempPosF, offset 0xb4>
	struct Vec moveTempPosF;

	// <struct Vec moveTempPosB, offset 0xc0>
	struct Vec moveTempPosB;

	// <struct Vec rot, offset 0xcc>
	struct Vec rot;

	// <struct Vec oldRot, offset 0xd8>
	struct Vec oldRot;

	// <float oldPosY, offset 0xe4>
	float oldPosY;

	// <float oldPosYF, offset 0xe8>
	float oldPosYF;

	// <float oldPosYB, offset 0xec>
	float oldPosYB;

	// <float adjustRotY, offset 0xf0>
	float adjustRotY;

	// <uint8_t hitCheck, offset 0xf4>
	uint8_t hitCheck;

	// <uint8_t clash, offset 0xf5>
	uint8_t clash;

	// <uint8_t hitWall, offset 0xf6>
	uint8_t hitWall;

	// <uint8_t hitWall4Spin, offset 0xf7>
	uint8_t hitWall4Spin;

	// <uint8_t alwaysCheckHitColl, offset 0xf8>
	uint8_t alwaysCheckHitColl;

	// <Unidentified data segment, offset 0xf9>
private:
	char _UnidentifiedData46[3];

public:
	// <int32_t hp, offset 0xfc>
	int32_t hp;

	// <int32_t bgmHdl, offset 0x100>
	int32_t bgmHdl;

	// <int32_t seHndlEngine, offset 0x104>
	int32_t seHndlEngine;

	// <int32_t seHndlEngineNeutral, offset 0x108>
	int32_t seHndlEngineNeutral;

	// <int32_t seHndlBreak, offset 0x10c>
	int32_t seHndlBreak;

	// <int32_t seHndlQBreak, offset 0x110>
	int32_t seHndlQBreak;

	// <int32_t seHndlAir, offset 0x114>
	int32_t seHndlAir;

	// <int32_t seHndlNitro, offset 0x118>
	int32_t seHndlNitro;

	// <int32_t seHndSqueal, offset 0x11c>
	int32_t seHndSqueal;

	// <float seVolEngine, offset 0x120>
	float seVolEngine;

	// <float seVolEngineNeutral, offset 0x124>
	float seVolEngineNeutral;

	// <float seVolBreak, offset 0x128>
	float seVolBreak;

	// <float seVolQBreak, offset 0x12c>
	float seVolQBreak;

	// <float seVolAir, offset 0x130>
	float seVolAir;

	// <float seVolNitro, offset 0x134>
	float seVolNitro;

	// <float seVolSqueal, offset 0x138>
	float seVolSqueal;

	// <int32_t command, offset 0x13c>
	int32_t command;

	// <float acc, offset 0x140>
	float acc;

	// <uint8_t useNitro, offset 0x144>
	uint8_t useNitro;

	// <Unidentified data segment, offset 0x145>
private:
	char _UnidentifiedData65[3];

public:
	// <float nitro, offset 0x148>
	float nitro;

	// <int32_t nitroStopTick, offset 0x14c>
	int32_t nitroStopTick;

	// <float turnVal, offset 0x150>
	float turnVal;

	// <float rimTurnVal, offset 0x154>
	float rimTurnVal;

	// <float qBreakRotY, offset 0x158>
	float qBreakRotY;

	// <enum enBikeSpinDir spinDir, offset 0x15c>
	enum enBikeSpinDir spinDir;

	// <float spinY, offset 0x160>
	float spinY;

	// <uint8_t wiry, offset 0x164>
	uint8_t wiry;

	// <uint8_t clashMySelf, offset 0x165>
	uint8_t clashMySelf;

	// <uint8_t battle, offset 0x166>
	uint8_t battle;

	// <uint8_t rideOnStart, offset 0x167>
	uint8_t rideOnStart;

	// <uint8_t initHitJudge, offset 0x168>
	uint8_t initHitJudge;

	// <uint8_t pushAcceling, offset 0x169>
	uint8_t pushAcceling;

	// <uint8_t pushBreaking, offset 0x16a>
	uint8_t pushBreaking;

	// <uint8_t cantRideOn, offset 0x16b>
	uint8_t cantRideOn;

	// <uint8_t cantGetOff, offset 0x16c>
	uint8_t cantGetOff;

	// <uint8_t cantHandling, offset 0x16d>
	uint8_t cantHandling;

	// <uint8_t dispCantGetOff, offset 0x16e>
	uint8_t dispCantGetOff;

	// <uint8_t crash2Stand, offset 0x16f>
	uint8_t crash2Stand;

	// <uint8_t changeVolEngine, offset 0x170>
	uint8_t changeVolEngine;

	// <uint8_t changeVolEngineIdle, offset 0x171>
	uint8_t changeVolEngineIdle;

	// <Unidentified data segment, offset 0x172>
private:
	char _UnidentifiedData86[2];

public:
	// <int32_t startWait, offset 0x174>
	int32_t startWait;

	// <float rateTbl[0x3], offset 0x178>
	float rateTbl[3];

	// <class WAnimF inputRelay, offset 0x184>
	class WAnimF inputRelay;

	// <class ghmGcCollObjCapsule hitColl, offset 0x1a4>
	class ghmGcCollObjCapsule hitColl;

	// <class ghmGcCollObjCapsule rideColl, offset 0x204>
	class ghmGcCollObjCapsule rideColl;

	// <class ghmGcCollObjCapsule hitStgColl, offset 0x264>
	class ghmGcCollObjCapsule hitStgColl;

	// <class ghmGcCollObjCapsule hitStgCollF, offset 0x2c4>
	class ghmGcCollObjCapsule hitStgCollF;

	// <class ghmGcCollObjCapsule hitStgCollB, offset 0x324>
	class ghmGcCollObjCapsule hitStgCollB;

	// <class ghmGcCollObj* footHitResultObj, offset 0x384>
	class ghmGcCollObj* footHitResultObj;

	// <class ghmGcCollObjHitResult* footHitResult, offset 0x388>
	class ghmGcCollObjHitResult* footHitResult;

	// <class ghmGcCollObjHitResultObj footHitResultObj2, offset 0x38c>
	class ghmGcCollObjHitResultObj footHitResultObj2;

	// <class EventAreaCircle* pEvIcn, offset 0x3d8>
	class EventAreaCircle* pEvIcn;

	// <struct tagGHMR_TEX texSpeed, offset 0x3dc>
	struct tagGHMR_TEX texSpeed;

	// <class WAnimF cameraLength, offset 0x404>
	class WAnimF cameraLength;

	// <class WAnimF cameraAngle, offset 0x424>
	class WAnimF cameraAngle;

	// <float rotZ, offset 0x444>
	float rotZ;

	// <uint8_t forceHitStage, offset 0x448>
	uint8_t forceHitStage;

	// <uint8_t crashFlag, offset 0x449>
	uint8_t crashFlag;

	// <Unidentified data segment, offset 0x44a>
private:
	char _UnidentifiedData104[2];

public:
	// <int32_t damageCount, offset 0x44c>
	int32_t damageCount;

	// <class WAnimF prj, offset 0x450>
	class WAnimF prj;

	// <class WAnimF modelAlpha, offset 0x470>
	class WAnimF modelAlpha;

	// <class CAmbientShadow m_inAmbientShadow, offset 0x490>
	class CAmbientShadow m_inAmbientShadow;

	// <uint8_t muteSe, offset 0x4c8>
	uint8_t muteSe;

	// <Unidentified data segment, offset 0x4c9>
private:
	char _UnidentifiedData109[3];

public:
	// <int32_t seLoadNoiseNo, offset 0x4cc>
	int32_t seLoadNoiseNo;

	// <int32_t seLoadNoiseHandle, offset 0x4d0>
	int32_t seLoadNoiseHandle;

	// <float seLoadNoisePitch, offset 0x4d4>
	float seLoadNoisePitch;

	// <float seLoadNoiseVolume, offset 0x4d8>
	float seLoadNoiseVolume;

	std::string ToString() const { return "struct stBike(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stBike>("stBike")
			.addFunction("__tostring", &stBike::ToString)
			.addFunction("GetPtrAddr", &stBike::GetPtrAddr)
			.addProperty("pGmf", &stBike::pGmf)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("pGan", &stBike::pGan)
			.addProperty("process", &stBike::process)
			.addProperty("fallProcess", &stBike::fallProcess)
			.addProperty("motionNo", &stBike::motionNo)
			.addProperty("motionNumMax", &stBike::motionNumMax)
			.addProperty("motionBrendNum", &stBike::motionBrendNum)
			.addProperty("restoreMotionNo", &stBike::restoreMotionNo)
			.addProperty("rotPerf", &stBike::rotPerf)
			.addProperty("spdU", &stBike::spdU)
			.addProperty("spdV", &stBike::spdV)
			.addProperty("angSpd", &stBike::angSpd)
			.addProperty("prevAngSpd", &stBike::prevAngSpd)
			.addProperty("forceU", &stBike::forceU)
			.addProperty("forceV", &stBike::forceV)
			.addProperty("gripState", &stBike::gripState)
			.addProperty("timerSlipTrigger", &stBike::timerSlipTrigger)
			.addProperty("timerMaxSlipTrigger", &stBike::timerMaxSlipTrigger)
			.addProperty("slipRate", &stBike::slipRate)
			.addProperty("slipAngle", &stBike::slipAngle)
			.addProperty("accelRate", &stBike::accelRate)
			.addProperty("brakeRate", &stBike::brakeRate)
			.addProperty("rudderAng", &stBike::rudderAng)
			.addProperty("length", &stBike::length)
			.addProperty("hitTame", &stBike::hitTame)
			.addProperty("externForce", &stBike::externForce)
			.addProperty("posYF", &stBike::posYF)
			.addProperty("posYB", &stBike::posYB)
			.addProperty("pos", &stBike::pos)
			.addProperty("beforePos", &stBike::beforePos)
			.addProperty("beforePosF", &stBike::beforePosF)
			.addProperty("beforePosB", &stBike::beforePosB)
			.addProperty("moveTempPos", &stBike::moveTempPos)
			.addProperty("moveTempPosF", &stBike::moveTempPosF)
			.addProperty("moveTempPosB", &stBike::moveTempPosB)
			.addProperty("rot", &stBike::rot)
			.addProperty("oldRot", &stBike::oldRot)
			.addProperty("oldPosY", &stBike::oldPosY)
			.addProperty("oldPosYF", &stBike::oldPosYF)
			.addProperty("oldPosYB", &stBike::oldPosYB)
			.addProperty("adjustRotY", &stBike::adjustRotY)
			.addProperty("hitCheck", &stBike::hitCheck)
			.addProperty("clash", &stBike::clash)
			.addProperty("hitWall", &stBike::hitWall)
			.addProperty("hitWall4Spin", &stBike::hitWall4Spin)
			.addProperty("alwaysCheckHitColl", &stBike::alwaysCheckHitColl)
			.addProperty("hp", &stBike::hp)
			.addProperty("bgmHdl", &stBike::bgmHdl)
			.addProperty("seHndlEngine", &stBike::seHndlEngine)
			.addProperty("seHndlEngineNeutral", &stBike::seHndlEngineNeutral)
			.addProperty("seHndlBreak", &stBike::seHndlBreak)
			.addProperty("seHndlQBreak", &stBike::seHndlQBreak)
			.addProperty("seHndlAir", &stBike::seHndlAir)
			.addProperty("seHndlNitro", &stBike::seHndlNitro)
			.addProperty("seHndSqueal", &stBike::seHndSqueal)
			.addProperty("seVolEngine", &stBike::seVolEngine)
			.addProperty("seVolEngineNeutral", &stBike::seVolEngineNeutral)
			.addProperty("seVolBreak", &stBike::seVolBreak)
			.addProperty("seVolQBreak", &stBike::seVolQBreak)
			.addProperty("seVolAir", &stBike::seVolAir)
			.addProperty("seVolNitro", &stBike::seVolNitro)
			.addProperty("seVolSqueal", &stBike::seVolSqueal)
			.addProperty("command", &stBike::command)
			.addProperty("acc", &stBike::acc)
			.addProperty("useNitro", &stBike::useNitro)
			.addProperty("nitro", &stBike::nitro)
			.addProperty("nitroStopTick", &stBike::nitroStopTick)
			.addProperty("turnVal", &stBike::turnVal)
			.addProperty("rimTurnVal", &stBike::rimTurnVal)
			.addProperty("qBreakRotY", &stBike::qBreakRotY)
			.addProperty("spinDir", &stBike::spinDir)
			.addProperty("spinY", &stBike::spinY)
			.addProperty("wiry", &stBike::wiry)
			.addProperty("clashMySelf", &stBike::clashMySelf)
			.addProperty("battle", &stBike::battle)
			.addProperty("rideOnStart", &stBike::rideOnStart)
			.addProperty("initHitJudge", &stBike::initHitJudge)
			.addProperty("pushAcceling", &stBike::pushAcceling)
			.addProperty("pushBreaking", &stBike::pushBreaking)
			.addProperty("cantRideOn", &stBike::cantRideOn)
			.addProperty("cantGetOff", &stBike::cantGetOff)
			.addProperty("cantHandling", &stBike::cantHandling)
			.addProperty("dispCantGetOff", &stBike::dispCantGetOff)
			.addProperty("crash2Stand", &stBike::crash2Stand)
			.addProperty("changeVolEngine", &stBike::changeVolEngine)
			.addProperty("changeVolEngineIdle", &stBike::changeVolEngineIdle)
			.addProperty("startWait", &stBike::startWait)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("rateTbl", &stBike::rateTbl)
			.addProperty("inputRelay", &stBike::inputRelay)
			.addProperty("hitColl", &stBike::hitColl)
			.addProperty("rideColl", &stBike::rideColl)
			.addProperty("hitStgColl", &stBike::hitStgColl)
			.addProperty("hitStgCollF", &stBike::hitStgCollF)
			.addProperty("hitStgCollB", &stBike::hitStgCollB)
			.addProperty("footHitResultObj", &stBike::footHitResultObj)
			.addProperty("footHitResult", &stBike::footHitResult)
			.addProperty("footHitResultObj2", &stBike::footHitResultObj2)
			.addProperty("pEvIcn", &stBike::pEvIcn)
			.addProperty("texSpeed", &stBike::texSpeed)
			.addProperty("cameraLength", &stBike::cameraLength)
			.addProperty("cameraAngle", &stBike::cameraAngle)
			.addProperty("rotZ", &stBike::rotZ)
			.addProperty("forceHitStage", &stBike::forceHitStage)
			.addProperty("crashFlag", &stBike::crashFlag)
			.addProperty("damageCount", &stBike::damageCount)
			.addProperty("prj", &stBike::prj)
			.addProperty("modelAlpha", &stBike::modelAlpha)
			.addProperty("m_inAmbientShadow", &stBike::m_inAmbientShadow)
			.addProperty("muteSe", &stBike::muteSe)
			.addProperty("seLoadNoiseNo", &stBike::seLoadNoiseNo)
			.addProperty("seLoadNoiseHandle", &stBike::seLoadNoiseHandle)
			.addProperty("seLoadNoisePitch", &stBike::seLoadNoisePitch)
			.addProperty("seLoadNoiseVolume", &stBike::seLoadNoiseVolume)
		.endClass();
	}
#endif
};
static_assert(sizeof(stBike::pGmf) == 4, "expected pGmf to be size 4");
static_assert(sizeof(stBike::pGan) == 4, "expected pGan to be size 4");
static_assert(sizeof(stBike::process) == 4, "expected process to be size 4");
static_assert(sizeof(stBike::fallProcess) == 4, "expected fallProcess to be size 4");
static_assert(sizeof(stBike::motionNo) == 4, "expected motionNo to be size 4");
static_assert(sizeof(stBike::motionNumMax) == 4, "expected motionNumMax to be size 4");
static_assert(sizeof(stBike::motionBrendNum) == 4, "expected motionBrendNum to be size 4");
static_assert(sizeof(stBike::restoreMotionNo) == 4, "expected restoreMotionNo to be size 4");
static_assert(sizeof(stBike::rotPerf) == 4, "expected rotPerf to be size 4");
static_assert(sizeof(stBike::spdU) == 4, "expected spdU to be size 4");
static_assert(sizeof(stBike::spdV) == 4, "expected spdV to be size 4");
static_assert(sizeof(stBike::angSpd) == 4, "expected angSpd to be size 4");
static_assert(sizeof(stBike::prevAngSpd) == 4, "expected prevAngSpd to be size 4");
static_assert(sizeof(stBike::forceU) == 4, "expected forceU to be size 4");
static_assert(sizeof(stBike::forceV) == 4, "expected forceV to be size 4");
static_assert(sizeof(stBike::gripState) == 4, "expected gripState to be size 4");
static_assert(sizeof(stBike::timerSlipTrigger) == 4, "expected timerSlipTrigger to be size 4");
static_assert(sizeof(stBike::timerMaxSlipTrigger) == 4, "expected timerMaxSlipTrigger to be size 4");
static_assert(sizeof(stBike::slipRate) == 4, "expected slipRate to be size 4");
static_assert(sizeof(stBike::slipAngle) == 4, "expected slipAngle to be size 4");
static_assert(sizeof(stBike::accelRate) == 4, "expected accelRate to be size 4");
static_assert(sizeof(stBike::brakeRate) == 4, "expected brakeRate to be size 4");
static_assert(sizeof(stBike::rudderAng) == 4, "expected rudderAng to be size 4");
static_assert(sizeof(stBike::length) == 4, "expected length to be size 4");
static_assert(sizeof(stBike::hitTame) == 4, "expected hitTame to be size 4");
static_assert(sizeof(stBike::externForce) == 12, "expected externForce to be size 12");
static_assert(sizeof(stBike::posYF) == 4, "expected posYF to be size 4");
static_assert(sizeof(stBike::posYB) == 4, "expected posYB to be size 4");
static_assert(sizeof(stBike::pos) == 12, "expected pos to be size 12");
static_assert(sizeof(stBike::beforePos) == 12, "expected beforePos to be size 12");
static_assert(sizeof(stBike::beforePosF) == 12, "expected beforePosF to be size 12");
static_assert(sizeof(stBike::beforePosB) == 12, "expected beforePosB to be size 12");
static_assert(sizeof(stBike::moveTempPos) == 12, "expected moveTempPos to be size 12");
static_assert(sizeof(stBike::moveTempPosF) == 12, "expected moveTempPosF to be size 12");
static_assert(sizeof(stBike::moveTempPosB) == 12, "expected moveTempPosB to be size 12");
static_assert(sizeof(stBike::rot) == 12, "expected rot to be size 12");
static_assert(sizeof(stBike::oldRot) == 12, "expected oldRot to be size 12");
static_assert(sizeof(stBike::oldPosY) == 4, "expected oldPosY to be size 4");
static_assert(sizeof(stBike::oldPosYF) == 4, "expected oldPosYF to be size 4");
static_assert(sizeof(stBike::oldPosYB) == 4, "expected oldPosYB to be size 4");
static_assert(sizeof(stBike::adjustRotY) == 4, "expected adjustRotY to be size 4");
static_assert(sizeof(stBike::hitCheck) == 1, "expected hitCheck to be size 1");
static_assert(sizeof(stBike::clash) == 1, "expected clash to be size 1");
static_assert(sizeof(stBike::hitWall) == 1, "expected hitWall to be size 1");
static_assert(sizeof(stBike::hitWall4Spin) == 1, "expected hitWall4Spin to be size 1");
static_assert(sizeof(stBike::alwaysCheckHitColl) == 1, "expected alwaysCheckHitColl to be size 1");
static_assert(sizeof(stBike::hp) == 4, "expected hp to be size 4");
static_assert(sizeof(stBike::bgmHdl) == 4, "expected bgmHdl to be size 4");
static_assert(sizeof(stBike::seHndlEngine) == 4, "expected seHndlEngine to be size 4");
static_assert(sizeof(stBike::seHndlEngineNeutral) == 4, "expected seHndlEngineNeutral to be size 4");
static_assert(sizeof(stBike::seHndlBreak) == 4, "expected seHndlBreak to be size 4");
static_assert(sizeof(stBike::seHndlQBreak) == 4, "expected seHndlQBreak to be size 4");
static_assert(sizeof(stBike::seHndlAir) == 4, "expected seHndlAir to be size 4");
static_assert(sizeof(stBike::seHndlNitro) == 4, "expected seHndlNitro to be size 4");
static_assert(sizeof(stBike::seHndSqueal) == 4, "expected seHndSqueal to be size 4");
static_assert(sizeof(stBike::seVolEngine) == 4, "expected seVolEngine to be size 4");
static_assert(sizeof(stBike::seVolEngineNeutral) == 4, "expected seVolEngineNeutral to be size 4");
static_assert(sizeof(stBike::seVolBreak) == 4, "expected seVolBreak to be size 4");
static_assert(sizeof(stBike::seVolQBreak) == 4, "expected seVolQBreak to be size 4");
static_assert(sizeof(stBike::seVolAir) == 4, "expected seVolAir to be size 4");
static_assert(sizeof(stBike::seVolNitro) == 4, "expected seVolNitro to be size 4");
static_assert(sizeof(stBike::seVolSqueal) == 4, "expected seVolSqueal to be size 4");
static_assert(sizeof(stBike::command) == 4, "expected command to be size 4");
static_assert(sizeof(stBike::acc) == 4, "expected acc to be size 4");
static_assert(sizeof(stBike::useNitro) == 1, "expected useNitro to be size 1");
static_assert(sizeof(stBike::nitro) == 4, "expected nitro to be size 4");
static_assert(sizeof(stBike::nitroStopTick) == 4, "expected nitroStopTick to be size 4");
static_assert(sizeof(stBike::turnVal) == 4, "expected turnVal to be size 4");
static_assert(sizeof(stBike::rimTurnVal) == 4, "expected rimTurnVal to be size 4");
static_assert(sizeof(stBike::qBreakRotY) == 4, "expected qBreakRotY to be size 4");
static_assert(sizeof(stBike::spinDir) == 4, "expected spinDir to be size 4");
static_assert(sizeof(stBike::spinY) == 4, "expected spinY to be size 4");
static_assert(sizeof(stBike::wiry) == 1, "expected wiry to be size 1");
static_assert(sizeof(stBike::clashMySelf) == 1, "expected clashMySelf to be size 1");
static_assert(sizeof(stBike::battle) == 1, "expected battle to be size 1");
static_assert(sizeof(stBike::rideOnStart) == 1, "expected rideOnStart to be size 1");
static_assert(sizeof(stBike::initHitJudge) == 1, "expected initHitJudge to be size 1");
static_assert(sizeof(stBike::pushAcceling) == 1, "expected pushAcceling to be size 1");
static_assert(sizeof(stBike::pushBreaking) == 1, "expected pushBreaking to be size 1");
static_assert(sizeof(stBike::cantRideOn) == 1, "expected cantRideOn to be size 1");
static_assert(sizeof(stBike::cantGetOff) == 1, "expected cantGetOff to be size 1");
static_assert(sizeof(stBike::cantHandling) == 1, "expected cantHandling to be size 1");
static_assert(sizeof(stBike::dispCantGetOff) == 1, "expected dispCantGetOff to be size 1");
static_assert(sizeof(stBike::crash2Stand) == 1, "expected crash2Stand to be size 1");
static_assert(sizeof(stBike::changeVolEngine) == 1, "expected changeVolEngine to be size 1");
static_assert(sizeof(stBike::changeVolEngineIdle) == 1, "expected changeVolEngineIdle to be size 1");
static_assert(sizeof(stBike::startWait) == 4, "expected startWait to be size 4");
static_assert(sizeof(stBike::rateTbl) == 12, "expected rateTbl to be size 12");
static_assert(sizeof(stBike::inputRelay) == 32, "expected inputRelay to be size 32");
static_assert(sizeof(stBike::hitColl) == 96, "expected hitColl to be size 96");
static_assert(sizeof(stBike::rideColl) == 96, "expected rideColl to be size 96");
static_assert(sizeof(stBike::hitStgColl) == 96, "expected hitStgColl to be size 96");
static_assert(sizeof(stBike::hitStgCollF) == 96, "expected hitStgCollF to be size 96");
static_assert(sizeof(stBike::hitStgCollB) == 96, "expected hitStgCollB to be size 96");
static_assert(sizeof(stBike::footHitResultObj) == 4, "expected footHitResultObj to be size 4");
static_assert(sizeof(stBike::footHitResult) == 4, "expected footHitResult to be size 4");
static_assert(sizeof(stBike::footHitResultObj2) == 76, "expected footHitResultObj2 to be size 76");
static_assert(sizeof(stBike::pEvIcn) == 4, "expected pEvIcn to be size 4");
static_assert(sizeof(stBike::texSpeed) == 40, "expected texSpeed to be size 40");
static_assert(sizeof(stBike::cameraLength) == 32, "expected cameraLength to be size 32");
static_assert(sizeof(stBike::cameraAngle) == 32, "expected cameraAngle to be size 32");
static_assert(sizeof(stBike::rotZ) == 4, "expected rotZ to be size 4");
static_assert(sizeof(stBike::forceHitStage) == 1, "expected forceHitStage to be size 1");
static_assert(sizeof(stBike::crashFlag) == 1, "expected crashFlag to be size 1");
static_assert(sizeof(stBike::damageCount) == 4, "expected damageCount to be size 4");
static_assert(sizeof(stBike::prj) == 32, "expected prj to be size 32");
static_assert(sizeof(stBike::modelAlpha) == 32, "expected modelAlpha to be size 32");
static_assert(sizeof(stBike::m_inAmbientShadow) == 56, "expected m_inAmbientShadow to be size 56");
static_assert(sizeof(stBike::muteSe) == 1, "expected muteSe to be size 1");
static_assert(sizeof(stBike::seLoadNoiseNo) == 4, "expected seLoadNoiseNo to be size 4");
static_assert(sizeof(stBike::seLoadNoiseHandle) == 4, "expected seLoadNoiseHandle to be size 4");
static_assert(sizeof(stBike::seLoadNoisePitch) == 4, "expected seLoadNoisePitch to be size 4");
static_assert(sizeof(stBike::seLoadNoiseVolume) == 4, "expected seLoadNoiseVolume to be size 4");
static_assert(sizeof(stBike) == 1244, "expected struct stBike to be size 1244");

// [Structure] class mHRBike
class mHRBike
{
public:
	/// Struct member variables

	// <struct stBike mBike, offset 0x0>
	struct stBike mBike;

	// <struct stBikeEffect mBikeEffect, offset 0x4dc>
	struct stBikeEffect mBikeEffect;

	// <uint8_t mhitStage, offset 0x504>
	uint8_t mhitStage;

	// <Unidentified data segment, offset 0x505>
private:
	char _UnidentifiedData3[3];

public:
	// <float mWryRate, offset 0x508>
	float mWryRate;

	// <float mBankRate, offset 0x50c>
	float mBankRate;

	// <struct Vec mDamegeDir, offset 0x510>
	struct Vec mDamegeDir;

	// <float mDamegeRotY, offset 0x51c>
	float mDamegeRotY;

	// <float mAccel, offset 0x520>
	float mAccel;

	// <struct Vec mPassRot, offset 0x524>
	struct Vec mPassRot;

	// <int32_t mFireSEID, offset 0x530>
	int32_t mFireSEID;

	// <float mHitWait, offset 0x534>
	float mHitWait;

	// <uint8_t mRotLock, offset 0x538>
	uint8_t mRotLock;

	// <uint8_t mBkAtkOk, offset 0x539>
	uint8_t mBkAtkOk;

	// <uint8_t m_bIsDrawShadow, offset 0x53a>
	uint8_t m_bIsDrawShadow;

	// <uint8_t m_boForceDisableDrawShadow, offset 0x53b>
	uint8_t m_boForceDisableDrawShadow;

	// <class CObjectShadow m_inObjectShadow, offset 0x53c>
	class CObjectShadow m_inObjectShadow;

	std::string ToString() const { return "class mHRBike(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRBike>("mHRBike")
			.addFunction("__tostring", &mHRBike::ToString)
			.addFunction("GetPtrAddr", &mHRBike::GetPtrAddr)
			.addProperty("mBike", &mHRBike::mBike)
			.addProperty("mBikeEffect", &mHRBike::mBikeEffect)
			.addProperty("mhitStage", &mHRBike::mhitStage)
			.addProperty("mWryRate", &mHRBike::mWryRate)
			.addProperty("mBankRate", &mHRBike::mBankRate)
			.addProperty("mDamegeDir", &mHRBike::mDamegeDir)
			.addProperty("mDamegeRotY", &mHRBike::mDamegeRotY)
			.addProperty("mAccel", &mHRBike::mAccel)
			.addProperty("mPassRot", &mHRBike::mPassRot)
			.addProperty("mFireSEID", &mHRBike::mFireSEID)
			.addProperty("mHitWait", &mHRBike::mHitWait)
			.addProperty("mRotLock", &mHRBike::mRotLock)
			.addProperty("mBkAtkOk", &mHRBike::mBkAtkOk)
			.addProperty("m_bIsDrawShadow", &mHRBike::m_bIsDrawShadow)
			.addProperty("m_boForceDisableDrawShadow", &mHRBike::m_boForceDisableDrawShadow)
			.addProperty("m_inObjectShadow", &mHRBike::m_inObjectShadow)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRBike::mBike) == 1244, "expected mBike to be size 1244");
static_assert(sizeof(mHRBike::mBikeEffect) == 40, "expected mBikeEffect to be size 40");
static_assert(sizeof(mHRBike::mhitStage) == 1, "expected mhitStage to be size 1");
static_assert(sizeof(mHRBike::mWryRate) == 4, "expected mWryRate to be size 4");
static_assert(sizeof(mHRBike::mBankRate) == 4, "expected mBankRate to be size 4");
static_assert(sizeof(mHRBike::mDamegeDir) == 12, "expected mDamegeDir to be size 12");
static_assert(sizeof(mHRBike::mDamegeRotY) == 4, "expected mDamegeRotY to be size 4");
static_assert(sizeof(mHRBike::mAccel) == 4, "expected mAccel to be size 4");
static_assert(sizeof(mHRBike::mPassRot) == 12, "expected mPassRot to be size 12");
static_assert(sizeof(mHRBike::mFireSEID) == 4, "expected mFireSEID to be size 4");
static_assert(sizeof(mHRBike::mHitWait) == 4, "expected mHitWait to be size 4");
static_assert(sizeof(mHRBike::mRotLock) == 1, "expected mRotLock to be size 1");
static_assert(sizeof(mHRBike::mBkAtkOk) == 1, "expected mBkAtkOk to be size 1");
static_assert(sizeof(mHRBike::m_bIsDrawShadow) == 1, "expected m_bIsDrawShadow to be size 1");
static_assert(sizeof(mHRBike::m_boForceDisableDrawShadow) == 1, "expected m_boForceDisableDrawShadow to be size 1");
static_assert(sizeof(mHRBike::m_inObjectShadow) == 112, "expected m_inObjectShadow to be size 112");
static_assert(sizeof(mHRBike) == 1452, "expected class mHRBike to be size 1452");

// [Structure] class EventAreaCircle
class EventAreaCircle : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <int32_t m_Kind, offset 0x10>
	int32_t m_Kind;

	// <struct Vec m_Center, offset 0x14>
	struct Vec m_Center;

	// <float m_sRadius, offset 0x20>
	float m_sRadius;

	// <float m_Rot, offset 0x24>
	float m_Rot;

	// <float m_Scale, offset 0x28>
	float m_Scale;

	// <float m_ScaleHoshi, offset 0x2c>
	float m_ScaleHoshi;

	// <float m_MinScale, offset 0x30>
	float m_MinScale;

	// <float m_MaxScale, offset 0x34>
	float m_MaxScale;

	// <int32_t m_Alpha, offset 0x38>
	int32_t m_Alpha;

	// <uint8_t m_Done, offset 0x3c>
	uint8_t m_Done;

	// <uint8_t m_PcPlayMotionDone, offset 0x3d>
	uint8_t m_PcPlayMotionDone;

	// <uint8_t m_PcMoveDone, offset 0x3e>
	uint8_t m_PcMoveDone;

	// <uint8_t m_firsttouch, offset 0x3f>
	uint8_t m_firsttouch;

	// <uint8_t m_nowtouch, offset 0x40>
	uint8_t m_nowtouch;

	// <char m_EventName[0x20], offset 0x41>
	char m_EventName[32];

	// <char m_StageName[0x10], offset 0x61>
	char m_StageName[16];

	// <Unidentified data segment, offset 0x71>
private:
	char _UnidentifiedData17[3];

public:
	// <uint32_t m_HrScriptHandle, offset 0x74>
	uint32_t m_HrScriptHandle;

	// <uint8_t m_PlayBossCornMotionFlag, offset 0x78>
	uint8_t m_PlayBossCornMotionFlag;

	// <Unidentified data segment, offset 0x79>
private:
	char _UnidentifiedData19[3];

public:
	// <class TGmf* m_pCornGmf, offset 0x7c>
	class TGmf* m_pCornGmf;

	// <class TGmf* m_pCornSleepGmf, offset 0x80>
	class TGmf* m_pCornSleepGmf;

	// <class TGmf* m_pCornShadowGmf, offset 0x84>
	class TGmf* m_pCornShadowGmf;

	// <int32_t m_pCornShadowGanNum, offset 0x88>
	int32_t m_pCornShadowGanNum;

	// <class TGan** m_pCornShadowGan, offset 0x8c>
	class TGan** m_pCornShadowGan;

	// <uint8_t m_PlaySe[0x2], offset 0x90>
	uint8_t m_PlaySe[2];

	// <Unidentified data segment, offset 0x92>
private:
	char _UnidentifiedData25[2];

public:
	// <int32_t m_MakerType, offset 0x94>
	int32_t m_MakerType;

	// <int32_t m_SignboardType, offset 0x98>
	int32_t m_SignboardType;

	// <int32_t m_Sleep, offset 0x9c>
	int32_t m_Sleep;

	// <int32_t m_SleepAlpha, offset 0xa0>
	int32_t m_SleepAlpha;

	// <int32_t m_SleepTick, offset 0xa4>
	int32_t m_SleepTick;

	// <uint8_t m_WakeUpCameraEffect, offset 0xa8>
	uint8_t m_WakeUpCameraEffect;

	// <uint8_t m_Visible, offset 0xa9>
	uint8_t m_Visible;

	// <Unidentified data segment, offset 0xaa>
private:
	char _UnidentifiedData32[2];

public:
	// <int32_t m_SleepMessage, offset 0xac>
	int32_t m_SleepMessage;

	// <int32_t m_SleepMessageProc, offset 0xb0>
	int32_t m_SleepMessageProc;

	// <int32_t mBackDispStatusDisEnable, offset 0xb4>
	int32_t mBackDispStatusDisEnable;

	// <int32_t m_EventRunEffectProcess, offset 0xb8>
	int32_t m_EventRunEffectProcess;

	// <int32_t m_EventRunEffectBit, offset 0xbc>
	int32_t m_EventRunEffectBit;

	// <uint8_t m_CameraOff, offset 0xc0>
	uint8_t m_CameraOff;

	// <uint8_t mCameraPosSetType, offset 0xc1>
	uint8_t mCameraPosSetType;

	// <Unidentified data segment, offset 0xc2>
private:
	char _UnidentifiedData39[2];

public:
	// <struct Vec mCameraPos, offset 0xc4>
	struct Vec mCameraPos;

	// <struct Vec mCameraTargetPos, offset 0xd0>
	struct Vec mCameraTargetPos;

	// <uint8_t mPcPosSetType, offset 0xdc>
	uint8_t mPcPosSetType;

	// <Unidentified data segment, offset 0xdd>
private:
	char _UnidentifiedData42[3];

public:
	// <struct Vec mPcPos, offset 0xe0>
	struct Vec mPcPos;

	// <float mCenterRotY, offset 0xec>
	float mCenterRotY;

	// <float mPcRotY, offset 0xf0>
	float mPcRotY;

	// <class HrScriptFunc* mpEventAreaCircleScriptFunc, offset 0xf4>
	class HrScriptFunc* mpEventAreaCircleScriptFunc;

	// <int32_t mFunctionCallCount, offset 0xf8>
	int32_t mFunctionCallCount;

	// <int32_t mFunctionCallType, offset 0xfc>
	int32_t mFunctionCallType;

	// <int32_t mPcMotionID, offset 0x100>
	int32_t mPcMotionID;

	// <int32_t mPcMoveFrame, offset 0x104>
	int32_t mPcMoveFrame;

	// <uint8_t mDelete, offset 0x108>
	uint8_t mDelete;

	// <Unidentified data segment, offset 0x109>
private:
	char _UnidentifiedData51[3];

public:
	// <class EveCorn* mpEveCorn, offset 0x10c>
	class EveCorn* mpEveCorn;

	// <uint8_t mEveCornVisible, offset 0x110>
	uint8_t mEveCornVisible;

	// <Unidentified data segment, offset 0x111>
private:
	char _UnidentifiedData53[3];

public:
	// <int32_t mEveCornRefreshCnt, offset 0x114>
	int32_t mEveCornRefreshCnt;

	// <uint8_t mEventEndCameraHold, offset 0x118>
	uint8_t mEventEndCameraHold;

	// <uint8_t mFlash, offset 0x119>
	uint8_t mFlash;

	// <uint8_t mFlashSE, offset 0x11a>
	uint8_t mFlashSE;

	// <Unidentified data segment, offset 0x11b>
private:
	char _UnidentifiedData57[1];

public:
	// <int32_t mFlashCounter, offset 0x11c>
	int32_t mFlashCounter;

	// <uint8_t mBikeRide, offset 0x120>
	uint8_t mBikeRide;

	// <Unidentified data segment, offset 0x121>
private:
	char _UnidentifiedData59[3];

public:
	// <class EventAreaCamera* mpEventAreaCamera, offset 0x124>
	class EventAreaCamera* mpEventAreaCamera;

	// <class EventAreaCamera* mpSleepWakeUpCamera, offset 0x128>
	class EventAreaCamera* mpSleepWakeUpCamera;

	// <uint32_t m_AreaCircleEventHandle, offset 0x12c>
	uint32_t m_AreaCircleEventHandle;

	std::string ToString() const { return "class EventAreaCircle(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EventAreaCircle, ghmListObj>("EventAreaCircle")
			.addFunction("__tostring", &EventAreaCircle::ToString)
			.addFunction("GetPtrAddr", &EventAreaCircle::GetPtrAddr)
			.addProperty("m_Kind", &EventAreaCircle::m_Kind)
			.addProperty("m_Center", &EventAreaCircle::m_Center)
			.addProperty("m_sRadius", &EventAreaCircle::m_sRadius)
			.addProperty("m_Rot", &EventAreaCircle::m_Rot)
			.addProperty("m_Scale", &EventAreaCircle::m_Scale)
			.addProperty("m_ScaleHoshi", &EventAreaCircle::m_ScaleHoshi)
			.addProperty("m_MinScale", &EventAreaCircle::m_MinScale)
			.addProperty("m_MaxScale", &EventAreaCircle::m_MaxScale)
			.addProperty("m_Alpha", &EventAreaCircle::m_Alpha)
			.addProperty("m_Done", &EventAreaCircle::m_Done)
			.addProperty("m_PcPlayMotionDone", &EventAreaCircle::m_PcPlayMotionDone)
			.addProperty("m_PcMoveDone", &EventAreaCircle::m_PcMoveDone)
			.addProperty("m_firsttouch", &EventAreaCircle::m_firsttouch)
			.addProperty("m_nowtouch", &EventAreaCircle::m_nowtouch)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_EventName", &EventAreaCircle::m_EventName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StageName", &EventAreaCircle::m_StageName)
			.addProperty("m_HrScriptHandle", &EventAreaCircle::m_HrScriptHandle)
			.addProperty("m_PlayBossCornMotionFlag", &EventAreaCircle::m_PlayBossCornMotionFlag)
			.addProperty("m_pCornGmf", &EventAreaCircle::m_pCornGmf)
			.addProperty("m_pCornSleepGmf", &EventAreaCircle::m_pCornSleepGmf)
			.addProperty("m_pCornShadowGmf", &EventAreaCircle::m_pCornShadowGmf)
			.addProperty("m_pCornShadowGanNum", &EventAreaCircle::m_pCornShadowGanNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("m_pCornShadowGan", &EventAreaCircle::m_pCornShadowGan)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_PlaySe", &EventAreaCircle::m_PlaySe)
			.addProperty("m_MakerType", &EventAreaCircle::m_MakerType)
			.addProperty("m_SignboardType", &EventAreaCircle::m_SignboardType)
			.addProperty("m_Sleep", &EventAreaCircle::m_Sleep)
			.addProperty("m_SleepAlpha", &EventAreaCircle::m_SleepAlpha)
			.addProperty("m_SleepTick", &EventAreaCircle::m_SleepTick)
			.addProperty("m_WakeUpCameraEffect", &EventAreaCircle::m_WakeUpCameraEffect)
			.addProperty("m_Visible", &EventAreaCircle::m_Visible)
			.addProperty("m_SleepMessage", &EventAreaCircle::m_SleepMessage)
			.addProperty("m_SleepMessageProc", &EventAreaCircle::m_SleepMessageProc)
			.addProperty("mBackDispStatusDisEnable", &EventAreaCircle::mBackDispStatusDisEnable)
			.addProperty("m_EventRunEffectProcess", &EventAreaCircle::m_EventRunEffectProcess)
			.addProperty("m_EventRunEffectBit", &EventAreaCircle::m_EventRunEffectBit)
			.addProperty("m_CameraOff", &EventAreaCircle::m_CameraOff)
			.addProperty("mCameraPosSetType", &EventAreaCircle::mCameraPosSetType)
			.addProperty("mCameraPos", &EventAreaCircle::mCameraPos)
			.addProperty("mCameraTargetPos", &EventAreaCircle::mCameraTargetPos)
			.addProperty("mPcPosSetType", &EventAreaCircle::mPcPosSetType)
			.addProperty("mPcPos", &EventAreaCircle::mPcPos)
			.addProperty("mCenterRotY", &EventAreaCircle::mCenterRotY)
			.addProperty("mPcRotY", &EventAreaCircle::mPcRotY)
			.addProperty("mpEventAreaCircleScriptFunc", &EventAreaCircle::mpEventAreaCircleScriptFunc)
			.addProperty("mFunctionCallCount", &EventAreaCircle::mFunctionCallCount)
			.addProperty("mFunctionCallType", &EventAreaCircle::mFunctionCallType)
			.addProperty("mPcMotionID", &EventAreaCircle::mPcMotionID)
			.addProperty("mPcMoveFrame", &EventAreaCircle::mPcMoveFrame)
			.addProperty("mDelete", &EventAreaCircle::mDelete)
			.addProperty("mpEveCorn", &EventAreaCircle::mpEveCorn)
			.addProperty("mEveCornVisible", &EventAreaCircle::mEveCornVisible)
			.addProperty("mEveCornRefreshCnt", &EventAreaCircle::mEveCornRefreshCnt)
			.addProperty("mEventEndCameraHold", &EventAreaCircle::mEventEndCameraHold)
			.addProperty("mFlash", &EventAreaCircle::mFlash)
			.addProperty("mFlashSE", &EventAreaCircle::mFlashSE)
			.addProperty("mFlashCounter", &EventAreaCircle::mFlashCounter)
			.addProperty("mBikeRide", &EventAreaCircle::mBikeRide)
			.addProperty("mpEventAreaCamera", &EventAreaCircle::mpEventAreaCamera)
			.addProperty("mpSleepWakeUpCamera", &EventAreaCircle::mpSleepWakeUpCamera)
			.addProperty("m_AreaCircleEventHandle", &EventAreaCircle::m_AreaCircleEventHandle)
		.endClass();
	}
#endif
};
static_assert(sizeof(EventAreaCircle::m_Kind) == 4, "expected m_Kind to be size 4");
static_assert(sizeof(EventAreaCircle::m_Center) == 12, "expected m_Center to be size 12");
static_assert(sizeof(EventAreaCircle::m_sRadius) == 4, "expected m_sRadius to be size 4");
static_assert(sizeof(EventAreaCircle::m_Rot) == 4, "expected m_Rot to be size 4");
static_assert(sizeof(EventAreaCircle::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EventAreaCircle::m_ScaleHoshi) == 4, "expected m_ScaleHoshi to be size 4");
static_assert(sizeof(EventAreaCircle::m_MinScale) == 4, "expected m_MinScale to be size 4");
static_assert(sizeof(EventAreaCircle::m_MaxScale) == 4, "expected m_MaxScale to be size 4");
static_assert(sizeof(EventAreaCircle::m_Alpha) == 4, "expected m_Alpha to be size 4");
static_assert(sizeof(EventAreaCircle::m_Done) == 1, "expected m_Done to be size 1");
static_assert(sizeof(EventAreaCircle::m_PcPlayMotionDone) == 1, "expected m_PcPlayMotionDone to be size 1");
static_assert(sizeof(EventAreaCircle::m_PcMoveDone) == 1, "expected m_PcMoveDone to be size 1");
static_assert(sizeof(EventAreaCircle::m_firsttouch) == 1, "expected m_firsttouch to be size 1");
static_assert(sizeof(EventAreaCircle::m_nowtouch) == 1, "expected m_nowtouch to be size 1");
static_assert(sizeof(EventAreaCircle::m_EventName) == 32, "expected m_EventName to be size 32");
static_assert(sizeof(EventAreaCircle::m_StageName) == 16, "expected m_StageName to be size 16");
static_assert(sizeof(EventAreaCircle::m_HrScriptHandle) == 4, "expected m_HrScriptHandle to be size 4");
static_assert(sizeof(EventAreaCircle::m_PlayBossCornMotionFlag) == 1, "expected m_PlayBossCornMotionFlag to be size 1");
static_assert(sizeof(EventAreaCircle::m_pCornGmf) == 4, "expected m_pCornGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornSleepGmf) == 4, "expected m_pCornSleepGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGmf) == 4, "expected m_pCornShadowGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGanNum) == 4, "expected m_pCornShadowGanNum to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGan) == 4, "expected m_pCornShadowGan to be size 4");
static_assert(sizeof(EventAreaCircle::m_PlaySe) == 2, "expected m_PlaySe to be size 2");
static_assert(sizeof(EventAreaCircle::m_MakerType) == 4, "expected m_MakerType to be size 4");
static_assert(sizeof(EventAreaCircle::m_SignboardType) == 4, "expected m_SignboardType to be size 4");
static_assert(sizeof(EventAreaCircle::m_Sleep) == 4, "expected m_Sleep to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepAlpha) == 4, "expected m_SleepAlpha to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepTick) == 4, "expected m_SleepTick to be size 4");
static_assert(sizeof(EventAreaCircle::m_WakeUpCameraEffect) == 1, "expected m_WakeUpCameraEffect to be size 1");
static_assert(sizeof(EventAreaCircle::m_Visible) == 1, "expected m_Visible to be size 1");
static_assert(sizeof(EventAreaCircle::m_SleepMessage) == 4, "expected m_SleepMessage to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepMessageProc) == 4, "expected m_SleepMessageProc to be size 4");
static_assert(sizeof(EventAreaCircle::mBackDispStatusDisEnable) == 4, "expected mBackDispStatusDisEnable to be size 4");
static_assert(sizeof(EventAreaCircle::m_EventRunEffectProcess) == 4, "expected m_EventRunEffectProcess to be size 4");
static_assert(sizeof(EventAreaCircle::m_EventRunEffectBit) == 4, "expected m_EventRunEffectBit to be size 4");
static_assert(sizeof(EventAreaCircle::m_CameraOff) == 1, "expected m_CameraOff to be size 1");
static_assert(sizeof(EventAreaCircle::mCameraPosSetType) == 1, "expected mCameraPosSetType to be size 1");
static_assert(sizeof(EventAreaCircle::mCameraPos) == 12, "expected mCameraPos to be size 12");
static_assert(sizeof(EventAreaCircle::mCameraTargetPos) == 12, "expected mCameraTargetPos to be size 12");
static_assert(sizeof(EventAreaCircle::mPcPosSetType) == 1, "expected mPcPosSetType to be size 1");
static_assert(sizeof(EventAreaCircle::mPcPos) == 12, "expected mPcPos to be size 12");
static_assert(sizeof(EventAreaCircle::mCenterRotY) == 4, "expected mCenterRotY to be size 4");
static_assert(sizeof(EventAreaCircle::mPcRotY) == 4, "expected mPcRotY to be size 4");
static_assert(sizeof(EventAreaCircle::mpEventAreaCircleScriptFunc) == 4, "expected mpEventAreaCircleScriptFunc to be size 4");
static_assert(sizeof(EventAreaCircle::mFunctionCallCount) == 4, "expected mFunctionCallCount to be size 4");
static_assert(sizeof(EventAreaCircle::mFunctionCallType) == 4, "expected mFunctionCallType to be size 4");
static_assert(sizeof(EventAreaCircle::mPcMotionID) == 4, "expected mPcMotionID to be size 4");
static_assert(sizeof(EventAreaCircle::mPcMoveFrame) == 4, "expected mPcMoveFrame to be size 4");
static_assert(sizeof(EventAreaCircle::mDelete) == 1, "expected mDelete to be size 1");
static_assert(sizeof(EventAreaCircle::mpEveCorn) == 4, "expected mpEveCorn to be size 4");
static_assert(sizeof(EventAreaCircle::mEveCornVisible) == 1, "expected mEveCornVisible to be size 1");
static_assert(sizeof(EventAreaCircle::mEveCornRefreshCnt) == 4, "expected mEveCornRefreshCnt to be size 4");
static_assert(sizeof(EventAreaCircle::mEventEndCameraHold) == 1, "expected mEventEndCameraHold to be size 1");
static_assert(sizeof(EventAreaCircle::mFlash) == 1, "expected mFlash to be size 1");
static_assert(sizeof(EventAreaCircle::mFlashSE) == 1, "expected mFlashSE to be size 1");
static_assert(sizeof(EventAreaCircle::mFlashCounter) == 4, "expected mFlashCounter to be size 4");
static_assert(sizeof(EventAreaCircle::mBikeRide) == 1, "expected mBikeRide to be size 1");
static_assert(sizeof(EventAreaCircle::mpEventAreaCamera) == 4, "expected mpEventAreaCamera to be size 4");
static_assert(sizeof(EventAreaCircle::mpSleepWakeUpCamera) == 4, "expected mpSleepWakeUpCamera to be size 4");
static_assert(sizeof(EventAreaCircle::m_AreaCircleEventHandle) == 4, "expected m_AreaCircleEventHandle to be size 4");
static_assert(sizeof(EventAreaCircle) == 304, "expected class EventAreaCircle to be size 304");

// [Structure] class ghmScriptVariables
class ghmScriptVariables
{
public:
	/// Struct member variables

	// <char* mpChar, offset 0x0>
	char* mpChar;

	// <int32_t mCharNum, offset 0x4>
	int32_t mCharNum;

	// <int16_t* mpShort, offset 0x8>
	int16_t* mpShort;

	// <int32_t mShortNum, offset 0xc>
	int32_t mShortNum;

	// <int32_t* mpInt, offset 0x10>
	int32_t* mpInt;

	// <int32_t mIntNum, offset 0x14>
	int32_t mIntNum;

	// <int64_t* mpLong, offset 0x18>
	int64_t* mpLong;

	// <int32_t mLongNum, offset 0x1c>
	int32_t mLongNum;

	// <float* mpFloat, offset 0x20>
	float* mpFloat;

	// <int32_t mFloatNum, offset 0x24>
	int32_t mFloatNum;

	// <class ghmString* mpString, offset 0x28>
	class ghmString* mpString;

	// <int32_t mStringNum, offset 0x2c>
	int32_t mStringNum;

	// <uint8_t mAdjustEnable, offset 0x30>
	uint8_t mAdjustEnable;

	// <Unidentified data segment, offset 0x31>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class ghmScriptVariables(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptVariables>("ghmScriptVariables")
			.addFunction("__tostring", &ghmScriptVariables::ToString)
			.addFunction("GetPtrAddr", &ghmScriptVariables::GetPtrAddr)
			// char* type not supported in LuaBridge
			//.addProperty("mpChar", &ghmScriptVariables::mpChar)
			.addProperty("mCharNum", &ghmScriptVariables::mCharNum)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpShort", &ghmScriptVariables::mpShort)
			.addProperty("mShortNum", &ghmScriptVariables::mShortNum)
			// native pointer type (int32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpInt", &ghmScriptVariables::mpInt)
			.addProperty("mIntNum", &ghmScriptVariables::mIntNum)
			// native pointer type (int64_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpLong", &ghmScriptVariables::mpLong)
			.addProperty("mLongNum", &ghmScriptVariables::mLongNum)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpFloat", &ghmScriptVariables::mpFloat)
			.addProperty("mFloatNum", &ghmScriptVariables::mFloatNum)
			.addProperty("mpString", &ghmScriptVariables::mpString)
			.addProperty("mStringNum", &ghmScriptVariables::mStringNum)
			.addProperty("mAdjustEnable", &ghmScriptVariables::mAdjustEnable)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptVariables::mpChar) == 4, "expected mpChar to be size 4");
static_assert(sizeof(ghmScriptVariables::mCharNum) == 4, "expected mCharNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpShort) == 4, "expected mpShort to be size 4");
static_assert(sizeof(ghmScriptVariables::mShortNum) == 4, "expected mShortNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpInt) == 4, "expected mpInt to be size 4");
static_assert(sizeof(ghmScriptVariables::mIntNum) == 4, "expected mIntNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpLong) == 4, "expected mpLong to be size 4");
static_assert(sizeof(ghmScriptVariables::mLongNum) == 4, "expected mLongNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpFloat) == 4, "expected mpFloat to be size 4");
static_assert(sizeof(ghmScriptVariables::mFloatNum) == 4, "expected mFloatNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpString) == 4, "expected mpString to be size 4");
static_assert(sizeof(ghmScriptVariables::mStringNum) == 4, "expected mStringNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mAdjustEnable) == 1, "expected mAdjustEnable to be size 1");
static_assert(sizeof(ghmScriptVariables) == 52, "expected class ghmScriptVariables to be size 52");

// [Structure] class ghmScript
class ghmScript : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct ghmScriptObjectType* mpObjectType, offset 0x10>
	struct ghmScriptObjectType* mpObjectType;

	// <int32_t mObjectTypeNum, offset 0x14>
	int32_t mObjectTypeNum;

	// <class ghmScriptObject* mpObject, offset 0x18>
	class ghmScriptObject* mpObject;

	// <class ghmScriptVariables mLocalVariables, offset 0x1c>
	class ghmScriptVariables mLocalVariables;

	// <uint32_t* mpLocalFlag, offset 0x50>
	uint32_t* mpLocalFlag;

	// <uint32_t mLocalFlagNum, offset 0x54>
	uint32_t mLocalFlagNum;

	// <struct ghmScrHeader* mpHeader, offset 0x58>
	struct ghmScrHeader* mpHeader;

	// <class ghmScriptProgFunc* mpProgFunc, offset 0x5c>
	class ghmScriptProgFunc* mpProgFunc;

	// <class ghmListObj mContextAnchor, offset 0x60>
	class ghmListObj mContextAnchor;

	// <class ghmScriptContext* mpContext, offset 0x70>
	class ghmScriptContext* mpContext;

	// <uint8_t mconvendian, offset 0x74>
	uint8_t mconvendian;

	// <Unidentified data segment, offset 0x75>
private:
	char _UnidentifiedData12[3];

public:
	// <uint32_t mFlag, offset 0x78>
	uint32_t mFlag;

	// <uint32_t mParam[0x4], offset 0x7c>
	uint32_t mParam[4];

	// <class ghmListObj mFuncAnchor, offset 0x8c>
	class ghmListObj mFuncAnchor;

	std::string ToString() const { return "class ghmScript(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmScript, ghmListObj>("ghmScript")
			.addFunction("__tostring", &ghmScript::ToString)
			.addFunction("GetPtrAddr", &ghmScript::GetPtrAddr)
			.addProperty("mpObjectType", &ghmScript::mpObjectType)
			.addProperty("mObjectTypeNum", &ghmScript::mObjectTypeNum)
			.addProperty("mpObject", &ghmScript::mpObject)
			.addProperty("mLocalVariables", &ghmScript::mLocalVariables)
			// native pointer type (uint32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpLocalFlag", &ghmScript::mpLocalFlag)
			.addProperty("mLocalFlagNum", &ghmScript::mLocalFlagNum)
			.addProperty("mpHeader", &ghmScript::mpHeader)
			.addProperty("mpProgFunc", &ghmScript::mpProgFunc)
			.addProperty("mContextAnchor", &ghmScript::mContextAnchor)
			.addProperty("mpContext", &ghmScript::mpContext)
			.addProperty("mconvendian", &ghmScript::mconvendian)
			.addProperty("mFlag", &ghmScript::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mParam", &ghmScript::mParam)
			.addProperty("mFuncAnchor", &ghmScript::mFuncAnchor)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScript::mpObjectType) == 4, "expected mpObjectType to be size 4");
static_assert(sizeof(ghmScript::mObjectTypeNum) == 4, "expected mObjectTypeNum to be size 4");
static_assert(sizeof(ghmScript::mpObject) == 4, "expected mpObject to be size 4");
static_assert(sizeof(ghmScript::mLocalVariables) == 52, "expected mLocalVariables to be size 52");
static_assert(sizeof(ghmScript::mpLocalFlag) == 4, "expected mpLocalFlag to be size 4");
static_assert(sizeof(ghmScript::mLocalFlagNum) == 4, "expected mLocalFlagNum to be size 4");
static_assert(sizeof(ghmScript::mpHeader) == 4, "expected mpHeader to be size 4");
static_assert(sizeof(ghmScript::mpProgFunc) == 4, "expected mpProgFunc to be size 4");
static_assert(sizeof(ghmScript::mContextAnchor) == 16, "expected mContextAnchor to be size 16");
static_assert(sizeof(ghmScript::mpContext) == 4, "expected mpContext to be size 4");
static_assert(sizeof(ghmScript::mconvendian) == 1, "expected mconvendian to be size 1");
static_assert(sizeof(ghmScript::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmScript::mParam) == 16, "expected mParam to be size 16");
static_assert(sizeof(ghmScript::mFuncAnchor) == 16, "expected mFuncAnchor to be size 16");
static_assert(sizeof(ghmScript) == 156, "expected class ghmScript to be size 156");

// [Structure] class ghmScriptFunc
class ghmScriptFunc : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <char mName[0x40], offset 0x10>
	char mName[64];

	// <uint16_t mReturnType, offset 0x50>
	uint16_t mReturnType;

	// <Unidentified data segment, offset 0x52>
private:
	char _UnidentifiedData3[2];

public:
	// <class ghmScriptFuncArgBase* mpReturnValue, offset 0x54>
	class ghmScriptFuncArgBase* mpReturnValue;

	// <uint16_t mArgNum, offset 0x58>
	uint16_t mArgNum;

	// <uint16_t mArgs[0x12], offset 0x5a>
	uint16_t mArgs[18];

	// <Unidentified data segment, offset 0x7e>
private:
	char _UnidentifiedData6[2];

public:
	// <class ghmScriptFuncArgBase* mpArgs[0x12], offset 0x80>
	class ghmScriptFuncArgBase* mpArgs[18];

	// <class ghmScript* mpCallScript, offset 0xc8>
	class ghmScript* mpCallScript;

	// <uint32_t mFlag, offset 0xcc>
	uint32_t mFlag;

	std::string ToString() const { return "class ghmScriptFunc(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmScriptFunc, ghmListObj>("ghmScriptFunc")
			.addFunction("__tostring", &ghmScriptFunc::ToString)
			.addFunction("GetPtrAddr", &ghmScriptFunc::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mName", &ghmScriptFunc::mName)
			.addProperty("mReturnType", &ghmScriptFunc::mReturnType)
			.addProperty("mpReturnValue", &ghmScriptFunc::mpReturnValue)
			.addProperty("mArgNum", &ghmScriptFunc::mArgNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mArgs", &ghmScriptFunc::mArgs)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpArgs", &ghmScriptFunc::mpArgs)
			.addProperty("mpCallScript", &ghmScriptFunc::mpCallScript)
			.addProperty("mFlag", &ghmScriptFunc::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptFunc::mName) == 64, "expected mName to be size 64");
static_assert(sizeof(ghmScriptFunc::mReturnType) == 2, "expected mReturnType to be size 2");
static_assert(sizeof(ghmScriptFunc::mpReturnValue) == 4, "expected mpReturnValue to be size 4");
static_assert(sizeof(ghmScriptFunc::mArgNum) == 2, "expected mArgNum to be size 2");
static_assert(sizeof(ghmScriptFunc::mArgs) == 36, "expected mArgs to be size 36");
static_assert(sizeof(ghmScriptFunc::mpArgs) == 72, "expected mpArgs to be size 72");
static_assert(sizeof(ghmScriptFunc::mpCallScript) == 4, "expected mpCallScript to be size 4");
static_assert(sizeof(ghmScriptFunc::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmScriptFunc) == 208, "expected class ghmScriptFunc to be size 208");

// [Structure] class HrScriptFunc
class HrScriptFunc : public ghmScriptFunc
{
public:
	// enum HrScriptFunc::SCRIPTFUNC_STS
	enum SCRIPTFUNC_STS : uint32_t
	{
		// <SCRIPTFUNC_INIT = 0x0>
		SCRIPTFUNC_INIT = 0,

		// <SCRIPTFUNC_IDLE = 0x1>
		SCRIPTFUNC_IDLE = 1,

		// <SCRIPTFUNC_TERM = 0x2>
		SCRIPTFUNC_TERM = 2,

		// <SCRIPTFUNC_MAX = 0x3>
		SCRIPTFUNC_MAX = 3

	};

	/// Struct member variables

	// <class ghmScriptFunc field_0, offset 0x0>
	// class ghmScriptFunc Super;

	// <enum HrScriptFunc::SCRIPTFUNC_STS m_Status, offset 0xd0>
	enum HrScriptFunc::SCRIPTFUNC_STS m_Status;

	// <uint8_t m_WaitVsync, offset 0xd4>
	uint8_t m_WaitVsync;

	// <Unidentified data segment, offset 0xd5>
private:
	char _UnidentifiedData3[3];

public:
	// <void* m_pScrData, offset 0xd8>
	void* m_pScrData;

	// <class ghmScript m_Script, offset 0xdc>
	class ghmScript m_Script;

	// <char m_SubName[0x10], offset 0x178>
	char m_SubName[16];

	std::string ToString() const { return "class HrScriptFunc(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrScriptFunc, ghmScriptFunc>("HrScriptFunc")
			.addFunction("__tostring", &HrScriptFunc::ToString)
			.addFunction("GetPtrAddr", &HrScriptFunc::GetPtrAddr)
			.addProperty("m_Status", &HrScriptFunc::m_Status)
			.addProperty("m_WaitVsync", &HrScriptFunc::m_WaitVsync)
			// void type not supported in LuaBridge
			//.addProperty("m_pScrData", &HrScriptFunc::m_pScrData)
			.addProperty("m_Script", &HrScriptFunc::m_Script)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_SubName", &HrScriptFunc::m_SubName)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrScriptFunc::m_Status) == 4, "expected m_Status to be size 4");
static_assert(sizeof(HrScriptFunc::m_WaitVsync) == 1, "expected m_WaitVsync to be size 1");
static_assert(sizeof(HrScriptFunc::m_pScrData) == 4, "expected m_pScrData to be size 4");
static_assert(sizeof(HrScriptFunc::m_Script) == 156, "expected m_Script to be size 156");
static_assert(sizeof(HrScriptFunc::m_SubName) == 16, "expected m_SubName to be size 16");
static_assert(sizeof(HrScriptFunc) == 392, "expected class HrScriptFunc to be size 392");

// [Structure] class ghmScriptBase
class ghmScriptBase
{
public:
	/// Struct member variables

	std::string ToString() const { return "class ghmScriptBase(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptBase>("ghmScriptBase")
			.addFunction("__tostring", &ghmScriptBase::ToString)
			.addFunction("GetPtrAddr", &ghmScriptBase::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptBase) == 1, "expected class ghmScriptBase to be size 1");

// [Structure] class CCameraCollision
class CCameraCollision
{
public:
	/// Struct member variables

	std::string ToString() const { return "class CCameraCollision(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraCollision>("CCameraCollision")
			.addFunction("__tostring", &CCameraCollision::ToString)
			.addFunction("GetPtrAddr", &CCameraCollision::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraCollision) == 1, "expected class CCameraCollision to be size 1");

// [Structure] class FkPjLib
class FkPjLib
{
public:
	// [Function] float FkPjLib::GetCharaNowPlayMotionTick(class mHRChara* arg1) [?GetCharaNowPlayMotionTick@FkPjLib@@SAMPAVmHRChara@@@Z]
	static float GetCharaNowPlayMotionTick(class mHRChara* arg1)
	{
		typedef float(__fastcall* _Func)(class mHRChara* arg1);
		_Func mFunc = (_Func)(GameModule + 0x4bca80);
		return mFunc(arg1);
	}
	// [Function] uint8_t FkPjLib::CheckValidCharaPtr(class mHRChara* arg1) [?CheckValidCharaPtr@FkPjLib@@SA_NPAVmHRChara@@@Z]
	static uint8_t CheckValidCharaPtr(class mHRChara* arg1)
	{
		typedef uint8_t(__fastcall* _Func)(class mHRChara* arg1);
		_Func mFunc = (_Func)(GameModule + 0x4bd1a0);
		return mFunc(arg1);
	}
	// [Function] uint8_t FkPjLib::CheckCharSurroundStageCollisionAndAdjustSafetyPos(class mHRChara* arg1, float arg2, float arg3) [?CheckCharSurroundStageCollisionAndAdjustSafetyPos@FkPjLib@@SA_NPAVmHRChara@@MM@Z]
	static uint8_t CheckCharSurroundStageCollisionAndAdjustSafetyPos(class mHRChara* arg1, float arg2, float arg3)
	{
		typedef uint8_t(__fastcall* _Func)(class mHRChara* arg1, float arg2, float arg3);
		_Func mFunc = (_Func)(GameModule + 0x4bd530);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] class mHRChara* FkPjLib::GetCharaPtrByNpcID(int32_t const arg1, uint8_t const arg2) [?GetCharaPtrByNpcID@FkPjLib@@SAPAVmHRChara@@H_N@Z]
	static class mHRChara* GetCharaPtrByNpcID(int32_t const arg1, uint8_t const arg2)
	{
		typedef class mHRChara*(__fastcall* _Func)(int32_t const arg1, uint8_t const arg2);
		_Func mFunc = (_Func)(GameModule + 0x4bdf20);
		return mFunc(arg1, arg2);
	}
	/// Struct member variables

	std::string ToString() const { return "class FkPjLib(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkPjLib>("FkPjLib")
			.addFunction("__tostring", &FkPjLib::ToString)
			.addFunction("GetPtrAddr", &FkPjLib::GetPtrAddr)
			.addStaticFunction("GetCharaNowPlayMotionTick", &FkPjLib::GetCharaNowPlayMotionTick)
			.addStaticFunction("CheckValidCharaPtr", &FkPjLib::CheckValidCharaPtr)
			.addStaticFunction("CheckCharSurroundStageCollisionAndAdjustSafetyPos", &FkPjLib::CheckCharSurroundStageCollisionAndAdjustSafetyPos)
			.addStaticFunction("GetCharaPtrByNpcID", &FkPjLib::GetCharaPtrByNpcID)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkPjLib) == 1, "expected class FkPjLib to be size 1");

// [Structure] class ghmScriptFuncArgBase
class ghmScriptFuncArgBase
{
public:
	/// Struct member variables

	// <void* (* field_0)[0xe], offset 0x0>
	void* (* field_0)[0xe];

	std::string ToString() const { return "class ghmScriptFuncArgBase(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptFuncArgBase>("ghmScriptFuncArgBase")
			.addFunction("__tostring", &ghmScriptFuncArgBase::ToString)
			.addFunction("GetPtrAddr", &ghmScriptFuncArgBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmScriptFuncArgBase::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptFuncArgBase::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmScriptFuncArgBase) == 4, "expected class ghmScriptFuncArgBase to be size 4");

// [Structure] struct ghmScriptObjectType
struct ghmScriptObjectType
{
public:
	/// Struct member variables

	// <uint8_t (* mpMethod)(class ghmScript*, uint16_t, uint16_t), offset 0x0>
	uint8_t (* mpMethod)(class ghmScript*, uint16_t, uint16_t);

	// <int32_t mObjectNum, offset 0x4>
	int32_t mObjectNum;

	// <int32_t mPropCharNum, offset 0x8>
	int32_t mPropCharNum;

	// <int32_t mPropShortNum, offset 0xc>
	int32_t mPropShortNum;

	// <int32_t mPropIntNum, offset 0x10>
	int32_t mPropIntNum;

	// <int32_t mPropLongNum, offset 0x14>
	int32_t mPropLongNum;

	// <int32_t mPropFloatNum, offset 0x18>
	int32_t mPropFloatNum;

	std::string ToString() const { return "struct ghmScriptObjectType(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptObjectType>("ghmScriptObjectType")
			.addFunction("__tostring", &ghmScriptObjectType::ToString)
			.addFunction("GetPtrAddr", &ghmScriptObjectType::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("mpMethod", &ghmScriptObjectType::mpMethod)
			.addProperty("mObjectNum", &ghmScriptObjectType::mObjectNum)
			.addProperty("mPropCharNum", &ghmScriptObjectType::mPropCharNum)
			.addProperty("mPropShortNum", &ghmScriptObjectType::mPropShortNum)
			.addProperty("mPropIntNum", &ghmScriptObjectType::mPropIntNum)
			.addProperty("mPropLongNum", &ghmScriptObjectType::mPropLongNum)
			.addProperty("mPropFloatNum", &ghmScriptObjectType::mPropFloatNum)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptObjectType::mpMethod) == 4, "expected mpMethod to be size 4");
static_assert(sizeof(ghmScriptObjectType::mObjectNum) == 4, "expected mObjectNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropCharNum) == 4, "expected mPropCharNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropShortNum) == 4, "expected mPropShortNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropIntNum) == 4, "expected mPropIntNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropLongNum) == 4, "expected mPropLongNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropFloatNum) == 4, "expected mPropFloatNum to be size 4");
static_assert(sizeof(ghmScriptObjectType) == 28, "expected struct ghmScriptObjectType to be size 28");

// [Structure] class ghmScriptObject
class ghmScriptObject
{
public:
	/// Struct member variables

	// <class ghmScriptVariables* mpProperty, offset 0x0>
	class ghmScriptVariables* mpProperty;

	// <struct ghmScriptObjectType* mpType, offset 0x4>
	struct ghmScriptObjectType* mpType;

	std::string ToString() const { return "class ghmScriptObject(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptObject>("ghmScriptObject")
			.addFunction("__tostring", &ghmScriptObject::ToString)
			.addFunction("GetPtrAddr", &ghmScriptObject::GetPtrAddr)
			.addProperty("mpProperty", &ghmScriptObject::mpProperty)
			.addProperty("mpType", &ghmScriptObject::mpType)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptObject::mpProperty) == 4, "expected mpProperty to be size 4");
static_assert(sizeof(ghmScriptObject::mpType) == 4, "expected mpType to be size 4");
static_assert(sizeof(ghmScriptObject) == 8, "expected class ghmScriptObject to be size 8");

// [Structure] class ghmString
class ghmString
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <char* mpBuff, offset 0x4>
	char* mpBuff;

	// <int32_t mAllocSize, offset 0x8>
	int32_t mAllocSize;

	// <int32_t mLength, offset 0xc>
	int32_t mLength;

	std::string ToString() const { return "class ghmString(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmString>("ghmString")
			.addFunction("__tostring", &ghmString::ToString)
			.addFunction("GetPtrAddr", &ghmString::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmString::field_0)
			// char* type not supported in LuaBridge
			//.addProperty("mpBuff", &ghmString::mpBuff)
			.addProperty("mAllocSize", &ghmString::mAllocSize)
			.addProperty("mLength", &ghmString::mLength)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmString::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmString::mpBuff) == 4, "expected mpBuff to be size 4");
static_assert(sizeof(ghmString::mAllocSize) == 4, "expected mAllocSize to be size 4");
static_assert(sizeof(ghmString::mLength) == 4, "expected mLength to be size 4");
static_assert(sizeof(ghmString) == 16, "expected class ghmString to be size 16");

// [Structure] struct ghmScrHeader
struct ghmScrHeader
{
public:
	/// Struct member variables

	// <uint8_t mMagicNoStr[0x4], offset 0x0>
	uint8_t mMagicNoStr[4];

	// <uint32_t mFlag, offset 0x4>
	uint32_t mFlag;

	// <uint16_t mIntFuncNum, offset 0x8>
	uint16_t mIntFuncNum;

	// <uint16_t mExtFuncNum, offset 0xa>
	uint16_t mExtFuncNum;

	// <struct ghmScrFuncHeader** mppIntFuncTable, offset 0xc>
	struct ghmScrFuncHeader** mppIntFuncTable;

	// <struct ghmScrFuncHeader** mppExtFuncTable, offset 0x10>
	struct ghmScrFuncHeader** mppExtFuncTable;

	// <uint16_t mStringNum, offset 0x14>
	uint16_t mStringNum;

	// <uint16_t mStringNumPad, offset 0x16>
	uint16_t mStringNumPad;

	// <char const** mppString, offset 0x18>
	char const** mppString;

	// <uint32_t mPad[0x1], offset 0x1c>
	uint32_t mPad[1];

	std::string ToString() const { return "struct ghmScrHeader(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScrHeader>("ghmScrHeader")
			.addFunction("__tostring", &ghmScrHeader::ToString)
			.addFunction("GetPtrAddr", &ghmScrHeader::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mMagicNoStr", &ghmScrHeader::mMagicNoStr)
			.addProperty("mFlag", &ghmScrHeader::mFlag)
			.addProperty("mIntFuncNum", &ghmScrHeader::mIntFuncNum)
			.addProperty("mExtFuncNum", &ghmScrHeader::mExtFuncNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppIntFuncTable", &ghmScrHeader::mppIntFuncTable)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppExtFuncTable", &ghmScrHeader::mppExtFuncTable)
			.addProperty("mStringNum", &ghmScrHeader::mStringNum)
			.addProperty("mStringNumPad", &ghmScrHeader::mStringNumPad)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppString", &ghmScrHeader::mppString)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmScrHeader::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScrHeader::mMagicNoStr) == 4, "expected mMagicNoStr to be size 4");
static_assert(sizeof(ghmScrHeader::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmScrHeader::mIntFuncNum) == 2, "expected mIntFuncNum to be size 2");
static_assert(sizeof(ghmScrHeader::mExtFuncNum) == 2, "expected mExtFuncNum to be size 2");
static_assert(sizeof(ghmScrHeader::mppIntFuncTable) == 4, "expected mppIntFuncTable to be size 4");
static_assert(sizeof(ghmScrHeader::mppExtFuncTable) == 4, "expected mppExtFuncTable to be size 4");
static_assert(sizeof(ghmScrHeader::mStringNum) == 2, "expected mStringNum to be size 2");
static_assert(sizeof(ghmScrHeader::mStringNumPad) == 2, "expected mStringNumPad to be size 2");
static_assert(sizeof(ghmScrHeader::mppString) == 4, "expected mppString to be size 4");
static_assert(sizeof(ghmScrHeader::mPad) == 4, "expected mPad to be size 4");
static_assert(sizeof(ghmScrHeader) == 32, "expected struct ghmScrHeader to be size 32");

// [Structure] struct ghmScrFuncHeader
struct ghmScrFuncHeader
{
public:
	/// Struct member variables

	// <char const* mpName, offset 0x0>
	char const* mpName;

	// <uint16_t mReturnType, offset 0x4>
	uint16_t mReturnType;

	// <uint16_t mArgNum, offset 0x6>
	uint16_t mArgNum;

	// <uint16_t* mpArgs, offset 0x8>
	uint16_t* mpArgs;

	// <uint16_t* mpDataTop, offset 0xc>
	uint16_t* mpDataTop;

	// <uint32_t mDataSize, offset 0x10>
	uint32_t mDataSize;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag;

	// <uint32_t mPad[0x2], offset 0x18>
	uint32_t mPad[2];

	std::string ToString() const { return "struct ghmScrFuncHeader(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScrFuncHeader>("ghmScrFuncHeader")
			.addFunction("__tostring", &ghmScrFuncHeader::ToString)
			.addFunction("GetPtrAddr", &ghmScrFuncHeader::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpName", &ghmScrFuncHeader::mpName)
			.addProperty("mReturnType", &ghmScrFuncHeader::mReturnType)
			.addProperty("mArgNum", &ghmScrFuncHeader::mArgNum)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpArgs", &ghmScrFuncHeader::mpArgs)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpDataTop", &ghmScrFuncHeader::mpDataTop)
			.addProperty("mDataSize", &ghmScrFuncHeader::mDataSize)
			.addProperty("mFlag", &ghmScrFuncHeader::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmScrFuncHeader::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScrFuncHeader::mpName) == 4, "expected mpName to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mReturnType) == 2, "expected mReturnType to be size 2");
static_assert(sizeof(ghmScrFuncHeader::mArgNum) == 2, "expected mArgNum to be size 2");
static_assert(sizeof(ghmScrFuncHeader::mpArgs) == 4, "expected mpArgs to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mpDataTop) == 4, "expected mpDataTop to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mDataSize) == 4, "expected mDataSize to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mPad) == 8, "expected mPad to be size 8");
static_assert(sizeof(ghmScrFuncHeader) == 32, "expected struct ghmScrFuncHeader to be size 32");

// [Structure] class ghmScriptProgFunc
class ghmScriptProgFunc : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class ghmScriptFunc mFunc, offset 0x10>
	class ghmScriptFunc mFunc;

	// <uint8_t (* mpCallback)(class ghmScriptFunc*), offset 0xe0>
	uint8_t (* mpCallback)(class ghmScriptFunc*);

	// <uint32_t mHashKey, offset 0xe4>
	uint32_t mHashKey;

	std::string ToString() const { return "class ghmScriptProgFunc(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmScriptProgFunc, ghmListObj>("ghmScriptProgFunc")
			.addFunction("__tostring", &ghmScriptProgFunc::ToString)
			.addFunction("GetPtrAddr", &ghmScriptProgFunc::GetPtrAddr)
			.addProperty("mFunc", &ghmScriptProgFunc::mFunc)
			// delegates are not supported in LuaBridge
			//.addProperty("mpCallback", &ghmScriptProgFunc::mpCallback)
			.addProperty("mHashKey", &ghmScriptProgFunc::mHashKey)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptProgFunc::mFunc) == 208, "expected mFunc to be size 208");
static_assert(sizeof(ghmScriptProgFunc::mpCallback) == 4, "expected mpCallback to be size 4");
static_assert(sizeof(ghmScriptProgFunc::mHashKey) == 4, "expected mHashKey to be size 4");
static_assert(sizeof(ghmScriptProgFunc) == 232, "expected class ghmScriptProgFunc to be size 232");

// [Structure] struct ghmScriptStackData
struct ghmScriptStackData
{
public:
	/// Struct member variables

	// <uint16_t mData[0x5], offset 0x0>
	uint16_t mData[5];

	// <uint8_t mSize, offset 0xa>
	uint8_t mSize;

	// <uint8_t mType, offset 0xb>
	uint8_t mType;

	// <Unidentified data segment, offset 0xc>
private:
	char _UnidentifiedData3[4];

public:
	// <float mFloat, offset 0x10>
	float mFloat;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData4[4];

public:
	// <class ghmString mString, offset 0x18>
	class ghmString mString;

	std::string ToString() const { return "struct ghmScriptStackData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptStackData>("ghmScriptStackData")
			.addFunction("__tostring", &ghmScriptStackData::ToString)
			.addFunction("GetPtrAddr", &ghmScriptStackData::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mData", &ghmScriptStackData::mData)
			.addProperty("mSize", &ghmScriptStackData::mSize)
			.addProperty("mType", &ghmScriptStackData::mType)
			.addProperty("mFloat", &ghmScriptStackData::mFloat)
			.addProperty("mString", &ghmScriptStackData::mString)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptStackData::mData) == 10, "expected mData to be size 10");
static_assert(sizeof(ghmScriptStackData::mSize) == 1, "expected mSize to be size 1");
static_assert(sizeof(ghmScriptStackData::mType) == 1, "expected mType to be size 1");
static_assert(sizeof(ghmScriptStackData::mFloat) == 4, "expected mFloat to be size 4");
static_assert(sizeof(ghmScriptStackData::mString) == 16, "expected mString to be size 16");
static_assert(sizeof(ghmScriptStackData) == 40, "expected struct ghmScriptStackData to be size 40");

// [Structure] class ghmScriptStack
class ghmScriptStack
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[744];
public:

	std::string ToString() const { return "class ghmScriptStack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptStack>("ghmScriptStack")
			.addFunction("__tostring", &ghmScriptStack::ToString)
			.addFunction("GetPtrAddr", &ghmScriptStack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptStack) == 744, "expected class ghmScriptStack to be size 744");

// [Structure] class ghmScriptContext
class ghmScriptContext : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class ghmScript* mpContainer, offset 0x10>
	class ghmScript* mpContainer;

	// <class ghmScript* mpDataSource, offset 0x14>
	class ghmScript* mpDataSource;

	// <class ghmScriptVariables mAutoVariables, offset 0x18>
	class ghmScriptVariables mAutoVariables;

	// <struct ghmScrFuncHeader* mpFuncHeader, offset 0x4c>
	struct ghmScrFuncHeader* mpFuncHeader;

	// <uint16_t* mpCode, offset 0x50>
	uint16_t* mpCode;

	// <int32_t mCodeCnt, offset 0x54>
	int32_t mCodeCnt;

	// <class ghmScriptStack mStack, offset 0x58>
	class ghmScriptStack mStack;

	// <struct ghmScriptStackData mReturnData, offset 0x340>
	struct ghmScriptStackData mReturnData;

	std::string ToString() const { return "class ghmScriptContext(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ghmScriptContext, ghmListObj>("ghmScriptContext")
			.addFunction("__tostring", &ghmScriptContext::ToString)
			.addFunction("GetPtrAddr", &ghmScriptContext::GetPtrAddr)
			.addProperty("mpContainer", &ghmScriptContext::mpContainer)
			.addProperty("mpDataSource", &ghmScriptContext::mpDataSource)
			.addProperty("mAutoVariables", &ghmScriptContext::mAutoVariables)
			.addProperty("mpFuncHeader", &ghmScriptContext::mpFuncHeader)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpCode", &ghmScriptContext::mpCode)
			.addProperty("mCodeCnt", &ghmScriptContext::mCodeCnt)
			.addProperty("mStack", &ghmScriptContext::mStack)
			.addProperty("mReturnData", &ghmScriptContext::mReturnData)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptContext::mpContainer) == 4, "expected mpContainer to be size 4");
static_assert(sizeof(ghmScriptContext::mpDataSource) == 4, "expected mpDataSource to be size 4");
static_assert(sizeof(ghmScriptContext::mAutoVariables) == 52, "expected mAutoVariables to be size 52");
static_assert(sizeof(ghmScriptContext::mpFuncHeader) == 4, "expected mpFuncHeader to be size 4");
static_assert(sizeof(ghmScriptContext::mpCode) == 4, "expected mpCode to be size 4");
static_assert(sizeof(ghmScriptContext::mCodeCnt) == 4, "expected mCodeCnt to be size 4");
static_assert(sizeof(ghmScriptContext::mStack) == 744, "expected mStack to be size 744");
static_assert(sizeof(ghmScriptContext::mReturnData) == 40, "expected mReturnData to be size 40");
static_assert(sizeof(ghmScriptContext) == 872, "expected class ghmScriptContext to be size 872");

// [Structure] class EveCorn
class EveCorn
{
public:
	/// Struct member variables

	// <uint8_t flag, offset 0x0>
	uint8_t flag;

	// <Unidentified data segment, offset 0x1>
private:
	char _UnidentifiedData1[3];

public:
	// <float mScale, offset 0x4>
	float mScale;

	// <uint32_t mColor, offset 0x8>
	uint32_t mColor;

	// <struct Vec mRootPosition, offset 0xc>
	struct Vec mRootPosition;

	// <float mRootRotY, offset 0x18>
	float mRootRotY;

	// <float mRootRotY2, offset 0x1c>
	float mRootRotY2;

	// <int32_t mMoveProcess, offset 0x20>
	int32_t mMoveProcess;

	// <int32_t mMakerType, offset 0x24>
	int32_t mMakerType;

	std::string ToString() const { return "class EveCorn(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EveCorn>("EveCorn")
			.addFunction("__tostring", &EveCorn::ToString)
			.addFunction("GetPtrAddr", &EveCorn::GetPtrAddr)
			.addProperty("flag", &EveCorn::flag)
			.addProperty("mScale", &EveCorn::mScale)
			.addProperty("mColor", &EveCorn::mColor)
			.addProperty("mRootPosition", &EveCorn::mRootPosition)
			.addProperty("mRootRotY", &EveCorn::mRootRotY)
			.addProperty("mRootRotY2", &EveCorn::mRootRotY2)
			.addProperty("mMoveProcess", &EveCorn::mMoveProcess)
			.addProperty("mMakerType", &EveCorn::mMakerType)
		.endClass();
	}
#endif
};
static_assert(sizeof(EveCorn::flag) == 1, "expected flag to be size 1");
static_assert(sizeof(EveCorn::mScale) == 4, "expected mScale to be size 4");
static_assert(sizeof(EveCorn::mColor) == 4, "expected mColor to be size 4");
static_assert(sizeof(EveCorn::mRootPosition) == 12, "expected mRootPosition to be size 12");
static_assert(sizeof(EveCorn::mRootRotY) == 4, "expected mRootRotY to be size 4");
static_assert(sizeof(EveCorn::mRootRotY2) == 4, "expected mRootRotY2 to be size 4");
static_assert(sizeof(EveCorn::mMoveProcess) == 4, "expected mMoveProcess to be size 4");
static_assert(sizeof(EveCorn::mMakerType) == 4, "expected mMakerType to be size 4");
static_assert(sizeof(EveCorn) == 40, "expected class EveCorn to be size 40");

// [Structure] class EventAreaCamera
class EventAreaCamera : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct EVENTAREACAMERA_DATA* pd, offset 0x10>
	struct EVENTAREACAMERA_DATA* pd;

	std::string ToString() const { return "class EventAreaCamera(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EventAreaCamera, ghmListObj>("EventAreaCamera")
			.addFunction("__tostring", &EventAreaCamera::ToString)
			.addFunction("GetPtrAddr", &EventAreaCamera::GetPtrAddr)
			.addProperty("pd", &EventAreaCamera::pd)
		.endClass();
	}
#endif
};
static_assert(sizeof(EventAreaCamera::pd) == 4, "expected pd to be size 4");
static_assert(sizeof(EventAreaCamera) == 20, "expected class EventAreaCamera to be size 20");

// enum HRCAMERA_MODE
enum HRCAMERA_MODE : uint32_t
{
	// <HRCAMERA_MODE_NONE = 0xffffffffffffffff>
	HRCAMERA_MODE_NONE = UINT32_MAX,

	// <HRCAMERA_MODE_RAIL = 0x0>
	HRCAMERA_MODE_RAIL = 0,

	// <HRCAMERA_MODE_TEPPEI = 0x1>
	HRCAMERA_MODE_TEPPEI = 1,

	// <HRCAMERA_MODE_MOTION = 0x2>
	HRCAMERA_MODE_MOTION = 2,

	// <HRCAMERA_MODE_NORMAL = 0x3>
	HRCAMERA_MODE_NORMAL = 3,

	// <HRCAMERA_MODE_FREE = 0x4>
	HRCAMERA_MODE_FREE = 4

};

// [Structure] struct EVENTAREACAMERA_DATA
struct EVENTAREACAMERA_DATA
{
public:
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mCameraPos, offset 0xc>
	struct Vec mCameraPos;

	// <struct Vec mTargetPos, offset 0x18>
	struct Vec mTargetPos;

	// <struct Vec mCameraDirec, offset 0x24>
	struct Vec mCameraDirec;

	// <float mCameraDist, offset 0x30>
	float mCameraDist;

	// <float mRadius, offset 0x34>
	float mRadius;

	// <int32_t mWalkWait, offset 0x38>
	int32_t mWalkWait;

	// <uint32_t mScriptHandle, offset 0x3c>
	uint32_t mScriptHandle;

	// <uint8_t mDone, offset 0x40>
	uint8_t mDone;

	// <uint8_t mFirstTouch, offset 0x41>
	uint8_t mFirstTouch;

	// <char mStageName[0x10], offset 0x42>
	char mStageName[16];

	// <Unidentified data segment, offset 0x52>
private:
	char _UnidentifiedData11[2];

public:
	// <int32_t mStatus, offset 0x54>
	int32_t mStatus;

	// <enum HRCAMERA_MODE mCameraModeSave, offset 0x58>
	enum HRCAMERA_MODE mCameraModeSave;

	// <int32_t mType, offset 0x5c>
	int32_t mType;

	// <class EventAreaCircle* mpEvAreaCircle, offset 0x60>
	class EventAreaCircle* mpEvAreaCircle;

	// <class TGmf* mpGmfTgt, offset 0x64>
	class TGmf* mpGmfTgt;

	// <uint8_t mEventEndCameraHold, offset 0x68>
	uint8_t mEventEndCameraHold;

	// <uint8_t mEventEndPcNoRefresh, offset 0x69>
	uint8_t mEventEndPcNoRefresh;

	// <Unidentified data segment, offset 0x6a>
private:
	char _UnidentifiedData[2];
public:

	std::string ToString() const { return "struct EVENTAREACAMERA_DATA(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EVENTAREACAMERA_DATA>("EVENTAREACAMERA_DATA")
			.addFunction("__tostring", &EVENTAREACAMERA_DATA::ToString)
			.addFunction("GetPtrAddr", &EVENTAREACAMERA_DATA::GetPtrAddr)
			.addProperty("mCenter", &EVENTAREACAMERA_DATA::mCenter)
			.addProperty("mCameraPos", &EVENTAREACAMERA_DATA::mCameraPos)
			.addProperty("mTargetPos", &EVENTAREACAMERA_DATA::mTargetPos)
			.addProperty("mCameraDirec", &EVENTAREACAMERA_DATA::mCameraDirec)
			.addProperty("mCameraDist", &EVENTAREACAMERA_DATA::mCameraDist)
			.addProperty("mRadius", &EVENTAREACAMERA_DATA::mRadius)
			.addProperty("mWalkWait", &EVENTAREACAMERA_DATA::mWalkWait)
			.addProperty("mScriptHandle", &EVENTAREACAMERA_DATA::mScriptHandle)
			.addProperty("mDone", &EVENTAREACAMERA_DATA::mDone)
			.addProperty("mFirstTouch", &EVENTAREACAMERA_DATA::mFirstTouch)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mStageName", &EVENTAREACAMERA_DATA::mStageName)
			.addProperty("mStatus", &EVENTAREACAMERA_DATA::mStatus)
			.addProperty("mCameraModeSave", &EVENTAREACAMERA_DATA::mCameraModeSave)
			.addProperty("mType", &EVENTAREACAMERA_DATA::mType)
			.addProperty("mpEvAreaCircle", &EVENTAREACAMERA_DATA::mpEvAreaCircle)
			.addProperty("mpGmfTgt", &EVENTAREACAMERA_DATA::mpGmfTgt)
			.addProperty("mEventEndCameraHold", &EVENTAREACAMERA_DATA::mEventEndCameraHold)
			.addProperty("mEventEndPcNoRefresh", &EVENTAREACAMERA_DATA::mEventEndPcNoRefresh)
		.endClass();
	}
#endif
};
static_assert(sizeof(EVENTAREACAMERA_DATA::mCenter) == 12, "expected mCenter to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraPos) == 12, "expected mCameraPos to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mTargetPos) == 12, "expected mTargetPos to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraDirec) == 12, "expected mCameraDirec to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraDist) == 4, "expected mCameraDist to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mRadius) == 4, "expected mRadius to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mWalkWait) == 4, "expected mWalkWait to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mScriptHandle) == 4, "expected mScriptHandle to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mDone) == 1, "expected mDone to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mFirstTouch) == 1, "expected mFirstTouch to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mStageName) == 16, "expected mStageName to be size 16");
static_assert(sizeof(EVENTAREACAMERA_DATA::mStatus) == 4, "expected mStatus to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraModeSave) == 4, "expected mCameraModeSave to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mType) == 4, "expected mType to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mpEvAreaCircle) == 4, "expected mpEvAreaCircle to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mpGmfTgt) == 4, "expected mpGmfTgt to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mEventEndCameraHold) == 1, "expected mEventEndCameraHold to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mEventEndPcNoRefresh) == 1, "expected mEventEndPcNoRefresh to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA) == 108, "expected struct EVENTAREACAMERA_DATA to be size 108");

// [Structure] class EffectDriftMark
class EffectDriftMark
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[388];
public:

	std::string ToString() const { return "class EffectDriftMark(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectDriftMark>("EffectDriftMark")
			.addFunction("__tostring", &EffectDriftMark::ToString)
			.addFunction("GetPtrAddr", &EffectDriftMark::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectDriftMark) == 388, "expected class EffectDriftMark to be size 388");

// [Structure] class EffectKeepSmoke
class EffectKeepSmoke : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData2[3];

public:
	// <class rPrimUnific m_QuadUni, offset 0x54>
	class rPrimUnific m_QuadUni;

	// <class rQuad* m_pQuadArray, offset 0x74>
	class rQuad* m_pQuadArray;

	// <struct tagGHMR_TEX m_SubTex, offset 0x78>
	struct tagGHMR_TEX m_SubTex;

	// <struct Vec* m_pMoveVecArray, offset 0xa0>
	struct Vec* m_pMoveVecArray;

	// <int32_t* m_pCountArray, offset 0xa4>
	int32_t* m_pCountArray;

	// <float* m_pSpeedArray, offset 0xa8>
	float* m_pSpeedArray;

	// <int32_t m_PrimNum, offset 0xac>
	int32_t m_PrimNum;

	// <float m_Scale, offset 0xb0>
	float m_Scale;

	// <int32_t m_FadeTime, offset 0xb4>
	int32_t m_FadeTime;

	// <void* m_pRes, offset 0xb8>
	void* m_pRes;

	// <float m_TimeCount, offset 0xbc>
	float m_TimeCount;

	// <int32_t m_TimeFrame, offset 0xc0>
	int32_t m_TimeFrame;

	// <float m_TimeRate, offset 0xc4>
	float m_TimeRate;

	std::string ToString() const { return "class EffectKeepSmoke(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectKeepSmoke, HrTask>("EffectKeepSmoke")
			.addFunction("__tostring", &EffectKeepSmoke::ToString)
			.addFunction("GetPtrAddr", &EffectKeepSmoke::GetPtrAddr)
			.addProperty("m_Flag", &EffectKeepSmoke::m_Flag)
			.addProperty("m_QuadUni", &EffectKeepSmoke::m_QuadUni)
			.addProperty("m_pQuadArray", &EffectKeepSmoke::m_pQuadArray)
			.addProperty("m_SubTex", &EffectKeepSmoke::m_SubTex)
			.addProperty("m_pMoveVecArray", &EffectKeepSmoke::m_pMoveVecArray)
			// native pointer type (int32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pCountArray", &EffectKeepSmoke::m_pCountArray)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pSpeedArray", &EffectKeepSmoke::m_pSpeedArray)
			.addProperty("m_PrimNum", &EffectKeepSmoke::m_PrimNum)
			.addProperty("m_Scale", &EffectKeepSmoke::m_Scale)
			.addProperty("m_FadeTime", &EffectKeepSmoke::m_FadeTime)
			// void type not supported in LuaBridge
			//.addProperty("m_pRes", &EffectKeepSmoke::m_pRes)
			.addProperty("m_TimeCount", &EffectKeepSmoke::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectKeepSmoke::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectKeepSmoke::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectKeepSmoke::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectKeepSmoke::m_QuadUni) == 32, "expected m_QuadUni to be size 32");
static_assert(sizeof(EffectKeepSmoke::m_pQuadArray) == 4, "expected m_pQuadArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_SubTex) == 40, "expected m_SubTex to be size 40");
static_assert(sizeof(EffectKeepSmoke::m_pMoveVecArray) == 4, "expected m_pMoveVecArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pCountArray) == 4, "expected m_pCountArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pSpeedArray) == 4, "expected m_pSpeedArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_PrimNum) == 4, "expected m_PrimNum to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_FadeTime) == 4, "expected m_FadeTime to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pRes) == 4, "expected m_pRes to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeFrame) == 4, "expected m_TimeFrame to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(EffectKeepSmoke) == 200, "expected class EffectKeepSmoke to be size 200");

// [Structure] class rQuad
class rQuad
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[172];
public:

	std::string ToString() const { return "class rQuad(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rQuad>("rQuad")
			.addFunction("__tostring", &rQuad::ToString)
			.addFunction("GetPtrAddr", &rQuad::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(rQuad) == 172, "expected class rQuad to be size 172");

// enum GHMR_BLEND
enum GHMR_BLEND : uint32_t
{
	// <GHMR_BLEND_ADD = 0x0>
	GHMR_BLEND_ADD = 0,

	// <GHMR_BLEND_SUB = 0x1>
	GHMR_BLEND_SUB = 1,

	// <GHMR_BLEND_MUL = 0x2>
	GHMR_BLEND_MUL = 2,

	// <GHMR_BLEND_ALPHA = 0x3>
	GHMR_BLEND_ALPHA = 3,

	// <GHMR_BLEND_NONE = 0x4>
	GHMR_BLEND_NONE = 4,

	// <GHMR_BLEND_NUM = 0x5>
	GHMR_BLEND_NUM = 5

};

// [Structure] class EffectFixFire
class EffectFixFire : public HrTask
{
public:
	// [Structure] struct EffectFixFire::Object
	struct Object
	{
	public:
		/// Struct member variables

		// <EffectFixFire::Object* m_pNext, offset 0x0>
		Object* m_pNext;

		// <EffectFixFire::Object* m_pPrev, offset 0x4>
		Object* m_pPrev;

		// <uint8_t m_Fade, offset 0x8>
		uint8_t m_Fade;

		// <Unidentified data segment, offset 0x9>
	private:
		char _UnidentifiedData3[3];

	public:
		// <struct Vec m_MoveVec, offset 0xc>
		struct Vec m_MoveVec;

		// <struct Vec m_LocalPos, offset 0x18>
		struct Vec m_LocalPos;

		// <float m_Scale, offset 0x24>
		float m_Scale;

		// <float m_u, offset 0x28>
		float m_u;

		// <float m_v, offset 0x2c>
		float m_v;

		// <int32_t m_Alpha, offset 0x30>
		int32_t m_Alpha;

		std::string ToString() const { return "struct Object(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectFixFire::Object>("EffectFixFire_Object")
				.addFunction("__tostring", &EffectFixFire::Object::ToString)
				.addFunction("GetPtrAddr", &EffectFixFire::Object::GetPtrAddr)
				.addProperty("m_pNext", &EffectFixFire::Object::m_pNext)
				.addProperty("m_pPrev", &EffectFixFire::Object::m_pPrev)
				.addProperty("m_Fade", &EffectFixFire::Object::m_Fade)
				.addProperty("m_MoveVec", &EffectFixFire::Object::m_MoveVec)
				.addProperty("m_LocalPos", &EffectFixFire::Object::m_LocalPos)
				.addProperty("m_Scale", &EffectFixFire::Object::m_Scale)
				.addProperty("m_u", &EffectFixFire::Object::m_u)
				.addProperty("m_v", &EffectFixFire::Object::m_v)
				.addProperty("m_Alpha", &EffectFixFire::Object::m_Alpha)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFixFire::Object::m_pNext) == 4, "expected m_pNext to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_pPrev) == 4, "expected m_pPrev to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_Fade) == 1, "expected m_Fade to be size 1");
	static_assert(sizeof(EffectFixFire::Object::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
	static_assert(sizeof(EffectFixFire::Object::m_LocalPos) == 12, "expected m_LocalPos to be size 12");
	static_assert(sizeof(EffectFixFire::Object::m_Scale) == 4, "expected m_Scale to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_u) == 4, "expected m_u to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_v) == 4, "expected m_v to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_Alpha) == 4, "expected m_Alpha to be size 4");
	static_assert(sizeof(EffectFixFire::Object) == 52, "expected struct EffectFixFire::Object to be size 52");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData2[3];

public:
	// <struct EffectFixFire::Object* m_pObject, offset 0x54>
	struct EffectFixFire::Object* m_pObject;

	// <struct EffectFixFire::Object m_ValidFirst, offset 0x58>
	struct EffectFixFire::Object m_ValidFirst;

	// <struct EffectFixFire::Object m_ValidLast, offset 0x8c>
	struct EffectFixFire::Object m_ValidLast;

	// <struct EffectFixFire::Object m_FreeFirst, offset 0xc0>
	struct EffectFixFire::Object m_FreeFirst;

	// <struct EffectFixFire::Object m_FreeLast, offset 0xf4>
	struct EffectFixFire::Object m_FreeLast;

	// <struct tagGHMR_TEX m_Tex, offset 0x128>
	struct tagGHMR_TEX m_Tex;

	// <enum GHMR_BLEND m_BlendMode, offset 0x150>
	enum GHMR_BLEND m_BlendMode;

	// <int32_t m_FadeAlphaSpeed, offset 0x154>
	int32_t m_FadeAlphaSpeed;

	// <int32_t m_PrimNum, offset 0x158>
	int32_t m_PrimNum;

	// <int32_t m_ValidPrimNum, offset 0x15c>
	int32_t m_ValidPrimNum;

	// <struct Vec m_CenterPos, offset 0x160>
	struct Vec m_CenterPos;

	// <struct Vec m_Direc, offset 0x16c>
	struct Vec m_Direc;

	// <struct Vec m_RotRange, offset 0x178>
	struct Vec m_RotRange;

	// <float m_Speed, offset 0x184>
	float m_Speed;

	// <struct GXColor m_Color, offset 0x188>
	struct GXColor m_Color;

	// <float m_Scale, offset 0x18c>
	float m_Scale;

	// <float m_ScaleAnime, offset 0x190>
	float m_ScaleAnime;

	// <float m_TimeCount, offset 0x194>
	float m_TimeCount;

	// <int32_t m_TimeFrame, offset 0x198>
	int32_t m_TimeFrame;

	// <float m_TimeRate, offset 0x19c>
	float m_TimeRate;

	std::string ToString() const { return "class EffectFixFire(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectFixFire, HrTask>("EffectFixFire")
			.addFunction("__tostring", &EffectFixFire::ToString)
			.addFunction("GetPtrAddr", &EffectFixFire::GetPtrAddr)
			.addProperty("m_Flag", &EffectFixFire::m_Flag)
			.addProperty("m_pObject", &EffectFixFire::m_pObject)
			.addProperty("m_ValidFirst", &EffectFixFire::m_ValidFirst)
			.addProperty("m_ValidLast", &EffectFixFire::m_ValidLast)
			.addProperty("m_FreeFirst", &EffectFixFire::m_FreeFirst)
			.addProperty("m_FreeLast", &EffectFixFire::m_FreeLast)
			.addProperty("m_Tex", &EffectFixFire::m_Tex)
			.addProperty("m_BlendMode", &EffectFixFire::m_BlendMode)
			.addProperty("m_FadeAlphaSpeed", &EffectFixFire::m_FadeAlphaSpeed)
			.addProperty("m_PrimNum", &EffectFixFire::m_PrimNum)
			.addProperty("m_ValidPrimNum", &EffectFixFire::m_ValidPrimNum)
			.addProperty("m_CenterPos", &EffectFixFire::m_CenterPos)
			.addProperty("m_Direc", &EffectFixFire::m_Direc)
			.addProperty("m_RotRange", &EffectFixFire::m_RotRange)
			.addProperty("m_Speed", &EffectFixFire::m_Speed)
			.addProperty("m_Color", &EffectFixFire::m_Color)
			.addProperty("m_Scale", &EffectFixFire::m_Scale)
			.addProperty("m_ScaleAnime", &EffectFixFire::m_ScaleAnime)
			.addProperty("m_TimeCount", &EffectFixFire::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectFixFire::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectFixFire::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectFixFire::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectFixFire::m_pObject) == 4, "expected m_pObject to be size 4");
static_assert(sizeof(EffectFixFire::m_ValidFirst) == 52, "expected m_ValidFirst to be size 52");
static_assert(sizeof(EffectFixFire::m_ValidLast) == 52, "expected m_ValidLast to be size 52");
static_assert(sizeof(EffectFixFire::m_FreeFirst) == 52, "expected m_FreeFirst to be size 52");
static_assert(sizeof(EffectFixFire::m_FreeLast) == 52, "expected m_FreeLast to be size 52");
static_assert(sizeof(EffectFixFire::m_Tex) == 40, "expected m_Tex to be size 40");
static_assert(sizeof(EffectFixFire::m_BlendMode) == 4, "expected m_BlendMode to be size 4");
static_assert(sizeof(EffectFixFire::m_FadeAlphaSpeed) == 4, "expected m_FadeAlphaSpeed to be size 4");
static_assert(sizeof(EffectFixFire::m_PrimNum) == 4, "expected m_PrimNum to be size 4");
static_assert(sizeof(EffectFixFire::m_ValidPrimNum) == 4, "expected m_ValidPrimNum to be size 4");
static_assert(sizeof(EffectFixFire::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(EffectFixFire::m_Direc) == 12, "expected m_Direc to be size 12");
static_assert(sizeof(EffectFixFire::m_RotRange) == 12, "expected m_RotRange to be size 12");
static_assert(sizeof(EffectFixFire::m_Speed) == 4, "expected m_Speed to be size 4");
static_assert(sizeof(EffectFixFire::m_Color) == 4, "expected m_Color to be size 4");
static_assert(sizeof(EffectFixFire::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EffectFixFire::m_ScaleAnime) == 4, "expected m_ScaleAnime to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeFrame) == 4, "expected m_TimeFrame to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(EffectFixFire) == 416, "expected class EffectFixFire to be size 416");

// [Structure] class HrOverLap
class HrOverLap
{
public:
	/// Struct member variables

	// <uint8_t mAlloc, offset 0x0>
	uint8_t mAlloc;

	// <Unidentified data segment, offset 0x1>
private:
	char _UnidentifiedData1[3];

public:
	// <int32_t mStatus, offset 0x4>
	int32_t mStatus;

	// <float mAlpha, offset 0x8>
	float mAlpha;

	// <float mSpeed, offset 0xc>
	float mSpeed;

	// <struct tagGHMR_TEX mTex, offset 0x10>
	struct tagGHMR_TEX mTex;

	// <uint8_t mbVisible, offset 0x38>
	uint8_t mbVisible;

	// <Unidentified data segment, offset 0x39>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class HrOverLap(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrOverLap>("HrOverLap")
			.addFunction("__tostring", &HrOverLap::ToString)
			.addFunction("GetPtrAddr", &HrOverLap::GetPtrAddr)
			.addProperty("mAlloc", &HrOverLap::mAlloc)
			.addProperty("mStatus", &HrOverLap::mStatus)
			.addProperty("mAlpha", &HrOverLap::mAlpha)
			.addProperty("mSpeed", &HrOverLap::mSpeed)
			.addProperty("mTex", &HrOverLap::mTex)
			.addProperty("mbVisible", &HrOverLap::mbVisible)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrOverLap::mAlloc) == 1, "expected mAlloc to be size 1");
static_assert(sizeof(HrOverLap::mStatus) == 4, "expected mStatus to be size 4");
static_assert(sizeof(HrOverLap::mAlpha) == 4, "expected mAlpha to be size 4");
static_assert(sizeof(HrOverLap::mSpeed) == 4, "expected mSpeed to be size 4");
static_assert(sizeof(HrOverLap::mTex) == 40, "expected mTex to be size 40");
static_assert(sizeof(HrOverLap::mbVisible) == 1, "expected mbVisible to be size 1");
static_assert(sizeof(HrOverLap) == 60, "expected class HrOverLap to be size 60");

// [Structure] class HrScreenStatus
class HrScreenStatus
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[14448];
public:

	std::string ToString() const { return "class HrScreenStatus(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrScreenStatus>("HrScreenStatus")
			.addFunction("__tostring", &HrScreenStatus::ToString)
			.addFunction("GetPtrAddr", &HrScreenStatus::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrScreenStatus) == 14448, "expected class HrScreenStatus to be size 14448");

// [Structure] class HrEffectShutter
class HrEffectShutter : public HrTask
{
public:
	// enum HrEffectShutter::D_EFFECTSHUTTER_STAT
	enum D_EFFECTSHUTTER_STAT : uint32_t
	{
		// <NONE = 0x0>
		NONE = 0,

		// <CLOSE_DO = 0x1>
		CLOSE_DO = 1,

		// <CLOSE_ED = 0x2>
		CLOSE_ED = 2,

		// <OPEN_DO = 0x3>
		OPEN_DO = 3,

		// <OPEN_ED = 0x4>
		OPEN_ED = 4

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <enum HrEffectShutter::D_EFFECTSHUTTER_STAT m_Stat, offset 0x50>
	enum HrEffectShutter::D_EFFECTSHUTTER_STAT m_Stat;

	// <int16_t m_Counter, offset 0x54>
	int16_t m_Counter;

	// <int16_t m_OpenTime, offset 0x56>
	int16_t m_OpenTime;

	// <int16_t m_CloseTime, offset 0x58>
	int16_t m_CloseTime;

	// <Unidentified data segment, offset 0x5a>
private:
	char _UnidentifiedData[2];
public:

	std::string ToString() const { return "class HrEffectShutter(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrEffectShutter, HrTask>("HrEffectShutter")
			.addFunction("__tostring", &HrEffectShutter::ToString)
			.addFunction("GetPtrAddr", &HrEffectShutter::GetPtrAddr)
			.addProperty("m_Stat", &HrEffectShutter::m_Stat)
			.addProperty("m_Counter", &HrEffectShutter::m_Counter)
			.addProperty("m_OpenTime", &HrEffectShutter::m_OpenTime)
			.addProperty("m_CloseTime", &HrEffectShutter::m_CloseTime)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrEffectShutter::m_Stat) == 4, "expected m_Stat to be size 4");
static_assert(sizeof(HrEffectShutter::m_Counter) == 2, "expected m_Counter to be size 2");
static_assert(sizeof(HrEffectShutter::m_OpenTime) == 2, "expected m_OpenTime to be size 2");
static_assert(sizeof(HrEffectShutter::m_CloseTime) == 2, "expected m_CloseTime to be size 2");
static_assert(sizeof(HrEffectShutter) == 92, "expected class HrEffectShutter to be size 92");

// [Structure] class EfSmoke
class EfSmoke : public HrTask
{
public:
	// [Structure] struct EfSmoke::SmokePrim
	struct SmokePrim
	{
	public:
		/// Struct member variables

		// <struct Vec Pos, offset 0x0>
		struct Vec Pos;

		// <struct Vec Mov, offset 0xc>
		struct Vec Mov;

		// <uint32_t Color, offset 0x18>
		uint32_t Color;

		// <float Scale, offset 0x1c>
		float Scale;

		// <float ScaleAdd, offset 0x20>
		float ScaleAdd;

		// <float Speed, offset 0x24>
		float Speed;

		// <float SpeedAdd, offset 0x28>
		float SpeedAdd;

		// <float Alpha, offset 0x2c>
		float Alpha;

		// <float Rot, offset 0x30>
		float Rot;

		// <float RotSpeed, offset 0x34>
		float RotSpeed;

		// <uint32_t Cnt, offset 0x38>
		uint32_t Cnt;

		// <uint32_t FadeStartTick, offset 0x3c>
		uint32_t FadeStartTick;

		// <float FadeValue, offset 0x40>
		float FadeValue;

		// <EfSmoke::SmokePrim* pNext, offset 0x44>
		SmokePrim* pNext;

		// <EfSmoke::SmokePrim* pPrev, offset 0x48>
		SmokePrim* pPrev;

		std::string ToString() const { return "struct SmokePrim(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EfSmoke::SmokePrim>("EfSmoke_SmokePrim")
				.addFunction("__tostring", &EfSmoke::SmokePrim::ToString)
				.addFunction("GetPtrAddr", &EfSmoke::SmokePrim::GetPtrAddr)
				.addProperty("Pos", &EfSmoke::SmokePrim::Pos)
				.addProperty("Mov", &EfSmoke::SmokePrim::Mov)
				.addProperty("Color", &EfSmoke::SmokePrim::Color)
				.addProperty("Scale", &EfSmoke::SmokePrim::Scale)
				.addProperty("ScaleAdd", &EfSmoke::SmokePrim::ScaleAdd)
				.addProperty("Speed", &EfSmoke::SmokePrim::Speed)
				.addProperty("SpeedAdd", &EfSmoke::SmokePrim::SpeedAdd)
				.addProperty("Alpha", &EfSmoke::SmokePrim::Alpha)
				.addProperty("Rot", &EfSmoke::SmokePrim::Rot)
				.addProperty("RotSpeed", &EfSmoke::SmokePrim::RotSpeed)
				.addProperty("Cnt", &EfSmoke::SmokePrim::Cnt)
				.addProperty("FadeStartTick", &EfSmoke::SmokePrim::FadeStartTick)
				.addProperty("FadeValue", &EfSmoke::SmokePrim::FadeValue)
				.addProperty("pNext", &EfSmoke::SmokePrim::pNext)
				.addProperty("pPrev", &EfSmoke::SmokePrim::pPrev)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EfSmoke::SmokePrim::Pos) == 12, "expected Pos to be size 12");
	static_assert(sizeof(EfSmoke::SmokePrim::Mov) == 12, "expected Mov to be size 12");
	static_assert(sizeof(EfSmoke::SmokePrim::Color) == 4, "expected Color to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Scale) == 4, "expected Scale to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::ScaleAdd) == 4, "expected ScaleAdd to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Speed) == 4, "expected Speed to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::SpeedAdd) == 4, "expected SpeedAdd to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Alpha) == 4, "expected Alpha to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Rot) == 4, "expected Rot to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::RotSpeed) == 4, "expected RotSpeed to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::Cnt) == 4, "expected Cnt to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::FadeStartTick) == 4, "expected FadeStartTick to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::FadeValue) == 4, "expected FadeValue to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::pNext) == 4, "expected pNext to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim::pPrev) == 4, "expected pPrev to be size 4");
	static_assert(sizeof(EfSmoke::SmokePrim) == 76, "expected struct EfSmoke::SmokePrim to be size 76");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <struct EfSmoke::SmokePrim* mpPrimAry, offset 0x68>
	struct EfSmoke::SmokePrim* mpPrimAry;

	// <struct EfSmoke::SmokePrim* mpValidList, offset 0x6c>
	struct EfSmoke::SmokePrim* mpValidList;

	// <struct EfSmoke::SmokePrim* mpActiveList, offset 0x70>
	struct EfSmoke::SmokePrim* mpActiveList;

	// <struct tagGHMR_TEX* mpChangeTex, offset 0x74>
	struct tagGHMR_TEX* mpChangeTex;

	// <int32_t mActiveNum, offset 0x78>
	int32_t mActiveNum;

	// <enum GHMR_BLEND mBlendMode, offset 0x7c>
	enum GHMR_BLEND mBlendMode;

	std::string ToString() const { return "class EfSmoke(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfSmoke, HrTask>("EfSmoke")
			.addFunction("__tostring", &EfSmoke::ToString)
			.addFunction("GetPtrAddr", &EfSmoke::GetPtrAddr)
			.addProperty("field_50", &EfSmoke::field_50)
			.addProperty("mpPrimAry", &EfSmoke::mpPrimAry)
			.addProperty("mpValidList", &EfSmoke::mpValidList)
			.addProperty("mpActiveList", &EfSmoke::mpActiveList)
			.addProperty("mpChangeTex", &EfSmoke::mpChangeTex)
			.addProperty("mActiveNum", &EfSmoke::mActiveNum)
			.addProperty("mBlendMode", &EfSmoke::mBlendMode)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfSmoke::field_50) == 24, "expected field_50 to be size 24");
static_assert(sizeof(EfSmoke::mpPrimAry) == 4, "expected mpPrimAry to be size 4");
static_assert(sizeof(EfSmoke::mpValidList) == 4, "expected mpValidList to be size 4");
static_assert(sizeof(EfSmoke::mpActiveList) == 4, "expected mpActiveList to be size 4");
static_assert(sizeof(EfSmoke::mpChangeTex) == 4, "expected mpChangeTex to be size 4");
static_assert(sizeof(EfSmoke::mActiveNum) == 4, "expected mActiveNum to be size 4");
static_assert(sizeof(EfSmoke::mBlendMode) == 4, "expected mBlendMode to be size 4");
static_assert(sizeof(EfSmoke) == 128, "expected class EfSmoke to be size 128");

// [Structure] struct HRSAVEDATA_DEBUNEKO
struct HRSAVEDATA_DEBUNEKO
{
public:
	/// Struct member variables

	// <uint8_t boEndTraining[0x5], offset 0x0>
	uint8_t boEndTraining[5];

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData1[3];

public:
	// <int32_t CatWeight, offset 0x8>
	int32_t CatWeight;

	// <int32_t CatMood, offset 0xc>
	int32_t CatMood;

	std::string ToString() const { return "struct HRSAVEDATA_DEBUNEKO(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HRSAVEDATA_DEBUNEKO>("HRSAVEDATA_DEBUNEKO")
			.addFunction("__tostring", &HRSAVEDATA_DEBUNEKO::ToString)
			.addFunction("GetPtrAddr", &HRSAVEDATA_DEBUNEKO::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("boEndTraining", &HRSAVEDATA_DEBUNEKO::boEndTraining)
			.addProperty("CatWeight", &HRSAVEDATA_DEBUNEKO::CatWeight)
			.addProperty("CatMood", &HRSAVEDATA_DEBUNEKO::CatMood)
		.endClass();
	}
#endif
};
static_assert(sizeof(HRSAVEDATA_DEBUNEKO::boEndTraining) == 5, "expected boEndTraining to be size 5");
static_assert(sizeof(HRSAVEDATA_DEBUNEKO::CatWeight) == 4, "expected CatWeight to be size 4");
static_assert(sizeof(HRSAVEDATA_DEBUNEKO::CatMood) == 4, "expected CatMood to be size 4");
static_assert(sizeof(HRSAVEDATA_DEBUNEKO) == 16, "expected struct HRSAVEDATA_DEBUNEKO to be size 16");

// [Structure] class WGcl
class WGcl : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <int32_t mState, offset 0x10>
	int32_t mState;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag;

	// <struct WGclSpec* mpSpec, offset 0x18>
	struct WGclSpec* mpSpec;

	// <class ghmGcColl* mpEntryColl, offset 0x1c>
	class ghmGcColl* mpEntryColl;

	// <class WGclNode* mpTopNode, offset 0x20>
	class WGclNode* mpTopNode;

	// <struct Vec mRootPosition, offset 0x24>
	struct Vec mRootPosition;

	// <struct Vec mRootRotation, offset 0x30>
	struct Vec mRootRotation;

	// <float mRootMatrix[0x3][0x4], offset 0x3c>
	float mRootMatrix[3][4];

	std::string ToString() const { return "class WGcl(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<WGcl, ghmListObj>("WGcl")
			.addFunction("__tostring", &WGcl::ToString)
			.addFunction("GetPtrAddr", &WGcl::GetPtrAddr)
			.addProperty("mState", &WGcl::mState)
			.addProperty("mFlag", &WGcl::mFlag)
			.addProperty("mpSpec", &WGcl::mpSpec)
			.addProperty("mpEntryColl", &WGcl::mpEntryColl)
			.addProperty("mpTopNode", &WGcl::mpTopNode)
			.addProperty("mRootPosition", &WGcl::mRootPosition)
			.addProperty("mRootRotation", &WGcl::mRootRotation)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mRootMatrix", &WGcl::mRootMatrix)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGcl::mState) == 4, "expected mState to be size 4");
static_assert(sizeof(WGcl::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGcl::mpSpec) == 4, "expected mpSpec to be size 4");
static_assert(sizeof(WGcl::mpEntryColl) == 4, "expected mpEntryColl to be size 4");
static_assert(sizeof(WGcl::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(WGcl::mRootPosition) == 12, "expected mRootPosition to be size 12");
static_assert(sizeof(WGcl::mRootRotation) == 12, "expected mRootRotation to be size 12");
static_assert(sizeof(WGcl::mRootMatrix) == 48, "expected mRootMatrix to be size 48");
static_assert(sizeof(WGcl) == 108, "expected class WGcl to be size 108");

// [Structure] class commonObj
class commonObj : public mHRChara
{
public:
	// [Function] uint8_t __convention("thiscall") commonObj::mSetDamage(class commonObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@commonObj@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class commonObj* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x3f1e50);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <uint8_t mCallMotionProcFlag, offset 0x580>
	uint8_t mCallMotionProcFlag;

	// <Unidentified data segment, offset 0x581>
private:
	char _UnidentifiedData2[3];

public:
	// <class WGcl mGcl, offset 0x584>
	class WGcl mGcl;

	// <uint8_t m_bIsGclExist, offset 0x5f0>
	uint8_t m_bIsGclExist;

	// <uint8_t m_bIsUseGcl, offset 0x5f1>
	uint8_t m_bIsUseGcl;

	// <uint8_t m_bActFadeInOut, offset 0x5f2>
	uint8_t m_bActFadeInOut;

	// <uint8_t m_bIsNotRequestDelete, offset 0x5f3>
	uint8_t m_bIsNotRequestDelete;

	// <class CTimeRatioInterpolate m_inFadeInOutAlpha, offset 0x5f4>
	class CTimeRatioInterpolate m_inFadeInOutAlpha;

	// <uint8_t m_bActVisibleFade, offset 0x600>
	uint8_t m_bActVisibleFade;

	// <Unidentified data segment, offset 0x601>
private:
	char _UnidentifiedData9[3];

public:
	// <float m_FadeDist, offset 0x604>
	float m_FadeDist;

	// <int32_t m_eRigidMaterialID, offset 0x608>
	int32_t m_eRigidMaterialID;

	// <uint8_t m_bActDeleteByDestroy, offset 0x60c>
	uint8_t m_bActDeleteByDestroy;

	// <uint8_t m_bIsNeedSetupMatrix, offset 0x60d>
	uint8_t m_bIsNeedSetupMatrix;

	// <Unidentified data segment, offset 0x60e>
private:
	char _UnidentifiedData13[2];

public:
	// <float m_fDestroyTimer, offset 0x610>
	float m_fDestroyTimer;

	// <uint8_t m_bIsDestroyMotLoop, offset 0x614>
	uint8_t m_bIsDestroyMotLoop;

	// <uint8_t m_bIsMiniDemoDamage, offset 0x615>
	uint8_t m_bIsMiniDemoDamage;

	// <Unidentified data segment, offset 0x616>
private:
	char _UnidentifiedData16[2];

public:
	// <float m_fDamagePower, offset 0x618>
	float m_fDamagePower;

	// <float m_fDamageYaw, offset 0x61c>
	float m_fDamageYaw;

	// <float m_fDamagePitch, offset 0x620>
	float m_fDamagePitch;

	// <uint8_t m_bIsSpreadBreak, offset 0x624>
	uint8_t m_bIsSpreadBreak;

	// <Unidentified data segment, offset 0x625>
private:
	char _UnidentifiedData20[3];

public:
	// <struct Vec m_inSpreadBreakSrcPosiOfst, offset 0x628>
	struct Vec m_inSpreadBreakSrcPosiOfst;

	// <uint8_t m_bIsSetGroundColPlane, offset 0x634>
	uint8_t m_bIsSetGroundColPlane;

	// <Unidentified data segment, offset 0x635>
private:
	char _UnidentifiedData22[3];

public:
	// <class ghmPlane m_inGroundColPlane, offset 0x638>
	class ghmPlane m_inGroundColPlane;

	// <uint8_t mbDistEraseDisable, offset 0x648>
	uint8_t mbDistEraseDisable;

	// <Unidentified data segment, offset 0x649>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class commonObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<commonObj, mHRChara>("commonObj")
			.addFunction("__tostring", &commonObj::ToString)
			.addFunction("GetPtrAddr", &commonObj::GetPtrAddr)
			.addProperty("mCallMotionProcFlag", &commonObj::mCallMotionProcFlag)
			.addProperty("mGcl", &commonObj::mGcl)
			.addProperty("m_bIsGclExist", &commonObj::m_bIsGclExist)
			.addProperty("m_bIsUseGcl", &commonObj::m_bIsUseGcl)
			.addProperty("m_bActFadeInOut", &commonObj::m_bActFadeInOut)
			.addProperty("m_bIsNotRequestDelete", &commonObj::m_bIsNotRequestDelete)
			.addProperty("m_inFadeInOutAlpha", &commonObj::m_inFadeInOutAlpha)
			.addProperty("m_bActVisibleFade", &commonObj::m_bActVisibleFade)
			.addProperty("m_FadeDist", &commonObj::m_FadeDist)
			.addProperty("m_eRigidMaterialID", &commonObj::m_eRigidMaterialID)
			.addProperty("m_bActDeleteByDestroy", &commonObj::m_bActDeleteByDestroy)
			.addProperty("m_bIsNeedSetupMatrix", &commonObj::m_bIsNeedSetupMatrix)
			.addProperty("m_fDestroyTimer", &commonObj::m_fDestroyTimer)
			.addProperty("m_bIsDestroyMotLoop", &commonObj::m_bIsDestroyMotLoop)
			.addProperty("m_bIsMiniDemoDamage", &commonObj::m_bIsMiniDemoDamage)
			.addProperty("m_fDamagePower", &commonObj::m_fDamagePower)
			.addProperty("m_fDamageYaw", &commonObj::m_fDamageYaw)
			.addProperty("m_fDamagePitch", &commonObj::m_fDamagePitch)
			.addProperty("m_bIsSpreadBreak", &commonObj::m_bIsSpreadBreak)
			.addProperty("m_inSpreadBreakSrcPosiOfst", &commonObj::m_inSpreadBreakSrcPosiOfst)
			.addProperty("m_bIsSetGroundColPlane", &commonObj::m_bIsSetGroundColPlane)
			.addProperty("m_inGroundColPlane", &commonObj::m_inGroundColPlane)
			.addProperty("mbDistEraseDisable", &commonObj::mbDistEraseDisable)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &commonObj::mSetDamage)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mSetDamage", &commonObj::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(commonObj::mCallMotionProcFlag) == 1, "expected mCallMotionProcFlag to be size 1");
static_assert(sizeof(commonObj::mGcl) == 108, "expected mGcl to be size 108");
static_assert(sizeof(commonObj::m_bIsGclExist) == 1, "expected m_bIsGclExist to be size 1");
static_assert(sizeof(commonObj::m_bIsUseGcl) == 1, "expected m_bIsUseGcl to be size 1");
static_assert(sizeof(commonObj::m_bActFadeInOut) == 1, "expected m_bActFadeInOut to be size 1");
static_assert(sizeof(commonObj::m_bIsNotRequestDelete) == 1, "expected m_bIsNotRequestDelete to be size 1");
static_assert(sizeof(commonObj::m_inFadeInOutAlpha) == 12, "expected m_inFadeInOutAlpha to be size 12");
static_assert(sizeof(commonObj::m_bActVisibleFade) == 1, "expected m_bActVisibleFade to be size 1");
static_assert(sizeof(commonObj::m_FadeDist) == 4, "expected m_FadeDist to be size 4");
static_assert(sizeof(commonObj::m_eRigidMaterialID) == 4, "expected m_eRigidMaterialID to be size 4");
static_assert(sizeof(commonObj::m_bActDeleteByDestroy) == 1, "expected m_bActDeleteByDestroy to be size 1");
static_assert(sizeof(commonObj::m_bIsNeedSetupMatrix) == 1, "expected m_bIsNeedSetupMatrix to be size 1");
static_assert(sizeof(commonObj::m_fDestroyTimer) == 4, "expected m_fDestroyTimer to be size 4");
static_assert(sizeof(commonObj::m_bIsDestroyMotLoop) == 1, "expected m_bIsDestroyMotLoop to be size 1");
static_assert(sizeof(commonObj::m_bIsMiniDemoDamage) == 1, "expected m_bIsMiniDemoDamage to be size 1");
static_assert(sizeof(commonObj::m_fDamagePower) == 4, "expected m_fDamagePower to be size 4");
static_assert(sizeof(commonObj::m_fDamageYaw) == 4, "expected m_fDamageYaw to be size 4");
static_assert(sizeof(commonObj::m_fDamagePitch) == 4, "expected m_fDamagePitch to be size 4");
static_assert(sizeof(commonObj::m_bIsSpreadBreak) == 1, "expected m_bIsSpreadBreak to be size 1");
static_assert(sizeof(commonObj::m_inSpreadBreakSrcPosiOfst) == 12, "expected m_inSpreadBreakSrcPosiOfst to be size 12");
static_assert(sizeof(commonObj::m_bIsSetGroundColPlane) == 1, "expected m_bIsSetGroundColPlane to be size 1");
static_assert(sizeof(commonObj::m_inGroundColPlane) == 16, "expected m_inGroundColPlane to be size 16");
static_assert(sizeof(commonObj::mbDistEraseDisable) == 1, "expected mbDistEraseDisable to be size 1");
static_assert(sizeof(commonObj) == 1612, "expected class commonObj to be size 1612");

// [Structure] class CustomColliderObj
class CustomColliderObj : public commonObj
{
public:
	// [Function] uint8_t __convention("thiscall") CustomColliderObj::mSetDamage(class CustomColliderObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11) [?mSetDamage@CustomColliderObj@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)
	{
		typedef uint8_t(__thiscall* _Func)(class CustomColliderObj* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11);
		_Func mFunc = (_Func)(GameModule + 0xa57d0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	// [Function] uint8_t __convention("thiscall") CustomColliderObj::mHitCheck(class CustomColliderObj* const this, class mHRChara* arg2) [?mHitCheck@CustomColliderObj@@UAE_NPAVmHRChara@@@Z]
	uint8_t mHitCheck(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class CustomColliderObj* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x5596a0);
		return mFunc(this, arg2);
	}
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class ghmGcCollObjCapsule* capsuleCollider, offset 0x64c>
	class ghmGcCollObjCapsule* capsuleCollider;

	std::string ToString() const { return "class CustomColliderObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CustomColliderObj, commonObj>("CustomColliderObj")
			.addFunction("__tostring", &CustomColliderObj::ToString)
			.addFunction("GetPtrAddr", &CustomColliderObj::GetPtrAddr)
			.addProperty("capsuleCollider", &CustomColliderObj::capsuleCollider)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &CustomColliderObj::mSetDamage)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mSetDamage", &CustomColliderObj::mSetDamage)
			.addFunction("mHitCheck", &CustomColliderObj::mHitCheck)
		.endClass();
	}
#endif
};
static_assert(sizeof(CustomColliderObj::capsuleCollider) == 4, "expected capsuleCollider to be size 4");
static_assert(sizeof(CustomColliderObj) == 1616, "expected class CustomColliderObj to be size 1616");

// [Structure] struct WGclSpec
struct WGclSpec
{
public:
	/// Struct member variables

	// <uint32_t mID, offset 0x0>
	uint32_t mID;

	// <uint32_t mVersion, offset 0x4>
	uint32_t mVersion;

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint16_t mNodeCount, offset 0xc>
	uint16_t mNodeCount;

	// <uint16_t mMaterialCount, offset 0xe>
	uint16_t mMaterialCount;

	// <struct WGclNodeSpec* mpTopNode, offset 0x10>
	struct WGclNodeSpec* mpTopNode;

	// <struct WGclMaterialSpec* mpTopMaterial, offset 0x14>
	struct WGclMaterialSpec* mpTopMaterial;

	// <uint32_t mConvVersion, offset 0x18>
	uint32_t mConvVersion;

	// <uint32_t mPad[0x5], offset 0x1c>
	uint32_t mPad[5];

	std::string ToString() const { return "struct WGclSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclSpec>("WGclSpec")
			.addFunction("__tostring", &WGclSpec::ToString)
			.addFunction("GetPtrAddr", &WGclSpec::GetPtrAddr)
			.addProperty("mID", &WGclSpec::mID)
			.addProperty("mVersion", &WGclSpec::mVersion)
			.addProperty("mFlag", &WGclSpec::mFlag)
			.addProperty("mNodeCount", &WGclSpec::mNodeCount)
			.addProperty("mMaterialCount", &WGclSpec::mMaterialCount)
			.addProperty("mpTopNode", &WGclSpec::mpTopNode)
			.addProperty("mpTopMaterial", &WGclSpec::mpTopMaterial)
			.addProperty("mConvVersion", &WGclSpec::mConvVersion)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclSpec::mID) == 4, "expected mID to be size 4");
static_assert(sizeof(WGclSpec::mVersion) == 4, "expected mVersion to be size 4");
static_assert(sizeof(WGclSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGclSpec::mNodeCount) == 2, "expected mNodeCount to be size 2");
static_assert(sizeof(WGclSpec::mMaterialCount) == 2, "expected mMaterialCount to be size 2");
static_assert(sizeof(WGclSpec::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(WGclSpec::mpTopMaterial) == 4, "expected mpTopMaterial to be size 4");
static_assert(sizeof(WGclSpec::mConvVersion) == 4, "expected mConvVersion to be size 4");
static_assert(sizeof(WGclSpec::mPad) == 20, "expected mPad to be size 20");
static_assert(sizeof(WGclSpec) == 48, "expected struct WGclSpec to be size 48");

// [Structure] struct WGclNodeSpec
struct WGclNodeSpec
{
public:
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint32_t mType, offset 0xc>
	uint32_t mType;

	// <WGclNodeSpec* mpParent, offset 0x10>
	WGclNodeSpec* mpParent;

	// <WGclNodeSpec* mpChild, offset 0x14>
	WGclNodeSpec* mpChild;

	// <WGclNodeSpec* mpPrev, offset 0x18>
	WGclNodeSpec* mpPrev;

	// <WGclNodeSpec* mpNext, offset 0x1c>
	WGclNodeSpec* mpNext;

	// <struct Vec mPosition, offset 0x20>
	struct Vec mPosition;

	// <struct Vec mRotation, offset 0x2c>
	struct Vec mRotation;

	// <struct WGclNodeShapeMeshSpec* mpMesh, offset 0x38>
	struct WGclNodeShapeMeshSpec* mpMesh;

	// <uint32_t mPad[0x5], offset 0x3c>
	uint32_t mPad[5];

	std::string ToString() const { return "struct WGclNodeSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeSpec>("WGclNodeSpec")
			.addFunction("__tostring", &WGclNodeSpec::ToString)
			.addFunction("GetPtrAddr", &WGclNodeSpec::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclNodeSpec::mIDStr)
			.addProperty("mFlag", &WGclNodeSpec::mFlag)
			.addProperty("mType", &WGclNodeSpec::mType)
			.addProperty("mpParent", &WGclNodeSpec::mpParent)
			.addProperty("mpChild", &WGclNodeSpec::mpChild)
			.addProperty("mpPrev", &WGclNodeSpec::mpPrev)
			.addProperty("mpNext", &WGclNodeSpec::mpNext)
			.addProperty("mPosition", &WGclNodeSpec::mPosition)
			.addProperty("mRotation", &WGclNodeSpec::mRotation)
			.addProperty("mpMesh", &WGclNodeSpec::mpMesh)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclNodeSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeSpec::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGclNodeSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGclNodeSpec::mType) == 4, "expected mType to be size 4");
static_assert(sizeof(WGclNodeSpec::mpParent) == 4, "expected mpParent to be size 4");
static_assert(sizeof(WGclNodeSpec::mpChild) == 4, "expected mpChild to be size 4");
static_assert(sizeof(WGclNodeSpec::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGclNodeSpec::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGclNodeSpec::mPosition) == 12, "expected mPosition to be size 12");
static_assert(sizeof(WGclNodeSpec::mRotation) == 12, "expected mRotation to be size 12");
static_assert(sizeof(WGclNodeSpec::mpMesh) == 4, "expected mpMesh to be size 4");
static_assert(sizeof(WGclNodeSpec::mPad) == 20, "expected mPad to be size 20");
static_assert(sizeof(WGclNodeSpec) == 80, "expected struct WGclNodeSpec to be size 80");

// [Structure] struct WGclNodeShapeMeshSpec
struct WGclNodeShapeMeshSpec
{
public:
	/// Struct member variables

	// <struct WGclNodeShapeMeshBspNodeSpec* mpBspTree, offset 0x0>
	struct WGclNodeShapeMeshBspNodeSpec* mpBspTree;

	// <struct WGclNodeShapeTriangleSpec* mpTriangles, offset 0x4>
	struct WGclNodeShapeTriangleSpec* mpTriangles;

	// <int32_t mNodeCount, offset 0x8>
	int32_t mNodeCount;

	// <int32_t mTriangleCount, offset 0xc>
	int32_t mTriangleCount;

	// <struct Vec mBoundingBoxCenter, offset 0x10>
	struct Vec mBoundingBoxCenter;

	// <struct Vec mBoundingBoxExtent, offset 0x1c>
	struct Vec mBoundingBoxExtent;

	std::string ToString() const { return "struct WGclNodeShapeMeshSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeMeshSpec>("WGclNodeShapeMeshSpec")
			.addFunction("__tostring", &WGclNodeShapeMeshSpec::ToString)
			.addFunction("GetPtrAddr", &WGclNodeShapeMeshSpec::GetPtrAddr)
			.addProperty("mpBspTree", &WGclNodeShapeMeshSpec::mpBspTree)
			.addProperty("mpTriangles", &WGclNodeShapeMeshSpec::mpTriangles)
			.addProperty("mNodeCount", &WGclNodeShapeMeshSpec::mNodeCount)
			.addProperty("mTriangleCount", &WGclNodeShapeMeshSpec::mTriangleCount)
			.addProperty("mBoundingBoxCenter", &WGclNodeShapeMeshSpec::mBoundingBoxCenter)
			.addProperty("mBoundingBoxExtent", &WGclNodeShapeMeshSpec::mBoundingBoxExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeShapeMeshSpec::mpBspTree) == 4, "expected mpBspTree to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mpTriangles) == 4, "expected mpTriangles to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mNodeCount) == 4, "expected mNodeCount to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mTriangleCount) == 4, "expected mTriangleCount to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mBoundingBoxCenter) == 12, "expected mBoundingBoxCenter to be size 12");
static_assert(sizeof(WGclNodeShapeMeshSpec::mBoundingBoxExtent) == 12, "expected mBoundingBoxExtent to be size 12");
static_assert(sizeof(WGclNodeShapeMeshSpec) == 40, "expected struct WGclNodeShapeMeshSpec to be size 40");

// [Structure] struct WGclNodeShapeMeshBspNodeSpec
struct WGclNodeShapeMeshBspNodeSpec
{
public:
	/// Struct member variables

	// <WGclNodeShapeMeshBspNodeSpec* mpFront, offset 0x0>
	WGclNodeShapeMeshBspNodeSpec* mpFront;

	// <WGclNodeShapeMeshBspNodeSpec* mpBack, offset 0x4>
	WGclNodeShapeMeshBspNodeSpec* mpBack;

	// <struct WGclNodeShapeTriangleSpec* mpTriangle, offset 0x8>
	struct WGclNodeShapeTriangleSpec* mpTriangle;

	// <uint16_t mTriangleCount, offset 0xc>
	uint16_t mTriangleCount;

	// <uint16_t mFlag, offset 0xe>
	uint16_t mFlag;

	// <struct Vec mNormal, offset 0x10>
	struct Vec mNormal;

	// <float mDist, offset 0x1c>
	float mDist;

	std::string ToString() const { return "struct WGclNodeShapeMeshBspNodeSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeMeshBspNodeSpec>("WGclNodeShapeMeshBspNodeSpec")
			.addFunction("__tostring", &WGclNodeShapeMeshBspNodeSpec::ToString)
			.addFunction("GetPtrAddr", &WGclNodeShapeMeshBspNodeSpec::GetPtrAddr)
			.addProperty("mpFront", &WGclNodeShapeMeshBspNodeSpec::mpFront)
			.addProperty("mpBack", &WGclNodeShapeMeshBspNodeSpec::mpBack)
			.addProperty("mpTriangle", &WGclNodeShapeMeshBspNodeSpec::mpTriangle)
			.addProperty("mTriangleCount", &WGclNodeShapeMeshBspNodeSpec::mTriangleCount)
			.addProperty("mFlag", &WGclNodeShapeMeshBspNodeSpec::mFlag)
			.addProperty("mNormal", &WGclNodeShapeMeshBspNodeSpec::mNormal)
			.addProperty("mDist", &WGclNodeShapeMeshBspNodeSpec::mDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpFront) == 4, "expected mpFront to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpBack) == 4, "expected mpBack to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpTriangle) == 4, "expected mpTriangle to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mTriangleCount) == 2, "expected mTriangleCount to be size 2");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mFlag) == 2, "expected mFlag to be size 2");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mNormal) == 12, "expected mNormal to be size 12");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mDist) == 4, "expected mDist to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec) == 32, "expected struct WGclNodeShapeMeshBspNodeSpec to be size 32");

// [Structure] struct WGclNodeShapeTriangleSpec
struct WGclNodeShapeTriangleSpec
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[48];
public:

	std::string ToString() const { return "struct WGclNodeShapeTriangleSpec(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeTriangleSpec>("WGclNodeShapeTriangleSpec")
			.addFunction("__tostring", &WGclNodeShapeTriangleSpec::ToString)
			.addFunction("GetPtrAddr", &WGclNodeShapeTriangleSpec::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeShapeTriangleSpec) == 48, "expected struct WGclNodeShapeTriangleSpec to be size 48");

// [Structure] class ghmGcColl
class ghmGcColl
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class ghmGcOctTree mOctTree, offset 0x4>
	class ghmGcOctTree mOctTree;

	std::string ToString() const { return "class ghmGcColl(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcColl>("ghmGcColl")
			.addFunction("__tostring", &ghmGcColl::ToString)
			.addFunction("GetPtrAddr", &ghmGcColl::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcColl::field_0)
			.addProperty("mOctTree", &ghmGcColl::mOctTree)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcColl::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmGcColl::mOctTree) == 12, "expected mOctTree to be size 12");
static_assert(sizeof(ghmGcColl) == 16, "expected class ghmGcColl to be size 16");

// [Structure] class WGclNode
class WGclNode
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <Unidentified data segment, offset 0x4>
private:
	char _UnidentifiedData1[4];

public:
	// <char mIDStr[0x8], offset 0x8>
	char mIDStr[8];

	// <class WGcl* mpContainer, offset 0x10>
	class WGcl* mpContainer;

	// <struct WGclNodeSpec* mpSpec, offset 0x14>
	struct WGclNodeSpec* mpSpec;

	// <class ghmGcCollObj* mpCollObj, offset 0x18>
	class ghmGcCollObj* mpCollObj;

	// <WGclNode* mpParent, offset 0x1c>
	WGclNode* mpParent;

	// <WGclNode* mpChild, offset 0x20>
	WGclNode* mpChild;

	// <WGclNode* mpNext, offset 0x24>
	WGclNode* mpNext;

	// <WGclNode* mpPrev, offset 0x28>
	WGclNode* mpPrev;

	// <struct Vec mPosition, offset 0x2c>
	struct Vec mPosition;

	// <struct Vec mRotation, offset 0x38>
	struct Vec mRotation;

	// <float mLocalWorldMatrix[0x3][0x4], offset 0x44>
	float mLocalWorldMatrix[3][4];

	// <float mWorldLocalMatrix[0x3][0x4], offset 0x74>
	float mWorldLocalMatrix[3][4];

	// <uint32_t mFlag, offset 0xa4>
	uint32_t mFlag;

	std::string ToString() const { return "class WGclNode(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNode>("WGclNode")
			.addFunction("__tostring", &WGclNode::ToString)
			.addFunction("GetPtrAddr", &WGclNode::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &WGclNode::field_0)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclNode::mIDStr)
			.addProperty("mpContainer", &WGclNode::mpContainer)
			.addProperty("mpSpec", &WGclNode::mpSpec)
			.addProperty("mpCollObj", &WGclNode::mpCollObj)
			.addProperty("mpParent", &WGclNode::mpParent)
			.addProperty("mpChild", &WGclNode::mpChild)
			.addProperty("mpNext", &WGclNode::mpNext)
			.addProperty("mpPrev", &WGclNode::mpPrev)
			.addProperty("mPosition", &WGclNode::mPosition)
			.addProperty("mRotation", &WGclNode::mRotation)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mLocalWorldMatrix", &WGclNode::mLocalWorldMatrix)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mWorldLocalMatrix", &WGclNode::mWorldLocalMatrix)
			.addProperty("mFlag", &WGclNode::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNode::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(WGclNode::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGclNode::mpContainer) == 4, "expected mpContainer to be size 4");
static_assert(sizeof(WGclNode::mpSpec) == 4, "expected mpSpec to be size 4");
static_assert(sizeof(WGclNode::mpCollObj) == 4, "expected mpCollObj to be size 4");
static_assert(sizeof(WGclNode::mpParent) == 4, "expected mpParent to be size 4");
static_assert(sizeof(WGclNode::mpChild) == 4, "expected mpChild to be size 4");
static_assert(sizeof(WGclNode::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGclNode::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGclNode::mPosition) == 12, "expected mPosition to be size 12");
static_assert(sizeof(WGclNode::mRotation) == 12, "expected mRotation to be size 12");
static_assert(sizeof(WGclNode::mLocalWorldMatrix) == 48, "expected mLocalWorldMatrix to be size 48");
static_assert(sizeof(WGclNode::mWorldLocalMatrix) == 48, "expected mWorldLocalMatrix to be size 48");
static_assert(sizeof(WGclNode::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGclNode) == 168, "expected class WGclNode to be size 168");

// [Structure] class CSpringInterpolate3D
class CSpringInterpolate3D
{
public:
	/// Struct member variables

	// <float m_fSpringCoe, offset 0x0>
	float m_fSpringCoe;

	// <float m_fMaxVel, offset 0x4>
	float m_fMaxVel;

	// <float m_fMinVel, offset 0x8>
	float m_fMinVel;

	// <uint8_t m_bIsRadiInterp, offset 0xc>
	uint8_t m_bIsRadiInterp;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData4[3];

public:
	// <float m_fEpsilon, offset 0x10>
	float m_fEpsilon;

	// <float m_fW, offset 0x14>
	float m_fW;

	// <Unidentified data segment, offset 0x18>
private:
	char _UnidentifiedData6[8];

public:
	// <class tiVector m_inValue, offset 0x20>
	class tiVector m_inValue;

	std::string ToString() const { return "class CSpringInterpolate3D(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CSpringInterpolate3D>("CSpringInterpolate3D")
			.addFunction("__tostring", &CSpringInterpolate3D::ToString)
			.addFunction("GetPtrAddr", &CSpringInterpolate3D::GetPtrAddr)
			.addProperty("m_fSpringCoe", &CSpringInterpolate3D::m_fSpringCoe)
			.addProperty("m_fMaxVel", &CSpringInterpolate3D::m_fMaxVel)
			.addProperty("m_fMinVel", &CSpringInterpolate3D::m_fMinVel)
			.addProperty("m_bIsRadiInterp", &CSpringInterpolate3D::m_bIsRadiInterp)
			.addProperty("m_fEpsilon", &CSpringInterpolate3D::m_fEpsilon)
			.addProperty("m_fW", &CSpringInterpolate3D::m_fW)
			.addProperty("m_inValue", &CSpringInterpolate3D::m_inValue)
		.endClass();
	}
#endif
};
static_assert(sizeof(CSpringInterpolate3D::m_fSpringCoe) == 4, "expected m_fSpringCoe to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fMaxVel) == 4, "expected m_fMaxVel to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fMinVel) == 4, "expected m_fMinVel to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_bIsRadiInterp) == 1, "expected m_bIsRadiInterp to be size 1");
static_assert(sizeof(CSpringInterpolate3D::m_fEpsilon) == 4, "expected m_fEpsilon to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fW) == 4, "expected m_fW to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_inValue) == 16, "expected m_inValue to be size 16");
static_assert(sizeof(CSpringInterpolate3D) == 48, "expected class CSpringInterpolate3D to be size 48");

// [Structure] class CDoubleSpringInterpolate3D
class CDoubleSpringInterpolate3D
{
public:
	/// Struct member variables

	// <class CSpringInterpolate3D m_inHopeInterp, offset 0x0>
	class CSpringInterpolate3D m_inHopeInterp;

	// <class CSpringInterpolate3D m_inCurInterp, offset 0x30>
	class CSpringInterpolate3D m_inCurInterp;

	std::string ToString() const { return "class CDoubleSpringInterpolate3D(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CDoubleSpringInterpolate3D>("CDoubleSpringInterpolate3D")
			.addFunction("__tostring", &CDoubleSpringInterpolate3D::ToString)
			.addFunction("GetPtrAddr", &CDoubleSpringInterpolate3D::GetPtrAddr)
			.addProperty("m_inHopeInterp", &CDoubleSpringInterpolate3D::m_inHopeInterp)
			.addProperty("m_inCurInterp", &CDoubleSpringInterpolate3D::m_inCurInterp)
		.endClass();
	}
#endif
};
static_assert(sizeof(CDoubleSpringInterpolate3D::m_inHopeInterp) == 48, "expected m_inHopeInterp to be size 48");
static_assert(sizeof(CDoubleSpringInterpolate3D::m_inCurInterp) == 48, "expected m_inCurInterp to be size 48");
static_assert(sizeof(CDoubleSpringInterpolate3D) == 96, "expected class CDoubleSpringInterpolate3D to be size 96");

// [Structure] class mot::CBoneEffectDamageData
namespace mot
{
	class CBoneEffectDamageData
	{
	public:
		// enum mot::CBoneEffectDamageData::EAttackType
		enum EAttackType : uint32_t
		{
			// <ATTACK_TYPE_NONE = 0x0>
			ATTACK_TYPE_NONE = 0,

			// <ATTACK_TYPE_STRAIGHT = 0x1>
			ATTACK_TYPE_STRAIGHT = 1,

			// <ATTACK_TYPE_LEFT_STRAIGHT = 0x2>
			ATTACK_TYPE_LEFT_STRAIGHT = 2,

			// <ATTACK_TYPE_RIGHT_STRAIGHT = 0x3>
			ATTACK_TYPE_RIGHT_STRAIGHT = 3,

			// <ATTACK_TYPE_LEFT_HOOK = 0x4>
			ATTACK_TYPE_LEFT_HOOK = 4,

			// <ATTACK_TYPE_RIGHT_HOOK = 0x5>
			ATTACK_TYPE_RIGHT_HOOK = 5,

			// <ATTACK_TYPE_UPPER = 0x6>
			ATTACK_TYPE_UPPER = 6,

			// <ATTACK_TYPE_LEFT_UPPER = 0x7>
			ATTACK_TYPE_LEFT_UPPER = 7,

			// <ATTACK_TYPE_RIGHT_UPPER = 0x8>
			ATTACK_TYPE_RIGHT_UPPER = 8,

			// <ATTACK_TYPE_CHOP = 0x9>
			ATTACK_TYPE_CHOP = 9,

			// <ATTACK_TYPE_LEFT_CHOP = 0xa>
			ATTACK_TYPE_LEFT_CHOP = 10,

			// <ATTACK_TYPE_RIGHT_CHOP = 0xb>
			ATTACK_TYPE_RIGHT_CHOP = 11

		};

		// enum mot::CBoneEffectDamageData::EAttackPart
		enum EAttackPart : uint32_t
		{
			// <ATTACK_PART_FACE = 0x0>
			ATTACK_PART_FACE = 0,

			// <ATTACK_PART_BODY = 0x1>
			ATTACK_PART_BODY = 1,

			// <ATTACK_PART_FOOT = 0x2>
			ATTACK_PART_FOOT = 2

		};

		// [Function] void __convention("thiscall") mot::CBoneEffectDamageData::setup(class mot::CBoneEffectDamageData* const this, class mHRChara* arg2) [?setup@CBoneEffectDamageData@mot@@QAEXPBVmHRChara@@@Z]
		void setup(class mHRChara* arg2)
		{
			typedef void(__thiscall* _Func)(class mot::CBoneEffectDamageData* const thisPtr, class mHRChara* arg2);
			_Func mFunc = (_Func)(GameModule + 0xabfa0);
			return mFunc(this, arg2);
		}
		/// Struct member variables

		// <uint8_t m_bIsHit, offset 0x0>
		uint8_t m_bIsHit;

		// <uint8_t m_bIsSuccessDefense, offset 0x1>
		uint8_t m_bIsSuccessDefense;

		// <uint8_t m_bIsKeepMyAttack, offset 0x2>
		uint8_t m_bIsKeepMyAttack;

		// <Unidentified data segment, offset 0x3>
	private:
		char _UnidentifiedData3[1];

	public:
		// <class mHRChara* m_pAttackChara, offset 0x4>
		class mHRChara* m_pAttackChara;

		// <enum mot::CBoneEffectDamageData::EAttackType m_eAttackType, offset 0x8>
		enum CBoneEffectDamageData::EAttackType m_eAttackType;

		// <enum mot::CBoneEffectDamageData::EAttackPart m_eAttackPart, offset 0xc>
		enum CBoneEffectDamageData::EAttackPart m_eAttackPart;

		std::string ToString() const { return "class CBoneEffectDamageData(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::CBoneEffectDamageData>("mot_CBoneEffectDamageData")
				.addFunction("__tostring", &mot::CBoneEffectDamageData::ToString)
				.addFunction("GetPtrAddr", &mot::CBoneEffectDamageData::GetPtrAddr)
				.addProperty("m_bIsHit", &mot::CBoneEffectDamageData::m_bIsHit)
				.addProperty("m_bIsSuccessDefense", &mot::CBoneEffectDamageData::m_bIsSuccessDefense)
				.addProperty("m_bIsKeepMyAttack", &mot::CBoneEffectDamageData::m_bIsKeepMyAttack)
				.addProperty("m_pAttackChara", &mot::CBoneEffectDamageData::m_pAttackChara)
				.addProperty("m_eAttackType", &mot::CBoneEffectDamageData::m_eAttackType)
				.addProperty("m_eAttackPart", &mot::CBoneEffectDamageData::m_eAttackPart)
				.addFunction("setup", &mot::CBoneEffectDamageData::setup)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsHit) == 1, "expected m_bIsHit to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsSuccessDefense) == 1, "expected m_bIsSuccessDefense to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsKeepMyAttack) == 1, "expected m_bIsKeepMyAttack to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_pAttackChara) == 4, "expected m_pAttackChara to be size 4");
static_assert(sizeof(mot::CBoneEffectDamageData::m_eAttackType) == 4, "expected m_eAttackType to be size 4");
static_assert(sizeof(mot::CBoneEffectDamageData::m_eAttackPart) == 4, "expected m_eAttackPart to be size 4");
static_assert(sizeof(mot::CBoneEffectDamageData) == 16, "expected class mot::CBoneEffectDamageData to be size 16");

// [Structure] class CGameDataLink
class CGameDataLink
{
public:
	/// Struct member variables

	// <class CGameData* m_pData, offset 0x0>
	class CGameData* m_pData;

	// <int32_t m_nDataIndex, offset 0x4>
	int32_t m_nDataIndex;

	// <class CGameDataManager* m_pDataManager, offset 0x8>
	class CGameDataManager* m_pDataManager;

	std::string ToString() const { return "class CGameDataLink(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameDataLink>("CGameDataLink")
			.addFunction("__tostring", &CGameDataLink::ToString)
			.addFunction("GetPtrAddr", &CGameDataLink::GetPtrAddr)
			.addProperty("m_pData", &CGameDataLink::m_pData)
			.addProperty("m_nDataIndex", &CGameDataLink::m_nDataIndex)
			.addProperty("m_pDataManager", &CGameDataLink::m_pDataManager)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameDataLink::m_pData) == 4, "expected m_pData to be size 4");
static_assert(sizeof(CGameDataLink::m_nDataIndex) == 4, "expected m_nDataIndex to be size 4");
static_assert(sizeof(CGameDataLink::m_pDataManager) == 4, "expected m_pDataManager to be size 4");
static_assert(sizeof(CGameDataLink) == 12, "expected class CGameDataLink to be size 12");

// [Structure] class mot::CBoneEffectManager
namespace mot
{
	class CBoneEffectManager
	{
	public:
		/// Struct member variables

		// <class CGameDataLink m_inDataLink, offset 0x0>
		class CGameDataLink m_inDataLink;

		// <class CStlVector<mot::IBoneEffect *> m_apBoneEffect, offset 0xc>
		class std::vector<IBoneEffect *> m_apBoneEffect;

		// <class mot::CIKManager* m_pIK, offset 0x18>
		class CIKManager* m_pIK;

		// <class mot::CYuremonoManager* m_pYuremono, offset 0x1c>
		class CYuremonoManager* m_pYuremono;

		std::string ToString() const { return "class CBoneEffectManager(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::CBoneEffectManager>("mot_CBoneEffectManager")
				.addFunction("__tostring", &mot::CBoneEffectManager::ToString)
				.addFunction("GetPtrAddr", &mot::CBoneEffectManager::GetPtrAddr)
				.addProperty("m_inDataLink", &mot::CBoneEffectManager::m_inDataLink)
				.addProperty("m_apBoneEffect", &mot::CBoneEffectManager::m_apBoneEffect)
				.addProperty("m_pIK", &mot::CBoneEffectManager::m_pIK)
				.addProperty("m_pYuremono", &mot::CBoneEffectManager::m_pYuremono)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CBoneEffectManager::m_inDataLink) == 12, "expected m_inDataLink to be size 12");
static_assert(sizeof(mot::CBoneEffectManager::m_apBoneEffect) == 12, "expected m_apBoneEffect to be size 12");
static_assert(sizeof(mot::CBoneEffectManager::m_pIK) == 4, "expected m_pIK to be size 4");
static_assert(sizeof(mot::CBoneEffectManager::m_pYuremono) == 4, "expected m_pYuremono to be size 4");
static_assert(sizeof(mot::CBoneEffectManager) == 32, "expected class mot::CBoneEffectManager to be size 32");

// [Structure] class mot::CBoneEffectPJ
namespace mot
{
	class CBoneEffectPJ : public mot::IBoneEffectPJ
	{
	public:
		// [Function] enum mot::CBoneEffectDamageData::EAttackType __convention("thiscall") mot::CBoneEffectPJ::getAttackType(class mot::CBoneEffectPJ* const this, class mHRChara* arg2) [?getAttackType@CBoneEffectPJ@mot@@QAE?AW4EAttackType@CBoneEffectDamageData@2@PBVmHRChara@@@Z]
		enum mot::CBoneEffectDamageData::EAttackType getAttackType(class mHRChara* arg2)
		{
			typedef enum mot::CBoneEffectDamageData::EAttackType(__thiscall* _Func)(class mot::CBoneEffectPJ* const thisPtr, class mHRChara* arg2);
			_Func mFunc = (_Func)(GameModule + 0xa77c0);
			return mFunc(this, arg2);
		}
		/// Struct member variables

		// <class mot::IBoneEffectPJ field_0, offset 0x0>
		// class IBoneEffectPJ Super;

		// <class mot::CBoneEffectManager m_inManager, offset 0x4>
		class CBoneEffectManager m_inManager;

		// <uint8_t m_bIsYuremonoExist, offset 0x24>
		uint8_t m_bIsYuremonoExist;

		// <uint8_t m_bActedWarp, offset 0x25>
		uint8_t m_bActedWarp;

		// <Unidentified data segment, offset 0x26>
	private:
		char _UnidentifiedData4[10];

	public:
		// <class tiMatrix m_inPreWorldMat, offset 0x30>
		class tiMatrix m_inPreWorldMat;

		// <class mot::CBoneEffectDamageData m_inDamageData, offset 0x70>
		class CBoneEffectDamageData m_inDamageData;

		// <class mot::CBoneEffectDamageData m_inPreDamageData, offset 0x80>
		class CBoneEffectDamageData m_inPreDamageData;

		// <uint8_t m_bIsAttackSideLeft, offset 0x90>
		uint8_t m_bIsAttackSideLeft;

		// <uint8_t m_bIsAttackDirSide, offset 0x91>
		uint8_t m_bIsAttackDirSide;

		// <uint8_t m_bIsNeedMoveInterp, offset 0x92>
		uint8_t m_bIsNeedMoveInterp;

		// <Unidentified data segment, offset 0x93>
	private:
		char _UnidentifiedData10[13];

	public:
		// <class CDoubleSpringInterpolate3D m_inInterpMove, offset 0xa0>
		class CDoubleSpringInterpolate3D m_inInterpMove;

		std::string ToString() const { return "class CBoneEffectPJ(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.deriveClass<mot::CBoneEffectPJ, mot::IBoneEffectPJ>("mot_CBoneEffectPJ")
				.addFunction("__tostring", &mot::CBoneEffectPJ::ToString)
				.addFunction("GetPtrAddr", &mot::CBoneEffectPJ::GetPtrAddr)
				.addProperty("m_inManager", &mot::CBoneEffectPJ::m_inManager)
				.addProperty("m_bIsYuremonoExist", &mot::CBoneEffectPJ::m_bIsYuremonoExist)
				.addProperty("m_bActedWarp", &mot::CBoneEffectPJ::m_bActedWarp)
				.addProperty("m_inPreWorldMat", &mot::CBoneEffectPJ::m_inPreWorldMat)
				.addProperty("m_inDamageData", &mot::CBoneEffectPJ::m_inDamageData)
				.addProperty("m_inPreDamageData", &mot::CBoneEffectPJ::m_inPreDamageData)
				.addProperty("m_bIsAttackSideLeft", &mot::CBoneEffectPJ::m_bIsAttackSideLeft)
				.addProperty("m_bIsAttackDirSide", &mot::CBoneEffectPJ::m_bIsAttackDirSide)
				.addProperty("m_bIsNeedMoveInterp", &mot::CBoneEffectPJ::m_bIsNeedMoveInterp)
				.addProperty("m_inInterpMove", &mot::CBoneEffectPJ::m_inInterpMove)
				.addFunction("getAttackType", &mot::CBoneEffectPJ::getAttackType)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CBoneEffectPJ::m_inManager) == 32, "expected m_inManager to be size 32");
static_assert(sizeof(mot::CBoneEffectPJ::m_bIsYuremonoExist) == 1, "expected m_bIsYuremonoExist to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_bActedWarp) == 1, "expected m_bActedWarp to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_inPreWorldMat) == 64, "expected m_inPreWorldMat to be size 64");
static_assert(sizeof(mot::CBoneEffectPJ::m_inDamageData) == 16, "expected m_inDamageData to be size 16");
static_assert(sizeof(mot::CBoneEffectPJ::m_inPreDamageData) == 16, "expected m_inPreDamageData to be size 16");
static_assert(sizeof(mot::CBoneEffectPJ::m_bIsAttackSideLeft) == 1, "expected m_bIsAttackSideLeft to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_bIsAttackDirSide) == 1, "expected m_bIsAttackDirSide to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_bIsNeedMoveInterp) == 1, "expected m_bIsNeedMoveInterp to be size 1");
static_assert(sizeof(mot::CBoneEffectPJ::m_inInterpMove) == 96, "expected m_inInterpMove to be size 96");
static_assert(sizeof(mot::CBoneEffectPJ) == 256, "expected class mot::CBoneEffectPJ to be size 256");

// [Structure] class CGameData
class CGameData
{
public:
	/// Struct member variables

	// <int32_t m_nID, offset 0x0>
	int32_t m_nID;

	// <int32_t m_nRefCounter, offset 0x4>
	int32_t m_nRefCounter;

	// <class CPackFileDataElement* m_pData, offset 0x8>
	class CPackFileDataElement* m_pData;

	// <int32_t m_nDataClassSize, offset 0xc>
	int32_t m_nDataClassSize;

	// <int32_t m_nTotalDataClass, offset 0x10>
	int32_t m_nTotalDataClass;

	std::string ToString() const { return "class CGameData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameData>("CGameData")
			.addFunction("__tostring", &CGameData::ToString)
			.addFunction("GetPtrAddr", &CGameData::GetPtrAddr)
			.addProperty("m_nID", &CGameData::m_nID)
			.addProperty("m_nRefCounter", &CGameData::m_nRefCounter)
			.addProperty("m_pData", &CGameData::m_pData)
			.addProperty("m_nDataClassSize", &CGameData::m_nDataClassSize)
			.addProperty("m_nTotalDataClass", &CGameData::m_nTotalDataClass)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameData::m_nID) == 4, "expected m_nID to be size 4");
static_assert(sizeof(CGameData::m_nRefCounter) == 4, "expected m_nRefCounter to be size 4");
static_assert(sizeof(CGameData::m_pData) == 4, "expected m_pData to be size 4");
static_assert(sizeof(CGameData::m_nDataClassSize) == 4, "expected m_nDataClassSize to be size 4");
static_assert(sizeof(CGameData::m_nTotalDataClass) == 4, "expected m_nTotalDataClass to be size 4");
static_assert(sizeof(CGameData) == 20, "expected class CGameData to be size 20");

// [Structure] class CPackFileDataElement
class CPackFileDataElement
{
public:
	/// Struct member variables

	// <char const* m_sName, offset 0x0>
	char const* m_sName;

	// <uint32_t m_nSize, offset 0x4>
	uint32_t m_nSize;

	// <void const* m_pContent, offset 0x8>
	void const* m_pContent;

	// <uint8_t m_endianSwapped, offset 0xc>
	uint8_t m_endianSwapped;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class CPackFileDataElement(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CPackFileDataElement>("CPackFileDataElement")
			.addFunction("__tostring", &CPackFileDataElement::ToString)
			.addFunction("GetPtrAddr", &CPackFileDataElement::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_sName", &CPackFileDataElement::m_sName)
			.addProperty("m_nSize", &CPackFileDataElement::m_nSize)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("m_pContent", &CPackFileDataElement::m_pContent)
			.addProperty("m_endianSwapped", &CPackFileDataElement::m_endianSwapped)
		.endClass();
	}
#endif
};
static_assert(sizeof(CPackFileDataElement::m_sName) == 4, "expected m_sName to be size 4");
static_assert(sizeof(CPackFileDataElement::m_nSize) == 4, "expected m_nSize to be size 4");
static_assert(sizeof(CPackFileDataElement::m_pContent) == 4, "expected m_pContent to be size 4");
static_assert(sizeof(CPackFileDataElement::m_endianSwapped) == 1, "expected m_endianSwapped to be size 1");
static_assert(sizeof(CPackFileDataElement) == 16, "expected class CPackFileDataElement to be size 16");

// [Structure] class CFileData
class CFileData
{
public:
	/// Struct member variables

	// <int32_t m_nSize, offset 0x0>
	int32_t m_nSize;

	// <void* m_pData, offset 0x4>
	void* m_pData;

	// <class CStlVector<unsigned char> m_abyData, offset 0x8>
	class std::vector<unsigned char> m_abyData;

	std::string ToString() const { return "class CFileData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CFileData>("CFileData")
			.addFunction("__tostring", &CFileData::ToString)
			.addFunction("GetPtrAddr", &CFileData::GetPtrAddr)
			.addProperty("m_nSize", &CFileData::m_nSize)
			// void type not supported in LuaBridge
			//.addProperty("m_pData", &CFileData::m_pData)
			.addProperty("m_abyData", &CFileData::m_abyData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CFileData::m_nSize) == 4, "expected m_nSize to be size 4");
static_assert(sizeof(CFileData::m_pData) == 4, "expected m_pData to be size 4");
static_assert(sizeof(CFileData::m_abyData) == 12, "expected m_abyData to be size 12");
static_assert(sizeof(CFileData) == 20, "expected class CFileData to be size 20");

// [Structure] class CPackFileData
class CPackFileData
{
public:
	/// Struct member variables

	// <class CFileData m_inPackData, offset 0x0>
	class CFileData m_inPackData;

	// <class CStlVector<CPackFileDataElement> m_ainElement, offset 0x14>
	class std::vector<CPackFileDataElement> m_ainElement;

	std::string ToString() const { return "class CPackFileData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CPackFileData>("CPackFileData")
			.addFunction("__tostring", &CPackFileData::ToString)
			.addFunction("GetPtrAddr", &CPackFileData::GetPtrAddr)
			.addProperty("m_inPackData", &CPackFileData::m_inPackData)
			.addProperty("m_ainElement", &CPackFileData::m_ainElement)
		.endClass();
	}
#endif
};
static_assert(sizeof(CPackFileData::m_inPackData) == 20, "expected m_inPackData to be size 20");
static_assert(sizeof(CPackFileData::m_ainElement) == 12, "expected m_ainElement to be size 12");
static_assert(sizeof(CPackFileData) == 32, "expected class CPackFileData to be size 32");

// [Structure] class CGameDataManager
class CGameDataManager
{
public:
	/// Struct member variables

	// <class CPackFileData m_inGDPackData, offset 0x0>
	class CPackFileData m_inGDPackData;

	// <class CStlVector<CGameData> m_ainData, offset 0x20>
	class std::vector<CGameData> m_ainData;

	std::string ToString() const { return "class CGameDataManager(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameDataManager>("CGameDataManager")
			.addFunction("__tostring", &CGameDataManager::ToString)
			.addFunction("GetPtrAddr", &CGameDataManager::GetPtrAddr)
			.addProperty("m_inGDPackData", &CGameDataManager::m_inGDPackData)
			.addProperty("m_ainData", &CGameDataManager::m_ainData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameDataManager::m_inGDPackData) == 32, "expected m_inGDPackData to be size 32");
static_assert(sizeof(CGameDataManager::m_ainData) == 12, "expected m_ainData to be size 12");
static_assert(sizeof(CGameDataManager) == 44, "expected class CGameDataManager to be size 44");

// [Structure] class mot::IBoneEffect
namespace mot
{
	class IBoneEffect
	{
	public:
		/// Struct member variables

		// <void* (* field_0)[0xa], offset 0x0>
		void* (* field_0)[0xa];

		std::string ToString() const { return "class IBoneEffect(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::IBoneEffect>("mot_IBoneEffect")
				.addFunction("__tostring", &mot::IBoneEffect::ToString)
				.addFunction("GetPtrAddr", &mot::IBoneEffect::GetPtrAddr)
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &mot::IBoneEffect::field_0)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffect::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(mot::IBoneEffect) == 4, "expected class mot::IBoneEffect to be size 4");

// [Structure] class mot::CIKManager
namespace mot
{
	class CIKManager
	{
	public:
		/// Struct member variables

		// <class mot::CBoneEffectManager* m_pBoneEffectManager, offset 0x0>
		class CBoneEffectManager* m_pBoneEffectManager;

		// <class CGameDataLink m_inDamagePartDataLink, offset 0x4>
		class CGameDataLink m_inDamagePartDataLink;

		std::string ToString() const { return "class CIKManager(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::CIKManager>("mot_CIKManager")
				.addFunction("__tostring", &mot::CIKManager::ToString)
				.addFunction("GetPtrAddr", &mot::CIKManager::GetPtrAddr)
				.addProperty("m_pBoneEffectManager", &mot::CIKManager::m_pBoneEffectManager)
				.addProperty("m_inDamagePartDataLink", &mot::CIKManager::m_inDamagePartDataLink)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CIKManager::m_pBoneEffectManager) == 4, "expected m_pBoneEffectManager to be size 4");
static_assert(sizeof(mot::CIKManager::m_inDamagePartDataLink) == 12, "expected m_inDamagePartDataLink to be size 12");
static_assert(sizeof(mot::CIKManager) == 16, "expected class mot::CIKManager to be size 16");

// [Structure] class mot::CYuremonoManager
namespace mot
{
	class CYuremonoManager
	{
	public:
		/// Struct member variables

		// <class mot::CBoneEffectManager* m_pBoneEffectManager, offset 0x0>
		class CBoneEffectManager* m_pBoneEffectManager;

		std::string ToString() const { return "class CYuremonoManager(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::CYuremonoManager>("mot_CYuremonoManager")
				.addFunction("__tostring", &mot::CYuremonoManager::ToString)
				.addFunction("GetPtrAddr", &mot::CYuremonoManager::GetPtrAddr)
				.addProperty("m_pBoneEffectManager", &mot::CYuremonoManager::m_pBoneEffectManager)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CYuremonoManager::m_pBoneEffectManager) == 4, "expected m_pBoneEffectManager to be size 4");
static_assert(sizeof(mot::CYuremonoManager) == 4, "expected class mot::CYuremonoManager to be size 4");

// [Structure] class mHRLockOnList
class mHRLockOnList : public ghmListObj
{
public:
	// [Function] class mHRChara* __convention("thiscall") mHRLockOnList::mGetCharaPtr(class mHRLockOnList* const this) [?mGetCharaPtr@mHRLockOnList@@QAEPAVmHRChara@@XZ]
	class mHRChara* mGetCharaPtr()
	{
		typedef class mHRChara*(__thiscall* _Func)(class mHRLockOnList* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xaab80);
		return mFunc(this);
	}
	// [Function] uint8_t mHRLockOnList::mCheckEntry(class mHRChara* arg1) [?mCheckEntry@mHRLockOnList@@SA_NPAVmHRChara@@@Z]
	static uint8_t mCheckEntry(class mHRChara* arg1)
	{
		typedef uint8_t(__fastcall* _Func)(class mHRChara* arg1);
		_Func mFunc = (_Func)(GameModule + 0x567850);
		return mFunc(arg1);
	}
	// [Function] void mHRLockOnList::mAddList(class mHRChara* arg1) [?mAddList@mHRLockOnList@@SAXPAVmHRChara@@@Z]
	static void mAddList(class mHRChara* arg1)
	{
		typedef void(__fastcall* _Func)(class mHRChara* arg1);
		_Func mFunc = (_Func)(GameModule + 0x567880);
		return mFunc(arg1);
	}
	// [Function] void mHRLockOnList::mDelList(class mHRChara* arg1) [?mDelList@mHRLockOnList@@SAXPAVmHRChara@@@Z]
	static void mDelList(class mHRChara* arg1)
	{
		typedef void(__fastcall* _Func)(class mHRChara* arg1);
		_Func mFunc = (_Func)(GameModule + 0x567910);
		return mFunc(arg1);
	}
	// [Function] class mHRLockOnList* mHRLockOnList::mGetNextTatget(class mHRChara* arg1) [?mGetNextTatget@mHRLockOnList@@SAPAV1@PAVmHRChara@@@Z]
	static class mHRLockOnList* mGetNextTatget(class mHRChara* arg1)
	{
		typedef class mHRLockOnList*(__fastcall* _Func)(class mHRChara* arg1);
		_Func mFunc = (_Func)(GameModule + 0x567940);
		return mFunc(arg1);
	}
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class mHRChara* mpChara, offset 0x10>
	class mHRChara* mpChara;

	std::string ToString() const { return "class mHRLockOnList(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<mHRLockOnList, ghmListObj>("mHRLockOnList")
			.addFunction("__tostring", &mHRLockOnList::ToString)
			.addFunction("GetPtrAddr", &mHRLockOnList::GetPtrAddr)
			.addProperty("mpChara", &mHRLockOnList::mpChara)
			.addFunction("mGetCharaPtr", &mHRLockOnList::mGetCharaPtr)
			.addStaticFunction("mCheckEntry", &mHRLockOnList::mCheckEntry)
			.addStaticFunction("mAddList", &mHRLockOnList::mAddList)
			.addStaticFunction("mDelList", &mHRLockOnList::mDelList)
			.addStaticFunction("mGetNextTatget", &mHRLockOnList::mGetNextTatget)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRLockOnList::mpChara) == 4, "expected mpChara to be size 4");
static_assert(sizeof(mHRLockOnList) == 20, "expected class mHRLockOnList to be size 20");

// [Structure] class EffectEnemyDamage
class EffectEnemyDamage : public HrTask
{
public:
	// [Function] class EffectEnemyDamage* EffectEnemyDamage::Create(class mHRChara* arg1, class TGmf* arg2, int32_t arg3, uint32_t const arg4) [?Create@EffectEnemyDamage@@SAPAV1@PAVmHRChara@@PAVTGmf@@HI@Z]
	static class EffectEnemyDamage* Create(class mHRChara* arg1, class TGmf* arg2, int32_t arg3, uint32_t const arg4)
	{
		typedef class EffectEnemyDamage*(__fastcall* _Func)(class mHRChara* arg1, class TGmf* arg2, int32_t arg3, uint32_t const arg4);
		_Func mFunc = (_Func)(GameModule + 0x585710);
		return mFunc(arg1, arg2, arg3, arg4);
	}
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pChara, offset 0x50>
	class mHRChara* m_pChara;

	// <class TGmf* m_pGmf, offset 0x54>
	class TGmf* m_pGmf;

	// <int32_t m_nUpSpeed, offset 0x58>
	int32_t m_nUpSpeed;

	// <uint32_t m_nColorMin, offset 0x5c>
	uint32_t m_nColorMin;

	// <int32_t m_nBright, offset 0x60>
	int32_t m_nBright;

	std::string ToString() const { return "class EffectEnemyDamage(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectEnemyDamage, HrTask>("EffectEnemyDamage")
			.addFunction("__tostring", &EffectEnemyDamage::ToString)
			.addFunction("GetPtrAddr", &EffectEnemyDamage::GetPtrAddr)
			.addProperty("m_pChara", &EffectEnemyDamage::m_pChara)
			.addProperty("m_pGmf", &EffectEnemyDamage::m_pGmf)
			.addProperty("m_nUpSpeed", &EffectEnemyDamage::m_nUpSpeed)
			.addProperty("m_nColorMin", &EffectEnemyDamage::m_nColorMin)
			.addProperty("m_nBright", &EffectEnemyDamage::m_nBright)
			.addStaticFunction("Create", &EffectEnemyDamage::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectEnemyDamage::m_pChara) == 4, "expected m_pChara to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_pGmf) == 4, "expected m_pGmf to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nUpSpeed) == 4, "expected m_nUpSpeed to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nColorMin) == 4, "expected m_nColorMin to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nBright) == 4, "expected m_nBright to be size 4");
static_assert(sizeof(EffectEnemyDamage) == 100, "expected class EffectEnemyDamage to be size 100");

// [Structure] class HrMap
class HrMap
{
public:
	// [Function] uint8_t __convention("thiscall") HrMap::IsDied(class HrMap* const this, class mHRChara* arg2) [?IsDied@HrMap@@IAE_NPAVmHRChara@@@Z]
	uint8_t IsDied(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class HrMap* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0xaceb0);
		return mFunc(this, arg2);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[7844];
public:

	std::string ToString() const { return "class HrMap(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrMap>("HrMap")
			.addFunction("__tostring", &HrMap::ToString)
			.addFunction("GetPtrAddr", &HrMap::GetPtrAddr)
			.addFunction("IsDied", &HrMap::IsDied)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMap) == 7844, "expected class HrMap to be size 7844");

// [Structure] struct stThrowInfo
struct stThrowInfo
{
public:
	/// Struct member variables

	// <float targetRotation, offset 0x0>
	float targetRotation;

	// <struct Vec basePosition, offset 0x4>
	struct Vec basePosition;

	// <struct Vec targetPosition, offset 0x10>
	struct Vec targetPosition;

	// <struct Vec addMovPosition, offset 0x1c>
	struct Vec addMovPosition;

	// <struct Vec addPcMovPosition, offset 0x28>
	struct Vec addPcMovPosition;

	// <int32_t slowMotionNo, offset 0x34>
	int32_t slowMotionNo;

	// <int32_t slowTick, offset 0x38>
	int32_t slowTick;

	// <uint8_t setThrowDamage, offset 0x3c>
	uint8_t setThrowDamage;

	// <Unidentified data segment, offset 0x3d>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "struct stThrowInfo(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stThrowInfo>("stThrowInfo")
			.addFunction("__tostring", &stThrowInfo::ToString)
			.addFunction("GetPtrAddr", &stThrowInfo::GetPtrAddr)
			.addProperty("targetRotation", &stThrowInfo::targetRotation)
			.addProperty("basePosition", &stThrowInfo::basePosition)
			.addProperty("targetPosition", &stThrowInfo::targetPosition)
			.addProperty("addMovPosition", &stThrowInfo::addMovPosition)
			.addProperty("addPcMovPosition", &stThrowInfo::addPcMovPosition)
			.addProperty("slowMotionNo", &stThrowInfo::slowMotionNo)
			.addProperty("slowTick", &stThrowInfo::slowTick)
			.addProperty("setThrowDamage", &stThrowInfo::setThrowDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(stThrowInfo::targetRotation) == 4, "expected targetRotation to be size 4");
static_assert(sizeof(stThrowInfo::basePosition) == 12, "expected basePosition to be size 12");
static_assert(sizeof(stThrowInfo::targetPosition) == 12, "expected targetPosition to be size 12");
static_assert(sizeof(stThrowInfo::addMovPosition) == 12, "expected addMovPosition to be size 12");
static_assert(sizeof(stThrowInfo::addPcMovPosition) == 12, "expected addPcMovPosition to be size 12");
static_assert(sizeof(stThrowInfo::slowMotionNo) == 4, "expected slowMotionNo to be size 4");
static_assert(sizeof(stThrowInfo::slowTick) == 4, "expected slowTick to be size 4");
static_assert(sizeof(stThrowInfo::setThrowDamage) == 1, "expected setThrowDamage to be size 1");
static_assert(sizeof(stThrowInfo) == 64, "expected struct stThrowInfo to be size 64");

// [Structure] class HrMessage
/// <summary>
/// Related to the top banner UI messages.
/// </summary>
class HrMessage : public ghmListObj
{
public:
	// enum HrMessage::MESS_STATUS_ID
	enum MESS_STATUS_ID : uint32_t
	{
		// <MESS_STS_IDLE = 0x0>
		MESS_STS_IDLE = 0,

		// <MESS_STS_DISP = 0x1>
		MESS_STS_DISP = 1,

		// <MESS_STS_PAUSE = 0x2>
		MESS_STS_PAUSE = 2,

		// <MESS_STS_END = 0x3>
		MESS_STS_END = 3,

		// <MESS_STS_MAX = 0x4>
		MESS_STS_MAX = 4

	};

	// [Function] class ghmGcFont* __convention("thiscall") HrMessage::_GetFont(class HrMessage* const this) [?_GetFont@HrMessage@@IAEPAVghmGcFont@@XZ]
	class ghmGcFont* _GetFont()
	{
		typedef class ghmGcFont*(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb36a0);
		return mFunc(this);
	}
	// [Function] enum HrMessage::MESS_STATUS_ID __convention("thiscall") HrMessage::_GetStatus(class HrMessage* const this) [?_GetStatus@HrMessage@@IAE?AW4MESS_STATUS_ID@1@XZ]
	enum HrMessage::MESS_STATUS_ID _GetStatus()
	{
		typedef enum HrMessage::MESS_STATUS_ID(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb3710);
		return mFunc(this);
	}
	// [Function] class HrMessage* __convention("thiscall") HrMessage::GetNext(class HrMessage* const this) [?GetNext@HrMessage@@QAEPAV1@XZ]
	class HrMessage* GetNext()
	{
		typedef class HrMessage*(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb3720);
		return mFunc(this);
	}
	// [Function] class WGdl* __convention("thiscall") HrMessage::_GetGdl(class HrMessage* const this) [?_GetGdl@HrMessage@@IAEPAVWGdl@@XZ]
	class WGdl* _GetGdl()
	{
		typedef class WGdl*(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb3730);
		return mFunc(this);
	}
	// [Function] uint32_t __convention("thiscall") HrMessage::GetHandle(class HrMessage* const this) [?GetHandle@HrMessage@@QAEIXZ]
	uint32_t GetHandle()
	{
		typedef uint32_t(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb3740);
		return mFunc(this);
	}
	// [Function] void HrMessage::StartMessage(uint32_t arg1, int32_t arg2, uint32_t arg3, uint8_t arg4) [?StartMessage@HrMessage@@SAXIHI_N@Z]
	static void StartMessage(uint32_t arg1, int32_t arg2, uint32_t arg3, uint8_t arg4)
	{
		typedef void(__fastcall* _Func)(uint32_t arg1, int32_t arg2, uint32_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x4896f0);
		return mFunc(arg1, arg2, arg3, arg4);
	}
	// [Function] void HrMessage::RenderProcess(void* arg1) [?RenderProcess@HrMessage@@SAXPAX@Z]
	static void RenderProcess(void* arg1)
	{
		typedef void(__fastcall* _Func)(void* arg1);
		_Func mFunc = (_Func)(GameModule + 0x489810);
		return mFunc(arg1);
	}
	// [Function] void __convention("thiscall") HrMessage::Render(class HrMessage* const this) [?Render@HrMessage@@IAEXXZ]
	void Render()
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x489860);
		return mFunc(this);
	}
	// [Function] struct GdlDialog* __convention("thiscall") HrMessage::GetDialog(class HrMessage* const this) [?GetDialog@HrMessage@@QAEPAUGdlDialog@@XZ]
	struct GdlDialog* GetDialog()
	{
		typedef struct GdlDialog*(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x489890);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMessage::Frame(class HrMessage* const this) [?Frame@HrMessage@@IAEXXZ]
	void Frame()
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4898a0);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMessage::DispLine_RenderProcess(class HrMessage* const this) [?DispLine_RenderProcess@HrMessage@@IAEXXZ]
	void DispLine_RenderProcess()
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4899c0);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::DispLine_FrameProcess(class HrMessage* const this) [?DispLine_FrameProcess@HrMessage@@IAE_NXZ]
	uint8_t DispLine_FrameProcess()
	{
		typedef uint8_t(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4899e0);
		return mFunc(this);
	}
	// [Function] void HrMessage::GetStrLengthW(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6) [?GetStrLengthW@HrMessage@@SAXIPBDHHAAM1@Z]
	static void GetStrLengthW(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef void(__fastcall* _Func)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6);
		_Func mFunc = (_Func)(GameModule + 0x489a60);
		return mFunc(arg1, arg2_c_str, arg3, arg4, arg5, arg6);
	}
	// [Function] void HrMessage::GetStrLength(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6) [?GetStrLength@HrMessage@@SAXIPBDHHAAM1@Z]
	static void GetStrLength(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef void(__fastcall* _Func)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float& arg5, float& arg6);
		_Func mFunc = (_Func)(GameModule + 0x489c60);
		return mFunc(arg1, arg2_c_str, arg3, arg4, arg5, arg6);
	}
	// [Function] void HrMessage::GetTick(uint32_t arg1, char const* arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5) [?GetTick@HrMessage@@SAXIPBDHAAI1@Z]
	static void GetTick(uint32_t arg1, std::string arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef void(__fastcall* _Func)(uint32_t arg1, char const* arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5);
		_Func mFunc = (_Func)(GameModule + 0x489e90);
		return mFunc(arg1, arg2_c_str, arg3, arg4, arg5);
	}
	// [Function] void __convention("thiscall") HrMessage::_GetTick(class HrMessage* const this, int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5) [?_GetTick@HrMessage@@IAEXHHAAI0@Z]
	void _GetTick(int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5)
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3, uint32_t& arg4, uint32_t& arg5);
		_Func mFunc = (_Func)(GameModule + 0x489f50);
		return mFunc(this, arg2, arg3, arg4, arg5);
	}
	// [Function] void HrMessage::SetFontFuti(uint32_t arg1, int32_t arg2, struct GXColor arg3) [?SetFontFuti@HrMessage@@SAXIHUGXColor@@@Z]
	static void SetFontFuti(uint32_t arg1, int32_t arg2, struct GXColor arg3)
	{
		typedef void(__fastcall* _Func)(uint32_t arg1, int32_t arg2, struct GXColor arg3);
		_Func mFunc = (_Func)(GameModule + 0x489fd0);
		return mFunc(arg1, arg2, arg3);
	}
	// [Function] void __convention("thiscall") HrMessage::_SetFontFuti(class HrMessage* const this, int32_t arg2, struct GXColor arg3) [?_SetFontFuti@HrMessage@@IAEXHUGXColor@@@Z]
	void _SetFontFuti(int32_t arg2, struct GXColor arg3)
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr, int32_t arg2, struct GXColor arg3);
		_Func mFunc = (_Func)(GameModule + 0x48a020);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void HrMessage::SetFontEx(uint32_t arg1, float arg2) [?SetFontEx@HrMessage@@SAXIM@Z]
	static void SetFontEx(uint32_t arg1, float arg2)
	{
		typedef void(__fastcall* _Func)(uint32_t arg1, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x48a040);
		return mFunc(arg1, arg2);
	}
	// [Function] void __convention("thiscall") HrMessage::_SetFontEx(class HrMessage* const this, float arg2) [?_SetFontEx@HrMessage@@IAEXM@Z]
	void _SetFontEx(float arg2)
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x48a080);
		return mFunc(this, arg2);
	}
	// [Function] int16_t const* HrMessage::GetStringsW(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4) [?GetStringsW@HrMessage@@SAPB_SIPBDHH@Z]
	// Can't export pointer to native type 'int16_t const*' [TypeClass.PointerTypeClass] in LuaBridge
	static void GetStringsW(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef int16_t const*(__fastcall* _Func)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x48a0a0);
		mFunc(arg1, arg2_c_str, arg3, arg4);
	}
	// [Function] char const* HrMessage::GetStrings(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4) [?GetStrings@HrMessage@@SAPBDIPBDHH@Z]
	// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
	static void GetStrings(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef char const*(__fastcall* _Func)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x48a120);
		mFunc(arg1, arg2_c_str, arg3, arg4);
	}
	// [Function] int16_t const* __convention("thiscall") HrMessage::_GetStringsW(class HrMessage* const this, int32_t arg2, int32_t arg3, int32_t arg4) [?_GetStringsW@HrMessage@@IAEPB_SHHH@Z]
	// Can't export pointer to native type 'int16_t const*' [TypeClass.PointerTypeClass] in LuaBridge
	void _GetStringsW(int32_t arg2, int32_t arg3, int32_t arg4)
	{
		typedef int16_t const*(__thiscall* _Func)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3, int32_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x48a1a0);
		mFunc(this, arg2, arg3, arg4);
	}
	// [Function] char const* __convention("thiscall") HrMessage::_GetStrings(class HrMessage* const this, int32_t arg2, int32_t arg3, int32_t arg4) [?_GetStrings@HrMessage@@IAEPBDHHH@Z]
	// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
	void _GetStrings(int32_t arg2, int32_t arg3, int32_t arg4)
	{
		typedef char const*(__thiscall* _Func)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3, int32_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x48a210);
		mFunc(this, arg2, arg3, arg4);
	}
	// [Function] float HrMessage::DispMessage(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10) [?DispMessage@HrMessage@@SAMIPBDHHMMUGXColor@@HH_N@Z]
	static float DispMessage(uint32_t arg1, std::string arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef float(__fastcall* _Func)(uint32_t arg1, char const* arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10);
		_Func mFunc = (_Func)(GameModule + 0x48a280);
		return mFunc(arg1, arg2_c_str, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] class ghmGcFont* HrMessage::GetFont(uint32_t arg1) [?GetFont@HrMessage@@SAPAVghmGcFont@@I@Z]
	static class ghmGcFont* GetFont(uint32_t arg1)
	{
		typedef class ghmGcFont*(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48a360);
		return mFunc(arg1);
	}
	// [Function] class WGdl* HrMessage::GetGdl(uint32_t arg1) [?GetGdl@HrMessage@@SAPAVWGdl@@I@Z]
	static class WGdl* GetGdl(uint32_t arg1)
	{
		typedef class WGdl*(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48a390);
		return mFunc(arg1);
	}
	// [Function] int32_t HrMessage::GetSentenceNum(uint32_t arg1, char const* arg2, int32_t arg3) [?GetSentenceNum@HrMessage@@SAHIPBDH@Z]
	static int32_t GetSentenceNum(uint32_t arg1, std::string arg2, int32_t arg3)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef int32_t(__fastcall* _Func)(uint32_t arg1, char const* arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x48a3c0);
		return mFunc(arg1, arg2_c_str, arg3);
	}
	// [Function] int32_t HrMessage::GetLineNum(uint32_t arg1, char const* arg2) [?GetLineNum@HrMessage@@SAHIPBD@Z]
	static int32_t GetLineNum(uint32_t arg1, std::string arg2)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef int32_t(__fastcall* _Func)(uint32_t arg1, char const* arg2);
		_Func mFunc = (_Func)(GameModule + 0x48a450);
		return mFunc(arg1, arg2_c_str);
	}
	// [Function] int32_t __convention("thiscall") HrMessage::_GetSentenceNum(class HrMessage* const this, int32_t arg2, int32_t arg3) [?_GetSentenceNum@HrMessage@@IAEHHH@Z]
	int32_t _GetSentenceNum(int32_t arg2, int32_t arg3)
	{
		typedef int32_t(__thiscall* _Func)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x48a510);
		return mFunc(this, arg2, arg3);
	}
	// [Function] int32_t __convention("thiscall") HrMessage::_GetLineNum(class HrMessage* const this, int32_t arg2) [?_GetLineNum@HrMessage@@IAEHH@Z]
	int32_t _GetLineNum(int32_t arg2)
	{
		typedef int32_t(__thiscall* _Func)(class HrMessage* const thisPtr, int32_t arg2);
		_Func mFunc = (_Func)(GameModule + 0x48a570);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::_DispChar(class HrMessage* const this, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, float arg7, struct GXColor arg8, uint8_t arg9) [?_DispChar@HrMessage@@IAE_NHHHHMMUGXColor@@_N@Z]
	uint8_t _DispChar(int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, float arg7, struct GXColor arg8, uint8_t arg9)
	{
		typedef uint8_t(__thiscall* _Func)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, float arg7, struct GXColor arg8, uint8_t arg9);
		_Func mFunc = (_Func)(GameModule + 0x48a5b0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
	}
	// [Function] float __convention("thiscall") HrMessage::_DispMessage(class HrMessage* const this, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10) [?_DispMessage@HrMessage@@IAEMHHHMMUGXColor@@HH_N@Z]
	float _DispMessage(int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10)
	{
		typedef float(__thiscall* _Func)(class HrMessage* const thisPtr, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6, struct GXColor arg7, int32_t arg8, int32_t arg9, uint8_t arg10);
		_Func mFunc = (_Func)(GameModule + 0x48a6a0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] void __convention("thiscall") HrMessage::_Stop(class HrMessage* const this) [?_Stop@HrMessage@@IAEXXZ]
	void _Stop()
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x48aa70);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::SetMessage(class HrMessage* const this, char const* arg2, uint32_t arg3, uint8_t arg4) [?SetMessage@HrMessage@@QAE_NPBDI_N@Z]
	uint8_t SetMessage(std::string arg2, uint32_t arg3, uint8_t arg4)
	{
		char const* arg2_c_str = arg2.c_str();
		typedef uint8_t(__thiscall* _Func)(class HrMessage* const thisPtr, char const* arg2, uint32_t arg3, uint8_t arg4);
		_Func mFunc = (_Func)(GameModule + 0x48aaa0);
		return mFunc(this, arg2_c_str, arg3, arg4);
	}
	// [Function] void __convention("thiscall") HrMessage::_DePause(class HrMessage* const this) [?_DePause@HrMessage@@IAEXXZ]
	void _DePause()
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x48ad10);
		return mFunc(this);
	}
	// [Function] void __convention("thiscall") HrMessage::_Pause(class HrMessage* const this) [?_Pause@HrMessage@@IAEXXZ]
	void _Pause()
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x48ad20);
		return mFunc(this);
	}
	// [Function] uint8_t __convention("thiscall") HrMessage::SetFont(class HrMessage* const this, class ghmGcFont* arg2) [?SetFont@HrMessage@@QAE_NPAVghmGcFont@@@Z]
	uint8_t SetFont(class ghmGcFont* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class HrMessage* const thisPtr, class ghmGcFont* arg2);
		_Func mFunc = (_Func)(GameModule + 0x48ad30);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") HrMessage::_SetPlayTick(class HrMessage* const this, float arg2) [?_SetPlayTick@HrMessage@@IAEXM@Z]
	void _SetPlayTick(float arg2)
	{
		typedef void(__thiscall* _Func)(class HrMessage* const thisPtr, float arg2);
		_Func mFunc = (_Func)(GameModule + 0x48ad80);
		return mFunc(this, arg2);
	}
	// [Function] int32_t HrMessage::GetDialogoNum(uint32_t arg1) [?GetDialogoNum@HrMessage@@SAHI@Z]
	static int32_t GetDialogoNum(uint32_t arg1)
	{
		typedef int32_t(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48ad90);
		return mFunc(arg1);
	}
	// [Function] uint8_t HrMessage::IsMessage() [?IsMessage@HrMessage@@SA_NXZ]
	static uint8_t IsMessage()
	{
		typedef uint8_t(__fastcall* _Func)();
		_Func mFunc = (_Func)(GameModule + 0x48b0c0);
		return mFunc();
	}
	// [Function] void HrMessage::SetPlayTick(float arg1) [?SetPlayTick@HrMessage@@SAXM@Z]
	static void SetPlayTick(float arg1)
	{
		typedef void(__fastcall* _Func)(float arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b0f0);
		return mFunc(arg1);
	}
	// [Function] void HrMessage::Pause(uint32_t arg1) [?Pause@HrMessage@@SAXI@Z]
	static void Pause(uint32_t arg1)
	{
		typedef void(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b110);
		return mFunc(arg1);
	}
	// [Function] void HrMessage::DePause(uint32_t arg1) [?DePause@HrMessage@@SAXI@Z]
	static void DePause(uint32_t arg1)
	{
		typedef void(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b140);
		return mFunc(arg1);
	}
	// [Function] uint8_t HrMessage::IsMessageEnd(uint32_t arg1) [?IsMessageEnd@HrMessage@@SA_NI@Z]
	static uint8_t IsMessageEnd(uint32_t arg1)
	{
		typedef uint8_t(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b170);
		return mFunc(arg1);
	}
	// [Function] uint32_t HrMessage::Create(void* arg1) [?Create@HrMessage@@SAIPAX@Z]
	static uint32_t Create(void* arg1)
	{
		typedef uint32_t(__fastcall* _Func)(void* arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b1b0);
		return mFunc(arg1);
	}
	// [Function] class HrMessage* HrMessage::GetObjectA(uint32_t arg1) [?GetObjectA@HrMessage@@SAPAV1@I@Z]
	static class HrMessage* GetObjectA(uint32_t arg1)
	{
		typedef class HrMessage*(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b220);
		return mFunc(arg1);
	}
	// [Function] void HrMessage::Stop(uint32_t arg1) [?Stop@HrMessage@@SAXI@Z]
	static void Stop(uint32_t arg1)
	{
		typedef void(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b2d0);
		return mFunc(arg1);
	}
	// [Function] void HrMessage::Delete(uint32_t arg1) [?Delete@HrMessage@@SAXI@Z]
	static void Delete(uint32_t arg1)
	{
		typedef void(__fastcall* _Func)(uint32_t arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b310);
		return mFunc(arg1);
	}
	// [Function] class ghmResGroup* HrMessage::GetLangageGroup(class ghmResGroup* arg1) [?GetLangageGroup@HrMessage@@SAPAVghmResGroup@@PAV2@@Z]
	static class ghmResGroup* GetLangageGroup(class ghmResGroup* arg1)
	{
		typedef class ghmResGroup*(__fastcall* _Func)(class ghmResGroup* arg1);
		_Func mFunc = (_Func)(GameModule + 0x48b490);
		return mFunc(arg1);
	}
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class ghmListObj m_Anchor, offset 0x10>
	class ghmListObj m_Anchor;

	// <uint32_t m_Handle, offset 0x20>
	uint32_t m_Handle;

	// <enum HrMessage::MESS_STATUS_ID m_Status, offset 0x24>
	enum HrMessage::MESS_STATUS_ID m_Status;

	// <class ghmGcFont* mp_Font, offset 0x28>
	class ghmGcFont* mp_Font;

	// <class ghmGcFont* m_pFont, offset 0x2c>
	class ghmGcFont* m_pFont;

	// <class WGdl* mp_Gdl, offset 0x30>
	class WGdl* mp_Gdl;

	// <uint32_t m_NowTick, offset 0x34>
	uint32_t m_NowTick;

	// <struct GdlDialog* m_pCurrentDialog, offset 0x38>
	struct GdlDialog* m_pCurrentDialog;

	std::string ToString() const { return "class HrMessage(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMessage, ghmListObj>("HrMessage")
			.addFunction("__tostring", &HrMessage::ToString)
			.addFunction("GetPtrAddr", &HrMessage::GetPtrAddr)
			.addProperty("m_Anchor", &HrMessage::m_Anchor)
			.addProperty("m_Handle", &HrMessage::m_Handle)
			.addProperty("m_Status", &HrMessage::m_Status)
			.addProperty("mp_Font", &HrMessage::mp_Font)
			.addProperty("m_pFont", &HrMessage::m_pFont)
			.addProperty("mp_Gdl", &HrMessage::mp_Gdl)
			.addProperty("m_NowTick", &HrMessage::m_NowTick)
			.addProperty("m_pCurrentDialog", &HrMessage::m_pCurrentDialog)
			.addFunction("_GetFont", &HrMessage::_GetFont)
			.addFunction("_GetStatus", &HrMessage::_GetStatus)
			.addFunction("GetNext", &HrMessage::GetNext)
			.addFunction("_GetGdl", &HrMessage::_GetGdl)
			.addFunction("GetHandle", &HrMessage::GetHandle)
			.addStaticFunction("StartMessage", &HrMessage::StartMessage)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("RenderProcess", &HrMessage::RenderProcess)
			.addFunction("Render", &HrMessage::Render)
			.addFunction("GetDialog", &HrMessage::GetDialog)
			.addFunction("Frame", &HrMessage::Frame)
			.addFunction("DispLine_RenderProcess", &HrMessage::DispLine_RenderProcess)
			.addFunction("DispLine_FrameProcess", &HrMessage::DispLine_FrameProcess)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStrLengthW", &HrMessage::GetStrLengthW)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("GetStrLengthW", &HrMessage::GetStrLengthW)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("GetStrLengthW", &HrMessage::GetStrLengthW)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStrLength", &HrMessage::GetStrLength)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("GetStrLength", &HrMessage::GetStrLength)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetTick", &HrMessage::GetTick)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("GetTick", &HrMessage::GetTick)
			// Can't export pointer to native type 'uint32_t&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("_GetTick", &HrMessage::_GetTick)
			.addStaticFunction("SetFontFuti", &HrMessage::SetFontFuti)
			.addFunction("_SetFontFuti", &HrMessage::_SetFontFuti)
			.addStaticFunction("SetFontEx", &HrMessage::SetFontEx)
			.addFunction("_SetFontEx", &HrMessage::_SetFontEx)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStringsW", &HrMessage::GetStringsW)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("GetStringsW", &HrMessage::GetStringsW)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetStrings", &HrMessage::GetStrings)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("GetStrings", &HrMessage::GetStrings)
			.addFunction("_GetStringsW", &HrMessage::_GetStringsW)
			.addFunction("_GetStrings", &HrMessage::_GetStrings)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addStaticFunction("DispMessage", &HrMessage::DispMessage)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("DispMessage", &HrMessage::DispMessage)
			.addStaticFunction("GetFont", &HrMessage::GetFont)
			.addStaticFunction("GetGdl", &HrMessage::GetGdl)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetSentenceNum", &HrMessage::GetSentenceNum)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("GetSentenceNum", &HrMessage::GetSentenceNum)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("GetLineNum", &HrMessage::GetLineNum)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("GetLineNum", &HrMessage::GetLineNum)
			.addFunction("_GetSentenceNum", &HrMessage::_GetSentenceNum)
			.addFunction("_GetLineNum", &HrMessage::_GetLineNum)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("_DispChar", &HrMessage::_DispChar)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("_DispMessage", &HrMessage::_DispMessage)
			.addFunction("_Stop", &HrMessage::_Stop)
			// Can't export pointer to native type 'char const*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("SetMessage", &HrMessage::SetMessage)
			// Function overloading not supported in LuaBridge.
			//.addFunction("SetMessage", &HrMessage::SetMessage)
			.addFunction("_DePause", &HrMessage::_DePause)
			.addFunction("_Pause", &HrMessage::_Pause)
			.addFunction("SetFont", &HrMessage::SetFont)
			.addFunction("_SetPlayTick", &HrMessage::_SetPlayTick)
			.addStaticFunction("GetDialogoNum", &HrMessage::GetDialogoNum)
			.addStaticFunction("IsMessage", &HrMessage::IsMessage)
			.addStaticFunction("SetPlayTick", &HrMessage::SetPlayTick)
			.addStaticFunction("Pause", &HrMessage::Pause)
			.addStaticFunction("DePause", &HrMessage::DePause)
			.addStaticFunction("IsMessageEnd", &HrMessage::IsMessageEnd)
			// Can't export void pointer 'void*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &HrMessage::Create)
			.addStaticFunction("GetObjectA", &HrMessage::GetObjectA)
			// Function overloading not supported in LuaBridge.
			//.addFunction("SetFont", &HrMessage::SetFont)
			// Function overloading not supported in LuaBridge.
			//.addStaticFunction("StartMessage", &HrMessage::StartMessage)
			.addStaticFunction("Stop", &HrMessage::Stop)
			.addStaticFunction("Delete", &HrMessage::Delete)
			//.addStaticFunction("FrameProcess", &HrMessage::FrameProcess)
			.addStaticFunction("GetLangageGroup", &HrMessage::GetLangageGroup)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMessage::m_Anchor) == 16, "expected m_Anchor to be size 16");
static_assert(sizeof(HrMessage::m_Handle) == 4, "expected m_Handle to be size 4");
static_assert(sizeof(HrMessage::m_Status) == 4, "expected m_Status to be size 4");
static_assert(sizeof(HrMessage::mp_Font) == 4, "expected mp_Font to be size 4");
static_assert(sizeof(HrMessage::m_pFont) == 4, "expected m_pFont to be size 4");
static_assert(sizeof(HrMessage::mp_Gdl) == 4, "expected mp_Gdl to be size 4");
static_assert(sizeof(HrMessage::m_NowTick) == 4, "expected m_NowTick to be size 4");
static_assert(sizeof(HrMessage::m_pCurrentDialog) == 4, "expected m_pCurrentDialog to be size 4");
static_assert(sizeof(HrMessage) == 60, "expected class HrMessage to be size 60");

// [Structure] class ghmGcFont
class ghmGcFont
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[2616];
public:

	std::string ToString() const { return "class ghmGcFont(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcFont>("ghmGcFont")
			.addFunction("__tostring", &ghmGcFont::ToString)
			.addFunction("GetPtrAddr", &ghmGcFont::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcFont) == 2616, "expected class ghmGcFont to be size 2616");

// [Structure] class WGdl
class WGdl : public ghmListObj
{
public:
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <int32_t mState, offset 0x10>
	int32_t mState;

	// <int32_t mLoadState, offset 0x14>
	int32_t mLoadState;

	// <uint32_t mFlag, offset 0x18>
	uint32_t mFlag;

	// <uint8_t mEidian, offset 0x1c>
	uint8_t mEidian;

	// <Unidentified data segment, offset 0x1d>
private:
	char _UnidentifiedData5[3];

public:
	// <class ghmGcFile* pLoadFilePtr, offset 0x20>
	class ghmGcFile* pLoadFilePtr;

	// <int32_t LoadFileID, offset 0x24>
	int32_t LoadFileID;

	// <int32_t LoadID, offset 0x28>
	int32_t LoadID;

	// <struct GdlHeader* mpData, offset 0x2c>
	struct GdlHeader* mpData;

	// <uint32_t mTime, offset 0x30>
	uint32_t mTime;

	// <int32_t mDialogID, offset 0x34>
	int32_t mDialogID;

	// <struct GdlDialog* mpDialog, offset 0x38>
	struct GdlDialog* mpDialog;

	// <int32_t mLinesID, offset 0x3c>
	int32_t mLinesID;

	// <struct GdlLines* mpLines, offset 0x40>
	struct GdlLines* mpLines;

	std::string ToString() const { return "class WGdl(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<WGdl, ghmListObj>("WGdl")
			.addFunction("__tostring", &WGdl::ToString)
			.addFunction("GetPtrAddr", &WGdl::GetPtrAddr)
			.addProperty("mState", &WGdl::mState)
			.addProperty("mLoadState", &WGdl::mLoadState)
			.addProperty("mFlag", &WGdl::mFlag)
			.addProperty("mEidian", &WGdl::mEidian)
			.addProperty("pLoadFilePtr", &WGdl::pLoadFilePtr)
			.addProperty("LoadFileID", &WGdl::LoadFileID)
			.addProperty("LoadID", &WGdl::LoadID)
			.addProperty("mpData", &WGdl::mpData)
			.addProperty("mTime", &WGdl::mTime)
			.addProperty("mDialogID", &WGdl::mDialogID)
			.addProperty("mpDialog", &WGdl::mpDialog)
			.addProperty("mLinesID", &WGdl::mLinesID)
			.addProperty("mpLines", &WGdl::mpLines)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGdl::mState) == 4, "expected mState to be size 4");
static_assert(sizeof(WGdl::mLoadState) == 4, "expected mLoadState to be size 4");
static_assert(sizeof(WGdl::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGdl::mEidian) == 1, "expected mEidian to be size 1");
static_assert(sizeof(WGdl::pLoadFilePtr) == 4, "expected pLoadFilePtr to be size 4");
static_assert(sizeof(WGdl::LoadFileID) == 4, "expected LoadFileID to be size 4");
static_assert(sizeof(WGdl::LoadID) == 4, "expected LoadID to be size 4");
static_assert(sizeof(WGdl::mpData) == 4, "expected mpData to be size 4");
static_assert(sizeof(WGdl::mTime) == 4, "expected mTime to be size 4");
static_assert(sizeof(WGdl::mDialogID) == 4, "expected mDialogID to be size 4");
static_assert(sizeof(WGdl::mpDialog) == 4, "expected mpDialog to be size 4");
static_assert(sizeof(WGdl::mLinesID) == 4, "expected mLinesID to be size 4");
static_assert(sizeof(WGdl::mpLines) == 4, "expected mpLines to be size 4");
static_assert(sizeof(WGdl) == 68, "expected class WGdl to be size 68");

// [Structure] struct GdlHeader
struct GdlHeader
{
public:
	/// Struct member variables

	// <uint32_t mID, offset 0x0>
	uint32_t mID;

	// <uint32_t mVersion, offset 0x4>
	uint32_t mVersion;

	// <uint16_t mDialogCount, offset 0x8>
	uint16_t mDialogCount;

	// <uint16_t mStringCount, offset 0xa>
	uint16_t mStringCount;

	// <uint32_t mDialogPtr, offset 0xc>
	uint32_t mDialogPtr;

	// <struct GdlDialog** mppDialogPtrTable, offset 0x10>
	struct GdlDialog** mppDialogPtrTable;

	// <uint32_t mStringPtr, offset 0x14>
	uint32_t mStringPtr;

	// <char const** mppStringPtrTable, offset 0x18>
	char const** mppStringPtrTable;

	// <uint32_t mFlag, offset 0x1c>
	uint32_t mFlag;

	// <uint16_t mFacialAnimCount, offset 0x20>
	uint16_t mFacialAnimCount;

	// <uint16_t mStringUcCount, offset 0x22>
	uint16_t mStringUcCount;

	// <uint32_t mFacialAnimPtr, offset 0x24>
	uint32_t mFacialAnimPtr;

	// <void** mppFacialAnimPtrTable, offset 0x28>
	void** mppFacialAnimPtrTable;

	// <uint32_t mStringUcPtr, offset 0x2c>
	uint32_t mStringUcPtr;

	// <int16_t const** mppStringUcPtrTable, offset 0x30>
	int16_t const** mppStringUcPtrTable;

	// <uint32_t mPad[0x3], offset 0x34>
	uint32_t mPad[3];

	std::string ToString() const { return "struct GdlHeader(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GdlHeader>("GdlHeader")
			.addFunction("__tostring", &GdlHeader::ToString)
			.addFunction("GetPtrAddr", &GdlHeader::GetPtrAddr)
			.addProperty("mID", &GdlHeader::mID)
			.addProperty("mVersion", &GdlHeader::mVersion)
			.addProperty("mDialogCount", &GdlHeader::mDialogCount)
			.addProperty("mStringCount", &GdlHeader::mStringCount)
			.addProperty("mDialogPtr", &GdlHeader::mDialogPtr)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppDialogPtrTable", &GdlHeader::mppDialogPtrTable)
			.addProperty("mStringPtr", &GdlHeader::mStringPtr)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppStringPtrTable", &GdlHeader::mppStringPtrTable)
			.addProperty("mFlag", &GdlHeader::mFlag)
			.addProperty("mFacialAnimCount", &GdlHeader::mFacialAnimCount)
			.addProperty("mStringUcCount", &GdlHeader::mStringUcCount)
			.addProperty("mFacialAnimPtr", &GdlHeader::mFacialAnimPtr)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppFacialAnimPtrTable", &GdlHeader::mppFacialAnimPtrTable)
			.addProperty("mStringUcPtr", &GdlHeader::mStringUcPtr)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppStringUcPtrTable", &GdlHeader::mppStringUcPtrTable)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &GdlHeader::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(GdlHeader::mID) == 4, "expected mID to be size 4");
static_assert(sizeof(GdlHeader::mVersion) == 4, "expected mVersion to be size 4");
static_assert(sizeof(GdlHeader::mDialogCount) == 2, "expected mDialogCount to be size 2");
static_assert(sizeof(GdlHeader::mStringCount) == 2, "expected mStringCount to be size 2");
static_assert(sizeof(GdlHeader::mDialogPtr) == 4, "expected mDialogPtr to be size 4");
static_assert(sizeof(GdlHeader::mppDialogPtrTable) == 4, "expected mppDialogPtrTable to be size 4");
static_assert(sizeof(GdlHeader::mStringPtr) == 4, "expected mStringPtr to be size 4");
static_assert(sizeof(GdlHeader::mppStringPtrTable) == 4, "expected mppStringPtrTable to be size 4");
static_assert(sizeof(GdlHeader::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(GdlHeader::mFacialAnimCount) == 2, "expected mFacialAnimCount to be size 2");
static_assert(sizeof(GdlHeader::mStringUcCount) == 2, "expected mStringUcCount to be size 2");
static_assert(sizeof(GdlHeader::mFacialAnimPtr) == 4, "expected mFacialAnimPtr to be size 4");
static_assert(sizeof(GdlHeader::mppFacialAnimPtrTable) == 4, "expected mppFacialAnimPtrTable to be size 4");
static_assert(sizeof(GdlHeader::mStringUcPtr) == 4, "expected mStringUcPtr to be size 4");
static_assert(sizeof(GdlHeader::mppStringUcPtrTable) == 4, "expected mppStringUcPtrTable to be size 4");
static_assert(sizeof(GdlHeader::mPad) == 12, "expected mPad to be size 12");
static_assert(sizeof(GdlHeader) == 64, "expected struct GdlHeader to be size 64");

// [Structure] struct GdlDialog
struct GdlDialog
{
public:
	/// Struct member variables

	// <char const* mpName, offset 0x0>
	char const* mpName;

	// <uint16_t mLinesCount, offset 0x4>
	uint16_t mLinesCount;

	// <uint16_t mPad0, offset 0x6>
	uint16_t mPad0;

	// <struct GdlLines** mppLinesPtrTable, offset 0x8>
	struct GdlLines** mppLinesPtrTable;

	// <uint32_t mFlag, offset 0xc>
	uint32_t mFlag;

	// <uint32_t mPad[0x4], offset 0x10>
	uint32_t mPad[4];

	std::string ToString() const { return "struct GdlDialog(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GdlDialog>("GdlDialog")
			.addFunction("__tostring", &GdlDialog::ToString)
			.addFunction("GetPtrAddr", &GdlDialog::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpName", &GdlDialog::mpName)
			.addProperty("mLinesCount", &GdlDialog::mLinesCount)
			.addProperty("mPad0", &GdlDialog::mPad0)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppLinesPtrTable", &GdlDialog::mppLinesPtrTable)
			.addProperty("mFlag", &GdlDialog::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &GdlDialog::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(GdlDialog::mpName) == 4, "expected mpName to be size 4");
static_assert(sizeof(GdlDialog::mLinesCount) == 2, "expected mLinesCount to be size 2");
static_assert(sizeof(GdlDialog::mPad0) == 2, "expected mPad0 to be size 2");
static_assert(sizeof(GdlDialog::mppLinesPtrTable) == 4, "expected mppLinesPtrTable to be size 4");
static_assert(sizeof(GdlDialog::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(GdlDialog::mPad) == 16, "expected mPad to be size 16");
static_assert(sizeof(GdlDialog) == 32, "expected struct GdlDialog to be size 32");

// [Structure] struct GdlLines
struct GdlLines
{
public:
	/// Struct member variables

	// <int16_t mVoiceID, offset 0x0>
	int16_t mVoiceID;

	// <uint16_t mSentenceCount, offset 0x2>
	uint16_t mSentenceCount;

	// <struct GdlSentence** mppSentencePtrTable, offset 0x4>
	struct GdlSentence** mppSentencePtrTable;

	// <uint32_t mStartTick, offset 0x8>
	uint32_t mStartTick;

	// <uint32_t mWaitTick, offset 0xc>
	uint32_t mWaitTick;

	// <uint32_t mFlag, offset 0x10>
	uint32_t mFlag;

	// <char const* mpCharaName, offset 0x14>
	char const* mpCharaName;

	// <void* mpFacialAnim, offset 0x18>
	void* mpFacialAnim;

	// <uint32_t mPad[0x1], offset 0x1c>
	uint32_t mPad[1];

	std::string ToString() const { return "struct GdlLines(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GdlLines>("GdlLines")
			.addFunction("__tostring", &GdlLines::ToString)
			.addFunction("GetPtrAddr", &GdlLines::GetPtrAddr)
			.addProperty("mVoiceID", &GdlLines::mVoiceID)
			.addProperty("mSentenceCount", &GdlLines::mSentenceCount)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppSentencePtrTable", &GdlLines::mppSentencePtrTable)
			.addProperty("mStartTick", &GdlLines::mStartTick)
			.addProperty("mWaitTick", &GdlLines::mWaitTick)
			.addProperty("mFlag", &GdlLines::mFlag)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpCharaName", &GdlLines::mpCharaName)
			// void type not supported in LuaBridge
			//.addProperty("mpFacialAnim", &GdlLines::mpFacialAnim)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &GdlLines::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(GdlLines::mVoiceID) == 2, "expected mVoiceID to be size 2");
static_assert(sizeof(GdlLines::mSentenceCount) == 2, "expected mSentenceCount to be size 2");
static_assert(sizeof(GdlLines::mppSentencePtrTable) == 4, "expected mppSentencePtrTable to be size 4");
static_assert(sizeof(GdlLines::mStartTick) == 4, "expected mStartTick to be size 4");
static_assert(sizeof(GdlLines::mWaitTick) == 4, "expected mWaitTick to be size 4");
static_assert(sizeof(GdlLines::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(GdlLines::mpCharaName) == 4, "expected mpCharaName to be size 4");
static_assert(sizeof(GdlLines::mpFacialAnim) == 4, "expected mpFacialAnim to be size 4");
static_assert(sizeof(GdlLines::mPad) == 4, "expected mPad to be size 4");
static_assert(sizeof(GdlLines) == 32, "expected struct GdlLines to be size 32");

// [Structure] struct GdlSentence
struct GdlSentence
{
public:
	/// Struct member variables

	// <int16_t const* mpLettersUc, offset 0x0>
	int16_t const* mpLettersUc;

	// <uint32_t mFlag, offset 0x4>
	uint32_t mFlag;

	// <uint32_t mPad[0x2], offset 0x8>
	uint32_t mPad[2];

	std::string ToString() const { return "struct GdlSentence(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GdlSentence>("GdlSentence")
			.addFunction("__tostring", &GdlSentence::ToString)
			.addFunction("GetPtrAddr", &GdlSentence::GetPtrAddr)
			// pointer to const not supported in LuaBridge and needs a getter
			//.addProperty("mpLettersUc", &GdlSentence::mpLettersUc)
			.addProperty("mFlag", &GdlSentence::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &GdlSentence::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(GdlSentence::mpLettersUc) == 4, "expected mpLettersUc to be size 4");
static_assert(sizeof(GdlSentence::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(GdlSentence::mPad) == 8, "expected mPad to be size 8");
static_assert(sizeof(GdlSentence) == 16, "expected struct GdlSentence to be size 16");

// [Structure] class ACameraModeBase
class ACameraModeBase
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class CTimeRatioInterpolate m_inRatio, offset 0x4>
	class CTimeRatioInterpolate m_inRatio;

	// <uint8_t m_bIsInitRatioOne, offset 0x10>
	uint8_t m_bIsInitRatioOne;

	// <Unidentified data segment, offset 0x11>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class ACameraModeBase(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ACameraModeBase>("ACameraModeBase")
			.addFunction("__tostring", &ACameraModeBase::ToString)
			.addFunction("GetPtrAddr", &ACameraModeBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ACameraModeBase::field_0)
			.addProperty("m_inRatio", &ACameraModeBase::m_inRatio)
			.addProperty("m_bIsInitRatioOne", &ACameraModeBase::m_bIsInitRatioOne)
		.endClass();
	}
#endif
};
static_assert(sizeof(ACameraModeBase::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ACameraModeBase::m_inRatio) == 12, "expected m_inRatio to be size 12");
static_assert(sizeof(ACameraModeBase::m_bIsInitRatioOne) == 1, "expected m_bIsInitRatioOne to be size 1");
static_assert(sizeof(ACameraModeBase) == 20, "expected class ACameraModeBase to be size 20");

// [Structure] class CCameraModeLockOn
class CCameraModeLockOn : public ACameraModeBase
{
public:
	// [Function] class mHRChara* __convention("thiscall") CCameraModeLockOn::getLockOnCharacter(class CCameraModeLockOn* const this) [?getLockOnCharacter@CCameraModeLockOn@@QBEPBVmHRChara@@XZ]
	class mHRChara* getLockOnCharacter()
	{
		typedef class mHRChara*(__thiscall* _Func)(class CCameraModeLockOn* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0xb5050);
		return mFunc(this);
	}
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <class CDoubleSpringInterpolate m_inYaw, offset 0x14>
	class CDoubleSpringInterpolate m_inYaw;

	// <class CDoubleSpringInterpolate m_inPitch, offset 0x44>
	class CDoubleSpringInterpolate m_inPitch;

	// <float m_fHopeYaw, offset 0x74>
	float m_fHopeYaw;

	// <float m_fHopePitch, offset 0x78>
	float m_fHopePitch;

	// <Unidentified data segment, offset 0x7c>
private:
	char _UnidentifiedData5[4];

public:
	// <class tiVector m_inLockOnPosi, offset 0x80>
	class tiVector m_inLockOnPosi;

	// <float m_fLockOnDist, offset 0x90>
	float m_fLockOnDist;

	// <float m_fEnemySiegeRatio, offset 0x94>
	float m_fEnemySiegeRatio;

	// <uint8_t m_bIsChangeLockOnChara, offset 0x98>
	uint8_t m_bIsChangeLockOnChara;

	// <Unidentified data segment, offset 0x99>
private:
	char _UnidentifiedData9[3];

public:
	// <class mHRChara* m_pLockOnChara, offset 0x9c>
	class mHRChara* m_pLockOnChara;

	// <uint8_t m_bStgHit, offset 0xa0>
	uint8_t m_bStgHit;

	// <Unidentified data segment, offset 0xa1>
private:
	char _UnidentifiedData[15];
public:

	std::string ToString() const { return "class CCameraModeLockOn(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeLockOn, ACameraModeBase>("CCameraModeLockOn")
			.addFunction("__tostring", &CCameraModeLockOn::ToString)
			.addFunction("GetPtrAddr", &CCameraModeLockOn::GetPtrAddr)
			.addProperty("m_inYaw", &CCameraModeLockOn::m_inYaw)
			.addProperty("m_inPitch", &CCameraModeLockOn::m_inPitch)
			.addProperty("m_fHopeYaw", &CCameraModeLockOn::m_fHopeYaw)
			.addProperty("m_fHopePitch", &CCameraModeLockOn::m_fHopePitch)
			.addProperty("m_inLockOnPosi", &CCameraModeLockOn::m_inLockOnPosi)
			.addProperty("m_fLockOnDist", &CCameraModeLockOn::m_fLockOnDist)
			.addProperty("m_fEnemySiegeRatio", &CCameraModeLockOn::m_fEnemySiegeRatio)
			.addProperty("m_bIsChangeLockOnChara", &CCameraModeLockOn::m_bIsChangeLockOnChara)
			.addProperty("m_pLockOnChara", &CCameraModeLockOn::m_pLockOnChara)
			.addProperty("m_bStgHit", &CCameraModeLockOn::m_bStgHit)
			.addFunction("getLockOnCharacter", &CCameraModeLockOn::getLockOnCharacter)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeLockOn::m_inYaw) == 48, "expected m_inYaw to be size 48");
static_assert(sizeof(CCameraModeLockOn::m_inPitch) == 48, "expected m_inPitch to be size 48");
static_assert(sizeof(CCameraModeLockOn::m_fHopeYaw) == 4, "expected m_fHopeYaw to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_fHopePitch) == 4, "expected m_fHopePitch to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_inLockOnPosi) == 16, "expected m_inLockOnPosi to be size 16");
static_assert(sizeof(CCameraModeLockOn::m_fLockOnDist) == 4, "expected m_fLockOnDist to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_fEnemySiegeRatio) == 4, "expected m_fEnemySiegeRatio to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_bIsChangeLockOnChara) == 1, "expected m_bIsChangeLockOnChara to be size 1");
static_assert(sizeof(CCameraModeLockOn::m_pLockOnChara) == 4, "expected m_pLockOnChara to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_bStgHit) == 1, "expected m_bStgHit to be size 1");
static_assert(sizeof(CCameraModeLockOn) == 176, "expected class CCameraModeLockOn to be size 176");

// [Structure] struct HRSAVEDATA_SHOP
struct HRSAVEDATA_SHOP
{
public:
	/// Struct member variables

	// <uint32_t m_checkedFlag[0xd], offset 0x0>
	uint32_t m_checkedFlag[13];

	std::string ToString() const { return "struct HRSAVEDATA_SHOP(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HRSAVEDATA_SHOP>("HRSAVEDATA_SHOP")
			.addFunction("__tostring", &HRSAVEDATA_SHOP::ToString)
			.addFunction("GetPtrAddr", &HRSAVEDATA_SHOP::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_checkedFlag", &HRSAVEDATA_SHOP::m_checkedFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(HRSAVEDATA_SHOP::m_checkedFlag) == 52, "expected m_checkedFlag to be size 52");
static_assert(sizeof(HRSAVEDATA_SHOP) == 52, "expected struct HRSAVEDATA_SHOP to be size 52");

// [Structure] class CCameraVibManager
class CCameraVibManager
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[576];
public:

	std::string ToString() const { return "class CCameraVibManager(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraVibManager>("CCameraVibManager")
			.addFunction("__tostring", &CCameraVibManager::ToString)
			.addFunction("GetPtrAddr", &CCameraVibManager::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraVibManager) == 576, "expected class CCameraVibManager to be size 576");

// [Structure] class CCameraBank
class CCameraBank
{
public:
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inOfst, offset 0x0>
	class CDoubleSpringInterpolate m_inOfst;

	std::string ToString() const { return "class CCameraBank(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraBank>("CCameraBank")
			.addFunction("__tostring", &CCameraBank::ToString)
			.addFunction("GetPtrAddr", &CCameraBank::GetPtrAddr)
			.addProperty("m_inOfst", &CCameraBank::m_inOfst)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraBank::m_inOfst) == 48, "expected m_inOfst to be size 48");
static_assert(sizeof(CCameraBank) == 48, "expected class CCameraBank to be size 48");

// [Structure] class CCameraModeSubjective
class CCameraModeSubjective : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <float m_fTimer, offset 0x14>
	float m_fTimer;

	// <float m_fDisappearTimer, offset 0x18>
	float m_fDisappearTimer;

	// <Unidentified data segment, offset 0x1c>
private:
	char _UnidentifiedData3[4];

public:
	// <class tiVector m_inSrcLookAtPosi, offset 0x20>
	class tiVector m_inSrcLookAtPosi;

	// <class tiVector m_inInterpLookAtPosi, offset 0x30>
	class tiVector m_inInterpLookAtPosi;

	// <float m_fSrcDistToLookAt, offset 0x40>
	float m_fSrcDistToLookAt;

	// <float m_fInterpDistToLookAt, offset 0x44>
	float m_fInterpDistToLookAt;

	// <float m_fSrcYaw, offset 0x48>
	float m_fSrcYaw;

	// <float m_fInterpYaw, offset 0x4c>
	float m_fInterpYaw;

	// <float m_fPitch, offset 0x50>
	float m_fPitch;

	// <Unidentified data segment, offset 0x54>
private:
	char _UnidentifiedData[12];
public:

	std::string ToString() const { return "class CCameraModeSubjective(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeSubjective, ACameraModeBase>("CCameraModeSubjective")
			.addFunction("__tostring", &CCameraModeSubjective::ToString)
			.addFunction("GetPtrAddr", &CCameraModeSubjective::GetPtrAddr)
			.addProperty("m_fTimer", &CCameraModeSubjective::m_fTimer)
			.addProperty("m_fDisappearTimer", &CCameraModeSubjective::m_fDisappearTimer)
			.addProperty("m_inSrcLookAtPosi", &CCameraModeSubjective::m_inSrcLookAtPosi)
			.addProperty("m_inInterpLookAtPosi", &CCameraModeSubjective::m_inInterpLookAtPosi)
			.addProperty("m_fSrcDistToLookAt", &CCameraModeSubjective::m_fSrcDistToLookAt)
			.addProperty("m_fInterpDistToLookAt", &CCameraModeSubjective::m_fInterpDistToLookAt)
			.addProperty("m_fSrcYaw", &CCameraModeSubjective::m_fSrcYaw)
			.addProperty("m_fInterpYaw", &CCameraModeSubjective::m_fInterpYaw)
			.addProperty("m_fPitch", &CCameraModeSubjective::m_fPitch)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeSubjective::m_fTimer) == 4, "expected m_fTimer to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fDisappearTimer) == 4, "expected m_fDisappearTimer to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_inSrcLookAtPosi) == 16, "expected m_inSrcLookAtPosi to be size 16");
static_assert(sizeof(CCameraModeSubjective::m_inInterpLookAtPosi) == 16, "expected m_inInterpLookAtPosi to be size 16");
static_assert(sizeof(CCameraModeSubjective::m_fSrcDistToLookAt) == 4, "expected m_fSrcDistToLookAt to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fInterpDistToLookAt) == 4, "expected m_fInterpDistToLookAt to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fSrcYaw) == 4, "expected m_fSrcYaw to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fInterpYaw) == 4, "expected m_fInterpYaw to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fPitch) == 4, "expected m_fPitch to be size 4");
static_assert(sizeof(CCameraModeSubjective) == 96, "expected class CCameraModeSubjective to be size 96");

// [Structure] class CCameraModePetitMovie
class CCameraModePetitMovie : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData1[12];

public:
	// <class CDoubleSpringInterpolate3D m_inAngle, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAngle;

	// <uint8_t m_bAct, offset 0x80>
	uint8_t m_bAct;

	// <Unidentified data segment, offset 0x81>
private:
	char _UnidentifiedData3[3];

public:
	// <float m_fLookAtOfstX, offset 0x84>
	float m_fLookAtOfstX;

	// <float m_fLookAtOfstY, offset 0x88>
	float m_fLookAtOfstY;

	// <float m_fDistToLookAt, offset 0x8c>
	float m_fDistToLookAt;

	// <float m_fYawOfst, offset 0x90>
	float m_fYawOfst;

	// <float m_fPitchOfst, offset 0x94>
	float m_fPitchOfst;

	// <Unidentified data segment, offset 0x98>
private:
	char _UnidentifiedData[8];
public:

	std::string ToString() const { return "class CCameraModePetitMovie(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModePetitMovie, ACameraModeBase>("CCameraModePetitMovie")
			.addFunction("__tostring", &CCameraModePetitMovie::ToString)
			.addFunction("GetPtrAddr", &CCameraModePetitMovie::GetPtrAddr)
			.addProperty("m_inAngle", &CCameraModePetitMovie::m_inAngle)
			.addProperty("m_bAct", &CCameraModePetitMovie::m_bAct)
			.addProperty("m_fLookAtOfstX", &CCameraModePetitMovie::m_fLookAtOfstX)
			.addProperty("m_fLookAtOfstY", &CCameraModePetitMovie::m_fLookAtOfstY)
			.addProperty("m_fDistToLookAt", &CCameraModePetitMovie::m_fDistToLookAt)
			.addProperty("m_fYawOfst", &CCameraModePetitMovie::m_fYawOfst)
			.addProperty("m_fPitchOfst", &CCameraModePetitMovie::m_fPitchOfst)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModePetitMovie::m_inAngle) == 96, "expected m_inAngle to be size 96");
static_assert(sizeof(CCameraModePetitMovie::m_bAct) == 1, "expected m_bAct to be size 1");
static_assert(sizeof(CCameraModePetitMovie::m_fLookAtOfstX) == 4, "expected m_fLookAtOfstX to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fLookAtOfstY) == 4, "expected m_fLookAtOfstY to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fDistToLookAt) == 4, "expected m_fDistToLookAt to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fYawOfst) == 4, "expected m_fYawOfst to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fPitchOfst) == 4, "expected m_fPitchOfst to be size 4");
static_assert(sizeof(CCameraModePetitMovie) == 160, "expected class CCameraModePetitMovie to be size 160");

// [Structure] class CCameraModeCircle
class CCameraModeCircle : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <uint8_t m_bIsPlusRot, offset 0x14>
	uint8_t m_bIsPlusRot;

	// <Unidentified data segment, offset 0x15>
private:
	char _UnidentifiedData2[3];

public:
	// <float m_fRotVel, offset 0x18>
	float m_fRotVel;

	std::string ToString() const { return "class CCameraModeCircle(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeCircle, ACameraModeBase>("CCameraModeCircle")
			.addFunction("__tostring", &CCameraModeCircle::ToString)
			.addFunction("GetPtrAddr", &CCameraModeCircle::GetPtrAddr)
			.addProperty("m_bIsPlusRot", &CCameraModeCircle::m_bIsPlusRot)
			.addProperty("m_fRotVel", &CCameraModeCircle::m_fRotVel)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeCircle::m_bIsPlusRot) == 1, "expected m_bIsPlusRot to be size 1");
static_assert(sizeof(CCameraModeCircle::m_fRotVel) == 4, "expected m_fRotVel to be size 4");
static_assert(sizeof(CCameraModeCircle) == 28, "expected class CCameraModeCircle to be size 28");

// [Structure] class CCameraModeDefaultAngle
class CCameraModeDefaultAngle : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData1[12];

public:
	// <class CDoubleSpringInterpolate3D m_inAngle, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAngle;

	// <class tiVector m_inHopeAngle, offset 0x80>
	class tiVector m_inHopeAngle;

	// <uint8_t m_bIsInputButton, offset 0x90>
	uint8_t m_bIsInputButton;

	// <Unidentified data segment, offset 0x91>
private:
	char _UnidentifiedData[15];
public:

	std::string ToString() const { return "class CCameraModeDefaultAngle(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeDefaultAngle, ACameraModeBase>("CCameraModeDefaultAngle")
			.addFunction("__tostring", &CCameraModeDefaultAngle::ToString)
			.addFunction("GetPtrAddr", &CCameraModeDefaultAngle::GetPtrAddr)
			.addProperty("m_inAngle", &CCameraModeDefaultAngle::m_inAngle)
			.addProperty("m_inHopeAngle", &CCameraModeDefaultAngle::m_inHopeAngle)
			.addProperty("m_bIsInputButton", &CCameraModeDefaultAngle::m_bIsInputButton)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeDefaultAngle::m_inAngle) == 96, "expected m_inAngle to be size 96");
static_assert(sizeof(CCameraModeDefaultAngle::m_inHopeAngle) == 16, "expected m_inHopeAngle to be size 16");
static_assert(sizeof(CCameraModeDefaultAngle::m_bIsInputButton) == 1, "expected m_bIsInputButton to be size 1");
static_assert(sizeof(CCameraModeDefaultAngle) == 160, "expected class CCameraModeDefaultAngle to be size 160");

// [Structure] class CCameraModeFree
class CCameraModeFree : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <float m_fInputYaw, offset 0x14>
	float m_fInputYaw;

	// <float m_fInputPitch, offset 0x18>
	float m_fInputPitch;

	// <float m_fKeepTimer, offset 0x1c>
	float m_fKeepTimer;

	// <class CDoubleSpringInterpolate3D m_inAddYP, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAddYP;

	std::string ToString() const { return "class CCameraModeFree(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeFree, ACameraModeBase>("CCameraModeFree")
			.addFunction("__tostring", &CCameraModeFree::ToString)
			.addFunction("GetPtrAddr", &CCameraModeFree::GetPtrAddr)
			.addProperty("m_fInputYaw", &CCameraModeFree::m_fInputYaw)
			.addProperty("m_fInputPitch", &CCameraModeFree::m_fInputPitch)
			.addProperty("m_fKeepTimer", &CCameraModeFree::m_fKeepTimer)
			.addProperty("m_inAddYP", &CCameraModeFree::m_inAddYP)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeFree::m_fInputYaw) == 4, "expected m_fInputYaw to be size 4");
static_assert(sizeof(CCameraModeFree::m_fInputPitch) == 4, "expected m_fInputPitch to be size 4");
static_assert(sizeof(CCameraModeFree::m_fKeepTimer) == 4, "expected m_fKeepTimer to be size 4");
static_assert(sizeof(CCameraModeFree::m_inAddYP) == 96, "expected m_inAddYP to be size 96");
static_assert(sizeof(CCameraModeFree) == 128, "expected class CCameraModeFree to be size 128");

// [Structure] class CCameraModeNormal
class CCameraModeNormal : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <class CDoubleSpringInterpolate m_inYaw, offset 0x14>
	class CDoubleSpringInterpolate m_inYaw;

	// <class CDoubleSpringInterpolate m_inPitch, offset 0x44>
	class CDoubleSpringInterpolate m_inPitch;

	// <float m_fHopeYaw, offset 0x74>
	float m_fHopeYaw;

	// <class CTimeRatioInterpolate m_inYawRatio, offset 0x78>
	class CTimeRatioInterpolate m_inYawRatio;

	std::string ToString() const { return "class CCameraModeNormal(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeNormal, ACameraModeBase>("CCameraModeNormal")
			.addFunction("__tostring", &CCameraModeNormal::ToString)
			.addFunction("GetPtrAddr", &CCameraModeNormal::GetPtrAddr)
			.addProperty("m_inYaw", &CCameraModeNormal::m_inYaw)
			.addProperty("m_inPitch", &CCameraModeNormal::m_inPitch)
			.addProperty("m_fHopeYaw", &CCameraModeNormal::m_fHopeYaw)
			.addProperty("m_inYawRatio", &CCameraModeNormal::m_inYawRatio)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeNormal::m_inYaw) == 48, "expected m_inYaw to be size 48");
static_assert(sizeof(CCameraModeNormal::m_inPitch) == 48, "expected m_inPitch to be size 48");
static_assert(sizeof(CCameraModeNormal::m_fHopeYaw) == 4, "expected m_fHopeYaw to be size 4");
static_assert(sizeof(CCameraModeNormal::m_inYawRatio) == 12, "expected m_inYawRatio to be size 12");
static_assert(sizeof(CCameraModeNormal) == 132, "expected class CCameraModeNormal to be size 132");

// [Structure] class CCameraModeReset
class CCameraModeReset : public ACameraModeBase
{
public:
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <uint8_t m_bIsSetResetYaw, offset 0x14>
	uint8_t m_bIsSetResetYaw;

	// <Unidentified data segment, offset 0x15>
private:
	char _UnidentifiedData2[3];

public:
	// <float m_fResetYaw, offset 0x18>
	float m_fResetYaw;

	std::string ToString() const { return "class CCameraModeReset(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<CCameraModeReset, ACameraModeBase>("CCameraModeReset")
			.addFunction("__tostring", &CCameraModeReset::ToString)
			.addFunction("GetPtrAddr", &CCameraModeReset::GetPtrAddr)
			.addProperty("m_bIsSetResetYaw", &CCameraModeReset::m_bIsSetResetYaw)
			.addProperty("m_fResetYaw", &CCameraModeReset::m_fResetYaw)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeReset::m_bIsSetResetYaw) == 1, "expected m_bIsSetResetYaw to be size 1");
static_assert(sizeof(CCameraModeReset::m_fResetYaw) == 4, "expected m_fResetYaw to be size 4");
static_assert(sizeof(CCameraModeReset) == 28, "expected class CCameraModeReset to be size 28");

// [Structure] class CCameraDistToLookAt
class CCameraDistToLookAt
{
public:
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inDistToLookAt, offset 0x0>
	class CDoubleSpringInterpolate m_inDistToLookAt;

	std::string ToString() const { return "class CCameraDistToLookAt(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDistToLookAt>("CCameraDistToLookAt")
			.addFunction("__tostring", &CCameraDistToLookAt::ToString)
			.addFunction("GetPtrAddr", &CCameraDistToLookAt::GetPtrAddr)
			.addProperty("m_inDistToLookAt", &CCameraDistToLookAt::m_inDistToLookAt)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDistToLookAt::m_inDistToLookAt) == 48, "expected m_inDistToLookAt to be size 48");
static_assert(sizeof(CCameraDistToLookAt) == 48, "expected class CCameraDistToLookAt to be size 48");

// [Structure] class CCameraFollowRot
class CCameraFollowRot
{
public:
	/// Struct member variables

	// <class CDoubleSpringInterpolate3D m_inMove, offset 0x0>
	class CDoubleSpringInterpolate3D m_inMove;

	std::string ToString() const { return "class CCameraFollowRot(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraFollowRot>("CCameraFollowRot")
			.addFunction("__tostring", &CCameraFollowRot::ToString)
			.addFunction("GetPtrAddr", &CCameraFollowRot::GetPtrAddr)
			.addProperty("m_inMove", &CCameraFollowRot::m_inMove)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraFollowRot::m_inMove) == 96, "expected m_inMove to be size 96");
static_assert(sizeof(CCameraFollowRot) == 96, "expected class CCameraFollowRot to be size 96");

// [Structure] class CCameraLookAtOffset
class CCameraLookAtOffset
{
public:
	/// Struct member variables

	// <class CTimeRatioInterpolate m_inInterpCoeRatio, offset 0x0>
	class CTimeRatioInterpolate m_inInterpCoeRatio;

	// <Unidentified data segment, offset 0xc>
private:
	char _UnidentifiedData1[4];

public:
	// <class CDoubleSpringInterpolate3D m_inLocalOfst, offset 0x10>
	class CDoubleSpringInterpolate3D m_inLocalOfst;

	// <class tiVector m_inHopeLocalOfst, offset 0x70>
	class tiVector m_inHopeLocalOfst;

	// <float m_fOfstXTimer, offset 0x80>
	float m_fOfstXTimer;

	// <uint8_t m_bIsOfstRayHit, offset 0x84>
	uint8_t m_bIsOfstRayHit;

	// <Unidentified data segment, offset 0x85>
private:
	char _UnidentifiedData5[3];

public:
	// <float m_fOfstRayHitTimer, offset 0x88>
	float m_fOfstRayHitTimer;

	// <float m_fOfstRayHitOfstX, offset 0x8c>
	float m_fOfstRayHitOfstX;

	// <class tiVector m_inCamAxisX, offset 0x90>
	class tiVector m_inCamAxisX;

	// <class tiVector m_inCamAxisY, offset 0xa0>
	class tiVector m_inCamAxisY;

	// <class tiVector m_inCamAxisZ, offset 0xb0>
	class tiVector m_inCamAxisZ;

	std::string ToString() const { return "class CCameraLookAtOffset(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLookAtOffset>("CCameraLookAtOffset")
			.addFunction("__tostring", &CCameraLookAtOffset::ToString)
			.addFunction("GetPtrAddr", &CCameraLookAtOffset::GetPtrAddr)
			.addProperty("m_inInterpCoeRatio", &CCameraLookAtOffset::m_inInterpCoeRatio)
			.addProperty("m_inLocalOfst", &CCameraLookAtOffset::m_inLocalOfst)
			.addProperty("m_inHopeLocalOfst", &CCameraLookAtOffset::m_inHopeLocalOfst)
			.addProperty("m_fOfstXTimer", &CCameraLookAtOffset::m_fOfstXTimer)
			.addProperty("m_bIsOfstRayHit", &CCameraLookAtOffset::m_bIsOfstRayHit)
			.addProperty("m_fOfstRayHitTimer", &CCameraLookAtOffset::m_fOfstRayHitTimer)
			.addProperty("m_fOfstRayHitOfstX", &CCameraLookAtOffset::m_fOfstRayHitOfstX)
			.addProperty("m_inCamAxisX", &CCameraLookAtOffset::m_inCamAxisX)
			.addProperty("m_inCamAxisY", &CCameraLookAtOffset::m_inCamAxisY)
			.addProperty("m_inCamAxisZ", &CCameraLookAtOffset::m_inCamAxisZ)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLookAtOffset::m_inInterpCoeRatio) == 12, "expected m_inInterpCoeRatio to be size 12");
static_assert(sizeof(CCameraLookAtOffset::m_inLocalOfst) == 96, "expected m_inLocalOfst to be size 96");
static_assert(sizeof(CCameraLookAtOffset::m_inHopeLocalOfst) == 16, "expected m_inHopeLocalOfst to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstXTimer) == 4, "expected m_fOfstXTimer to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_bIsOfstRayHit) == 1, "expected m_bIsOfstRayHit to be size 1");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstRayHitTimer) == 4, "expected m_fOfstRayHitTimer to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstRayHitOfstX) == 4, "expected m_fOfstRayHitOfstX to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisX) == 16, "expected m_inCamAxisX to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisY) == 16, "expected m_inCamAxisY to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisZ) == 16, "expected m_inCamAxisZ to be size 16");
static_assert(sizeof(CCameraLookAtOffset) == 192, "expected class CCameraLookAtOffset to be size 192");

// [Structure] class CCameraLookAtBase
class CCameraLookAtBase
{
public:
	/// Struct member variables

	// <class tiVector m_inPosi, offset 0x0>
	class tiVector m_inPosi;

	// <class tiVector m_inPrePosi, offset 0x10>
	class tiVector m_inPrePosi;

	// <class tiVector m_inPreHopePosi, offset 0x20>
	class tiVector m_inPreHopePosi;

	// <class CDoubleSpringInterpolate3D m_inSpringCoe, offset 0x30>
	class CDoubleSpringInterpolate3D m_inSpringCoe;

	std::string ToString() const { return "class CCameraLookAtBase(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLookAtBase>("CCameraLookAtBase")
			.addFunction("__tostring", &CCameraLookAtBase::ToString)
			.addFunction("GetPtrAddr", &CCameraLookAtBase::GetPtrAddr)
			.addProperty("m_inPosi", &CCameraLookAtBase::m_inPosi)
			.addProperty("m_inPrePosi", &CCameraLookAtBase::m_inPrePosi)
			.addProperty("m_inPreHopePosi", &CCameraLookAtBase::m_inPreHopePosi)
			.addProperty("m_inSpringCoe", &CCameraLookAtBase::m_inSpringCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLookAtBase::m_inPosi) == 16, "expected m_inPosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inPrePosi) == 16, "expected m_inPrePosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inPreHopePosi) == 16, "expected m_inPreHopePosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inSpringCoe) == 96, "expected m_inSpringCoe to be size 96");
static_assert(sizeof(CCameraLookAtBase) == 144, "expected class CCameraLookAtBase to be size 144");

// [Structure] class CCameraDefaultAngle
class CCameraDefaultAngle
{
public:
	/// Struct member variables

	// <class tiVector m_inDefaultYP, offset 0x0>
	class tiVector m_inDefaultYP;

	// <uint8_t m_bActYawRot, offset 0x10>
	uint8_t m_bActYawRot;

	// <uint8_t m_bIsDownAttackPitchUp, offset 0x11>
	uint8_t m_bIsDownAttackPitchUp;

	// <Unidentified data segment, offset 0x12>
private:
	char _UnidentifiedData3[2];

public:
	// <float m_fSlopeCheckDelayTimer, offset 0x14>
	float m_fSlopeCheckDelayTimer;

	// <float m_fSlopeCheckPitchOfst, offset 0x18>
	float m_fSlopeCheckPitchOfst;

	// <int32_t m_nSlopeCheckPhase, offset 0x1c>
	int32_t m_nSlopeCheckPhase;

	// <class tiVector m_inSlopeCheckPosi, offset 0x20>
	class tiVector m_inSlopeCheckPosi;

	// <float m_fSlopeCheckYaw, offset 0x30>
	float m_fSlopeCheckYaw;

	// <Unidentified data segment, offset 0x34>
private:
	char _UnidentifiedData8[12];

public:
	// <class tiVector m_inSlopeCheckDir, offset 0x40>
	class tiVector m_inSlopeCheckDir;

	// <class tiVector m_inSlopeCheckTopPosi, offset 0x50>
	class tiVector m_inSlopeCheckTopPosi;

	std::string ToString() const { return "class CCameraDefaultAngle(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDefaultAngle>("CCameraDefaultAngle")
			.addFunction("__tostring", &CCameraDefaultAngle::ToString)
			.addFunction("GetPtrAddr", &CCameraDefaultAngle::GetPtrAddr)
			.addProperty("m_inDefaultYP", &CCameraDefaultAngle::m_inDefaultYP)
			.addProperty("m_bActYawRot", &CCameraDefaultAngle::m_bActYawRot)
			.addProperty("m_bIsDownAttackPitchUp", &CCameraDefaultAngle::m_bIsDownAttackPitchUp)
			.addProperty("m_fSlopeCheckDelayTimer", &CCameraDefaultAngle::m_fSlopeCheckDelayTimer)
			.addProperty("m_fSlopeCheckPitchOfst", &CCameraDefaultAngle::m_fSlopeCheckPitchOfst)
			.addProperty("m_nSlopeCheckPhase", &CCameraDefaultAngle::m_nSlopeCheckPhase)
			.addProperty("m_inSlopeCheckPosi", &CCameraDefaultAngle::m_inSlopeCheckPosi)
			.addProperty("m_fSlopeCheckYaw", &CCameraDefaultAngle::m_fSlopeCheckYaw)
			.addProperty("m_inSlopeCheckDir", &CCameraDefaultAngle::m_inSlopeCheckDir)
			.addProperty("m_inSlopeCheckTopPosi", &CCameraDefaultAngle::m_inSlopeCheckTopPosi)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDefaultAngle::m_inDefaultYP) == 16, "expected m_inDefaultYP to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_bActYawRot) == 1, "expected m_bActYawRot to be size 1");
static_assert(sizeof(CCameraDefaultAngle::m_bIsDownAttackPitchUp) == 1, "expected m_bIsDownAttackPitchUp to be size 1");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckDelayTimer) == 4, "expected m_fSlopeCheckDelayTimer to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckPitchOfst) == 4, "expected m_fSlopeCheckPitchOfst to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_nSlopeCheckPhase) == 4, "expected m_nSlopeCheckPhase to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckPosi) == 16, "expected m_inSlopeCheckPosi to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckYaw) == 4, "expected m_fSlopeCheckYaw to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckDir) == 16, "expected m_inSlopeCheckDir to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckTopPosi) == 16, "expected m_inSlopeCheckTopPosi to be size 16");
static_assert(sizeof(CCameraDefaultAngle) == 96, "expected class CCameraDefaultAngle to be size 96");

// [Structure] class CCameraLockOnModeData
class CCameraLockOnModeData
{
public:
	/// Struct member variables

	// <float m_fLookAtOfstMinX, offset 0x0>
	float m_fLookAtOfstMinX;

	// <float m_fLookAtOfstRatioX, offset 0x4>
	float m_fLookAtOfstRatioX;

	// <float m_fLookAtOfstMinY, offset 0x8>
	float m_fLookAtOfstMinY;

	// <float m_fLookAtOfstRatioY, offset 0xc>
	float m_fLookAtOfstRatioY;

	// <float m_fYawOfstMin, offset 0x10>
	float m_fYawOfstMin;

	// <float m_fYawOfstMax, offset 0x14>
	float m_fYawOfstMax;

	// <float m_fPitchMax, offset 0x18>
	float m_fPitchMax;

	// <float m_fPitchMin, offset 0x1c>
	float m_fPitchMin;

	// <float m_fDistToLookAtMin, offset 0x20>
	float m_fDistToLookAtMin;

	// <float m_fDistToLookAtMax, offset 0x24>
	float m_fDistToLookAtMax;

	std::string ToString() const { return "class CCameraLockOnModeData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLockOnModeData>("CCameraLockOnModeData")
			.addFunction("__tostring", &CCameraLockOnModeData::ToString)
			.addFunction("GetPtrAddr", &CCameraLockOnModeData::GetPtrAddr)
			.addProperty("m_fLookAtOfstMinX", &CCameraLockOnModeData::m_fLookAtOfstMinX)
			.addProperty("m_fLookAtOfstRatioX", &CCameraLockOnModeData::m_fLookAtOfstRatioX)
			.addProperty("m_fLookAtOfstMinY", &CCameraLockOnModeData::m_fLookAtOfstMinY)
			.addProperty("m_fLookAtOfstRatioY", &CCameraLockOnModeData::m_fLookAtOfstRatioY)
			.addProperty("m_fYawOfstMin", &CCameraLockOnModeData::m_fYawOfstMin)
			.addProperty("m_fYawOfstMax", &CCameraLockOnModeData::m_fYawOfstMax)
			.addProperty("m_fPitchMax", &CCameraLockOnModeData::m_fPitchMax)
			.addProperty("m_fPitchMin", &CCameraLockOnModeData::m_fPitchMin)
			.addProperty("m_fDistToLookAtMin", &CCameraLockOnModeData::m_fDistToLookAtMin)
			.addProperty("m_fDistToLookAtMax", &CCameraLockOnModeData::m_fDistToLookAtMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstMinX) == 4, "expected m_fLookAtOfstMinX to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstRatioX) == 4, "expected m_fLookAtOfstRatioX to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstMinY) == 4, "expected m_fLookAtOfstMinY to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstRatioY) == 4, "expected m_fLookAtOfstRatioY to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fYawOfstMin) == 4, "expected m_fYawOfstMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fYawOfstMax) == 4, "expected m_fYawOfstMax to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fPitchMax) == 4, "expected m_fPitchMax to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fPitchMin) == 4, "expected m_fPitchMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fDistToLookAtMin) == 4, "expected m_fDistToLookAtMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fDistToLookAtMax) == 4, "expected m_fDistToLookAtMax to be size 4");
static_assert(sizeof(CCameraLockOnModeData) == 40, "expected class CCameraLockOnModeData to be size 40");

// [Structure] class CCameraNormalModeData
class CCameraNormalModeData
{
public:
	/// Struct member variables

	// <float m_fFollowRotCoe, offset 0x0>
	float m_fFollowRotCoe;

	std::string ToString() const { return "class CCameraNormalModeData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraNormalModeData>("CCameraNormalModeData")
			.addFunction("__tostring", &CCameraNormalModeData::ToString)
			.addFunction("GetPtrAddr", &CCameraNormalModeData::GetPtrAddr)
			.addProperty("m_fFollowRotCoe", &CCameraNormalModeData::m_fFollowRotCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraNormalModeData::m_fFollowRotCoe) == 4, "expected m_fFollowRotCoe to be size 4");
static_assert(sizeof(CCameraNormalModeData) == 4, "expected class CCameraNormalModeData to be size 4");

// [Structure] class CCameraModeCommonData
class CCameraModeCommonData
{
public:
	/// Struct member variables

	// <float m_fLookAtOfstMinX, offset 0x0>
	float m_fLookAtOfstMinX;

	// <float m_fLookAtOfstRatioX, offset 0x4>
	float m_fLookAtOfstRatioX;

	// <float m_fLookAtOfstMinY, offset 0x8>
	float m_fLookAtOfstMinY;

	// <float m_fLookAtOfstRatioY, offset 0xc>
	float m_fLookAtOfstRatioY;

	// <float m_fLookAtOfstYDistZero, offset 0x10>
	float m_fLookAtOfstYDistZero;

	// <float m_fDefaultPitchOfst, offset 0x14>
	float m_fDefaultPitchOfst;

	// <int32_t m_bIsAddSlopePitchOfst, offset 0x18>
	int32_t m_bIsAddSlopePitchOfst;

	// <float m_fDistToLookAt, offset 0x1c>
	float m_fDistToLookAt;

	std::string ToString() const { return "class CCameraModeCommonData(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeCommonData>("CCameraModeCommonData")
			.addFunction("__tostring", &CCameraModeCommonData::ToString)
			.addFunction("GetPtrAddr", &CCameraModeCommonData::GetPtrAddr)
			.addProperty("m_fLookAtOfstMinX", &CCameraModeCommonData::m_fLookAtOfstMinX)
			.addProperty("m_fLookAtOfstRatioX", &CCameraModeCommonData::m_fLookAtOfstRatioX)
			.addProperty("m_fLookAtOfstMinY", &CCameraModeCommonData::m_fLookAtOfstMinY)
			.addProperty("m_fLookAtOfstRatioY", &CCameraModeCommonData::m_fLookAtOfstRatioY)
			.addProperty("m_fLookAtOfstYDistZero", &CCameraModeCommonData::m_fLookAtOfstYDistZero)
			.addProperty("m_fDefaultPitchOfst", &CCameraModeCommonData::m_fDefaultPitchOfst)
			.addProperty("m_bIsAddSlopePitchOfst", &CCameraModeCommonData::m_bIsAddSlopePitchOfst)
			.addProperty("m_fDistToLookAt", &CCameraModeCommonData::m_fDistToLookAt)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstMinX) == 4, "expected m_fLookAtOfstMinX to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstRatioX) == 4, "expected m_fLookAtOfstRatioX to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstMinY) == 4, "expected m_fLookAtOfstMinY to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstRatioY) == 4, "expected m_fLookAtOfstRatioY to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstYDistZero) == 4, "expected m_fLookAtOfstYDistZero to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fDefaultPitchOfst) == 4, "expected m_fDefaultPitchOfst to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_bIsAddSlopePitchOfst) == 4, "expected m_bIsAddSlopePitchOfst to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fDistToLookAt) == 4, "expected m_fDistToLookAt to be size 4");
static_assert(sizeof(CCameraModeCommonData) == 32, "expected class CCameraModeCommonData to be size 32");

// [Structure] class CCameraDataManager
class CCameraDataManager
{
public:
	/// Struct member variables

	// <int32_t m_eEventCond, offset 0x0>
	int32_t m_eEventCond;

	// <class CGameDataLink m_inModeManagerDataLink, offset 0x4>
	class CGameDataLink m_inModeManagerDataLink;

	// <class CGameDataLink m_inModeCommonDataLink, offset 0x10>
	class CGameDataLink m_inModeCommonDataLink;

	// <class CGameDataLink m_inNormalModeDataLink, offset 0x1c>
	class CGameDataLink m_inNormalModeDataLink;

	// <class CGameDataLink m_inLockOnModeDataLink, offset 0x28>
	class CGameDataLink m_inLockOnModeDataLink;

	// <class CCameraModeCommonData m_inModeCommonData, offset 0x34>
	class CCameraModeCommonData m_inModeCommonData;

	// <class CCameraNormalModeData m_inNormalModeData, offset 0x54>
	class CCameraNormalModeData m_inNormalModeData;

	// <class CCameraLockOnModeData m_inLockOnModeData, offset 0x58>
	class CCameraLockOnModeData m_inLockOnModeData;

	std::string ToString() const { return "class CCameraDataManager(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDataManager>("CCameraDataManager")
			.addFunction("__tostring", &CCameraDataManager::ToString)
			.addFunction("GetPtrAddr", &CCameraDataManager::GetPtrAddr)
			.addProperty("m_eEventCond", &CCameraDataManager::m_eEventCond)
			.addProperty("m_inModeManagerDataLink", &CCameraDataManager::m_inModeManagerDataLink)
			.addProperty("m_inModeCommonDataLink", &CCameraDataManager::m_inModeCommonDataLink)
			.addProperty("m_inNormalModeDataLink", &CCameraDataManager::m_inNormalModeDataLink)
			.addProperty("m_inLockOnModeDataLink", &CCameraDataManager::m_inLockOnModeDataLink)
			.addProperty("m_inModeCommonData", &CCameraDataManager::m_inModeCommonData)
			.addProperty("m_inNormalModeData", &CCameraDataManager::m_inNormalModeData)
			.addProperty("m_inLockOnModeData", &CCameraDataManager::m_inLockOnModeData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDataManager::m_eEventCond) == 4, "expected m_eEventCond to be size 4");
static_assert(sizeof(CCameraDataManager::m_inModeManagerDataLink) == 12, "expected m_inModeManagerDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inModeCommonDataLink) == 12, "expected m_inModeCommonDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inNormalModeDataLink) == 12, "expected m_inNormalModeDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inLockOnModeDataLink) == 12, "expected m_inLockOnModeDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inModeCommonData) == 32, "expected m_inModeCommonData to be size 32");
static_assert(sizeof(CCameraDataManager::m_inNormalModeData) == 4, "expected m_inNormalModeData to be size 4");
static_assert(sizeof(CCameraDataManager::m_inLockOnModeData) == 40, "expected m_inLockOnModeData to be size 40");
static_assert(sizeof(CCameraDataManager) == 128, "expected class CCameraDataManager to be size 128");

// [Structure] class CCameraAreaManager
class CCameraAreaManager
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[4336];
public:

	std::string ToString() const { return "class CCameraAreaManager(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraAreaManager>("CCameraAreaManager")
			.addFunction("__tostring", &CCameraAreaManager::ToString)
			.addFunction("GetPtrAddr", &CCameraAreaManager::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraAreaManager) == 4336, "expected class CCameraAreaManager to be size 4336");

// [Structure] class gameUtil::CPositionControl
namespace gameUtil
{
	class CPositionControl
	{
	public:
		/// Struct member variables

		// <class tiVector m_inPosi, offset 0x0>
		class tiVector m_inPosi;

		// <float m_fUpdateDistSqu, offset 0x10>
		float m_fUpdateDistSqu;

		// <Unidentified data segment, offset 0x14>
	private:
		char _UnidentifiedData[12];
	public:

		std::string ToString() const { return "class CPositionControl(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<gameUtil::CPositionControl>("gameUtil_CPositionControl")
				.addFunction("__tostring", &gameUtil::CPositionControl::ToString)
				.addFunction("GetPtrAddr", &gameUtil::CPositionControl::GetPtrAddr)
				.addProperty("m_inPosi", &gameUtil::CPositionControl::m_inPosi)
				.addProperty("m_fUpdateDistSqu", &gameUtil::CPositionControl::m_fUpdateDistSqu)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(gameUtil::CPositionControl::m_inPosi) == 16, "expected m_inPosi to be size 16");
static_assert(sizeof(gameUtil::CPositionControl::m_fUpdateDistSqu) == 4, "expected m_fUpdateDistSqu to be size 4");
static_assert(sizeof(gameUtil::CPositionControl) == 32, "expected class gameUtil::CPositionControl to be size 32");

// [Structure] class CCameraTarget
class CCameraTarget
{
public:
	/// Struct member variables

	// <class mot::IBoneEffectModel* m_pModel, offset 0x0>
	class mot::IBoneEffectModel* m_pModel;

	// <Unidentified data segment, offset 0x4>
private:
	char _UnidentifiedData1[12];

public:
	// <class tiVector m_inCenterPosi, offset 0x10>
	class tiVector m_inCenterPosi;

	// <float m_fYaw, offset 0x20>
	float m_fYaw;

	// <float m_fPitch, offset 0x24>
	float m_fPitch;

	// <uint8_t m_bIsIdleTime, offset 0x28>
	uint8_t m_bIsIdleTime;

	// <uint8_t m_bIsVisible, offset 0x29>
	uint8_t m_bIsVisible;

	// <uint8_t m_bIsVisibleYawExist, offset 0x2a>
	uint8_t m_bIsVisibleYawExist;

	// <Unidentified data segment, offset 0x2b>
private:
	char _UnidentifiedData7[1];

public:
	// <float m_fVisibleYaw, offset 0x2c>
	float m_fVisibleYaw;

	// <class gameUtil::CPositionControl m_inVisibleCheckPosi, offset 0x30>
	class gameUtil::CPositionControl m_inVisibleCheckPosi;

	// <float m_fVisiblePosiInterpTimer, offset 0x50>
	float m_fVisiblePosiInterpTimer;

	// <Unidentified data segment, offset 0x54>
private:
	char _UnidentifiedData[12];
public:

	std::string ToString() const { return "class CCameraTarget(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraTarget>("CCameraTarget")
			.addFunction("__tostring", &CCameraTarget::ToString)
			.addFunction("GetPtrAddr", &CCameraTarget::GetPtrAddr)
			.addProperty("m_pModel", &CCameraTarget::m_pModel)
			.addProperty("m_inCenterPosi", &CCameraTarget::m_inCenterPosi)
			.addProperty("m_fYaw", &CCameraTarget::m_fYaw)
			.addProperty("m_fPitch", &CCameraTarget::m_fPitch)
			.addProperty("m_bIsIdleTime", &CCameraTarget::m_bIsIdleTime)
			.addProperty("m_bIsVisible", &CCameraTarget::m_bIsVisible)
			.addProperty("m_bIsVisibleYawExist", &CCameraTarget::m_bIsVisibleYawExist)
			.addProperty("m_fVisibleYaw", &CCameraTarget::m_fVisibleYaw)
			.addProperty("m_inVisibleCheckPosi", &CCameraTarget::m_inVisibleCheckPosi)
			.addProperty("m_fVisiblePosiInterpTimer", &CCameraTarget::m_fVisiblePosiInterpTimer)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraTarget::m_pModel) == 4, "expected m_pModel to be size 4");
static_assert(sizeof(CCameraTarget::m_inCenterPosi) == 16, "expected m_inCenterPosi to be size 16");
static_assert(sizeof(CCameraTarget::m_fYaw) == 4, "expected m_fYaw to be size 4");
static_assert(sizeof(CCameraTarget::m_fPitch) == 4, "expected m_fPitch to be size 4");
static_assert(sizeof(CCameraTarget::m_bIsIdleTime) == 1, "expected m_bIsIdleTime to be size 1");
static_assert(sizeof(CCameraTarget::m_bIsVisible) == 1, "expected m_bIsVisible to be size 1");
static_assert(sizeof(CCameraTarget::m_bIsVisibleYawExist) == 1, "expected m_bIsVisibleYawExist to be size 1");
static_assert(sizeof(CCameraTarget::m_fVisibleYaw) == 4, "expected m_fVisibleYaw to be size 4");
static_assert(sizeof(CCameraTarget::m_inVisibleCheckPosi) == 32, "expected m_inVisibleCheckPosi to be size 32");
static_assert(sizeof(CCameraTarget::m_fVisiblePosiInterpTimer) == 4, "expected m_fVisiblePosiInterpTimer to be size 4");
static_assert(sizeof(CCameraTarget) == 96, "expected class CCameraTarget to be size 96");

// enum EGameCameraMode
enum EGameCameraMode : uint32_t
{
	// <GAME_CAMERA_MODE_NONE = 0xffffffffffffffff>
	GAME_CAMERA_MODE_NONE = UINT32_MAX,

	// <GAME_CAMERA_MODE_RESET = 0x0>
	GAME_CAMERA_MODE_RESET = 0,

	// <GAME_CAMERA_MODE_NORMAL = 0x1>
	GAME_CAMERA_MODE_NORMAL = 1,

	// <GAME_CAMERA_MODE_FREE = 0x2>
	GAME_CAMERA_MODE_FREE = 2,

	// <GAME_CAMERA_MODE_DEFAULT_ANGLE = 0x3>
	GAME_CAMERA_MODE_DEFAULT_ANGLE = 3,

	// <GAME_CAMERA_MODE_LOCK_ON = 0x4>
	GAME_CAMERA_MODE_LOCK_ON = 4,

	// <GAME_CAMERA_MODE_CIRCLE = 0x5>
	GAME_CAMERA_MODE_CIRCLE = 5,

	// <GAME_CAMERA_MODE_PETIT_MOVIE = 0x6>
	GAME_CAMERA_MODE_PETIT_MOVIE = 6,

	// <GAME_CAMERA_MODE_SUBJECTIVE = 0x7>
	GAME_CAMERA_MODE_SUBJECTIVE = 7

};

// [Structure] class ti::CCamera
namespace ti
{
	class CCamera
	{
	public:
		/// Struct member variables

		// <class tiVector m_inPosi, offset 0x0>
		class tiVector m_inPosi;

		// <class tiVector m_inDir, offset 0x10>
		class tiVector m_inDir;

		// <class tiVector m_inUpDir, offset 0x20>
		class tiVector m_inUpDir;

		// <class tiVector m_inLookAtPosi, offset 0x30>
		class tiVector m_inLookAtPosi;

		// <float m_fDistToLookAt, offset 0x40>
		float m_fDistToLookAt;

		// <float m_fYaw, offset 0x44>
		float m_fYaw;

		// <float m_fPitch, offset 0x48>
		float m_fPitch;

		// <float m_fBank, offset 0x4c>
		float m_fBank;

		// <float m_fViewAngleRadi, offset 0x50>
		float m_fViewAngleRadi;

		// <float m_fAspectRatio, offset 0x54>
		float m_fAspectRatio;

		// <Unidentified data segment, offset 0x58>
	private:
		char _UnidentifiedData10[8];

	public:
		// <class tiMatrix m_inWorldMat, offset 0x60>
		class tiMatrix m_inWorldMat;

		std::string ToString() const { return "class CCamera(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<ti::CCamera>("ti_CCamera")
				.addFunction("__tostring", &ti::CCamera::ToString)
				.addFunction("GetPtrAddr", &ti::CCamera::GetPtrAddr)
				.addProperty("m_inPosi", &ti::CCamera::m_inPosi)
				.addProperty("m_inDir", &ti::CCamera::m_inDir)
				.addProperty("m_inUpDir", &ti::CCamera::m_inUpDir)
				.addProperty("m_inLookAtPosi", &ti::CCamera::m_inLookAtPosi)
				.addProperty("m_fDistToLookAt", &ti::CCamera::m_fDistToLookAt)
				.addProperty("m_fYaw", &ti::CCamera::m_fYaw)
				.addProperty("m_fPitch", &ti::CCamera::m_fPitch)
				.addProperty("m_fBank", &ti::CCamera::m_fBank)
				.addProperty("m_fViewAngleRadi", &ti::CCamera::m_fViewAngleRadi)
				.addProperty("m_fAspectRatio", &ti::CCamera::m_fAspectRatio)
				.addProperty("m_inWorldMat", &ti::CCamera::m_inWorldMat)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(ti::CCamera::m_inPosi) == 16, "expected m_inPosi to be size 16");
static_assert(sizeof(ti::CCamera::m_inDir) == 16, "expected m_inDir to be size 16");
static_assert(sizeof(ti::CCamera::m_inUpDir) == 16, "expected m_inUpDir to be size 16");
static_assert(sizeof(ti::CCamera::m_inLookAtPosi) == 16, "expected m_inLookAtPosi to be size 16");
static_assert(sizeof(ti::CCamera::m_fDistToLookAt) == 4, "expected m_fDistToLookAt to be size 4");
static_assert(sizeof(ti::CCamera::m_fYaw) == 4, "expected m_fYaw to be size 4");
static_assert(sizeof(ti::CCamera::m_fPitch) == 4, "expected m_fPitch to be size 4");
static_assert(sizeof(ti::CCamera::m_fBank) == 4, "expected m_fBank to be size 4");
static_assert(sizeof(ti::CCamera::m_fViewAngleRadi) == 4, "expected m_fViewAngleRadi to be size 4");
static_assert(sizeof(ti::CCamera::m_fAspectRatio) == 4, "expected m_fAspectRatio to be size 4");
static_assert(sizeof(ti::CCamera::m_inWorldMat) == 64, "expected m_inWorldMat to be size 64");
static_assert(sizeof(ti::CCamera) == 160, "expected class ti::CCamera to be size 160");

// [Structure] class CGameCamera
class CGameCamera
{
public:
	/// Struct member variables

	// <class ti::CCamera m_inCamera, offset 0x0>
	class ti::CCamera m_inCamera;

	// <float m_fYawVel, offset 0xa0>
	float m_fYawVel;

	// <enum EGameCameraMode m_eMode, offset 0xa4>
	enum EGameCameraMode m_eMode;

	// <int32_t m_nResetModeCounter, offset 0xa8>
	int32_t m_nResetModeCounter;

	// <uint8_t m_bActCircle, offset 0xac>
	uint8_t m_bActCircle;

	// <Unidentified data segment, offset 0xad>
private:
	char _UnidentifiedData5[3];

public:
	// <float m_fSearchAreaTimer, offset 0xb0>
	float m_fSearchAreaTimer;

	// <Unidentified data segment, offset 0xb4>
private:
	char _UnidentifiedData6[12];

public:
	// <class CCameraTarget m_inTarget, offset 0xc0>
	class CCameraTarget m_inTarget;

	// <class CCameraAreaManager m_inAreaManager, offset 0x120>
	class CCameraAreaManager m_inAreaManager;

	// <class CCameraDataManager m_inDataManager, offset 0x1210>
	class CCameraDataManager m_inDataManager;

	// <class CCameraDefaultAngle m_inDefaultAngle, offset 0x1290>
	class CCameraDefaultAngle m_inDefaultAngle;

	// <class CCameraLookAtBase m_inLookAtBase, offset 0x12f0>
	class CCameraLookAtBase m_inLookAtBase;

	// <class CCameraLookAtOffset m_inLookAtOffset, offset 0x1380>
	class CCameraLookAtOffset m_inLookAtOffset;

	// <class CCameraFollowRot m_inFollowRot, offset 0x1440>
	class CCameraFollowRot m_inFollowRot;

	// <class CCameraDistToLookAt m_inDistToLookAt, offset 0x14a0>
	class CCameraDistToLookAt m_inDistToLookAt;

	// <class CCameraModeReset m_inResetMode, offset 0x14d0>
	class CCameraModeReset m_inResetMode;

	// <class CCameraModeNormal m_inNormalMode, offset 0x14ec>
	class CCameraModeNormal m_inNormalMode;

	// <class CCameraModeFree m_inFreeMode, offset 0x1570>
	class CCameraModeFree m_inFreeMode;

	// <class CCameraModeDefaultAngle m_inDefaultAngleMode, offset 0x15f0>
	class CCameraModeDefaultAngle m_inDefaultAngleMode;

	// <class CCameraModeLockOn m_inLockOnMode, offset 0x1690>
	class CCameraModeLockOn m_inLockOnMode;

	// <class CCameraModeCircle m_inCircleMode, offset 0x1740>
	class CCameraModeCircle m_inCircleMode;

	// <Unidentified data segment, offset 0x175c>
private:
	char _UnidentifiedData20[4];

public:
	// <class CCameraModePetitMovie m_inPetitMovieMode, offset 0x1760>
	class CCameraModePetitMovie m_inPetitMovieMode;

	// <class CCameraModeSubjective m_inSubjectiveMode, offset 0x1800>
	class CCameraModeSubjective m_inSubjectiveMode;

	// <class CCameraCollision m_inCollision, offset 0x1860>
	class CCameraCollision m_inCollision;

	// <Unidentified data segment, offset 0x1861>
private:
	char _UnidentifiedData23[3];

public:
	// <class CCameraBank m_inBank, offset 0x1864>
	class CCameraBank m_inBank;

	// <Unidentified data segment, offset 0x1894>
private:
	char _UnidentifiedData24[12];

public:
	// <class CCameraVibManager m_inVibManager, offset 0x18a0>
	class CCameraVibManager m_inVibManager;

	std::string ToString() const { return "class CGameCamera(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameCamera>("CGameCamera")
			.addFunction("__tostring", &CGameCamera::ToString)
			.addFunction("GetPtrAddr", &CGameCamera::GetPtrAddr)
			.addProperty("m_inCamera", &CGameCamera::m_inCamera)
			.addProperty("m_fYawVel", &CGameCamera::m_fYawVel)
			.addProperty("m_eMode", &CGameCamera::m_eMode)
			.addProperty("m_nResetModeCounter", &CGameCamera::m_nResetModeCounter)
			.addProperty("m_bActCircle", &CGameCamera::m_bActCircle)
			.addProperty("m_fSearchAreaTimer", &CGameCamera::m_fSearchAreaTimer)
			.addProperty("m_inTarget", &CGameCamera::m_inTarget)
			.addProperty("m_inAreaManager", &CGameCamera::m_inAreaManager)
			.addProperty("m_inDataManager", &CGameCamera::m_inDataManager)
			.addProperty("m_inDefaultAngle", &CGameCamera::m_inDefaultAngle)
			.addProperty("m_inLookAtBase", &CGameCamera::m_inLookAtBase)
			.addProperty("m_inLookAtOffset", &CGameCamera::m_inLookAtOffset)
			.addProperty("m_inFollowRot", &CGameCamera::m_inFollowRot)
			.addProperty("m_inDistToLookAt", &CGameCamera::m_inDistToLookAt)
			.addProperty("m_inResetMode", &CGameCamera::m_inResetMode)
			.addProperty("m_inNormalMode", &CGameCamera::m_inNormalMode)
			.addProperty("m_inFreeMode", &CGameCamera::m_inFreeMode)
			.addProperty("m_inDefaultAngleMode", &CGameCamera::m_inDefaultAngleMode)
			.addProperty("m_inLockOnMode", &CGameCamera::m_inLockOnMode)
			.addProperty("m_inCircleMode", &CGameCamera::m_inCircleMode)
			.addProperty("m_inPetitMovieMode", &CGameCamera::m_inPetitMovieMode)
			.addProperty("m_inSubjectiveMode", &CGameCamera::m_inSubjectiveMode)
			.addProperty("m_inCollision", &CGameCamera::m_inCollision)
			.addProperty("m_inBank", &CGameCamera::m_inBank)
			.addProperty("m_inVibManager", &CGameCamera::m_inVibManager)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameCamera::m_inCamera) == 160, "expected m_inCamera to be size 160");
static_assert(sizeof(CGameCamera::m_fYawVel) == 4, "expected m_fYawVel to be size 4");
static_assert(sizeof(CGameCamera::m_eMode) == 4, "expected m_eMode to be size 4");
static_assert(sizeof(CGameCamera::m_nResetModeCounter) == 4, "expected m_nResetModeCounter to be size 4");
static_assert(sizeof(CGameCamera::m_bActCircle) == 1, "expected m_bActCircle to be size 1");
static_assert(sizeof(CGameCamera::m_fSearchAreaTimer) == 4, "expected m_fSearchAreaTimer to be size 4");
static_assert(sizeof(CGameCamera::m_inTarget) == 96, "expected m_inTarget to be size 96");
static_assert(sizeof(CGameCamera::m_inAreaManager) == 4336, "expected m_inAreaManager to be size 4336");
static_assert(sizeof(CGameCamera::m_inDataManager) == 128, "expected m_inDataManager to be size 128");
static_assert(sizeof(CGameCamera::m_inDefaultAngle) == 96, "expected m_inDefaultAngle to be size 96");
static_assert(sizeof(CGameCamera::m_inLookAtBase) == 144, "expected m_inLookAtBase to be size 144");
static_assert(sizeof(CGameCamera::m_inLookAtOffset) == 192, "expected m_inLookAtOffset to be size 192");
static_assert(sizeof(CGameCamera::m_inFollowRot) == 96, "expected m_inFollowRot to be size 96");
static_assert(sizeof(CGameCamera::m_inDistToLookAt) == 48, "expected m_inDistToLookAt to be size 48");
static_assert(sizeof(CGameCamera::m_inResetMode) == 28, "expected m_inResetMode to be size 28");
static_assert(sizeof(CGameCamera::m_inNormalMode) == 132, "expected m_inNormalMode to be size 132");
static_assert(sizeof(CGameCamera::m_inFreeMode) == 128, "expected m_inFreeMode to be size 128");
static_assert(sizeof(CGameCamera::m_inDefaultAngleMode) == 160, "expected m_inDefaultAngleMode to be size 160");
static_assert(sizeof(CGameCamera::m_inLockOnMode) == 176, "expected m_inLockOnMode to be size 176");
static_assert(sizeof(CGameCamera::m_inCircleMode) == 28, "expected m_inCircleMode to be size 28");
static_assert(sizeof(CGameCamera::m_inPetitMovieMode) == 160, "expected m_inPetitMovieMode to be size 160");
static_assert(sizeof(CGameCamera::m_inSubjectiveMode) == 96, "expected m_inSubjectiveMode to be size 96");
static_assert(sizeof(CGameCamera::m_inCollision) == 1, "expected m_inCollision to be size 1");
static_assert(sizeof(CGameCamera::m_inBank) == 48, "expected m_inBank to be size 48");
static_assert(sizeof(CGameCamera::m_inVibManager) == 576, "expected m_inVibManager to be size 576");
static_assert(sizeof(CGameCamera) == 6880, "expected class CGameCamera to be size 6880");

// enum ECameraResetType
enum ECameraResetType : uint32_t
{
	// <CAMERA_RESET_TYPE_NONE = 0x0>
	CAMERA_RESET_TYPE_NONE = 0,

	// <CAMERA_RESET_TYPE_NORMAL = 0x1>
	CAMERA_RESET_TYPE_NORMAL = 1,

	// <CAMERA_RESET_TYPE_SEAMLESS = 0x2>
	CAMERA_RESET_TYPE_SEAMLESS = 2,

	// <CAMERA_RESET_TYPE_SET_YAW = 0x3>
	CAMERA_RESET_TYPE_SET_YAW = 3

};

// [Structure] class CCameraman
class CCameraman
{
public:
	// [Function] void __convention("thiscall") CCameraman::beginTsubazeriai(class CCameraman* const this, class mHRChara* arg2, float const arg3) [?beginTsubazeriai@CCameraman@@QAEXPBVmHRChara@@M@Z]
	void beginTsubazeriai(class mHRChara* arg2, float const arg3)
	{
		typedef void(__thiscall* _Func)(class CCameraman* const thisPtr, class mHRChara* arg2, float const arg3);
		_Func mFunc = (_Func)(GameModule + 0x398630);
		return mFunc(this, arg2, arg3);
	}
	// enum CCameraman::ECameraMode
	enum ECameraMode : uint32_t
	{
		// <CAMERA_MODE_NONE = 0xffffffffffffffff>
		CAMERA_MODE_NONE = UINT32_MAX,

		// <CAMERA_MODE_GAME = 0x0>
		CAMERA_MODE_GAME = 0,

		// <CAMERA_MODE_DEBUG_GLOBAL = 0x1>
		CAMERA_MODE_DEBUG_GLOBAL = 1

	};

	/// Struct member variables

	// <class ti::CCamera m_inCamera, offset 0x0>
	class ti::CCamera m_inCamera;

	// <uint8_t m_bIsCalledOnUpdate, offset 0xa0>
	uint8_t m_bIsCalledOnUpdate;

	// <Unidentified data segment, offset 0xa1>
private:
	char _UnidentifiedData2[3];

public:
	// <enum ECameraResetType m_eResetType, offset 0xa4>
	enum ECameraResetType m_eResetType;

	// <enum CCameraman::ECameraMode m_eCamMode, offset 0xa8>
	enum CCameraman::ECameraMode m_eCamMode;

	// <class mot::IBoneEffectModel* m_pTarget, offset 0xac>
	class mot::IBoneEffectModel* m_pTarget;

	// <class CGameCamera m_inGameCamera, offset 0xb0>
	class CGameCamera m_inGameCamera;

	// <uint8_t m_bIsTsubazeriai, offset 0x1b90>
	uint8_t m_bIsTsubazeriai;

	// <Unidentified data segment, offset 0x1b91>
private:
	char _UnidentifiedData7[3];

public:
	// <enum enCharaType m_eTsubaTarget, offset 0x1b94>
	enum enCharaType m_eTsubaTarget;

	// <float m_fTsubaSuperiorRatio, offset 0x1b98>
	float m_fTsubaSuperiorRatio;

	// <uint8_t m_bIsTsubaYawPlus, offset 0x1b9c>
	uint8_t m_bIsTsubaYawPlus;

	// <Unidentified data segment, offset 0x1b9d>
private:
	char _UnidentifiedData10[3];

public:
	// <int32_t m_nTsubaCamVibID, offset 0x1ba0>
	int32_t m_nTsubaCamVibID;

	// <Unidentified data segment, offset 0x1ba4>
private:
	char _UnidentifiedData[12];
public:

	std::string ToString() const { return "class CCameraman(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraman>("CCameraman")
			.addFunction("__tostring", &CCameraman::ToString)
			.addFunction("GetPtrAddr", &CCameraman::GetPtrAddr)
			.addProperty("m_inCamera", &CCameraman::m_inCamera)
			.addProperty("m_bIsCalledOnUpdate", &CCameraman::m_bIsCalledOnUpdate)
			.addProperty("m_eResetType", &CCameraman::m_eResetType)
			.addProperty("m_eCamMode", &CCameraman::m_eCamMode)
			.addProperty("m_pTarget", &CCameraman::m_pTarget)
			.addProperty("m_inGameCamera", &CCameraman::m_inGameCamera)
			.addProperty("m_bIsTsubazeriai", &CCameraman::m_bIsTsubazeriai)
			.addProperty("m_eTsubaTarget", &CCameraman::m_eTsubaTarget)
			.addProperty("m_fTsubaSuperiorRatio", &CCameraman::m_fTsubaSuperiorRatio)
			.addProperty("m_bIsTsubaYawPlus", &CCameraman::m_bIsTsubaYawPlus)
			.addProperty("m_nTsubaCamVibID", &CCameraman::m_nTsubaCamVibID)
			.addFunction("beginTsubazeriai", &CCameraman::beginTsubazeriai)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraman::m_inCamera) == 160, "expected m_inCamera to be size 160");
static_assert(sizeof(CCameraman::m_bIsCalledOnUpdate) == 1, "expected m_bIsCalledOnUpdate to be size 1");
static_assert(sizeof(CCameraman::m_eResetType) == 4, "expected m_eResetType to be size 4");
static_assert(sizeof(CCameraman::m_eCamMode) == 4, "expected m_eCamMode to be size 4");
static_assert(sizeof(CCameraman::m_pTarget) == 4, "expected m_pTarget to be size 4");
static_assert(sizeof(CCameraman::m_inGameCamera) == 6880, "expected m_inGameCamera to be size 6880");
static_assert(sizeof(CCameraman::m_bIsTsubazeriai) == 1, "expected m_bIsTsubazeriai to be size 1");
static_assert(sizeof(CCameraman::m_eTsubaTarget) == 4, "expected m_eTsubaTarget to be size 4");
static_assert(sizeof(CCameraman::m_fTsubaSuperiorRatio) == 4, "expected m_fTsubaSuperiorRatio to be size 4");
static_assert(sizeof(CCameraman::m_bIsTsubaYawPlus) == 1, "expected m_bIsTsubaYawPlus to be size 1");
static_assert(sizeof(CCameraman::m_nTsubaCamVibID) == 4, "expected m_nTsubaCamVibID to be size 4");
static_assert(sizeof(CCameraman) == 7088, "expected class CCameraman to be size 7088");

// [Structure] class HrMiniDemoObj
class HrMiniDemoObj : public ghmListObj
{
public:
	// enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID
	enum HRMINIDEMOOBJ_KIND_ID : uint32_t
	{
		// <MDEMO_KIND_TRV = 0x0>
		MDEMO_KIND_TRV = 0,

		// <MDEMO_KIND_MODEL = 0x1>
		MDEMO_KIND_MODEL = 1,

		// <MDEMO_KIND_CAMERA = 0x2>
		MDEMO_KIND_CAMERA = 2,

		// <MDEMO_KIND_SOUND = 0x3>
		MDEMO_KIND_SOUND = 3,

		// <MDEMO_KIND_EFFECT = 0x4>
		MDEMO_KIND_EFFECT = 4,

		// <MDEMO_KIND_MESSAGE = 0x5>
		MDEMO_KIND_MESSAGE = 5,

		// <MDEMO_KIND_BIKE = 0x6>
		MDEMO_KIND_BIKE = 6,

		// <MDEMO_KIND_MAX = 0x7>
		MDEMO_KIND_MAX = 7

	};

	// enum HrMiniDemoObj::MDEMO_OBJ_STS
	enum MDEMO_OBJ_STS : uint32_t
	{
		// <MDEMO_OBJ_INIT = 0x0>
		MDEMO_OBJ_INIT = 0,

		// <MDEMO_OBJ_IDLE = 0x1>
		MDEMO_OBJ_IDLE = 1,

		// <MDEMO_OBJ_PLAY = 0x2>
		MDEMO_OBJ_PLAY = 2,

		// <MDEMO_OBJ_FIN = 0x3>
		MDEMO_OBJ_FIN = 3,

		// <MDEMO_OBJ_PAUSE = 0x4>
		MDEMO_OBJ_PAUSE = 4,

		// <MDEMO_OBJ_EXIT = 0x5>
		MDEMO_OBJ_EXIT = 5,

		// <MDEMO_OBJ_MAX = 0x6>
		MDEMO_OBJ_MAX = 6

	};

	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID mKind, offset 0x10>
	enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID mKind;

	// <class TGan* mpGan, offset 0x14>
	class TGan* mpGan;

	// <float mStartTick, offset 0x18>
	float mStartTick;

	// <enum HrMiniDemoObj::MDEMO_OBJ_STS mStatus, offset 0x1c>
	enum HrMiniDemoObj::MDEMO_OBJ_STS mStatus;

	// <uint8_t mPause, offset 0x20>
	uint8_t mPause;

	// <uint8_t mEndPause, offset 0x21>
	uint8_t mEndPause;

	// <uint8_t mEndPauseDo, offset 0x22>
	uint8_t mEndPauseDo;

	// <Unidentified data segment, offset 0x23>
private:
	char _UnidentifiedData8[5];

public:
	// <uint64_t mName, offset 0x28>
	uint64_t mName;

	// <char mNameStr[0x10], offset 0x30>
	char mNameStr[16];

	// <uint8_t mSHeightflg, offset 0x40>
	uint8_t mSHeightflg;

	// <Unidentified data segment, offset 0x41>
private:
	char _UnidentifiedData11[3];

public:
	// <float mSHeight, offset 0x44>
	float mSHeight;

	// <uint8_t mbDrawMirror, offset 0x48>
	uint8_t mbDrawMirror;

	// <uint8_t mbShadowDraw, offset 0x49>
	uint8_t mbShadowDraw;

	// <Unidentified data segment, offset 0x4a>
private:
	char _UnidentifiedData[6];
public:

	std::string ToString() const { return "class HrMiniDemoObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMiniDemoObj, ghmListObj>("HrMiniDemoObj")
			.addFunction("__tostring", &HrMiniDemoObj::ToString)
			.addFunction("GetPtrAddr", &HrMiniDemoObj::GetPtrAddr)
			.addProperty("mKind", &HrMiniDemoObj::mKind)
			.addProperty("mpGan", &HrMiniDemoObj::mpGan)
			.addProperty("mStartTick", &HrMiniDemoObj::mStartTick)
			.addProperty("mStatus", &HrMiniDemoObj::mStatus)
			.addProperty("mPause", &HrMiniDemoObj::mPause)
			.addProperty("mEndPause", &HrMiniDemoObj::mEndPause)
			.addProperty("mEndPauseDo", &HrMiniDemoObj::mEndPauseDo)
			.addProperty("mName", &HrMiniDemoObj::mName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mNameStr", &HrMiniDemoObj::mNameStr)
			.addProperty("mSHeightflg", &HrMiniDemoObj::mSHeightflg)
			.addProperty("mSHeight", &HrMiniDemoObj::mSHeight)
			.addProperty("mbDrawMirror", &HrMiniDemoObj::mbDrawMirror)
			.addProperty("mbShadowDraw", &HrMiniDemoObj::mbShadowDraw)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemoObj::mKind) == 4, "expected mKind to be size 4");
static_assert(sizeof(HrMiniDemoObj::mpGan) == 4, "expected mpGan to be size 4");
static_assert(sizeof(HrMiniDemoObj::mStartTick) == 4, "expected mStartTick to be size 4");
static_assert(sizeof(HrMiniDemoObj::mStatus) == 4, "expected mStatus to be size 4");
static_assert(sizeof(HrMiniDemoObj::mPause) == 1, "expected mPause to be size 1");
static_assert(sizeof(HrMiniDemoObj::mEndPause) == 1, "expected mEndPause to be size 1");
static_assert(sizeof(HrMiniDemoObj::mEndPauseDo) == 1, "expected mEndPauseDo to be size 1");
static_assert(sizeof(HrMiniDemoObj::mName) == 8, "expected mName to be size 8");
static_assert(sizeof(HrMiniDemoObj::mNameStr) == 16, "expected mNameStr to be size 16");
static_assert(sizeof(HrMiniDemoObj::mSHeightflg) == 1, "expected mSHeightflg to be size 1");
static_assert(sizeof(HrMiniDemoObj::mSHeight) == 4, "expected mSHeight to be size 4");
static_assert(sizeof(HrMiniDemoObj::mbDrawMirror) == 1, "expected mbDrawMirror to be size 1");
static_assert(sizeof(HrMiniDemoObj::mbShadowDraw) == 1, "expected mbShadowDraw to be size 1");
static_assert(sizeof(HrMiniDemoObj) == 80, "expected class HrMiniDemoObj to be size 80");

// [Structure] class HrMiniDemoModel
class HrMiniDemoModel : public HrMiniDemoObj
{
public:
	/// Struct member variables

	// <class HrMiniDemoObj field_0, offset 0x0>
	// class HrMiniDemoObj Super;

	// <struct WGanNodeSpec* mpGanNodeSpec, offset 0x50>
	struct WGanNodeSpec* mpGanNodeSpec;

	// <class TGmf* mpGmf, offset 0x54>
	class TGmf* mpGmf;

	// <class mHRChara* mpChara, offset 0x58>
	class mHRChara* mpChara;

	// <struct Vec mPos, offset 0x5c>
	struct Vec mPos;

	// <struct Vec mRot, offset 0x68>
	struct Vec mRot;

	// <uint8_t mUseTexShadow, offset 0x74>
	uint8_t mUseTexShadow;

	// <Unidentified data segment, offset 0x75>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class HrMiniDemoModel(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<HrMiniDemoModel, HrMiniDemoObj>("HrMiniDemoModel")
			.addFunction("__tostring", &HrMiniDemoModel::ToString)
			.addFunction("GetPtrAddr", &HrMiniDemoModel::GetPtrAddr)
			.addProperty("mpGanNodeSpec", &HrMiniDemoModel::mpGanNodeSpec)
			.addProperty("mpGmf", &HrMiniDemoModel::mpGmf)
			.addProperty("mpChara", &HrMiniDemoModel::mpChara)
			.addProperty("mPos", &HrMiniDemoModel::mPos)
			.addProperty("mRot", &HrMiniDemoModel::mRot)
			.addProperty("mUseTexShadow", &HrMiniDemoModel::mUseTexShadow)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemoModel::mpGanNodeSpec) == 4, "expected mpGanNodeSpec to be size 4");
static_assert(sizeof(HrMiniDemoModel::mpGmf) == 4, "expected mpGmf to be size 4");
static_assert(sizeof(HrMiniDemoModel::mpChara) == 4, "expected mpChara to be size 4");
static_assert(sizeof(HrMiniDemoModel::mPos) == 12, "expected mPos to be size 12");
static_assert(sizeof(HrMiniDemoModel::mRot) == 12, "expected mRot to be size 12");
static_assert(sizeof(HrMiniDemoModel::mUseTexShadow) == 1, "expected mUseTexShadow to be size 1");
static_assert(sizeof(HrMiniDemoModel) == 120, "expected class HrMiniDemoModel to be size 120");

// [Function] int32_t __convention("thiscall") j_sub_849ca0(class mHRPc* const this) [j_sub_849ca0]
int32_t j_sub_849ca0(class mHRPc* const thisPtr)
{
	typedef int32_t(__thiscall* _Func)(class mHRPc* const thisPtr);
	_Func mFunc = (_Func)(GameModule + 0x41efc0);
	return mFunc(thisPtr);
}
// [Function] int32_t sub_4467e6(int32_t* arg1 @ ebp, class mHRPc* arg2 @ esi, class mHRChara* arg3 @ edi) [sub_4467e6]
int32_t sub_4467e6(int32_t* arg1, class mHRPc* arg2, class mHRChara* arg3)
{
	typedef int32_t(__fastcall* _Func)(int32_t* arg1, class mHRPc* arg2, class mHRChara* arg3);
	_Func mFunc = (_Func)(GameModule + 0x4467e6);
	return mFunc(arg1, arg2, arg3);
}
// [Structure] class STG0202
class STG0202
{
public:
	// [Function] void __convention("thiscall") STG0202::CharMoveByConbeyor(class STG0202* const this, class mHRChara* arg2) [?CharMoveByConbeyor@STG0202@@AAEXPAVmHRChara@@@Z]
	void CharMoveByConbeyor(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class STG0202* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x455920);
		return mFunc(this, arg2);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[96];
public:

	std::string ToString() const { return "class STG0202(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<STG0202>("STG0202")
			.addFunction("__tostring", &STG0202::ToString)
			.addFunction("GetPtrAddr", &STG0202::GetPtrAddr)
			.addFunction("CharMoveByConbeyor", &STG0202::CharMoveByConbeyor)
		.endClass();
	}
#endif
};
static_assert(sizeof(STG0202) == 96, "expected class STG0202 to be size 96");

// [Structure] struct tagHRTASKCHECK
struct tagHRTASKCHECK
{
public:
	/// Struct member variables

	// <class HrTask* Task, offset 0x0>
	class HrTask* Task;

	// <uint32_t MagicNumber, offset 0x4>
	uint32_t MagicNumber;

	std::string ToString() const { return "struct tagHRTASKCHECK(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagHRTASKCHECK>("tagHRTASKCHECK")
			.addFunction("__tostring", &tagHRTASKCHECK::ToString)
			.addFunction("GetPtrAddr", &tagHRTASKCHECK::GetPtrAddr)
			.addProperty("Task", &tagHRTASKCHECK::Task)
			.addProperty("MagicNumber", &tagHRTASKCHECK::MagicNumber)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagHRTASKCHECK::Task) == 4, "expected Task to be size 4");
static_assert(sizeof(tagHRTASKCHECK::MagicNumber) == 4, "expected MagicNumber to be size 4");
static_assert(sizeof(tagHRTASKCHECK) == 8, "expected struct tagHRTASKCHECK to be size 8");

// [Structure] class EffectBoneElect
class EffectBoneElect : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class TGmf* m_pGmf, offset 0x50>
	class TGmf* m_pGmf;

	// <uint32_t m_Color, offset 0x54>
	uint32_t m_Color;

	// <class FkStlList<BoneStreamObj *> m_BoneStrmObjPtrList, offset 0x58>
	class FkStlList<BoneStreamObj *> m_BoneStrmObjPtrList;

	// <int32_t m_CeateID, offset 0x64>
	int32_t m_CeateID;

	// <class EffectMetalElect* m_pMetalEffect, offset 0x68>
	class EffectMetalElect* m_pMetalEffect;

	// <int32_t m_Cnt, offset 0x6c>
	int32_t m_Cnt;

	// <class mHRChara* m_pTargetChara, offset 0x70>
	class mHRChara* m_pTargetChara;

	std::string ToString() const { return "class EffectBoneElect(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectBoneElect, HrTask>("EffectBoneElect")
			.addFunction("__tostring", &EffectBoneElect::ToString)
			.addFunction("GetPtrAddr", &EffectBoneElect::GetPtrAddr)
			.addProperty("m_pGmf", &EffectBoneElect::m_pGmf)
			.addProperty("m_Color", &EffectBoneElect::m_Color)
			.addProperty("m_BoneStrmObjPtrList", &EffectBoneElect::m_BoneStrmObjPtrList)
			.addProperty("m_CeateID", &EffectBoneElect::m_CeateID)
			.addProperty("m_pMetalEffect", &EffectBoneElect::m_pMetalEffect)
			.addProperty("m_Cnt", &EffectBoneElect::m_Cnt)
			.addProperty("m_pTargetChara", &EffectBoneElect::m_pTargetChara)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectBoneElect::m_pGmf) == 4, "expected m_pGmf to be size 4");
static_assert(sizeof(EffectBoneElect::m_Color) == 4, "expected m_Color to be size 4");
static_assert(sizeof(EffectBoneElect::m_BoneStrmObjPtrList) == 12, "expected m_BoneStrmObjPtrList to be size 12");
static_assert(sizeof(EffectBoneElect::m_CeateID) == 4, "expected m_CeateID to be size 4");
static_assert(sizeof(EffectBoneElect::m_pMetalEffect) == 4, "expected m_pMetalEffect to be size 4");
static_assert(sizeof(EffectBoneElect::m_Cnt) == 4, "expected m_Cnt to be size 4");
static_assert(sizeof(EffectBoneElect::m_pTargetChara) == 4, "expected m_pTargetChara to be size 4");
static_assert(sizeof(EffectBoneElect) == 116, "expected class EffectBoneElect to be size 116");

// [Structure] class BoneStreamObj
class BoneStreamObj
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[220];
public:

	std::string ToString() const { return "class BoneStreamObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<BoneStreamObj>("BoneStreamObj")
			.addFunction("__tostring", &BoneStreamObj::ToString)
			.addFunction("GetPtrAddr", &BoneStreamObj::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(BoneStreamObj) == 220, "expected class BoneStreamObj to be size 220");

// [Structure] class EffectMetalElect
class EffectMetalElect
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[226464];
public:

	std::string ToString() const { return "class EffectMetalElect(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectMetalElect>("EffectMetalElect")
			.addFunction("__tostring", &EffectMetalElect::ToString)
			.addFunction("GetPtrAddr", &EffectMetalElect::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectMetalElect) == 226464, "expected class EffectMetalElect to be size 226464");

// [Structure] class EffectCutMark
class EffectCutMark
{
public:
	// enum EffectCutMark::eCutMarkType
	enum eCutMarkType : uint32_t
	{
		// <eCutMarkType_UNKNOWN = 0xffffffffffffffff>
		eCutMarkType_UNKNOWN = UINT32_MAX,

		// <eCutMarkType_Beam = 0x0>
		eCutMarkType_Beam = 0,

		// <eCutMarkType_Sword = 0x1>
		eCutMarkType_Sword = 1,

		// <eCutMarkType_NUM = 0x2>
		eCutMarkType_NUM = 2

	};

	// [Function] class EffectCutMark* EffectCutMark::Create(class TGmf* arg1, class mHRChara* arg2, struct Vec* arg3, uint32_t const arg4, enum eEfDmgLevel& arg5, enum EffectCutMark::eCutMarkType& arg6, float const arg7) [?Create@EffectCutMark@@SAPAV1@PAVTGmf@@PAVmHRChara@@PBUVec@@IABW4eEfDmgLevel@@ABW4eCutMarkType@1@M@Z]
	static class EffectCutMark* Create(class TGmf* arg1, class mHRChara* arg2, struct Vec* arg3, uint32_t const arg4, enum eEfDmgLevel& arg5, enum EffectCutMark::eCutMarkType& arg6, float const arg7)
	{
		typedef class EffectCutMark*(__fastcall* _Func)(class TGmf* arg1, class mHRChara* arg2, struct Vec* arg3, uint32_t const arg4, enum eEfDmgLevel& arg5, enum EffectCutMark::eCutMarkType& arg6, float const arg7);
		_Func mFunc = (_Func)(GameModule + 0x56f2c0);
		return mFunc(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[21812];
public:

	std::string ToString() const { return "class EffectCutMark(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectCutMark>("EffectCutMark")
			.addFunction("__tostring", &EffectCutMark::ToString)
			.addFunction("GetPtrAddr", &EffectCutMark::GetPtrAddr)
			// Can't export & pointer 'enum eEfDmgLevel&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectCutMark::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectCutMark) == 21812, "expected class EffectCutMark to be size 21812");

// [Structure] class PJTateshi
class PJTateshi
{
public:
	// [Function] void __convention("thiscall") PJTateshi::SetZakoAllFuttobiFromPc(class PJTateshi* const this, class mHRChara* arg2) [?SetZakoAllFuttobiFromPc@PJTateshi@@QAEXPAVmHRChara@@@Z]
	void SetZakoAllFuttobiFromPc(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class PJTateshi* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x4b12c0);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJTateshi::SetDemoDamage2PC(class PJTateshi* const this, float const arg2, class mHRChara* arg3) [?SetDemoDamage2PC@PJTateshi@@QAEXMPAVmHRChara@@@Z]
	void SetDemoDamage2PC(float const arg2, class mHRChara* arg3)
	{
		typedef void(__thiscall* _Func)(class PJTateshi* const thisPtr, float const arg2, class mHRChara* arg3);
		_Func mFunc = (_Func)(GameModule + 0x4b1ea0);
		return mFunc(this, arg2, arg3);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[492];
public:

	std::string ToString() const { return "class PJTateshi(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJTateshi>("PJTateshi")
			.addFunction("__tostring", &PJTateshi::ToString)
			.addFunction("GetPtrAddr", &PJTateshi::GetPtrAddr)
			.addFunction("SetZakoAllFuttobiFromPc", &PJTateshi::SetZakoAllFuttobiFromPc)
			.addFunction("SetDemoDamage2PC", &PJTateshi::SetDemoDamage2PC)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJTateshi) == 492, "expected class PJTateshi to be size 492");

// [Structure] class PJState
class PJState
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x5], offset 0x0>
	void* (* field_0)[0x5];

	std::string ToString() const { return "class PJState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJState>("PJState")
			.addFunction("__tostring", &PJState::ToString)
			.addFunction("GetPtrAddr", &PJState::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &PJState::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJState::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(PJState) == 4, "expected class PJState to be size 4");

// [Structure] class ZkState_DownAttack
class ZkState_DownAttack : public PJState
{
public:
	// enum ZkState_DownAttack::eStat
	enum eStat : uint32_t
	{
		// <eStat_Close = 0x0>
		eStat_Close = 0,

		// <eStat_Attacking = 0x1>
		eStat_Attacking = 1

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum ZkState_DownAttack::eStat m_eStat, offset 0x4>
	enum ZkState_DownAttack::eStat m_eStat;

	std::string ToString() const { return "class ZkState_DownAttack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkState_DownAttack, PJState>("ZkState_DownAttack")
			.addFunction("__tostring", &ZkState_DownAttack::ToString)
			.addFunction("GetPtrAddr", &ZkState_DownAttack::GetPtrAddr)
			.addProperty("m_eStat", &ZkState_DownAttack::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_DownAttack::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(ZkState_DownAttack) == 8, "expected class ZkState_DownAttack to be size 8");

// [Structure] class State_AwayAfterAttack
class State_AwayAfterAttack : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	std::string ToString() const { return "class State_AwayAfterAttack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_AwayAfterAttack, PJState>("State_AwayAfterAttack")
			.addFunction("__tostring", &State_AwayAfterAttack::ToString)
			.addFunction("GetPtrAddr", &State_AwayAfterAttack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_AwayAfterAttack) == 4, "expected class State_AwayAfterAttack to be size 4");

// [Structure] class State_CloseBeforeAttack
class State_CloseBeforeAttack : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	std::string ToString() const { return "class State_CloseBeforeAttack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_CloseBeforeAttack, PJState>("State_CloseBeforeAttack")
			.addFunction("__tostring", &State_CloseBeforeAttack::ToString)
			.addFunction("GetPtrAddr", &State_CloseBeforeAttack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_CloseBeforeAttack) == 4, "expected class State_CloseBeforeAttack to be size 4");

// [Structure] class State_StepInAttack
class State_StepInAttack : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	std::string ToString() const { return "class State_StepInAttack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_StepInAttack, PJState>("State_StepInAttack")
			.addFunction("__tostring", &State_StepInAttack::ToString)
			.addFunction("GetPtrAddr", &State_StepInAttack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_StepInAttack) == 4, "expected class State_StepInAttack to be size 4");

// [Structure] class State_DownDamage
class State_DownDamage : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	std::string ToString() const { return "class State_DownDamage(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_DownDamage, PJState>("State_DownDamage")
			.addFunction("__tostring", &State_DownDamage::ToString)
			.addFunction("GetPtrAddr", &State_DownDamage::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_DownDamage) == 4, "expected class State_DownDamage to be size 4");

// [Structure] class State_TojoBaseState
class State_TojoBaseState : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	std::string ToString() const { return "class State_TojoBaseState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_TojoBaseState, PJState>("State_TojoBaseState")
			.addFunction("__tostring", &State_TojoBaseState::ToString)
			.addFunction("GetPtrAddr", &State_TojoBaseState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_TojoBaseState) == 4, "expected class State_TojoBaseState to be size 4");

// [Structure] class State_LeadPcWayPointMove
class State_LeadPcWayPointMove : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	std::string ToString() const { return "class State_LeadPcWayPointMove(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_LeadPcWayPointMove, PJState>("State_LeadPcWayPointMove")
			.addFunction("__tostring", &State_LeadPcWayPointMove::ToString)
			.addFunction("GetPtrAddr", &State_LeadPcWayPointMove::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_LeadPcWayPointMove) == 4, "expected class State_LeadPcWayPointMove to be size 4");

// [Structure] class State_FixTurret
class State_FixTurret : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	std::string ToString() const { return "class State_FixTurret(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_FixTurret, PJState>("State_FixTurret")
			.addFunction("__tostring", &State_FixTurret::ToString)
			.addFunction("GetPtrAddr", &State_FixTurret::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_FixTurret) == 4, "expected class State_FixTurret to be size 4");

// [Structure] class State_WayPointMoveAfterPop
class State_WayPointMoveAfterPop : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	std::string ToString() const { return "class State_WayPointMoveAfterPop(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_WayPointMoveAfterPop, PJState>("State_WayPointMoveAfterPop")
			.addFunction("__tostring", &State_WayPointMoveAfterPop::ToString)
			.addFunction("GetPtrAddr", &State_WayPointMoveAfterPop::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_WayPointMoveAfterPop) == 4, "expected class State_WayPointMoveAfterPop to be size 4");

// [Structure] class State_Tojo_RoomRunner
class State_Tojo_RoomRunner : public State_TojoBaseState
{
public:
	// enum State_Tojo_RoomRunner::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_Ready = 0x1>
		eStat_Ready = 1

	};

	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_RoomRunner::eStat m_eStat, offset 0x4>
	enum State_Tojo_RoomRunner::eStat m_eStat;

	std::string ToString() const { return "class State_Tojo_RoomRunner(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_RoomRunner, State_TojoBaseState>("State_Tojo_RoomRunner")
			.addFunction("__tostring", &State_Tojo_RoomRunner::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_RoomRunner::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_RoomRunner::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_RoomRunner::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Tojo_RoomRunner) == 8, "expected class State_Tojo_RoomRunner to be size 8");

// [Structure] class State_Tojo_AeroBike
class State_Tojo_AeroBike : public State_TojoBaseState
{
public:
	// enum State_Tojo_AeroBike::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_Ready = 0x1>
		eStat_Ready = 1

	};

	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_AeroBike::eStat m_eStat, offset 0x4>
	enum State_Tojo_AeroBike::eStat m_eStat;

	std::string ToString() const { return "class State_Tojo_AeroBike(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_AeroBike, State_TojoBaseState>("State_Tojo_AeroBike")
			.addFunction("__tostring", &State_Tojo_AeroBike::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_AeroBike::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_AeroBike::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_AeroBike::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Tojo_AeroBike) == 8, "expected class State_Tojo_AeroBike to be size 8");

// [Structure] class State_Tojo_BreakCmnObj
class State_Tojo_BreakCmnObj : public State_TojoBaseState
{
public:
	// enum State_Tojo_BreakCmnObj::eStat
	enum eStat : uint32_t
	{
		// <eStat_WaitBreak = 0x0>
		eStat_WaitBreak = 0,

		// <eStat_BreakMotionPlay = 0x1>
		eStat_BreakMotionPlay = 1

	};

	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_BreakCmnObj::eStat m_eStat, offset 0x4>
	enum State_Tojo_BreakCmnObj::eStat m_eStat;

	// <uint8_t m_boAttacked, offset 0x8>
	uint8_t m_boAttacked;

	// <Unidentified data segment, offset 0x9>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class State_Tojo_BreakCmnObj(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_BreakCmnObj, State_TojoBaseState>("State_Tojo_BreakCmnObj")
			.addFunction("__tostring", &State_Tojo_BreakCmnObj::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_BreakCmnObj::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_BreakCmnObj::m_eStat)
			.addProperty("m_boAttacked", &State_Tojo_BreakCmnObj::m_boAttacked)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_BreakCmnObj::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Tojo_BreakCmnObj::m_boAttacked) == 1, "expected m_boAttacked to be size 1");
static_assert(sizeof(State_Tojo_BreakCmnObj) == 12, "expected class State_Tojo_BreakCmnObj to be size 12");

// [Structure] class State_Tojo_JumpOff
class State_Tojo_JumpOff : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <float m_fSpdY, offset 0x4>
	float m_fSpdY;

	std::string ToString() const { return "class State_Tojo_JumpOff(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_JumpOff, State_TojoBaseState>("State_Tojo_JumpOff")
			.addFunction("__tostring", &State_Tojo_JumpOff::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_JumpOff::GetPtrAddr)
			.addProperty("m_fSpdY", &State_Tojo_JumpOff::m_fSpdY)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_JumpOff::m_fSpdY) == 4, "expected m_fSpdY to be size 4");
static_assert(sizeof(State_Tojo_JumpOff) == 8, "expected class State_Tojo_JumpOff to be size 8");

// [Structure] class State_Tojo_Car
class State_Tojo_Car : public State_TojoBaseState
{
public:
	// enum State_Tojo_Car::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_GetOff = 0x1>
		eStat_GetOff = 1

	};

	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_Car::eStat m_eStat, offset 0x4>
	enum State_Tojo_Car::eStat m_eStat;

	std::string ToString() const { return "class State_Tojo_Car(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Car, State_TojoBaseState>("State_Tojo_Car")
			.addFunction("__tostring", &State_Tojo_Car::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Car::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_Car::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Car::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Tojo_Car) == 8, "expected class State_Tojo_Car to be size 8");

// [Structure] class State_Tojo_RunAndTurnPc
class State_Tojo_RunAndTurnPc : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	std::string ToString() const { return "class State_Tojo_RunAndTurnPc(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_RunAndTurnPc, State_TojoBaseState>("State_Tojo_RunAndTurnPc")
			.addFunction("__tostring", &State_Tojo_RunAndTurnPc::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_RunAndTurnPc::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_RunAndTurnPc) == 4, "expected class State_Tojo_RunAndTurnPc to be size 4");

// [Structure] class State_Idle
class State_Idle : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	std::string ToString() const { return "class State_Idle(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Idle, State_TojoBaseState>("State_Idle")
			.addFunction("__tostring", &State_Idle::ToString)
			.addFunction("GetPtrAddr", &State_Idle::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Idle) == 4, "expected class State_Idle to be size 4");

// [Structure] class State_Tojo_AgainstWall
class State_Tojo_AgainstWall : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	std::string ToString() const { return "class State_Tojo_AgainstWall(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_AgainstWall, State_TojoBaseState>("State_Tojo_AgainstWall")
			.addFunction("__tostring", &State_Tojo_AgainstWall::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_AgainstWall::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_AgainstWall) == 4, "expected class State_Tojo_AgainstWall to be size 4");

// [Structure] class State_Tojo_LookAround
class State_Tojo_LookAround : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	std::string ToString() const { return "class State_Tojo_LookAround(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_LookAround, State_TojoBaseState>("State_Tojo_LookAround")
			.addFunction("__tostring", &State_Tojo_LookAround::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_LookAround::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_LookAround) == 4, "expected class State_Tojo_LookAround to be size 4");

// [Structure] class State_Tojo_Stand
class State_Tojo_Stand : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	std::string ToString() const { return "class State_Tojo_Stand(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Stand, State_TojoBaseState>("State_Tojo_Stand")
			.addFunction("__tostring", &State_Tojo_Stand::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Stand::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Stand) == 4, "expected class State_Tojo_Stand to be size 4");

// [Structure] class State_Tojo_Bench
class State_Tojo_Bench : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	std::string ToString() const { return "class State_Tojo_Bench(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Bench, State_TojoBaseState>("State_Tojo_Bench")
			.addFunction("__tostring", &State_Tojo_Bench::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Bench::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Bench) == 4, "expected class State_Tojo_Bench to be size 4");

// [Structure] class State_Tojo_Sit
class State_Tojo_Sit : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	std::string ToString() const { return "class State_Tojo_Sit(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Sit, State_TojoBaseState>("State_Tojo_Sit")
			.addFunction("__tostring", &State_Tojo_Sit::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Sit::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Sit) == 4, "expected class State_Tojo_Sit to be size 4");

// [Structure] class State_Tojo_SuddenAttack
class State_Tojo_SuddenAttack : public State_TojoBaseState
{
public:
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	std::string ToString() const { return "class State_Tojo_SuddenAttack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_SuddenAttack, State_TojoBaseState>("State_Tojo_SuddenAttack")
			.addFunction("__tostring", &State_Tojo_SuddenAttack::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_SuddenAttack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_SuddenAttack) == 4, "expected class State_Tojo_SuddenAttack to be size 4");

// [Structure] class State_ReleaseWaitIdle
class State_ReleaseWaitIdle : public State_Idle
{
public:
	/// Struct member variables

	// <class State_Idle field_0, offset 0x0>
	// class State_Idle Super;

	std::string ToString() const { return "class State_ReleaseWaitIdle(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_ReleaseWaitIdle, State_Idle>("State_ReleaseWaitIdle")
			.addFunction("__tostring", &State_ReleaseWaitIdle::ToString)
			.addFunction("GetPtrAddr", &State_ReleaseWaitIdle::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ReleaseWaitIdle) == 4, "expected class State_ReleaseWaitIdle to be size 4");

// [Structure] class State_Scare_Base
class State_Scare_Base : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_Cnt, offset 0x4>
	int32_t m_Cnt;

	std::string ToString() const { return "class State_Scare_Base(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Base, PJState>("State_Scare_Base")
			.addFunction("__tostring", &State_Scare_Base::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Base::GetPtrAddr)
			.addProperty("m_Cnt", &State_Scare_Base::m_Cnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Base::m_Cnt) == 4, "expected m_Cnt to be size 4");
static_assert(sizeof(State_Scare_Base) == 8, "expected class State_Scare_Base to be size 8");

// [Structure] class State_Scare_Kosinukasi
class State_Scare_Kosinukasi : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	std::string ToString() const { return "class State_Scare_Kosinukasi(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Kosinukasi, State_Scare_Base>("State_Scare_Kosinukasi")
			.addFunction("__tostring", &State_Scare_Kosinukasi::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Kosinukasi::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Kosinukasi) == 8, "expected class State_Scare_Kosinukasi to be size 8");

// [Structure] class State_Scare_Run
class State_Scare_Run : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	std::string ToString() const { return "class State_Scare_Run(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Run, State_Scare_Base>("State_Scare_Run")
			.addFunction("__tostring", &State_Scare_Run::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Run::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Run) == 8, "expected class State_Scare_Run to be size 8");

// [Structure] class State_WayPointMove
class State_WayPointMove : public PJState
{
public:
	// enum State_WayPointMove::eWaypointSbSt
	enum eWaypointSbSt : uint32_t
	{
		// <eWaypointSbSt_UNKNOWN = 0xffffffffffffffff>
		eWaypointSbSt_UNKNOWN = UINT32_MAX,

		// <eWaypointSbSt_WayPoint = 0x0>
		eWaypointSbSt_WayPoint = 0,

		// <eWaypointSbSt_ClosePc = 0x1>
		eWaypointSbSt_ClosePc = 1

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_WayPointMove::eWaypointSbSt m_eStat, offset 0x4>
	enum State_WayPointMove::eWaypointSbSt m_eStat;

	std::string ToString() const { return "class State_WayPointMove(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_WayPointMove, PJState>("State_WayPointMove")
			.addFunction("__tostring", &State_WayPointMove::ToString)
			.addFunction("GetPtrAddr", &State_WayPointMove::GetPtrAddr)
			.addProperty("m_eStat", &State_WayPointMove::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_WayPointMove::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_WayPointMove) == 8, "expected class State_WayPointMove to be size 8");

// [Structure] class State_Pressure
class State_Pressure : public PJState
{
public:
	// enum State_Pressure::eStat
	enum eStat : uint32_t
	{
		// <eStat_CLOSE = 0x0>
		eStat_CLOSE = 0,

		// <eStat_WAIT = 0x1>
		eStat_WAIT = 1,

		// <eStat_AWAY = 0x2>
		eStat_AWAY = 2

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_Pressure::eStat m_eStat, offset 0x4>
	enum State_Pressure::eStat m_eStat;

	// <int32_t m_WaitCnt, offset 0x8>
	int32_t m_WaitCnt;

	std::string ToString() const { return "class State_Pressure(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Pressure, PJState>("State_Pressure")
			.addFunction("__tostring", &State_Pressure::ToString)
			.addFunction("GetPtrAddr", &State_Pressure::GetPtrAddr)
			.addProperty("m_eStat", &State_Pressure::m_eStat)
			.addProperty("m_WaitCnt", &State_Pressure::m_WaitCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Pressure::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Pressure::m_WaitCnt) == 4, "expected m_WaitCnt to be size 4");
static_assert(sizeof(State_Pressure) == 12, "expected class State_Pressure to be size 12");

// [Structure] class State_ThroughDamage
class State_ThroughDamage : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <uint8_t m_boHitSword, offset 0x4>
	uint8_t m_boHitSword;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class State_ThroughDamage(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_ThroughDamage, PJState>("State_ThroughDamage")
			.addFunction("__tostring", &State_ThroughDamage::ToString)
			.addFunction("GetPtrAddr", &State_ThroughDamage::GetPtrAddr)
			.addProperty("m_boHitSword", &State_ThroughDamage::m_boHitSword)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ThroughDamage::m_boHitSword) == 1, "expected m_boHitSword to be size 1");
static_assert(sizeof(State_ThroughDamage) == 8, "expected class State_ThroughDamage to be size 8");

// enum eMoveDir
enum eMoveDir : uint32_t
{
	// <eMoveDir_Left = 0x0>
	eMoveDir_Left = 0,

	// <eMoveDir_Right = 0x1>
	eMoveDir_Right = 1,

	// <eMoveDir_Forward = 0x2>
	eMoveDir_Forward = 2,

	// <eMoveDir_Back = 0x3>
	eMoveDir_Back = 3,

	// <eMoveDir_Idle = 0x4>
	eMoveDir_Idle = 4,

	// <eMoveDir_NumMax = 0x5>
	eMoveDir_NumMax = 5

};

// [Structure] class State_Defence
class State_Defence : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum eMoveDir m_eStateMovDir, offset 0x4>
	enum eMoveDir m_eStateMovDir;

	std::string ToString() const { return "class State_Defence(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Defence, PJState>("State_Defence")
			.addFunction("__tostring", &State_Defence::ToString)
			.addFunction("GetPtrAddr", &State_Defence::GetPtrAddr)
			.addProperty("m_eStateMovDir", &State_Defence::m_eStateMovDir)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Defence::m_eStateMovDir) == 4, "expected m_eStateMovDir to be size 4");
static_assert(sizeof(State_Defence) == 8, "expected class State_Defence to be size 8");

// [Structure] class State_Evacuate
class State_Evacuate : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_nContinueEvacuate, offset 0x4>
	int32_t m_nContinueEvacuate;

	std::string ToString() const { return "class State_Evacuate(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Evacuate, PJState>("State_Evacuate")
			.addFunction("__tostring", &State_Evacuate::ToString)
			.addFunction("GetPtrAddr", &State_Evacuate::GetPtrAddr)
			.addProperty("m_nContinueEvacuate", &State_Evacuate::m_nContinueEvacuate)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Evacuate::m_nContinueEvacuate) == 4, "expected m_nContinueEvacuate to be size 4");
static_assert(sizeof(State_Evacuate) == 8, "expected class State_Evacuate to be size 8");

// [Structure] class State_ComboAttack
class State_ComboAttack : public PJState
{
public:
	// enum State_ComboAttack::eStat
	enum eStat : uint32_t
	{
		// <eStat_ATTACKSTART = 0x0>
		eStat_ATTACKSTART = 0,

		// <eStat_ATTACKING = 0x1>
		eStat_ATTACKING = 1

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_ComboAttack::eStat m_eStat, offset 0x4>
	enum State_ComboAttack::eStat m_eStat;

	// <uint8_t m_ComboRequest, offset 0x8>
	uint8_t m_ComboRequest;

	// <Unidentified data segment, offset 0x9>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class State_ComboAttack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_ComboAttack, PJState>("State_ComboAttack")
			.addFunction("__tostring", &State_ComboAttack::ToString)
			.addFunction("GetPtrAddr", &State_ComboAttack::GetPtrAddr)
			.addProperty("m_eStat", &State_ComboAttack::m_eStat)
			.addProperty("m_ComboRequest", &State_ComboAttack::m_ComboRequest)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ComboAttack::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_ComboAttack::m_ComboRequest) == 1, "expected m_ComboRequest to be size 1");
static_assert(sizeof(State_ComboAttack) == 12, "expected class State_ComboAttack to be size 12");

// [Structure] class State_Damage
class State_Damage : public PJState
{
public:
	// enum State_Damage::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0xffffffffffffffff>
		eStat_Init = UINT32_MAX,

		// <eStat_DmgNormal = 0x0>
		eStat_DmgNormal = 0,

		// <eStat_DmgUchiage = 0x1>
		eStat_DmgUchiage = 1,

		// <eStat_Dmg2Down = 0x2>
		eStat_Dmg2Down = 2,

		// <eStat_DmgDownLoop = 0x3>
		eStat_DmgDownLoop = 3,

		// <eStat_DmgWakeUp = 0x4>
		eStat_DmgWakeUp = 4,

		// <eStat_DmgPiyori = 0x5>
		eStat_DmgPiyori = 5,

		// <eStat_ExitDamageState = 0x6>
		eStat_ExitDamageState = 6

	};

	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_DownCnt, offset 0x4>
	int32_t m_DownCnt;

	// <enum State_Damage::eStat m_eStat, offset 0x8>
	enum State_Damage::eStat m_eStat;

	std::string ToString() const { return "class State_Damage(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Damage, PJState>("State_Damage")
			.addFunction("__tostring", &State_Damage::ToString)
			.addFunction("GetPtrAddr", &State_Damage::GetPtrAddr)
			.addProperty("m_DownCnt", &State_Damage::m_DownCnt)
			.addProperty("m_eStat", &State_Damage::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Damage::m_DownCnt) == 4, "expected m_DownCnt to be size 4");
static_assert(sizeof(State_Damage::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Damage) == 12, "expected class State_Damage to be size 12");

// [Structure] struct CollInfo
struct CollInfo
{
public:
	/// Struct member variables

	// <float fDistLeft, offset 0x0>
	float fDistLeft;

	// <float fDistRight, offset 0x4>
	float fDistRight;

	// <float fDistBack, offset 0x8>
	float fDistBack;

	std::string ToString() const { return "struct CollInfo(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CollInfo>("CollInfo")
			.addFunction("__tostring", &CollInfo::ToString)
			.addFunction("GetPtrAddr", &CollInfo::GetPtrAddr)
			.addProperty("fDistLeft", &CollInfo::fDistLeft)
			.addProperty("fDistRight", &CollInfo::fDistRight)
			.addProperty("fDistBack", &CollInfo::fDistBack)
		.endClass();
	}
#endif
};
static_assert(sizeof(CollInfo::fDistLeft) == 4, "expected fDistLeft to be size 4");
static_assert(sizeof(CollInfo::fDistRight) == 4, "expected fDistRight to be size 4");
static_assert(sizeof(CollInfo::fDistBack) == 4, "expected fDistBack to be size 4");
static_assert(sizeof(CollInfo) == 12, "expected struct CollInfo to be size 12");

// enum eScareType
enum eScareType : uint32_t
{
	// <eScareType_NO_SCARE = 0xffffffffffffffff>
	eScareType_NO_SCARE = UINT32_MAX,

	// <eScareType_Tiger = 0x0>
	eScareType_Tiger = 0,

	// <eScareType_FriendDead = 0x1>
	eScareType_FriendDead = 1

};

// enum eZkStat
enum eZkStat : uint32_t
{
	// <eZkCmnStat_INVALID = 0xffffffffffffffff>
	eZkCmnStat_INVALID = UINT32_MAX,

	// <eZkCmnStat_IDLE = 0x0>
	eZkCmnStat_IDLE = 0,

	// <eZkCmnStat_GLOBAL = 0x1>
	eZkCmnStat_GLOBAL = 1,

	// <eZkCmnStat_CLOSE = 0x2>
	eZkCmnStat_CLOSE = 2,

	// <eZkCmnStat_OBSERV = 0x3>
	eZkCmnStat_OBSERV = 3,

	// <eZkCmnStat_SIDEMOVE = 0x4>
	eZkCmnStat_SIDEMOVE = 4,

	// <eZkCmnStat_CloseBeforeATK = 0x5>
	eZkCmnStat_CloseBeforeATK = 5,

	// <eZkCmnStat_AwayAfterATK = 0x6>
	eZkCmnStat_AwayAfterATK = 6,

	// <eZkCmnStat_StepInATK = 0x7>
	eZkCmnStat_StepInATK = 7,

	// <eZkCmnStat_ComboATK = 0x8>
	eZkCmnStat_ComboATK = 8,

	// <eZkCmnStat_RUNAWAY = 0x9>
	eZkCmnStat_RUNAWAY = 9,

	// <eZkCmnStat_DEFENCE = 0xa>
	eZkCmnStat_DEFENCE = 10,

	// <eZkCmnStat_RANDOMMOVE = 0xb>
	eZkCmnStat_RANDOMMOVE = 11,

	// <eZkCmnStat_EVACUATION = 0xc>
	eZkCmnStat_EVACUATION = 12,

	// <eZkCmnStat_DAMAGE = 0xd>
	eZkCmnStat_DAMAGE = 13,

	// <eZkCmnStat_THROUGHDAMAGE = 0xe>
	eZkCmnStat_THROUGHDAMAGE = 14,

	// <eZkCmnStat_DOWNDAMAGE = 0xf>
	eZkCmnStat_DOWNDAMAGE = 15,

	// <eZkCmnStat_GUARD = 0x10>
	eZkCmnStat_GUARD = 16,

	// <eZkCmnStat_DYING = 0x11>
	eZkCmnStat_DYING = 17,

	// <eZkCmnStat_DEBUG = 0x12>
	eZkCmnStat_DEBUG = 18,

	// <eZkCmnStat_GETPCBEHIND = 0x13>
	eZkCmnStat_GETPCBEHIND = 19,

	// <eZkCmnStat_GO2FIGHTLINE = 0x14>
	eZkCmnStat_GO2FIGHTLINE = 20,

	// <eZkCmnStat_OUTFIELD = 0x15>
	eZkCmnStat_OUTFIELD = 21,

	// <eZkCmnStat_CAUTION = 0x16>
	eZkCmnStat_CAUTION = 22,

	// <eZkCmnStat_NOPROC = 0x17>
	eZkCmnStat_NOPROC = 23,

	// <eZkCmnStat_PRESSURE = 0x18>
	eZkCmnStat_PRESSURE = 24,

	// <eZkCmnStat_PATHFIND2PC = 0x19>
	eZkCmnStat_PATHFIND2PC = 25,

	// <eZkCmnStat_WAYPOINTMOVE = 0x1a>
	eZkCmnStat_WAYPOINTMOVE = 26,

	// <eZkCmnStat_LeadPcWayPointMove = 0x1b>
	eZkCmnStat_LeadPcWayPointMove = 27,

	// <eZkCmnStat_FixTurret = 0x1c>
	eZkCmnStat_FixTurret = 28,

	// <eZkCmnStat_WayPointMoveAfterPop = 0x1d>
	eZkCmnStat_WayPointMoveAfterPop = 29,

	// <eZkCmnStat_DownAttack = 0x1e>
	eZkCmnStat_DownAttack = 30,

	// <eZkCmnStat_SCARE_RUN = 0x1f>
	eZkCmnStat_SCARE_RUN = 31,

	// <eZkCmnStat_SCARE_KOSINUKASI = 0x20>
	eZkCmnStat_SCARE_KOSINUKASI = 32,

	// <eZkCmnStat_SCARE_YOTUNBAI = 0x21>
	eZkCmnStat_SCARE_YOTUNBAI = 33,

	// <eZkCmnStat_SCARE_STAND = 0x22>
	eZkCmnStat_SCARE_STAND = 34,

	// <eZkCmnStat_PerformIll = 0x23>
	eZkCmnStat_PerformIll = 35,

	// <eZkCmnStat_RELEASEWAIT_IDLE = 0x24>
	eZkCmnStat_RELEASEWAIT_IDLE = 36,

	// <eZkCmnStat_TOJO_RunAndTurnPc = 0x25>
	eZkCmnStat_TOJO_RunAndTurnPc = 37,

	// <eZkCmnStat_TOJO_AgainstWall = 0x26>
	eZkCmnStat_TOJO_AgainstWall = 38,

	// <eZkCmnStat_TOJO_LookAround = 0x27>
	eZkCmnStat_TOJO_LookAround = 39,

	// <eZkCmnStat_TOJO_Stand = 0x28>
	eZkCmnStat_TOJO_Stand = 40,

	// <eZkCmnStat_TOJO_Bench = 0x29>
	eZkCmnStat_TOJO_Bench = 41,

	// <eZkCmnStat_TOJO_Sit = 0x2a>
	eZkCmnStat_TOJO_Sit = 42,

	// <eZkCmnStat_TOJO_Car = 0x2b>
	eZkCmnStat_TOJO_Car = 43,

	// <eZkCmnStat_TOJO_JumpOff = 0x2c>
	eZkCmnStat_TOJO_JumpOff = 44,

	// <eZkCmnStat_TOJO_BreakCmnObj = 0x2d>
	eZkCmnStat_TOJO_BreakCmnObj = 45,

	// <eZkCmnStat_TOJO_AeroBike = 0x2e>
	eZkCmnStat_TOJO_AeroBike = 46,

	// <eZkCmnStat_TOJO_RoomRunner = 0x2f>
	eZkCmnStat_TOJO_RoomRunner = 47,

	// <eZkCmnStat_TOJO_SuddenAttack = 0x30>
	eZkCmnStat_TOJO_SuddenAttack = 48,

	// <eZkCmnStat_UNDERCTRL_MOVE = 0x31>
	eZkCmnStat_UNDERCTRL_MOVE = 49,

	// <eZkCmnStat_UNDERCTRL_ATTACK = 0x32>
	eZkCmnStat_UNDERCTRL_ATTACK = 50,

	// <eZkCmnStat_UNDERCTRL_EVACUATE = 0x33>
	eZkCmnStat_UNDERCTRL_EVACUATE = 51,

	// <eZkCmnStat_UNDERCTRL_GUARD = 0x34>
	eZkCmnStat_UNDERCTRL_GUARD = 52,

	// <eZkCmnStat_UNDERCTRL_DAMAGE = 0x35>
	eZkCmnStat_UNDERCTRL_DAMAGE = 53,

	// <eZkCmnStat_NUM = 0x36>
	eZkCmnStat_NUM = 54

};

// enum FightSpirit
enum FightSpirit : uint32_t
{
	// <e_Defensive = 0x0>
	e_Defensive = 0,

	// <e_Offensive = 0x1>
	e_Offensive = 1,

	// <e_FsStatNum = 0x2>
	e_FsStatNum = 2

};

// enum eFightLine
enum eFightLine : uint32_t
{
	// <eFightLine_Init = 0xffffffffffffffff>
	eFightLine_Init = UINT32_MAX,

	// <eFightLine_Defence = 0x0>
	eFightLine_Defence = 0,

	// <eFightLine_SideMove = 0x1>
	eFightLine_SideMove = 1,

	// <eFightLine_OutField = 0x2>
	eFightLine_OutField = 2,

	// <eFightLine_NUM = 0x3>
	eFightLine_NUM = 3

};

// [Structure] struct ZkGuardParam
struct ZkGuardParam
{
public:
	/// Struct member variables

	// <int32_t GrdCnt, offset 0x0>
	int32_t GrdCnt;

	// <int32_t nGrdCombo, offset 0x4>
	int32_t nGrdCombo;

	// <int32_t GrdStiffCnt, offset 0x8>
	int32_t GrdStiffCnt;

	// <uint8_t boGrdStiff, offset 0xc>
	uint8_t boGrdStiff;

	// <Unidentified data segment, offset 0xd>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "struct ZkGuardParam(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkGuardParam>("ZkGuardParam")
			.addFunction("__tostring", &ZkGuardParam::ToString)
			.addFunction("GetPtrAddr", &ZkGuardParam::GetPtrAddr)
			.addProperty("GrdCnt", &ZkGuardParam::GrdCnt)
			.addProperty("nGrdCombo", &ZkGuardParam::nGrdCombo)
			.addProperty("GrdStiffCnt", &ZkGuardParam::GrdStiffCnt)
			.addProperty("boGrdStiff", &ZkGuardParam::boGrdStiff)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkGuardParam::GrdCnt) == 4, "expected GrdCnt to be size 4");
static_assert(sizeof(ZkGuardParam::nGrdCombo) == 4, "expected nGrdCombo to be size 4");
static_assert(sizeof(ZkGuardParam::GrdStiffCnt) == 4, "expected GrdStiffCnt to be size 4");
static_assert(sizeof(ZkGuardParam::boGrdStiff) == 1, "expected boGrdStiff to be size 1");
static_assert(sizeof(ZkGuardParam) == 16, "expected struct ZkGuardParam to be size 16");

// [Structure] struct ZkEvacuateParam
struct ZkEvacuateParam
{
public:
	/// Struct member variables

	// <int32_t EvcCnt, offset 0x0>
	int32_t EvcCnt;

	// <int32_t nEvcCombo, offset 0x4>
	int32_t nEvcCombo;

	std::string ToString() const { return "struct ZkEvacuateParam(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkEvacuateParam>("ZkEvacuateParam")
			.addFunction("__tostring", &ZkEvacuateParam::ToString)
			.addFunction("GetPtrAddr", &ZkEvacuateParam::GetPtrAddr)
			.addProperty("EvcCnt", &ZkEvacuateParam::EvcCnt)
			.addProperty("nEvcCombo", &ZkEvacuateParam::nEvcCombo)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkEvacuateParam::EvcCnt) == 4, "expected EvcCnt to be size 4");
static_assert(sizeof(ZkEvacuateParam::nEvcCombo) == 4, "expected nEvcCombo to be size 4");
static_assert(sizeof(ZkEvacuateParam) == 8, "expected struct ZkEvacuateParam to be size 8");

// enum eDownDir
enum eDownDir : uint32_t
{
	// <eDownDir_UNKNOWN = 0xffffffffffffffff>
	eDownDir_UNKNOWN = UINT32_MAX,

	// <eDownDir_UP = 0x0>
	eDownDir_UP = 0,

	// <eDownDir_DOWN = 0x1>
	eDownDir_DOWN = 1

};

// enum eZkCarSheet
enum eZkCarSheet : uint32_t
{
	// <eZkCarSheet_UNKONOWN = 0xffffffffffffffff>
	eZkCarSheet_UNKONOWN = UINT32_MAX,

	// <eZkCarSheet_FR = 0x0>
	eZkCarSheet_FR = 0,

	// <eZkCarSheet_FL = 0x1>
	eZkCarSheet_FL = 1,

	// <eZkCarSheet_BR = 0x2>
	eZkCarSheet_BR = 2,

	// <eZkCarSheet_BL = 0x3>
	eZkCarSheet_BL = 3,

	// <eZkCarSheet_VAN = 0x4>
	eZkCarSheet_VAN = 4,

	// <eZkCarSheet_NUM = 0x5>
	eZkCarSheet_NUM = 5

};

// [Structure] class FkCounter
class FkCounter
{
public:
	/// Struct member variables

	// <int32_t NowCnt, offset 0x0>
	int32_t NowCnt;

	// <int32_t MaxCnt, offset 0x4>
	int32_t MaxCnt;

	std::string ToString() const { return "class FkCounter(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkCounter>("FkCounter")
			.addFunction("__tostring", &FkCounter::ToString)
			.addFunction("GetPtrAddr", &FkCounter::GetPtrAddr)
			.addProperty("NowCnt", &FkCounter::NowCnt)
			.addProperty("MaxCnt", &FkCounter::MaxCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkCounter::NowCnt) == 4, "expected NowCnt to be size 4");
static_assert(sizeof(FkCounter::MaxCnt) == 4, "expected MaxCnt to be size 4");
static_assert(sizeof(FkCounter) == 8, "expected class FkCounter to be size 8");

// enum ePcSideFromMe
enum ePcSideFromMe : uint32_t
{
	// <ePcSideFromMe_Unknown = 0xffffffffffffffff>
	ePcSideFromMe_Unknown = UINT32_MAX,

	// <ePcSideFromMe_Left = 0x0>
	ePcSideFromMe_Left = 0,

	// <ePcSideFromMe_Right = 0x1>
	ePcSideFromMe_Right = 1

};

// enum eSideFromPc
enum eSideFromPc : uint32_t
{
	// <eSideFromPC_Left = 0x0>
	eSideFromPC_Left = 0,

	// <eSideFromPC_Right = 0x1>
	eSideFromPC_Right = 1

};

// [Structure] struct ZkSetDamageInfo
struct ZkSetDamageInfo
{
public:
	/// Struct member variables

	// <uint8_t boCounterHit, offset 0x0>
	uint8_t boCounterHit;

	// <uint8_t boFollowThroughHit, offset 0x1>
	uint8_t boFollowThroughHit;

	// <uint8_t boNoConvertMotionTypeDamage, offset 0x2>
	uint8_t boNoConvertMotionTypeDamage;

	// <uint8_t boGuard, offset 0x3>
	uint8_t boGuard;

	std::string ToString() const { return "struct ZkSetDamageInfo(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkSetDamageInfo>("ZkSetDamageInfo")
			.addFunction("__tostring", &ZkSetDamageInfo::ToString)
			.addFunction("GetPtrAddr", &ZkSetDamageInfo::GetPtrAddr)
			.addProperty("boCounterHit", &ZkSetDamageInfo::boCounterHit)
			.addProperty("boFollowThroughHit", &ZkSetDamageInfo::boFollowThroughHit)
			.addProperty("boNoConvertMotionTypeDamage", &ZkSetDamageInfo::boNoConvertMotionTypeDamage)
			.addProperty("boGuard", &ZkSetDamageInfo::boGuard)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkSetDamageInfo::boCounterHit) == 1, "expected boCounterHit to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boFollowThroughHit) == 1, "expected boFollowThroughHit to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boNoConvertMotionTypeDamage) == 1, "expected boNoConvertMotionTypeDamage to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boGuard) == 1, "expected boGuard to be size 1");
static_assert(sizeof(ZkSetDamageInfo) == 4, "expected struct ZkSetDamageInfo to be size 4");

// enum eZkBoneScale
enum eZkBoneScale : uint32_t
{
	// <eZkBoneScale_UNKNOWN = 0xffffffffffffffff>
	eZkBoneScale_UNKNOWN = UINT32_MAX,

	// <eZkBoneScale_A = 0x0>
	eZkBoneScale_A = 0,

	// <eZkBoneScale_B = 0x1>
	eZkBoneScale_B = 1,

	// <eZkBoneScale_C = 0x2>
	eZkBoneScale_C = 2,

	// <eZkBoneScale_D = 0x3>
	eZkBoneScale_D = 3,

	// <eZkBoneScale_Five = 0x4>
	eZkBoneScale_Five = 4,

	// <eZkBoneScaleNum = 0x5>
	eZkBoneScaleNum = 5

};

// [Structure] class State_Scare_Yotunbai
class State_Scare_Yotunbai : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	std::string ToString() const { return "class State_Scare_Yotunbai(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Yotunbai, State_Scare_Base>("State_Scare_Yotunbai")
			.addFunction("__tostring", &State_Scare_Yotunbai::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Yotunbai::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Yotunbai) == 8, "expected class State_Scare_Yotunbai to be size 8");

// [Structure] class State_Scare_Stand
class State_Scare_Stand : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	std::string ToString() const { return "class State_Scare_Stand(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Scare_Stand, State_Scare_Base>("State_Scare_Stand")
			.addFunction("__tostring", &State_Scare_Stand::ToString)
			.addFunction("GetPtrAddr", &State_Scare_Stand::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Stand) == 8, "expected class State_Scare_Stand to be size 8");

// [Structure] class State_RandomMove
class State_RandomMove : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum eMoveDir m_eStateMovDir, offset 0x4>
	enum eMoveDir m_eStateMovDir;

	std::string ToString() const { return "class State_RandomMove(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_RandomMove, PJState>("State_RandomMove")
			.addFunction("__tostring", &State_RandomMove::ToString)
			.addFunction("GetPtrAddr", &State_RandomMove::GetPtrAddr)
			.addProperty("m_eStateMovDir", &State_RandomMove::m_eStateMovDir)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_RandomMove::m_eStateMovDir) == 4, "expected m_eStateMovDir to be size 4");
static_assert(sizeof(State_RandomMove) == 8, "expected class State_RandomMove to be size 8");

// [Structure] class State_PerformIll
class State_PerformIll : public State_Scare_Base
{
public:
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

	std::string ToString() const { return "class State_PerformIll(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_PerformIll, State_Scare_Base>("State_PerformIll")
			.addFunction("__tostring", &State_PerformIll::ToString)
			.addFunction("GetPtrAddr", &State_PerformIll::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_PerformIll) == 8, "expected class State_PerformIll to be size 8");

// [Structure] class PJZAKO
class PJZAKO : public mHRChara
{
public:
	// [Function] uint8_t __convention("thiscall") PJZAKO::IsAtkObj(class PJZAKO* const this, class mHRChara* arg2) [?IsAtkObj@PJZAKO@@EAE_NPAVmHRChara@@@Z]
	uint8_t IsAtkObj(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class PJZAKO* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x4d51b0);
		return mFunc(this, arg2);
	}
	// [Structure] struct PJZAKO::ZakoInfo
	struct ZakoInfo
	{
	public:
		/// Struct member variables

		// <int32_t m_ComboAtkTbl[0x4], offset 0x0>
		int32_t m_ComboAtkTbl[4];

		// <int32_t m_NowComboAtkNo, offset 0x10>
		int32_t m_NowComboAtkNo;

		// <uint8_t m_ComboAtkReq, offset 0x14>
		uint8_t m_ComboAtkReq;

		// <Unidentified data segment, offset 0x15>
	private:
		char _UnidentifiedData3[3];

	public:
		// <int32_t m_nMaxComboAtk, offset 0x18>
		int32_t m_nMaxComboAtk;

		// <enum eMoveDir m_eMaaiMovDir, offset 0x1c>
		enum eMoveDir m_eMaaiMovDir;

		// <enum eSideFromPc m_SideFromPc, offset 0x20>
		enum eSideFromPc m_SideFromPc;

		// <enum ePcSideFromMe m_PcSideFromMe, offset 0x24>
		enum ePcSideFromMe m_PcSideFromMe;

		// <class FkCounter m_MoveCnt, offset 0x28>
		class FkCounter m_MoveCnt;

		// <struct Vec m_MoveVec, offset 0x30>
		struct Vec m_MoveVec;

		// <struct Vec m_FrontVec, offset 0x3c>
		struct Vec m_FrontVec;

		// <float m_EnmSubAngle, offset 0x48>
		float m_EnmSubAngle;

		// <float m_fMaaiTbl[0x8], offset 0x4c>
		float m_fMaaiTbl[8];

		// <float m_fMovSpd[0x1], offset 0x6c>
		float m_fMovSpd[1];

		// <int32_t m_CirclePcPointHnd, offset 0x70>
		int32_t m_CirclePcPointHnd;

		// <struct Vec m_PrevPos, offset 0x74>
		struct Vec m_PrevPos;

		// <float m_fWayPointMoveLength, offset 0x80>
		float m_fWayPointMoveLength;

		// <int32_t m_WayPointCnt, offset 0x84>
		int32_t m_WayPointCnt;

		// <uint8_t m_boWaypointMoveStopping, offset 0x88>
		uint8_t m_boWaypointMoveStopping;

		// <Unidentified data segment, offset 0x89>
	private:
		char _UnidentifiedData18[3];

	public:
		// <int32_t m_GoPointKuruKuruCnt, offset 0x8c>
		int32_t m_GoPointKuruKuruCnt;

		// <uint8_t m_boLookPC, offset 0x90>
		uint8_t m_boLookPC;

		// <Unidentified data segment, offset 0x91>
	private:
		char _UnidentifiedData[3];
	public:

		std::string ToString() const { return "struct ZakoInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::ZakoInfo>("PJZAKO_ZakoInfo")
				.addFunction("__tostring", &PJZAKO::ZakoInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::ZakoInfo::GetPtrAddr)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_ComboAtkTbl", &PJZAKO::ZakoInfo::m_ComboAtkTbl)
				.addProperty("m_NowComboAtkNo", &PJZAKO::ZakoInfo::m_NowComboAtkNo)
				.addProperty("m_ComboAtkReq", &PJZAKO::ZakoInfo::m_ComboAtkReq)
				.addProperty("m_nMaxComboAtk", &PJZAKO::ZakoInfo::m_nMaxComboAtk)
				.addProperty("m_eMaaiMovDir", &PJZAKO::ZakoInfo::m_eMaaiMovDir)
				.addProperty("m_SideFromPc", &PJZAKO::ZakoInfo::m_SideFromPc)
				.addProperty("m_PcSideFromMe", &PJZAKO::ZakoInfo::m_PcSideFromMe)
				.addProperty("m_MoveCnt", &PJZAKO::ZakoInfo::m_MoveCnt)
				.addProperty("m_MoveVec", &PJZAKO::ZakoInfo::m_MoveVec)
				.addProperty("m_FrontVec", &PJZAKO::ZakoInfo::m_FrontVec)
				.addProperty("m_EnmSubAngle", &PJZAKO::ZakoInfo::m_EnmSubAngle)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_fMaaiTbl", &PJZAKO::ZakoInfo::m_fMaaiTbl)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_fMovSpd", &PJZAKO::ZakoInfo::m_fMovSpd)
				.addProperty("m_CirclePcPointHnd", &PJZAKO::ZakoInfo::m_CirclePcPointHnd)
				.addProperty("m_PrevPos", &PJZAKO::ZakoInfo::m_PrevPos)
				.addProperty("m_fWayPointMoveLength", &PJZAKO::ZakoInfo::m_fWayPointMoveLength)
				.addProperty("m_WayPointCnt", &PJZAKO::ZakoInfo::m_WayPointCnt)
				.addProperty("m_boWaypointMoveStopping", &PJZAKO::ZakoInfo::m_boWaypointMoveStopping)
				.addProperty("m_GoPointKuruKuruCnt", &PJZAKO::ZakoInfo::m_GoPointKuruKuruCnt)
				.addProperty("m_boLookPC", &PJZAKO::ZakoInfo::m_boLookPC)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::ZakoInfo::m_ComboAtkTbl) == 16, "expected m_ComboAtkTbl to be size 16");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_NowComboAtkNo) == 4, "expected m_NowComboAtkNo to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_ComboAtkReq) == 1, "expected m_ComboAtkReq to be size 1");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_nMaxComboAtk) == 4, "expected m_nMaxComboAtk to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_eMaaiMovDir) == 4, "expected m_eMaaiMovDir to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_SideFromPc) == 4, "expected m_SideFromPc to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_PcSideFromMe) == 4, "expected m_PcSideFromMe to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_MoveCnt) == 8, "expected m_MoveCnt to be size 8");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_FrontVec) == 12, "expected m_FrontVec to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_EnmSubAngle) == 4, "expected m_EnmSubAngle to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fMaaiTbl) == 32, "expected m_fMaaiTbl to be size 32");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fMovSpd) == 4, "expected m_fMovSpd to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_CirclePcPointHnd) == 4, "expected m_CirclePcPointHnd to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_PrevPos) == 12, "expected m_PrevPos to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fWayPointMoveLength) == 4, "expected m_fWayPointMoveLength to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_WayPointCnt) == 4, "expected m_WayPointCnt to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_boWaypointMoveStopping) == 1, "expected m_boWaypointMoveStopping to be size 1");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_GoPointKuruKuruCnt) == 4, "expected m_GoPointKuruKuruCnt to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_boLookPC) == 1, "expected m_boLookPC to be size 1");
	static_assert(sizeof(PJZAKO::ZakoInfo) == 148, "expected struct PJZAKO::ZakoInfo to be size 148");

	// [Structure] struct PJZAKO::MotionInfo
	struct MotionInfo
	{
	public:
		/// Struct member variables

		// <int32_t m_MotionFrame, offset 0x0>
		int32_t m_MotionFrame;

		// <float m_fMotSpd, offset 0x4>
		float m_fMotSpd;

		// <int32_t m_nMaxCommonMot, offset 0x8>
		int32_t m_nMaxCommonMot;

		// <int32_t m_nMaxWepMot, offset 0xc>
		int32_t m_nMaxWepMot;

		std::string ToString() const { return "struct MotionInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::MotionInfo>("PJZAKO_MotionInfo")
				.addFunction("__tostring", &PJZAKO::MotionInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::MotionInfo::GetPtrAddr)
				.addProperty("m_MotionFrame", &PJZAKO::MotionInfo::m_MotionFrame)
				.addProperty("m_fMotSpd", &PJZAKO::MotionInfo::m_fMotSpd)
				.addProperty("m_nMaxCommonMot", &PJZAKO::MotionInfo::m_nMaxCommonMot)
				.addProperty("m_nMaxWepMot", &PJZAKO::MotionInfo::m_nMaxWepMot)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::MotionInfo::m_MotionFrame) == 4, "expected m_MotionFrame to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_fMotSpd) == 4, "expected m_fMotSpd to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_nMaxCommonMot) == 4, "expected m_nMaxCommonMot to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_nMaxWepMot) == 4, "expected m_nMaxWepMot to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo) == 16, "expected struct PJZAKO::MotionInfo to be size 16");

	// [Structure] struct PJZAKO::TojoInfo
	struct TojoInfo
	{
	public:
		/// Struct member variables

		// <uint8_t m_boWaitReleaseIdleState, offset 0x0>
		uint8_t m_boWaitReleaseIdleState;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData1[3];

	public:
		// <class commonObj* m_pSyncStgObj, offset 0x4>
		class commonObj* m_pSyncStgObj;

		// <uint8_t m_boGetOffCar, offset 0x8>
		uint8_t m_boGetOffCar;

		// <Unidentified data segment, offset 0x9>
	private:
		char _UnidentifiedData3[3];

	public:
		// <enum eZkCarSheet m_eCarSheet, offset 0xc>
		enum eZkCarSheet m_eCarSheet;

		// <uint8_t m_boBreakPopCmnObjStart, offset 0x10>
		uint8_t m_boBreakPopCmnObjStart;

		// <Unidentified data segment, offset 0x11>
	private:
		char _UnidentifiedData[3];
	public:

		std::string ToString() const { return "struct TojoInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::TojoInfo>("PJZAKO_TojoInfo")
				.addFunction("__tostring", &PJZAKO::TojoInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::TojoInfo::GetPtrAddr)
				.addProperty("m_boWaitReleaseIdleState", &PJZAKO::TojoInfo::m_boWaitReleaseIdleState)
				.addProperty("m_pSyncStgObj", &PJZAKO::TojoInfo::m_pSyncStgObj)
				.addProperty("m_boGetOffCar", &PJZAKO::TojoInfo::m_boGetOffCar)
				.addProperty("m_eCarSheet", &PJZAKO::TojoInfo::m_eCarSheet)
				.addProperty("m_boBreakPopCmnObjStart", &PJZAKO::TojoInfo::m_boBreakPopCmnObjStart)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::TojoInfo::m_boWaitReleaseIdleState) == 1, "expected m_boWaitReleaseIdleState to be size 1");
	static_assert(sizeof(PJZAKO::TojoInfo::m_pSyncStgObj) == 4, "expected m_pSyncStgObj to be size 4");
	static_assert(sizeof(PJZAKO::TojoInfo::m_boGetOffCar) == 1, "expected m_boGetOffCar to be size 1");
	static_assert(sizeof(PJZAKO::TojoInfo::m_eCarSheet) == 4, "expected m_eCarSheet to be size 4");
	static_assert(sizeof(PJZAKO::TojoInfo::m_boBreakPopCmnObjStart) == 1, "expected m_boBreakPopCmnObjStart to be size 1");
	static_assert(sizeof(PJZAKO::TojoInfo) == 20, "expected struct PJZAKO::TojoInfo to be size 20");

	// [Structure] struct PJZAKO::PcInfo
	struct PcInfo
	{
	public:
		/// Struct member variables

		// <struct Vec m_PcPosition, offset 0x0>
		struct Vec m_PcPosition;

		// <struct Vec m_PcDirection, offset 0xc>
		struct Vec m_PcDirection;

		// <struct Vec m_PcNavel, offset 0x18>
		struct Vec m_PcNavel;

		// <float m_PcDistance, offset 0x24>
		float m_PcDistance;

		// <struct Vec m_PcRot, offset 0x28>
		struct Vec m_PcRot;

		// <float m_PcSubAngle, offset 0x34>
		float m_PcSubAngle;

		// <enum enPcPose m_PcPose, offset 0x38>
		enum enPcPose m_PcPose;

		// <uint8_t m_LockonPc, offset 0x3c>
		uint8_t m_LockonPc;

		// <uint8_t m_boPcInSight, offset 0x3d>
		uint8_t m_boPcInSight;

		// <Unidentified data segment, offset 0x3e>
	private:
		char _UnidentifiedData[2];
	public:

		std::string ToString() const { return "struct PcInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::PcInfo>("PJZAKO_PcInfo")
				.addFunction("__tostring", &PJZAKO::PcInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::PcInfo::GetPtrAddr)
				.addProperty("m_PcPosition", &PJZAKO::PcInfo::m_PcPosition)
				.addProperty("m_PcDirection", &PJZAKO::PcInfo::m_PcDirection)
				.addProperty("m_PcNavel", &PJZAKO::PcInfo::m_PcNavel)
				.addProperty("m_PcDistance", &PJZAKO::PcInfo::m_PcDistance)
				.addProperty("m_PcRot", &PJZAKO::PcInfo::m_PcRot)
				.addProperty("m_PcSubAngle", &PJZAKO::PcInfo::m_PcSubAngle)
				.addProperty("m_PcPose", &PJZAKO::PcInfo::m_PcPose)
				.addProperty("m_LockonPc", &PJZAKO::PcInfo::m_LockonPc)
				.addProperty("m_boPcInSight", &PJZAKO::PcInfo::m_boPcInSight)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::PcInfo::m_PcPosition) == 12, "expected m_PcPosition to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcDirection) == 12, "expected m_PcDirection to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcNavel) == 12, "expected m_PcNavel to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcDistance) == 4, "expected m_PcDistance to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcRot) == 12, "expected m_PcRot to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcSubAngle) == 4, "expected m_PcSubAngle to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcPose) == 4, "expected m_PcPose to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_LockonPc) == 1, "expected m_LockonPc to be size 1");
	static_assert(sizeof(PJZAKO::PcInfo::m_boPcInSight) == 1, "expected m_boPcInSight to be size 1");
	static_assert(sizeof(PJZAKO::PcInfo) == 64, "expected struct PJZAKO::PcInfo to be size 64");

	// [Structure] struct PJZAKO::DmgInfo
	struct DmgInfo
	{
	public:
		/// Struct member variables

		// <int32_t mLoseSightTick, offset 0x0>
		int32_t mLoseSightTick;

		// <int32_t m_PiyoDuration, offset 0x4>
		int32_t m_PiyoDuration;

		// <int32_t m_mSetDmgDir, offset 0x8>
		int32_t m_mSetDmgDir;

		// <enum eDownDir m_eDownDir, offset 0xc>
		enum eDownDir m_eDownDir;

		// <int32_t m_FuttobiDur, offset 0x10>
		int32_t m_FuttobiDur;

		// <int32_t m_DagekiCounterCnt, offset 0x14>
		int32_t m_DagekiCounterCnt;

		// <uint8_t m_boDagekiCounterAttack, offset 0x18>
		uint8_t m_boDagekiCounterAttack;

		// <Unidentified data segment, offset 0x19>
	private:
		char _UnidentifiedData7[3];

	public:
		// <int32_t m_PiyoTick, offset 0x1c>
		int32_t m_PiyoTick;

		// <int32_t m_RestStompDropMoneyTime, offset 0x20>
		int32_t m_RestStompDropMoneyTime;

		// <float m_fKnockBackDist, offset 0x24>
		float m_fKnockBackDist;

		// <float m_fKnockBackSpd, offset 0x28>
		float m_fKnockBackSpd;

		// <float m_fDbgKnockBackSum, offset 0x2c>
		float m_fDbgKnockBackSum;

		// <struct Vec m_VecKnocBack, offset 0x30>
		struct Vec m_VecKnocBack;

		// <float m_fInAtkRotY, offset 0x3c>
		float m_fInAtkRotY;

		// <uint8_t m_boCantCreaatedDeadModelByNoMemory, offset 0x40>
		uint8_t m_boCantCreaatedDeadModelByNoMemory;

		// <Unidentified data segment, offset 0x41>
	private:
		char _UnidentifiedData[3];
	public:

		std::string ToString() const { return "struct DmgInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::DmgInfo>("PJZAKO_DmgInfo")
				.addFunction("__tostring", &PJZAKO::DmgInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::DmgInfo::GetPtrAddr)
				.addProperty("mLoseSightTick", &PJZAKO::DmgInfo::mLoseSightTick)
				.addProperty("m_PiyoDuration", &PJZAKO::DmgInfo::m_PiyoDuration)
				.addProperty("m_mSetDmgDir", &PJZAKO::DmgInfo::m_mSetDmgDir)
				.addProperty("m_eDownDir", &PJZAKO::DmgInfo::m_eDownDir)
				.addProperty("m_FuttobiDur", &PJZAKO::DmgInfo::m_FuttobiDur)
				.addProperty("m_DagekiCounterCnt", &PJZAKO::DmgInfo::m_DagekiCounterCnt)
				.addProperty("m_boDagekiCounterAttack", &PJZAKO::DmgInfo::m_boDagekiCounterAttack)
				.addProperty("m_PiyoTick", &PJZAKO::DmgInfo::m_PiyoTick)
				.addProperty("m_RestStompDropMoneyTime", &PJZAKO::DmgInfo::m_RestStompDropMoneyTime)
				.addProperty("m_fKnockBackDist", &PJZAKO::DmgInfo::m_fKnockBackDist)
				.addProperty("m_fKnockBackSpd", &PJZAKO::DmgInfo::m_fKnockBackSpd)
				.addProperty("m_fDbgKnockBackSum", &PJZAKO::DmgInfo::m_fDbgKnockBackSum)
				.addProperty("m_VecKnocBack", &PJZAKO::DmgInfo::m_VecKnocBack)
				.addProperty("m_fInAtkRotY", &PJZAKO::DmgInfo::m_fInAtkRotY)
				.addProperty("m_boCantCreaatedDeadModelByNoMemory", &PJZAKO::DmgInfo::m_boCantCreaatedDeadModelByNoMemory)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::DmgInfo::mLoseSightTick) == 4, "expected mLoseSightTick to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_PiyoDuration) == 4, "expected m_PiyoDuration to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_mSetDmgDir) == 4, "expected m_mSetDmgDir to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_eDownDir) == 4, "expected m_eDownDir to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_FuttobiDur) == 4, "expected m_FuttobiDur to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_DagekiCounterCnt) == 4, "expected m_DagekiCounterCnt to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_boDagekiCounterAttack) == 1, "expected m_boDagekiCounterAttack to be size 1");
	static_assert(sizeof(PJZAKO::DmgInfo::m_PiyoTick) == 4, "expected m_PiyoTick to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_RestStompDropMoneyTime) == 4, "expected m_RestStompDropMoneyTime to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fKnockBackDist) == 4, "expected m_fKnockBackDist to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fKnockBackSpd) == 4, "expected m_fKnockBackSpd to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fDbgKnockBackSum) == 4, "expected m_fDbgKnockBackSum to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_VecKnocBack) == 12, "expected m_VecKnocBack to be size 12");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fInAtkRotY) == 4, "expected m_fInAtkRotY to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_boCantCreaatedDeadModelByNoMemory) == 1, "expected m_boCantCreaatedDeadModelByNoMemory to be size 1");
	static_assert(sizeof(PJZAKO::DmgInfo) == 68, "expected struct PJZAKO::DmgInfo to be size 68");

	// [Structure] struct PJZAKO::AiInfo
	struct AiInfo
	{
	public:
		/// Struct member variables

		// <uint8_t m_boCutAi, offset 0x0>
		uint8_t m_boCutAi;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData1[3];

	public:
		// <int32_t m_ThinkCnt, offset 0x4>
		int32_t m_ThinkCnt;

		// <struct ZkEvacuateParam m_EvacuateParam, offset 0x8>
		struct ZkEvacuateParam m_EvacuateParam;

		// <struct ZkGuardParam m_GuardParam, offset 0x10>
		struct ZkGuardParam m_GuardParam;

		// <enum eFightLine m_FightLine, offset 0x20>
		enum eFightLine m_FightLine;

		// <class FkCounter m_AtkCnt, offset 0x24>
		class FkCounter m_AtkCnt;

		// <int32_t m_OffensiveMol, offset 0x2c>
		int32_t m_OffensiveMol;

		// <enum FightSpirit m_FS, offset 0x30>
		enum FightSpirit m_FS;

		// <int32_t m_boHitPrevAttack, offset 0x34>
		int32_t m_boHitPrevAttack;

		// <int32_t m_AtkAiLvRand, offset 0x38>
		int32_t m_AtkAiLvRand;

		// <class FkCounter m_PressureCnt, offset 0x3c>
		class FkCounter m_PressureCnt;

		// <int32_t m_ReactRatio, offset 0x44>
		int32_t m_ReactRatio;

		// <int32_t m_PathFindIntervalCnt, offset 0x48>
		int32_t m_PathFindIntervalCnt;

		std::string ToString() const { return "struct AiInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::AiInfo>("PJZAKO_AiInfo")
				.addFunction("__tostring", &PJZAKO::AiInfo::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::AiInfo::GetPtrAddr)
				.addProperty("m_boCutAi", &PJZAKO::AiInfo::m_boCutAi)
				.addProperty("m_ThinkCnt", &PJZAKO::AiInfo::m_ThinkCnt)
				.addProperty("m_EvacuateParam", &PJZAKO::AiInfo::m_EvacuateParam)
				.addProperty("m_GuardParam", &PJZAKO::AiInfo::m_GuardParam)
				.addProperty("m_FightLine", &PJZAKO::AiInfo::m_FightLine)
				.addProperty("m_AtkCnt", &PJZAKO::AiInfo::m_AtkCnt)
				.addProperty("m_OffensiveMol", &PJZAKO::AiInfo::m_OffensiveMol)
				.addProperty("m_FS", &PJZAKO::AiInfo::m_FS)
				.addProperty("m_boHitPrevAttack", &PJZAKO::AiInfo::m_boHitPrevAttack)
				.addProperty("m_AtkAiLvRand", &PJZAKO::AiInfo::m_AtkAiLvRand)
				.addProperty("m_PressureCnt", &PJZAKO::AiInfo::m_PressureCnt)
				.addProperty("m_ReactRatio", &PJZAKO::AiInfo::m_ReactRatio)
				.addProperty("m_PathFindIntervalCnt", &PJZAKO::AiInfo::m_PathFindIntervalCnt)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::AiInfo::m_boCutAi) == 1, "expected m_boCutAi to be size 1");
	static_assert(sizeof(PJZAKO::AiInfo::m_ThinkCnt) == 4, "expected m_ThinkCnt to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_EvacuateParam) == 8, "expected m_EvacuateParam to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_GuardParam) == 16, "expected m_GuardParam to be size 16");
	static_assert(sizeof(PJZAKO::AiInfo::m_FightLine) == 4, "expected m_FightLine to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_AtkCnt) == 8, "expected m_AtkCnt to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_OffensiveMol) == 4, "expected m_OffensiveMol to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_FS) == 4, "expected m_FS to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_boHitPrevAttack) == 4, "expected m_boHitPrevAttack to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_AtkAiLvRand) == 4, "expected m_AtkAiLvRand to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_PressureCnt) == 8, "expected m_PressureCnt to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_ReactRatio) == 4, "expected m_ReactRatio to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_PathFindIntervalCnt) == 4, "expected m_PathFindIntervalCnt to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo) == 76, "expected struct PJZAKO::AiInfo to be size 76");

	// [Structure] struct PJZAKO::EfDanmen
	struct EfDanmen
	{
	public:
		/// Struct member variables

		// <class EffectDanmenFlash* pEf, offset 0x0>
		class EffectDanmenFlash* pEf;

		// <struct tagHRTASKCHECK taskCheck, offset 0x4>
		struct tagHRTASKCHECK taskCheck;

		std::string ToString() const { return "struct EfDanmen(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::EfDanmen>("PJZAKO_EfDanmen")
				.addFunction("__tostring", &PJZAKO::EfDanmen::ToString)
				.addFunction("GetPtrAddr", &PJZAKO::EfDanmen::GetPtrAddr)
				.addProperty("pEf", &PJZAKO::EfDanmen::pEf)
				.addProperty("taskCheck", &PJZAKO::EfDanmen::taskCheck)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::EfDanmen::pEf) == 4, "expected pEf to be size 4");
	static_assert(sizeof(PJZAKO::EfDanmen::taskCheck) == 8, "expected taskCheck to be size 8");
	static_assert(sizeof(PJZAKO::EfDanmen) == 12, "expected struct PJZAKO::EfDanmen to be size 12");

	// enum PJZAKO::eSuddenAtkPopDir
	enum eSuddenAtkPopDir : uint32_t
	{
		// <eSuddenAtkPopDir_UNKNOWN = 0xffffffffffffffff>
		eSuddenAtkPopDir_UNKNOWN = UINT32_MAX,

		// <eSuddenAtkPopDir_Above = 0x0>
		eSuddenAtkPopDir_Above = 0,

		// <eSuddenAtkPopDir_FromR = 0x1>
		eSuddenAtkPopDir_FromR = 1,

		// <eSuddenAtkPopDir_FromL = 0x2>
		eSuddenAtkPopDir_FromL = 2

	};

	// enum PJZAKO::eTimeShare
	enum eTimeShare : uint32_t
	{
		// <eTimeShare_Begin = 0x0>
		eTimeShare_Begin = 0,

		// <eTimeShare_ColBack = 0x1>
		eTimeShare_ColBack = 1,

		// <eTimeShare_ColLeft = 0x2>
		eTimeShare_ColLeft = 2,

		// <eTimeShare_ColRight = 0x3>
		eTimeShare_ColRight = 3,

		// <eTimeShare_PcInSight = 0x4>
		eTimeShare_PcInSight = 4,

		// <eTimeShare_End = 0x5>
		eTimeShare_End = 5

	};

	// [Function] uint8_t __convention("thiscall") PJZAKO::IsSetDamageFromPcThroughAttack(class PJZAKO* const this, class mHRChara* arg2) [?IsSetDamageFromPcThroughAttack@PJZAKO@@AAE_NPAVmHRChara@@@Z]
	uint8_t IsSetDamageFromPcThroughAttack(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class PJZAKO* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x4d5b50);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_Dead(class PJZAKO* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4) [?mSetDamage_Dead@PJZAKO@@AAEXHHPBVmHRChara@@@Z]
	void mSetDamage_Dead(int32_t const arg2, int32_t const arg3, class mHRChara* arg4)
	{
		typedef void(__thiscall* _Func)(class PJZAKO* const thisPtr, int32_t const arg2, int32_t const arg3, class mHRChara* arg4);
		_Func mFunc = (_Func)(GameModule + 0x4d5fd0);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_CutDamage(class PJZAKO* const this, class mHRChara* arg2, int32_t arg3) [?mSetDamage_CutDamage@PJZAKO@@AAEXPAVmHRChara@@H@Z]
	void mSetDamage_CutDamage(class mHRChara* arg2, int32_t arg3)
	{
		typedef void(__thiscall* _Func)(class PJZAKO* const thisPtr, class mHRChara* arg2, int32_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x4d63f0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_NoStateChangeDamage(class PJZAKO* const this, class mHRChara* arg2) [?mSetDamage_NoStateChangeDamage@PJZAKO@@AAEXPAVmHRChara@@@Z]
	void mSetDamage_NoStateChangeDamage(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class PJZAKO* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x4d6510);
		return mFunc(this, arg2);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_DamageCounterProc(class PJZAKO* const this, int32_t* arg2, class mHRChara* arg3) [?mSetDamage_DamageCounterProc@PJZAKO@@AAEXPAHPAVmHRChara@@@Z]
	void mSetDamage_DamageCounterProc(int32_t* arg2, class mHRChara* arg3)
	{
		typedef void(__thiscall* _Func)(class PJZAKO* const thisPtr, int32_t* arg2, class mHRChara* arg3);
		_Func mFunc = (_Func)(GameModule + 0x4d65a0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_InitDamageReaction(class PJZAKO* const this, class mHRChara* arg2, int32_t const arg3) [?mSetDamage_InitDamageReaction@PJZAKO@@AAEXPBVmHRChara@@H@Z]
	void mSetDamage_InitDamageReaction(class mHRChara* arg2, int32_t const arg3)
	{
		typedef void(__thiscall* _Func)(class PJZAKO* const thisPtr, class mHRChara* arg2, int32_t const arg3);
		_Func mFunc = (_Func)(GameModule + 0x4d6720);
		return mFunc(this, arg2, arg3);
	}
	// [Function] void __convention("thiscall") PJZAKO::mSetDamage_Initialize(class PJZAKO* const this, class mHRChara* arg2, int32_t const arg3) [?mSetDamage_Initialize@PJZAKO@@AAEXPBVmHRChara@@H@Z]
	void mSetDamage_Initialize(class mHRChara* arg2, int32_t const arg3)
	{
		typedef void(__thiscall* _Func)(class PJZAKO* const thisPtr, class mHRChara* arg2, int32_t const arg3);
		_Func mFunc = (_Func)(GameModule + 0x4d6780);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") PJZAKO::mSetDamage(class PJZAKO* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJZAKO@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class PJZAKO* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x4d67f0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] void __convention("thiscall") PJZAKO::CheckSetDmgFuncGarbageInData(class PJZAKO* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?CheckSetDmgFuncGarbageInData@PJZAKO@@AAEXMHHHMHMMPAVmHRChara@@@Z]
	void CheckSetDmgFuncGarbageInData(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef void(__thiscall* _Func)(class PJZAKO* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x4d75d0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] int32_t __convention("thiscall") PJZAKO::ConvertDmgMot(class PJZAKO* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4) [?ConvertDmgMot@PJZAKO@@EAEHHHPAVmHRChara@@@Z]
	int32_t ConvertDmgMot(int32_t const arg2, int32_t const arg3, class mHRChara* arg4)
	{
		typedef int32_t(__thiscall* _Func)(class PJZAKO* const thisPtr, int32_t const arg2, int32_t const arg3, class mHRChara* arg4);
		_Func mFunc = (_Func)(GameModule + 0x4d7850);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] int32_t __fastcall PJZAKO::StaticProc(class mHRBattle* arg1) [?StaticProc@PJZAKO@@CAXXZ]
	static int32_t StaticProc(class mHRBattle* arg1)
	{
		typedef int32_t(__fastcall* _Func)(class mHRBattle* arg1);
		_Func mFunc = (_Func)(GameModule + 0x4de320);
		return mFunc(arg1);
	}
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <class PJState* m_StatePtrArr[0x3c], offset 0x580>
	class PJState* m_StatePtrArr[60];

	// <enum eZkBoneScale m_BoneScale, offset 0x670>
	enum eZkBoneScale m_BoneScale;

	// <struct ZkSetDamageInfo m_SetDamageInfo, offset 0x674>
	struct ZkSetDamageInfo m_SetDamageInfo;

	// <struct PJZAKO::ZakoInfo m_ZakoInfo, offset 0x678>
	struct PJZAKO::ZakoInfo m_ZakoInfo;

	// <struct PJZAKO::MotionInfo m_MotionInfo, offset 0x70c>
	struct PJZAKO::MotionInfo m_MotionInfo;

	// <struct PJZAKO::TojoInfo m_TojoInfo, offset 0x71c>
	struct PJZAKO::TojoInfo m_TojoInfo;

	// <struct PJZAKO::PcInfo m_PcInfo, offset 0x730>
	struct PJZAKO::PcInfo m_PcInfo;

	// <struct PJZAKO::DmgInfo m_DmgInfo, offset 0x770>
	struct PJZAKO::DmgInfo m_DmgInfo;

	// <struct PJZAKO::AiInfo m_AiInfo, offset 0x7b4>
	struct PJZAKO::AiInfo m_AiInfo;

	// <int32_t m_Counter, offset 0x800>
	int32_t m_Counter;

	// <int32_t m_CheckCanHitPrevCnt, offset 0x804>
	int32_t m_CheckCanHitPrevCnt;

	// <int32_t m_AddKillNumWaitCounter, offset 0x808>
	int32_t m_AddKillNumWaitCounter;

	// <uint8_t m_boAddedKillNum, offset 0x80c>
	uint8_t m_boAddedKillNum;

	// <uint8_t m_boMoveTurretFlag, offset 0x80d>
	uint8_t m_boMoveTurretFlag;

	// <uint8_t m_boWayPointMoveAfterPop, offset 0x80e>
	uint8_t m_boWayPointMoveAfterPop;

	// <Unidentified data segment, offset 0x80f>
private:
	char _UnidentifiedData16[1];

public:
	// <class PJStateMachine* m_pStateMachine, offset 0x810>
	class PJStateMachine* m_pStateMachine;

	// <enum eZkStat m_eNowStateIdx, offset 0x814>
	enum eZkStat m_eNowStateIdx;

	// <enum eZkStat m_ePrevStateIdx, offset 0x818>
	enum eZkStat m_ePrevStateIdx;

	// <enum eScareType m_eScareType, offset 0x81c>
	enum eScareType m_eScareType;

	// <float mTargetDirec, offset 0x820>
	float mTargetDirec;

	// <float mNowDirecY, offset 0x824>
	float mNowDirecY;

	// <int32_t mDeadModelType, offset 0x828>
	int32_t mDeadModelType;

	// <struct PJZAKO::EfDanmen m_EfDanmen, offset 0x82c>
	struct PJZAKO::EfDanmen m_EfDanmen;

	// <class EffectCutMark* m_pCutMark, offset 0x838>
	class EffectCutMark* m_pCutMark;

	// <class EffectQuestion* mpEfQuestion, offset 0x83c>
	class EffectQuestion* mpEfQuestion;

	// <class PJZakoMotMng* m_pMotMng, offset 0x840>
	class PJZakoMotMng* m_pMotMng;

	// <class FkStlVector<Vec> m_WayPointArry, offset 0x844>
	class FkStlVector<Vec> m_WayPointArry;

	// <int32_t m_iWayPoint, offset 0x858>
	int32_t m_iWayPoint;

	// <class PathPlanner* m_pPathPlanner, offset 0x85c>
	class PathPlanner* m_pPathPlanner;

	// <uint8_t m_boUseObstacleSensor, offset 0x860>
	uint8_t m_boUseObstacleSensor;

	// <uint8_t m_boDisableInterestIK, offset 0x861>
	uint8_t m_boDisableInterestIK;

	// <uint8_t m_boBerserkAtk, offset 0x862>
	uint8_t m_boBerserkAtk;

	// <uint8_t m_boRequestDeathOutOfCamera, offset 0x863>
	uint8_t m_boRequestDeathOutOfCamera;

	// <uint8_t m_boFirstBombDeadFxPlay, offset 0x864>
	uint8_t m_boFirstBombDeadFxPlay;

	// <Unidentified data segment, offset 0x865>
private:
	char _UnidentifiedData35[3];

public:
	// <struct Vec m_JumpOffTojoLandingPos, offset 0x868>
	struct Vec m_JumpOffTojoLandingPos;

	// <uint8_t m_boFixTurret, offset 0x874>
	uint8_t m_boFixTurret;

	// <Unidentified data segment, offset 0x875>
private:
	char _UnidentifiedData37[3];

public:
	// <enum PJZAKO::eSuddenAtkPopDir m_eSdnAtkPopDir, offset 0x878>
	enum PJZAKO::eSuddenAtkPopDir m_eSdnAtkPopDir;

	// <class FkDynamicParam* m_pDP, offset 0x87c>
	class FkDynamicParam* m_pDP;

	// <class FkObstacleSensor* m_pObsSens, offset 0x880>
	class FkObstacleSensor* m_pObsSens;

	// <int32_t m_Atk2PcHitAfterCnt, offset 0x884>
	int32_t m_Atk2PcHitAfterCnt;

	// <uint8_t m_boPcDownLaugh, offset 0x888>
	uint8_t m_boPcDownLaugh;

	// <Unidentified data segment, offset 0x889>
private:
	char _UnidentifiedData42[3];

public:
	// <class FkBulletManager* m_pBulletManager, offset 0x88c>
	class FkBulletManager* m_pBulletManager;

	// <uint8_t m_boPhysicDeadProc, offset 0x890>
	uint8_t m_boPhysicDeadProc;

	// <uint8_t m_bIsHeadPhysicsEnd, offset 0x891>
	uint8_t m_bIsHeadPhysicsEnd;

	// <Unidentified data segment, offset 0x892>
private:
	char _UnidentifiedData45[2];

public:
	// <class TGmf* m_pPhysicDeadGmf, offset 0x894>
	class TGmf* m_pPhysicDeadGmf;

	// <uint8_t m_boTodomeDead, offset 0x898>
	uint8_t m_boTodomeDead;

	// <uint8_t m_boDeadEffectReq, offset 0x899>
	uint8_t m_boDeadEffectReq;

	// <Unidentified data segment, offset 0x89a>
private:
	char _UnidentifiedData48[2];

public:
	// <int32_t m_DeadEffectCountCown, offset 0x89c>
	int32_t m_DeadEffectCountCown;

	// <int32_t m_ParticleDeadZakoTerminateWaitTick, offset 0x8a0>
	int32_t m_ParticleDeadZakoTerminateWaitTick;

	// <class mot::CBoneEffectDamageData* m_pBnFxDmgDat, offset 0x8a4>
	class mot::CBoneEffectDamageData* m_pBnFxDmgDat;

	// <uint8_t m_boTimeShareUpdate, offset 0x8a8>
	uint8_t m_boTimeShareUpdate;

	// <Unidentified data segment, offset 0x8a9>
private:
	char _UnidentifiedData52[3];

public:
	// <enum PJZAKO::eTimeShare m_eTimeShareStat, offset 0x8ac>
	enum PJZAKO::eTimeShare m_eTimeShareStat;

	// <struct CollInfo m_CollInfo, offset 0x8b0>
	struct CollInfo m_CollInfo;

	// <struct tagGHMR_TEX m_Tex, offset 0x8bc>
	struct tagGHMR_TEX m_Tex;

	// <int32_t m_ChangeStateLimitTick, offset 0x8e4>
	int32_t m_ChangeStateLimitTick;

	// <float m_fRotSpd, offset 0x8e8>
	float m_fRotSpd;

	// <class FkStlList<commonObj *> m_BreakPopCmnObjPtrList, offset 0x8ec>
	class FkStlList<commonObj *> m_BreakPopCmnObjPtrList;

	// <class commonObj* m_pSyncPopCmnObj, offset 0x8f8>
	class commonObj* m_pSyncPopCmnObj;

	// <uint8_t m_boCalledNoGuardEfOnce, offset 0x8fc>
	uint8_t m_boCalledNoGuardEfOnce;

	// <Unidentified data segment, offset 0x8fd>
private:
	char _UnidentifiedData60[3];

public:
	// <int32_t m_OutOfCameraIkakuShootTime, offset 0x900>
	int32_t m_OutOfCameraIkakuShootTime;

	// <class State_Damage m_State_Damage, offset 0x904>
	class State_Damage m_State_Damage;

	// <class State_CloseBeforeAttack m_State_CloseForAtk, offset 0x910>
	class State_CloseBeforeAttack m_State_CloseForAtk;

	// <class State_AwayAfterAttack m_State_AwayAfterAtk, offset 0x914>
	class State_AwayAfterAttack m_State_AwayAfterAtk;

	// <class State_ComboAttack m_State_ComboAttack, offset 0x918>
	class State_ComboAttack m_State_ComboAttack;

	// <class State_StepInAttack m_State_StepInAttack, offset 0x924>
	class State_StepInAttack m_State_StepInAttack;

	// <class State_Defence m_State_Defence, offset 0x928>
	class State_Defence m_State_Defence;

	// <class State_Evacuate m_State_Evacuate, offset 0x930>
	class State_Evacuate m_State_Evacuate;

	// <class State_RandomMove m_State_RandomMove, offset 0x938>
	class State_RandomMove m_State_RandomMove;

	// <class State_ThroughDamage m_State_ThroughDamage, offset 0x940>
	class State_ThroughDamage m_State_ThroughDamage;

	// <class State_DownDamage m_State_DownDamage, offset 0x948>
	class State_DownDamage m_State_DownDamage;

	// <class State_Pressure m_State_Pressure, offset 0x94c>
	class State_Pressure m_State_Pressure;

	// <class State_WayPointMove m_State_WayPointMove, offset 0x958>
	class State_WayPointMove m_State_WayPointMove;

	// <class State_Scare_Run m_State_Run, offset 0x960>
	class State_Scare_Run m_State_Run;

	// <class State_Scare_Kosinukasi m_State_Kosinukasi, offset 0x968>
	class State_Scare_Kosinukasi m_State_Kosinukasi;

	// <class State_Scare_Yotunbai m_State_Yotunbai, offset 0x970>
	class State_Scare_Yotunbai m_State_Yotunbai;

	// <class State_Scare_Stand m_State_Stand, offset 0x978>
	class State_Scare_Stand m_State_Stand;

	// <class State_PerformIll m_StatePerformIll, offset 0x980>
	class State_PerformIll m_StatePerformIll;

	// <class State_ReleaseWaitIdle m_ReleaseWaitIdle, offset 0x988>
	class State_ReleaseWaitIdle m_ReleaseWaitIdle;

	// <class State_Tojo_RunAndTurnPc m_State_Tojo_RunAndTurnPc, offset 0x98c>
	class State_Tojo_RunAndTurnPc m_State_Tojo_RunAndTurnPc;

	// <class State_Tojo_AgainstWall m_State_Tojo_AgainstWall, offset 0x990>
	class State_Tojo_AgainstWall m_State_Tojo_AgainstWall;

	// <class State_Tojo_LookAround m_State_Tojo_LookAround, offset 0x994>
	class State_Tojo_LookAround m_State_Tojo_LookAround;

	// <class State_Tojo_Stand m_State_Tojo_Stand, offset 0x998>
	class State_Tojo_Stand m_State_Tojo_Stand;

	// <class State_Tojo_Bench m_State_Tojo_Bench, offset 0x99c>
	class State_Tojo_Bench m_State_Tojo_Bench;

	// <class State_Tojo_Sit m_State_Tojo_Sit, offset 0x9a0>
	class State_Tojo_Sit m_State_Tojo_Sit;

	// <class State_Tojo_Car m_State_Tojo_Car, offset 0x9a4>
	class State_Tojo_Car m_State_Tojo_Car;

	// <class State_Tojo_JumpOff m_State_Tojo_JumpOff, offset 0x9ac>
	class State_Tojo_JumpOff m_State_Tojo_JumpOff;

	// <class State_Tojo_BreakCmnObj m_State_Tojo_BreakCmnObj, offset 0x9b4>
	class State_Tojo_BreakCmnObj m_State_Tojo_BreakCmnObj;

	// <class State_Tojo_AeroBike m_State_Tojo_AeroBike, offset 0x9c0>
	class State_Tojo_AeroBike m_State_Tojo_AeroBike;

	// <class State_Tojo_RoomRunner m_State_Tojo_RoomRunner, offset 0x9c8>
	class State_Tojo_RoomRunner m_State_Tojo_RoomRunner;

	// <class State_LeadPcWayPointMove m_State_LeadPcWayPointMove, offset 0x9d0>
	class State_LeadPcWayPointMove m_State_LeadPcWayPointMove;

	// <class State_FixTurret m_State_FixTurret, offset 0x9d4>
	class State_FixTurret m_State_FixTurret;

	// <class State_WayPointMoveAfterPop m_State_WayPointMoveAfterPop, offset 0x9d8>
	class State_WayPointMoveAfterPop m_State_WayPointMoveAfterPop;

	// <class ZkState_DownAttack m_State_DownAttack, offset 0x9dc>
	class ZkState_DownAttack m_State_DownAttack;

	std::string ToString() const { return "class PJZAKO(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZAKO, mHRChara>("PJZAKO")
			.addFunction("__tostring", &PJZAKO::ToString)
			.addFunction("GetPtrAddr", &PJZAKO::GetPtrAddr)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StatePtrArr", &PJZAKO::m_StatePtrArr)
			.addProperty("m_BoneScale", &PJZAKO::m_BoneScale)
			.addProperty("m_SetDamageInfo", &PJZAKO::m_SetDamageInfo)
			.addProperty("m_ZakoInfo", &PJZAKO::m_ZakoInfo)
			.addProperty("m_MotionInfo", &PJZAKO::m_MotionInfo)
			.addProperty("m_TojoInfo", &PJZAKO::m_TojoInfo)
			.addProperty("m_PcInfo", &PJZAKO::m_PcInfo)
			.addProperty("m_DmgInfo", &PJZAKO::m_DmgInfo)
			.addProperty("m_AiInfo", &PJZAKO::m_AiInfo)
			.addProperty("m_Counter", &PJZAKO::m_Counter)
			.addProperty("m_CheckCanHitPrevCnt", &PJZAKO::m_CheckCanHitPrevCnt)
			.addProperty("m_AddKillNumWaitCounter", &PJZAKO::m_AddKillNumWaitCounter)
			.addProperty("m_boAddedKillNum", &PJZAKO::m_boAddedKillNum)
			.addProperty("m_boMoveTurretFlag", &PJZAKO::m_boMoveTurretFlag)
			.addProperty("m_boWayPointMoveAfterPop", &PJZAKO::m_boWayPointMoveAfterPop)
			.addProperty("m_pStateMachine", &PJZAKO::m_pStateMachine)
			.addProperty("m_eNowStateIdx", &PJZAKO::m_eNowStateIdx)
			.addProperty("m_ePrevStateIdx", &PJZAKO::m_ePrevStateIdx)
			.addProperty("m_eScareType", &PJZAKO::m_eScareType)
			.addProperty("mTargetDirec", &PJZAKO::mTargetDirec)
			.addProperty("mNowDirecY", &PJZAKO::mNowDirecY)
			.addProperty("mDeadModelType", &PJZAKO::mDeadModelType)
			.addProperty("m_EfDanmen", &PJZAKO::m_EfDanmen)
			.addProperty("m_pCutMark", &PJZAKO::m_pCutMark)
			.addProperty("mpEfQuestion", &PJZAKO::mpEfQuestion)
			.addProperty("m_pMotMng", &PJZAKO::m_pMotMng)
			.addProperty("m_WayPointArry", &PJZAKO::m_WayPointArry)
			.addProperty("m_iWayPoint", &PJZAKO::m_iWayPoint)
			.addProperty("m_pPathPlanner", &PJZAKO::m_pPathPlanner)
			.addProperty("m_boUseObstacleSensor", &PJZAKO::m_boUseObstacleSensor)
			.addProperty("m_boDisableInterestIK", &PJZAKO::m_boDisableInterestIK)
			.addProperty("m_boBerserkAtk", &PJZAKO::m_boBerserkAtk)
			.addProperty("m_boRequestDeathOutOfCamera", &PJZAKO::m_boRequestDeathOutOfCamera)
			.addProperty("m_boFirstBombDeadFxPlay", &PJZAKO::m_boFirstBombDeadFxPlay)
			.addProperty("m_JumpOffTojoLandingPos", &PJZAKO::m_JumpOffTojoLandingPos)
			.addProperty("m_boFixTurret", &PJZAKO::m_boFixTurret)
			.addProperty("m_eSdnAtkPopDir", &PJZAKO::m_eSdnAtkPopDir)
			.addProperty("m_pDP", &PJZAKO::m_pDP)
			.addProperty("m_pObsSens", &PJZAKO::m_pObsSens)
			.addProperty("m_Atk2PcHitAfterCnt", &PJZAKO::m_Atk2PcHitAfterCnt)
			.addProperty("m_boPcDownLaugh", &PJZAKO::m_boPcDownLaugh)
			.addProperty("m_pBulletManager", &PJZAKO::m_pBulletManager)
			.addProperty("m_boPhysicDeadProc", &PJZAKO::m_boPhysicDeadProc)
			.addProperty("m_bIsHeadPhysicsEnd", &PJZAKO::m_bIsHeadPhysicsEnd)
			.addProperty("m_pPhysicDeadGmf", &PJZAKO::m_pPhysicDeadGmf)
			.addProperty("m_boTodomeDead", &PJZAKO::m_boTodomeDead)
			.addProperty("m_boDeadEffectReq", &PJZAKO::m_boDeadEffectReq)
			.addProperty("m_DeadEffectCountCown", &PJZAKO::m_DeadEffectCountCown)
			.addProperty("m_ParticleDeadZakoTerminateWaitTick", &PJZAKO::m_ParticleDeadZakoTerminateWaitTick)
			.addProperty("m_pBnFxDmgDat", &PJZAKO::m_pBnFxDmgDat)
			.addProperty("m_boTimeShareUpdate", &PJZAKO::m_boTimeShareUpdate)
			.addProperty("m_eTimeShareStat", &PJZAKO::m_eTimeShareStat)
			.addProperty("m_CollInfo", &PJZAKO::m_CollInfo)
			.addProperty("m_Tex", &PJZAKO::m_Tex)
			.addProperty("m_ChangeStateLimitTick", &PJZAKO::m_ChangeStateLimitTick)
			.addProperty("m_fRotSpd", &PJZAKO::m_fRotSpd)
			.addProperty("m_BreakPopCmnObjPtrList", &PJZAKO::m_BreakPopCmnObjPtrList)
			.addProperty("m_pSyncPopCmnObj", &PJZAKO::m_pSyncPopCmnObj)
			.addProperty("m_boCalledNoGuardEfOnce", &PJZAKO::m_boCalledNoGuardEfOnce)
			.addProperty("m_OutOfCameraIkakuShootTime", &PJZAKO::m_OutOfCameraIkakuShootTime)
			.addProperty("m_State_Damage", &PJZAKO::m_State_Damage)
			.addProperty("m_State_CloseForAtk", &PJZAKO::m_State_CloseForAtk)
			.addProperty("m_State_AwayAfterAtk", &PJZAKO::m_State_AwayAfterAtk)
			.addProperty("m_State_ComboAttack", &PJZAKO::m_State_ComboAttack)
			.addProperty("m_State_StepInAttack", &PJZAKO::m_State_StepInAttack)
			.addProperty("m_State_Defence", &PJZAKO::m_State_Defence)
			.addProperty("m_State_Evacuate", &PJZAKO::m_State_Evacuate)
			.addProperty("m_State_RandomMove", &PJZAKO::m_State_RandomMove)
			.addProperty("m_State_ThroughDamage", &PJZAKO::m_State_ThroughDamage)
			.addProperty("m_State_DownDamage", &PJZAKO::m_State_DownDamage)
			.addProperty("m_State_Pressure", &PJZAKO::m_State_Pressure)
			.addProperty("m_State_WayPointMove", &PJZAKO::m_State_WayPointMove)
			.addProperty("m_State_Run", &PJZAKO::m_State_Run)
			.addProperty("m_State_Kosinukasi", &PJZAKO::m_State_Kosinukasi)
			.addProperty("m_State_Yotunbai", &PJZAKO::m_State_Yotunbai)
			.addProperty("m_State_Stand", &PJZAKO::m_State_Stand)
			.addProperty("m_StatePerformIll", &PJZAKO::m_StatePerformIll)
			.addProperty("m_ReleaseWaitIdle", &PJZAKO::m_ReleaseWaitIdle)
			.addProperty("m_State_Tojo_RunAndTurnPc", &PJZAKO::m_State_Tojo_RunAndTurnPc)
			.addProperty("m_State_Tojo_AgainstWall", &PJZAKO::m_State_Tojo_AgainstWall)
			.addProperty("m_State_Tojo_LookAround", &PJZAKO::m_State_Tojo_LookAround)
			.addProperty("m_State_Tojo_Stand", &PJZAKO::m_State_Tojo_Stand)
			.addProperty("m_State_Tojo_Bench", &PJZAKO::m_State_Tojo_Bench)
			.addProperty("m_State_Tojo_Sit", &PJZAKO::m_State_Tojo_Sit)
			.addProperty("m_State_Tojo_Car", &PJZAKO::m_State_Tojo_Car)
			.addProperty("m_State_Tojo_JumpOff", &PJZAKO::m_State_Tojo_JumpOff)
			.addProperty("m_State_Tojo_BreakCmnObj", &PJZAKO::m_State_Tojo_BreakCmnObj)
			.addProperty("m_State_Tojo_AeroBike", &PJZAKO::m_State_Tojo_AeroBike)
			.addProperty("m_State_Tojo_RoomRunner", &PJZAKO::m_State_Tojo_RoomRunner)
			.addProperty("m_State_LeadPcWayPointMove", &PJZAKO::m_State_LeadPcWayPointMove)
			.addProperty("m_State_FixTurret", &PJZAKO::m_State_FixTurret)
			.addProperty("m_State_WayPointMoveAfterPop", &PJZAKO::m_State_WayPointMoveAfterPop)
			.addProperty("m_State_DownAttack", &PJZAKO::m_State_DownAttack)
			.addFunction("IsAtkObj", &PJZAKO::IsAtkObj)
			.addFunction("IsSetDamageFromPcThroughAttack", &PJZAKO::IsSetDamageFromPcThroughAttack)
			.addFunction("mSetDamage_Dead", &PJZAKO::mSetDamage_Dead)
			.addFunction("mSetDamage_CutDamage", &PJZAKO::mSetDamage_CutDamage)
			.addFunction("mSetDamage_NoStateChangeDamage", &PJZAKO::mSetDamage_NoStateChangeDamage)
			// Can't export pointer to native type 'int32_t*' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("mSetDamage_DamageCounterProc", &PJZAKO::mSetDamage_DamageCounterProc)
			.addFunction("mSetDamage_InitDamageReaction", &PJZAKO::mSetDamage_InitDamageReaction)
			.addFunction("mSetDamage_Initialize", &PJZAKO::mSetDamage_Initialize)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJZAKO::mSetDamage)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("CheckSetDmgFuncGarbageInData", &PJZAKO::CheckSetDmgFuncGarbageInData)
			.addFunction("ConvertDmgMot", &PJZAKO::ConvertDmgMot)
			.addStaticFunction("StaticProc", &PJZAKO::StaticProc)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKO::m_StatePtrArr) == 240, "expected m_StatePtrArr to be size 240");
static_assert(sizeof(PJZAKO::m_BoneScale) == 4, "expected m_BoneScale to be size 4");
static_assert(sizeof(PJZAKO::m_SetDamageInfo) == 4, "expected m_SetDamageInfo to be size 4");
static_assert(sizeof(PJZAKO::m_ZakoInfo) == 148, "expected m_ZakoInfo to be size 148");
static_assert(sizeof(PJZAKO::m_MotionInfo) == 16, "expected m_MotionInfo to be size 16");
static_assert(sizeof(PJZAKO::m_TojoInfo) == 20, "expected m_TojoInfo to be size 20");
static_assert(sizeof(PJZAKO::m_PcInfo) == 64, "expected m_PcInfo to be size 64");
static_assert(sizeof(PJZAKO::m_DmgInfo) == 68, "expected m_DmgInfo to be size 68");
static_assert(sizeof(PJZAKO::m_AiInfo) == 76, "expected m_AiInfo to be size 76");
static_assert(sizeof(PJZAKO::m_Counter) == 4, "expected m_Counter to be size 4");
static_assert(sizeof(PJZAKO::m_CheckCanHitPrevCnt) == 4, "expected m_CheckCanHitPrevCnt to be size 4");
static_assert(sizeof(PJZAKO::m_AddKillNumWaitCounter) == 4, "expected m_AddKillNumWaitCounter to be size 4");
static_assert(sizeof(PJZAKO::m_boAddedKillNum) == 1, "expected m_boAddedKillNum to be size 1");
static_assert(sizeof(PJZAKO::m_boMoveTurretFlag) == 1, "expected m_boMoveTurretFlag to be size 1");
static_assert(sizeof(PJZAKO::m_boWayPointMoveAfterPop) == 1, "expected m_boWayPointMoveAfterPop to be size 1");
static_assert(sizeof(PJZAKO::m_pStateMachine) == 4, "expected m_pStateMachine to be size 4");
static_assert(sizeof(PJZAKO::m_eNowStateIdx) == 4, "expected m_eNowStateIdx to be size 4");
static_assert(sizeof(PJZAKO::m_ePrevStateIdx) == 4, "expected m_ePrevStateIdx to be size 4");
static_assert(sizeof(PJZAKO::m_eScareType) == 4, "expected m_eScareType to be size 4");
static_assert(sizeof(PJZAKO::mTargetDirec) == 4, "expected mTargetDirec to be size 4");
static_assert(sizeof(PJZAKO::mNowDirecY) == 4, "expected mNowDirecY to be size 4");
static_assert(sizeof(PJZAKO::mDeadModelType) == 4, "expected mDeadModelType to be size 4");
static_assert(sizeof(PJZAKO::m_EfDanmen) == 12, "expected m_EfDanmen to be size 12");
static_assert(sizeof(PJZAKO::m_pCutMark) == 4, "expected m_pCutMark to be size 4");
static_assert(sizeof(PJZAKO::mpEfQuestion) == 4, "expected mpEfQuestion to be size 4");
static_assert(sizeof(PJZAKO::m_pMotMng) == 4, "expected m_pMotMng to be size 4");
static_assert(sizeof(PJZAKO::m_WayPointArry) == 20, "expected m_WayPointArry to be size 20");
static_assert(sizeof(PJZAKO::m_iWayPoint) == 4, "expected m_iWayPoint to be size 4");
static_assert(sizeof(PJZAKO::m_pPathPlanner) == 4, "expected m_pPathPlanner to be size 4");
static_assert(sizeof(PJZAKO::m_boUseObstacleSensor) == 1, "expected m_boUseObstacleSensor to be size 1");
static_assert(sizeof(PJZAKO::m_boDisableInterestIK) == 1, "expected m_boDisableInterestIK to be size 1");
static_assert(sizeof(PJZAKO::m_boBerserkAtk) == 1, "expected m_boBerserkAtk to be size 1");
static_assert(sizeof(PJZAKO::m_boRequestDeathOutOfCamera) == 1, "expected m_boRequestDeathOutOfCamera to be size 1");
static_assert(sizeof(PJZAKO::m_boFirstBombDeadFxPlay) == 1, "expected m_boFirstBombDeadFxPlay to be size 1");
static_assert(sizeof(PJZAKO::m_JumpOffTojoLandingPos) == 12, "expected m_JumpOffTojoLandingPos to be size 12");
static_assert(sizeof(PJZAKO::m_boFixTurret) == 1, "expected m_boFixTurret to be size 1");
static_assert(sizeof(PJZAKO::m_eSdnAtkPopDir) == 4, "expected m_eSdnAtkPopDir to be size 4");
static_assert(sizeof(PJZAKO::m_pDP) == 4, "expected m_pDP to be size 4");
static_assert(sizeof(PJZAKO::m_pObsSens) == 4, "expected m_pObsSens to be size 4");
static_assert(sizeof(PJZAKO::m_Atk2PcHitAfterCnt) == 4, "expected m_Atk2PcHitAfterCnt to be size 4");
static_assert(sizeof(PJZAKO::m_boPcDownLaugh) == 1, "expected m_boPcDownLaugh to be size 1");
static_assert(sizeof(PJZAKO::m_pBulletManager) == 4, "expected m_pBulletManager to be size 4");
static_assert(sizeof(PJZAKO::m_boPhysicDeadProc) == 1, "expected m_boPhysicDeadProc to be size 1");
static_assert(sizeof(PJZAKO::m_bIsHeadPhysicsEnd) == 1, "expected m_bIsHeadPhysicsEnd to be size 1");
static_assert(sizeof(PJZAKO::m_pPhysicDeadGmf) == 4, "expected m_pPhysicDeadGmf to be size 4");
static_assert(sizeof(PJZAKO::m_boTodomeDead) == 1, "expected m_boTodomeDead to be size 1");
static_assert(sizeof(PJZAKO::m_boDeadEffectReq) == 1, "expected m_boDeadEffectReq to be size 1");
static_assert(sizeof(PJZAKO::m_DeadEffectCountCown) == 4, "expected m_DeadEffectCountCown to be size 4");
static_assert(sizeof(PJZAKO::m_ParticleDeadZakoTerminateWaitTick) == 4, "expected m_ParticleDeadZakoTerminateWaitTick to be size 4");
static_assert(sizeof(PJZAKO::m_pBnFxDmgDat) == 4, "expected m_pBnFxDmgDat to be size 4");
static_assert(sizeof(PJZAKO::m_boTimeShareUpdate) == 1, "expected m_boTimeShareUpdate to be size 1");
static_assert(sizeof(PJZAKO::m_eTimeShareStat) == 4, "expected m_eTimeShareStat to be size 4");
static_assert(sizeof(PJZAKO::m_CollInfo) == 12, "expected m_CollInfo to be size 12");
static_assert(sizeof(PJZAKO::m_Tex) == 40, "expected m_Tex to be size 40");
static_assert(sizeof(PJZAKO::m_ChangeStateLimitTick) == 4, "expected m_ChangeStateLimitTick to be size 4");
static_assert(sizeof(PJZAKO::m_fRotSpd) == 4, "expected m_fRotSpd to be size 4");
static_assert(sizeof(PJZAKO::m_BreakPopCmnObjPtrList) == 12, "expected m_BreakPopCmnObjPtrList to be size 12");
static_assert(sizeof(PJZAKO::m_pSyncPopCmnObj) == 4, "expected m_pSyncPopCmnObj to be size 4");
static_assert(sizeof(PJZAKO::m_boCalledNoGuardEfOnce) == 1, "expected m_boCalledNoGuardEfOnce to be size 1");
static_assert(sizeof(PJZAKO::m_OutOfCameraIkakuShootTime) == 4, "expected m_OutOfCameraIkakuShootTime to be size 4");
static_assert(sizeof(PJZAKO::m_State_Damage) == 12, "expected m_State_Damage to be size 12");
static_assert(sizeof(PJZAKO::m_State_CloseForAtk) == 4, "expected m_State_CloseForAtk to be size 4");
static_assert(sizeof(PJZAKO::m_State_AwayAfterAtk) == 4, "expected m_State_AwayAfterAtk to be size 4");
static_assert(sizeof(PJZAKO::m_State_ComboAttack) == 12, "expected m_State_ComboAttack to be size 12");
static_assert(sizeof(PJZAKO::m_State_StepInAttack) == 4, "expected m_State_StepInAttack to be size 4");
static_assert(sizeof(PJZAKO::m_State_Defence) == 8, "expected m_State_Defence to be size 8");
static_assert(sizeof(PJZAKO::m_State_Evacuate) == 8, "expected m_State_Evacuate to be size 8");
static_assert(sizeof(PJZAKO::m_State_RandomMove) == 8, "expected m_State_RandomMove to be size 8");
static_assert(sizeof(PJZAKO::m_State_ThroughDamage) == 8, "expected m_State_ThroughDamage to be size 8");
static_assert(sizeof(PJZAKO::m_State_DownDamage) == 4, "expected m_State_DownDamage to be size 4");
static_assert(sizeof(PJZAKO::m_State_Pressure) == 12, "expected m_State_Pressure to be size 12");
static_assert(sizeof(PJZAKO::m_State_WayPointMove) == 8, "expected m_State_WayPointMove to be size 8");
static_assert(sizeof(PJZAKO::m_State_Run) == 8, "expected m_State_Run to be size 8");
static_assert(sizeof(PJZAKO::m_State_Kosinukasi) == 8, "expected m_State_Kosinukasi to be size 8");
static_assert(sizeof(PJZAKO::m_State_Yotunbai) == 8, "expected m_State_Yotunbai to be size 8");
static_assert(sizeof(PJZAKO::m_State_Stand) == 8, "expected m_State_Stand to be size 8");
static_assert(sizeof(PJZAKO::m_StatePerformIll) == 8, "expected m_StatePerformIll to be size 8");
static_assert(sizeof(PJZAKO::m_ReleaseWaitIdle) == 4, "expected m_ReleaseWaitIdle to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_RunAndTurnPc) == 4, "expected m_State_Tojo_RunAndTurnPc to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_AgainstWall) == 4, "expected m_State_Tojo_AgainstWall to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_LookAround) == 4, "expected m_State_Tojo_LookAround to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Stand) == 4, "expected m_State_Tojo_Stand to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Bench) == 4, "expected m_State_Tojo_Bench to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Sit) == 4, "expected m_State_Tojo_Sit to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Car) == 8, "expected m_State_Tojo_Car to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_JumpOff) == 8, "expected m_State_Tojo_JumpOff to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_BreakCmnObj) == 12, "expected m_State_Tojo_BreakCmnObj to be size 12");
static_assert(sizeof(PJZAKO::m_State_Tojo_AeroBike) == 8, "expected m_State_Tojo_AeroBike to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_RoomRunner) == 8, "expected m_State_Tojo_RoomRunner to be size 8");
static_assert(sizeof(PJZAKO::m_State_LeadPcWayPointMove) == 4, "expected m_State_LeadPcWayPointMove to be size 4");
static_assert(sizeof(PJZAKO::m_State_FixTurret) == 4, "expected m_State_FixTurret to be size 4");
static_assert(sizeof(PJZAKO::m_State_WayPointMoveAfterPop) == 4, "expected m_State_WayPointMoveAfterPop to be size 4");
static_assert(sizeof(PJZAKO::m_State_DownAttack) == 8, "expected m_State_DownAttack to be size 8");
static_assert(sizeof(PJZAKO) == 2532, "expected class PJZAKO to be size 2532");

// [Structure] class PJStateMachine
class PJStateMachine
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class PJZAKO* m_pOwner, offset 0x4>
	class PJZAKO* m_pOwner;

	// <class PJState* m_pCurrentState, offset 0x8>
	class PJState* m_pCurrentState;

	// <class PJState* m_pPreviousState, offset 0xc>
	class PJState* m_pPreviousState;

	// <class PJState* m_pGlobalState, offset 0x10>
	class PJState* m_pGlobalState;

	std::string ToString() const { return "class PJStateMachine(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJStateMachine>("PJStateMachine")
			.addFunction("__tostring", &PJStateMachine::ToString)
			.addFunction("GetPtrAddr", &PJStateMachine::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &PJStateMachine::field_0)
			.addProperty("m_pOwner", &PJStateMachine::m_pOwner)
			.addProperty("m_pCurrentState", &PJStateMachine::m_pCurrentState)
			.addProperty("m_pPreviousState", &PJStateMachine::m_pPreviousState)
			.addProperty("m_pGlobalState", &PJStateMachine::m_pGlobalState)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJStateMachine::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(PJStateMachine::m_pOwner) == 4, "expected m_pOwner to be size 4");
static_assert(sizeof(PJStateMachine::m_pCurrentState) == 4, "expected m_pCurrentState to be size 4");
static_assert(sizeof(PJStateMachine::m_pPreviousState) == 4, "expected m_pPreviousState to be size 4");
static_assert(sizeof(PJStateMachine::m_pGlobalState) == 4, "expected m_pGlobalState to be size 4");
static_assert(sizeof(PJStateMachine) == 20, "expected class PJStateMachine to be size 20");

// [Structure] class EffectDanmenFlash
class EffectDanmenFlash
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[604];
public:

	std::string ToString() const { return "class EffectDanmenFlash(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectDanmenFlash>("EffectDanmenFlash")
			.addFunction("__tostring", &EffectDanmenFlash::ToString)
			.addFunction("GetPtrAddr", &EffectDanmenFlash::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectDanmenFlash) == 604, "expected class EffectDanmenFlash to be size 604");

// [Structure] class EffectQuestion
class EffectQuestion : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData2[3];

public:
	// <class rPrimUnific m_StarUni, offset 0x54>
	class rPrimUnific m_StarUni;

	// <class rQuad m_Star, offset 0x74>
	class rQuad m_Star;

	// <struct tagGHMR_TEX m_StarTex, offset 0x120>
	struct tagGHMR_TEX m_StarTex;

	// <struct Vec m_Pos, offset 0x148>
	struct Vec m_Pos;

	// <float m_Speed, offset 0x154>
	float m_Speed;

	// <float m_Up, offset 0x158>
	float m_Up;

	// <float m_Add, offset 0x15c>
	float m_Add;

	// <float m_TimeCount, offset 0x160>
	float m_TimeCount;

	// <int32_t m_TimeFrame, offset 0x164>
	int32_t m_TimeFrame;

	// <float m_TimeRate, offset 0x168>
	float m_TimeRate;

	std::string ToString() const { return "class EffectQuestion(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectQuestion, HrTask>("EffectQuestion")
			.addFunction("__tostring", &EffectQuestion::ToString)
			.addFunction("GetPtrAddr", &EffectQuestion::GetPtrAddr)
			.addProperty("m_Flag", &EffectQuestion::m_Flag)
			.addProperty("m_StarUni", &EffectQuestion::m_StarUni)
			.addProperty("m_Star", &EffectQuestion::m_Star)
			.addProperty("m_StarTex", &EffectQuestion::m_StarTex)
			.addProperty("m_Pos", &EffectQuestion::m_Pos)
			.addProperty("m_Speed", &EffectQuestion::m_Speed)
			.addProperty("m_Up", &EffectQuestion::m_Up)
			.addProperty("m_Add", &EffectQuestion::m_Add)
			.addProperty("m_TimeCount", &EffectQuestion::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectQuestion::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectQuestion::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectQuestion::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectQuestion::m_StarUni) == 32, "expected m_StarUni to be size 32");
static_assert(sizeof(EffectQuestion::m_Star) == 172, "expected m_Star to be size 172");
static_assert(sizeof(EffectQuestion::m_StarTex) == 40, "expected m_StarTex to be size 40");
static_assert(sizeof(EffectQuestion::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectQuestion::m_Speed) == 4, "expected m_Speed to be size 4");
static_assert(sizeof(EffectQuestion::m_Up) == 4, "expected m_Up to be size 4");
static_assert(sizeof(EffectQuestion::m_Add) == 4, "expected m_Add to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeFrame) == 4, "expected m_TimeFrame to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(EffectQuestion) == 364, "expected class EffectQuestion to be size 364");

// [Structure] class PJZakoMotMng
class PJZakoMotMng
{
public:
	// enum PJZakoMotMng::MotMode
	enum MotMode : uint32_t
	{
		// <MotMode_Init = 0x0>
		MotMode_Init = 0,

		// <MotMode_Walk = 0x1>
		MotMode_Walk = 1,

		// <MotMode_Run = 0x2>
		MotMode_Run = 2,

		// <MotMode_Evacuate = 0x3>
		MotMode_Evacuate = 3,

		// <MotMode_Attack = 0x4>
		MotMode_Attack = 4,

		// <MotMode_Damage = 0x5>
		MotMode_Damage = 5,

		// <MotMode_Guard = 0x6>
		MotMode_Guard = 6,

		// <MotMode_Debug = 0x7>
		MotMode_Debug = 7,

		// <MotMode_Misc = 0x8>
		MotMode_Misc = 8,

		// <MotMode_NUM = 0x9>
		MotMode_NUM = 9

	};

	/// Struct member variables

	// <struct Vec m_MoveVec, offset 0x0>
	struct Vec m_MoveVec;

	// <float m_fCharRotY, offset 0xc>
	float m_fCharRotY;

	// <float m_fMoveSpd, offset 0x10>
	float m_fMoveSpd;

	// <float m_fMotSpd, offset 0x14>
	float m_fMotSpd;

	// <enum PJZakoMotMng::MotMode m_MotMode, offset 0x18>
	enum PJZakoMotMng::MotMode m_MotMode;

	// <class PJZAKO* m_pOwnerChar, offset 0x1c>
	class PJZAKO* m_pOwnerChar;

	// <enum eMoveDir m_MoveDir, offset 0x20>
	enum eMoveDir m_MoveDir;

	std::string ToString() const { return "class PJZakoMotMng(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJZakoMotMng>("PJZakoMotMng")
			.addFunction("__tostring", &PJZakoMotMng::ToString)
			.addFunction("GetPtrAddr", &PJZakoMotMng::GetPtrAddr)
			.addProperty("m_MoveVec", &PJZakoMotMng::m_MoveVec)
			.addProperty("m_fCharRotY", &PJZakoMotMng::m_fCharRotY)
			.addProperty("m_fMoveSpd", &PJZakoMotMng::m_fMoveSpd)
			.addProperty("m_fMotSpd", &PJZakoMotMng::m_fMotSpd)
			.addProperty("m_MotMode", &PJZakoMotMng::m_MotMode)
			.addProperty("m_pOwnerChar", &PJZakoMotMng::m_pOwnerChar)
			.addProperty("m_MoveDir", &PJZakoMotMng::m_MoveDir)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoMotMng::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(PJZakoMotMng::m_fCharRotY) == 4, "expected m_fCharRotY to be size 4");
static_assert(sizeof(PJZakoMotMng::m_fMoveSpd) == 4, "expected m_fMoveSpd to be size 4");
static_assert(sizeof(PJZakoMotMng::m_fMotSpd) == 4, "expected m_fMotSpd to be size 4");
static_assert(sizeof(PJZakoMotMng::m_MotMode) == 4, "expected m_MotMode to be size 4");
static_assert(sizeof(PJZakoMotMng::m_pOwnerChar) == 4, "expected m_pOwnerChar to be size 4");
static_assert(sizeof(PJZakoMotMng::m_MoveDir) == 4, "expected m_MoveDir to be size 4");
static_assert(sizeof(PJZakoMotMng) == 36, "expected class PJZakoMotMng to be size 36");

// [Structure] class PathPlanner
class PathPlanner
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[1220];
public:

	std::string ToString() const { return "class PathPlanner(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PathPlanner>("PathPlanner")
			.addFunction("__tostring", &PathPlanner::ToString)
			.addFunction("GetPtrAddr", &PathPlanner::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(PathPlanner) == 1220, "expected class PathPlanner to be size 1220");

// [Structure] class FkDynamicParam
class FkDynamicParam
{
public:
	// [Structure] struct FkDynamicParam::DynamicParam
	struct DynamicParam
	{
	public:
		/// Struct member variables

		// <char* strParamName, offset 0x0>
		char* strParamName;

		// <float fParam, offset 0x4>
		float fParam;

		std::string ToString() const { return "struct DynamicParam(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkDynamicParam::DynamicParam>("FkDynamicParam_DynamicParam")
				.addFunction("__tostring", &FkDynamicParam::DynamicParam::ToString)
				.addFunction("GetPtrAddr", &FkDynamicParam::DynamicParam::GetPtrAddr)
				// char* type not supported in LuaBridge
				//.addProperty("strParamName", &FkDynamicParam::DynamicParam::strParamName)
				.addProperty("fParam", &FkDynamicParam::DynamicParam::fParam)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkDynamicParam::DynamicParam::strParamName) == 4, "expected strParamName to be size 4");
	static_assert(sizeof(FkDynamicParam::DynamicParam::fParam) == 4, "expected fParam to be size 4");
	static_assert(sizeof(FkDynamicParam::DynamicParam) == 8, "expected struct FkDynamicParam::DynamicParam to be size 8");

	// enum FkDynamicParam::DP_STAT
	enum DP_STAT : uint32_t
	{
		// <eDP_STAT_INIT = 0xffffffffffffffff>
		eDP_STAT_INIT = UINT32_MAX,

		// <eDP_STAT_STANDBY = 0x0>
		eDP_STAT_STANDBY = 0

	};

	/// Struct member variables

	// <class FkStlVector<FkDynamicParam::DynamicParam> m_DP, offset 0x0>
	class FkStlVector<FkDynamicParam::DynamicParam> m_DP;

	// <char m_StrFilePath[0x104], offset 0x14>
	char m_StrFilePath[260];

	// <int32_t m_nParam, offset 0x118>
	int32_t m_nParam;

	// <enum FkDynamicParam::DP_STAT m_Stat, offset 0x11c>
	enum FkDynamicParam::DP_STAT m_Stat;

	// <char* m_pReadBuffer, offset 0x120>
	char* m_pReadBuffer;

	// <char* m_pReadHead, offset 0x124>
	char* m_pReadHead;

	// <uint32_t m_BufferSize, offset 0x128>
	uint32_t m_BufferSize;

	// <uint32_t m_HeadSize, offset 0x12c>
	uint32_t m_HeadSize;

	// <uint8_t m_boEOF, offset 0x130>
	uint8_t m_boEOF;

	// <Unidentified data segment, offset 0x131>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class FkDynamicParam(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkDynamicParam>("FkDynamicParam")
			.addFunction("__tostring", &FkDynamicParam::ToString)
			.addFunction("GetPtrAddr", &FkDynamicParam::GetPtrAddr)
			.addProperty("m_DP", &FkDynamicParam::m_DP)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StrFilePath", &FkDynamicParam::m_StrFilePath)
			.addProperty("m_nParam", &FkDynamicParam::m_nParam)
			.addProperty("m_Stat", &FkDynamicParam::m_Stat)
			// char* type not supported in LuaBridge
			//.addProperty("m_pReadBuffer", &FkDynamicParam::m_pReadBuffer)
			// char* type not supported in LuaBridge
			//.addProperty("m_pReadHead", &FkDynamicParam::m_pReadHead)
			.addProperty("m_BufferSize", &FkDynamicParam::m_BufferSize)
			.addProperty("m_HeadSize", &FkDynamicParam::m_HeadSize)
			.addProperty("m_boEOF", &FkDynamicParam::m_boEOF)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkDynamicParam::m_DP) == 20, "expected m_DP to be size 20");
static_assert(sizeof(FkDynamicParam::m_StrFilePath) == 260, "expected m_StrFilePath to be size 260");
static_assert(sizeof(FkDynamicParam::m_nParam) == 4, "expected m_nParam to be size 4");
static_assert(sizeof(FkDynamicParam::m_Stat) == 4, "expected m_Stat to be size 4");
static_assert(sizeof(FkDynamicParam::m_pReadBuffer) == 4, "expected m_pReadBuffer to be size 4");
static_assert(sizeof(FkDynamicParam::m_pReadHead) == 4, "expected m_pReadHead to be size 4");
static_assert(sizeof(FkDynamicParam::m_BufferSize) == 4, "expected m_BufferSize to be size 4");
static_assert(sizeof(FkDynamicParam::m_HeadSize) == 4, "expected m_HeadSize to be size 4");
static_assert(sizeof(FkDynamicParam::m_boEOF) == 1, "expected m_boEOF to be size 1");
static_assert(sizeof(FkDynamicParam) == 308, "expected class FkDynamicParam to be size 308");

// [Structure] class FkObstacleSensor
class FkObstacleSensor
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[52];
public:

	std::string ToString() const { return "class FkObstacleSensor(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkObstacleSensor>("FkObstacleSensor")
			.addFunction("__tostring", &FkObstacleSensor::ToString)
			.addFunction("GetPtrAddr", &FkObstacleSensor::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkObstacleSensor) == 52, "expected class FkObstacleSensor to be size 52");

// [Structure] class FkBulletManager
class FkBulletManager
{
public:
	// [Structure] struct FkBulletManager::stEfBullet
	struct stEfBullet
	{
	public:
		/// Struct member variables

		// <uint8_t fireFlag, offset 0x0>
		uint8_t fireFlag;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData1[3];

	public:
		// <class HrTask* pTask, offset 0x4>
		class HrTask* pTask;

		// <struct tagHRTASKCHECK taskCheckBullet, offset 0x8>
		struct tagHRTASKCHECK taskCheckBullet;

		// <class EffectFkTobiDoguBase* pTobiDoguBase, offset 0x10>
		class EffectFkTobiDoguBase* pTobiDoguBase;

		std::string ToString() const { return "struct stEfBullet(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkBulletManager::stEfBullet>("FkBulletManager_stEfBullet")
				.addFunction("__tostring", &FkBulletManager::stEfBullet::ToString)
				.addFunction("GetPtrAddr", &FkBulletManager::stEfBullet::GetPtrAddr)
				.addProperty("fireFlag", &FkBulletManager::stEfBullet::fireFlag)
				.addProperty("pTask", &FkBulletManager::stEfBullet::pTask)
				.addProperty("taskCheckBullet", &FkBulletManager::stEfBullet::taskCheckBullet)
				.addProperty("pTobiDoguBase", &FkBulletManager::stEfBullet::pTobiDoguBase)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBulletManager::stEfBullet::fireFlag) == 1, "expected fireFlag to be size 1");
	static_assert(sizeof(FkBulletManager::stEfBullet::pTask) == 4, "expected pTask to be size 4");
	static_assert(sizeof(FkBulletManager::stEfBullet::taskCheckBullet) == 8, "expected taskCheckBullet to be size 8");
	static_assert(sizeof(FkBulletManager::stEfBullet::pTobiDoguBase) == 4, "expected pTobiDoguBase to be size 4");
	static_assert(sizeof(FkBulletManager::stEfBullet) == 20, "expected struct FkBulletManager::stEfBullet to be size 20");

	// [Structure] struct FkBulletManager::DmgInfo
	struct DmgInfo
	{
	public:
		/// Struct member variables

		// <float fDmg, offset 0x0>
		float fDmg;

		// <float fKnockBack, offset 0x4>
		float fKnockBack;

		// <int32_t AtkKind, offset 0x8>
		int32_t AtkKind;

		// <float fSubBatteryRatio, offset 0xc>
		float fSubBatteryRatio;

		// <uint8_t boDownAtk, offset 0x10>
		uint8_t boDownAtk;

		// <Unidentified data segment, offset 0x11>
	private:
		char _UnidentifiedData5[3];

	public:
		// <class mHRChara* pOwner, offset 0x14>
		class mHRChara* pOwner;

		// <int32_t CharaHitSeID, offset 0x18>
		int32_t CharaHitSeID;

		std::string ToString() const { return "struct DmgInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkBulletManager::DmgInfo>("FkBulletManager_DmgInfo")
				.addFunction("__tostring", &FkBulletManager::DmgInfo::ToString)
				.addFunction("GetPtrAddr", &FkBulletManager::DmgInfo::GetPtrAddr)
				.addProperty("fDmg", &FkBulletManager::DmgInfo::fDmg)
				.addProperty("fKnockBack", &FkBulletManager::DmgInfo::fKnockBack)
				.addProperty("AtkKind", &FkBulletManager::DmgInfo::AtkKind)
				.addProperty("fSubBatteryRatio", &FkBulletManager::DmgInfo::fSubBatteryRatio)
				.addProperty("boDownAtk", &FkBulletManager::DmgInfo::boDownAtk)
				.addProperty("pOwner", &FkBulletManager::DmgInfo::pOwner)
				.addProperty("CharaHitSeID", &FkBulletManager::DmgInfo::CharaHitSeID)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBulletManager::DmgInfo::fDmg) == 4, "expected fDmg to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::fKnockBack) == 4, "expected fKnockBack to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::AtkKind) == 4, "expected AtkKind to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::fSubBatteryRatio) == 4, "expected fSubBatteryRatio to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::boDownAtk) == 1, "expected boDownAtk to be size 1");
	static_assert(sizeof(FkBulletManager::DmgInfo::pOwner) == 4, "expected pOwner to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::CharaHitSeID) == 4, "expected CharaHitSeID to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo) == 28, "expected struct FkBulletManager::DmgInfo to be size 28");

	// [Function] void __convention("thiscall") FkBulletManager::AddManageBullet(class FkBulletManager* const this, class HrTask* arg2, class EffectFkTobiDoguBase* arg3, class mHRChara* arg4, float arg5, float arg6, int32_t arg7, float arg8, uint8_t arg9, int32_t arg10) [?AddManageBullet@FkBulletManager@@QAEXPAVHrTask@@PAVEffectFkTobiDoguBase@@PAVmHRChara@@MMHM_NH@Z]
	void AddManageBullet(class HrTask* arg2, class EffectFkTobiDoguBase* arg3, class mHRChara* arg4, float arg5, float arg6, int32_t arg7, float arg8, uint8_t arg9, int32_t arg10)
	{
		typedef void(__thiscall* _Func)(class FkBulletManager* const thisPtr, class HrTask* arg2, class EffectFkTobiDoguBase* arg3, class mHRChara* arg4, float arg5, float arg6, int32_t arg7, float arg8, uint8_t arg9, int32_t arg10);
		_Func mFunc = (_Func)(GameModule + 0x5d03f0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <class FkStlVector<FkBulletManager::stEfBullet> mEfBulletArr, offset 0x0>
	class FkStlVector<FkBulletManager::stEfBullet> mEfBulletArr;

	// <int32_t m_nBulletMax, offset 0x14>
	int32_t m_nBulletMax;

	// <struct FkBulletManager::DmgInfo m_DmgInfo, offset 0x18>
	struct FkBulletManager::DmgInfo m_DmgInfo;

	std::string ToString() const { return "class FkBulletManager(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkBulletManager>("FkBulletManager")
			.addFunction("__tostring", &FkBulletManager::ToString)
			.addFunction("GetPtrAddr", &FkBulletManager::GetPtrAddr)
			.addProperty("mEfBulletArr", &FkBulletManager::mEfBulletArr)
			.addProperty("m_nBulletMax", &FkBulletManager::m_nBulletMax)
			.addProperty("m_DmgInfo", &FkBulletManager::m_DmgInfo)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("AddManageBullet", &FkBulletManager::AddManageBullet)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkBulletManager::mEfBulletArr) == 20, "expected mEfBulletArr to be size 20");
static_assert(sizeof(FkBulletManager::m_nBulletMax) == 4, "expected m_nBulletMax to be size 4");
static_assert(sizeof(FkBulletManager::m_DmgInfo) == 28, "expected m_DmgInfo to be size 28");
static_assert(sizeof(FkBulletManager) == 52, "expected class FkBulletManager to be size 52");

// [Structure] class EffectFkTobiDoguBase
class EffectFkTobiDoguBase
{
public:
	// [Structure] struct EffectFkTobiDoguBase::strHitCheck
	struct strHitCheck
	{
	public:
		/// Struct member variables

		// <float fTgtRadius, offset 0x0>
		float fTgtRadius;

		// <struct Vec* pTgtPos, offset 0x4>
		struct Vec* pTgtPos;

		std::string ToString() const { return "struct strHitCheck(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectFkTobiDoguBase::strHitCheck>("EffectFkTobiDoguBase_strHitCheck")
				.addFunction("__tostring", &EffectFkTobiDoguBase::strHitCheck::ToString)
				.addFunction("GetPtrAddr", &EffectFkTobiDoguBase::strHitCheck::GetPtrAddr)
				.addProperty("fTgtRadius", &EffectFkTobiDoguBase::strHitCheck::fTgtRadius)
				.addProperty("pTgtPos", &EffectFkTobiDoguBase::strHitCheck::pTgtPos)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFkTobiDoguBase::strHitCheck::fTgtRadius) == 4, "expected fTgtRadius to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::strHitCheck::pTgtPos) == 4, "expected pTgtPos to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::strHitCheck) == 8, "expected struct EffectFkTobiDoguBase::strHitCheck to be size 8");

	// enum EffectFkTobiDoguBase::eHitObjType
	enum eHitObjType : uint32_t
	{
		// <eHitObjType_Unknown = 0xffffffffffffffff>
		eHitObjType_Unknown = UINT32_MAX,

		// <eHitObjType_Stage = 0x0>
		eHitObjType_Stage = 0,

		// <eHitObjType_Char = 0x1>
		eHitObjType_Char = 1

	};

	// [Structure] struct EffectFkTobiDoguBase::HitObjInfo
	struct HitObjInfo
	{
	public:
		/// Struct member variables

		// <uint8_t boHit, offset 0x0>
		uint8_t boHit;

		// <Unidentified data segment, offset 0x1>
	private:
		char _UnidentifiedData1[3];

	public:
		// <enum EffectFkTobiDoguBase::eHitObjType eHitObjType, offset 0x4>
		enum eHitObjType eHitObjType;

		// <struct Vec HitPos, offset 0x8>
		struct Vec HitPos;

		// <float fSqDistFromLaunch, offset 0x14>
		float fSqDistFromLaunch;

		std::string ToString() const { return "struct HitObjInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectFkTobiDoguBase::HitObjInfo>("EffectFkTobiDoguBase_HitObjInfo")
				.addFunction("__tostring", &EffectFkTobiDoguBase::HitObjInfo::ToString)
				.addFunction("GetPtrAddr", &EffectFkTobiDoguBase::HitObjInfo::GetPtrAddr)
				.addProperty("boHit", &EffectFkTobiDoguBase::HitObjInfo::boHit)
				.addProperty("eHitObjType", &EffectFkTobiDoguBase::HitObjInfo::eHitObjType)
				.addProperty("HitPos", &EffectFkTobiDoguBase::HitObjInfo::HitPos)
				.addProperty("fSqDistFromLaunch", &EffectFkTobiDoguBase::HitObjInfo::fSqDistFromLaunch)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::boHit) == 1, "expected boHit to be size 1");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::eHitObjType) == 4, "expected eHitObjType to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::HitPos) == 12, "expected HitPos to be size 12");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::fSqDistFromLaunch) == 4, "expected fSqDistFromLaunch to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo) == 24, "expected struct EffectFkTobiDoguBase::HitObjInfo to be size 24");

	/// Struct member variables

	// <void* (* field_0)[0x3], offset 0x0>
	void* (* field_0)[0x3];

	// <uint8_t m_Flag, offset 0x4>
	uint8_t m_Flag;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData2[3];

public:
	// <float m_TimeCount, offset 0x8>
	float m_TimeCount;

	// <float m_TimeRate, offset 0xc>
	float m_TimeRate;

	// <uint32_t m_Counter, offset 0x10>
	uint32_t m_Counter;

	// <int32_t m_PcDmgMotNo, offset 0x14>
	int32_t m_PcDmgMotNo;

	// <int32_t m_PcGrdMotNo, offset 0x18>
	int32_t m_PcGrdMotNo;

	// <float m_Damage, offset 0x1c>
	float m_Damage;

	// <float m_RotY, offset 0x20>
	float m_RotY;

	// <struct Vec m_TgtPos, offset 0x24>
	struct Vec m_TgtPos;

	// <float m_Speed, offset 0x30>
	float m_Speed;

	// <float m_BackBlow, offset 0x34>
	float m_BackBlow;

	// <uint8_t m_Reverse, offset 0x38>
	uint8_t m_Reverse;

	// <uint8_t m_bHitExp, offset 0x39>
	uint8_t m_bHitExp;

	// <uint8_t m_boDeleteRequest, offset 0x3a>
	uint8_t m_boDeleteRequest;

	// <Unidentified data segment, offset 0x3b>
private:
	char _UnidentifiedData15[1];

public:
	// <struct Vec m_LancPos, offset 0x3c>
	struct Vec m_LancPos;

	// <struct Vec m_Pos, offset 0x48>
	struct Vec m_Pos;

	// <struct Vec m_MoveVec, offset 0x54>
	struct Vec m_MoveVec;

	// <struct Vec m_BeforePos, offset 0x60>
	struct Vec m_BeforePos;

	// <struct Vec m_MoveDir, offset 0x6c>
	struct Vec m_MoveDir;

	// <class EffectGunTrack* m_pGunTrack, offset 0x78>
	class EffectGunTrack* m_pGunTrack;

	// <struct tagHRTASKCHECK m_TrackCheck, offset 0x7c>
	struct tagHRTASKCHECK m_TrackCheck;

	// <struct Vec m_DbgColSegA, offset 0x84>
	struct Vec m_DbgColSegA;

	// <struct Vec m_DbgColSegB, offset 0x90>
	struct Vec m_DbgColSegB;

	// <int32_t mStgHitSeID, offset 0x9c>
	int32_t mStgHitSeID;

	// <struct EffectFkTobiDoguBase::strHitCheck m_HitCheckInfo, offset 0xa0>
	struct EffectFkTobiDoguBase::strHitCheck m_HitCheckInfo;

	// <class WGcl* m_pGcl, offset 0xa8>
	class WGcl* m_pGcl;

	// <struct EffectFkTobiDoguBase::HitObjInfo m_HitInfo, offset 0xac>
	struct EffectFkTobiDoguBase::HitObjInfo m_HitInfo;

	std::string ToString() const { return "class EffectFkTobiDoguBase(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectFkTobiDoguBase>("EffectFkTobiDoguBase")
			.addFunction("__tostring", &EffectFkTobiDoguBase::ToString)
			.addFunction("GetPtrAddr", &EffectFkTobiDoguBase::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &EffectFkTobiDoguBase::field_0)
			.addProperty("m_Flag", &EffectFkTobiDoguBase::m_Flag)
			.addProperty("m_TimeCount", &EffectFkTobiDoguBase::m_TimeCount)
			.addProperty("m_TimeRate", &EffectFkTobiDoguBase::m_TimeRate)
			.addProperty("m_Counter", &EffectFkTobiDoguBase::m_Counter)
			.addProperty("m_PcDmgMotNo", &EffectFkTobiDoguBase::m_PcDmgMotNo)
			.addProperty("m_PcGrdMotNo", &EffectFkTobiDoguBase::m_PcGrdMotNo)
			.addProperty("m_Damage", &EffectFkTobiDoguBase::m_Damage)
			.addProperty("m_RotY", &EffectFkTobiDoguBase::m_RotY)
			.addProperty("m_TgtPos", &EffectFkTobiDoguBase::m_TgtPos)
			.addProperty("m_Speed", &EffectFkTobiDoguBase::m_Speed)
			.addProperty("m_BackBlow", &EffectFkTobiDoguBase::m_BackBlow)
			.addProperty("m_Reverse", &EffectFkTobiDoguBase::m_Reverse)
			.addProperty("m_bHitExp", &EffectFkTobiDoguBase::m_bHitExp)
			.addProperty("m_boDeleteRequest", &EffectFkTobiDoguBase::m_boDeleteRequest)
			.addProperty("m_LancPos", &EffectFkTobiDoguBase::m_LancPos)
			.addProperty("m_Pos", &EffectFkTobiDoguBase::m_Pos)
			.addProperty("m_MoveVec", &EffectFkTobiDoguBase::m_MoveVec)
			.addProperty("m_BeforePos", &EffectFkTobiDoguBase::m_BeforePos)
			.addProperty("m_MoveDir", &EffectFkTobiDoguBase::m_MoveDir)
			.addProperty("m_pGunTrack", &EffectFkTobiDoguBase::m_pGunTrack)
			.addProperty("m_TrackCheck", &EffectFkTobiDoguBase::m_TrackCheck)
			.addProperty("m_DbgColSegA", &EffectFkTobiDoguBase::m_DbgColSegA)
			.addProperty("m_DbgColSegB", &EffectFkTobiDoguBase::m_DbgColSegB)
			.addProperty("mStgHitSeID", &EffectFkTobiDoguBase::mStgHitSeID)
			.addProperty("m_HitCheckInfo", &EffectFkTobiDoguBase::m_HitCheckInfo)
			.addProperty("m_pGcl", &EffectFkTobiDoguBase::m_pGcl)
			.addProperty("m_HitInfo", &EffectFkTobiDoguBase::m_HitInfo)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectFkTobiDoguBase::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Counter) == 4, "expected m_Counter to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_PcDmgMotNo) == 4, "expected m_PcDmgMotNo to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_PcGrdMotNo) == 4, "expected m_PcGrdMotNo to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Damage) == 4, "expected m_Damage to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_RotY) == 4, "expected m_RotY to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TgtPos) == 12, "expected m_TgtPos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_Speed) == 4, "expected m_Speed to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_BackBlow) == 4, "expected m_BackBlow to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Reverse) == 1, "expected m_Reverse to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_bHitExp) == 1, "expected m_bHitExp to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_boDeleteRequest) == 1, "expected m_boDeleteRequest to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_LancPos) == 12, "expected m_LancPos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_BeforePos) == 12, "expected m_BeforePos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_MoveDir) == 12, "expected m_MoveDir to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_pGunTrack) == 4, "expected m_pGunTrack to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TrackCheck) == 8, "expected m_TrackCheck to be size 8");
static_assert(sizeof(EffectFkTobiDoguBase::m_DbgColSegA) == 12, "expected m_DbgColSegA to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_DbgColSegB) == 12, "expected m_DbgColSegB to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::mStgHitSeID) == 4, "expected mStgHitSeID to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_HitCheckInfo) == 8, "expected m_HitCheckInfo to be size 8");
static_assert(sizeof(EffectFkTobiDoguBase::m_pGcl) == 4, "expected m_pGcl to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_HitInfo) == 24, "expected m_HitInfo to be size 24");
static_assert(sizeof(EffectFkTobiDoguBase) == 196, "expected class EffectFkTobiDoguBase to be size 196");

// [Structure] class rQuadEx
class rQuadEx
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[220];
public:

	std::string ToString() const { return "class rQuadEx(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rQuadEx>("rQuadEx")
			.addFunction("__tostring", &rQuadEx::ToString)
			.addFunction("GetPtrAddr", &rQuadEx::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(rQuadEx) == 220, "expected class rQuadEx to be size 220");

// [Structure] class EffectGunTrack
class EffectGunTrack : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData2[3];

public:
	// <class rPrimUnific m_SmokeUni, offset 0x54>
	class rPrimUnific m_SmokeUni;

	// <class rQuadEx* m_pWidth, offset 0x74>
	class rQuadEx* m_pWidth;

	// <class rQuadEx* m_pHeight, offset 0x78>
	class rQuadEx* m_pHeight;

	// <class rPrimUnific m_LightUni, offset 0x7c>
	class rPrimUnific m_LightUni;

	// <class rQuadEx m_LightWidth, offset 0x9c>
	class rQuadEx m_LightWidth;

	// <class rQuadEx m_LightHeight, offset 0x178>
	class rQuadEx m_LightHeight;

	// <struct Vec* m_pSlashPoint, offset 0x254>
	struct Vec* m_pSlashPoint;

	// <uint32_t m_PointAddCount, offset 0x258>
	uint32_t m_PointAddCount;

	// <uint32_t m_MaxPoint, offset 0x25c>
	uint32_t m_MaxPoint;

	// <uint32_t m_PolyMax, offset 0x260>
	uint32_t m_PolyMax;

	// <uint32_t m_DeleteCount, offset 0x264>
	uint32_t m_DeleteCount;

	// <float m_RotY, offset 0x268>
	float m_RotY;

	// <float m_Scale, offset 0x26c>
	float m_Scale;

	// <float m_Anime, offset 0x270>
	float m_Anime;

	// <float* m_RandU, offset 0x274>
	float* m_RandU;

	// <float m_OnePiece, offset 0x278>
	float m_OnePiece;

	// <float m_TimeCount, offset 0x27c>
	float m_TimeCount;

	// <int32_t m_TimeFrame, offset 0x280>
	int32_t m_TimeFrame;

	// <float m_TimeRate, offset 0x284>
	float m_TimeRate;

	std::string ToString() const { return "class EffectGunTrack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectGunTrack, HrTask>("EffectGunTrack")
			.addFunction("__tostring", &EffectGunTrack::ToString)
			.addFunction("GetPtrAddr", &EffectGunTrack::GetPtrAddr)
			.addProperty("m_Flag", &EffectGunTrack::m_Flag)
			.addProperty("m_SmokeUni", &EffectGunTrack::m_SmokeUni)
			.addProperty("m_pWidth", &EffectGunTrack::m_pWidth)
			.addProperty("m_pHeight", &EffectGunTrack::m_pHeight)
			.addProperty("m_LightUni", &EffectGunTrack::m_LightUni)
			.addProperty("m_LightWidth", &EffectGunTrack::m_LightWidth)
			.addProperty("m_LightHeight", &EffectGunTrack::m_LightHeight)
			.addProperty("m_pSlashPoint", &EffectGunTrack::m_pSlashPoint)
			.addProperty("m_PointAddCount", &EffectGunTrack::m_PointAddCount)
			.addProperty("m_MaxPoint", &EffectGunTrack::m_MaxPoint)
			.addProperty("m_PolyMax", &EffectGunTrack::m_PolyMax)
			.addProperty("m_DeleteCount", &EffectGunTrack::m_DeleteCount)
			.addProperty("m_RotY", &EffectGunTrack::m_RotY)
			.addProperty("m_Scale", &EffectGunTrack::m_Scale)
			.addProperty("m_Anime", &EffectGunTrack::m_Anime)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_RandU", &EffectGunTrack::m_RandU)
			.addProperty("m_OnePiece", &EffectGunTrack::m_OnePiece)
			.addProperty("m_TimeCount", &EffectGunTrack::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectGunTrack::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectGunTrack::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectGunTrack::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectGunTrack::m_SmokeUni) == 32, "expected m_SmokeUni to be size 32");
static_assert(sizeof(EffectGunTrack::m_pWidth) == 4, "expected m_pWidth to be size 4");
static_assert(sizeof(EffectGunTrack::m_pHeight) == 4, "expected m_pHeight to be size 4");
static_assert(sizeof(EffectGunTrack::m_LightUni) == 32, "expected m_LightUni to be size 32");
static_assert(sizeof(EffectGunTrack::m_LightWidth) == 220, "expected m_LightWidth to be size 220");
static_assert(sizeof(EffectGunTrack::m_LightHeight) == 220, "expected m_LightHeight to be size 220");
static_assert(sizeof(EffectGunTrack::m_pSlashPoint) == 4, "expected m_pSlashPoint to be size 4");
static_assert(sizeof(EffectGunTrack::m_PointAddCount) == 4, "expected m_PointAddCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_MaxPoint) == 4, "expected m_MaxPoint to be size 4");
static_assert(sizeof(EffectGunTrack::m_PolyMax) == 4, "expected m_PolyMax to be size 4");
static_assert(sizeof(EffectGunTrack::m_DeleteCount) == 4, "expected m_DeleteCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_RotY) == 4, "expected m_RotY to be size 4");
static_assert(sizeof(EffectGunTrack::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EffectGunTrack::m_Anime) == 4, "expected m_Anime to be size 4");
static_assert(sizeof(EffectGunTrack::m_RandU) == 4, "expected m_RandU to be size 4");
static_assert(sizeof(EffectGunTrack::m_OnePiece) == 4, "expected m_OnePiece to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeFrame) == 4, "expected m_TimeFrame to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(EffectGunTrack) == 648, "expected class EffectGunTrack to be size 648");

// [Structure] class pcSNB
class pcSNB
{
public:
	// [Function] class mHRChara* __convention("thiscall") pcSNB::mGetSerchNearJumpAttackTarget(class pcSNB* const this) [?mGetSerchNearJumpAttackTarget@pcSNB@@QAEPAVmHRChara@@XZ]
	class mHRChara* mGetSerchNearJumpAttackTarget()
	{
		typedef class mHRChara*(__thiscall* _Func)(class pcSNB* const thisPtr);
		_Func mFunc = (_Func)(GameModule + 0x4f8fc0);
		return mFunc(this);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[8252];
public:

	std::string ToString() const { return "class pcSNB(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<pcSNB>("pcSNB")
			.addFunction("__tostring", &pcSNB::ToString)
			.addFunction("GetPtrAddr", &pcSNB::GetPtrAddr)
			.addFunction("mGetSerchNearJumpAttackTarget", &pcSNB::mGetSerchNearJumpAttackTarget)
		.endClass();
	}
#endif
};
static_assert(sizeof(pcSNB) == 8252, "expected class pcSNB to be size 8252");

// [Structure] class State_Tojo_Knife_SuddenAttack
class State_Tojo_Knife_SuddenAttack : public State_Tojo_SuddenAttack
{
public:
	// enum State_Tojo_Knife_SuddenAttack::eStat
	enum eStat : uint32_t
	{
		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_WaitPcClose = 0x1>
		eStat_WaitPcClose = 1,

		// <eStat_Attack = 0x2>
		eStat_Attack = 2

	};

	/// Struct member variables

	// <class State_Tojo_SuddenAttack field_0, offset 0x0>
	// class State_Tojo_SuddenAttack Super;

	// <enum State_Tojo_Knife_SuddenAttack::eStat m_eStat, offset 0x4>
	enum State_Tojo_Knife_SuddenAttack::eStat m_eStat;

	// <struct Vec m_TrapPos, offset 0x8>
	struct Vec m_TrapPos;

	std::string ToString() const { return "class State_Tojo_Knife_SuddenAttack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<State_Tojo_Knife_SuddenAttack, State_Tojo_SuddenAttack>("State_Tojo_Knife_SuddenAttack")
			.addFunction("__tostring", &State_Tojo_Knife_SuddenAttack::ToString)
			.addFunction("GetPtrAddr", &State_Tojo_Knife_SuddenAttack::GetPtrAddr)
			.addProperty("m_eStat", &State_Tojo_Knife_SuddenAttack::m_eStat)
			.addProperty("m_TrapPos", &State_Tojo_Knife_SuddenAttack::m_TrapPos)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Knife_SuddenAttack::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Tojo_Knife_SuddenAttack::m_TrapPos) == 12, "expected m_TrapPos to be size 12");
static_assert(sizeof(State_Tojo_Knife_SuddenAttack) == 20, "expected class State_Tojo_Knife_SuddenAttack to be size 20");

// [Structure] class ZkKnifeState_ThroughKnife
class ZkKnifeState_ThroughKnife : public PJState
{
public:
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <uint8_t m_boTrigger, offset 0x4>
	uint8_t m_boTrigger;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class ZkKnifeState_ThroughKnife(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<ZkKnifeState_ThroughKnife, PJState>("ZkKnifeState_ThroughKnife")
			.addFunction("__tostring", &ZkKnifeState_ThroughKnife::ToString)
			.addFunction("GetPtrAddr", &ZkKnifeState_ThroughKnife::GetPtrAddr)
			.addProperty("m_boTrigger", &ZkKnifeState_ThroughKnife::m_boTrigger)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkKnifeState_ThroughKnife::m_boTrigger) == 1, "expected m_boTrigger to be size 1");
static_assert(sizeof(ZkKnifeState_ThroughKnife) == 8, "expected class ZkKnifeState_ThroughKnife to be size 8");

// [Structure] class PJZAKOBoneB
class PJZAKOBoneB : public PJZAKO
{
public:
	/// Struct member variables

	// <class PJZAKO field_0, offset 0x0>
	// class PJZAKO Super;

	std::string ToString() const { return "class PJZAKOBoneB(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZAKOBoneB, PJZAKO>("PJZAKOBoneB")
			.addFunction("__tostring", &PJZAKOBoneB::ToString)
			.addFunction("GetPtrAddr", &PJZAKOBoneB::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKOBoneB) == 2532, "expected class PJZAKOBoneB to be size 2532");

// [Structure] class PJZakoKnife
class PJZakoKnife : public PJZAKOBoneB
{
public:
	// [Function] int32_t __convention("thiscall") PJZakoKnife::ConvertDmgMot(class PJZakoKnife* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4) [?ConvertDmgMot@PJZakoKnife@@UAEHHHPAVmHRChara@@@Z]
	int32_t ConvertDmgMot(int32_t const arg2, int32_t const arg3, class mHRChara* arg4)
	{
		typedef int32_t(__thiscall* _Func)(class PJZakoKnife* const thisPtr, int32_t const arg2, int32_t const arg3, class mHRChara* arg4);
		_Func mFunc = (_Func)(GameModule + 0x4fd290);
		return mFunc(this, arg2, arg3, arg4);
	}
	/// Struct member variables

	// <class PJZAKOBoneB field_0, offset 0x0>
	// class PJZAKOBoneB Super;

	// <class ZkKnifeState_ThroughKnife m_State_ThroughKnife, offset 0x9e4>
	class ZkKnifeState_ThroughKnife m_State_ThroughKnife;

	// <class State_Tojo_Knife_SuddenAttack m_State_SdnAtk, offset 0x9ec>
	class State_Tojo_Knife_SuddenAttack m_State_SdnAtk;

	std::string ToString() const { return "class PJZakoKnife(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJZakoKnife, PJZAKOBoneB>("PJZakoKnife")
			.addFunction("__tostring", &PJZakoKnife::ToString)
			.addFunction("GetPtrAddr", &PJZakoKnife::GetPtrAddr)
			.addProperty("m_State_ThroughKnife", &PJZakoKnife::m_State_ThroughKnife)
			.addProperty("m_State_SdnAtk", &PJZakoKnife::m_State_SdnAtk)
			.addFunction("ConvertDmgMot", &PJZakoKnife::ConvertDmgMot)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoKnife::m_State_ThroughKnife) == 8, "expected m_State_ThroughKnife to be size 8");
static_assert(sizeof(PJZakoKnife::m_State_SdnAtk) == 20, "expected m_State_SdnAtk to be size 20");
static_assert(sizeof(PJZakoKnife) == 2560, "expected class PJZakoKnife to be size 2560");

// [Structure] class bsSKE
class bsSKE
{
public:
	// [Function] uint8_t __convention("thiscall") bsSKE::mSetDamage(class bsSKE* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsSKE@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class bsSKE* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x501450);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[3684];
public:

	std::string ToString() const { return "class bsSKE(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsSKE>("bsSKE")
			.addFunction("__tostring", &bsSKE::ToString)
			.addFunction("GetPtrAddr", &bsSKE::GetPtrAddr)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &bsSKE::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsSKE) == 3684, "expected class bsSKE to be size 3684");

// [Structure] class bsLEZ
class bsLEZ
{
public:
	// [Function] uint8_t __convention("thiscall") bsLEZ::mSetDamage(class bsLEZ* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsLEZ@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class bsLEZ* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x52ed70);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[4412];
public:

	std::string ToString() const { return "class bsLEZ(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsLEZ>("bsLEZ")
			.addFunction("__tostring", &bsLEZ::ToString)
			.addFunction("GetPtrAddr", &bsLEZ::GetPtrAddr)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &bsLEZ::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsLEZ) == 4412, "expected class bsLEZ to be size 4412");

// [Structure] class bsCEW
class bsCEW
{
public:
	// [Function] uint8_t __convention("thiscall") bsCEW::mSetDamage(class bsCEW* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsCEW@@EAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class bsCEW* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x533080);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[4232];
public:

	std::string ToString() const { return "class bsCEW(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsCEW>("bsCEW")
			.addFunction("__tostring", &bsCEW::ToString)
			.addFunction("GetPtrAddr", &bsCEW::GetPtrAddr)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &bsCEW::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsCEW) == 4232, "expected class bsCEW to be size 4232");

// [Structure] class bsAST
class bsAST
{
public:
	// [Function] uint8_t __convention("thiscall") bsAST::mSetDamage(class bsAST* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsAST@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class bsAST* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x541b20);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[4352];
public:

	std::string ToString() const { return "class bsAST(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsAST>("bsAST")
			.addFunction("__tostring", &bsAST::ToString)
			.addFunction("GetPtrAddr", &bsAST::GetPtrAddr)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &bsAST::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsAST) == 4352, "expected class bsAST to be size 4352");

// [Structure] class bsRKT
class bsRKT
{
public:
	// [Function] uint8_t __convention("thiscall") bsRKT::mSetDamage(class bsRKT* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsRKT@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class bsRKT* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x547690);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[4672];
public:

	std::string ToString() const { return "class bsRKT(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsRKT>("bsRKT")
			.addFunction("__tostring", &bsRKT::ToString)
			.addFunction("GetPtrAddr", &bsRKT::GetPtrAddr)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &bsRKT::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsRKT) == 4672, "expected class bsRKT to be size 4672");

// [Structure] class KrBaseState<bsBasic>
template<typename T>
class KrBaseState
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x7], offset 0x0>
	void* (* field_0)[0x7];

	std::string ToString() const { return "class KrBaseState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
	// Exporting templated types to Lua currently not supported.
	// static void BindLua(luabridge::Namespace& NS)
};
static_assert(sizeof(KrBaseState<bsBasic>::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(KrBaseState<bsBasic>) == 4, "expected class KrBaseState<bsBasic> to be size 4");

// [Structure] class GLBDeathState
class GLBDeathState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <int32_t mExpCnt, offset 0x4>
	int32_t mExpCnt;

	std::string ToString() const { return "class GLBDeathState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBDeathState>("GLBDeathState")
			.addFunction("__tostring", &GLBDeathState::ToString)
			.addFunction("GetPtrAddr", &GLBDeathState::GetPtrAddr)
			.addProperty("mExpCnt", &GLBDeathState::mExpCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBDeathState::mExpCnt) == 4, "expected mExpCnt to be size 4");
static_assert(sizeof(GLBDeathState) == 8, "expected class GLBDeathState to be size 8");

// [Structure] class GLBWalkState
class GLBWalkState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	std::string ToString() const { return "class GLBWalkState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBWalkState>("GLBWalkState")
			.addFunction("__tostring", &GLBWalkState::ToString)
			.addFunction("GetPtrAddr", &GLBWalkState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBWalkState) == 4, "expected class GLBWalkState to be size 4");

// [Structure] class GLBComboState
class GLBComboState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <uint8_t mbCancel, offset 0x4>
	uint8_t mbCancel;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class GLBComboState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBComboState>("GLBComboState")
			.addFunction("__tostring", &GLBComboState::ToString)
			.addFunction("GetPtrAddr", &GLBComboState::GetPtrAddr)
			.addProperty("mbCancel", &GLBComboState::mbCancel)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBComboState::mbCancel) == 1, "expected mbCancel to be size 1");
static_assert(sizeof(GLBComboState) == 8, "expected class GLBComboState to be size 8");

// [Structure] class GLBIdleState
class GLBIdleState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	std::string ToString() const { return "class GLBIdleState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBIdleState>("GLBIdleState")
			.addFunction("__tostring", &GLBIdleState::ToString)
			.addFunction("GetPtrAddr", &GLBIdleState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBIdleState) == 4, "expected class GLBIdleState to be size 4");

// [Structure] class GLBJampState
class GLBJampState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <int32_t JumpTick, offset 0x4>
	int32_t JumpTick;

	std::string ToString() const { return "class GLBJampState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBJampState>("GLBJampState")
			.addFunction("__tostring", &GLBJampState::ToString)
			.addFunction("GetPtrAddr", &GLBJampState::GetPtrAddr)
			.addProperty("JumpTick", &GLBJampState::JumpTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBJampState::JumpTick) == 4, "expected JumpTick to be size 4");
static_assert(sizeof(GLBJampState) == 8, "expected class GLBJampState to be size 8");

// [Structure] class KrStateMachine<pcGLB,32>
template<typename T1, int T2>
class KrStateMachine
{
public:
	/// Struct member variables

	// <class pcGLB* mpOwner, offset 0x0>
	T1* mpOwner;

	// <int32_t mpCurrentIdx, offset 0x4>
	int32_t mpCurrentIdx;

	// <int32_t mpPreviousIdx, offset 0x8>
	int32_t mpPreviousIdx;

	// <int32_t mpGlobalIdx, offset 0xc>
	int32_t mpGlobalIdx;

	// <class KrBaseState<pcGLB>* mpState[0x20], offset 0x10>
	class KrBaseState<T1>* mpState[T2];

	std::string ToString() const { return "class KrStateMachine(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
	// Exporting templated types to Lua currently not supported.
	// static void BindLua(luabridge::Namespace& NS)
};
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpOwner) == 4, "expected mpOwner to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpCurrentIdx) == 4, "expected mpCurrentIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpPreviousIdx) == 4, "expected mpPreviousIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpGlobalIdx) == 4, "expected mpGlobalIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpState) == 128, "expected mpState to be size 128");
static_assert(sizeof(KrStateMachine<pcGLB,32>) == 144, "expected class KrStateMachine<pcGLB,32> to be size 144");

// [Structure] class rSideScrollCamera
class rSideScrollCamera
{
public:
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <struct Vec mPos, offset 0x4>
	struct Vec mPos;

	// <struct Vec mTarget, offset 0x10>
	struct Vec mTarget;

	// <float mInterpolateSpd, offset 0x1c>
	float mInterpolateSpd;

	// <float mPosDist, offset 0x20>
	float mPosDist;

	// <float mXAngle, offset 0x24>
	float mXAngle;

	// <float mYAngle, offset 0x28>
	float mYAngle;

	// <float mAdjustYAngle, offset 0x2c>
	float mAdjustYAngle;

	// <uint8_t mbZoom, offset 0x30>
	uint8_t mbZoom;

	// <Unidentified data segment, offset 0x31>
private:
	char _UnidentifiedData9[3];

public:
	// <float mZoomDist, offset 0x34>
	float mZoomDist;

	// <float mZoomSpeed, offset 0x38>
	float mZoomSpeed;

	// <struct Vec mZoomDirec, offset 0x3c>
	struct Vec mZoomDirec;

	std::string ToString() const { return "class rSideScrollCamera(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rSideScrollCamera>("rSideScrollCamera")
			.addFunction("__tostring", &rSideScrollCamera::ToString)
			.addFunction("GetPtrAddr", &rSideScrollCamera::GetPtrAddr)
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &rSideScrollCamera::field_0)
			.addProperty("mPos", &rSideScrollCamera::mPos)
			.addProperty("mTarget", &rSideScrollCamera::mTarget)
			.addProperty("mInterpolateSpd", &rSideScrollCamera::mInterpolateSpd)
			.addProperty("mPosDist", &rSideScrollCamera::mPosDist)
			.addProperty("mXAngle", &rSideScrollCamera::mXAngle)
			.addProperty("mYAngle", &rSideScrollCamera::mYAngle)
			.addProperty("mAdjustYAngle", &rSideScrollCamera::mAdjustYAngle)
			.addProperty("mbZoom", &rSideScrollCamera::mbZoom)
			.addProperty("mZoomDist", &rSideScrollCamera::mZoomDist)
			.addProperty("mZoomSpeed", &rSideScrollCamera::mZoomSpeed)
			.addProperty("mZoomDirec", &rSideScrollCamera::mZoomDirec)
		.endClass();
	}
#endif
};
static_assert(sizeof(rSideScrollCamera::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(rSideScrollCamera::mPos) == 12, "expected mPos to be size 12");
static_assert(sizeof(rSideScrollCamera::mTarget) == 12, "expected mTarget to be size 12");
static_assert(sizeof(rSideScrollCamera::mInterpolateSpd) == 4, "expected mInterpolateSpd to be size 4");
static_assert(sizeof(rSideScrollCamera::mPosDist) == 4, "expected mPosDist to be size 4");
static_assert(sizeof(rSideScrollCamera::mXAngle) == 4, "expected mXAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mYAngle) == 4, "expected mYAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mAdjustYAngle) == 4, "expected mAdjustYAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mbZoom) == 1, "expected mbZoom to be size 1");
static_assert(sizeof(rSideScrollCamera::mZoomDist) == 4, "expected mZoomDist to be size 4");
static_assert(sizeof(rSideScrollCamera::mZoomSpeed) == 4, "expected mZoomSpeed to be size 4");
static_assert(sizeof(rSideScrollCamera::mZoomDirec) == 12, "expected mZoomDirec to be size 12");
static_assert(sizeof(rSideScrollCamera) == 72, "expected class rSideScrollCamera to be size 72");

// [Structure] class GLBDamageState
class GLBDamageState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	std::string ToString() const { return "class GLBDamageState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBDamageState>("GLBDamageState")
			.addFunction("__tostring", &GLBDamageState::ToString)
			.addFunction("GetPtrAddr", &GLBDamageState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBDamageState) == 4, "expected class GLBDamageState to be size 4");

// [Structure] class GLBGuardState
class GLBGuardState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	std::string ToString() const { return "class GLBGuardState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBGuardState>("GLBGuardState")
			.addFunction("__tostring", &GLBGuardState::ToString)
			.addFunction("GetPtrAddr", &GLBGuardState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBGuardState) == 4, "expected class GLBGuardState to be size 4");

// [Structure] class GLBAirKickState
class GLBAirKickState : public KrBaseState<pcGLB>
{
public:
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	std::string ToString() const { return "class GLBAirKickState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBAirKickState>("GLBAirKickState")
			.addFunction("__tostring", &GLBAirKickState::ToString)
			.addFunction("GetPtrAddr", &GLBAirKickState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBAirKickState) == 4, "expected class GLBAirKickState to be size 4");

// [Structure] class pcGLB
class pcGLB : public mHRChara
{
public:
	// [Function] uint8_t __convention("thiscall") pcGLB::IsAtkObj(class pcGLB* const this, class mHRChara* arg2) [?IsAtkObj@pcGLB@@EAE_NPAVmHRChara@@@Z]
	uint8_t IsAtkObj(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class pcGLB* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x54ac90);
		return mFunc(this, arg2);
	}
	// [Structure] struct pcGLB::DmgInfo
	struct DmgInfo
	{
	public:
		/// Struct member variables

		// <uint32_t Kind, offset 0x0>
		uint32_t Kind;

		// <uint32_t DirecKind, offset 0x4>
		uint32_t DirecKind;

		// <float Direc, offset 0x8>
		float Direc;

		// <uint32_t FinishHitNum, offset 0xc>
		uint32_t FinishHitNum;

		// <uint32_t DownFinishHitMax, offset 0x10>
		uint32_t DownFinishHitMax;

		// <float AccumuAmount, offset 0x14>
		float AccumuAmount;

		// <float AccumuMax, offset 0x18>
		float AccumuMax;

		// <float AccumuRecovery, offset 0x1c>
		float AccumuRecovery;

		// <float GroggyAmount, offset 0x20>
		float GroggyAmount;

		// <float GroggyMax, offset 0x24>
		float GroggyMax;

		// <float GroggyRecovery, offset 0x28>
		float GroggyRecovery;

		std::string ToString() const { return "struct DmgInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<pcGLB::DmgInfo>("pcGLB_DmgInfo")
				.addFunction("__tostring", &pcGLB::DmgInfo::ToString)
				.addFunction("GetPtrAddr", &pcGLB::DmgInfo::GetPtrAddr)
				.addProperty("Kind", &pcGLB::DmgInfo::Kind)
				.addProperty("DirecKind", &pcGLB::DmgInfo::DirecKind)
				.addProperty("Direc", &pcGLB::DmgInfo::Direc)
				.addProperty("FinishHitNum", &pcGLB::DmgInfo::FinishHitNum)
				.addProperty("DownFinishHitMax", &pcGLB::DmgInfo::DownFinishHitMax)
				.addProperty("AccumuAmount", &pcGLB::DmgInfo::AccumuAmount)
				.addProperty("AccumuMax", &pcGLB::DmgInfo::AccumuMax)
				.addProperty("AccumuRecovery", &pcGLB::DmgInfo::AccumuRecovery)
				.addProperty("GroggyAmount", &pcGLB::DmgInfo::GroggyAmount)
				.addProperty("GroggyMax", &pcGLB::DmgInfo::GroggyMax)
				.addProperty("GroggyRecovery", &pcGLB::DmgInfo::GroggyRecovery)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(pcGLB::DmgInfo::Kind) == 4, "expected Kind to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::DirecKind) == 4, "expected DirecKind to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::Direc) == 4, "expected Direc to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::FinishHitNum) == 4, "expected FinishHitNum to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::DownFinishHitMax) == 4, "expected DownFinishHitMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuAmount) == 4, "expected AccumuAmount to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuMax) == 4, "expected AccumuMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuRecovery) == 4, "expected AccumuRecovery to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyAmount) == 4, "expected GroggyAmount to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyMax) == 4, "expected GroggyMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyRecovery) == 4, "expected GroggyRecovery to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo) == 44, "expected struct pcGLB::DmgInfo to be size 44");

	// [Structure] struct pcGLB::TickCnt
	struct TickCnt
	{
	public:
		/// Struct member variables

		// <int32_t Motion, offset 0x0>
		int32_t Motion;

		// <int32_t AtkWait, offset 0x4>
		int32_t AtkWait;

		// <int32_t Loop, offset 0x8>
		int32_t Loop;

		// <int32_t State, offset 0xc>
		int32_t State;

		// <int32_t DmgWait, offset 0x10>
		int32_t DmgWait;

		// <int32_t DmgPlayAccept, offset 0x14>
		int32_t DmgPlayAccept;

		std::string ToString() const { return "struct TickCnt(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<pcGLB::TickCnt>("pcGLB_TickCnt")
				.addFunction("__tostring", &pcGLB::TickCnt::ToString)
				.addFunction("GetPtrAddr", &pcGLB::TickCnt::GetPtrAddr)
				.addProperty("Motion", &pcGLB::TickCnt::Motion)
				.addProperty("AtkWait", &pcGLB::TickCnt::AtkWait)
				.addProperty("Loop", &pcGLB::TickCnt::Loop)
				.addProperty("State", &pcGLB::TickCnt::State)
				.addProperty("DmgWait", &pcGLB::TickCnt::DmgWait)
				.addProperty("DmgPlayAccept", &pcGLB::TickCnt::DmgPlayAccept)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(pcGLB::TickCnt::Motion) == 4, "expected Motion to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::AtkWait) == 4, "expected AtkWait to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::Loop) == 4, "expected Loop to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::State) == 4, "expected State to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::DmgWait) == 4, "expected DmgWait to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::DmgPlayAccept) == 4, "expected DmgPlayAccept to be size 4");
	static_assert(sizeof(pcGLB::TickCnt) == 24, "expected struct pcGLB::TickCnt to be size 24");

	// enum pcGLB::MiniDemoEnum
	enum MiniDemoEnum : uint32_t
	{
		// <MD_Init = 0xffffffffffffffff>
		MD_Init = UINT32_MAX,

		// <MD_Strawberry = 0x0>
		MD_Strawberry = 0,

		// <MD_London = 0x1>
		MD_London = 1,

		// <MD_Ragvy = 0x2>
		MD_Ragvy = 2

	};

	// [Function] void __convention("thiscall") pcGLB::SetDamageIK(class pcGLB* const this, class mHRChara* arg2, uint8_t arg3) [?SetDamageIK@pcGLB@@AAEXPAVmHRChara@@_N@Z]
	void SetDamageIK(class mHRChara* arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class pcGLB* const thisPtr, class mHRChara* arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x54b5e0);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") pcGLB::mSetDamage(class pcGLB* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@pcGLB@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class pcGLB* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x54bb60);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <uint8_t mCanOperate, offset 0x580>
	uint8_t mCanOperate;

	// <uint8_t mTestOnCanOperate, offset 0x581>
	uint8_t mTestOnCanOperate;

	// <Unidentified data segment, offset 0x582>
private:
	char _UnidentifiedData3[2];

public:
	// <class rSideScrollCamera mSideCamera, offset 0x584>
	class rSideScrollCamera mSideCamera;

	// <class EfRoboInterface* mpInterface, offset 0x5cc>
	class EfRoboInterface* mpInterface;

	// <class bsSDP* mpSDP, offset 0x5d0>
	class bsSDP* mpSDP;

	// <class KrStateMachine<pcGLB,32> mStateMachine, offset 0x5d4>
	class KrStateMachine<pcGLB,32> mStateMachine;

	// <class GLBIdleState mIdleState, offset 0x664>
	class GLBIdleState mIdleState;

	// <class GLBWalkState mWalkState, offset 0x668>
	class GLBWalkState mWalkState;

	// <class GLBJampState mJampState, offset 0x66c>
	class GLBJampState mJampState;

	// <class GLBDamageState mDamageState, offset 0x674>
	class GLBDamageState mDamageState;

	// <class GLBGuardState mGuardState, offset 0x678>
	class GLBGuardState mGuardState;

	// <class GLBComboState mComboState, offset 0x67c>
	class GLBComboState mComboState;

	// <class GLBAirKickState mAirKickState, offset 0x684>
	class GLBAirKickState mAirKickState;

	// <class GLBDeathState mDeathState, offset 0x688>
	class GLBDeathState mDeathState;

	// <struct pcGLB::DmgInfo mDmgInfo, offset 0x690>
	struct pcGLB::DmgInfo mDmgInfo;

	// <struct pcGLB::TickCnt mTickCnt, offset 0x6bc>
	struct pcGLB::TickCnt mTickCnt;

	// <float mAirY, offset 0x6d4>
	float mAirY;

	// <float mAirPower, offset 0x6d8>
	float mAirPower;

	// <uint8_t mbAir, offset 0x6dc>
	uint8_t mbAir;

	// <Unidentified data segment, offset 0x6dd>
private:
	char _UnidentifiedData20[3];

public:
	// <float mTension, offset 0x6e0>
	float mTension;

	// <struct Vec mBefPos, offset 0x6e4>
	struct Vec mBefPos;

	// <enum pcGLB::MiniDemoEnum mMDemoNo, offset 0x6f0>
	enum pcGLB::MiniDemoEnum mMDemoNo;

	// <int32_t mPhase, offset 0x6f4>
	int32_t mPhase;

	// <uint32_t mBeamColor, offset 0x6f8>
	uint32_t mBeamColor;

	// <uint8_t mbDemoWait, offset 0x6fc>
	uint8_t mbDemoWait;

	// <Unidentified data segment, offset 0x6fd>
private:
	char _UnidentifiedData26[3];

public:
	// <class TGmfNode* mpWristLNode, offset 0x700>
	class TGmfNode* mpWristLNode;

	// <class EffectModelBeam* mpWepBeam, offset 0x704>
	class EffectModelBeam* mpWepBeam;

	// <uint8_t mbCanKick, offset 0x708>
	uint8_t mbCanKick;

	// <Unidentified data segment, offset 0x709>
private:
	char _UnidentifiedData29[3];

public:
	// <int32_t mhVernierSE, offset 0x70c>
	int32_t mhVernierSE;

	// <int32_t mMDFlag, offset 0x710>
	int32_t mMDFlag;

	std::string ToString() const { return "class pcGLB(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<pcGLB, mHRChara>("pcGLB")
			.addFunction("__tostring", &pcGLB::ToString)
			.addFunction("GetPtrAddr", &pcGLB::GetPtrAddr)
			.addProperty("mCanOperate", &pcGLB::mCanOperate)
			.addProperty("mTestOnCanOperate", &pcGLB::mTestOnCanOperate)
			.addProperty("mSideCamera", &pcGLB::mSideCamera)
			.addProperty("mpInterface", &pcGLB::mpInterface)
			.addProperty("mpSDP", &pcGLB::mpSDP)
			.addProperty("mStateMachine", &pcGLB::mStateMachine)
			.addProperty("mIdleState", &pcGLB::mIdleState)
			.addProperty("mWalkState", &pcGLB::mWalkState)
			.addProperty("mJampState", &pcGLB::mJampState)
			.addProperty("mDamageState", &pcGLB::mDamageState)
			.addProperty("mGuardState", &pcGLB::mGuardState)
			.addProperty("mComboState", &pcGLB::mComboState)
			.addProperty("mAirKickState", &pcGLB::mAirKickState)
			.addProperty("mDeathState", &pcGLB::mDeathState)
			.addProperty("mDmgInfo", &pcGLB::mDmgInfo)
			.addProperty("mTickCnt", &pcGLB::mTickCnt)
			.addProperty("mAirY", &pcGLB::mAirY)
			.addProperty("mAirPower", &pcGLB::mAirPower)
			.addProperty("mbAir", &pcGLB::mbAir)
			.addProperty("mTension", &pcGLB::mTension)
			.addProperty("mBefPos", &pcGLB::mBefPos)
			.addProperty("mMDemoNo", &pcGLB::mMDemoNo)
			.addProperty("mPhase", &pcGLB::mPhase)
			.addProperty("mBeamColor", &pcGLB::mBeamColor)
			.addProperty("mbDemoWait", &pcGLB::mbDemoWait)
			.addProperty("mpWristLNode", &pcGLB::mpWristLNode)
			.addProperty("mpWepBeam", &pcGLB::mpWepBeam)
			.addProperty("mbCanKick", &pcGLB::mbCanKick)
			.addProperty("mhVernierSE", &pcGLB::mhVernierSE)
			.addProperty("mMDFlag", &pcGLB::mMDFlag)
			.addFunction("IsAtkObj", &pcGLB::IsAtkObj)
			.addFunction("SetDamageIK", &pcGLB::SetDamageIK)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &pcGLB::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(pcGLB::mCanOperate) == 1, "expected mCanOperate to be size 1");
static_assert(sizeof(pcGLB::mTestOnCanOperate) == 1, "expected mTestOnCanOperate to be size 1");
static_assert(sizeof(pcGLB::mSideCamera) == 72, "expected mSideCamera to be size 72");
static_assert(sizeof(pcGLB::mpInterface) == 4, "expected mpInterface to be size 4");
static_assert(sizeof(pcGLB::mpSDP) == 4, "expected mpSDP to be size 4");
static_assert(sizeof(pcGLB::mStateMachine) == 144, "expected mStateMachine to be size 144");
static_assert(sizeof(pcGLB::mIdleState) == 4, "expected mIdleState to be size 4");
static_assert(sizeof(pcGLB::mWalkState) == 4, "expected mWalkState to be size 4");
static_assert(sizeof(pcGLB::mJampState) == 8, "expected mJampState to be size 8");
static_assert(sizeof(pcGLB::mDamageState) == 4, "expected mDamageState to be size 4");
static_assert(sizeof(pcGLB::mGuardState) == 4, "expected mGuardState to be size 4");
static_assert(sizeof(pcGLB::mComboState) == 8, "expected mComboState to be size 8");
static_assert(sizeof(pcGLB::mAirKickState) == 4, "expected mAirKickState to be size 4");
static_assert(sizeof(pcGLB::mDeathState) == 8, "expected mDeathState to be size 8");
static_assert(sizeof(pcGLB::mDmgInfo) == 44, "expected mDmgInfo to be size 44");
static_assert(sizeof(pcGLB::mTickCnt) == 24, "expected mTickCnt to be size 24");
static_assert(sizeof(pcGLB::mAirY) == 4, "expected mAirY to be size 4");
static_assert(sizeof(pcGLB::mAirPower) == 4, "expected mAirPower to be size 4");
static_assert(sizeof(pcGLB::mbAir) == 1, "expected mbAir to be size 1");
static_assert(sizeof(pcGLB::mTension) == 4, "expected mTension to be size 4");
static_assert(sizeof(pcGLB::mBefPos) == 12, "expected mBefPos to be size 12");
static_assert(sizeof(pcGLB::mMDemoNo) == 4, "expected mMDemoNo to be size 4");
static_assert(sizeof(pcGLB::mPhase) == 4, "expected mPhase to be size 4");
static_assert(sizeof(pcGLB::mBeamColor) == 4, "expected mBeamColor to be size 4");
static_assert(sizeof(pcGLB::mbDemoWait) == 1, "expected mbDemoWait to be size 1");
static_assert(sizeof(pcGLB::mpWristLNode) == 4, "expected mpWristLNode to be size 4");
static_assert(sizeof(pcGLB::mpWepBeam) == 4, "expected mpWepBeam to be size 4");
static_assert(sizeof(pcGLB::mbCanKick) == 1, "expected mbCanKick to be size 1");
static_assert(sizeof(pcGLB::mhVernierSE) == 4, "expected mhVernierSE to be size 4");
static_assert(sizeof(pcGLB::mMDFlag) == 4, "expected mMDFlag to be size 4");
static_assert(sizeof(pcGLB) == 1812, "expected class pcGLB to be size 1812");

// [Structure] class EfRoboInterface
class EfRoboInterface : public HrTask
{
public:
	// enum EfRoboInterface::InterfaceState
	enum InterfaceState : uint32_t
	{
		// <State_Init = 0x0>
		State_Init = 0,

		// <State_FadeIn = 0x1>
		State_FadeIn = 1,

		// <State_Active = 0x2>
		State_Active = 2,

		// <State_FadeOut = 0x3>
		State_FadeOut = 3

	};

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <class EffectSpeedBlur* mpBlur, offset 0x68>
	class EffectSpeedBlur* mpBlur;

	// <struct tagGHMR_TEX mInputCZTex, offset 0x6c>
	struct tagGHMR_TEX mInputCZTex;

	// <struct tagGHMR_TEX mInputLineTex, offset 0x94>
	struct tagGHMR_TEX mInputLineTex;

	// <struct tagGHMR_TEX mPcHpFrameTex, offset 0xbc>
	struct tagGHMR_TEX mPcHpFrameTex;

	// <struct tagGHMR_TEX mEnemyHpFrameTex, offset 0xe4>
	struct tagGHMR_TEX mEnemyHpFrameTex;

	// <struct tagGHMR_TEX mHpTex, offset 0x10c>
	struct tagGHMR_TEX mHpTex;

	// <struct tagGHMR_TEX mFrameDamageTex, offset 0x134>
	struct tagGHMR_TEX mFrameDamageTex;

	// <struct tagGHMR_TEX mFrameTrvDmgTex, offset 0x15c>
	struct tagGHMR_TEX mFrameTrvDmgTex;

	// <struct tagGHMR_TEX mFrameSdpDmgTex, offset 0x184>
	struct tagGHMR_TEX mFrameSdpDmgTex;

	// <struct tagGHMR_TEX mFrameNoiseTex, offset 0x1ac>
	struct tagGHMR_TEX mFrameNoiseTex;

	// <struct tagGHMR_TEX mPcTensionFrameTex, offset 0x1d4>
	struct tagGHMR_TEX mPcTensionFrameTex;

	// <struct tagGHMR_TEX mEnemyTensionFrameTex, offset 0x1fc>
	struct tagGHMR_TEX mEnemyTensionFrameTex;

	// <struct tagGHMR_TEX mTensionTex, offset 0x224>
	struct tagGHMR_TEX mTensionTex;

	// <struct tagGHMR_TEX mPcTensionMaxTex, offset 0x24c>
	struct tagGHMR_TEX mPcTensionMaxTex;

	// <struct tagGHMR_TEX mEnemeyTensionMaxTex, offset 0x274>
	struct tagGHMR_TEX mEnemeyTensionMaxTex;

	// <struct tagGHMR_TEX mLTigerTex, offset 0x29c>
	struct tagGHMR_TEX mLTigerTex;

	// <struct tagGHMR_TEX mLBackTex, offset 0x2c4>
	struct tagGHMR_TEX mLBackTex;

	// <struct tagGHMR_TEX mRTigerTex, offset 0x2ec>
	struct tagGHMR_TEX mRTigerTex;

	// <struct tagGHMR_TEX mRBackTex, offset 0x314>
	struct tagGHMR_TEX mRBackTex;

	// <enum EfRoboInterface::InterfaceState mInputCState, offset 0x33c>
	enum EfRoboInterface::InterfaceState mInputCState;

	// <float mInputCSlide, offset 0x340>
	float mInputCSlide;

	// <uint8_t mbInputCVisble, offset 0x344>
	uint8_t mbInputCVisble;

	// <Unidentified data segment, offset 0x345>
private:
	char _UnidentifiedData24[3];

public:
	// <float mInputCAlpha, offset 0x348>
	float mInputCAlpha;

	// <enum EfRoboInterface::InterfaceState mBlackState, offset 0x34c>
	enum EfRoboInterface::InterfaceState mBlackState;

	// <float mBlackAlpha, offset 0x350>
	float mBlackAlpha;

	// <enum EfRoboInterface::InterfaceState mPcFlashState, offset 0x354>
	enum EfRoboInterface::InterfaceState mPcFlashState;

	// <int32_t mPcFlashAnimeCnt, offset 0x358>
	int32_t mPcFlashAnimeCnt;

	// <int32_t mPcFlashCnt, offset 0x35c>
	int32_t mPcFlashCnt;

	// <float mPcFlashAlpha, offset 0x360>
	float mPcFlashAlpha;

	// <enum EfRoboInterface::InterfaceState mEnemyFlashState, offset 0x364>
	enum EfRoboInterface::InterfaceState mEnemyFlashState;

	// <int32_t mEnemyFlashAnimeCnt, offset 0x368>
	int32_t mEnemyFlashAnimeCnt;

	// <int32_t mEnemyFlashCnt, offset 0x36c>
	int32_t mEnemyFlashCnt;

	// <float mEnemyFlashAlpha, offset 0x370>
	float mEnemyFlashAlpha;

	// <float mPcHpRate, offset 0x374>
	float mPcHpRate;

	// <float mPcHpRateTarget, offset 0x378>
	float mPcHpRateTarget;

	// <float mBefPcHpRateTarget, offset 0x37c>
	float mBefPcHpRateTarget;

	// <float mPcDmgSubRate, offset 0x380>
	float mPcDmgSubRate;

	// <float mEnemyHpRate, offset 0x384>
	float mEnemyHpRate;

	// <float mEnemyHpRateTarget, offset 0x388>
	float mEnemyHpRateTarget;

	// <float mBefEnemyHpRateTarget, offset 0x38c>
	float mBefEnemyHpRateTarget;

	// <float mEnemyDmgSubRate, offset 0x390>
	float mEnemyDmgSubRate;

	// <float mPcHpWait, offset 0x394>
	float mPcHpWait;

	// <float mEnemyHpWait, offset 0x398>
	float mEnemyHpWait;

	// <float mPcTensionRate, offset 0x39c>
	float mPcTensionRate;

	// <float mPcTensionRateTarget, offset 0x3a0>
	float mPcTensionRateTarget;

	// <float mEnemyTensionRate, offset 0x3a4>
	float mEnemyTensionRate;

	// <float mEnemyTensionRateTarget, offset 0x3a8>
	float mEnemyTensionRateTarget;

	// <float mTensionSlide, offset 0x3ac>
	float mTensionSlide;

	// <uint8_t mbPcMaxVisible, offset 0x3b0>
	uint8_t mbPcMaxVisible;

	// <uint8_t mbEnemyMaxVisible, offset 0x3b1>
	uint8_t mbEnemyMaxVisible;

	// <Unidentified data segment, offset 0x3b2>
private:
	char _UnidentifiedData52[2];

public:
	// <uint32_t mDmgAnimeCnt, offset 0x3b4>
	uint32_t mDmgAnimeCnt;

	// <uint8_t mbFinish, offset 0x3b8>
	uint8_t mbFinish;

	// <Unidentified data segment, offset 0x3b9>
private:
	char _UnidentifiedData54[3];

public:
	// <float mBlurAlpha, offset 0x3bc>
	float mBlurAlpha;

	// <uint8_t mBlurValid, offset 0x3c0>
	uint8_t mBlurValid;

	// <Unidentified data segment, offset 0x3c1>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class EfRoboInterface(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EfRoboInterface, HrTask>("EfRoboInterface")
			.addFunction("__tostring", &EfRoboInterface::ToString)
			.addFunction("GetPtrAddr", &EfRoboInterface::GetPtrAddr)
			.addProperty("field_50", &EfRoboInterface::field_50)
			.addProperty("mpBlur", &EfRoboInterface::mpBlur)
			.addProperty("mInputCZTex", &EfRoboInterface::mInputCZTex)
			.addProperty("mInputLineTex", &EfRoboInterface::mInputLineTex)
			.addProperty("mPcHpFrameTex", &EfRoboInterface::mPcHpFrameTex)
			.addProperty("mEnemyHpFrameTex", &EfRoboInterface::mEnemyHpFrameTex)
			.addProperty("mHpTex", &EfRoboInterface::mHpTex)
			.addProperty("mFrameDamageTex", &EfRoboInterface::mFrameDamageTex)
			.addProperty("mFrameTrvDmgTex", &EfRoboInterface::mFrameTrvDmgTex)
			.addProperty("mFrameSdpDmgTex", &EfRoboInterface::mFrameSdpDmgTex)
			.addProperty("mFrameNoiseTex", &EfRoboInterface::mFrameNoiseTex)
			.addProperty("mPcTensionFrameTex", &EfRoboInterface::mPcTensionFrameTex)
			.addProperty("mEnemyTensionFrameTex", &EfRoboInterface::mEnemyTensionFrameTex)
			.addProperty("mTensionTex", &EfRoboInterface::mTensionTex)
			.addProperty("mPcTensionMaxTex", &EfRoboInterface::mPcTensionMaxTex)
			.addProperty("mEnemeyTensionMaxTex", &EfRoboInterface::mEnemeyTensionMaxTex)
			.addProperty("mLTigerTex", &EfRoboInterface::mLTigerTex)
			.addProperty("mLBackTex", &EfRoboInterface::mLBackTex)
			.addProperty("mRTigerTex", &EfRoboInterface::mRTigerTex)
			.addProperty("mRBackTex", &EfRoboInterface::mRBackTex)
			.addProperty("mInputCState", &EfRoboInterface::mInputCState)
			.addProperty("mInputCSlide", &EfRoboInterface::mInputCSlide)
			.addProperty("mbInputCVisble", &EfRoboInterface::mbInputCVisble)
			.addProperty("mInputCAlpha", &EfRoboInterface::mInputCAlpha)
			.addProperty("mBlackState", &EfRoboInterface::mBlackState)
			.addProperty("mBlackAlpha", &EfRoboInterface::mBlackAlpha)
			.addProperty("mPcFlashState", &EfRoboInterface::mPcFlashState)
			.addProperty("mPcFlashAnimeCnt", &EfRoboInterface::mPcFlashAnimeCnt)
			.addProperty("mPcFlashCnt", &EfRoboInterface::mPcFlashCnt)
			.addProperty("mPcFlashAlpha", &EfRoboInterface::mPcFlashAlpha)
			.addProperty("mEnemyFlashState", &EfRoboInterface::mEnemyFlashState)
			.addProperty("mEnemyFlashAnimeCnt", &EfRoboInterface::mEnemyFlashAnimeCnt)
			.addProperty("mEnemyFlashCnt", &EfRoboInterface::mEnemyFlashCnt)
			.addProperty("mEnemyFlashAlpha", &EfRoboInterface::mEnemyFlashAlpha)
			.addProperty("mPcHpRate", &EfRoboInterface::mPcHpRate)
			.addProperty("mPcHpRateTarget", &EfRoboInterface::mPcHpRateTarget)
			.addProperty("mBefPcHpRateTarget", &EfRoboInterface::mBefPcHpRateTarget)
			.addProperty("mPcDmgSubRate", &EfRoboInterface::mPcDmgSubRate)
			.addProperty("mEnemyHpRate", &EfRoboInterface::mEnemyHpRate)
			.addProperty("mEnemyHpRateTarget", &EfRoboInterface::mEnemyHpRateTarget)
			.addProperty("mBefEnemyHpRateTarget", &EfRoboInterface::mBefEnemyHpRateTarget)
			.addProperty("mEnemyDmgSubRate", &EfRoboInterface::mEnemyDmgSubRate)
			.addProperty("mPcHpWait", &EfRoboInterface::mPcHpWait)
			.addProperty("mEnemyHpWait", &EfRoboInterface::mEnemyHpWait)
			.addProperty("mPcTensionRate", &EfRoboInterface::mPcTensionRate)
			.addProperty("mPcTensionRateTarget", &EfRoboInterface::mPcTensionRateTarget)
			.addProperty("mEnemyTensionRate", &EfRoboInterface::mEnemyTensionRate)
			.addProperty("mEnemyTensionRateTarget", &EfRoboInterface::mEnemyTensionRateTarget)
			.addProperty("mTensionSlide", &EfRoboInterface::mTensionSlide)
			.addProperty("mbPcMaxVisible", &EfRoboInterface::mbPcMaxVisible)
			.addProperty("mbEnemyMaxVisible", &EfRoboInterface::mbEnemyMaxVisible)
			.addProperty("mDmgAnimeCnt", &EfRoboInterface::mDmgAnimeCnt)
			.addProperty("mbFinish", &EfRoboInterface::mbFinish)
			.addProperty("mBlurAlpha", &EfRoboInterface::mBlurAlpha)
			.addProperty("mBlurValid", &EfRoboInterface::mBlurValid)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfRoboInterface::field_50) == 24, "expected field_50 to be size 24");
static_assert(sizeof(EfRoboInterface::mpBlur) == 4, "expected mpBlur to be size 4");
static_assert(sizeof(EfRoboInterface::mInputCZTex) == 40, "expected mInputCZTex to be size 40");
static_assert(sizeof(EfRoboInterface::mInputLineTex) == 40, "expected mInputLineTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcHpFrameTex) == 40, "expected mPcHpFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemyHpFrameTex) == 40, "expected mEnemyHpFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mHpTex) == 40, "expected mHpTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameDamageTex) == 40, "expected mFrameDamageTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameTrvDmgTex) == 40, "expected mFrameTrvDmgTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameSdpDmgTex) == 40, "expected mFrameSdpDmgTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameNoiseTex) == 40, "expected mFrameNoiseTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcTensionFrameTex) == 40, "expected mPcTensionFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemyTensionFrameTex) == 40, "expected mEnemyTensionFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mTensionTex) == 40, "expected mTensionTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcTensionMaxTex) == 40, "expected mPcTensionMaxTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemeyTensionMaxTex) == 40, "expected mEnemeyTensionMaxTex to be size 40");
static_assert(sizeof(EfRoboInterface::mLTigerTex) == 40, "expected mLTigerTex to be size 40");
static_assert(sizeof(EfRoboInterface::mLBackTex) == 40, "expected mLBackTex to be size 40");
static_assert(sizeof(EfRoboInterface::mRTigerTex) == 40, "expected mRTigerTex to be size 40");
static_assert(sizeof(EfRoboInterface::mRBackTex) == 40, "expected mRBackTex to be size 40");
static_assert(sizeof(EfRoboInterface::mInputCState) == 4, "expected mInputCState to be size 4");
static_assert(sizeof(EfRoboInterface::mInputCSlide) == 4, "expected mInputCSlide to be size 4");
static_assert(sizeof(EfRoboInterface::mbInputCVisble) == 1, "expected mbInputCVisble to be size 1");
static_assert(sizeof(EfRoboInterface::mInputCAlpha) == 4, "expected mInputCAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mBlackState) == 4, "expected mBlackState to be size 4");
static_assert(sizeof(EfRoboInterface::mBlackAlpha) == 4, "expected mBlackAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashState) == 4, "expected mPcFlashState to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashAnimeCnt) == 4, "expected mPcFlashAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashCnt) == 4, "expected mPcFlashCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashAlpha) == 4, "expected mPcFlashAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashState) == 4, "expected mEnemyFlashState to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashAnimeCnt) == 4, "expected mEnemyFlashAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashCnt) == 4, "expected mEnemyFlashCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashAlpha) == 4, "expected mEnemyFlashAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpRate) == 4, "expected mPcHpRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpRateTarget) == 4, "expected mPcHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mBefPcHpRateTarget) == 4, "expected mBefPcHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mPcDmgSubRate) == 4, "expected mPcDmgSubRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpRate) == 4, "expected mEnemyHpRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpRateTarget) == 4, "expected mEnemyHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mBefEnemyHpRateTarget) == 4, "expected mBefEnemyHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyDmgSubRate) == 4, "expected mEnemyDmgSubRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpWait) == 4, "expected mPcHpWait to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpWait) == 4, "expected mEnemyHpWait to be size 4");
static_assert(sizeof(EfRoboInterface::mPcTensionRate) == 4, "expected mPcTensionRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcTensionRateTarget) == 4, "expected mPcTensionRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyTensionRate) == 4, "expected mEnemyTensionRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyTensionRateTarget) == 4, "expected mEnemyTensionRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mTensionSlide) == 4, "expected mTensionSlide to be size 4");
static_assert(sizeof(EfRoboInterface::mbPcMaxVisible) == 1, "expected mbPcMaxVisible to be size 1");
static_assert(sizeof(EfRoboInterface::mbEnemyMaxVisible) == 1, "expected mbEnemyMaxVisible to be size 1");
static_assert(sizeof(EfRoboInterface::mDmgAnimeCnt) == 4, "expected mDmgAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mbFinish) == 1, "expected mbFinish to be size 1");
static_assert(sizeof(EfRoboInterface::mBlurAlpha) == 4, "expected mBlurAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mBlurValid) == 1, "expected mBlurValid to be size 1");
static_assert(sizeof(EfRoboInterface) == 964, "expected class EfRoboInterface to be size 964");

// [Structure] class EffectSpeedBlur
class EffectSpeedBlur : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Unidentified data segment, offset 0x51>
private:
	char _UnidentifiedData2[3];

public:
	// <float m_BlurValue, offset 0x54>
	float m_BlurValue;

	// <float m_Scale, offset 0x58>
	float m_Scale;

	// <int32_t m_RepNum, offset 0x5c>
	int32_t m_RepNum;

	// <uint8_t m_Wait, offset 0x60>
	uint8_t m_Wait;

	// <Unidentified data segment, offset 0x61>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class EffectSpeedBlur(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSpeedBlur, HrTask>("EffectSpeedBlur")
			.addFunction("__tostring", &EffectSpeedBlur::ToString)
			.addFunction("GetPtrAddr", &EffectSpeedBlur::GetPtrAddr)
			.addProperty("m_Flag", &EffectSpeedBlur::m_Flag)
			.addProperty("m_BlurValue", &EffectSpeedBlur::m_BlurValue)
			.addProperty("m_Scale", &EffectSpeedBlur::m_Scale)
			.addProperty("m_RepNum", &EffectSpeedBlur::m_RepNum)
			.addProperty("m_Wait", &EffectSpeedBlur::m_Wait)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSpeedBlur::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectSpeedBlur::m_BlurValue) == 4, "expected m_BlurValue to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_RepNum) == 4, "expected m_RepNum to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_Wait) == 1, "expected m_Wait to be size 1");
static_assert(sizeof(EffectSpeedBlur) == 100, "expected class EffectSpeedBlur to be size 100");

// [Structure] class CmDeathState
class CmDeathState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <uint8_t mbDeadScriptCall, offset 0x4>
	uint8_t mbDeadScriptCall;

	// <Unidentified data segment, offset 0x5>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class CmDeathState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmDeathState>("CmDeathState")
			.addFunction("__tostring", &CmDeathState::ToString)
			.addFunction("GetPtrAddr", &CmDeathState::GetPtrAddr)
			.addProperty("mbDeadScriptCall", &CmDeathState::mbDeadScriptCall)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmDeathState::mbDeadScriptCall) == 1, "expected mbDeadScriptCall to be size 1");
static_assert(sizeof(CmDeathState) == 8, "expected class CmDeathState to be size 8");

// [Structure] class SDPDeathState
class SDPDeathState : public CmDeathState
{
public:
	/// Struct member variables

	// <class CmDeathState field_0, offset 0x0>
	// class CmDeathState Super;

	std::string ToString() const { return "class SDPDeathState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<SDPDeathState, CmDeathState>("SDPDeathState")
			.addFunction("__tostring", &SDPDeathState::ToString)
			.addFunction("GetPtrAddr", &SDPDeathState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPDeathState) == 8, "expected class SDPDeathState to be size 8");

// [Structure] class SDPComboState
class SDPComboState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	std::string ToString() const { return "class SDPComboState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPComboState>("SDPComboState")
			.addFunction("__tostring", &SDPComboState::ToString)
			.addFunction("GetPtrAddr", &SDPComboState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPComboState) == 4, "expected class SDPComboState to be size 4");

// [Structure] class CmDamageState
class CmDamageState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <int32_t mDownTick, offset 0x4>
	int32_t mDownTick;

	std::string ToString() const { return "class CmDamageState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmDamageState>("CmDamageState")
			.addFunction("__tostring", &CmDamageState::ToString)
			.addFunction("GetPtrAddr", &CmDamageState::GetPtrAddr)
			.addProperty("mDownTick", &CmDamageState::mDownTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmDamageState::mDownTick) == 4, "expected mDownTick to be size 4");
static_assert(sizeof(CmDamageState) == 8, "expected class CmDamageState to be size 8");

// [Structure] class SDPDamageState
class SDPDamageState : public CmDamageState
{
public:
	/// Struct member variables

	// <class CmDamageState field_0, offset 0x0>
	// class CmDamageState Super;

	std::string ToString() const { return "class SDPDamageState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<SDPDamageState, CmDamageState>("SDPDamageState")
			.addFunction("__tostring", &SDPDamageState::ToString)
			.addFunction("GetPtrAddr", &SDPDamageState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPDamageState) == 8, "expected class SDPDamageState to be size 8");

// [Structure] class SDPBeamState
class SDPBeamState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	std::string ToString() const { return "class SDPBeamState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPBeamState>("SDPBeamState")
			.addFunction("__tostring", &SDPBeamState::ToString)
			.addFunction("GetPtrAddr", &SDPBeamState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPBeamState) == 4, "expected class SDPBeamState to be size 4");

// [Structure] class CmIdleState
class CmIdleState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <int32_t mContinuTick, offset 0x4>
	int32_t mContinuTick;

	std::string ToString() const { return "class CmIdleState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmIdleState>("CmIdleState")
			.addFunction("__tostring", &CmIdleState::ToString)
			.addFunction("GetPtrAddr", &CmIdleState::GetPtrAddr)
			.addProperty("mContinuTick", &CmIdleState::mContinuTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmIdleState::mContinuTick) == 4, "expected mContinuTick to be size 4");
static_assert(sizeof(CmIdleState) == 8, "expected class CmIdleState to be size 8");

// [Structure] class SDPIdleState
class SDPIdleState : public CmIdleState
{
public:
	/// Struct member variables

	// <class CmIdleState field_0, offset 0x0>
	// class CmIdleState Super;

	std::string ToString() const { return "class SDPIdleState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<SDPIdleState, CmIdleState>("SDPIdleState")
			.addFunction("__tostring", &SDPIdleState::ToString)
			.addFunction("GetPtrAddr", &SDPIdleState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPIdleState) == 8, "expected class SDPIdleState to be size 8");

// [Structure] class bsBasic
class bsBasic : public mHRChara
{
public:
	// [Structure] struct bsBasic::PcInfo
	struct PcInfo
	{
	public:
		/// Struct member variables

		// <struct Vec Pos, offset 0x0>
		struct Vec Pos;

		// <struct Vec NavelPos, offset 0xc>
		struct Vec NavelPos;

		// <struct Vec Direc, offset 0x18>
		struct Vec Direc;

		// <float DirecY, offset 0x24>
		float DirecY;

		// <float Dist, offset 0x28>
		float Dist;

		// <float SubAngle, offset 0x2c>
		float SubAngle;

		// <float RotY, offset 0x30>
		float RotY;

		// <uint8_t bObstacle, offset 0x34>
		uint8_t bObstacle;

		// <Unidentified data segment, offset 0x35>
	private:
		char _UnidentifiedData[3];
	public:

		std::string ToString() const { return "struct PcInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::PcInfo>("bsBasic_PcInfo")
				.addFunction("__tostring", &bsBasic::PcInfo::ToString)
				.addFunction("GetPtrAddr", &bsBasic::PcInfo::GetPtrAddr)
				.addProperty("Pos", &bsBasic::PcInfo::Pos)
				.addProperty("NavelPos", &bsBasic::PcInfo::NavelPos)
				.addProperty("Direc", &bsBasic::PcInfo::Direc)
				.addProperty("DirecY", &bsBasic::PcInfo::DirecY)
				.addProperty("Dist", &bsBasic::PcInfo::Dist)
				.addProperty("SubAngle", &bsBasic::PcInfo::SubAngle)
				.addProperty("RotY", &bsBasic::PcInfo::RotY)
				.addProperty("bObstacle", &bsBasic::PcInfo::bObstacle)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::PcInfo::Pos) == 12, "expected Pos to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::NavelPos) == 12, "expected NavelPos to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::Direc) == 12, "expected Direc to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::DirecY) == 4, "expected DirecY to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::Dist) == 4, "expected Dist to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::SubAngle) == 4, "expected SubAngle to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::RotY) == 4, "expected RotY to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::bObstacle) == 1, "expected bObstacle to be size 1");
	static_assert(sizeof(bsBasic::PcInfo) == 56, "expected struct bsBasic::PcInfo to be size 56");

	// [Structure] struct bsBasic::SurroundInfo
	struct SurroundInfo
	{
	public:
		/// Struct member variables

		// <float SearchDist, offset 0x0>
		float SearchDist;

		// <float FrontDist, offset 0x4>
		float FrontDist;

		// <float BackDist, offset 0x8>
		float BackDist;

		// <float RightDist, offset 0xc>
		float RightDist;

		// <float LeftDist, offset 0x10>
		float LeftDist;

		// <struct Vec FrontPos, offset 0x14>
		struct Vec FrontPos;

		// <struct Vec BackPos, offset 0x20>
		struct Vec BackPos;

		// <struct Vec RightPos, offset 0x2c>
		struct Vec RightPos;

		// <struct Vec LeftPos, offset 0x38>
		struct Vec LeftPos;

		// <float StageFrontDist, offset 0x44>
		float StageFrontDist;

		// <float StageBackDist, offset 0x48>
		float StageBackDist;

		// <float StageRightDist, offset 0x4c>
		float StageRightDist;

		// <float StageLeftDist, offset 0x50>
		float StageLeftDist;

		// <struct Vec StageFrontPos, offset 0x54>
		struct Vec StageFrontPos;

		// <struct Vec StageBackPos, offset 0x60>
		struct Vec StageBackPos;

		// <struct Vec StageRightPos, offset 0x6c>
		struct Vec StageRightPos;

		// <struct Vec StageLeftPos, offset 0x78>
		struct Vec StageLeftPos;

		// <float CharaFrontDist, offset 0x84>
		float CharaFrontDist;

		// <float CharaBackDist, offset 0x88>
		float CharaBackDist;

		// <float CharaRightDist, offset 0x8c>
		float CharaRightDist;

		// <float CharaLeftDist, offset 0x90>
		float CharaLeftDist;

		// <struct Vec CharaFrontPos, offset 0x94>
		struct Vec CharaFrontPos;

		// <struct Vec CharaBackPos, offset 0xa0>
		struct Vec CharaBackPos;

		// <struct Vec CharaRightPos, offset 0xac>
		struct Vec CharaRightPos;

		// <struct Vec CharaLeftPos, offset 0xb8>
		struct Vec CharaLeftPos;

		// <float TargetDist, offset 0xc4>
		float TargetDist;

		std::string ToString() const { return "struct SurroundInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::SurroundInfo>("bsBasic_SurroundInfo")
				.addFunction("__tostring", &bsBasic::SurroundInfo::ToString)
				.addFunction("GetPtrAddr", &bsBasic::SurroundInfo::GetPtrAddr)
				.addProperty("SearchDist", &bsBasic::SurroundInfo::SearchDist)
				.addProperty("FrontDist", &bsBasic::SurroundInfo::FrontDist)
				.addProperty("BackDist", &bsBasic::SurroundInfo::BackDist)
				.addProperty("RightDist", &bsBasic::SurroundInfo::RightDist)
				.addProperty("LeftDist", &bsBasic::SurroundInfo::LeftDist)
				.addProperty("FrontPos", &bsBasic::SurroundInfo::FrontPos)
				.addProperty("BackPos", &bsBasic::SurroundInfo::BackPos)
				.addProperty("RightPos", &bsBasic::SurroundInfo::RightPos)
				.addProperty("LeftPos", &bsBasic::SurroundInfo::LeftPos)
				.addProperty("StageFrontDist", &bsBasic::SurroundInfo::StageFrontDist)
				.addProperty("StageBackDist", &bsBasic::SurroundInfo::StageBackDist)
				.addProperty("StageRightDist", &bsBasic::SurroundInfo::StageRightDist)
				.addProperty("StageLeftDist", &bsBasic::SurroundInfo::StageLeftDist)
				.addProperty("StageFrontPos", &bsBasic::SurroundInfo::StageFrontPos)
				.addProperty("StageBackPos", &bsBasic::SurroundInfo::StageBackPos)
				.addProperty("StageRightPos", &bsBasic::SurroundInfo::StageRightPos)
				.addProperty("StageLeftPos", &bsBasic::SurroundInfo::StageLeftPos)
				.addProperty("CharaFrontDist", &bsBasic::SurroundInfo::CharaFrontDist)
				.addProperty("CharaBackDist", &bsBasic::SurroundInfo::CharaBackDist)
				.addProperty("CharaRightDist", &bsBasic::SurroundInfo::CharaRightDist)
				.addProperty("CharaLeftDist", &bsBasic::SurroundInfo::CharaLeftDist)
				.addProperty("CharaFrontPos", &bsBasic::SurroundInfo::CharaFrontPos)
				.addProperty("CharaBackPos", &bsBasic::SurroundInfo::CharaBackPos)
				.addProperty("CharaRightPos", &bsBasic::SurroundInfo::CharaRightPos)
				.addProperty("CharaLeftPos", &bsBasic::SurroundInfo::CharaLeftPos)
				.addProperty("TargetDist", &bsBasic::SurroundInfo::TargetDist)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::SurroundInfo::SearchDist) == 4, "expected SearchDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::FrontDist) == 4, "expected FrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::BackDist) == 4, "expected BackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::RightDist) == 4, "expected RightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::LeftDist) == 4, "expected LeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::FrontPos) == 12, "expected FrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::BackPos) == 12, "expected BackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::RightPos) == 12, "expected RightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::LeftPos) == 12, "expected LeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageFrontDist) == 4, "expected StageFrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageBackDist) == 4, "expected StageBackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageRightDist) == 4, "expected StageRightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageLeftDist) == 4, "expected StageLeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageFrontPos) == 12, "expected StageFrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageBackPos) == 12, "expected StageBackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageRightPos) == 12, "expected StageRightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageLeftPos) == 12, "expected StageLeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaFrontDist) == 4, "expected CharaFrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaBackDist) == 4, "expected CharaBackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaRightDist) == 4, "expected CharaRightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaLeftDist) == 4, "expected CharaLeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaFrontPos) == 12, "expected CharaFrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaBackPos) == 12, "expected CharaBackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaRightPos) == 12, "expected CharaRightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaLeftPos) == 12, "expected CharaLeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::TargetDist) == 4, "expected TargetDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo) == 200, "expected struct bsBasic::SurroundInfo to be size 200");

	// [Structure] struct bsBasic::DistSense
	struct DistSense
	{
	public:
		/// Struct member variables

		// <float Base, offset 0x0>
		float Base;

		// <float Small, offset 0x4>
		float Small;

		// <float Middle, offset 0x8>
		float Middle;

		// <float Long, offset 0xc>
		float Long;

		// <float Allowance, offset 0x10>
		float Allowance;

		std::string ToString() const { return "struct DistSense(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::DistSense>("bsBasic_DistSense")
				.addFunction("__tostring", &bsBasic::DistSense::ToString)
				.addFunction("GetPtrAddr", &bsBasic::DistSense::GetPtrAddr)
				.addProperty("Base", &bsBasic::DistSense::Base)
				.addProperty("Small", &bsBasic::DistSense::Small)
				.addProperty("Middle", &bsBasic::DistSense::Middle)
				.addProperty("Long", &bsBasic::DistSense::Long)
				.addProperty("Allowance", &bsBasic::DistSense::Allowance)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::DistSense::Base) == 4, "expected Base to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Small) == 4, "expected Small to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Middle) == 4, "expected Middle to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Long) == 4, "expected Long to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Allowance) == 4, "expected Allowance to be size 4");
	static_assert(sizeof(bsBasic::DistSense) == 20, "expected struct bsBasic::DistSense to be size 20");

	// [Structure] struct bsBasic::TickCnt
	struct TickCnt
	{
	public:
		/// Struct member variables

		// <int32_t Motion, offset 0x0>
		int32_t Motion;

		// <int32_t AtkWait, offset 0x4>
		int32_t AtkWait;

		// <int32_t Loop, offset 0x8>
		int32_t Loop;

		// <int32_t State, offset 0xc>
		int32_t State;

		// <int32_t DmgWait, offset 0x10>
		int32_t DmgWait;

		// <int32_t DmgPlayAccept, offset 0x14>
		int32_t DmgPlayAccept;

		// <int32_t PreAvoid, offset 0x18>
		int32_t PreAvoid;

		// <int32_t Piyori, offset 0x1c>
		int32_t Piyori;

		std::string ToString() const { return "struct TickCnt(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::TickCnt>("bsBasic_TickCnt")
				.addFunction("__tostring", &bsBasic::TickCnt::ToString)
				.addFunction("GetPtrAddr", &bsBasic::TickCnt::GetPtrAddr)
				.addProperty("Motion", &bsBasic::TickCnt::Motion)
				.addProperty("AtkWait", &bsBasic::TickCnt::AtkWait)
				.addProperty("Loop", &bsBasic::TickCnt::Loop)
				.addProperty("State", &bsBasic::TickCnt::State)
				.addProperty("DmgWait", &bsBasic::TickCnt::DmgWait)
				.addProperty("DmgPlayAccept", &bsBasic::TickCnt::DmgPlayAccept)
				.addProperty("PreAvoid", &bsBasic::TickCnt::PreAvoid)
				.addProperty("Piyori", &bsBasic::TickCnt::Piyori)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::TickCnt::Motion) == 4, "expected Motion to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::AtkWait) == 4, "expected AtkWait to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::Loop) == 4, "expected Loop to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::State) == 4, "expected State to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::DmgWait) == 4, "expected DmgWait to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::DmgPlayAccept) == 4, "expected DmgPlayAccept to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::PreAvoid) == 4, "expected PreAvoid to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::Piyori) == 4, "expected Piyori to be size 4");
	static_assert(sizeof(bsBasic::TickCnt) == 32, "expected struct bsBasic::TickCnt to be size 32");

	// [Structure] struct bsBasic::BattleParam
	struct BattleParam
	{
	public:
		/// Struct member variables

		// <struct Vec TargetPos, offset 0x0>
		struct Vec TargetPos;

		// <uint32_t AtkPercent, offset 0xc>
		uint32_t AtkPercent;

		// <uint32_t GrdPercent, offset 0x10>
		uint32_t GrdPercent;

		// <int32_t TsubaTick, offset 0x14>
		int32_t TsubaTick;

		// <uint8_t TsubaRotNum, offset 0x18>
		uint8_t TsubaRotNum;

		// <Unidentified data segment, offset 0x19>
	private:
		char _UnidentifiedData5[3];

	public:
		// <int32_t HpPhase, offset 0x1c>
		int32_t HpPhase;

		std::string ToString() const { return "struct BattleParam(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::BattleParam>("bsBasic_BattleParam")
				.addFunction("__tostring", &bsBasic::BattleParam::ToString)
				.addFunction("GetPtrAddr", &bsBasic::BattleParam::GetPtrAddr)
				.addProperty("TargetPos", &bsBasic::BattleParam::TargetPos)
				.addProperty("AtkPercent", &bsBasic::BattleParam::AtkPercent)
				.addProperty("GrdPercent", &bsBasic::BattleParam::GrdPercent)
				.addProperty("TsubaTick", &bsBasic::BattleParam::TsubaTick)
				.addProperty("TsubaRotNum", &bsBasic::BattleParam::TsubaRotNum)
				.addProperty("HpPhase", &bsBasic::BattleParam::HpPhase)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::BattleParam::TargetPos) == 12, "expected TargetPos to be size 12");
	static_assert(sizeof(bsBasic::BattleParam::AtkPercent) == 4, "expected AtkPercent to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::GrdPercent) == 4, "expected GrdPercent to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::TsubaTick) == 4, "expected TsubaTick to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::TsubaRotNum) == 1, "expected TsubaRotNum to be size 1");
	static_assert(sizeof(bsBasic::BattleParam::HpPhase) == 4, "expected HpPhase to be size 4");
	static_assert(sizeof(bsBasic::BattleParam) == 32, "expected struct bsBasic::BattleParam to be size 32");

	// [Structure] struct bsBasic::DmgInfo
	struct DmgInfo
	{
	public:
		/// Struct member variables

		// <uint32_t Kind, offset 0x0>
		uint32_t Kind;

		// <uint32_t DirecKind, offset 0x4>
		uint32_t DirecKind;

		// <float Direc, offset 0x8>
		float Direc;

		// <uint32_t FinishHitNum, offset 0xc>
		uint32_t FinishHitNum;

		// <uint32_t DownFinishHitMax, offset 0x10>
		uint32_t DownFinishHitMax;

		// <float AccumuAmount, offset 0x14>
		float AccumuAmount;

		// <float AccumuMax, offset 0x18>
		float AccumuMax;

		// <float AccumuRecovery, offset 0x1c>
		float AccumuRecovery;

		// <float GroggyAmount, offset 0x20>
		float GroggyAmount;

		// <float GroggyMax, offset 0x24>
		float GroggyMax;

		// <float GroggyRecovery, offset 0x28>
		float GroggyRecovery;

		// <int32_t PiyoriTick, offset 0x2c>
		int32_t PiyoriTick;

		// <float DamagePower, offset 0x30>
		float DamagePower;

		std::string ToString() const { return "struct DmgInfo(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::DmgInfo>("bsBasic_DmgInfo")
				.addFunction("__tostring", &bsBasic::DmgInfo::ToString)
				.addFunction("GetPtrAddr", &bsBasic::DmgInfo::GetPtrAddr)
				.addProperty("Kind", &bsBasic::DmgInfo::Kind)
				.addProperty("DirecKind", &bsBasic::DmgInfo::DirecKind)
				.addProperty("Direc", &bsBasic::DmgInfo::Direc)
				.addProperty("FinishHitNum", &bsBasic::DmgInfo::FinishHitNum)
				.addProperty("DownFinishHitMax", &bsBasic::DmgInfo::DownFinishHitMax)
				.addProperty("AccumuAmount", &bsBasic::DmgInfo::AccumuAmount)
				.addProperty("AccumuMax", &bsBasic::DmgInfo::AccumuMax)
				.addProperty("AccumuRecovery", &bsBasic::DmgInfo::AccumuRecovery)
				.addProperty("GroggyAmount", &bsBasic::DmgInfo::GroggyAmount)
				.addProperty("GroggyMax", &bsBasic::DmgInfo::GroggyMax)
				.addProperty("GroggyRecovery", &bsBasic::DmgInfo::GroggyRecovery)
				.addProperty("PiyoriTick", &bsBasic::DmgInfo::PiyoriTick)
				.addProperty("DamagePower", &bsBasic::DmgInfo::DamagePower)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::DmgInfo::Kind) == 4, "expected Kind to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DirecKind) == 4, "expected DirecKind to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::Direc) == 4, "expected Direc to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::FinishHitNum) == 4, "expected FinishHitNum to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DownFinishHitMax) == 4, "expected DownFinishHitMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuAmount) == 4, "expected AccumuAmount to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuMax) == 4, "expected AccumuMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuRecovery) == 4, "expected AccumuRecovery to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyAmount) == 4, "expected GroggyAmount to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyMax) == 4, "expected GroggyMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyRecovery) == 4, "expected GroggyRecovery to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::PiyoriTick) == 4, "expected PiyoriTick to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DamagePower) == 4, "expected DamagePower to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo) == 52, "expected struct bsBasic::DmgInfo to be size 52");

	// [Function] void __convention("thiscall") bsBasic::SetDamageIK(class bsBasic* const this, class mHRChara* arg2, uint8_t arg3) [?SetDamageIK@bsBasic@@IAEXPAVmHRChara@@_N@Z]
	void SetDamageIK(class mHRChara* arg2, uint8_t arg3)
	{
		typedef void(__thiscall* _Func)(class bsBasic* const thisPtr, class mHRChara* arg2, uint8_t arg3);
		_Func mFunc = (_Func)(GameModule + 0x573a80);
		return mFunc(this, arg2, arg3);
	}
	// [Function] uint8_t __convention("thiscall") bsBasic::mSetDamage(class bsBasic* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsBasic@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class bsBasic* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x575360);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") bsBasic::IsAtkObj(class bsBasic* const this, class mHRChara* arg2) [?IsAtkObj@bsBasic@@MAE_NPAVmHRChara@@@Z]
	uint8_t IsAtkObj(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class bsBasic* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x5786a0);
		return mFunc(this, arg2);
	}
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <float mRotSpeed, offset 0x580>
	float mRotSpeed;

	// <struct bsBasic::PcInfo mPcInfo, offset 0x584>
	struct bsBasic::PcInfo mPcInfo;

	// <struct bsBasic::SurroundInfo mSurroundInfo, offset 0x5bc>
	struct bsBasic::SurroundInfo mSurroundInfo;

	// <struct bsBasic::DistSense mDistSense, offset 0x684>
	struct bsBasic::DistSense mDistSense;

	// <struct bsBasic::TickCnt mTickCnt, offset 0x698>
	struct bsBasic::TickCnt mTickCnt;

	// <struct bsBasic::BattleParam mBattleParam, offset 0x6b8>
	struct bsBasic::BattleParam mBattleParam;

	// <struct bsBasic::DmgInfo mDmgInfo, offset 0x6d8>
	struct bsBasic::DmgInfo mDmgInfo;

	// <class KrStateMachine<bsBasic,32> mStateMachine, offset 0x70c>
	class KrStateMachine<bsBasic,32> mStateMachine;

	// <class PathPlanner mPathPlan, offset 0x79c>
	class PathPlanner mPathPlan;

	// <int32_t mVoiceID, offset 0xc60>
	int32_t mVoiceID;

	// <uint8_t mbDownVoice, offset 0xc64>
	uint8_t mbDownVoice;

	// <Unidentified data segment, offset 0xc65>
private:
	char _UnidentifiedData12[3];

public:
	// <int32_t mMiniDemoNum, offset 0xc68>
	int32_t mMiniDemoNum;

	// <class TGmf* mpLowModelGmf, offset 0xc6c>
	class TGmf* mpLowModelGmf;

	// <class EffectModelBeam* m_pEffectModelBeam, offset 0xc70>
	class EffectModelBeam* m_pEffectModelBeam;

	// <class FkObstacleSensor* m_pObsSens, offset 0xc74>
	class FkObstacleSensor* m_pObsSens;

	// <uint8_t m_boUseObsSens, offset 0xc78>
	uint8_t m_boUseObsSens;

	// <uint8_t m_boCalledNoGuardEfOnce, offset 0xc79>
	uint8_t m_boCalledNoGuardEfOnce;

	// <Unidentified data segment, offset 0xc7a>
private:
	char _UnidentifiedData18[2];

public:
	// <float m_fCheckSrroundHeight, offset 0xc7c>
	float m_fCheckSrroundHeight;

	// <uint32_t mFlag, offset 0xc80>
	uint32_t mFlag;

	std::string ToString() const { return "class bsBasic(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<bsBasic, mHRChara>("bsBasic")
			.addFunction("__tostring", &bsBasic::ToString)
			.addFunction("GetPtrAddr", &bsBasic::GetPtrAddr)
			.addProperty("mRotSpeed", &bsBasic::mRotSpeed)
			.addProperty("mPcInfo", &bsBasic::mPcInfo)
			.addProperty("mSurroundInfo", &bsBasic::mSurroundInfo)
			.addProperty("mDistSense", &bsBasic::mDistSense)
			.addProperty("mTickCnt", &bsBasic::mTickCnt)
			.addProperty("mBattleParam", &bsBasic::mBattleParam)
			.addProperty("mDmgInfo", &bsBasic::mDmgInfo)
			.addProperty("mStateMachine", &bsBasic::mStateMachine)
			.addProperty("mPathPlan", &bsBasic::mPathPlan)
			.addProperty("mVoiceID", &bsBasic::mVoiceID)
			.addProperty("mbDownVoice", &bsBasic::mbDownVoice)
			.addProperty("mMiniDemoNum", &bsBasic::mMiniDemoNum)
			.addProperty("mpLowModelGmf", &bsBasic::mpLowModelGmf)
			.addProperty("m_pEffectModelBeam", &bsBasic::m_pEffectModelBeam)
			.addProperty("m_pObsSens", &bsBasic::m_pObsSens)
			.addProperty("m_boUseObsSens", &bsBasic::m_boUseObsSens)
			.addProperty("m_boCalledNoGuardEfOnce", &bsBasic::m_boCalledNoGuardEfOnce)
			.addProperty("m_fCheckSrroundHeight", &bsBasic::m_fCheckSrroundHeight)
			.addProperty("mFlag", &bsBasic::mFlag)
			.addFunction("SetDamageIK", &bsBasic::SetDamageIK)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &bsBasic::mSetDamage)
			.addFunction("IsAtkObj", &bsBasic::IsAtkObj)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsBasic::mRotSpeed) == 4, "expected mRotSpeed to be size 4");
static_assert(sizeof(bsBasic::mPcInfo) == 56, "expected mPcInfo to be size 56");
static_assert(sizeof(bsBasic::mSurroundInfo) == 200, "expected mSurroundInfo to be size 200");
static_assert(sizeof(bsBasic::mDistSense) == 20, "expected mDistSense to be size 20");
static_assert(sizeof(bsBasic::mTickCnt) == 32, "expected mTickCnt to be size 32");
static_assert(sizeof(bsBasic::mBattleParam) == 32, "expected mBattleParam to be size 32");
static_assert(sizeof(bsBasic::mDmgInfo) == 52, "expected mDmgInfo to be size 52");
static_assert(sizeof(bsBasic::mStateMachine) == 144, "expected mStateMachine to be size 144");
static_assert(sizeof(bsBasic::mPathPlan) == 1220, "expected mPathPlan to be size 1220");
static_assert(sizeof(bsBasic::mVoiceID) == 4, "expected mVoiceID to be size 4");
static_assert(sizeof(bsBasic::mbDownVoice) == 1, "expected mbDownVoice to be size 1");
static_assert(sizeof(bsBasic::mMiniDemoNum) == 4, "expected mMiniDemoNum to be size 4");
static_assert(sizeof(bsBasic::mpLowModelGmf) == 4, "expected mpLowModelGmf to be size 4");
static_assert(sizeof(bsBasic::m_pEffectModelBeam) == 4, "expected m_pEffectModelBeam to be size 4");
static_assert(sizeof(bsBasic::m_pObsSens) == 4, "expected m_pObsSens to be size 4");
static_assert(sizeof(bsBasic::m_boUseObsSens) == 1, "expected m_boUseObsSens to be size 1");
static_assert(sizeof(bsBasic::m_boCalledNoGuardEfOnce) == 1, "expected m_boCalledNoGuardEfOnce to be size 1");
static_assert(sizeof(bsBasic::m_fCheckSrroundHeight) == 4, "expected m_fCheckSrroundHeight to be size 4");
static_assert(sizeof(bsBasic::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(bsBasic) == 3204, "expected class bsBasic to be size 3204");

// [Structure] class SDPMoveState
class SDPMoveState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	std::string ToString() const { return "class SDPMoveState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPMoveState>("SDPMoveState")
			.addFunction("__tostring", &SDPMoveState::ToString)
			.addFunction("GetPtrAddr", &SDPMoveState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPMoveState) == 4, "expected class SDPMoveState to be size 4");

// [Structure] class SDPGuardState
class SDPGuardState : public KrBaseState<bsBasic>
{
public:
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	std::string ToString() const { return "class SDPGuardState(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPGuardState>("SDPGuardState")
			.addFunction("__tostring", &SDPGuardState::ToString)
			.addFunction("GetPtrAddr", &SDPGuardState::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(SDPGuardState) == 4, "expected class SDPGuardState to be size 4");

// [Structure] class bsSDP
class bsSDP : public bsBasic
{
public:
	// [Function] uint8_t __convention("thiscall") bsSDP::IsAtkObj(class bsSDP* const this, class mHRChara* arg2) [?IsAtkObj@bsSDP@@EAE_NPAVmHRChara@@@Z]
	uint8_t IsAtkObj(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class bsSDP* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x54e160);
		return mFunc(this, arg2);
	}
	// [Function] uint8_t __convention("thiscall") bsSDP::mSetDamage(class bsSDP* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@bsSDP@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class bsSDP* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x54ebc0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <class bsBasic field_0, offset 0x0>
	// class bsBasic Super;

	// <class EfRoboInterface* mpIntarface, offset 0xc84>
	class EfRoboInterface* mpIntarface;

	// <class pcGLB* mpGLB, offset 0xc88>
	class pcGLB* mpGLB;

	// <class EfGeneralBeam* mpGeneralBeam, offset 0xc8c>
	class EfGeneralBeam* mpGeneralBeam;

	// <class TGmfNode* mpBeamLaunchNode, offset 0xc90>
	class TGmfNode* mpBeamLaunchNode;

	// <class TGmfNode* mpWristRNode, offset 0xc94>
	class TGmfNode* mpWristRNode;

	// <float mTension, offset 0xc98>
	float mTension;

	// <class SDPIdleState mIdleState, offset 0xc9c>
	class SDPIdleState mIdleState;

	// <class SDPComboState mComboState, offset 0xca4>
	class SDPComboState mComboState;

	// <class SDPBeamState mBeamState, offset 0xca8>
	class SDPBeamState mBeamState;

	// <class SDPGuardState mGuardState, offset 0xcac>
	class SDPGuardState mGuardState;

	// <class SDPDamageState mDamageState, offset 0xcb0>
	class SDPDamageState mDamageState;

	// <class SDPMoveState mMoveState, offset 0xcb8>
	class SDPMoveState mMoveState;

	// <class SDPDeathState mDeathState, offset 0xcbc>
	class SDPDeathState mDeathState;

	// <struct Vec mBefPos, offset 0xcc4>
	struct Vec mBefPos;

	// <uint8_t mbDemoWait, offset 0xcd0>
	uint8_t mbDemoWait;

	// <uint8_t mbDeadScriptCall, offset 0xcd1>
	uint8_t mbDeadScriptCall;

	// <uint8_t mbFirstSE, offset 0xcd2>
	uint8_t mbFirstSE;

	// <uint8_t mbGLBSE, offset 0xcd3>
	uint8_t mbGLBSE;

	std::string ToString() const { return "class bsSDP(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<bsSDP, bsBasic>("bsSDP")
			.addFunction("__tostring", &bsSDP::ToString)
			.addFunction("GetPtrAddr", &bsSDP::GetPtrAddr)
			.addProperty("mpIntarface", &bsSDP::mpIntarface)
			.addProperty("mpGLB", &bsSDP::mpGLB)
			.addProperty("mpGeneralBeam", &bsSDP::mpGeneralBeam)
			.addProperty("mpBeamLaunchNode", &bsSDP::mpBeamLaunchNode)
			.addProperty("mpWristRNode", &bsSDP::mpWristRNode)
			.addProperty("mTension", &bsSDP::mTension)
			.addProperty("mIdleState", &bsSDP::mIdleState)
			.addProperty("mComboState", &bsSDP::mComboState)
			.addProperty("mBeamState", &bsSDP::mBeamState)
			.addProperty("mGuardState", &bsSDP::mGuardState)
			.addProperty("mDamageState", &bsSDP::mDamageState)
			.addProperty("mMoveState", &bsSDP::mMoveState)
			.addProperty("mDeathState", &bsSDP::mDeathState)
			.addProperty("mBefPos", &bsSDP::mBefPos)
			.addProperty("mbDemoWait", &bsSDP::mbDemoWait)
			.addProperty("mbDeadScriptCall", &bsSDP::mbDeadScriptCall)
			.addProperty("mbFirstSE", &bsSDP::mbFirstSE)
			.addProperty("mbGLBSE", &bsSDP::mbGLBSE)
			.addFunction("IsAtkObj", &bsSDP::IsAtkObj)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &bsSDP::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsSDP::mpIntarface) == 4, "expected mpIntarface to be size 4");
static_assert(sizeof(bsSDP::mpGLB) == 4, "expected mpGLB to be size 4");
static_assert(sizeof(bsSDP::mpGeneralBeam) == 4, "expected mpGeneralBeam to be size 4");
static_assert(sizeof(bsSDP::mpBeamLaunchNode) == 4, "expected mpBeamLaunchNode to be size 4");
static_assert(sizeof(bsSDP::mpWristRNode) == 4, "expected mpWristRNode to be size 4");
static_assert(sizeof(bsSDP::mTension) == 4, "expected mTension to be size 4");
static_assert(sizeof(bsSDP::mIdleState) == 8, "expected mIdleState to be size 8");
static_assert(sizeof(bsSDP::mComboState) == 4, "expected mComboState to be size 4");
static_assert(sizeof(bsSDP::mBeamState) == 4, "expected mBeamState to be size 4");
static_assert(sizeof(bsSDP::mGuardState) == 4, "expected mGuardState to be size 4");
static_assert(sizeof(bsSDP::mDamageState) == 8, "expected mDamageState to be size 8");
static_assert(sizeof(bsSDP::mMoveState) == 4, "expected mMoveState to be size 4");
static_assert(sizeof(bsSDP::mDeathState) == 8, "expected mDeathState to be size 8");
static_assert(sizeof(bsSDP::mBefPos) == 12, "expected mBefPos to be size 12");
static_assert(sizeof(bsSDP::mbDemoWait) == 1, "expected mbDemoWait to be size 1");
static_assert(sizeof(bsSDP::mbDeadScriptCall) == 1, "expected mbDeadScriptCall to be size 1");
static_assert(sizeof(bsSDP::mbFirstSE) == 1, "expected mbFirstSE to be size 1");
static_assert(sizeof(bsSDP::mbGLBSE) == 1, "expected mbGLBSE to be size 1");
static_assert(sizeof(bsSDP) == 3284, "expected class bsSDP to be size 3284");

// [Structure] class FkTriangleList
class FkTriangleList
{
public:
	/// Struct member variables

	// <class FkStlVector<FkVtx> m_VtxArr, offset 0x0>
	class FkStlVector<FkVtx> m_VtxArr;

	std::string ToString() const { return "class FkTriangleList(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkTriangleList>("FkTriangleList")
			.addFunction("__tostring", &FkTriangleList::ToString)
			.addFunction("GetPtrAddr", &FkTriangleList::GetPtrAddr)
			.addProperty("m_VtxArr", &FkTriangleList::m_VtxArr)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkTriangleList::m_VtxArr) == 20, "expected m_VtxArr to be size 20");
static_assert(sizeof(FkTriangleList) == 20, "expected class FkTriangleList to be size 20");

// [Structure] class EffectModelBeam
class EffectModelBeam : public HrTask
{
public:
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class FkTriangleList m_TriangleList, offset 0x50>
	class FkTriangleList m_TriangleList;

	// <class TGmf* m_pGmf, offset 0x64>
	class TGmf* m_pGmf;

	// <class TGmfNode* m_pBeamNode, offset 0x68>
	class TGmfNode* m_pBeamNode;

	// <uint32_t m_Color, offset 0x6c>
	uint32_t m_Color;

	// <uint8_t m_boVisible, offset 0x70>
	uint8_t m_boVisible;

	// <Unidentified data segment, offset 0x71>
private:
	char _UnidentifiedData6[3];

public:
	// <float m_fScale, offset 0x74>
	float m_fScale;

	std::string ToString() const { return "class EffectModelBeam(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectModelBeam, HrTask>("EffectModelBeam")
			.addFunction("__tostring", &EffectModelBeam::ToString)
			.addFunction("GetPtrAddr", &EffectModelBeam::GetPtrAddr)
			.addProperty("m_TriangleList", &EffectModelBeam::m_TriangleList)
			.addProperty("m_pGmf", &EffectModelBeam::m_pGmf)
			.addProperty("m_pBeamNode", &EffectModelBeam::m_pBeamNode)
			.addProperty("m_Color", &EffectModelBeam::m_Color)
			.addProperty("m_boVisible", &EffectModelBeam::m_boVisible)
			.addProperty("m_fScale", &EffectModelBeam::m_fScale)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectModelBeam::m_TriangleList) == 20, "expected m_TriangleList to be size 20");
static_assert(sizeof(EffectModelBeam::m_pGmf) == 4, "expected m_pGmf to be size 4");
static_assert(sizeof(EffectModelBeam::m_pBeamNode) == 4, "expected m_pBeamNode to be size 4");
static_assert(sizeof(EffectModelBeam::m_Color) == 4, "expected m_Color to be size 4");
static_assert(sizeof(EffectModelBeam::m_boVisible) == 1, "expected m_boVisible to be size 1");
static_assert(sizeof(EffectModelBeam::m_fScale) == 4, "expected m_fScale to be size 4");
static_assert(sizeof(EffectModelBeam) == 120, "expected class EffectModelBeam to be size 120");

// [Structure] struct FkVtx
struct FkVtx
{
public:
	/// Struct member variables

	// <struct Vec Pos, offset 0x0>
	struct Vec Pos;

	// <struct Vec Norm, offset 0xc>
	struct Vec Norm;

	std::string ToString() const { return "struct FkVtx(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkVtx>("FkVtx")
			.addFunction("__tostring", &FkVtx::ToString)
			.addFunction("GetPtrAddr", &FkVtx::GetPtrAddr)
			.addProperty("Pos", &FkVtx::Pos)
			.addProperty("Norm", &FkVtx::Norm)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkVtx::Pos) == 12, "expected Pos to be size 12");
static_assert(sizeof(FkVtx::Norm) == 12, "expected Norm to be size 12");
static_assert(sizeof(FkVtx) == 24, "expected struct FkVtx to be size 24");

// [Structure] class EfGeneralBeam
class EfGeneralBeam
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[54968];
public:

	std::string ToString() const { return "class EfGeneralBeam(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfGeneralBeam>("EfGeneralBeam")
			.addFunction("__tostring", &EfGeneralBeam::ToString)
			.addFunction("GetPtrAddr", &EfGeneralBeam::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfGeneralBeam) == 54968, "expected class EfGeneralBeam to be size 54968");

// [Structure] class PJOBJ0029
class PJOBJ0029 : public commonObj
{
public:
	// [Function] uint8_t __convention("thiscall") PJOBJ0029::mSetDamage(class PJOBJ0029* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11) [?mSetDamage@PJOBJ0029@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)
	{
		typedef uint8_t(__thiscall* _Func)(class PJOBJ0029* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11);
		_Func mFunc = (_Func)(GameModule + 0x5541f0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class TGmfNode* mpTopNode, offset 0x64c>
	class TGmfNode* mpTopNode;

	// <uint8_t mbBreak, offset 0x650>
	uint8_t mbBreak;

	// <Unidentified data segment, offset 0x651>
private:
	char _UnidentifiedData3[3];

public:
	// <float mRadius, offset 0x654>
	float mRadius;

	std::string ToString() const { return "class PJOBJ0029(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0029, commonObj>("PJOBJ0029")
			.addFunction("__tostring", &PJOBJ0029::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0029::GetPtrAddr)
			.addProperty("mpTopNode", &PJOBJ0029::mpTopNode)
			.addProperty("mbBreak", &PJOBJ0029::mbBreak)
			.addProperty("mRadius", &PJOBJ0029::mRadius)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJOBJ0029::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0029::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(PJOBJ0029::mbBreak) == 1, "expected mbBreak to be size 1");
static_assert(sizeof(PJOBJ0029::mRadius) == 4, "expected mRadius to be size 4");
static_assert(sizeof(PJOBJ0029) == 1624, "expected class PJOBJ0029 to be size 1624");

// [Structure] class PJOBJ0033
class PJOBJ0033 : public commonObj
{
public:
	// [Function] uint8_t __convention("thiscall") PJOBJ0033::mSetDamage(class PJOBJ0033* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11) [?mSetDamage@PJOBJ0033@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)
	{
		typedef uint8_t(__thiscall* _Func)(class PJOBJ0033* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11);
		_Func mFunc = (_Func)(GameModule + 0x554750);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <int32_t m_BreakCnt, offset 0x64c>
	int32_t m_BreakCnt;

	// <uint8_t m_Dead, offset 0x650>
	uint8_t m_Dead;

	// <uint8_t m_Motion, offset 0x651>
	uint8_t m_Motion;

	// <uint8_t m_Off, offset 0x652>
	uint8_t m_Off;

	// <Unidentified data segment, offset 0x653>
private:
	char _UnidentifiedData5[1];

public:
	// <struct Vec m_CenterPos, offset 0x654>
	struct Vec m_CenterPos;

	// <float m_fAccumDmg, offset 0x660>
	float m_fAccumDmg;

	// <float m_fMaxAccumDmg, offset 0x664>
	float m_fMaxAccumDmg;

	// <uint8_t m_boGetBreakNode, offset 0x668>
	uint8_t m_boGetBreakNode;

	// <uint8_t m_boCreateFire, offset 0x669>
	uint8_t m_boCreateFire;

	// <Unidentified data segment, offset 0x66a>
private:
	char _UnidentifiedData10[2];

public:
	// <int32_t m_BlinkCnt, offset 0x66c>
	int32_t m_BlinkCnt;

	// <uint8_t m_boBlink, offset 0x670>
	uint8_t m_boBlink;

	// <Unidentified data segment, offset 0x671>
private:
	char _UnidentifiedData12[3];

public:
	// <class FkStlVector<TGmfNode const *> m_apNode, offset 0x674>
	class FkStlVector<TGmfNode const *> m_apNode;

	// <class FkStlVector<EffectModelFire *> m_pModelFireArr, offset 0x688>
	class FkStlVector<EffectModelFire *> m_pModelFireArr;

	// <int32_t m_SeHnd, offset 0x69c>
	int32_t m_SeHnd;

	std::string ToString() const { return "class PJOBJ0033(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0033, commonObj>("PJOBJ0033")
			.addFunction("__tostring", &PJOBJ0033::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0033::GetPtrAddr)
			.addProperty("m_BreakCnt", &PJOBJ0033::m_BreakCnt)
			.addProperty("m_Dead", &PJOBJ0033::m_Dead)
			.addProperty("m_Motion", &PJOBJ0033::m_Motion)
			.addProperty("m_Off", &PJOBJ0033::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0033::m_CenterPos)
			.addProperty("m_fAccumDmg", &PJOBJ0033::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0033::m_fMaxAccumDmg)
			.addProperty("m_boGetBreakNode", &PJOBJ0033::m_boGetBreakNode)
			.addProperty("m_boCreateFire", &PJOBJ0033::m_boCreateFire)
			.addProperty("m_BlinkCnt", &PJOBJ0033::m_BlinkCnt)
			.addProperty("m_boBlink", &PJOBJ0033::m_boBlink)
			.addProperty("m_apNode", &PJOBJ0033::m_apNode)
			.addProperty("m_pModelFireArr", &PJOBJ0033::m_pModelFireArr)
			.addProperty("m_SeHnd", &PJOBJ0033::m_SeHnd)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJOBJ0033::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0033::m_BreakCnt) == 4, "expected m_BreakCnt to be size 4");
static_assert(sizeof(PJOBJ0033::m_Dead) == 1, "expected m_Dead to be size 1");
static_assert(sizeof(PJOBJ0033::m_Motion) == 1, "expected m_Motion to be size 1");
static_assert(sizeof(PJOBJ0033::m_Off) == 1, "expected m_Off to be size 1");
static_assert(sizeof(PJOBJ0033::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0033::m_fAccumDmg) == 4, "expected m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0033::m_fMaxAccumDmg) == 4, "expected m_fMaxAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0033::m_boGetBreakNode) == 1, "expected m_boGetBreakNode to be size 1");
static_assert(sizeof(PJOBJ0033::m_boCreateFire) == 1, "expected m_boCreateFire to be size 1");
static_assert(sizeof(PJOBJ0033::m_BlinkCnt) == 4, "expected m_BlinkCnt to be size 4");
static_assert(sizeof(PJOBJ0033::m_boBlink) == 1, "expected m_boBlink to be size 1");
static_assert(sizeof(PJOBJ0033::m_apNode) == 20, "expected m_apNode to be size 20");
static_assert(sizeof(PJOBJ0033::m_pModelFireArr) == 20, "expected m_pModelFireArr to be size 20");
static_assert(sizeof(PJOBJ0033::m_SeHnd) == 4, "expected m_SeHnd to be size 4");
static_assert(sizeof(PJOBJ0033) == 1696, "expected class PJOBJ0033 to be size 1696");

// [Structure] struct EFFECTSIMPLEOBJ3PARAM
struct EFFECTSIMPLEOBJ3PARAM
{
public:
	/// Struct member variables

	// <int32_t MaxObjNum, offset 0x0>
	int32_t MaxObjNum;

	// <float SpeedUpSpeed, offset 0x4>
	float SpeedUpSpeed;

	// <float SideSpeedDownRate, offset 0x8>
	float SideSpeedDownRate;

	// <int16_t MaxVisibleTime, offset 0xc>
	int16_t MaxVisibleTime;

	// <int16_t MinVisibleTime, offset 0xe>
	int16_t MinVisibleTime;

	// <int16_t MaxFadeInSpeed, offset 0x10>
	int16_t MaxFadeInSpeed;

	// <int16_t MinFadeInSpeed, offset 0x12>
	int16_t MinFadeInSpeed;

	// <int16_t MaxFadeOutSpeed, offset 0x14>
	int16_t MaxFadeOutSpeed;

	// <int16_t MinFadeOutSpeed, offset 0x16>
	int16_t MinFadeOutSpeed;

	// <float MaxSideSpeed, offset 0x18>
	float MaxSideSpeed;

	// <float MinSideSpeed, offset 0x1c>
	float MinSideSpeed;

	// <float InitMaxSpeed, offset 0x20>
	float InitMaxSpeed;

	// <float InitMinSpeed, offset 0x24>
	float InitMinSpeed;

	// <float MaxWidth, offset 0x28>
	float MaxWidth;

	// <float MinWidth, offset 0x2c>
	float MinWidth;

	// <uint32_t Color, offset 0x30>
	uint32_t Color;

	// <int32_t ColorRand, offset 0x34>
	int32_t ColorRand;

	// <struct tagGHMR_TEX* pTexture, offset 0x38>
	struct tagGHMR_TEX* pTexture;

	// <int32_t TexDivX, offset 0x3c>
	int32_t TexDivX;

	// <int32_t TexDivY, offset 0x40>
	int32_t TexDivY;

	std::string ToString() const { return "struct EFFECTSIMPLEOBJ3PARAM(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EFFECTSIMPLEOBJ3PARAM>("EFFECTSIMPLEOBJ3PARAM")
			.addFunction("__tostring", &EFFECTSIMPLEOBJ3PARAM::ToString)
			.addFunction("GetPtrAddr", &EFFECTSIMPLEOBJ3PARAM::GetPtrAddr)
			.addProperty("MaxObjNum", &EFFECTSIMPLEOBJ3PARAM::MaxObjNum)
			.addProperty("SpeedUpSpeed", &EFFECTSIMPLEOBJ3PARAM::SpeedUpSpeed)
			.addProperty("SideSpeedDownRate", &EFFECTSIMPLEOBJ3PARAM::SideSpeedDownRate)
			.addProperty("MaxVisibleTime", &EFFECTSIMPLEOBJ3PARAM::MaxVisibleTime)
			.addProperty("MinVisibleTime", &EFFECTSIMPLEOBJ3PARAM::MinVisibleTime)
			.addProperty("MaxFadeInSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxFadeInSpeed)
			.addProperty("MinFadeInSpeed", &EFFECTSIMPLEOBJ3PARAM::MinFadeInSpeed)
			.addProperty("MaxFadeOutSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxFadeOutSpeed)
			.addProperty("MinFadeOutSpeed", &EFFECTSIMPLEOBJ3PARAM::MinFadeOutSpeed)
			.addProperty("MaxSideSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxSideSpeed)
			.addProperty("MinSideSpeed", &EFFECTSIMPLEOBJ3PARAM::MinSideSpeed)
			.addProperty("InitMaxSpeed", &EFFECTSIMPLEOBJ3PARAM::InitMaxSpeed)
			.addProperty("InitMinSpeed", &EFFECTSIMPLEOBJ3PARAM::InitMinSpeed)
			.addProperty("MaxWidth", &EFFECTSIMPLEOBJ3PARAM::MaxWidth)
			.addProperty("MinWidth", &EFFECTSIMPLEOBJ3PARAM::MinWidth)
			.addProperty("Color", &EFFECTSIMPLEOBJ3PARAM::Color)
			.addProperty("ColorRand", &EFFECTSIMPLEOBJ3PARAM::ColorRand)
			.addProperty("pTexture", &EFFECTSIMPLEOBJ3PARAM::pTexture)
			.addProperty("TexDivX", &EFFECTSIMPLEOBJ3PARAM::TexDivX)
			.addProperty("TexDivY", &EFFECTSIMPLEOBJ3PARAM::TexDivY)
		.endClass();
	}
#endif
};
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxObjNum) == 4, "expected MaxObjNum to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::SpeedUpSpeed) == 4, "expected SpeedUpSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::SideSpeedDownRate) == 4, "expected SideSpeedDownRate to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxVisibleTime) == 2, "expected MaxVisibleTime to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinVisibleTime) == 2, "expected MinVisibleTime to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxFadeInSpeed) == 2, "expected MaxFadeInSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinFadeInSpeed) == 2, "expected MinFadeInSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxFadeOutSpeed) == 2, "expected MaxFadeOutSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinFadeOutSpeed) == 2, "expected MinFadeOutSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxSideSpeed) == 4, "expected MaxSideSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinSideSpeed) == 4, "expected MinSideSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::InitMaxSpeed) == 4, "expected InitMaxSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::InitMinSpeed) == 4, "expected InitMinSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxWidth) == 4, "expected MaxWidth to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinWidth) == 4, "expected MinWidth to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::Color) == 4, "expected Color to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::ColorRand) == 4, "expected ColorRand to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::pTexture) == 4, "expected pTexture to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::TexDivX) == 4, "expected TexDivX to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::TexDivY) == 4, "expected TexDivY to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM) == 68, "expected struct EFFECTSIMPLEOBJ3PARAM to be size 68");

// [Structure] struct EFFECTMODELFIREPARAM
struct EFFECTMODELFIREPARAM
{
public:
	/// Struct member variables

	// <float CreateRate, offset 0x0>
	float CreateRate;

	// <float CreateArea, offset 0x4>
	float CreateArea;

	// <struct EFFECTSIMPLEOBJ3PARAM Obj3Param, offset 0x8>
	struct EFFECTSIMPLEOBJ3PARAM Obj3Param;

	std::string ToString() const { return "struct EFFECTMODELFIREPARAM(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EFFECTMODELFIREPARAM>("EFFECTMODELFIREPARAM")
			.addFunction("__tostring", &EFFECTMODELFIREPARAM::ToString)
			.addFunction("GetPtrAddr", &EFFECTMODELFIREPARAM::GetPtrAddr)
			.addProperty("CreateRate", &EFFECTMODELFIREPARAM::CreateRate)
			.addProperty("CreateArea", &EFFECTMODELFIREPARAM::CreateArea)
			.addProperty("Obj3Param", &EFFECTMODELFIREPARAM::Obj3Param)
		.endClass();
	}
#endif
};
static_assert(sizeof(EFFECTMODELFIREPARAM::CreateRate) == 4, "expected CreateRate to be size 4");
static_assert(sizeof(EFFECTMODELFIREPARAM::CreateArea) == 4, "expected CreateArea to be size 4");
static_assert(sizeof(EFFECTMODELFIREPARAM::Obj3Param) == 68, "expected Obj3Param to be size 68");
static_assert(sizeof(EFFECTMODELFIREPARAM) == 76, "expected struct EFFECTMODELFIREPARAM to be size 76");

// [Structure] class EffectModelFire
class EffectModelFire : public HrTask
{
public:
	// [Structure] struct EffectModelFire::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <class TGmf* pGmf, offset 0x0>
		class TGmf* pGmf;

		// <class TGmfNode* pGmfNode, offset 0x4>
		class TGmfNode* pGmfNode;

		// <float CreateCounter, offset 0x8>
		float CreateCounter;

		// <int32_t SinCounter[0x3], offset 0xc>
		int32_t SinCounter[3];

		// <int32_t SinSpeed[0x3], offset 0x18>
		int32_t SinSpeed[3];

		// <float NowCreateRate, offset 0x24>
		float NowCreateRate;

		// <float MinY, offset 0x28>
		float MinY;

		// <float MaxY, offset 0x2c>
		float MaxY;

		// <float BoarderY, offset 0x30>
		float BoarderY;

		// <float OutRate, offset 0x34>
		float OutRate;

		// <int32_t SoundID, offset 0x38>
		int32_t SoundID;

		// <int32_t SoundHandle, offset 0x3c>
		int32_t SoundHandle;

		// <struct EFFECTMODELFIREPARAM Param, offset 0x40>
		struct EFFECTMODELFIREPARAM Param;

		// <class EffectSimpleObj3* pObj3, offset 0x8c>
		class EffectSimpleObj3* pObj3;

		std::string ToString() const { return "struct MAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectModelFire::MAIN>("EffectModelFire_MAIN")
				.addFunction("__tostring", &EffectModelFire::MAIN::ToString)
				.addFunction("GetPtrAddr", &EffectModelFire::MAIN::GetPtrAddr)
				.addProperty("pGmf", &EffectModelFire::MAIN::pGmf)
				.addProperty("pGmfNode", &EffectModelFire::MAIN::pGmfNode)
				.addProperty("CreateCounter", &EffectModelFire::MAIN::CreateCounter)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("SinCounter", &EffectModelFire::MAIN::SinCounter)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("SinSpeed", &EffectModelFire::MAIN::SinSpeed)
				.addProperty("NowCreateRate", &EffectModelFire::MAIN::NowCreateRate)
				.addProperty("MinY", &EffectModelFire::MAIN::MinY)
				.addProperty("MaxY", &EffectModelFire::MAIN::MaxY)
				.addProperty("BoarderY", &EffectModelFire::MAIN::BoarderY)
				.addProperty("OutRate", &EffectModelFire::MAIN::OutRate)
				.addProperty("SoundID", &EffectModelFire::MAIN::SoundID)
				.addProperty("SoundHandle", &EffectModelFire::MAIN::SoundHandle)
				.addProperty("Param", &EffectModelFire::MAIN::Param)
				.addProperty("pObj3", &EffectModelFire::MAIN::pObj3)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectModelFire::MAIN::pGmf) == 4, "expected pGmf to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::pGmfNode) == 4, "expected pGmfNode to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::CreateCounter) == 4, "expected CreateCounter to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SinCounter) == 12, "expected SinCounter to be size 12");
	static_assert(sizeof(EffectModelFire::MAIN::SinSpeed) == 12, "expected SinSpeed to be size 12");
	static_assert(sizeof(EffectModelFire::MAIN::NowCreateRate) == 4, "expected NowCreateRate to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::MinY) == 4, "expected MinY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::MaxY) == 4, "expected MaxY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::BoarderY) == 4, "expected BoarderY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::OutRate) == 4, "expected OutRate to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SoundID) == 4, "expected SoundID to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SoundHandle) == 4, "expected SoundHandle to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::Param) == 76, "expected Param to be size 76");
	static_assert(sizeof(EffectModelFire::MAIN::pObj3) == 4, "expected pObj3 to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN) == 144, "expected struct EffectModelFire::MAIN to be size 144");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectModelFire::MAIN dat, offset 0x50>
	struct EffectModelFire::MAIN dat;

	std::string ToString() const { return "class EffectModelFire(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectModelFire, HrTask>("EffectModelFire")
			.addFunction("__tostring", &EffectModelFire::ToString)
			.addFunction("GetPtrAddr", &EffectModelFire::GetPtrAddr)
			.addProperty("dat", &EffectModelFire::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectModelFire::dat) == 144, "expected dat to be size 144");
static_assert(sizeof(EffectModelFire) == 224, "expected class EffectModelFire to be size 224");

// [Structure] class EffectSimpleObj3
class EffectSimpleObj3 : public HrTask
{
public:
	// [Structure] struct EffectSimpleObj3::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <int32_t ObjNum, offset 0x0>
		int32_t ObjNum;

		// <struct EffectSimpleObj3::OBJECT* Obj, offset 0x4>
		struct OBJECT* Obj;

		// <struct tagTLIST* ValidFirstObj, offset 0x8>
		struct tagTLIST* ValidFirstObj;

		// <struct tagTLIST* FreeFirstObj, offset 0xc>
		struct tagTLIST* FreeFirstObj;

		// <struct EFFECTSIMPLEOBJ3PARAM Param, offset 0x10>
		struct EFFECTSIMPLEOBJ3PARAM Param;

		std::string ToString() const { return "struct MAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectSimpleObj3::MAIN>("EffectSimpleObj3_MAIN")
				.addFunction("__tostring", &EffectSimpleObj3::MAIN::ToString)
				.addFunction("GetPtrAddr", &EffectSimpleObj3::MAIN::GetPtrAddr)
				.addProperty("ObjNum", &EffectSimpleObj3::MAIN::ObjNum)
				.addProperty("Obj", &EffectSimpleObj3::MAIN::Obj)
				.addProperty("ValidFirstObj", &EffectSimpleObj3::MAIN::ValidFirstObj)
				.addProperty("FreeFirstObj", &EffectSimpleObj3::MAIN::FreeFirstObj)
				.addProperty("Param", &EffectSimpleObj3::MAIN::Param)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectSimpleObj3::MAIN::ObjNum) == 4, "expected ObjNum to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::Obj) == 4, "expected Obj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::ValidFirstObj) == 4, "expected ValidFirstObj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::FreeFirstObj) == 4, "expected FreeFirstObj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::Param) == 68, "expected Param to be size 68");
	static_assert(sizeof(EffectSimpleObj3::MAIN) == 84, "expected struct EffectSimpleObj3::MAIN to be size 84");

	// [Structure] struct EffectSimpleObj3::OBJECT
	struct OBJECT
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData[68];
	public:

		std::string ToString() const { return "struct OBJECT(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectSimpleObj3::OBJECT>("EffectSimpleObj3_OBJECT")
				.addFunction("__tostring", &EffectSimpleObj3::OBJECT::ToString)
				.addFunction("GetPtrAddr", &EffectSimpleObj3::OBJECT::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectSimpleObj3::OBJECT) == 68, "expected struct EffectSimpleObj3::OBJECT to be size 68");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectSimpleObj3::MAIN dat, offset 0x50>
	struct EffectSimpleObj3::MAIN dat;

	std::string ToString() const { return "class EffectSimpleObj3(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSimpleObj3, HrTask>("EffectSimpleObj3")
			.addFunction("__tostring", &EffectSimpleObj3::ToString)
			.addFunction("GetPtrAddr", &EffectSimpleObj3::GetPtrAddr)
			.addProperty("dat", &EffectSimpleObj3::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSimpleObj3::dat) == 84, "expected dat to be size 84");
static_assert(sizeof(EffectSimpleObj3) == 164, "expected class EffectSimpleObj3 to be size 164");

// [Structure] struct tagTLIST
struct tagTLIST
{
public:
	/// Struct member variables

	// <tagTLIST* Prev, offset 0x0>
	tagTLIST* Prev;

	// <tagTLIST* Next, offset 0x4>
	tagTLIST* Next;

	std::string ToString() const { return "struct tagTLIST(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagTLIST>("tagTLIST")
			.addFunction("__tostring", &tagTLIST::ToString)
			.addFunction("GetPtrAddr", &tagTLIST::GetPtrAddr)
			.addProperty("Prev", &tagTLIST::Prev)
			.addProperty("Next", &tagTLIST::Next)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagTLIST::Prev) == 4, "expected Prev to be size 4");
static_assert(sizeof(tagTLIST::Next) == 4, "expected Next to be size 4");
static_assert(sizeof(tagTLIST) == 8, "expected struct tagTLIST to be size 8");

// [Structure] class PJOBJ0036
class PJOBJ0036 : public commonObj
{
public:
	// [Function] uint8_t __convention("thiscall") PJOBJ0036::mSetDamage(class PJOBJ0036* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0036@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class PJOBJ0036* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x556080);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <uint8_t m_Dead, offset 0x64c>
	uint8_t m_Dead;

	// <uint8_t m_Motion, offset 0x64d>
	uint8_t m_Motion;

	// <uint8_t m_Off, offset 0x64e>
	uint8_t m_Off;

	// <Unidentified data segment, offset 0x64f>
private:
	char _UnidentifiedData4[1];

public:
	// <struct Vec m_CenterPos, offset 0x650>
	struct Vec m_CenterPos;

	// <int32_t m_Cnt, offset 0x65c>
	int32_t m_Cnt;

	// <float m_fAccumDmg, offset 0x660>
	float m_fAccumDmg;

	// <float m_fMaxAccumDmg, offset 0x664>
	float m_fMaxAccumDmg;

	// <uint8_t m_boGetBreakNode, offset 0x668>
	uint8_t m_boGetBreakNode;

	// <Unidentified data segment, offset 0x669>
private:
	char _UnidentifiedData9[3];

public:
	// <struct tagGHMR_TEX m_Tex, offset 0x66c>
	struct tagGHMR_TEX m_Tex;

	// <class FkStlVector<TGmfNode const *> m_apNode, offset 0x694>
	class FkStlVector<TGmfNode const *> m_apNode;

	std::string ToString() const { return "class PJOBJ0036(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0036, commonObj>("PJOBJ0036")
			.addFunction("__tostring", &PJOBJ0036::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0036::GetPtrAddr)
			.addProperty("m_Dead", &PJOBJ0036::m_Dead)
			.addProperty("m_Motion", &PJOBJ0036::m_Motion)
			.addProperty("m_Off", &PJOBJ0036::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0036::m_CenterPos)
			.addProperty("m_Cnt", &PJOBJ0036::m_Cnt)
			.addProperty("m_fAccumDmg", &PJOBJ0036::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0036::m_fMaxAccumDmg)
			.addProperty("m_boGetBreakNode", &PJOBJ0036::m_boGetBreakNode)
			.addProperty("m_Tex", &PJOBJ0036::m_Tex)
			.addProperty("m_apNode", &PJOBJ0036::m_apNode)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJOBJ0036::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0036::m_Dead) == 1, "expected m_Dead to be size 1");
static_assert(sizeof(PJOBJ0036::m_Motion) == 1, "expected m_Motion to be size 1");
static_assert(sizeof(PJOBJ0036::m_Off) == 1, "expected m_Off to be size 1");
static_assert(sizeof(PJOBJ0036::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0036::m_Cnt) == 4, "expected m_Cnt to be size 4");
static_assert(sizeof(PJOBJ0036::m_fAccumDmg) == 4, "expected m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0036::m_fMaxAccumDmg) == 4, "expected m_fMaxAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0036::m_boGetBreakNode) == 1, "expected m_boGetBreakNode to be size 1");
static_assert(sizeof(PJOBJ0036::m_Tex) == 40, "expected m_Tex to be size 40");
static_assert(sizeof(PJOBJ0036::m_apNode) == 20, "expected m_apNode to be size 20");
static_assert(sizeof(PJOBJ0036) == 1704, "expected class PJOBJ0036 to be size 1704");

// [Structure] class PJOBJ0037
class PJOBJ0037 : public commonObj
{
public:
	// [Function] uint8_t __convention("thiscall") PJOBJ0037::mSetDamage(class PJOBJ0037* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0037@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class PJOBJ0037* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x556390);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Function] uint8_t __convention("thiscall") PJOBJ0037::IsHitChar(class PJOBJ0037* const this, class mHRChara* arg2) [?IsHitChar@PJOBJ0037@@AAE_NPAVmHRChara@@@Z]
	uint8_t IsHitChar(class mHRChara* arg2)
	{
		typedef uint8_t(__thiscall* _Func)(class PJOBJ0037* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x556590);
		return mFunc(this, arg2);
	}
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	std::string ToString() const { return "class PJOBJ0037(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0037, commonObj>("PJOBJ0037")
			.addFunction("__tostring", &PJOBJ0037::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0037::GetPtrAddr)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJOBJ0037::mSetDamage)
			.addFunction("IsHitChar", &PJOBJ0037::IsHitChar)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0037) == 1612, "expected class PJOBJ0037 to be size 1612");

// [Structure] class PJOBJ0104
class PJOBJ0104 : public commonObj
{
public:
	// [Function] uint8_t __convention("thiscall") PJOBJ0104::mSetDamage(class PJOBJ0104* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0104@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class PJOBJ0104* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x556730);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <uint8_t m_Dead, offset 0x64c>
	uint8_t m_Dead;

	// <uint8_t m_Motion, offset 0x64d>
	uint8_t m_Motion;

	// <uint8_t m_Off, offset 0x64e>
	uint8_t m_Off;

	// <Unidentified data segment, offset 0x64f>
private:
	char _UnidentifiedData4[1];

public:
	// <struct Vec m_CenterPos, offset 0x650>
	struct Vec m_CenterPos;

	// <class TGmf* m_DamageModel[0x3], offset 0x65c>
	class TGmf* m_DamageModel[3];

	// <class TGan* m_BreakMotion, offset 0x668>
	class TGan* m_BreakMotion;

	// <float m_fAccumDmg, offset 0x66c>
	float m_fAccumDmg;

	// <float m_fMaxAccumDmg, offset 0x670>
	float m_fMaxAccumDmg;

	std::string ToString() const { return "class PJOBJ0104(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0104, commonObj>("PJOBJ0104")
			.addFunction("__tostring", &PJOBJ0104::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0104::GetPtrAddr)
			.addProperty("m_Dead", &PJOBJ0104::m_Dead)
			.addProperty("m_Motion", &PJOBJ0104::m_Motion)
			.addProperty("m_Off", &PJOBJ0104::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0104::m_CenterPos)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_DamageModel", &PJOBJ0104::m_DamageModel)
			.addProperty("m_BreakMotion", &PJOBJ0104::m_BreakMotion)
			.addProperty("m_fAccumDmg", &PJOBJ0104::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0104::m_fMaxAccumDmg)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJOBJ0104::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0104::m_Dead) == 1, "expected m_Dead to be size 1");
static_assert(sizeof(PJOBJ0104::m_Motion) == 1, "expected m_Motion to be size 1");
static_assert(sizeof(PJOBJ0104::m_Off) == 1, "expected m_Off to be size 1");
static_assert(sizeof(PJOBJ0104::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0104::m_DamageModel) == 12, "expected m_DamageModel to be size 12");
static_assert(sizeof(PJOBJ0104::m_BreakMotion) == 4, "expected m_BreakMotion to be size 4");
static_assert(sizeof(PJOBJ0104::m_fAccumDmg) == 4, "expected m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0104::m_fMaxAccumDmg) == 4, "expected m_fMaxAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0104) == 1652, "expected class PJOBJ0104 to be size 1652");

// [Structure] class PJOBJ0155
class PJOBJ0155 : public commonObj
{
public:
	// [Function] uint8_t __convention("thiscall") PJOBJ0155::mSetDamage(class PJOBJ0155* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJOBJ0155@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class PJOBJ0155* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x556c00);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <int32_t m_AlphaVisibleCnt, offset 0x64c>
	int32_t m_AlphaVisibleCnt;

	// <int32_t m_AlphaVisibleFrmMax, offset 0x650>
	int32_t m_AlphaVisibleFrmMax;

	// <uint8_t m_Dead, offset 0x654>
	uint8_t m_Dead;

	// <uint8_t m_Motion, offset 0x655>
	uint8_t m_Motion;

	// <uint8_t m_Off, offset 0x656>
	uint8_t m_Off;

	// <Unidentified data segment, offset 0x657>
private:
	char _UnidentifiedData6[1];

public:
	// <struct Vec m_CenterPos, offset 0x658>
	struct Vec m_CenterPos;

	// <int32_t m_Counter, offset 0x664>
	int32_t m_Counter;

	// <int32_t m_nPipe, offset 0x668>
	int32_t m_nPipe;

	// <struct tagGHMR_TEX m_Tex, offset 0x66c>
	struct tagGHMR_TEX m_Tex;

	std::string ToString() const { return "class PJOBJ0155(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0155, commonObj>("PJOBJ0155")
			.addFunction("__tostring", &PJOBJ0155::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0155::GetPtrAddr)
			.addProperty("m_AlphaVisibleCnt", &PJOBJ0155::m_AlphaVisibleCnt)
			.addProperty("m_AlphaVisibleFrmMax", &PJOBJ0155::m_AlphaVisibleFrmMax)
			.addProperty("m_Dead", &PJOBJ0155::m_Dead)
			.addProperty("m_Motion", &PJOBJ0155::m_Motion)
			.addProperty("m_Off", &PJOBJ0155::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0155::m_CenterPos)
			.addProperty("m_Counter", &PJOBJ0155::m_Counter)
			.addProperty("m_nPipe", &PJOBJ0155::m_nPipe)
			.addProperty("m_Tex", &PJOBJ0155::m_Tex)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJOBJ0155::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0155::m_AlphaVisibleCnt) == 4, "expected m_AlphaVisibleCnt to be size 4");
static_assert(sizeof(PJOBJ0155::m_AlphaVisibleFrmMax) == 4, "expected m_AlphaVisibleFrmMax to be size 4");
static_assert(sizeof(PJOBJ0155::m_Dead) == 1, "expected m_Dead to be size 1");
static_assert(sizeof(PJOBJ0155::m_Motion) == 1, "expected m_Motion to be size 1");
static_assert(sizeof(PJOBJ0155::m_Off) == 1, "expected m_Off to be size 1");
static_assert(sizeof(PJOBJ0155::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0155::m_Counter) == 4, "expected m_Counter to be size 4");
static_assert(sizeof(PJOBJ0155::m_nPipe) == 4, "expected m_nPipe to be size 4");
static_assert(sizeof(PJOBJ0155::m_Tex) == 40, "expected m_Tex to be size 40");
static_assert(sizeof(PJOBJ0155) == 1684, "expected class PJOBJ0155 to be size 1684");

// [Structure] class PJOBJ0190
class PJOBJ0190 : public commonObj
{
public:
	// [Function] uint8_t __convention("thiscall") PJOBJ0190::mSetDamage(class PJOBJ0190* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11) [?mSetDamage@PJOBJ0190@@UAE_NMHHHMHMMPAVmHRChara@@M@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)
	{
		typedef uint8_t(__thiscall* _Func)(class PJOBJ0190* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11);
		_Func mFunc = (_Func)(GameModule + 0x557250);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
	}
	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class TGmfNode* mpTopNode, offset 0x64c>
	class TGmfNode* mpTopNode;

	// <uint8_t mbBreak, offset 0x650>
	uint8_t mbBreak;

	// <Unidentified data segment, offset 0x651>
private:
	char _UnidentifiedData3[3];

public:
	// <float mRadius, offset 0x654>
	float mRadius;

	std::string ToString() const { return "class PJOBJ0190(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<PJOBJ0190, commonObj>("PJOBJ0190")
			.addFunction("__tostring", &PJOBJ0190::ToString)
			.addFunction("GetPtrAddr", &PJOBJ0190::GetPtrAddr)
			.addProperty("mpTopNode", &PJOBJ0190::mpTopNode)
			.addProperty("mbBreak", &PJOBJ0190::mbBreak)
			.addProperty("mRadius", &PJOBJ0190::mRadius)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJOBJ0190::mSetDamage)
			// Function overloading not supported in LuaBridge.
			//.addFunction("mSetDamage", &PJOBJ0190::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0190::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(PJOBJ0190::mbBreak) == 1, "expected mbBreak to be size 1");
static_assert(sizeof(PJOBJ0190::mRadius) == 4, "expected mRadius to be size 4");
static_assert(sizeof(PJOBJ0190) == 1624, "expected class PJOBJ0190 to be size 1624");

// [Structure] class PJPTR
class PJPTR
{
public:
	// [Function] uint8_t __convention("thiscall") PJPTR::mSetDamage(class PJPTR* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@PJPTR@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class PJPTR* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x557550);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[1668];
public:

	std::string ToString() const { return "class PJPTR(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJPTR>("PJPTR")
			.addFunction("__tostring", &PJPTR::ToString)
			.addFunction("GetPtrAddr", &PJPTR::GetPtrAddr)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &PJPTR::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJPTR) == 1668, "expected class PJPTR to be size 1668");

// [Function] void mHRCharaVoiceTable_Initialize() [mHRCharaVoiceTable_Initialize]
void mHRCharaVoiceTable_Initialize()
{
	typedef void(__fastcall* _Func)();
	_Func mFunc = (_Func)(GameModule + 0x5b1950);
	return mFunc();
}
// [Structure] struct FkDbgInfo_EventArea
struct FkDbgInfo_EventArea
{
public:
	/// Struct member variables

	// <float fRadius, offset 0x0>
	float fRadius;

	// <struct Vec CenterPos, offset 0x4>
	struct Vec CenterPos;

	std::string ToString() const { return "struct FkDbgInfo_EventArea(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkDbgInfo_EventArea>("FkDbgInfo_EventArea")
			.addFunction("__tostring", &FkDbgInfo_EventArea::ToString)
			.addFunction("GetPtrAddr", &FkDbgInfo_EventArea::GetPtrAddr)
			.addProperty("fRadius", &FkDbgInfo_EventArea::fRadius)
			.addProperty("CenterPos", &FkDbgInfo_EventArea::CenterPos)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkDbgInfo_EventArea::fRadius) == 4, "expected fRadius to be size 4");
static_assert(sizeof(FkDbgInfo_EventArea::CenterPos) == 12, "expected CenterPos to be size 12");
static_assert(sizeof(FkDbgInfo_EventArea) == 16, "expected struct FkDbgInfo_EventArea to be size 16");

// [Structure] class FkGlobalDBG
class FkGlobalDBG
{
public:
	// [Function] void __convention("thiscall") FkGlobalDBG::ReleaseCtrlChar(class FkGlobalDBG* const this, class mHRChara* arg2) [?ReleaseCtrlChar@FkGlobalDBG@@QAEXPAVmHRChara@@@Z]
	void ReleaseCtrlChar(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class FkGlobalDBG* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x5b39a0);
		return mFunc(this, arg2);
	}
	// [Structure] struct FkGlobalDBG::CommonObjSetInf
	struct CommonObjSetInf
	{
	public:
		/// Struct member variables

		// <int32_t iNowCursor, offset 0x0>
		int32_t iNowCursor;

		// <uint32_t nObjRegist, offset 0x4>
		uint32_t nObjRegist;

		// <struct Vec SetPos, offset 0x8>
		struct Vec SetPos;

		std::string ToString() const { return "struct CommonObjSetInf(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkGlobalDBG::CommonObjSetInf>("FkGlobalDBG_CommonObjSetInf")
				.addFunction("__tostring", &FkGlobalDBG::CommonObjSetInf::ToString)
				.addFunction("GetPtrAddr", &FkGlobalDBG::CommonObjSetInf::GetPtrAddr)
				.addProperty("iNowCursor", &FkGlobalDBG::CommonObjSetInf::iNowCursor)
				.addProperty("nObjRegist", &FkGlobalDBG::CommonObjSetInf::nObjRegist)
				.addProperty("SetPos", &FkGlobalDBG::CommonObjSetInf::SetPos)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::iNowCursor) == 4, "expected iNowCursor to be size 4");
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::nObjRegist) == 4, "expected nObjRegist to be size 4");
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::SetPos) == 12, "expected SetPos to be size 12");
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf) == 20, "expected struct FkGlobalDBG::CommonObjSetInf to be size 20");

	/// Struct member variables

	// <struct FkDbgInfo_EventArea m_EventAreaDbgInfo, offset 0x0>
	struct FkDbgInfo_EventArea m_EventAreaDbgInfo;

	// <class PathPlanner* m_pPathPlanner, offset 0x10>
	class PathPlanner* m_pPathPlanner;

	// <Unidentified data segment, offset 0x14>
private:
	char _UnidentifiedData2[4];

public:
	// <uint64_t m_PathPlanningTime, offset 0x18>
	uint64_t m_PathPlanningTime;

	// <class mHRChara* m_pCtrlChar, offset 0x20>
	class mHRChara* m_pCtrlChar;

	// <struct FkGlobalDBG::CommonObjSetInf m_CmnObjSetInf, offset 0x24>
	struct FkGlobalDBG::CommonObjSetInf m_CmnObjSetInf;

	std::string ToString() const { return "class FkGlobalDBG(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkGlobalDBG>("FkGlobalDBG")
			.addFunction("__tostring", &FkGlobalDBG::ToString)
			.addFunction("GetPtrAddr", &FkGlobalDBG::GetPtrAddr)
			.addProperty("m_EventAreaDbgInfo", &FkGlobalDBG::m_EventAreaDbgInfo)
			.addProperty("m_pPathPlanner", &FkGlobalDBG::m_pPathPlanner)
			.addProperty("m_PathPlanningTime", &FkGlobalDBG::m_PathPlanningTime)
			.addProperty("m_pCtrlChar", &FkGlobalDBG::m_pCtrlChar)
			.addProperty("m_CmnObjSetInf", &FkGlobalDBG::m_CmnObjSetInf)
			.addFunction("ReleaseCtrlChar", &FkGlobalDBG::ReleaseCtrlChar)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkGlobalDBG::m_EventAreaDbgInfo) == 16, "expected m_EventAreaDbgInfo to be size 16");
static_assert(sizeof(FkGlobalDBG::m_pPathPlanner) == 4, "expected m_pPathPlanner to be size 4");
static_assert(sizeof(FkGlobalDBG::m_PathPlanningTime) == 8, "expected m_PathPlanningTime to be size 8");
static_assert(sizeof(FkGlobalDBG::m_pCtrlChar) == 4, "expected m_pCtrlChar to be size 4");
static_assert(sizeof(FkGlobalDBG::m_CmnObjSetInf) == 20, "expected m_CmnObjSetInf to be size 20");
static_assert(sizeof(FkGlobalDBG) == 56, "expected class FkGlobalDBG to be size 56");

// [Structure] class EffectBloodSplash
class EffectBloodSplash : public HrTask
{
public:
	// [Function] class EffectBloodSplash* EffectBloodSplash::Create(class TGmfNode* arg1, int32_t arg2, int32_t arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13, float arg14, int32_t arg15, float arg16, int32_t arg17, float arg18, float arg19, float arg20, float arg21, float arg22, float arg23, float arg24, float arg25, float arg26, float arg27, uint32_t arg28, uint8_t arg29, class mHRChara* arg30) [?Create@EffectBloodSplash@@SAPAV1@PAVTGmfNode@@HHMMMMMMMMMMMHMHMMMMMMMMMMI_NPAVmHRChara@@@Z]
	static class EffectBloodSplash* Create(class TGmfNode* arg1, int32_t arg2, int32_t arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13, float arg14, int32_t arg15, float arg16, int32_t arg17, float arg18, float arg19, float arg20, float arg21, float arg22, float arg23, float arg24, float arg25, float arg26, float arg27, uint32_t arg28, uint8_t arg29, class mHRChara* arg30)
	{
		typedef class EffectBloodSplash*(__fastcall* _Func)(class TGmfNode* arg1, int32_t arg2, int32_t arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13, float arg14, int32_t arg15, float arg16, int32_t arg17, float arg18, float arg19, float arg20, float arg21, float arg22, float arg23, float arg24, float arg25, float arg26, float arg27, uint32_t arg28, uint8_t arg29, class mHRChara* arg30);
		_Func mFunc = (_Func)(GameModule + 0x5b4ec0);
		return mFunc(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30);
	}
	// [Structure] struct EffectBloodSplash::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <class TGmfNode* Node, offset 0x0>
		class TGmfNode* Node;

		// <class EffectSimpleObj2* Line, offset 0x4>
		class EffectSimpleObj2* Line;

		// <struct TGMFMESH** MeshList, offset 0x8>
		struct TGMFMESH** MeshList;

		// <float AreaSize, offset 0xc>
		float AreaSize;

		// <float MaxSpeed, offset 0x10>
		float MaxSpeed;

		// <float MinSpeed, offset 0x14>
		float MinSpeed;

		// <float MaxWidth, offset 0x18>
		float MaxWidth;

		// <float MinWidth, offset 0x1c>
		float MinWidth;

		// <float MaxSize, offset 0x20>
		float MaxSize;

		// <float MinSize, offset 0x24>
		float MinSize;

		// <float Length, offset 0x28>
		float Length;

		// <float Width, offset 0x2c>
		float Width;

		// <float CreateRate, offset 0x30>
		float CreateRate;

		// <float TimeCounter, offset 0x34>
		float TimeCounter;

		// <float Time, offset 0x38>
		float Time;

		// <float FadeTime, offset 0x3c>
		float FadeTime;

		// <float SpeedRate, offset 0x40>
		float SpeedRate;

		// <float SpeedRate2, offset 0x44>
		float SpeedRate2;

		// <int32_t MinRangeCounter, offset 0x48>
		int32_t MinRangeCounter;

		// <int32_t MinRangeSpeed, offset 0x4c>
		int32_t MinRangeSpeed;

		// <int32_t MinRangeSpeedTime, offset 0x50>
		int32_t MinRangeSpeedTime;

		// <float MinRimitSpeed, offset 0x54>
		float MinRimitSpeed;

		// <float MinCreateRate, offset 0x58>
		float MinCreateRate;

		// <float CenterRate, offset 0x5c>
		float CenterRate;

		// <float FadeSpeed, offset 0x60>
		float FadeSpeed;

		// <float FadeSpeed2, offset 0x64>
		float FadeSpeed2;

		// <float MinRange, offset 0x68>
		float MinRange;

		// <float DirRange, offset 0x6c>
		float DirRange;

		// <float FadeTime2CreateRate, offset 0x70>
		float FadeTime2CreateRate;

		// <float FadeTime2SpeedRate, offset 0x74>
		float FadeTime2SpeedRate;

		// <float FadeTime2, offset 0x78>
		float FadeTime2;

		// <struct Vec Pos, offset 0x7c>
		struct Vec Pos;

		// <struct Vec Dir, offset 0x88>
		struct Vec Dir;

		// <uint8_t DirValid, offset 0x94>
		uint8_t DirValid;

		// <uint8_t AddStopFlag, offset 0x95>
		uint8_t AddStopFlag;

		// <Unidentified data segment, offset 0x96>
	private:
		char _UnidentifiedData35[2];

	public:
		// <int32_t id, offset 0x98>
		int32_t id;

		// <class mHRChara* pOwner, offset 0x9c>
		class mHRChara* pOwner;

		std::string ToString() const { return "struct MAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectBloodSplash::MAIN>("EffectBloodSplash_MAIN")
				.addFunction("__tostring", &EffectBloodSplash::MAIN::ToString)
				.addFunction("GetPtrAddr", &EffectBloodSplash::MAIN::GetPtrAddr)
				.addProperty("Node", &EffectBloodSplash::MAIN::Node)
				.addProperty("Line", &EffectBloodSplash::MAIN::Line)
				// pointer to pointer is not supported in LuaBridge
				//.addProperty("MeshList", &EffectBloodSplash::MAIN::MeshList)
				.addProperty("AreaSize", &EffectBloodSplash::MAIN::AreaSize)
				.addProperty("MaxSpeed", &EffectBloodSplash::MAIN::MaxSpeed)
				.addProperty("MinSpeed", &EffectBloodSplash::MAIN::MinSpeed)
				.addProperty("MaxWidth", &EffectBloodSplash::MAIN::MaxWidth)
				.addProperty("MinWidth", &EffectBloodSplash::MAIN::MinWidth)
				.addProperty("MaxSize", &EffectBloodSplash::MAIN::MaxSize)
				.addProperty("MinSize", &EffectBloodSplash::MAIN::MinSize)
				.addProperty("Length", &EffectBloodSplash::MAIN::Length)
				.addProperty("Width", &EffectBloodSplash::MAIN::Width)
				.addProperty("CreateRate", &EffectBloodSplash::MAIN::CreateRate)
				.addProperty("TimeCounter", &EffectBloodSplash::MAIN::TimeCounter)
				.addProperty("Time", &EffectBloodSplash::MAIN::Time)
				.addProperty("FadeTime", &EffectBloodSplash::MAIN::FadeTime)
				.addProperty("SpeedRate", &EffectBloodSplash::MAIN::SpeedRate)
				.addProperty("SpeedRate2", &EffectBloodSplash::MAIN::SpeedRate2)
				.addProperty("MinRangeCounter", &EffectBloodSplash::MAIN::MinRangeCounter)
				.addProperty("MinRangeSpeed", &EffectBloodSplash::MAIN::MinRangeSpeed)
				.addProperty("MinRangeSpeedTime", &EffectBloodSplash::MAIN::MinRangeSpeedTime)
				.addProperty("MinRimitSpeed", &EffectBloodSplash::MAIN::MinRimitSpeed)
				.addProperty("MinCreateRate", &EffectBloodSplash::MAIN::MinCreateRate)
				.addProperty("CenterRate", &EffectBloodSplash::MAIN::CenterRate)
				.addProperty("FadeSpeed", &EffectBloodSplash::MAIN::FadeSpeed)
				.addProperty("FadeSpeed2", &EffectBloodSplash::MAIN::FadeSpeed2)
				.addProperty("MinRange", &EffectBloodSplash::MAIN::MinRange)
				.addProperty("DirRange", &EffectBloodSplash::MAIN::DirRange)
				.addProperty("FadeTime2CreateRate", &EffectBloodSplash::MAIN::FadeTime2CreateRate)
				.addProperty("FadeTime2SpeedRate", &EffectBloodSplash::MAIN::FadeTime2SpeedRate)
				.addProperty("FadeTime2", &EffectBloodSplash::MAIN::FadeTime2)
				.addProperty("Pos", &EffectBloodSplash::MAIN::Pos)
				.addProperty("Dir", &EffectBloodSplash::MAIN::Dir)
				.addProperty("DirValid", &EffectBloodSplash::MAIN::DirValid)
				.addProperty("AddStopFlag", &EffectBloodSplash::MAIN::AddStopFlag)
				.addProperty("id", &EffectBloodSplash::MAIN::id)
				.addProperty("pOwner", &EffectBloodSplash::MAIN::pOwner)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectBloodSplash::MAIN::Node) == 4, "expected Node to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Line) == 4, "expected Line to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MeshList) == 4, "expected MeshList to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::AreaSize) == 4, "expected AreaSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxSpeed) == 4, "expected MaxSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinSpeed) == 4, "expected MinSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxWidth) == 4, "expected MaxWidth to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinWidth) == 4, "expected MinWidth to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxSize) == 4, "expected MaxSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinSize) == 4, "expected MinSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Length) == 4, "expected Length to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Width) == 4, "expected Width to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::CreateRate) == 4, "expected CreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::TimeCounter) == 4, "expected TimeCounter to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Time) == 4, "expected Time to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime) == 4, "expected FadeTime to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::SpeedRate) == 4, "expected SpeedRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::SpeedRate2) == 4, "expected SpeedRate2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeCounter) == 4, "expected MinRangeCounter to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeSpeed) == 4, "expected MinRangeSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeSpeedTime) == 4, "expected MinRangeSpeedTime to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRimitSpeed) == 4, "expected MinRimitSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinCreateRate) == 4, "expected MinCreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::CenterRate) == 4, "expected CenterRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeSpeed) == 4, "expected FadeSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeSpeed2) == 4, "expected FadeSpeed2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRange) == 4, "expected MinRange to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::DirRange) == 4, "expected DirRange to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2CreateRate) == 4, "expected FadeTime2CreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2SpeedRate) == 4, "expected FadeTime2SpeedRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2) == 4, "expected FadeTime2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Pos) == 12, "expected Pos to be size 12");
	static_assert(sizeof(EffectBloodSplash::MAIN::Dir) == 12, "expected Dir to be size 12");
	static_assert(sizeof(EffectBloodSplash::MAIN::DirValid) == 1, "expected DirValid to be size 1");
	static_assert(sizeof(EffectBloodSplash::MAIN::AddStopFlag) == 1, "expected AddStopFlag to be size 1");
	static_assert(sizeof(EffectBloodSplash::MAIN::id) == 4, "expected id to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::pOwner) == 4, "expected pOwner to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN) == 160, "expected struct EffectBloodSplash::MAIN to be size 160");

	// [Function] class EffectBloodSplash* EffectBloodSplash::Create2(class TGmfNode* arg1, float arg2, float arg3, float arg4, float arg5, int32_t arg6, uint8_t arg7, class mHRChara* arg8) [?Create2@EffectBloodSplash@@SAPAV1@PAVTGmfNode@@MMMMH_NPAVmHRChara@@@Z]
	static class EffectBloodSplash* Create2(class TGmfNode* arg1, float arg2, float arg3, float arg4, float arg5, int32_t arg6, uint8_t arg7, class mHRChara* arg8)
	{
		typedef class EffectBloodSplash*(__fastcall* _Func)(class TGmfNode* arg1, float arg2, float arg3, float arg4, float arg5, int32_t arg6, uint8_t arg7, class mHRChara* arg8);
		_Func mFunc = (_Func)(GameModule + 0x5b5410);
		return mFunc(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
	}
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <float m_fCreateNum, offset 0x50>
	float m_fCreateNum;

	// <struct EffectBloodSplash::MAIN dat, offset 0x54>
	struct EffectBloodSplash::MAIN dat;

	std::string ToString() const { return "class EffectBloodSplash(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectBloodSplash, HrTask>("EffectBloodSplash")
			.addFunction("__tostring", &EffectBloodSplash::ToString)
			.addFunction("GetPtrAddr", &EffectBloodSplash::GetPtrAddr)
			.addProperty("m_fCreateNum", &EffectBloodSplash::m_fCreateNum)
			.addProperty("dat", &EffectBloodSplash::dat)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addStaticFunction("Create", &EffectBloodSplash::Create)
			.addStaticFunction("Create2", &EffectBloodSplash::Create2)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectBloodSplash::m_fCreateNum) == 4, "expected m_fCreateNum to be size 4");
static_assert(sizeof(EffectBloodSplash::dat) == 160, "expected dat to be size 160");
static_assert(sizeof(EffectBloodSplash) == 244, "expected class EffectBloodSplash to be size 244");

// [Structure] class EffectSimpleObj2
class EffectSimpleObj2 : public HrTask
{
public:
	// [Structure] struct EffectSimpleObj2::MAIN
	struct MAIN
	{
	public:
		/// Struct member variables

		// <Unidentified data segment, offset 0x0>
	private:
		char _UnidentifiedData[176];
	public:

		std::string ToString() const { return "struct MAIN(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectSimpleObj2::MAIN>("EffectSimpleObj2_MAIN")
				.addFunction("__tostring", &EffectSimpleObj2::MAIN::ToString)
				.addFunction("GetPtrAddr", &EffectSimpleObj2::MAIN::GetPtrAddr)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectSimpleObj2::MAIN) == 176, "expected struct EffectSimpleObj2::MAIN to be size 176");

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectSimpleObj2::MAIN dat, offset 0x50>
	struct EffectSimpleObj2::MAIN dat;

	std::string ToString() const { return "class EffectSimpleObj2(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSimpleObj2, HrTask>("EffectSimpleObj2")
			.addFunction("__tostring", &EffectSimpleObj2::ToString)
			.addFunction("GetPtrAddr", &EffectSimpleObj2::GetPtrAddr)
			.addProperty("dat", &EffectSimpleObj2::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSimpleObj2::dat) == 176, "expected dat to be size 176");
static_assert(sizeof(EffectSimpleObj2) == 256, "expected class EffectSimpleObj2 to be size 256");

// [Structure] class EffectSlashHit
class EffectSlashHit : public HrTask
{
public:
	// [Function] class EffectSlashHit* EffectSlashHit::Create(struct Vec& arg1, struct Vec& arg2, class mHRChara* arg3, float const arg4) [?Create@EffectSlashHit@@SAPAV1@ABUVec@@0PBVmHRChara@@M@Z]
	static class EffectSlashHit* Create(struct Vec& arg1, struct Vec& arg2, class mHRChara* arg3, float const arg4)
	{
		typedef class EffectSlashHit*(__fastcall* _Func)(struct Vec& arg1, struct Vec& arg2, class mHRChara* arg3, float const arg4);
		_Func mFunc = (_Func)(GameModule + 0x61f210);
		return mFunc(arg1, arg2, arg3, arg4);
	}
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct Vec m_SlashVec, offset 0x50>
	struct Vec m_SlashVec;

	// <struct Vec m_SlashPlnNrm, offset 0x5c>
	struct Vec m_SlashPlnNrm;

	// <class mHRChara* m_pChara, offset 0x68>
	class mHRChara* m_pChara;

	// <struct Vec m_Pos, offset 0x6c>
	struct Vec m_Pos;

	// <enum eEfDmgLevel m_eDamageLevel, offset 0x78>
	enum eEfDmgLevel m_eDamageLevel;

	// <uint32_t m_nColor, offset 0x7c>
	uint32_t m_nColor;

	// <int32_t m_nCounter, offset 0x80>
	int32_t m_nCounter;

	// <float m_fScale, offset 0x84>
	float m_fScale;

	std::string ToString() const { return "class EffectSlashHit(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectSlashHit, HrTask>("EffectSlashHit")
			.addFunction("__tostring", &EffectSlashHit::ToString)
			.addFunction("GetPtrAddr", &EffectSlashHit::GetPtrAddr)
			.addProperty("m_SlashVec", &EffectSlashHit::m_SlashVec)
			.addProperty("m_SlashPlnNrm", &EffectSlashHit::m_SlashPlnNrm)
			.addProperty("m_pChara", &EffectSlashHit::m_pChara)
			.addProperty("m_Pos", &EffectSlashHit::m_Pos)
			.addProperty("m_eDamageLevel", &EffectSlashHit::m_eDamageLevel)
			.addProperty("m_nColor", &EffectSlashHit::m_nColor)
			.addProperty("m_nCounter", &EffectSlashHit::m_nCounter)
			.addProperty("m_fScale", &EffectSlashHit::m_fScale)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectSlashHit::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSlashHit::m_SlashVec) == 12, "expected m_SlashVec to be size 12");
static_assert(sizeof(EffectSlashHit::m_SlashPlnNrm) == 12, "expected m_SlashPlnNrm to be size 12");
static_assert(sizeof(EffectSlashHit::m_pChara) == 4, "expected m_pChara to be size 4");
static_assert(sizeof(EffectSlashHit::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectSlashHit::m_eDamageLevel) == 4, "expected m_eDamageLevel to be size 4");
static_assert(sizeof(EffectSlashHit::m_nColor) == 4, "expected m_nColor to be size 4");
static_assert(sizeof(EffectSlashHit::m_nCounter) == 4, "expected m_nCounter to be size 4");
static_assert(sizeof(EffectSlashHit::m_fScale) == 4, "expected m_fScale to be size 4");
static_assert(sizeof(EffectSlashHit) == 136, "expected class EffectSlashHit to be size 136");

// [Structure] class FkBoss
class FkBoss : public bsBasic
{
public:
	// [Function] uint8_t __convention("thiscall") FkBoss::mSetDamage(class FkBoss* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10) [?mSetDamage@FkBoss@@UAE_NMHHHMHMMPAVmHRChara@@@Z]
	uint8_t mSetDamage(float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)
	{
		typedef uint8_t(__thiscall* _Func)(class FkBoss* const thisPtr, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10);
		_Func mFunc = (_Func)(GameModule + 0x6392c0);
		return mFunc(this, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	}
	// [Structure] struct FkBoss::GuardParam
	struct GuardParam
	{
	public:
		/// Struct member variables

		// <int32_t GuardBeginCnt, offset 0x0>
		int32_t GuardBeginCnt;

		// <int32_t GuardContinueCnt, offset 0x4>
		int32_t GuardContinueCnt;

		std::string ToString() const { return "struct GuardParam(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkBoss::GuardParam>("FkBoss_GuardParam")
				.addFunction("__tostring", &FkBoss::GuardParam::ToString)
				.addFunction("GetPtrAddr", &FkBoss::GuardParam::GetPtrAddr)
				.addProperty("GuardBeginCnt", &FkBoss::GuardParam::GuardBeginCnt)
				.addProperty("GuardContinueCnt", &FkBoss::GuardParam::GuardContinueCnt)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBoss::GuardParam::GuardBeginCnt) == 4, "expected GuardBeginCnt to be size 4");
	static_assert(sizeof(FkBoss::GuardParam::GuardContinueCnt) == 4, "expected GuardContinueCnt to be size 4");
	static_assert(sizeof(FkBoss::GuardParam) == 8, "expected struct FkBoss::GuardParam to be size 8");

	// enum FkBoss::eReqAvoidDir
	enum eReqAvoidDir : uint32_t
	{
		// <eReqAvoidDir_UNKNOWN = 0xffffffffffffffff>
		eReqAvoidDir_UNKNOWN = UINT32_MAX,

		// <eReqAvoidDir_Side = 0x0>
		eReqAvoidDir_Side = 0,

		// <eReqAvoidDir_Back = 0x1>
		eReqAvoidDir_Back = 1

	};

	/// Struct member variables

	// <class bsBasic field_0, offset 0x0>
	// class bsBasic Super;

	// <int32_t m_ContinueAvoidNum, offset 0xc84>
	int32_t m_ContinueAvoidNum;

	// <int32_t m_GeneralComboAttackArray[0x5][0xa], offset 0xc88>
	int32_t m_GeneralComboAttackArray[5][10];

	// <struct FkBoss::GuardParam m_GuardParam, offset 0xd50>
	struct FkBoss::GuardParam m_GuardParam;

	// <int32_t m_ThinkCnt, offset 0xd58>
	int32_t m_ThinkCnt;

	// <int32_t m_AttackCnt, offset 0xd5c>
	int32_t m_AttackCnt;

	// <enum FightSpirit m_FightSpirit, offset 0xd60>
	enum FightSpirit m_FightSpirit;

	// <int32_t m_ContinueDamageNum, offset 0xd64>
	int32_t m_ContinueDamageNum;

	// <int32_t m_ContinueGuardNum, offset 0xd68>
	int32_t m_ContinueGuardNum;

	// <enum FkBoss::eReqAvoidDir m_eReqAvoidDir, offset 0xd6c>
	enum FkBoss::eReqAvoidDir m_eReqAvoidDir;

	// <uint8_t m_boNoEfGuard, offset 0xd70>
	uint8_t m_boNoEfGuard;

	// <Unidentified data segment, offset 0xd71>
private:
	char _UnidentifiedData11[3];

public:
	// <struct Vec m_FrontDir, offset 0xd74>
	struct Vec m_FrontDir;

	// <class FkStlVector<Vec> m_RunAwayPointArr, offset 0xd80>
	class FkStlVector<Vec> m_RunAwayPointArr;

	// <int32_t m_ComboAttackNo, offset 0xd94>
	int32_t m_ComboAttackNo;

	// <int32_t m_SafetyStateChangeTick, offset 0xd98>
	int32_t m_SafetyStateChangeTick;

	// <float m_fEventAccumDamage, offset 0xd9c>
	float m_fEventAccumDamage;

	// <struct tagGHMR_TEX* m_apTex[0x1], offset 0xda0>
	struct tagGHMR_TEX* m_apTex[1];

	// <class EffectSlashTrack* m_pEfSamasoTrack[0x2], offset 0xda4>
	class EffectSlashTrack* m_pEfSamasoTrack[2];

	std::string ToString() const { return "class FkBoss(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<FkBoss, bsBasic>("FkBoss")
			.addFunction("__tostring", &FkBoss::ToString)
			.addFunction("GetPtrAddr", &FkBoss::GetPtrAddr)
			.addProperty("m_ContinueAvoidNum", &FkBoss::m_ContinueAvoidNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_GeneralComboAttackArray", &FkBoss::m_GeneralComboAttackArray)
			.addProperty("m_GuardParam", &FkBoss::m_GuardParam)
			.addProperty("m_ThinkCnt", &FkBoss::m_ThinkCnt)
			.addProperty("m_AttackCnt", &FkBoss::m_AttackCnt)
			.addProperty("m_FightSpirit", &FkBoss::m_FightSpirit)
			.addProperty("m_ContinueDamageNum", &FkBoss::m_ContinueDamageNum)
			.addProperty("m_ContinueGuardNum", &FkBoss::m_ContinueGuardNum)
			.addProperty("m_eReqAvoidDir", &FkBoss::m_eReqAvoidDir)
			.addProperty("m_boNoEfGuard", &FkBoss::m_boNoEfGuard)
			.addProperty("m_FrontDir", &FkBoss::m_FrontDir)
			.addProperty("m_RunAwayPointArr", &FkBoss::m_RunAwayPointArr)
			.addProperty("m_ComboAttackNo", &FkBoss::m_ComboAttackNo)
			.addProperty("m_SafetyStateChangeTick", &FkBoss::m_SafetyStateChangeTick)
			.addProperty("m_fEventAccumDamage", &FkBoss::m_fEventAccumDamage)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_apTex", &FkBoss::m_apTex)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pEfSamasoTrack", &FkBoss::m_pEfSamasoTrack)
			// Can't export functions with more than 8 parameters to LuaBridge.
			//.addFunction("mSetDamage", &FkBoss::mSetDamage)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkBoss::m_ContinueAvoidNum) == 4, "expected m_ContinueAvoidNum to be size 4");
static_assert(sizeof(FkBoss::m_GeneralComboAttackArray) == 200, "expected m_GeneralComboAttackArray to be size 200");
static_assert(sizeof(FkBoss::m_GuardParam) == 8, "expected m_GuardParam to be size 8");
static_assert(sizeof(FkBoss::m_ThinkCnt) == 4, "expected m_ThinkCnt to be size 4");
static_assert(sizeof(FkBoss::m_AttackCnt) == 4, "expected m_AttackCnt to be size 4");
static_assert(sizeof(FkBoss::m_FightSpirit) == 4, "expected m_FightSpirit to be size 4");
static_assert(sizeof(FkBoss::m_ContinueDamageNum) == 4, "expected m_ContinueDamageNum to be size 4");
static_assert(sizeof(FkBoss::m_ContinueGuardNum) == 4, "expected m_ContinueGuardNum to be size 4");
static_assert(sizeof(FkBoss::m_eReqAvoidDir) == 4, "expected m_eReqAvoidDir to be size 4");
static_assert(sizeof(FkBoss::m_boNoEfGuard) == 1, "expected m_boNoEfGuard to be size 1");
static_assert(sizeof(FkBoss::m_FrontDir) == 12, "expected m_FrontDir to be size 12");
static_assert(sizeof(FkBoss::m_RunAwayPointArr) == 20, "expected m_RunAwayPointArr to be size 20");
static_assert(sizeof(FkBoss::m_ComboAttackNo) == 4, "expected m_ComboAttackNo to be size 4");
static_assert(sizeof(FkBoss::m_SafetyStateChangeTick) == 4, "expected m_SafetyStateChangeTick to be size 4");
static_assert(sizeof(FkBoss::m_fEventAccumDamage) == 4, "expected m_fEventAccumDamage to be size 4");
static_assert(sizeof(FkBoss::m_apTex) == 4, "expected m_apTex to be size 4");
static_assert(sizeof(FkBoss::m_pEfSamasoTrack) == 8, "expected m_pEfSamasoTrack to be size 8");
static_assert(sizeof(FkBoss) == 3500, "expected class FkBoss to be size 3500");

// [Structure] class EffectSlashTrack
class EffectSlashTrack
{
public:
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[944];
public:

	std::string ToString() const { return "class EffectSlashTrack(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectSlashTrack>("EffectSlashTrack")
			.addFunction("__tostring", &EffectSlashTrack::ToString)
			.addFunction("GetPtrAddr", &EffectSlashTrack::GetPtrAddr)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSlashTrack) == 944, "expected class EffectSlashTrack to be size 944");

// [Structure] class EffectBeamDragon
class EffectBeamDragon
{
public:
	// [Function] void __convention("thiscall") EffectBeamDragon::Set(class EffectBeamDragon* const this, struct Vec* arg2, class mHRChara* arg3) [?Set@EffectBeamDragon@@QAEXPAUVec@@PAVmHRChara@@@Z]
	void Set(struct Vec* arg2, class mHRChara* arg3)
	{
		typedef void(__thiscall* _Func)(class EffectBeamDragon* const thisPtr, struct Vec* arg2, class mHRChara* arg3);
		_Func mFunc = (_Func)(GameModule + 0x643840);
		return mFunc(this, arg2, arg3);
	}
	// [Function] class EffectBeamDragon* EffectBeamDragon::Create(struct Vec* arg1, class mHRChara* arg2) [?Create@EffectBeamDragon@@SAPAV1@PAUVec@@PAVmHRChara@@@Z]
	static class EffectBeamDragon* Create(struct Vec* arg1, class mHRChara* arg2)
	{
		typedef class EffectBeamDragon*(__fastcall* _Func)(struct Vec* arg1, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x644130);
		return mFunc(arg1, arg2);
	}
	/// Struct member variables

	// <Unidentified data segment, offset 0x0>
private:
	char _UnidentifiedData[520];
public:

	std::string ToString() const { return "class EffectBeamDragon(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectBeamDragon>("EffectBeamDragon")
			.addFunction("__tostring", &EffectBeamDragon::ToString)
			.addFunction("GetPtrAddr", &EffectBeamDragon::GetPtrAddr)
			.addFunction("Set", &EffectBeamDragon::Set)
			.addStaticFunction("Create", &EffectBeamDragon::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectBeamDragon) == 520, "expected class EffectBeamDragon to be size 520");

// [Structure] class EffectGYNMissile
class EffectGYNMissile : public HrTask
{
public:
	// [Function] void __convention("thiscall") EffectGYNMissile::Set(class EffectGYNMissile* const this, struct Vec& arg2, float const arg3, class mHRChara* arg4) [?Set@EffectGYNMissile@@AAEXABUVec@@MPAVmHRChara@@@Z]
	void Set(struct Vec& arg2, float const arg3, class mHRChara* arg4)
	{
		typedef void(__thiscall* _Func)(class EffectGYNMissile* const thisPtr, struct Vec& arg2, float const arg3, class mHRChara* arg4);
		_Func mFunc = (_Func)(GameModule + 0x646520);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class EffectGYNMissile* EffectGYNMissile::Create(struct Vec& arg1, float const arg2, class mHRChara* arg3) [?Create@EffectGYNMissile@@SAPAV1@ABUVec@@MPAVmHRChara@@@Z]
	static class EffectGYNMissile* Create(struct Vec& arg1, float const arg2, class mHRChara* arg3)
	{
		typedef class EffectGYNMissile*(__fastcall* _Func)(struct Vec& arg1, float const arg2, class mHRChara* arg3);
		_Func mFunc = (_Func)(GameModule + 0x6467a0);
		return mFunc(arg1, arg2, arg3);
	}
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pTgtChar, offset 0x50>
	class mHRChara* m_pTgtChar;

	// <class TGmf* m_pMissileGmf, offset 0x54>
	class TGmf* m_pMissileGmf;

	// <struct Vec m_Pos, offset 0x58>
	struct Vec m_Pos;

	// <struct Vec m_BeforePos, offset 0x64>
	struct Vec m_BeforePos;

	// <struct Vec m_Rot, offset 0x70>
	struct Vec m_Rot;

	// <struct Vec m_MoveVec, offset 0x7c>
	struct Vec m_MoveVec;

	// <struct Vec m_LaunchVec, offset 0x88>
	struct Vec m_LaunchVec;

	// <float m_fRotYSpd, offset 0x94>
	float m_fRotYSpd;

	// <float m_fMoveSpd, offset 0x98>
	float m_fMoveSpd;

	// <int32_t m_Cnt, offset 0x9c>
	int32_t m_Cnt;

	// <int32_t m_SeHnd, offset 0xa0>
	int32_t m_SeHnd;

	// <uint8_t m_boHoming, offset 0xa4>
	uint8_t m_boHoming;

	// <Unidentified data segment, offset 0xa5>
private:
	char _UnidentifiedData[3];
public:

	std::string ToString() const { return "class EffectGYNMissile(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectGYNMissile, HrTask>("EffectGYNMissile")
			.addFunction("__tostring", &EffectGYNMissile::ToString)
			.addFunction("GetPtrAddr", &EffectGYNMissile::GetPtrAddr)
			.addProperty("m_pTgtChar", &EffectGYNMissile::m_pTgtChar)
			.addProperty("m_pMissileGmf", &EffectGYNMissile::m_pMissileGmf)
			.addProperty("m_Pos", &EffectGYNMissile::m_Pos)
			.addProperty("m_BeforePos", &EffectGYNMissile::m_BeforePos)
			.addProperty("m_Rot", &EffectGYNMissile::m_Rot)
			.addProperty("m_MoveVec", &EffectGYNMissile::m_MoveVec)
			.addProperty("m_LaunchVec", &EffectGYNMissile::m_LaunchVec)
			.addProperty("m_fRotYSpd", &EffectGYNMissile::m_fRotYSpd)
			.addProperty("m_fMoveSpd", &EffectGYNMissile::m_fMoveSpd)
			.addProperty("m_Cnt", &EffectGYNMissile::m_Cnt)
			.addProperty("m_SeHnd", &EffectGYNMissile::m_SeHnd)
			.addProperty("m_boHoming", &EffectGYNMissile::m_boHoming)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("Set", &EffectGYNMissile::Set)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectGYNMissile::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectGYNMissile::m_pTgtChar) == 4, "expected m_pTgtChar to be size 4");
static_assert(sizeof(EffectGYNMissile::m_pMissileGmf) == 4, "expected m_pMissileGmf to be size 4");
static_assert(sizeof(EffectGYNMissile::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectGYNMissile::m_BeforePos) == 12, "expected m_BeforePos to be size 12");
static_assert(sizeof(EffectGYNMissile::m_Rot) == 12, "expected m_Rot to be size 12");
static_assert(sizeof(EffectGYNMissile::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(EffectGYNMissile::m_LaunchVec) == 12, "expected m_LaunchVec to be size 12");
static_assert(sizeof(EffectGYNMissile::m_fRotYSpd) == 4, "expected m_fRotYSpd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_fMoveSpd) == 4, "expected m_fMoveSpd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_Cnt) == 4, "expected m_Cnt to be size 4");
static_assert(sizeof(EffectGYNMissile::m_SeHnd) == 4, "expected m_SeHnd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_boHoming) == 1, "expected m_boHoming to be size 1");
static_assert(sizeof(EffectGYNMissile) == 168, "expected class EffectGYNMissile to be size 168");

// [Structure] class EffectMoeMissile
class EffectMoeMissile : public HrTask
{
public:
	// [Function] void __convention("thiscall") EffectMoeMissile::Set(class EffectMoeMissile* const this, struct Vec& arg2, float const arg3, class mHRChara* arg4) [?Set@EffectMoeMissile@@AAEXABUVec@@MPAVmHRChara@@@Z]
	void Set(struct Vec& arg2, float const arg3, class mHRChara* arg4)
	{
		typedef void(__thiscall* _Func)(class EffectMoeMissile* const thisPtr, struct Vec& arg2, float const arg3, class mHRChara* arg4);
		_Func mFunc = (_Func)(GameModule + 0x64a900);
		return mFunc(this, arg2, arg3, arg4);
	}
	// [Function] class EffectMoeMissile* EffectMoeMissile::Create(struct Vec& arg1, float const arg2, class mHRChara* arg3) [?Create@EffectMoeMissile@@SAPAV1@ABUVec@@MPAVmHRChara@@@Z]
	static class EffectMoeMissile* Create(struct Vec& arg1, float const arg2, class mHRChara* arg3)
	{
		typedef class EffectMoeMissile*(__fastcall* _Func)(struct Vec& arg1, float const arg2, class mHRChara* arg3);
		_Func mFunc = (_Func)(GameModule + 0x64a930);
		return mFunc(arg1, arg2, arg3);
	}
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pTgtChar, offset 0x50>
	class mHRChara* m_pTgtChar;

	// <struct Vec m_Pos, offset 0x54>
	struct Vec m_Pos;

	// <struct Vec m_BeforePos, offset 0x60>
	struct Vec m_BeforePos;

	// <struct Vec m_Rot, offset 0x6c>
	struct Vec m_Rot;

	// <struct Vec m_MoveDir, offset 0x78>
	struct Vec m_MoveDir;

	// <struct Vec m_MoveVec, offset 0x84>
	struct Vec m_MoveVec;

	// <uint8_t m_boHoming, offset 0x90>
	uint8_t m_boHoming;

	// <Unidentified data segment, offset 0x91>
private:
	char _UnidentifiedData8[3];

public:
	// <class EffectFixFire* m_pFire, offset 0x94>
	class EffectFixFire* m_pFire;

	// <float m_MatRot[0x3][0x4], offset 0x98>
	float m_MatRot[3][4];

	// <float m_fSpd, offset 0xc8>
	float m_fSpd;

	// <class TGmf* m_pMissileGmf, offset 0xcc>
	class TGmf* m_pMissileGmf;

	std::string ToString() const { return "class EffectMoeMissile(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.deriveClass<EffectMoeMissile, HrTask>("EffectMoeMissile")
			.addFunction("__tostring", &EffectMoeMissile::ToString)
			.addFunction("GetPtrAddr", &EffectMoeMissile::GetPtrAddr)
			.addProperty("m_pTgtChar", &EffectMoeMissile::m_pTgtChar)
			.addProperty("m_Pos", &EffectMoeMissile::m_Pos)
			.addProperty("m_BeforePos", &EffectMoeMissile::m_BeforePos)
			.addProperty("m_Rot", &EffectMoeMissile::m_Rot)
			.addProperty("m_MoveDir", &EffectMoeMissile::m_MoveDir)
			.addProperty("m_MoveVec", &EffectMoeMissile::m_MoveVec)
			.addProperty("m_boHoming", &EffectMoeMissile::m_boHoming)
			.addProperty("m_pFire", &EffectMoeMissile::m_pFire)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_MatRot", &EffectMoeMissile::m_MatRot)
			.addProperty("m_fSpd", &EffectMoeMissile::m_fSpd)
			.addProperty("m_pMissileGmf", &EffectMoeMissile::m_pMissileGmf)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addFunction("Set", &EffectMoeMissile::Set)
			// Can't export & pointer 'struct Vec&' [TypeClass.PointerTypeClass] in LuaBridge
			//.addStaticFunction("Create", &EffectMoeMissile::Create)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectMoeMissile::m_pTgtChar) == 4, "expected m_pTgtChar to be size 4");
static_assert(sizeof(EffectMoeMissile::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectMoeMissile::m_BeforePos) == 12, "expected m_BeforePos to be size 12");
static_assert(sizeof(EffectMoeMissile::m_Rot) == 12, "expected m_Rot to be size 12");
static_assert(sizeof(EffectMoeMissile::m_MoveDir) == 12, "expected m_MoveDir to be size 12");
static_assert(sizeof(EffectMoeMissile::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(EffectMoeMissile::m_boHoming) == 1, "expected m_boHoming to be size 1");
static_assert(sizeof(EffectMoeMissile::m_pFire) == 4, "expected m_pFire to be size 4");
static_assert(sizeof(EffectMoeMissile::m_MatRot) == 48, "expected m_MatRot to be size 48");
static_assert(sizeof(EffectMoeMissile::m_fSpd) == 4, "expected m_fSpd to be size 4");
static_assert(sizeof(EffectMoeMissile::m_pMissileGmf) == 4, "expected m_pMissileGmf to be size 4");
static_assert(sizeof(EffectMoeMissile) == 208, "expected class EffectMoeMissile to be size 208");

// [Structure] class CMotionPlayer
class CMotionPlayer
{
public:
	// [Function] void __convention("thiscall") CMotionPlayer::begin(class CMotionPlayer* const this, class mHRChara* arg2) [?begin@CMotionPlayer@@QAEXPAVmHRChara@@@Z]
	void begin(class mHRChara* arg2)
	{
		typedef void(__thiscall* _Func)(class CMotionPlayer* const thisPtr, class mHRChara* arg2);
		_Func mFunc = (_Func)(GameModule + 0x697c70);
		return mFunc(this, arg2);
	}
	// [Structure] class CMotionPlayer::CElement
	class CElement
	{
	public:
		/// Struct member variables

		// <int32_t m_nMotIndex, offset 0x0>
		int32_t m_nMotIndex;

		// <enum HRCAMERA_MODE m_eCamMode, offset 0x4>
		enum HRCAMERA_MODE m_eCamMode;

		std::string ToString() const { return "class CElement(" + std::to_string(GetPtrAddr()) + ")"; }
		int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CMotionPlayer::CElement>("CMotionPlayer_CElement")
				.addFunction("__tostring", &CMotionPlayer::CElement::ToString)
				.addFunction("GetPtrAddr", &CMotionPlayer::CElement::GetPtrAddr)
				.addProperty("m_nMotIndex", &CMotionPlayer::CElement::m_nMotIndex)
				.addProperty("m_eCamMode", &CMotionPlayer::CElement::m_eCamMode)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(CMotionPlayer::CElement::m_nMotIndex) == 4, "expected m_nMotIndex to be size 4");
	static_assert(sizeof(CMotionPlayer::CElement::m_eCamMode) == 4, "expected m_eCamMode to be size 4");
	static_assert(sizeof(CMotionPlayer::CElement) == 8, "expected class CMotionPlayer::CElement to be size 8");

	/// Struct member variables

	// <class CStlVector<CMotionPlayer::CElement> m_ainElement, offset 0x0>
	class std::vector<CMotionPlayer::CElement> m_ainElement;

	// <class mHRChara* m_pChara, offset 0xc>
	class mHRChara* m_pChara;

	// <int32_t m_nPlayIndex, offset 0x10>
	int32_t m_nPlayIndex;

	std::string ToString() const { return "class CMotionPlayer(" + std::to_string(GetPtrAddr()) + ")"; }
	int GetPtrAddr() const { return (int)this; }
#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CMotionPlayer>("CMotionPlayer")
			.addFunction("__tostring", &CMotionPlayer::ToString)
			.addFunction("GetPtrAddr", &CMotionPlayer::GetPtrAddr)
			.addProperty("m_ainElement", &CMotionPlayer::m_ainElement)
			.addProperty("m_pChara", &CMotionPlayer::m_pChara)
			.addProperty("m_nPlayIndex", &CMotionPlayer::m_nPlayIndex)
			.addFunction("begin", &CMotionPlayer::begin)
		.endClass();
	}
#endif
};
static_assert(sizeof(CMotionPlayer::m_ainElement) == 12, "expected m_ainElement to be size 12");
static_assert(sizeof(CMotionPlayer::m_pChara) == 4, "expected m_pChara to be size 4");
static_assert(sizeof(CMotionPlayer::m_nPlayIndex) == 4, "expected m_nPlayIndex to be size 4");
static_assert(sizeof(CMotionPlayer) == 20, "expected class CMotionPlayer to be size 20");


#ifdef WITH_LUA
/// Lua binding

void BindLua_Exported(luabridge::Namespace& NS)
{
#ifdef LOG_INIT
	std::cout << "Binding 'struct stBtEffect'" << std::endl;
#endif
	stBtEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct Vec'" << std::endl;
#endif
	Vec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRBattle'" << std::endl;
#endif
	mHRBattle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CTimeRatioInterpolate'" << std::endl;
#endif
	CTimeRatioInterpolate::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'union uniSMflag'" << std::endl;
#endif
	uniSMflag::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stFade'" << std::endl;
#endif
	stFade::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CSpringInterpolate'" << std::endl;
#endif
	CSpringInterpolate::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CDoubleSpringInterpolate'" << std::endl;
#endif
	CDoubleSpringInterpolate::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CAmbientShadow'" << std::endl;
#endif
	CAmbientShadow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stCharaEffect'" << std::endl;
#endif
	stCharaEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class stCharaFileData'" << std::endl;
#endif
	stCharaFileData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmSegment'" << std::endl;
#endif
	ghmSegment::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmCapsule'" << std::endl;
#endif
	ghmCapsule::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcOctTreeNodeObj'" << std::endl;
#endif
	ghmGcOctTreeNodeObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObj'" << std::endl;
#endif
	ghmGcCollObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObjCapsule'" << std::endl;
#endif
	ghmGcCollObjCapsule::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WAnim'" << std::endl;
#endif
	WAnim::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WAnimF'" << std::endl;
#endif
	WAnimF::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stDamageInfo'" << std::endl;
#endif
	stDamageInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmTriangle'" << std::endl;
#endif
	ghmTriangle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmPlane'" << std::endl;
#endif
	ghmPlane::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObjHitResultObj'" << std::endl;
#endif
	ghmGcCollObjHitResultObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stVec'" << std::endl;
#endif
	stVec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct Quaternion'" << std::endl;
#endif
	Quaternion::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stCharaStatus'" << std::endl;
#endif
	stCharaStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmListObj'" << std::endl;
#endif
	ghmListObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct CharControlMotID'" << std::endl;
#endif
	CharControlMotID::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GXColor'" << std::endl;
#endif
	GXColor::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'union __m128'" << std::endl;
#endif
	__m128::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class vector4f'" << std::endl;
#endif
	vector4f::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class vector4x'" << std::endl;
#endif
	vector4x::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class tiVector'" << std::endl;
#endif
	tiVector::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::IBoneEffectModel'" << std::endl;
#endif
	mot::IBoneEffectModel::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::IBoneEffectModelPJ'" << std::endl;
#endif
	mot::IBoneEffectModelPJ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGmf::tagMAIN'" << std::endl;
#endif
	TGmf::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGmf'" << std::endl;
#endif
	TGmf::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class NYPhase'" << std::endl;
#endif
	NYPhase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class NYApproachToTargetVal'" << std::endl;
#endif
	NYApproachToTargetVal::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrTask'" << std::endl;
#endif
	HrTask::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrBattleIcon::CHrHpGauge'" << std::endl;
#endif
	HrBattleIcon::CHrHpGauge::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrBattleIcon'" << std::endl;
#endif
	HrBattleIcon::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRChara'" << std::endl;
#endif
	mHRChara::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HROBJDummy'" << std::endl;
#endif
	HROBJDummy::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stTiger'" << std::endl;
#endif
	stTiger::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stHugWalk'" << std::endl;
#endif
	stHugWalk::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stPcEffect'" << std::endl;
#endif
	stPcEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stPcSndData'" << std::endl;
#endif
	stPcSndData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stDarkSideInfo'" << std::endl;
#endif
	stDarkSideInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stPcSaveData'" << std::endl;
#endif
	stPcSaveData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stMiniDemo'" << std::endl;
#endif
	stMiniDemo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stPcStatus'" << std::endl;
#endif
	stPcStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRPc'" << std::endl;
#endif
	mHRPc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmAABB'" << std::endl;
#endif
	ghmAABB::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcOctTreeNode'" << std::endl;
#endif
	ghmGcOctTreeNode::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcOctTree'" << std::endl;
#endif
	ghmGcOctTree::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcCollObjHitResult'" << std::endl;
#endif
	ghmGcCollObjHitResult::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclMaterialSpec'" << std::endl;
#endif
	WGclMaterialSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct DVDCommandBlock'" << std::endl;
#endif
	DVDCommandBlock::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct DVDFileInfo'" << std::endl;
#endif
	DVDFileInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmGcFile::ghmGcFileInfo'" << std::endl;
#endif
	ghmGcFile::ghmGcFileInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcFile'" << std::endl;
#endif
	ghmGcFile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct DVDDiskID'" << std::endl;
#endif
	DVDDiskID::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EE::RefObject'" << std::endl;
#endif
	EE::RefObject::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EE::IFile'" << std::endl;
#endif
	EE::IFile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmResGroup'" << std::endl;
#endif
	ghmResGroup::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmResStrTable'" << std::endl;
#endif
	ghmResStrTable::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGanPlay::MAIN'" << std::endl;
#endif
	TGanPlay::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGanPlay'" << std::endl;
#endif
	TGanPlay::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGan::tagMAIN'" << std::endl;
#endif
	TGan::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGan'" << std::endl;
#endif
	TGan::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanSpec'" << std::endl;
#endif
	WGanSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanMaterialSpec'" << std::endl;
#endif
	WGanMaterialSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanFAnmSpec'" << std::endl;
#endif
	WGanFAnmSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct _WFAnmObjHeader'" << std::endl;
#endif
	_WFAnmObjHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct _WFAnmObjKeyListHeader'" << std::endl;
#endif
	_WFAnmObjKeyListHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanMaterialLayerSpec'" << std::endl;
#endif
	WGanMaterialLayerSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGanNodeSpec'" << std::endl;
#endif
	WGanNodeSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGanPlayNode::MAIN'" << std::endl;
#endif
	TGanPlayNode::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGanPlayNode'" << std::endl;
#endif
	TGanPlayNode::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TFAnm::tagMAIN'" << std::endl;
#endif
	TFAnm::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TFAnm'" << std::endl;
#endif
	TFAnm::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGmfNode::tagMAIN'" << std::endl;
#endif
	TGmfNode::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TGmfNode'" << std::endl;
#endif
	TGmfNode::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CViewClipObjSphere'" << std::endl;
#endif
	CViewClipObjSphere::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CViewClipObjBox'" << std::endl;
#endif
	CViewClipObjBox::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rPrimUnific'" << std::endl;
#endif
	rPrimUnific::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfBase'" << std::endl;
#endif
	EfBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfDestortion'" << std::endl;
#endif
	EfDestortion::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TGMFMESH'" << std::endl;
#endif
	TGMFMESH::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GXTexObj'" << std::endl;
#endif
	GXTexObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagGHMR_TEX'" << std::endl;
#endif
	tagGHMR_TEX::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'union GXSamplerStuff'" << std::endl;
#endif
	GXSamplerStuff::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GXTexture::GXSpecs'" << std::endl;
#endif
	GXTexture::GXSpecs::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GXTexture'" << std::endl;
#endif
	GXTexture::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rAlphaAnime'" << std::endl;
#endif
	rAlphaAnime::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rAnimeCounter'" << std::endl;
#endif
	rAnimeCounter::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rST'" << std::endl;
#endif
	rST::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct rColor'" << std::endl;
#endif
	rColor::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rPrimBase'" << std::endl;
#endif
	rPrimBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rTriangleList'" << std::endl;
#endif
	rTriangleList::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CVertexAnimation::CVertex'" << std::endl;
#endif
	CVertexAnimation::CVertex::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CVertexAnimation'" << std::endl;
#endif
	CVertexAnimation::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TFAnmObjF32_3::tagMAIN'" << std::endl;
#endif
	TFAnmObjF32_3::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TFAnmObjF32_3'" << std::endl;
#endif
	TFAnmObjF32_3::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'union _WFAnmVal'" << std::endl;
#endif
	_WFAnmVal::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TFAnmObj::tagGETA'" << std::endl;
#endif
	TFAnmObj::tagGETA::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct TFAnmObj::tagMAIN'" << std::endl;
#endif
	TFAnmObj::tagMAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class TFAnmObj'" << std::endl;
#endif
	TFAnmObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::IBoneEffectPJ'" << std::endl;
#endif
	mot::IBoneEffectPJ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraVibTiming'" << std::endl;
#endif
	CCameraVibTiming::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HRCHARAVOICE'" << std::endl;
#endif
	HRCHARAVOICE::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class gameUtil::CPlane'" << std::endl;
#endif
	gameUtil::CPlane::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CStickShadow'" << std::endl;
#endif
	CStickShadow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CharController'" << std::endl;
#endif
	CharController::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CObjectShadow'" << std::endl;
#endif
	CObjectShadow::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stBikeEffect'" << std::endl;
#endif
	stBikeEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stBike'" << std::endl;
#endif
	stBike::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRBike'" << std::endl;
#endif
	mHRBike::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EventAreaCircle'" << std::endl;
#endif
	EventAreaCircle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptVariables'" << std::endl;
#endif
	ghmScriptVariables::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScript'" << std::endl;
#endif
	ghmScript::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptFunc'" << std::endl;
#endif
	ghmScriptFunc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrScriptFunc'" << std::endl;
#endif
	HrScriptFunc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptBase'" << std::endl;
#endif
	ghmScriptBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraCollision'" << std::endl;
#endif
	CCameraCollision::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkPjLib'" << std::endl;
#endif
	FkPjLib::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptFuncArgBase'" << std::endl;
#endif
	ghmScriptFuncArgBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmScriptObjectType'" << std::endl;
#endif
	ghmScriptObjectType::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptObject'" << std::endl;
#endif
	ghmScriptObject::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmString'" << std::endl;
#endif
	ghmString::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmScrHeader'" << std::endl;
#endif
	ghmScrHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmScrFuncHeader'" << std::endl;
#endif
	ghmScrFuncHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptProgFunc'" << std::endl;
#endif
	ghmScriptProgFunc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ghmScriptStackData'" << std::endl;
#endif
	ghmScriptStackData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptStack'" << std::endl;
#endif
	ghmScriptStack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmScriptContext'" << std::endl;
#endif
	ghmScriptContext::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EveCorn'" << std::endl;
#endif
	EveCorn::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EventAreaCamera'" << std::endl;
#endif
	EventAreaCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EVENTAREACAMERA_DATA'" << std::endl;
#endif
	EVENTAREACAMERA_DATA::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectDriftMark'" << std::endl;
#endif
	EffectDriftMark::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectKeepSmoke'" << std::endl;
#endif
	EffectKeepSmoke::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rQuad'" << std::endl;
#endif
	rQuad::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectFixFire::Object'" << std::endl;
#endif
	EffectFixFire::Object::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectFixFire'" << std::endl;
#endif
	EffectFixFire::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrOverLap'" << std::endl;
#endif
	HrOverLap::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrScreenStatus'" << std::endl;
#endif
	HrScreenStatus::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrEffectShutter'" << std::endl;
#endif
	HrEffectShutter::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EfSmoke::SmokePrim'" << std::endl;
#endif
	EfSmoke::SmokePrim::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfSmoke'" << std::endl;
#endif
	EfSmoke::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HRSAVEDATA_DEBUNEKO'" << std::endl;
#endif
	HRSAVEDATA_DEBUNEKO::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WGcl'" << std::endl;
#endif
	WGcl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class commonObj'" << std::endl;
#endif
	commonObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CustomColliderObj'" << std::endl;
#endif
	CustomColliderObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclSpec'" << std::endl;
#endif
	WGclSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclNodeSpec'" << std::endl;
#endif
	WGclNodeSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclNodeShapeMeshSpec'" << std::endl;
#endif
	WGclNodeShapeMeshSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclNodeShapeMeshBspNodeSpec'" << std::endl;
#endif
	WGclNodeShapeMeshBspNodeSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct WGclNodeShapeTriangleSpec'" << std::endl;
#endif
	WGclNodeShapeTriangleSpec::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcColl'" << std::endl;
#endif
	ghmGcColl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WGclNode'" << std::endl;
#endif
	WGclNode::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CSpringInterpolate3D'" << std::endl;
#endif
	CSpringInterpolate3D::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CDoubleSpringInterpolate3D'" << std::endl;
#endif
	CDoubleSpringInterpolate3D::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CBoneEffectDamageData'" << std::endl;
#endif
	mot::CBoneEffectDamageData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CGameDataLink'" << std::endl;
#endif
	CGameDataLink::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CBoneEffectManager'" << std::endl;
#endif
	mot::CBoneEffectManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CBoneEffectPJ'" << std::endl;
#endif
	mot::CBoneEffectPJ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CGameData'" << std::endl;
#endif
	CGameData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CPackFileDataElement'" << std::endl;
#endif
	CPackFileDataElement::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CFileData'" << std::endl;
#endif
	CFileData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CPackFileData'" << std::endl;
#endif
	CPackFileData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CGameDataManager'" << std::endl;
#endif
	CGameDataManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::IBoneEffect'" << std::endl;
#endif
	mot::IBoneEffect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CIKManager'" << std::endl;
#endif
	mot::CIKManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mot::CYuremonoManager'" << std::endl;
#endif
	mot::CYuremonoManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class mHRLockOnList'" << std::endl;
#endif
	mHRLockOnList::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectEnemyDamage'" << std::endl;
#endif
	EffectEnemyDamage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMap'" << std::endl;
#endif
	HrMap::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct stThrowInfo'" << std::endl;
#endif
	stThrowInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMessage'" << std::endl;
#endif
	HrMessage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ghmGcFont'" << std::endl;
#endif
	ghmGcFont::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class WGdl'" << std::endl;
#endif
	WGdl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GdlHeader'" << std::endl;
#endif
	GdlHeader::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GdlDialog'" << std::endl;
#endif
	GdlDialog::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GdlLines'" << std::endl;
#endif
	GdlLines::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct GdlSentence'" << std::endl;
#endif
	GdlSentence::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ACameraModeBase'" << std::endl;
#endif
	ACameraModeBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeLockOn'" << std::endl;
#endif
	CCameraModeLockOn::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct HRSAVEDATA_SHOP'" << std::endl;
#endif
	HRSAVEDATA_SHOP::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraVibManager'" << std::endl;
#endif
	CCameraVibManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraBank'" << std::endl;
#endif
	CCameraBank::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeSubjective'" << std::endl;
#endif
	CCameraModeSubjective::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModePetitMovie'" << std::endl;
#endif
	CCameraModePetitMovie::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeCircle'" << std::endl;
#endif
	CCameraModeCircle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeDefaultAngle'" << std::endl;
#endif
	CCameraModeDefaultAngle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeFree'" << std::endl;
#endif
	CCameraModeFree::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeNormal'" << std::endl;
#endif
	CCameraModeNormal::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeReset'" << std::endl;
#endif
	CCameraModeReset::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraDistToLookAt'" << std::endl;
#endif
	CCameraDistToLookAt::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraFollowRot'" << std::endl;
#endif
	CCameraFollowRot::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraLookAtOffset'" << std::endl;
#endif
	CCameraLookAtOffset::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraLookAtBase'" << std::endl;
#endif
	CCameraLookAtBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraDefaultAngle'" << std::endl;
#endif
	CCameraDefaultAngle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraLockOnModeData'" << std::endl;
#endif
	CCameraLockOnModeData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraNormalModeData'" << std::endl;
#endif
	CCameraNormalModeData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraModeCommonData'" << std::endl;
#endif
	CCameraModeCommonData::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraDataManager'" << std::endl;
#endif
	CCameraDataManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraAreaManager'" << std::endl;
#endif
	CCameraAreaManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class gameUtil::CPositionControl'" << std::endl;
#endif
	gameUtil::CPositionControl::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraTarget'" << std::endl;
#endif
	CCameraTarget::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ti::CCamera'" << std::endl;
#endif
	ti::CCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CGameCamera'" << std::endl;
#endif
	CGameCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CCameraman'" << std::endl;
#endif
	CCameraman::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMiniDemoObj'" << std::endl;
#endif
	HrMiniDemoObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class HrMiniDemoModel'" << std::endl;
#endif
	HrMiniDemoModel::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class STG0202'" << std::endl;
#endif
	STG0202::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagHRTASKCHECK'" << std::endl;
#endif
	tagHRTASKCHECK::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectBoneElect'" << std::endl;
#endif
	EffectBoneElect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class BoneStreamObj'" << std::endl;
#endif
	BoneStreamObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectMetalElect'" << std::endl;
#endif
	EffectMetalElect::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectCutMark'" << std::endl;
#endif
	EffectCutMark::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJTateshi'" << std::endl;
#endif
	PJTateshi::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJState'" << std::endl;
#endif
	PJState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkState_DownAttack'" << std::endl;
#endif
	ZkState_DownAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_AwayAfterAttack'" << std::endl;
#endif
	State_AwayAfterAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_CloseBeforeAttack'" << std::endl;
#endif
	State_CloseBeforeAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_StepInAttack'" << std::endl;
#endif
	State_StepInAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_DownDamage'" << std::endl;
#endif
	State_DownDamage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_TojoBaseState'" << std::endl;
#endif
	State_TojoBaseState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_LeadPcWayPointMove'" << std::endl;
#endif
	State_LeadPcWayPointMove::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_FixTurret'" << std::endl;
#endif
	State_FixTurret::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_WayPointMoveAfterPop'" << std::endl;
#endif
	State_WayPointMoveAfterPop::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_RoomRunner'" << std::endl;
#endif
	State_Tojo_RoomRunner::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_AeroBike'" << std::endl;
#endif
	State_Tojo_AeroBike::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_BreakCmnObj'" << std::endl;
#endif
	State_Tojo_BreakCmnObj::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_JumpOff'" << std::endl;
#endif
	State_Tojo_JumpOff::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Car'" << std::endl;
#endif
	State_Tojo_Car::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_RunAndTurnPc'" << std::endl;
#endif
	State_Tojo_RunAndTurnPc::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Idle'" << std::endl;
#endif
	State_Idle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_AgainstWall'" << std::endl;
#endif
	State_Tojo_AgainstWall::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_LookAround'" << std::endl;
#endif
	State_Tojo_LookAround::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Stand'" << std::endl;
#endif
	State_Tojo_Stand::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Bench'" << std::endl;
#endif
	State_Tojo_Bench::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Sit'" << std::endl;
#endif
	State_Tojo_Sit::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_SuddenAttack'" << std::endl;
#endif
	State_Tojo_SuddenAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_ReleaseWaitIdle'" << std::endl;
#endif
	State_ReleaseWaitIdle::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Base'" << std::endl;
#endif
	State_Scare_Base::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Kosinukasi'" << std::endl;
#endif
	State_Scare_Kosinukasi::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Run'" << std::endl;
#endif
	State_Scare_Run::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_WayPointMove'" << std::endl;
#endif
	State_WayPointMove::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Pressure'" << std::endl;
#endif
	State_Pressure::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_ThroughDamage'" << std::endl;
#endif
	State_ThroughDamage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Defence'" << std::endl;
#endif
	State_Defence::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Evacuate'" << std::endl;
#endif
	State_Evacuate::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_ComboAttack'" << std::endl;
#endif
	State_ComboAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Damage'" << std::endl;
#endif
	State_Damage::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct CollInfo'" << std::endl;
#endif
	CollInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ZkGuardParam'" << std::endl;
#endif
	ZkGuardParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ZkEvacuateParam'" << std::endl;
#endif
	ZkEvacuateParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkCounter'" << std::endl;
#endif
	FkCounter::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct ZkSetDamageInfo'" << std::endl;
#endif
	ZkSetDamageInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Yotunbai'" << std::endl;
#endif
	State_Scare_Yotunbai::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Scare_Stand'" << std::endl;
#endif
	State_Scare_Stand::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_RandomMove'" << std::endl;
#endif
	State_RandomMove::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_PerformIll'" << std::endl;
#endif
	State_PerformIll::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::ZakoInfo'" << std::endl;
#endif
	PJZAKO::ZakoInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::MotionInfo'" << std::endl;
#endif
	PJZAKO::MotionInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::TojoInfo'" << std::endl;
#endif
	PJZAKO::TojoInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::PcInfo'" << std::endl;
#endif
	PJZAKO::PcInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::DmgInfo'" << std::endl;
#endif
	PJZAKO::DmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::AiInfo'" << std::endl;
#endif
	PJZAKO::AiInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct PJZAKO::EfDanmen'" << std::endl;
#endif
	PJZAKO::EfDanmen::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZAKO'" << std::endl;
#endif
	PJZAKO::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJStateMachine'" << std::endl;
#endif
	PJStateMachine::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectDanmenFlash'" << std::endl;
#endif
	EffectDanmenFlash::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectQuestion'" << std::endl;
#endif
	EffectQuestion::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZakoMotMng'" << std::endl;
#endif
	PJZakoMotMng::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PathPlanner'" << std::endl;
#endif
	PathPlanner::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkDynamicParam::DynamicParam'" << std::endl;
#endif
	FkDynamicParam::DynamicParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkDynamicParam'" << std::endl;
#endif
	FkDynamicParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkObstacleSensor'" << std::endl;
#endif
	FkObstacleSensor::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkBulletManager::stEfBullet'" << std::endl;
#endif
	FkBulletManager::stEfBullet::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkBulletManager::DmgInfo'" << std::endl;
#endif
	FkBulletManager::DmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkBulletManager'" << std::endl;
#endif
	FkBulletManager::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectFkTobiDoguBase::strHitCheck'" << std::endl;
#endif
	EffectFkTobiDoguBase::strHitCheck::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectFkTobiDoguBase::HitObjInfo'" << std::endl;
#endif
	EffectFkTobiDoguBase::HitObjInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectFkTobiDoguBase'" << std::endl;
#endif
	EffectFkTobiDoguBase::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rQuadEx'" << std::endl;
#endif
	rQuadEx::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectGunTrack'" << std::endl;
#endif
	EffectGunTrack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class pcSNB'" << std::endl;
#endif
	pcSNB::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class State_Tojo_Knife_SuddenAttack'" << std::endl;
#endif
	State_Tojo_Knife_SuddenAttack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class ZkKnifeState_ThroughKnife'" << std::endl;
#endif
	ZkKnifeState_ThroughKnife::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZAKOBoneB'" << std::endl;
#endif
	PJZAKOBoneB::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJZakoKnife'" << std::endl;
#endif
	PJZakoKnife::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsSKE'" << std::endl;
#endif
	bsSKE::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsLEZ'" << std::endl;
#endif
	bsLEZ::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsCEW'" << std::endl;
#endif
	bsCEW::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsAST'" << std::endl;
#endif
	bsAST::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsRKT'" << std::endl;
#endif
	bsRKT::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBDeathState'" << std::endl;
#endif
	GLBDeathState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBWalkState'" << std::endl;
#endif
	GLBWalkState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBComboState'" << std::endl;
#endif
	GLBComboState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBIdleState'" << std::endl;
#endif
	GLBIdleState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBJampState'" << std::endl;
#endif
	GLBJampState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class rSideScrollCamera'" << std::endl;
#endif
	rSideScrollCamera::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBDamageState'" << std::endl;
#endif
	GLBDamageState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBGuardState'" << std::endl;
#endif
	GLBGuardState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class GLBAirKickState'" << std::endl;
#endif
	GLBAirKickState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct pcGLB::DmgInfo'" << std::endl;
#endif
	pcGLB::DmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct pcGLB::TickCnt'" << std::endl;
#endif
	pcGLB::TickCnt::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class pcGLB'" << std::endl;
#endif
	pcGLB::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfRoboInterface'" << std::endl;
#endif
	EfRoboInterface::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSpeedBlur'" << std::endl;
#endif
	EffectSpeedBlur::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CmDeathState'" << std::endl;
#endif
	CmDeathState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPDeathState'" << std::endl;
#endif
	SDPDeathState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPComboState'" << std::endl;
#endif
	SDPComboState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CmDamageState'" << std::endl;
#endif
	CmDamageState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPDamageState'" << std::endl;
#endif
	SDPDamageState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPBeamState'" << std::endl;
#endif
	SDPBeamState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CmIdleState'" << std::endl;
#endif
	CmIdleState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPIdleState'" << std::endl;
#endif
	SDPIdleState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::PcInfo'" << std::endl;
#endif
	bsBasic::PcInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::SurroundInfo'" << std::endl;
#endif
	bsBasic::SurroundInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::DistSense'" << std::endl;
#endif
	bsBasic::DistSense::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::TickCnt'" << std::endl;
#endif
	bsBasic::TickCnt::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::BattleParam'" << std::endl;
#endif
	bsBasic::BattleParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct bsBasic::DmgInfo'" << std::endl;
#endif
	bsBasic::DmgInfo::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsBasic'" << std::endl;
#endif
	bsBasic::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPMoveState'" << std::endl;
#endif
	SDPMoveState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class SDPGuardState'" << std::endl;
#endif
	SDPGuardState::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class bsSDP'" << std::endl;
#endif
	bsSDP::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkTriangleList'" << std::endl;
#endif
	FkTriangleList::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectModelBeam'" << std::endl;
#endif
	EffectModelBeam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkVtx'" << std::endl;
#endif
	FkVtx::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EfGeneralBeam'" << std::endl;
#endif
	EfGeneralBeam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0029'" << std::endl;
#endif
	PJOBJ0029::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0033'" << std::endl;
#endif
	PJOBJ0033::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EFFECTSIMPLEOBJ3PARAM'" << std::endl;
#endif
	EFFECTSIMPLEOBJ3PARAM::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EFFECTMODELFIREPARAM'" << std::endl;
#endif
	EFFECTMODELFIREPARAM::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectModelFire::MAIN'" << std::endl;
#endif
	EffectModelFire::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectModelFire'" << std::endl;
#endif
	EffectModelFire::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectSimpleObj3::MAIN'" << std::endl;
#endif
	EffectSimpleObj3::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectSimpleObj3::OBJECT'" << std::endl;
#endif
	EffectSimpleObj3::OBJECT::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSimpleObj3'" << std::endl;
#endif
	EffectSimpleObj3::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct tagTLIST'" << std::endl;
#endif
	tagTLIST::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0036'" << std::endl;
#endif
	PJOBJ0036::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0037'" << std::endl;
#endif
	PJOBJ0037::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0104'" << std::endl;
#endif
	PJOBJ0104::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0155'" << std::endl;
#endif
	PJOBJ0155::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJOBJ0190'" << std::endl;
#endif
	PJOBJ0190::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class PJPTR'" << std::endl;
#endif
	PJPTR::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkDbgInfo_EventArea'" << std::endl;
#endif
	FkDbgInfo_EventArea::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkGlobalDBG::CommonObjSetInf'" << std::endl;
#endif
	FkGlobalDBG::CommonObjSetInf::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkGlobalDBG'" << std::endl;
#endif
	FkGlobalDBG::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectBloodSplash::MAIN'" << std::endl;
#endif
	EffectBloodSplash::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectBloodSplash'" << std::endl;
#endif
	EffectBloodSplash::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct EffectSimpleObj2::MAIN'" << std::endl;
#endif
	EffectSimpleObj2::MAIN::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSimpleObj2'" << std::endl;
#endif
	EffectSimpleObj2::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSlashHit'" << std::endl;
#endif
	EffectSlashHit::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'struct FkBoss::GuardParam'" << std::endl;
#endif
	FkBoss::GuardParam::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class FkBoss'" << std::endl;
#endif
	FkBoss::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectSlashTrack'" << std::endl;
#endif
	EffectSlashTrack::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectBeamDragon'" << std::endl;
#endif
	EffectBeamDragon::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectGYNMissile'" << std::endl;
#endif
	EffectGYNMissile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class EffectMoeMissile'" << std::endl;
#endif
	EffectMoeMissile::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CMotionPlayer::CElement'" << std::endl;
#endif
	CMotionPlayer::CElement::BindLua(NS);
#ifdef LOG_INIT
	std::cout << "Binding 'class CMotionPlayer'" << std::endl;
#endif
	CMotionPlayer::BindLua(NS);
}
#endif
