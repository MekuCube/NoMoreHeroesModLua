// Exporter by @MekuCube

#pragma once

/// Forward Declaration

// TODO: Function 'int32_t `dynamic initializer for 'mHRChara::mCharaAnchor''()'
class CSpringInterpolate;
class CDoubleSpringInterpolate;
class CAmbientShadow;
struct stCharaEffect;
class stCharaFileData;
struct Vec;
class ghmSegment;
class ghmCapsule;
class ghmGcOctTreeNodeObj;
class ghmGcCollObj;
class ghmGcCollObjCapsule;
class WAnim;
class WAnimF;
struct stDamageInfo;
class ghmTriangle;
class ghmPlane;
class ghmGcCollObjHitResultObj;
struct stVec;
struct Quaternion;
struct stCharaStatus;
class ghmListObj;
class mHRChara;
class ghmAABB;
class ghmGcOctTreeNode;
class ghmGcOctTree;
class ghmGcCollObjHitResult;
struct WGclMaterialSpec;
namespace EE
{
	template<typename T>
	class SmartPtr;
}
struct DVDCommandBlock;
struct DVDFileInfo;
class ghmGcFile;
struct DVDDiskID;
namespace EE
{
	class RefObject;
}
namespace EE
{
	class IFile;
}
class ghmResGroup;
class ghmResStrTable;
class vector4f;
class vector4x;
class tiVector;
namespace mot
{
	class IBoneEffectModel;
}
namespace mot
{
	class IBoneEffectModelPJ;
}
class TGmf;
class TGanPlay;
class TGan;
struct WGanSpec;
struct WGanMaterialSpec;
struct WGanFAnmSpec;
struct _WFAnmObjHeader;
struct _WFAnmObjKeyListHeader;
struct WGanMaterialLayerSpec;
struct WGanNodeSpec;
class TGanPlayNode;
class TFAnm;
class TGmfNode;
class CViewClipObjSphere;
class CViewClipObjBox;
class rPrimUnific;
class EfBase;
class HrTask;
class EfDestortion;
struct TGMFMESH;
struct GXTexObj;
struct tagGHMR_TEX;
class GXTexture;
struct rAlphaAnime;
struct rAnimeCounter;
struct rST;
struct rColor;
class rPrimBase;
class rTriangleList;
class CVertexAnimation;
class TFAnmObjF32_3;
class TFAnmObj;
namespace mot
{
	class IBoneEffectPJ;
}
class CCameraVibTiming;
struct HRCHARAVOICE;
namespace gameUtil
{
	class CPlane;
}
class CStickShadow;
struct CharControlMotID;
class CharController;
class CTimeRatioInterpolate;
struct stFade;
class HROBJDummy;
struct stTiger;
struct stHugWalk;
struct stPcEffect;
struct stPcSndData;
struct stDarkSideInfo;
struct stPcSaveData;
struct stMiniDemo;
struct stPcStatus;
class mHRPc;
class CObjectShadow;
struct stBikeEffect;
struct stBike;
class mHRBike;
class EventAreaCircle;
class ghmScriptVariables;
class ghmScript;
class ghmScriptFunc;
class HrScriptFunc;
class ghmScriptBase;
class CCameraCollision;
class FkPjLib;
class ghmScriptFuncArgBase;
struct ghmScriptObjectType;
class ghmScriptObject;
class ghmString;
struct ghmScrHeader;
struct ghmScrFuncHeader;
class ghmScriptProgFunc;
struct ghmScriptStackData;
class ghmScriptStack;
class ghmScriptContext;
class EveCorn;
class EventAreaCamera;
struct EVENTAREACAMERA_DATA;
class EffectDriftMark;
class EffectKeepSmoke;
class rQuad;
struct GXColor;
class EffectFixFire;
class HrOverLap;
class WGcl;
class commonObj;
class CustomColliderObj;
struct WGclSpec;
struct WGclNodeSpec;
struct WGclNodeShapeMeshSpec;
struct WGclNodeShapeMeshBspNodeSpec;
struct WGclNodeShapeTriangleSpec;
class ghmGcColl;
class WGclNode;
// TODO: Function 'enum mot::CBoneEffectDamageData::EAttackType __convention("thiscall") mot::CBoneEffectPJ::getAttackType(class mot::CBoneEffectPJ* const this, class mHRChara* arg2)'
namespace mot
{
	class CBoneEffectDamageData;
}
// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnFinishDemo(class mHRChara* const this, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4)'
// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnFinishDemo(class mHRChara* const this, enum HrBattleIcon::D_TODOME_DIRECT arg2)'
class mHRLockOnList;
// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnFinish(class mHRChara* const this, enum HrBattleIcon::D_TODOME_DIRECT arg2)'
// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnFinish(class mHRChara* const this, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4)'
class NYPhase;
class NYApproachToTargetVal;
class HrBattleIcon;
// TODO: Function 'void __convention("thiscall") mot::CBoneEffectDamageData::setup(class mot::CBoneEffectDamageData* const this, class mHRChara* arg2)'
class HrMap;
class ACameraModeBase;
class CCameraModeLockOn;
class CCameraVibManager;
class CCameraBank;
class CCameraModeSubjective;
class CSpringInterpolate3D;
class CDoubleSpringInterpolate3D;
class CCameraModePetitMovie;
class CCameraModeCircle;
class CCameraModeDefaultAngle;
class CCameraModeFree;
class CCameraModeNormal;
class CCameraModeReset;
class CCameraDistToLookAt;
class CCameraFollowRot;
class CCameraLookAtOffset;
class CCameraLookAtBase;
class CCameraDefaultAngle;
class CCameraLockOnModeData;
class CCameraNormalModeData;
class CCameraModeCommonData;
class CGameDataLink;
class CCameraDataManager;
class CCameraAreaManager;
namespace gameUtil
{
	class CPositionControl;
}
class CCameraTarget;
namespace ti
{
	class CCamera;
}
class CGameCamera;
class CCameraman;
class CGameData;
class CPackFileDataElement;
class CFileData;
class CPackFileData;
class CGameDataManager;
class mHRBattle;
class HrMiniDemoObj;
class HrMiniDemoModel;
// TODO: Function 'int32_t sub_4467e6(int32_t* arg1 @ ebp, class mHRPc* arg2 @ esi, class mHRChara* arg3 @ edi)'
class STG0202;
// TODO: Function 'class mot::IBoneEffectPJ* __convention("thiscall") mHRChara::getBoneEffect(class mHRChara* const this)'
// TODO: Function 'class mot::CBoneEffectDamageData* __convention("thiscall") mHRChara::getBoneEffectDamageData(class mHRChara* const this)'
class PJTateshi;
// TODO: Function 'void __convention("thiscall") HrBattleIcon::CHrHpGauge::Initialize(class HrBattleIcon::CHrHpGauge* const this, class mHRChara* arg2)'
class PJState;
class ZkState_DownAttack;
class State_AwayAfterAttack;
class State_CloseBeforeAttack;
class State_StepInAttack;
class State_DownDamage;
class State_TojoBaseState;
class State_LeadPcWayPointMove;
class State_FixTurret;
class State_WayPointMoveAfterPop;
class State_Tojo_RoomRunner;
class State_Tojo_AeroBike;
class State_Tojo_BreakCmnObj;
class State_Tojo_JumpOff;
class State_Tojo_Car;
class State_Tojo_RunAndTurnPc;
class State_Idle;
class State_Tojo_AgainstWall;
class State_Tojo_LookAround;
class State_Tojo_Stand;
class State_Tojo_Bench;
class State_Tojo_Sit;
class State_Tojo_SuddenAttack;
class State_ReleaseWaitIdle;
class State_Scare_Base;
class State_Scare_Kosinukasi;
class State_Scare_Run;
class State_WayPointMove;
class State_Pressure;
class State_ThroughDamage;
class State_Defence;
class State_Evacuate;
class State_ComboAttack;
class State_Damage;
struct CollInfo;
struct tagHRTASKCHECK;
struct ZkGuardParam;
struct ZkEvacuateParam;
class FkCounter;
struct ZkSetDamageInfo;
class State_Scare_Yotunbai;
class State_Scare_Stand;
class State_RandomMove;
class State_PerformIll;
class PJZAKO;
class PJStateMachine;
class EffectDanmenFlash;
class EffectCutMark;
class EffectQuestion;
class PJZakoMotMng;
class PathPlanner;
class FkDynamicParam;
class FkObstacleSensor;
class FkBulletManager;
class EffectFkTobiDoguBase;
class rQuadEx;
class EffectGunTrack;
class pcSNB;
class State_Tojo_Knife_SuddenAttack;
class ZkKnifeState_ThroughKnife;
class PJZAKOBoneB;
class PJZakoKnife;
class bsSKE;
class bsLEZ;
class bsCEW;
class bsAST;
class bsRKT;
template<typename T>
class KrBaseState;
class GLBDeathState;
class GLBWalkState;
class GLBComboState;
class GLBIdleState;
class GLBJampState;
template<typename T1, int T2>
class KrStateMachine;
class rSideScrollCamera;
class GLBDamageState;
class GLBGuardState;
class GLBAirKickState;
class pcGLB;
class EfRoboInterface;
class EffectSpeedBlur;
class CmDeathState;
class SDPDeathState;
class SDPComboState;
class CmDamageState;
class SDPDamageState;
class SDPBeamState;
class CmIdleState;
class SDPIdleState;
class bsBasic;
class SDPMoveState;
class SDPGuardState;
class bsSDP;
class FkTriangleList;
class EffectModelBeam;
struct FkVtx;
class EfGeneralBeam;
class PJOBJ0029;
class PJOBJ0033;
struct EFFECTSIMPLEOBJ3PARAM;
struct EFFECTMODELFIREPARAM;
class EffectModelFire;
class EffectSimpleObj3;
struct tagTLIST;
class PJOBJ0036;
class PJOBJ0037;
class PJOBJ0104;
class PJOBJ0155;
class PJOBJ0190;
class PJPTR;
// TODO: Function 'class EffectCutMark* EffectCutMark::Create(class TGmf* arg1, class mHRChara* arg2, struct Vec* arg3, uint32_t const arg4, enum eEfDmgLevel& arg5, enum EffectCutMark::eCutMarkType& arg6, float const arg7)'
class EffectEnemyDamage;
// TODO: Function 'void mHRCharaVoiceTable_Initialize()'
struct FkDbgInfo_EventArea;
class FkGlobalDBG;
class EffectBloodSplash;
class EffectSimpleObj2;
class EffectSlashHit;
class FkBoss;
class EffectSlashTrack;
class EffectBeamDragon;
class EffectGYNMissile;
class EffectMoeMissile;
class CMotionPlayer;
// TODO: Function 'void `dynamic atexit destructor for 'mHRChara::mCharaAnchor''()'

/// Full Declaration

// TODO: Function 'int32_t `dynamic initializer for 'mHRChara::mCharaAnchor''()'
// enum enCharaInitProc
enum enCharaInitProc : uint32_t
{
	// Enum values

	// <eCharaInitProcPrepareForReadRsl = 0x0>
	eCharaInitProcPrepareForReadRsl = 0,

	// <eCharaInitProcReadRsl = 0x1>
	eCharaInitProcReadRsl = 1,

	// <eCharaInitProcReadRslWait = 0x2>
	eCharaInitProcReadRslWait = 2,

	// <eCharaInitProcPrepareForRsl = 0x3>
	eCharaInitProcPrepareForRsl = 3,

	// <eCharaInitProcFinish = 0x4>
	eCharaInitProcFinish = 4,

	// <eCharaInitProcMax = 0x5>
	eCharaInitProcMax = 5

};

// class CSpringInterpolate
// no dependencies
class CSpringInterpolate
{
public:
	/// No namespace types
	/// Struct member variables

	// <float m_fSpringCoe, offset 0x0>
	float m_fSpringCoe;

	// <float m_fMaxVel, offset 0x4>
	float m_fMaxVel;

	// <float m_fMinVel, offset 0x8>
	float m_fMinVel;

	// <uint8_t m_bIsRadiInterp, offset 0xc>
	uint8_t m_bIsRadiInterp;

	// <Filler, offset 0xd>
	char _Filler4[3];

	// <float m_fEpsilon, offset 0x10>
	float m_fEpsilon;

	// <float m_fValue, offset 0x14>
	float m_fValue;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CSpringInterpolate>("CSpringInterpolate")
			.addProperty("m_fSpringCoe", &CSpringInterpolate::m_fSpringCoe)
			.addProperty("m_fMaxVel", &CSpringInterpolate::m_fMaxVel)
			.addProperty("m_fMinVel", &CSpringInterpolate::m_fMinVel)
			.addProperty("m_bIsRadiInterp", &CSpringInterpolate::m_bIsRadiInterp)
			.addProperty("m_fEpsilon", &CSpringInterpolate::m_fEpsilon)
			.addProperty("m_fValue", &CSpringInterpolate::m_fValue)
		.endClass();
	}
#endif
};
static_assert(sizeof(CSpringInterpolate::m_fSpringCoe) == 4, "expected m_fSpringCoe to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fMaxVel) == 4, "expected m_fMaxVel to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fMinVel) == 4, "expected m_fMinVel to be size 4");
static_assert(sizeof(CSpringInterpolate::m_bIsRadiInterp) == 1, "expected m_bIsRadiInterp to be size 1");
static_assert(sizeof(CSpringInterpolate::m_fEpsilon) == 4, "expected m_fEpsilon to be size 4");
static_assert(sizeof(CSpringInterpolate::m_fValue) == 4, "expected m_fValue to be size 4");
static_assert(sizeof(class CSpringInterpolate) == 24, "expected class CSpringInterpolate to be size 24");

// class CDoubleSpringInterpolate
// 1 dependencies: class CSpringInterpolate
class CDoubleSpringInterpolate
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CSpringInterpolate m_inHopeInterp, offset 0x0>
	class CSpringInterpolate m_inHopeInterp;

	// <class CSpringInterpolate m_inCurInterp, offset 0x18>
	class CSpringInterpolate m_inCurInterp;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CDoubleSpringInterpolate>("CDoubleSpringInterpolate")
			.addProperty("m_inHopeInterp", &CDoubleSpringInterpolate::m_inHopeInterp)
			.addProperty("m_inCurInterp", &CDoubleSpringInterpolate::m_inCurInterp)
		.endClass();
	}
#endif
};
static_assert(sizeof(CDoubleSpringInterpolate::m_inHopeInterp) == 24, "expected m_inHopeInterp to be size 24");
static_assert(sizeof(CDoubleSpringInterpolate::m_inCurInterp) == 24, "expected m_inCurInterp to be size 24");
static_assert(sizeof(class CDoubleSpringInterpolate) == 48, "expected class CDoubleSpringInterpolate to be size 48");

// class CAmbientShadow
// 2 dependencies: class CDoubleSpringInterpolate, class CSpringInterpolate
class CAmbientShadow
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inRatio, offset 0x0>
	class CDoubleSpringInterpolate m_inRatio;

	// <float m_fSetRatio, offset 0x30>
	float m_fSetRatio;

	// <class TGmf* m_pPreGmf, offset 0x34>
	class TGmf* m_pPreGmf;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CAmbientShadow>("CAmbientShadow")
			.addProperty("m_inRatio", &CAmbientShadow::m_inRatio)
			.addProperty("m_fSetRatio", &CAmbientShadow::m_fSetRatio)
			.addProperty("m_pPreGmf", &CAmbientShadow::m_pPreGmf)
		.endClass();
	}
#endif
};
static_assert(sizeof(CAmbientShadow::m_inRatio) == 48, "expected m_inRatio to be size 48");
static_assert(sizeof(CAmbientShadow::m_fSetRatio) == 4, "expected m_fSetRatio to be size 4");
static_assert(sizeof(CAmbientShadow::m_pPreGmf) == 4, "expected m_pPreGmf to be size 4");
static_assert(sizeof(class CAmbientShadow) == 56, "expected class CAmbientShadow to be size 56");

// struct stCharaEffect
// no dependencies
struct stCharaEffect
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[292];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaEffect>("stCharaEffect")
		.endClass();
	}
#endif
};
static_assert(sizeof(struct stCharaEffect) == 292, "expected struct stCharaEffect to be size 292");

// class stCharaFileData
// no dependencies
class stCharaFileData
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmGcFile* file, offset 0x0>
	class ghmGcFile* file;

	// <void* pData, offset 0x4>
	void* pData;

	// <class ghmResGroup* pRsl, offset 0x8>
	class ghmResGroup* pRsl;

	// <class TGmf* pGmf, offset 0xc>
	class TGmf* pGmf;

	// <class TGmf* pGmfDead, offset 0x10>
	class TGmf* pGmfDead;

	// <class TGmf* pGmfWepR, offset 0x14>
	class TGmf* pGmfWepR;

	// <class TGmf* pGmfWepL, offset 0x18>
	class TGmf* pGmfWepL;

	// <int16_t motionNumMax, offset 0x1c>
	int16_t motionNumMax;

	// <uint8_t readyDelete, offset 0x1e>
	uint8_t readyDelete;

	// <Filler, offset 0x1f>
	char _Filler9[1];

	// <int32_t sndFileHandle, offset 0x20>
	int32_t sndFileHandle;

	// <struct HRCHARAVOICE* pVoice, offset 0x24>
	struct HRCHARAVOICE* pVoice;

	// <char FileName[0x9], offset 0x28>
	char FileName[9];

	// <Filler, offset 0x31>
	char _Filler12[3];

	// <class TGan** pGan, offset 0x34>
	class TGan** pGan;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaFileData>("stCharaFileData")
			.addProperty("file", &stCharaFileData::file)
			// void type not supported in LuaBridge
			//.addProperty("pData", &stCharaFileData::pData)
			.addProperty("pRsl", &stCharaFileData::pRsl)
			.addProperty("pGmf", &stCharaFileData::pGmf)
			.addProperty("pGmfDead", &stCharaFileData::pGmfDead)
			.addProperty("pGmfWepR", &stCharaFileData::pGmfWepR)
			.addProperty("pGmfWepL", &stCharaFileData::pGmfWepL)
			.addProperty("motionNumMax", &stCharaFileData::motionNumMax)
			.addProperty("readyDelete", &stCharaFileData::readyDelete)
			.addProperty("sndFileHandle", &stCharaFileData::sndFileHandle)
			.addProperty("pVoice", &stCharaFileData::pVoice)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("FileName", &stCharaFileData::FileName)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("pGan", &stCharaFileData::pGan)
		.endClass();
	}
#endif
};
static_assert(sizeof(stCharaFileData::file) == 4, "expected file to be size 4");
static_assert(sizeof(stCharaFileData::pData) == 4, "expected pData to be size 4");
static_assert(sizeof(stCharaFileData::pRsl) == 4, "expected pRsl to be size 4");
static_assert(sizeof(stCharaFileData::pGmf) == 4, "expected pGmf to be size 4");
static_assert(sizeof(stCharaFileData::pGmfDead) == 4, "expected pGmfDead to be size 4");
static_assert(sizeof(stCharaFileData::pGmfWepR) == 4, "expected pGmfWepR to be size 4");
static_assert(sizeof(stCharaFileData::pGmfWepL) == 4, "expected pGmfWepL to be size 4");
static_assert(sizeof(stCharaFileData::motionNumMax) == 2, "expected motionNumMax to be size 2");
static_assert(sizeof(stCharaFileData::readyDelete) == 1, "expected readyDelete to be size 1");
static_assert(sizeof(stCharaFileData::sndFileHandle) == 4, "expected sndFileHandle to be size 4");
static_assert(sizeof(stCharaFileData::pVoice) == 4, "expected pVoice to be size 4");
static_assert(sizeof(stCharaFileData::FileName) == 9, "expected FileName to be size 9");
static_assert(sizeof(stCharaFileData::pGan) == 4, "expected pGan to be size 4");
static_assert(sizeof(class stCharaFileData) == 56, "expected class stCharaFileData to be size 56");

// struct Vec
// no dependencies
struct Vec
{
public:
	/// No namespace types
	/// Struct member variables

	// <float x, offset 0x0>
	float x;

	// <float y, offset 0x4>
	float y;

	// <float z, offset 0x8>
	float z;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Vec>("Vec")
			.addProperty("x", &Vec::x)
			.addProperty("y", &Vec::y)
			.addProperty("z", &Vec::z)
		.endClass();
	}
#endif
};
static_assert(sizeof(Vec::x) == 4, "expected x to be size 4");
static_assert(sizeof(Vec::y) == 4, "expected y to be size 4");
static_assert(sizeof(Vec::z) == 4, "expected z to be size 4");
static_assert(sizeof(struct Vec) == 12, "expected struct Vec to be size 12");

// class ghmSegment
// 1 dependencies: struct Vec
class ghmSegment
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mDir, offset 0xc>
	struct Vec mDir;

	// <float mExtent, offset 0x18>
	float mExtent;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmSegment>("ghmSegment")
			.addProperty("mCenter", &ghmSegment::mCenter)
			.addProperty("mDir", &ghmSegment::mDir)
			.addProperty("mExtent", &ghmSegment::mExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmSegment::mCenter) == 12, "expected mCenter to be size 12");
static_assert(sizeof(ghmSegment::mDir) == 12, "expected mDir to be size 12");
static_assert(sizeof(ghmSegment::mExtent) == 4, "expected mExtent to be size 4");
static_assert(sizeof(class ghmSegment) == 28, "expected class ghmSegment to be size 28");

// class ghmCapsule
// 2 dependencies: class ghmSegment, struct Vec
class ghmCapsule
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmSegment mAxis, offset 0x0>
	class ghmSegment mAxis;

	// <float mRadius, offset 0x1c>
	float mRadius;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmCapsule>("ghmCapsule")
			.addProperty("mAxis", &ghmCapsule::mAxis)
			.addProperty("mRadius", &ghmCapsule::mRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmCapsule::mAxis) == 28, "expected mAxis to be size 28");
static_assert(sizeof(ghmCapsule::mRadius) == 4, "expected mRadius to be size 4");
static_assert(sizeof(class ghmCapsule) == 32, "expected class ghmCapsule to be size 32");

// class ghmGcOctTreeNodeObj
// no dependencies
class ghmGcOctTreeNodeObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x2], offset 0x0>
	void* (* field_0)[0x2];

	// <class ghmGcOctTreeNode* mpContainer, offset 0x4>
	class ghmGcOctTreeNode* mpContainer;

	// <ghmGcOctTreeNodeObj* mpNext, offset 0x8>
	ghmGcOctTreeNodeObj* mpNext;

	// <ghmGcOctTreeNodeObj* mpPrev, offset 0xc>
	ghmGcOctTreeNodeObj* mpPrev;

	// <uint32_t mUserData, offset 0x10>
	uint32_t mUserData;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTreeNodeObj>("ghmGcOctTreeNodeObj")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTreeNodeObj::field_0)
			.addProperty("mpContainer", &ghmGcOctTreeNodeObj::mpContainer)
			.addProperty("mpNext", &ghmGcOctTreeNodeObj::mpNext)
			.addProperty("mpPrev", &ghmGcOctTreeNodeObj::mpPrev)
			.addProperty("mUserData", &ghmGcOctTreeNodeObj::mUserData)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTreeNodeObj::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpContainer) == 4, "expected mpContainer to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(ghmGcOctTreeNodeObj::mUserData) == 4, "expected mUserData to be size 4");
static_assert(sizeof(class ghmGcOctTreeNodeObj) == 20, "expected class ghmGcOctTreeNodeObj to be size 20");

// class ghmGcCollObj
// 3 dependencies: class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, struct Vec
class ghmGcCollObj : ghmGcOctTreeNodeObj
{
public:
	/// 1 namespace types: enum ghmGcCollObj::Type

	// enum ghmGcCollObj::Type
	enum Type : uint32_t
	{
		// Enum values

		// <TYPE_TRIANGLE = 0x0>
		TYPE_TRIANGLE = 0,

		// <TYPE_SPHERE = 0x1>
		TYPE_SPHERE = 1,

		// <TYPE_AABB = 0x2>
		TYPE_AABB = 2,

		// <TYPE_OBB = 0x3>
		TYPE_OBB = 3,

		// <TYPE_CAPSULE = 0x4>
		TYPE_CAPSULE = 4,

		// <TYPE_USER = 0x5>
		TYPE_USER = 5,

		// <TYPE_INVALID = 0xffffffffffffffff>
		TYPE_INVALID = UINT32_MAX

	};


	/// Struct member variables

	// <class ghmGcOctTreeNodeObj field_0, offset 0x0>
	// class ghmGcOctTreeNodeObj Super;

	// <enum ghmGcCollObj::Type mObjType, offset 0x14>
	enum ghmGcCollObj::Type mObjType;

	// <uint32_t mGroup, offset 0x18>
	uint32_t mGroup;

	// <uint32_t mIgnoreGroup, offset 0x1c>
	uint32_t mIgnoreGroup;

	// <int32_t (* mpHitTestCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*), offset 0x20>
	int32_t (* mpHitTestCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*);

	// <int32_t (* mpHitCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*), offset 0x24>
	int32_t (* mpHitCallback)(ghmGcCollObj*, ghmGcCollObj*, class ghmGcCollObjHitResult*);

	// <struct Vec mVelocity, offset 0x28>
	struct Vec mVelocity;

	// <uint32_t mFlag, offset 0x34>
	uint32_t mFlag;

	// <uint32_t mParam[0x2], offset 0x38>
	uint32_t mParam[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcCollObj>("ghmGcCollObj")
			.addProperty("mObjType", &ghmGcCollObj::mObjType)
			.addProperty("mGroup", &ghmGcCollObj::mGroup)
			.addProperty("mIgnoreGroup", &ghmGcCollObj::mIgnoreGroup)
			// delegates are not supported in LuaBridge
			//.addProperty("mpHitTestCallback", &ghmGcCollObj::mpHitTestCallback)
			// delegates are not supported in LuaBridge
			//.addProperty("mpHitCallback", &ghmGcCollObj::mpHitCallback)
			.addProperty("mVelocity", &ghmGcCollObj::mVelocity)
			.addProperty("mFlag", &ghmGcCollObj::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mParam", &ghmGcCollObj::mParam)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObj::mObjType) == 4, "expected mObjType to be size 4");
static_assert(sizeof(ghmGcCollObj::mGroup) == 4, "expected mGroup to be size 4");
static_assert(sizeof(ghmGcCollObj::mIgnoreGroup) == 4, "expected mIgnoreGroup to be size 4");
static_assert(sizeof(ghmGcCollObj::mpHitTestCallback) == 4, "expected mpHitTestCallback to be size 4");
static_assert(sizeof(ghmGcCollObj::mpHitCallback) == 4, "expected mpHitCallback to be size 4");
static_assert(sizeof(ghmGcCollObj::mVelocity) == 12, "expected mVelocity to be size 12");
static_assert(sizeof(ghmGcCollObj::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmGcCollObj::mParam) == 8, "expected mParam to be size 8");
static_assert(sizeof(class ghmGcCollObj) == 64, "expected class ghmGcCollObj to be size 64");

// class ghmGcCollObjCapsule
// 6 dependencies: class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, struct Vec, class ghmCapsule, class ghmSegment
class ghmGcCollObjCapsule : ghmGcCollObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmGcCollObj field_0, offset 0x0>
	// class ghmGcCollObj Super;

	// <class ghmCapsule mShape, offset 0x40>
	class ghmCapsule mShape;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcCollObjCapsule>("ghmGcCollObjCapsule")
			.addProperty("mShape", &ghmGcCollObjCapsule::mShape)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjCapsule::mShape) == 32, "expected mShape to be size 32");
static_assert(sizeof(class ghmGcCollObjCapsule) == 96, "expected class ghmGcCollObjCapsule to be size 96");

// class WAnim
// no dependencies
class WAnim
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WAnim>("WAnim")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &WAnim::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(WAnim::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(class WAnim) == 4, "expected class WAnim to be size 4");

// class WAnimF
// 1 dependencies: class WAnim
class WAnimF : WAnim
{
public:
	/// No namespace types
	/// Struct member variables

	// <class WAnim field_0, offset 0x0>
	// class WAnim Super;

	// <float mCurValue, offset 0x4>
	float mCurValue;

	// <float mDstValue, offset 0x8>
	float mDstValue;

	// <float mSrcValue, offset 0xc>
	float mSrcValue;

	// <uint32_t mCount, offset 0x10>
	uint32_t mCount;

	// <uint32_t mTime, offset 0x14>
	uint32_t mTime;

	// <int32_t mIpType, offset 0x18>
	int32_t mIpType;

	// <float mMotionRate, offset 0x1c>
	float mMotionRate;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WAnimF>("WAnimF")
			.addProperty("mCurValue", &WAnimF::mCurValue)
			.addProperty("mDstValue", &WAnimF::mDstValue)
			.addProperty("mSrcValue", &WAnimF::mSrcValue)
			.addProperty("mCount", &WAnimF::mCount)
			.addProperty("mTime", &WAnimF::mTime)
			.addProperty("mIpType", &WAnimF::mIpType)
			.addProperty("mMotionRate", &WAnimF::mMotionRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(WAnimF::mCurValue) == 4, "expected mCurValue to be size 4");
static_assert(sizeof(WAnimF::mDstValue) == 4, "expected mDstValue to be size 4");
static_assert(sizeof(WAnimF::mSrcValue) == 4, "expected mSrcValue to be size 4");
static_assert(sizeof(WAnimF::mCount) == 4, "expected mCount to be size 4");
static_assert(sizeof(WAnimF::mTime) == 4, "expected mTime to be size 4");
static_assert(sizeof(WAnimF::mIpType) == 4, "expected mIpType to be size 4");
static_assert(sizeof(WAnimF::mMotionRate) == 4, "expected mMotionRate to be size 4");
static_assert(sizeof(class WAnimF) == 32, "expected class WAnimF to be size 32");

// struct stDamageInfo
// 3 dependencies: struct Vec, class WAnimF, class WAnim
struct stDamageInfo
{
public:
	/// No namespace types
	/// Struct member variables

	// <float dmg, offset 0x0>
	float dmg;

	// <int32_t dmgMot, offset 0x4>
	int32_t dmgMot;

	// <int32_t grdMot, offset 0x8>
	int32_t grdMot;

	// <int32_t atkMot, offset 0xc>
	int32_t atkMot;

	// <int32_t atkKind, offset 0x10>
	int32_t atkKind;

	// <float dmgDirec, offset 0x14>
	float dmgDirec;

	// <float nockBackSpd, offset 0x18>
	float nockBackSpd;

	// <float nockBackDst, offset 0x1c>
	float nockBackDst;

	// <struct Vec nockBackDir, offset 0x20>
	struct Vec nockBackDir;

	// <float nockBackMasatu, offset 0x2c>
	float nockBackMasatu;

	// <float upperPow, offset 0x30>
	float upperPow;

	// <float upperPowLast, offset 0x34>
	float upperPowLast;

	// <float upperPosY, offset 0x38>
	float upperPosY;

	// <float grav, offset 0x3c>
	float grav;

	// <uint8_t upper, offset 0x40>
	uint8_t upper;

	// <Filler, offset 0x41>
	char _Filler15[3];

	// <int32_t tick, offset 0x44>
	int32_t tick;

	// <class WAnimF fade, offset 0x48>
	class WAnimF fade;

	// <uint8_t m_PiyoRequest, offset 0x68>
	uint8_t m_PiyoRequest;

	// <uint8_t m_BikeDeadRequest, offset 0x69>
	uint8_t m_BikeDeadRequest;

	// <Filler, offset 0x6a>
	char _Filler[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stDamageInfo>("stDamageInfo")
			.addProperty("dmg", &stDamageInfo::dmg)
			.addProperty("dmgMot", &stDamageInfo::dmgMot)
			.addProperty("grdMot", &stDamageInfo::grdMot)
			.addProperty("atkMot", &stDamageInfo::atkMot)
			.addProperty("atkKind", &stDamageInfo::atkKind)
			.addProperty("dmgDirec", &stDamageInfo::dmgDirec)
			.addProperty("nockBackSpd", &stDamageInfo::nockBackSpd)
			.addProperty("nockBackDst", &stDamageInfo::nockBackDst)
			.addProperty("nockBackDir", &stDamageInfo::nockBackDir)
			.addProperty("nockBackMasatu", &stDamageInfo::nockBackMasatu)
			.addProperty("upperPow", &stDamageInfo::upperPow)
			.addProperty("upperPowLast", &stDamageInfo::upperPowLast)
			.addProperty("upperPosY", &stDamageInfo::upperPosY)
			.addProperty("grav", &stDamageInfo::grav)
			.addProperty("upper", &stDamageInfo::upper)
			.addProperty("tick", &stDamageInfo::tick)
			.addProperty("fade", &stDamageInfo::fade)
			.addProperty("m_PiyoRequest", &stDamageInfo::m_PiyoRequest)
			.addProperty("m_BikeDeadRequest", &stDamageInfo::m_BikeDeadRequest)
		.endClass();
	}
#endif
};
static_assert(sizeof(stDamageInfo::dmg) == 4, "expected dmg to be size 4");
static_assert(sizeof(stDamageInfo::dmgMot) == 4, "expected dmgMot to be size 4");
static_assert(sizeof(stDamageInfo::grdMot) == 4, "expected grdMot to be size 4");
static_assert(sizeof(stDamageInfo::atkMot) == 4, "expected atkMot to be size 4");
static_assert(sizeof(stDamageInfo::atkKind) == 4, "expected atkKind to be size 4");
static_assert(sizeof(stDamageInfo::dmgDirec) == 4, "expected dmgDirec to be size 4");
static_assert(sizeof(stDamageInfo::nockBackSpd) == 4, "expected nockBackSpd to be size 4");
static_assert(sizeof(stDamageInfo::nockBackDst) == 4, "expected nockBackDst to be size 4");
static_assert(sizeof(stDamageInfo::nockBackDir) == 12, "expected nockBackDir to be size 12");
static_assert(sizeof(stDamageInfo::nockBackMasatu) == 4, "expected nockBackMasatu to be size 4");
static_assert(sizeof(stDamageInfo::upperPow) == 4, "expected upperPow to be size 4");
static_assert(sizeof(stDamageInfo::upperPowLast) == 4, "expected upperPowLast to be size 4");
static_assert(sizeof(stDamageInfo::upperPosY) == 4, "expected upperPosY to be size 4");
static_assert(sizeof(stDamageInfo::grav) == 4, "expected grav to be size 4");
static_assert(sizeof(stDamageInfo::upper) == 1, "expected upper to be size 1");
static_assert(sizeof(stDamageInfo::tick) == 4, "expected tick to be size 4");
static_assert(sizeof(stDamageInfo::fade) == 32, "expected fade to be size 32");
static_assert(sizeof(stDamageInfo::m_PiyoRequest) == 1, "expected m_PiyoRequest to be size 1");
static_assert(sizeof(stDamageInfo::m_BikeDeadRequest) == 1, "expected m_BikeDeadRequest to be size 1");
static_assert(sizeof(struct stDamageInfo) == 108, "expected struct stDamageInfo to be size 108");

// class ghmTriangle
// no dependencies
class ghmTriangle
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[36];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmTriangle>("ghmTriangle")
		.endClass();
	}
#endif
};
static_assert(sizeof(class ghmTriangle) == 36, "expected class ghmTriangle to be size 36");

// class ghmPlane
// 1 dependencies: struct Vec
class ghmPlane
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct Vec mNormal, offset 0x0>
	struct Vec mNormal;

	// <float mDist, offset 0xc>
	float mDist;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmPlane>("ghmPlane")
			.addProperty("mNormal", &ghmPlane::mNormal)
			.addProperty("mDist", &ghmPlane::mDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmPlane::mNormal) == 12, "expected mNormal to be size 12");
static_assert(sizeof(ghmPlane::mDist) == 4, "expected mDist to be size 4");
static_assert(sizeof(class ghmPlane) == 16, "expected class ghmPlane to be size 16");

// class ghmGcCollObjHitResultObj
// 3 dependencies: class ghmPlane, struct Vec, class ghmTriangle
class ghmGcCollObjHitResultObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmPlane mPlane, offset 0x0>
	class ghmPlane mPlane;

	// <class ghmTriangle mTriangle, offset 0x10>
	class ghmTriangle mTriangle;

	// <struct Vec mPoint, offset 0x34>
	struct Vec mPoint;

	// <float mRate, offset 0x40>
	float mRate;

	// <uint32_t mAttr, offset 0x44>
	uint32_t mAttr;

	// <class ghmGcCollObj* mpObj, offset 0x48>
	class ghmGcCollObj* mpObj;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcCollObjHitResultObj>("ghmGcCollObjHitResultObj")
			.addProperty("mPlane", &ghmGcCollObjHitResultObj::mPlane)
			.addProperty("mTriangle", &ghmGcCollObjHitResultObj::mTriangle)
			.addProperty("mPoint", &ghmGcCollObjHitResultObj::mPoint)
			.addProperty("mRate", &ghmGcCollObjHitResultObj::mRate)
			.addProperty("mAttr", &ghmGcCollObjHitResultObj::mAttr)
			.addProperty("mpObj", &ghmGcCollObjHitResultObj::mpObj)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcCollObjHitResultObj::mPlane) == 16, "expected mPlane to be size 16");
static_assert(sizeof(ghmGcCollObjHitResultObj::mTriangle) == 36, "expected mTriangle to be size 36");
static_assert(sizeof(ghmGcCollObjHitResultObj::mPoint) == 12, "expected mPoint to be size 12");
static_assert(sizeof(ghmGcCollObjHitResultObj::mRate) == 4, "expected mRate to be size 4");
static_assert(sizeof(ghmGcCollObjHitResultObj::mAttr) == 4, "expected mAttr to be size 4");
static_assert(sizeof(ghmGcCollObjHitResultObj::mpObj) == 4, "expected mpObj to be size 4");
static_assert(sizeof(class ghmGcCollObjHitResultObj) == 76, "expected class ghmGcCollObjHitResultObj to be size 76");

// enum enCharaCondition
enum enCharaCondition : uint32_t
{
	// Enum values

	// <eGood = 0x0>
	eGood = 0,

	// <eDamaging = 0x1>
	eDamaging = 1,

	// <eDying = 0x2>
	eDying = 2,

	// <eDead = 0x3>
	eDead = 3,

	// <eBossDead = 0x4>
	eBossDead = 4,

	// <eConditionInit = 0x5>
	eConditionInit = 5,

	// <eConditionMax = 0x6>
	eConditionMax = 6

};

// struct stVec
// 2 dependencies: class WAnimF, class WAnim
struct stVec
{
public:
	/// No namespace types
	/// Struct member variables

	// <class WAnimF x, offset 0x0>
	class WAnimF x;

	// <class WAnimF y, offset 0x20>
	class WAnimF y;

	// <class WAnimF z, offset 0x40>
	class WAnimF z;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stVec>("stVec")
			.addProperty("x", &stVec::x)
			.addProperty("y", &stVec::y)
			.addProperty("z", &stVec::z)
		.endClass();
	}
#endif
};
static_assert(sizeof(stVec::x) == 32, "expected x to be size 32");
static_assert(sizeof(stVec::y) == 32, "expected y to be size 32");
static_assert(sizeof(stVec::z) == 32, "expected z to be size 32");
static_assert(sizeof(struct stVec) == 96, "expected struct stVec to be size 96");

// struct Quaternion
// no dependencies
struct Quaternion
{
public:
	/// No namespace types
	/// Struct member variables

	// <float x, offset 0x0>
	float x;

	// <float y, offset 0x4>
	float y;

	// <float z, offset 0x8>
	float z;

	// <float w, offset 0xc>
	float w;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<Quaternion>("Quaternion")
			.addProperty("x", &Quaternion::x)
			.addProperty("y", &Quaternion::y)
			.addProperty("z", &Quaternion::z)
			.addProperty("w", &Quaternion::w)
		.endClass();
	}
#endif
};
static_assert(sizeof(Quaternion::x) == 4, "expected x to be size 4");
static_assert(sizeof(Quaternion::y) == 4, "expected y to be size 4");
static_assert(sizeof(Quaternion::z) == 4, "expected z to be size 4");
static_assert(sizeof(Quaternion::w) == 4, "expected w to be size 4");
static_assert(sizeof(struct Quaternion) == 16, "expected struct Quaternion to be size 16");

// enum enCharaType
enum enCharaType : uint32_t
{
	// Enum values

	// <eCharaTypeNone = 0x0>
	eCharaTypeNone = 0,

	// <eCharaTypePC = 0x1>
	eCharaTypePC = 1,

	// <CHARACTER_TYPE_ZAKO_BEGIN = 0x2>
	CHARACTER_TYPE_ZAKO_BEGIN = 2,

	// <eCharaTypeZKPipe = 0x3>
	eCharaTypeZKPipe = 3,

	// <eCharaTypeZKBat = 0x4>
	eCharaTypeZKBat = 4,

	// <eCharaTypeZKHandGun = 0x5>
	eCharaTypeZKHandGun = 5,

	// <eCharaTypeZKSubMachineGun = 0x6>
	eCharaTypeZKSubMachineGun = 6,

	// <eCharaTypeZKKnife = 0x7>
	eCharaTypeZKKnife = 7,

	// <eCharaTypeZKKakuto = 0x8>
	eCharaTypeZKKakuto = 8,

	// <eCharaTypeZKNihonto = 0x9>
	eCharaTypeZKNihonto = 9,

	// <eCharaTypeZKBeamKatana = 0xa>
	eCharaTypeZKBeamKatana = 10,

	// <eCharaTypeZKWarPick = 0xb>
	eCharaTypeZKWarPick = 11,

	// <eCharaTypeZKChainSaw = 0xc>
	eCharaTypeZKChainSaw = 12,

	// <eCharaTypeZKFiveNata = 0xd>
	eCharaTypeZKFiveNata = 13,

	// <eCharaTypeZKFiveHandGun = 0xe>
	eCharaTypeZKFiveHandGun = 14,

	// <eCharaTypeZKFiveMachineGun = 0xf>
	eCharaTypeZKFiveMachineGun = 15,

	// <CHARACTER_TYPE_ZAKO_END = 0x10>
	CHARACTER_TYPE_ZAKO_END = 16,

	// <CHARACTER_TYPE_BOSS_BEGIN = 0x11>
	CHARACTER_TYPE_BOSS_BEGIN = 17,

	// <eCharaTypeSKE = 0x12>
	eCharaTypeSKE = 18,

	// <eCharaTypeSPU = 0x13>
	eCharaTypeSPU = 19,

	// <eCharaTypeDSL = 0x14>
	eCharaTypeDSL = 20,

	// <eCharaTypeDSR = 0x15>
	eCharaTypeDSR = 21,

	// <eCharaTypeGSR = 0x16>
	eCharaTypeGSR = 22,

	// <eCharaTypePOP = 0x17>
	eCharaTypePOP = 23,

	// <eCharaTypeJPY = 0x18>
	eCharaTypeJPY = 24,

	// <eCharaTypeGYN = 0x19>
	eCharaTypeGYN = 25,

	// <eCharaTypeMGN = 0x1a>
	eCharaTypeMGN = 26,

	// <eCharaTypeMOE = 0x1b>
	eCharaTypeMOE = 27,

	// <eCharaTypeLEZ = 0x1c>
	eCharaTypeLEZ = 28,

	// <eCharaTypeCEW = 0x1d>
	eCharaTypeCEW = 29,

	// <eCharaTypeJBJA = 0x1e>
	eCharaTypeJBJA = 30,

	// <eCharaTypeJBJB = 0x1f>
	eCharaTypeJBJB = 31,

	// <eCharaTypeJBJC = 0x20>
	eCharaTypeJBJC = 32,

	// <eCharaTypeAST = 0x21>
	eCharaTypeAST = 33,

	// <eCharaTypeRKT = 0x22>
	eCharaTypeRKT = 34,

	// <eCharaTypeGLB = 0x23>
	eCharaTypeGLB = 35,

	// <eCharaTypeSDP = 0x24>
	eCharaTypeSDP = 36,

	// <eCharaTypeBIKJPY = 0x25>
	eCharaTypeBIKJPY = 37,

	// <CHARACTER_TYPE_BOSS_END = 0x26>
	CHARACTER_TYPE_BOSS_END = 38,

	// <eCharaTypePatroller = 0x27>
	eCharaTypePatroller = 39,

	// <eCharaTypeZKCar_Sedan = 0x28>
	eCharaTypeZKCar_Sedan = 40,

	// <eCharaTypeZKCar_Van = 0x29>
	eCharaTypeZKCar_Van = 41,

	// <eCharaTypePhotoCat = 0x2a>
	eCharaTypePhotoCat = 42,

	// <eCharaTypeFCA = 0x2b>
	eCharaTypeFCA = 43,

	// <eCharaTypeCommonNpc = 0x2c>
	eCharaTypeCommonNpc = 44,

	// <eCharaTypeScorpion = 0x2d>
	eCharaTypeScorpion = 45,

	// <eCharaTypeHelicopter = 0x2e>
	eCharaTypeHelicopter = 46,

	// <eCharaTypeCommonNpc_BUG = 0x2f>
	eCharaTypeCommonNpc_BUG = 47,

	// <eCharaTypeCommonNpc_PIPE = 0x30>
	eCharaTypeCommonNpc_PIPE = 48,

	// <eCharaTypeCommonNpc_COCONUT = 0x31>
	eCharaTypeCommonNpc_COCONUT = 49,

	// <eCharaTypeCommonNpc_DEBLI = 0x32>
	eCharaTypeCommonNpc_DEBLI = 50,

	// <eCharaTypeCommonNpc_PIZZA = 0x33>
	eCharaTypeCommonNpc_PIZZA = 51,

	// <eCharaTypeCommonNpc_TILE = 0x34>
	eCharaTypeCommonNpc_TILE = 52,

	// <eCharaTypeCommonNpc_STEAK = 0x35>
	eCharaTypeCommonNpc_STEAK = 53,

	// <eCharaTypeCommonNpc_SCORPION = 0x36>
	eCharaTypeCommonNpc_SCORPION = 54,

	// <eCharaTypeCommonNpc_CAR_BUG = 0x37>
	eCharaTypeCommonNpc_CAR_BUG = 55,

	// <eCharaTypeCommonNpc_CAR_PIPE = 0x38>
	eCharaTypeCommonNpc_CAR_PIPE = 56,

	// <eCharaTypeCommonNpc_CAR_COCONUT = 0x39>
	eCharaTypeCommonNpc_CAR_COCONUT = 57,

	// <eCharaTypeCommonNpc_CAR_DEBLI = 0x3a>
	eCharaTypeCommonNpc_CAR_DEBLI = 58,

	// <eCharaTypeCommonNpc_CAR_TILE = 0x3b>
	eCharaTypeCommonNpc_CAR_TILE = 59,

	// <eCharaTypeCommonNpc_CAR_STEAK = 0x3c>
	eCharaTypeCommonNpc_CAR_STEAK = 60,

	// <eCharaTypeCommonNpc_CAR_SCORPION = 0x3d>
	eCharaTypeCommonNpc_CAR_SCORPION = 61,

	// <eCharaTypeCmnObj = 0x3e8>
	eCharaTypeCmnObj = 1000,

	// <eCharaTypePlayerWeapon = 0x3e9>
	eCharaTypePlayerWeapon = 1001,

	// <eCustomColliderObject = 0x3ea>
	eCustomColliderObject = 1002

};

// struct stCharaStatus
// 17 dependencies: enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment
struct stCharaStatus
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t resNo, offset 0x0>
	int32_t resNo;

	// <int32_t datNo, offset 0x4>
	int32_t datNo;

	// <enum enCharaType charaType, offset 0x8>
	enum enCharaType charaType;

	// <int16_t zakoWepType, offset 0xc>
	int16_t zakoWepType;

	// <Filler, offset 0xe>
	char _Filler4[2];

	// <float maxHp, offset 0x10>
	float maxHp;

	// <float hp, offset 0x14>
	float hp;

	// <int16_t money, offset 0x18>
	int16_t money;

	// <int16_t dropMoney, offset 0x1a>
	int16_t dropMoney;

	// <float tension, offset 0x1c>
	float tension;

	// <float hajikiCount, offset 0x20>
	float hajikiCount;

	// <uint8_t alwaysCheckHitColl, offset 0x24>
	uint8_t alwaysCheckHitColl;

	// <Filler, offset 0x25>
	char _Filler11[3];

	// <struct Vec pos, offset 0x28>
	struct Vec pos;

	// <struct Vec beforePos, offset 0x34>
	struct Vec beforePos;

	// <struct Vec oldPos, offset 0x40>
	struct Vec oldPos;

	// <struct Vec navelPos, offset 0x4c>
	struct Vec navelPos;

	// <struct Vec brainPos, offset 0x58>
	struct Vec brainPos;

	// <struct Vec rot, offset 0x64>
	struct Vec rot;

	// <struct Vec scale, offset 0x70>
	struct Vec scale;

	// <struct Quaternion qRot, offset 0x7c>
	struct Quaternion qRot;

	// <float movSpd, offset 0x8c>
	float movSpd;

	// <float hitSize, offset 0x90>
	float hitSize;

	// <float height, offset 0x94>
	float height;

	// <struct stVec aPos, offset 0x98>
	struct stVec aPos;

	// <struct stVec aRot, offset 0xf8>
	struct stVec aRot;

	// <int32_t enterPattern, offset 0x158>
	int32_t enterPattern;

	// <float reactionDist, offset 0x15c>
	float reactionDist;

	// <int32_t itemNo, offset 0x160>
	int32_t itemNo;

	// <int32_t mAiDefBasic, offset 0x164>
	int32_t mAiDefBasic;

	// <int32_t mAiDefCurrent, offset 0x168>
	int32_t mAiDefCurrent;

	// <int32_t mAiDefTick, offset 0x16c>
	int32_t mAiDefTick;

	// <int32_t mAiDefBaseTick, offset 0x170>
	int32_t mAiDefBaseTick;

	// <float mAiDamageCount, offset 0x174>
	float mAiDamageCount;

	// <char* pScriptProc, offset 0x178>
	char* pScriptProc;

	// <int32_t tsubazeriNum, offset 0x17c>
	int32_t tsubazeriNum;

	// <int32_t DamageAcceptFrame, offset 0x180>
	int32_t DamageAcceptFrame;

	// <int32_t motionNo, offset 0x184>
	int32_t motionNo;

	// <char motionBrendNum, offset 0x188>
	char motionBrendNum;

	// <Filler, offset 0x189>
	char _Filler37[3];

	// <float motSpd, offset 0x18c>
	float motSpd;

	// <float subMotSpd, offset 0x190>
	float subMotSpd;

	// <enum enCharaCondition condition, offset 0x194>
	enum enCharaCondition condition;

	// <class ghmGcCollObj* footHitResultObj, offset 0x198>
	class ghmGcCollObj* footHitResultObj;

	// <class ghmGcCollObjHitResult* footHitResult, offset 0x19c>
	class ghmGcCollObjHitResult* footHitResult;

	// <class ghmGcCollObjHitResultObj footHitResultObj2, offset 0x1a0>
	class ghmGcCollObjHitResultObj footHitResultObj2;

	// <class ghmGcCollObjHitResultObj HitWallObj, offset 0x1ec>
	class ghmGcCollObjHitResultObj HitWallObj;

	// <struct WGclMaterialSpec* hitWallMaterial, offset 0x238>
	struct WGclMaterialSpec* hitWallMaterial;

	// <struct Vec HitWallNormal, offset 0x23c>
	struct Vec HitWallNormal;

	// <struct stDamageInfo dmgInfo, offset 0x248>
	struct stDamageInfo dmgInfo;

	// <struct Vec mYukaNormal, offset 0x2b4>
	struct Vec mYukaNormal;

	// <int32_t mFootNumber, offset 0x2c0>
	int32_t mFootNumber;

	// <int32_t movTick, offset 0x2c4>
	int32_t movTick;

	// <int16_t hitNum, offset 0x2c8>
	int16_t hitNum;

	// <Filler, offset 0x2ca>
	char _Filler51[2];

	// <class ghmGcCollObjCapsule hitColl, offset 0x2cc>
	class ghmGcCollObjCapsule hitColl;

	// <int32_t mAiAtkLv, offset 0x32c>
	int32_t mAiAtkLv;

	// <int32_t mAiAtkClass, offset 0x330>
	int32_t mAiAtkClass;

	// <int16_t AtkAi[0xa], offset 0x334>
	int16_t AtkAi[10];

	// <int32_t renderSkipCounter, offset 0x348>
	int32_t renderSkipCounter;

	// <float renderSkipMotSpd, offset 0x34c>
	float renderSkipMotSpd;

	// <int32_t frameStop, offset 0x350>
	int32_t frameStop;

	// <float lockOnDistance, offset 0x354>
	float lockOnDistance;

	// <float lockOnDistanceHi, offset 0x358>
	float lockOnDistanceHi;

	// <float lockOnDistanceLow, offset 0x35c>
	float lockOnDistanceLow;

	// <float DrawYAdjust, offset 0x360>
	float DrawYAdjust;

	// <uint8_t bBloom, offset 0x364>
	uint8_t bBloom;

	// <uint8_t JumpBlockHit, offset 0x365>
	uint8_t JumpBlockHit;

	// <Filler, offset 0x366>
	char _Filler64[2];

	// <float AtkDisAdjust, offset 0x368>
	float AtkDisAdjust;

	// <float TubaFrmOffset, offset 0x36c>
	float TubaFrmOffset;

	// <int32_t motionNoNpc, offset 0x370>
	int32_t motionNoNpc;

	// <class WAnimF semiTransRate, offset 0x374>
	class WAnimF semiTransRate;

	// <uint32_t flag[0x2], offset 0x394>
	uint32_t flag[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stCharaStatus>("stCharaStatus")
			.addProperty("resNo", &stCharaStatus::resNo)
			.addProperty("datNo", &stCharaStatus::datNo)
			.addProperty("charaType", &stCharaStatus::charaType)
			.addProperty("zakoWepType", &stCharaStatus::zakoWepType)
			.addProperty("maxHp", &stCharaStatus::maxHp)
			.addProperty("hp", &stCharaStatus::hp)
			.addProperty("money", &stCharaStatus::money)
			.addProperty("dropMoney", &stCharaStatus::dropMoney)
			.addProperty("tension", &stCharaStatus::tension)
			.addProperty("hajikiCount", &stCharaStatus::hajikiCount)
			.addProperty("alwaysCheckHitColl", &stCharaStatus::alwaysCheckHitColl)
			.addProperty("pos", &stCharaStatus::pos)
			.addProperty("beforePos", &stCharaStatus::beforePos)
			.addProperty("oldPos", &stCharaStatus::oldPos)
			.addProperty("navelPos", &stCharaStatus::navelPos)
			.addProperty("brainPos", &stCharaStatus::brainPos)
			.addProperty("rot", &stCharaStatus::rot)
			.addProperty("scale", &stCharaStatus::scale)
			.addProperty("qRot", &stCharaStatus::qRot)
			.addProperty("movSpd", &stCharaStatus::movSpd)
			.addProperty("hitSize", &stCharaStatus::hitSize)
			.addProperty("height", &stCharaStatus::height)
			.addProperty("aPos", &stCharaStatus::aPos)
			.addProperty("aRot", &stCharaStatus::aRot)
			.addProperty("enterPattern", &stCharaStatus::enterPattern)
			.addProperty("reactionDist", &stCharaStatus::reactionDist)
			.addProperty("itemNo", &stCharaStatus::itemNo)
			.addProperty("mAiDefBasic", &stCharaStatus::mAiDefBasic)
			.addProperty("mAiDefCurrent", &stCharaStatus::mAiDefCurrent)
			.addProperty("mAiDefTick", &stCharaStatus::mAiDefTick)
			.addProperty("mAiDefBaseTick", &stCharaStatus::mAiDefBaseTick)
			.addProperty("mAiDamageCount", &stCharaStatus::mAiDamageCount)
			// native pointer type (char*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("pScriptProc", &stCharaStatus::pScriptProc)
			.addProperty("tsubazeriNum", &stCharaStatus::tsubazeriNum)
			.addProperty("DamageAcceptFrame", &stCharaStatus::DamageAcceptFrame)
			.addProperty("motionNo", &stCharaStatus::motionNo)
			.addProperty("motionBrendNum", &stCharaStatus::motionBrendNum)
			.addProperty("motSpd", &stCharaStatus::motSpd)
			.addProperty("subMotSpd", &stCharaStatus::subMotSpd)
			.addProperty("condition", &stCharaStatus::condition)
			.addProperty("footHitResultObj", &stCharaStatus::footHitResultObj)
			.addProperty("footHitResult", &stCharaStatus::footHitResult)
			.addProperty("footHitResultObj2", &stCharaStatus::footHitResultObj2)
			.addProperty("HitWallObj", &stCharaStatus::HitWallObj)
			.addProperty("hitWallMaterial", &stCharaStatus::hitWallMaterial)
			.addProperty("HitWallNormal", &stCharaStatus::HitWallNormal)
			.addProperty("dmgInfo", &stCharaStatus::dmgInfo)
			.addProperty("mYukaNormal", &stCharaStatus::mYukaNormal)
			.addProperty("mFootNumber", &stCharaStatus::mFootNumber)
			.addProperty("movTick", &stCharaStatus::movTick)
			.addProperty("hitNum", &stCharaStatus::hitNum)
			.addProperty("hitColl", &stCharaStatus::hitColl)
			.addProperty("mAiAtkLv", &stCharaStatus::mAiAtkLv)
			.addProperty("mAiAtkClass", &stCharaStatus::mAiAtkClass)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("AtkAi", &stCharaStatus::AtkAi)
			.addProperty("renderSkipCounter", &stCharaStatus::renderSkipCounter)
			.addProperty("renderSkipMotSpd", &stCharaStatus::renderSkipMotSpd)
			.addProperty("frameStop", &stCharaStatus::frameStop)
			.addProperty("lockOnDistance", &stCharaStatus::lockOnDistance)
			.addProperty("lockOnDistanceHi", &stCharaStatus::lockOnDistanceHi)
			.addProperty("lockOnDistanceLow", &stCharaStatus::lockOnDistanceLow)
			.addProperty("DrawYAdjust", &stCharaStatus::DrawYAdjust)
			.addProperty("bBloom", &stCharaStatus::bBloom)
			.addProperty("JumpBlockHit", &stCharaStatus::JumpBlockHit)
			.addProperty("AtkDisAdjust", &stCharaStatus::AtkDisAdjust)
			.addProperty("TubaFrmOffset", &stCharaStatus::TubaFrmOffset)
			.addProperty("motionNoNpc", &stCharaStatus::motionNoNpc)
			.addProperty("semiTransRate", &stCharaStatus::semiTransRate)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("flag", &stCharaStatus::flag)
		.endClass();
	}
#endif
};
static_assert(sizeof(stCharaStatus::resNo) == 4, "expected resNo to be size 4");
static_assert(sizeof(stCharaStatus::datNo) == 4, "expected datNo to be size 4");
static_assert(sizeof(stCharaStatus::charaType) == 4, "expected charaType to be size 4");
static_assert(sizeof(stCharaStatus::zakoWepType) == 2, "expected zakoWepType to be size 2");
static_assert(sizeof(stCharaStatus::maxHp) == 4, "expected maxHp to be size 4");
static_assert(sizeof(stCharaStatus::hp) == 4, "expected hp to be size 4");
static_assert(sizeof(stCharaStatus::money) == 2, "expected money to be size 2");
static_assert(sizeof(stCharaStatus::dropMoney) == 2, "expected dropMoney to be size 2");
static_assert(sizeof(stCharaStatus::tension) == 4, "expected tension to be size 4");
static_assert(sizeof(stCharaStatus::hajikiCount) == 4, "expected hajikiCount to be size 4");
static_assert(sizeof(stCharaStatus::alwaysCheckHitColl) == 1, "expected alwaysCheckHitColl to be size 1");
static_assert(sizeof(stCharaStatus::pos) == 12, "expected pos to be size 12");
static_assert(sizeof(stCharaStatus::beforePos) == 12, "expected beforePos to be size 12");
static_assert(sizeof(stCharaStatus::oldPos) == 12, "expected oldPos to be size 12");
static_assert(sizeof(stCharaStatus::navelPos) == 12, "expected navelPos to be size 12");
static_assert(sizeof(stCharaStatus::brainPos) == 12, "expected brainPos to be size 12");
static_assert(sizeof(stCharaStatus::rot) == 12, "expected rot to be size 12");
static_assert(sizeof(stCharaStatus::scale) == 12, "expected scale to be size 12");
static_assert(sizeof(stCharaStatus::qRot) == 16, "expected qRot to be size 16");
static_assert(sizeof(stCharaStatus::movSpd) == 4, "expected movSpd to be size 4");
static_assert(sizeof(stCharaStatus::hitSize) == 4, "expected hitSize to be size 4");
static_assert(sizeof(stCharaStatus::height) == 4, "expected height to be size 4");
static_assert(sizeof(stCharaStatus::aPos) == 96, "expected aPos to be size 96");
static_assert(sizeof(stCharaStatus::aRot) == 96, "expected aRot to be size 96");
static_assert(sizeof(stCharaStatus::enterPattern) == 4, "expected enterPattern to be size 4");
static_assert(sizeof(stCharaStatus::reactionDist) == 4, "expected reactionDist to be size 4");
static_assert(sizeof(stCharaStatus::itemNo) == 4, "expected itemNo to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefBasic) == 4, "expected mAiDefBasic to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefCurrent) == 4, "expected mAiDefCurrent to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefTick) == 4, "expected mAiDefTick to be size 4");
static_assert(sizeof(stCharaStatus::mAiDefBaseTick) == 4, "expected mAiDefBaseTick to be size 4");
static_assert(sizeof(stCharaStatus::mAiDamageCount) == 4, "expected mAiDamageCount to be size 4");
static_assert(sizeof(stCharaStatus::pScriptProc) == 4, "expected pScriptProc to be size 4");
static_assert(sizeof(stCharaStatus::tsubazeriNum) == 4, "expected tsubazeriNum to be size 4");
static_assert(sizeof(stCharaStatus::DamageAcceptFrame) == 4, "expected DamageAcceptFrame to be size 4");
static_assert(sizeof(stCharaStatus::motionNo) == 4, "expected motionNo to be size 4");
static_assert(sizeof(stCharaStatus::motionBrendNum) == 1, "expected motionBrendNum to be size 1");
static_assert(sizeof(stCharaStatus::motSpd) == 4, "expected motSpd to be size 4");
static_assert(sizeof(stCharaStatus::subMotSpd) == 4, "expected subMotSpd to be size 4");
static_assert(sizeof(stCharaStatus::condition) == 4, "expected condition to be size 4");
static_assert(sizeof(stCharaStatus::footHitResultObj) == 4, "expected footHitResultObj to be size 4");
static_assert(sizeof(stCharaStatus::footHitResult) == 4, "expected footHitResult to be size 4");
static_assert(sizeof(stCharaStatus::footHitResultObj2) == 76, "expected footHitResultObj2 to be size 76");
static_assert(sizeof(stCharaStatus::HitWallObj) == 76, "expected HitWallObj to be size 76");
static_assert(sizeof(stCharaStatus::hitWallMaterial) == 4, "expected hitWallMaterial to be size 4");
static_assert(sizeof(stCharaStatus::HitWallNormal) == 12, "expected HitWallNormal to be size 12");
static_assert(sizeof(stCharaStatus::dmgInfo) == 108, "expected dmgInfo to be size 108");
static_assert(sizeof(stCharaStatus::mYukaNormal) == 12, "expected mYukaNormal to be size 12");
static_assert(sizeof(stCharaStatus::mFootNumber) == 4, "expected mFootNumber to be size 4");
static_assert(sizeof(stCharaStatus::movTick) == 4, "expected movTick to be size 4");
static_assert(sizeof(stCharaStatus::hitNum) == 2, "expected hitNum to be size 2");
static_assert(sizeof(stCharaStatus::hitColl) == 96, "expected hitColl to be size 96");
static_assert(sizeof(stCharaStatus::mAiAtkLv) == 4, "expected mAiAtkLv to be size 4");
static_assert(sizeof(stCharaStatus::mAiAtkClass) == 4, "expected mAiAtkClass to be size 4");
static_assert(sizeof(stCharaStatus::AtkAi) == 20, "expected AtkAi to be size 20");
static_assert(sizeof(stCharaStatus::renderSkipCounter) == 4, "expected renderSkipCounter to be size 4");
static_assert(sizeof(stCharaStatus::renderSkipMotSpd) == 4, "expected renderSkipMotSpd to be size 4");
static_assert(sizeof(stCharaStatus::frameStop) == 4, "expected frameStop to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistance) == 4, "expected lockOnDistance to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistanceHi) == 4, "expected lockOnDistanceHi to be size 4");
static_assert(sizeof(stCharaStatus::lockOnDistanceLow) == 4, "expected lockOnDistanceLow to be size 4");
static_assert(sizeof(stCharaStatus::DrawYAdjust) == 4, "expected DrawYAdjust to be size 4");
static_assert(sizeof(stCharaStatus::bBloom) == 1, "expected bBloom to be size 1");
static_assert(sizeof(stCharaStatus::JumpBlockHit) == 1, "expected JumpBlockHit to be size 1");
static_assert(sizeof(stCharaStatus::AtkDisAdjust) == 4, "expected AtkDisAdjust to be size 4");
static_assert(sizeof(stCharaStatus::TubaFrmOffset) == 4, "expected TubaFrmOffset to be size 4");
static_assert(sizeof(stCharaStatus::motionNoNpc) == 4, "expected motionNoNpc to be size 4");
static_assert(sizeof(stCharaStatus::semiTransRate) == 32, "expected semiTransRate to be size 32");
static_assert(sizeof(stCharaStatus::flag) == 8, "expected flag to be size 8");
static_assert(sizeof(struct stCharaStatus) == 924, "expected struct stCharaStatus to be size 924");

// class ghmListObj
// no dependencies
class ghmListObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x6], offset 0x0>
	void* (* field_0)[0x6];

	// <ghmListObj* mpPrev, offset 0x4>
	ghmListObj* mpPrev;

	// <ghmListObj* mpNext, offset 0x8>
	ghmListObj* mpNext;

	// <int32_t mPriority, offset 0xc>
	int32_t mPriority;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmListObj>("ghmListObj")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmListObj::field_0)
			.addProperty("mpPrev", &ghmListObj::mpPrev)
			.addProperty("mpNext", &ghmListObj::mpNext)
			.addProperty("mPriority", &ghmListObj::mPriority)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmListObj::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmListObj::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(ghmListObj::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(ghmListObj::mPriority) == 4, "expected mPriority to be size 4");
static_assert(sizeof(class ghmListObj) == 16, "expected class ghmListObj to be size 16");

// class mHRChara
// 25 dependencies: class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc
class mHRChara : ghmListObj
{
public:
	/// 363 namespace types: enum enCharaType __convention("thiscall") mHRChara::mGetCharaType(class mHRChara* const this), uint8_t mHRChara::isCharacterTypeZako(enum enCharaType arg1), uint8_t __convention("thiscall") mHRChara::mTestZako(class mHRChara* const this), uint8_t mHRChara::isCharacterTypeBoss(enum enCharaType arg1), uint8_t __convention("thiscall") mHRChara::mTestBoss(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mTestEnemy(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetItemNo(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mSetLockOnNoCheckColl(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetLockOnDistanceLow(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mSetLockOnDistanceHi(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mSetLockOnDistance(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mSetCanLockOn(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetDisableDameged(class mHRChara* const this, uint8_t arg2), uint8_t __convention("thiscall") mHRChara::mGetDisableDameged(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetMaxHp(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mUndispTgtIcn(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mDispTgtIcn(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetHp(class mHRChara* const this), enum enCharaCondition __convention("thiscall") mHRChara::mGetCondition(class mHRChara* const this), class mHRChara* __convention("thiscall") mHRChara::mGetNext(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetHp(class mHRChara* const this, float arg2), class mHRChara* mHRChara::mGetTop(), struct Vec& __convention("thiscall") mHRChara::mGetRot(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetCharaPause(class mHRChara* const this, uint8_t arg2), float __convention("thiscall") mHRChara::mGetRotY(class mHRChara* const this), struct WGclMaterialSpec* __convention("thiscall") mHRChara::GetGroundTouchMaterial(class mHRChara* const this), struct stCharaStatus* __convention("thiscall") mHRChara::mGetStatusPtr(class mHRChara* const this), struct Vec& __convention("thiscall") mHRChara::mGetPos(class mHRChara* const this), int32_t __convention("thiscall") mHRChara::mGetMotionNo(class mHRChara* const this), char* __convention("thiscall") mHRChara::mGetFileName(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsTubaAngleCorrect(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::getMiraretaiPosition(class mHRChara* const this, struct Vec* arg2), uint8_t __convention("thiscall") mHRChara::isHopeInterestMe(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsWatchPc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsUseRotMov(class mHRChara* const this), char const* __convention("thiscall") mHRChara::getCurMotionName(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mTestRunMotion(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mZakoDieOut(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCreateLoseSight(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckDamageMotion(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckEnterMotion(class mHRChara* const this), class TGan* __convention("thiscall") mHRChara::mpGetGan(class mHRChara* const this, int32_t arg2), class TGmf* __convention("thiscall") mHRChara::mGetCurResourceGmfPtr(class mHRChara* const this), class TGmf* __convention("thiscall") mHRChara::mGetCurResourceGmfPtr(class mHRChara* const this), class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfWepLPtr(class mHRChara* const this), class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfWepRPtr(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetResourceGmfPtr(class mHRChara* const this, class TGmf* arg2, char* arg3), class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfDeadPtr(class mHRChara* const this), class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfDeadPtr(class mHRChara* const this), class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfPtr(class mHRChara* const this), class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfPtr(class mHRChara* const this), class ghmGcCollObjCapsule* __convention("thiscall") mHRChara::mGetCollPtr(class mHRChara* const this), void __convention("thiscall") mHRChara::mSethitOidashiDisEnable(class mHRChara* const this, uint8_t arg2), struct Vec& __convention("thiscall") mHRChara::mGetBrainPos(class mHRChara* const this), struct Vec& __convention("thiscall") mHRChara::mGetHitPos(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetMirrorModel(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetVisibleDist(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetCondition(class mHRChara* const this, enum enCharaCondition arg2), void __convention("thiscall") mHRChara::mSetSubMotionSpd(class mHRChara* const this, float arg2), uint8_t __convention("thiscall") mHRChara::mCheck4tsunbai(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckSquat(class mHRChara* const this), void __convention("thiscall") mHRChara::mGetThrowMotNo(class mHRChara* const this, int32_t* arg2, int32_t* arg3), int32_t __convention("thiscall") mHRChara::mGetTsubazeriMotionID(class mHRChara* const this), void __convention("thiscall") mHRChara::mTsubazeriDifficultyClear(class mHRChara* const this), void __convention("thiscall") mHRChara::mTsubazeriDifficultyUp(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsTubaPosAdjust(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckGuard(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckAttack(class mHRChara* const this), void __convention("thiscall") mHRChara::mSubTension(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mAddTension(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mSetTension(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mResetTension(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetMovSpd(class mHRChara* const this, float arg2), uint8_t __convention("thiscall") mHRChara::UnderControllAttack_A(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::UnderControllComboAttack(class mHRChara* const this), void __convention("thiscall") mHRChara::ExitUnderControl(class mHRChara* const this), void __convention("thiscall") mHRChara::EnterUnderControl(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mPostRenderProc(class mHRChara* const this), float __convention("thiscall") mHRChara::getViewClipBoxPositionOffsetY(class mHRChara* const this), void __convention("thiscall") mHRChara::getViewClipBoxHalfLengthXYZ(class mHRChara* const this, struct Vec* arg2), int32_t __convention("thiscall") mHRChara::mGetResNo(class mHRChara* const this), int32_t __convention("thiscall") mHRChara::mGetDropMoney(class mHRChara* const this), int32_t __convention("thiscall") mHRChara::mGetItemNo(class mHRChara* const this), void __convention("thiscall") mHRChara::setLocatorNode(class mHRChara* const this, class TGmfNode* arg2), float __convention("thiscall") mHRChara::mGetHpRate(class mHRChara* const this), void __convention("thiscall") mHRChara::mSubHp(class mHRChara* const this, float arg2), float __convention("thiscall") mHRChara::mGetHitSize(class mHRChara* const this), enum enCharaInitProc __convention("thiscall") mHRChara::mGetInitProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::isCrashBreak(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetCharaHit(class mHRChara* const this, uint8_t arg2), int32_t __convention("thiscall") mHRChara::mGetDmgAtkMot(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetMotionProcessDisEnable(class mHRChara* const this, uint8_t arg2), float __convention("thiscall") mHRChara::mGetMotionSpd(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetStageHitDisEnable(class mHRChara* const this, uint8_t arg2), uint8_t __convention("thiscall") mHRChara::IsFootShadowDraw(class mHRChara* const this), void __convention("thiscall") mHRChara::SetFootShadowDraw(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetMotionNoNpc(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mSetCallScriptProc(class mHRChara* const this, char* arg2), void __convention("thiscall") mHRChara::mSetDropMoney(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mSetReactionDist(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mSetEnterPattern(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mSetDatNo(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mSetResNo(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mSetCharaType(class mHRChara* const this, enum enCharaType arg2), int32_t __convention("thiscall") mHRChara::mGetDatNo(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetResourceDeleteFlag(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetDmgUpperPosY(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetDmgUpper(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetResourceDeleteFlag(class mHRChara* const this, uint8_t arg2), class ghmPlane& __convention("thiscall") mHRChara::getLatestGroundTouchPlane(class mHRChara* const this), void __convention("thiscall") mHRChara::mUndispBtlIcn(class mHRChara* const this), void __convention("thiscall") mHRChara::mChgBtlIcnTb(class mHRChara* const this), void __convention("thiscall") mHRChara::SetDrawYAdjust(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mSetDemoCtrl(class mHRChara* const this, uint8_t arg2), uint64_t __convention("thiscall") mHRChara::mGetDemoCtrl(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::isAcceptDistanceDelete(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetStageHitDisEnableReq(class mHRChara* const this, uint8_t arg2), struct stCharaEffect* __convention("thiscall") mHRChara::mGetEffectStPtr(class mHRChara* const this), void __convention("thiscall") mHRChara::setBlackBodyEffect(class mHRChara* const this, class EffectEnemyDamage* arg2), struct Vec& __convention("thiscall") mHRChara::mGetNavelPos(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetDamageAcceptFrame(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mSetAlwaysCheckHitColl(class mHRChara* const this, uint8_t arg2), uint8_t __convention("thiscall") mHRChara::mGetLockOnNoCheckColl(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetLockOnDistanceLow(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetLockOnDistanceHi(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetLockOnDistance(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetAliveBtlIcn(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetSlowBlow(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetInputFinishReq(class mHRChara* const this, uint8_t arg2), class TGan* __convention("thiscall") mHRChara::mGetResourceGanPtr(class mHRChara* const this, int32_t arg2), int16_t __convention("thiscall") mHRChara::mGetMoney(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetMoney(class mHRChara* const this, int16_t arg2), uint8_t __convention("thiscall") mHRChara::mGetInputFinishReq(class mHRChara* const this), void __convention("thiscall") mHRChara::mAddMoney(class mHRChara* const this, int16_t arg2), void __convention("thiscall") mHRChara::mSetInvincibleMotion(class mHRChara* const this, int32_t arg2, int32_t arg3), void __convention("thiscall") mHRChara::mResetInvincibleMotion(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCanGetHitByMotion(class mHRChara* const this, int32_t arg2), uint8_t __convention("thiscall") mHRChara::mDispAtkHitIcn(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetDontStandUp(class mHRChara* const this), float __convention("thiscall") mHRChara::GetTubaFrmOffset(class mHRChara* const this), float __convention("thiscall") mHRChara::GetAtkDisAdjust(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetLoseTsubazeriFlag(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetSuccessThrow(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetRotYA(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mSetDontStandUp(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetDmgGrav(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mChgBtlIcnSml(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mChgBtlIcnBig(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetCharaHit(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetCanLockOn(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGethitOidashiDisEnable(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetWepVisible(class mHRChara* const this), int32_t __convention("thiscall") mHRChara::mGetMotionBrendNum(class mHRChara* const this), int16_t __convention("thiscall") mHRChara::mGetAiValue(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mResetPosA(class mHRChara* const this), class ghmPlane& __convention("thiscall") mHRChara::getEasyShadowProjectionPlane(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::isInterestTarget(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetMotionSpd(class mHRChara* const this, float arg2), uint8_t __convention("thiscall") mHRChara::mGetWepEffectVisible(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetVisible(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetTension(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetMiniMapRender(class mHRChara* const this), class ghmResGroup* __convention("thiscall") mHRChara::mGetResourceRslPtr(class mHRChara* const this), int32_t __convention("thiscall") mHRChara::getFootNumber(class mHRChara* const this), void* __convention("thiscall") mHRChara::`vector deleting destructor'(class mHRChara* const this, uint32_t arg2), char* __convention("thiscall") mHRChara::mGetCallScriptProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetMotionProcessDisEnable(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsBloom(class mHRChara* const this), void __convention("thiscall") mHRChara::SetTermAll(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::SetKnockBackSpd(class mHRChara* const this, float arg2), float __convention("thiscall") mHRChara::GetKnockBackSpd(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetStageHitDisEnable(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetStartSplitFlameFlag(class mHRChara* const this), class TGmf* __convention("thiscall") mHRChara::getBoneEffectGmf(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetStartSplitFlameFlag(class mHRChara* const this, uint8_t arg2), uint8_t __convention("thiscall") mHRChara::mGetCharaPause(class mHRChara* const this), struct Vec& __convention("thiscall") mHRChara::mGetBeforePos(class mHRChara* const this), int16_t __convention("thiscall") mHRChara::mGetZakoWepType(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetFootHitResultObj2(class mHRChara* const this, class ghmGcCollObjHitResultObj& arg2), void __convention("thiscall") mHRChara::mSetDmgUpperPow(class mHRChara* const this, float arg2), void __convention("thiscall") mHRChara::mAddHp(class mHRChara* const this, float arg2), float __convention("thiscall") mHRChara::mGetSubMotionSpd(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetZakoWepType(class mHRChara* const this, int16_t arg2), void __convention("thiscall") mHRChara::mSetHitSize(class mHRChara* const this, float arg2), float __convention("thiscall") mHRChara::mGetReactionDist(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetMiniMapRender(class mHRChara* const this, uint8_t arg2), struct Vec __convention("thiscall") mHRChara::GetKnockBackDir(class mHRChara* const this), int32_t __convention("thiscall") mHRChara::mGetMotionNoNpc(class mHRChara* const this), void __convention("thiscall") mHRChara::SetNormalClip(class mHRChara* const this, uint8_t arg2), struct Vec& __convention("thiscall") mHRChara::mGetOldPos(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mGetSuccessThrow(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetDmgUpperPosY(class mHRChara* const this, float const arg2), void __convention("thiscall") mHRChara::SetDeleteReq(class mHRChara* const this), void __convention("thiscall") mHRChara::getShootPosiAndYaw(class mHRChara* const this, struct Vec* arg2, float* arg3, class TGmf& arg4, char const* arg5), void __convention("thiscall") mHRChara::setHomingPositionFromAI(class mHRChara* const this, struct Vec& arg2), void __convention("thiscall") mHRChara::setHomingActFlagFromAI(class mHRChara* const this, uint8_t const arg2), uint8_t __convention("thiscall") mHRChara::isHoming(class mHRChara* const this), void __convention("thiscall") mHRChara::setInterestUseBoneNumFromAI(class mHRChara* const this, int32_t const arg2), uint8_t __convention("thiscall") mHRChara::isInteresting(class mHRChara* const this), void __convention("thiscall") mHRChara::addDamageToYuremono(class mHRChara* const this, float const arg2, struct Vec& arg3), uint8_t __convention("thiscall") mHRChara::mSetHajikiCheck(class mHRChara* const this, float arg2), uint8_t __convention("thiscall") mHRChara::mCheckDamageAccept(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mTestZakoDown(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mTestPiyoRequest(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetPiyoriHeight(class mHRChara* const this), class mHRChara* mHRChara::mGetCharaPtr(int32_t arg1), void mHRChara::mRenderGmf(void* arg1), int32_t mHRChara::debugDispCharaInfo(), uint8_t mHRChara::mTermAllZakoMotion(), uint8_t mHRChara::mInitAllNpc(), void __convention("thiscall") mHRChara::mCreateBloodSplash(class mHRChara* const this, class TGmfNode* arg2, float arg3, struct tagHRTASKCHECK* arg4), void __convention("thiscall") mHRChara::mBloodSplashProc(class mHRChara* const this), void __convention("thiscall") mHRChara::AddBoneElectPtrToList(class mHRChara* const this, class EffectBoneElect* arg2), uint8_t __convention("thiscall") mHRChara::ReleaseBoneElect(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsEmtpyBoneElectList(class mHRChara* const this), void __convention("thiscall") mHRChara::DeleteBoneElectFromList(class mHRChara* const this, class EffectBoneElect* arg2), void __convention("thiscall") mHRChara::AddCutmarkPtrToList(class mHRChara* const this, class EffectCutMark* arg2), uint8_t __convention("thiscall") mHRChara::IsEmtpyCutmarkList(class mHRChara* const this), void __convention("thiscall") mHRChara::DeleteCutmarkFromList(class mHRChara* const this, class EffectCutMark* arg2), uint8_t __convention("thiscall") mHRChara::SetPowerFlash(class mHRChara* const this, int32_t arg2, struct GXColor arg3), uint8_t __convention("thiscall") mHRChara::SetNoGuardEffect(class mHRChara* const this), uint8_t mHRChara::mCheckAtkAllNpc(), uint8_t mHRChara::mCheckCanAtk(), void __convention("thiscall") mHRChara::mCallBeforeRenderProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckCanHit(class mHRChara* const this, int32_t arg2, uint8_t arg3, uint8_t arg4), void __convention("thiscall") mHRChara::CreateFootSmokeEffect(class mHRChara* const this), void __convention("thiscall") mHRChara::KnockBackProc(class mHRChara* const this), float __convention("thiscall") mHRChara::GetKnockBackRatio(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mSetDamage(class mHRChara* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), void __convention("thiscall") mHRChara::mInitDamageMotInfo(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mChangeDefAi(class mHRChara* const this, uint8_t arg2, uint8_t arg3), void __convention("thiscall") mHRChara::mSetDefAI(class mHRChara* const this, uint8_t arg2), uint8_t __convention("thiscall") mHRChara::mCheckCallFrameProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsNowUnderControl(class mHRChara* const this), void __convention("thiscall") mHRChara::RegistUnderControlAtkFuncPtr(class mHRChara* const this), void __convention("thiscall") mHRChara::RegistUnderControlMotID(class mHRChara* const this, struct CharControlMotID& arg2), void __convention("thiscall") mHRChara::SetUnderControlFlag(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::DrawDebugCollision(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mRenderProc(class mHRChara* const this), void __convention("thiscall") mHRChara::postSetupMatrix(class mHRChara* const this), void __convention("thiscall") mHRChara::preSetupMatrix(class mHRChara* const this), void __convention("thiscall") mHRChara::mFootSmokeEffect(class mHRChara* const this), void __convention("thiscall") mHRChara::mPosAnimationProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mPostFrameProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mFrameProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mInit(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetRotA(class mHRChara* const this, struct Vec& arg2, uint32_t const arg3), void __convention("thiscall") mHRChara::mSetWepEffectVisibleInstant(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSubFrameStop(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mPlayMotionMov(class mHRChara* const this, int32_t arg2, float arg3, float arg4, float arg5, uint8_t arg6), uint8_t __convention("thiscall") mHRChara::mTestMotion(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::mSetDifficultyMotionSpeed(class mHRChara* const this, float arg2), class mHRChara* mHRChara::getCharaByGM2FileName(char const* arg1), void __convention("thiscall") mHRChara::mSetDeath(class mHRChara* const this), void __convention("thiscall") mHRChara::mDamageCallBackForScript(class mHRChara* const this, int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4, int32_t arg5), uint8_t __convention("thiscall") mHRChara::mGetMotionPlay(class mHRChara* const this), class mHRChara* mHRChara::mGetAliveResourceCharaPtr(enum enCharaType arg1, uint32_t arg2), uint8_t __convention("thiscall") mHRChara::ReleaseCutmark(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mTestPiyori(class mHRChara* const this), uint32_t __convention("thiscall") mHRChara::mGetMotionTotalTick(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::setInterestPositionFromAI(class mHRChara* const this, struct Vec& arg2), void __convention("thiscall") mHRChara::setInterestActFlagFromAI(class mHRChara* const this, uint8_t const arg2), uint8_t __convention("thiscall") mHRChara::mGetWepTopPos(class mHRChara* const this, struct Vec* arg2, enum enWepLeftRight arg3), void __convention("thiscall") mHRChara::mInitDamageStatus(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mPostFrameCommonProc1(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mPostFrameCommonProc2(class mHRChara* const this), void __convention("thiscall") mHRChara::SetKnockBack(class mHRChara* const this, float arg2, struct Vec& arg3, float arg4), uint8_t __convention("thiscall") mHRChara::CheckWallCrashAndDamageProc(class mHRChara* const this, int32_t const arg2, int32_t const arg3), uint8_t __convention("thiscall") mHRChara::mSetHpBarVisible(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetPosA(class mHRChara* const this, struct Vec& arg2, uint32_t const arg3, int32_t const arg4), uint8_t __convention("thiscall") mHRChara::mSetSimpleHpBarVisible(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mPlayCamMotFromCharMot(class mHRChara* const this, int32_t arg2, int32_t arg3, uint8_t arg4, uint8_t arg5, uint8_t arg6), uint8_t __convention("thiscall") mHRChara::mPlayMotionMov(class mHRChara* const this, int32_t arg2, float arg3, float arg4, uint8_t arg5), void __convention("thiscall") mHRChara::checkDeleteBlackBodyEffect(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetHitCounter(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mReleaseBloodSplash(class mHRChara* const this, uint8_t arg2), uint8_t __convention("thiscall") mHRChara::mPreFrameProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mPreRenderProc(class mHRChara* const this), void __convention("thiscall") mHRChara::mDetouchMotionBrend(class mHRChara* const this), void __convention("thiscall") mHRChara::mReleaseDemoBtleIcn(class mHRChara* const this), uint8_t mHRChara::isThisCharaExist(class mHRChara* arg1), uint8_t mHRChara::mTermAllNpc(), int32_t mHRChara::mGetPopZakoNum(), void __convention("thiscall") mHRChara::mDeleteDispChara(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetAiDef(class mHRChara* const this, int32_t arg2), void __convention("thiscall") mHRChara::setFootShadowDrawFlag(class mHRChara* const this, uint8_t const arg2), uint8_t mHRChara::mFrameProcAll(), uint8_t mHRChara::mRenderProcAll(uint8_t arg1), uint8_t mHRChara::mPostRenderProcAll(), uint8_t mHRChara::mTermAllNpcWithoutCmnObj(), uint8_t mHRChara::mTermAllEnemyNpc(), class mHRChara* mHRChara::mGetNpcTop(), void __convention("thiscall") mHRChara::~mHRChara(class mHRChara* const this), void __convention("thiscall") mHRChara::mHRChara(class mHRChara* const this), void __convention("thiscall") mHRChara::SetFileName(class mHRChara* const this, char const* arg2), void __convention("thiscall") mHRChara::mSetMaxHp(class mHRChara* const this, float arg2), uint8_t __convention("thiscall") mHRChara::mTerm(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetPos(class mHRChara* const this, struct Vec& arg2, uint8_t arg3, float arg4), void __convention("thiscall") mHRChara::mSetRot(class mHRChara* const this, struct Vec& arg2), void __convention("thiscall") mHRChara::mSetScale(class mHRChara* const this, struct Vec& arg2), uint8_t __convention("thiscall") mHRChara::mHitCheck(class mHRChara* const this, class mHRChara* arg2), void __convention("thiscall") mHRChara::mMotionSpeedControl(class mHRChara* const this), void __convention("thiscall") mHRChara::mCallMotionProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mPlayMotion(class mHRChara* const this, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6), void __convention("thiscall") mHRChara::mCallMoneyDrop(class mHRChara* const this, int32_t arg2, uint8_t arg3, uint8_t arg4), uint8_t __convention("thiscall") mHRChara::mAttachWep(class mHRChara* const this, class TGmf* arg2, enum eUDLR arg3, char* arg4), uint8_t __convention("thiscall") mHRChara::mDetachWep(class mHRChara* const this, enum eUDLR arg2, char* arg3), void __convention("thiscall") mHRChara::mSemitransparentProcess(class mHRChara* const this), void __convention("thiscall") mHRChara::mUpdateAtkColl(class mHRChara* const this), void __convention("thiscall") mHRChara::mRenderShadowProc(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mRefreshFloorPosition(class mHRChara* const this, float arg2, uint8_t arg3), uint8_t __convention("thiscall") mHRChara::mDamageProc(class mHRChara* const this), void __convention("thiscall") mHRChara::mRestoreDamage(class mHRChara* const this, int32_t arg2, float arg3), uint8_t __convention("thiscall") mHRChara::mCheckAttack(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckCanAttack(class mHRChara* const this), void __convention("thiscall") mHRChara::mGetTsubazeriaiPos(class mHRChara* const this, struct Vec* arg2), void __convention("thiscall") mHRChara::mSetPcTsubaOuterMot(class mHRChara* const this), struct Vec __convention("thiscall") mHRChara::GetTsubaEffectPos(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckCanCatch(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckCanThrow(class mHRChara* const this), void __convention("thiscall") mHRChara::mPlayThrownMotion(class mHRChara* const this, int32_t arg2, int32_t arg3), uint8_t __convention("thiscall") mHRChara::mPlayMotionBlend(class mHRChara* const this, class TGan** arg2, char arg3), uint8_t __convention("thiscall") mHRChara::mPlayMotionBlend(class mHRChara* const this, int32_t arg2, char arg3, uint8_t arg4, uint8_t arg5), void __convention("thiscall") mHRChara::mBossDeadCommonProcess(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckCanLockOn(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::getLockOnCursorBasePosition(class mHRChara* const this, struct Vec* arg2), void __convention("thiscall") mHRChara::mSetVisible(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetWepVisible(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetWepEffectVisible(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetVisibleDist(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mEffectInit(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetMirrorModel(class mHRChara* const this, uint8_t arg2), void __convention("thiscall") mHRChara::mSetAiAtk(class mHRChara* const this, int32_t arg2, int32_t arg3), void __convention("thiscall") mHRChara::mSetWarpPos(class mHRChara* const this, struct Vec& arg2, uint8_t arg3), uint8_t __convention("thiscall") mHRChara::mHitCheckStage(class mHRChara* const this, class ghmGcCollObjCapsule* arg2, struct Vec* arg3, struct Vec* arg4, struct Vec* arg5, struct Vec* arg6, class ghmGcCollObj** arg7, class ghmGcCollObjHitResult** arg8, class ghmGcCollObjHitResultObj* arg9, struct WGclMaterialSpec** arg10, uint8_t* arg11, uint8_t arg12, float arg13), class TGan* __convention("thiscall") mHRChara::mpGetGan(class mHRChara* const this, int32_t arg2), class TGan** __convention("thiscall") mHRChara::mppGetGan(class mHRChara* const this, int32_t arg2), uint8_t __convention("thiscall") mHRChara::mRequestBloodSplash(class mHRChara* const this, char* arg2, int32_t arg3), void __convention("thiscall") mHRChara::mCallKillPcProcess(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCheckComboing(class mHRChara* const this), float __convention("thiscall") mHRChara::mGetAttackTableValue(class mHRChara* const this, int32_t arg2, int32_t arg3), float __convention("thiscall") mHRChara::mGetAttackDirection(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mTestLowDmg(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mCreatePiyori(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mTermPiyori(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::mPiyoriProc(class mHRChara* const this), void __convention("thiscall") mHRChara::mSetDamageAcceptFrame(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsMultiStep(class mHRChara* const this), uint8_t __convention("thiscall") mHRChara::IsDownAttack(class mHRChara* const this), float __convention("thiscall") mHRChara::getFootShadowWidthHalf(class mHRChara* const this), float __convention("thiscall") mHRChara::getFootShadowDepthPlus(class mHRChara* const this), float __convention("thiscall") mHRChara::getFootShadowDepthMinus(class mHRChara* const this), void __convention("thiscall") mHRChara::OnStageUnload(class mHRChara* const this), void __convention("thiscall") mHRChara::setFootGroundTouchActFlagFromAI(class mHRChara* const this, uint8_t const arg2), void __convention("thiscall") mHRChara::mPlayCamMot(class mHRChara* const this, class TGan* arg2, int32_t arg3, uint8_t arg4, struct Vec* arg5, float* arg6, uint8_t arg7), void __convention("thiscall") mHRChara::mStopCamMotFromCharMot(class mHRChara* const this), uint8_t mHRChara::mRenderShadowProcAll(), void __convention("thiscall") mHRChara::mSetRotY(class mHRChara* const this, float arg2), uint8_t __convention("thiscall") mHRChara::mCheckSegmentHitStage(class mHRChara* const this, int64_t arg2, int32_t, float arg4, uint8_t arg5, float* arg6, struct Vec* arg7), void __convention("thiscall") mHRChara::mEraseDispChara(class mHRChara* const this), class mHRChara* mHRChara::mGetCharaPtr(enum enCharaType arg1, uint32_t arg2), class mHRChara* mHRChara::mAllSearchPiyoZako(), void mHRChara::OnStageUnloadAll()

	// TODO: Function 'enum enCharaType __convention("thiscall") mHRChara::mGetCharaType(class mHRChara* const this)'
	// TODO: Function 'uint8_t mHRChara::isCharacterTypeZako(enum enCharaType arg1)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestZako(class mHRChara* const this)'
	// TODO: Function 'uint8_t mHRChara::isCharacterTypeBoss(enum enCharaType arg1)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestBoss(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestEnemy(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetItemNo(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetLockOnNoCheckColl(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetLockOnDistanceLow(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetLockOnDistanceHi(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetLockOnDistance(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetCanLockOn(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDisableDameged(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetDisableDameged(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetMaxHp(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mUndispTgtIcn(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mDispTgtIcn(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetHp(class mHRChara* const this)'
	// TODO: Function 'enum enCharaCondition __convention("thiscall") mHRChara::mGetCondition(class mHRChara* const this)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRChara::mGetNext(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetHp(class mHRChara* const this, float arg2)'
	// TODO: Function 'class mHRChara* mHRChara::mGetTop()'
	// TODO: Function 'struct Vec& __convention("thiscall") mHRChara::mGetRot(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetCharaPause(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetRotY(class mHRChara* const this)'
	// TODO: Function 'struct WGclMaterialSpec* __convention("thiscall") mHRChara::GetGroundTouchMaterial(class mHRChara* const this)'
	// TODO: Function 'struct stCharaStatus* __convention("thiscall") mHRChara::mGetStatusPtr(class mHRChara* const this)'
	// TODO: Function 'struct Vec& __convention("thiscall") mHRChara::mGetPos(class mHRChara* const this)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetMotionNo(class mHRChara* const this)'
	// TODO: Function 'char* __convention("thiscall") mHRChara::mGetFileName(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsTubaAngleCorrect(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::getMiraretaiPosition(class mHRChara* const this, struct Vec* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::isHopeInterestMe(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsWatchPc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsUseRotMov(class mHRChara* const this)'
	// TODO: Function 'char const* __convention("thiscall") mHRChara::getCurMotionName(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestRunMotion(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mZakoDieOut(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCreateLoseSight(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckDamageMotion(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckEnterMotion(class mHRChara* const this)'
	// TODO: Function 'class TGan* __convention("thiscall") mHRChara::mpGetGan(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::mGetCurResourceGmfPtr(class mHRChara* const this)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::mGetCurResourceGmfPtr(class mHRChara* const this)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfWepLPtr(class mHRChara* const this)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfWepRPtr(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetResourceGmfPtr(class mHRChara* const this, class TGmf* arg2, char* arg3)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfDeadPtr(class mHRChara* const this)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfDeadPtr(class mHRChara* const this)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfPtr(class mHRChara* const this)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::mGetResourceGmfPtr(class mHRChara* const this)'
	// TODO: Function 'class ghmGcCollObjCapsule* __convention("thiscall") mHRChara::mGetCollPtr(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSethitOidashiDisEnable(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'struct Vec& __convention("thiscall") mHRChara::mGetBrainPos(class mHRChara* const this)'
	// TODO: Function 'struct Vec& __convention("thiscall") mHRChara::mGetHitPos(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetMirrorModel(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetVisibleDist(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetCondition(class mHRChara* const this, enum enCharaCondition arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetSubMotionSpd(class mHRChara* const this, float arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheck4tsunbai(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckSquat(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mGetThrowMotNo(class mHRChara* const this, int32_t* arg2, int32_t* arg3)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetTsubazeriMotionID(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mTsubazeriDifficultyClear(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mTsubazeriDifficultyUp(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsTubaPosAdjust(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckGuard(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckAttack(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSubTension(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mAddTension(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetTension(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mResetTension(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetMovSpd(class mHRChara* const this, float arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::UnderControllAttack_A(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::UnderControllComboAttack(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::ExitUnderControl(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::EnterUnderControl(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPostRenderProc(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::getViewClipBoxPositionOffsetY(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::getViewClipBoxHalfLengthXYZ(class mHRChara* const this, struct Vec* arg2)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetResNo(class mHRChara* const this)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetDropMoney(class mHRChara* const this)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetItemNo(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setLocatorNode(class mHRChara* const this, class TGmfNode* arg2)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetHpRate(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSubHp(class mHRChara* const this, float arg2)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetHitSize(class mHRChara* const this)'
	// TODO: Function 'enum enCharaInitProc __convention("thiscall") mHRChara::mGetInitProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::isCrashBreak(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetCharaHit(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetDmgAtkMot(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetMotionProcessDisEnable(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetMotionSpd(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetStageHitDisEnable(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsFootShadowDraw(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetFootShadowDraw(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetMotionNoNpc(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetCallScriptProc(class mHRChara* const this, char* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDropMoney(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetReactionDist(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetEnterPattern(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDatNo(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetResNo(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetCharaType(class mHRChara* const this, enum enCharaType arg2)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetDatNo(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetResourceDeleteFlag(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetDmgUpperPosY(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetDmgUpper(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetResourceDeleteFlag(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'class ghmPlane& __convention("thiscall") mHRChara::getLatestGroundTouchPlane(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mUndispBtlIcn(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnTb(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetDrawYAdjust(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDemoCtrl(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'uint64_t __convention("thiscall") mHRChara::mGetDemoCtrl(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::isAcceptDistanceDelete(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetStageHitDisEnableReq(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'struct stCharaEffect* __convention("thiscall") mHRChara::mGetEffectStPtr(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setBlackBodyEffect(class mHRChara* const this, class EffectEnemyDamage* arg2)'
	// TODO: Function 'struct Vec& __convention("thiscall") mHRChara::mGetNavelPos(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDamageAcceptFrame(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetAlwaysCheckHitColl(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetLockOnNoCheckColl(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetLockOnDistanceLow(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetLockOnDistanceHi(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetLockOnDistance(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetAliveBtlIcn(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetSlowBlow(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetInputFinishReq(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'class TGan* __convention("thiscall") mHRChara::mGetResourceGanPtr(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'int16_t __convention("thiscall") mHRChara::mGetMoney(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetMoney(class mHRChara* const this, int16_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetInputFinishReq(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mAddMoney(class mHRChara* const this, int16_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetInvincibleMotion(class mHRChara* const this, int32_t arg2, int32_t arg3)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mResetInvincibleMotion(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCanGetHitByMotion(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mDispAtkHitIcn(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetDontStandUp(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::GetTubaFrmOffset(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::GetAtkDisAdjust(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetLoseTsubazeriFlag(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetSuccessThrow(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetRotYA(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDontStandUp(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDmgGrav(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnSml(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnBig(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetCharaHit(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetCanLockOn(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGethitOidashiDisEnable(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetWepVisible(class mHRChara* const this)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetMotionBrendNum(class mHRChara* const this)'
	// TODO: Function 'int16_t __convention("thiscall") mHRChara::mGetAiValue(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mResetPosA(class mHRChara* const this)'
	// TODO: Function 'class ghmPlane& __convention("thiscall") mHRChara::getEasyShadowProjectionPlane(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::isInterestTarget(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetMotionSpd(class mHRChara* const this, float arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetWepEffectVisible(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetVisible(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetTension(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetMiniMapRender(class mHRChara* const this)'
	// TODO: Function 'class ghmResGroup* __convention("thiscall") mHRChara::mGetResourceRslPtr(class mHRChara* const this)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::getFootNumber(class mHRChara* const this)'
	// TODO: Function 'void* __convention("thiscall") mHRChara::`vector deleting destructor'(class mHRChara* const this, uint32_t arg2)'
	// TODO: Function 'char* __convention("thiscall") mHRChara::mGetCallScriptProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetMotionProcessDisEnable(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsBloom(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetTermAll(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetKnockBackSpd(class mHRChara* const this, float arg2)'
	// TODO: Function 'float __convention("thiscall") mHRChara::GetKnockBackSpd(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetStageHitDisEnable(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetStartSplitFlameFlag(class mHRChara* const this)'
	// TODO: Function 'class TGmf* __convention("thiscall") mHRChara::getBoneEffectGmf(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetStartSplitFlameFlag(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetCharaPause(class mHRChara* const this)'
	// TODO: Function 'struct Vec& __convention("thiscall") mHRChara::mGetBeforePos(class mHRChara* const this)'
	// TODO: Function 'int16_t __convention("thiscall") mHRChara::mGetZakoWepType(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetFootHitResultObj2(class mHRChara* const this, class ghmGcCollObjHitResultObj& arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDmgUpperPow(class mHRChara* const this, float arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mAddHp(class mHRChara* const this, float arg2)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetSubMotionSpd(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetZakoWepType(class mHRChara* const this, int16_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetHitSize(class mHRChara* const this, float arg2)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetReactionDist(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetMiniMapRender(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'struct Vec __convention("thiscall") mHRChara::GetKnockBackDir(class mHRChara* const this)'
	// TODO: Function 'int32_t __convention("thiscall") mHRChara::mGetMotionNoNpc(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetNormalClip(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'struct Vec& __convention("thiscall") mHRChara::mGetOldPos(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetSuccessThrow(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDmgUpperPosY(class mHRChara* const this, float const arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetDeleteReq(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::getShootPosiAndYaw(class mHRChara* const this, struct Vec* arg2, float* arg3, class TGmf& arg4, char const* arg5)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setHomingPositionFromAI(class mHRChara* const this, struct Vec& arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setHomingActFlagFromAI(class mHRChara* const this, uint8_t const arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::isHoming(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setInterestUseBoneNumFromAI(class mHRChara* const this, int32_t const arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::isInteresting(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::addDamageToYuremono(class mHRChara* const this, float const arg2, struct Vec& arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mSetHajikiCheck(class mHRChara* const this, float arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckDamageAccept(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestZakoDown(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestPiyoRequest(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetPiyoriHeight(class mHRChara* const this)'
	// TODO: Function 'class mHRChara* mHRChara::mGetCharaPtr(int32_t arg1)'
	// TODO: Function 'void mHRChara::mRenderGmf(void* arg1)'
	// TODO: Function 'int32_t mHRChara::debugDispCharaInfo()'
	// TODO: Function 'uint8_t mHRChara::mTermAllZakoMotion()'
	// TODO: Function 'uint8_t mHRChara::mInitAllNpc()'
	// TODO: Function 'void __convention("thiscall") mHRChara::mCreateBloodSplash(class mHRChara* const this, class TGmfNode* arg2, float arg3, struct tagHRTASKCHECK* arg4)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mBloodSplashProc(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::AddBoneElectPtrToList(class mHRChara* const this, class EffectBoneElect* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::ReleaseBoneElect(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsEmtpyBoneElectList(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::DeleteBoneElectFromList(class mHRChara* const this, class EffectBoneElect* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::AddCutmarkPtrToList(class mHRChara* const this, class EffectCutMark* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsEmtpyCutmarkList(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::DeleteCutmarkFromList(class mHRChara* const this, class EffectCutMark* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::SetPowerFlash(class mHRChara* const this, int32_t arg2, struct GXColor arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::SetNoGuardEffect(class mHRChara* const this)'
	// TODO: Function 'uint8_t mHRChara::mCheckAtkAllNpc()'
	// TODO: Function 'uint8_t mHRChara::mCheckCanAtk()'
	// TODO: Function 'void __convention("thiscall") mHRChara::mCallBeforeRenderProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckCanHit(class mHRChara* const this, int32_t arg2, uint8_t arg3, uint8_t arg4)'
	// TODO: Function 'void __convention("thiscall") mHRChara::CreateFootSmokeEffect(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::KnockBackProc(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::GetKnockBackRatio(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mSetDamage(class mHRChara* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mInitDamageMotInfo(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mChangeDefAi(class mHRChara* const this, uint8_t arg2, uint8_t arg3)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDefAI(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckCallFrameProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsNowUnderControl(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::RegistUnderControlAtkFuncPtr(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::RegistUnderControlMotID(class mHRChara* const this, struct CharControlMotID& arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetUnderControlFlag(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::DrawDebugCollision(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mRenderProc(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::postSetupMatrix(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::preSetupMatrix(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mFootSmokeEffect(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mPosAnimationProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPostFrameProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mFrameProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mInit(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetRotA(class mHRChara* const this, struct Vec& arg2, uint32_t const arg3)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetWepEffectVisibleInstant(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSubFrameStop(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPlayMotionMov(class mHRChara* const this, int32_t arg2, float arg3, float arg4, float arg5, uint8_t arg6)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestMotion(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDifficultyMotionSpeed(class mHRChara* const this, float arg2)'
	// TODO: Function 'class mHRChara* mHRChara::getCharaByGM2FileName(char const* arg1)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDeath(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mDamageCallBackForScript(class mHRChara* const this, int32_t arg2, uint8_t arg3, enum eDmgCallBackDmgType arg4, int32_t arg5)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetMotionPlay(class mHRChara* const this)'
	// TODO: Function 'class mHRChara* mHRChara::mGetAliveResourceCharaPtr(enum enCharaType arg1, uint32_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::ReleaseCutmark(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestPiyori(class mHRChara* const this)'
	// TODO: Function 'uint32_t __convention("thiscall") mHRChara::mGetMotionTotalTick(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setInterestPositionFromAI(class mHRChara* const this, struct Vec& arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setInterestActFlagFromAI(class mHRChara* const this, uint8_t const arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mGetWepTopPos(class mHRChara* const this, struct Vec* arg2, enum enWepLeftRight arg3)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mInitDamageStatus(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPostFrameCommonProc1(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPostFrameCommonProc2(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetKnockBack(class mHRChara* const this, float arg2, struct Vec& arg3, float arg4)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::CheckWallCrashAndDamageProc(class mHRChara* const this, int32_t const arg2, int32_t const arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mSetHpBarVisible(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetPosA(class mHRChara* const this, struct Vec& arg2, uint32_t const arg3, int32_t const arg4)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mSetSimpleHpBarVisible(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mPlayCamMotFromCharMot(class mHRChara* const this, int32_t arg2, int32_t arg3, uint8_t arg4, uint8_t arg5, uint8_t arg6)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPlayMotionMov(class mHRChara* const this, int32_t arg2, float arg3, float arg4, uint8_t arg5)'
	// TODO: Function 'void __convention("thiscall") mHRChara::checkDeleteBlackBodyEffect(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetHitCounter(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mReleaseBloodSplash(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPreFrameProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPreRenderProc(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mDetouchMotionBrend(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mReleaseDemoBtleIcn(class mHRChara* const this)'
	// TODO: Function 'uint8_t mHRChara::isThisCharaExist(class mHRChara* arg1)'
	// TODO: Function 'uint8_t mHRChara::mTermAllNpc()'
	// TODO: Function 'int32_t mHRChara::mGetPopZakoNum()'
	// TODO: Function 'void __convention("thiscall") mHRChara::mDeleteDispChara(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetAiDef(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setFootShadowDrawFlag(class mHRChara* const this, uint8_t const arg2)'
	// TODO: Function 'uint8_t mHRChara::mFrameProcAll()'
	// TODO: Function 'uint8_t mHRChara::mRenderProcAll(uint8_t arg1)'
	// TODO: Function 'uint8_t mHRChara::mPostRenderProcAll()'
	// TODO: Function 'uint8_t mHRChara::mTermAllNpcWithoutCmnObj()'
	// TODO: Function 'uint8_t mHRChara::mTermAllEnemyNpc()'
	// TODO: Function 'class mHRChara* mHRChara::mGetNpcTop()'
	// TODO: Function 'void __convention("thiscall") mHRChara::~mHRChara(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mHRChara(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::SetFileName(class mHRChara* const this, char const* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetMaxHp(class mHRChara* const this, float arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTerm(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetPos(class mHRChara* const this, struct Vec& arg2, uint8_t arg3, float arg4)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetRot(class mHRChara* const this, struct Vec& arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetScale(class mHRChara* const this, struct Vec& arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mHitCheck(class mHRChara* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mMotionSpeedControl(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mCallMotionProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPlayMotion(class mHRChara* const this, int32_t arg2, uint8_t arg3, int32_t arg4, uint8_t arg5, float arg6)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mCallMoneyDrop(class mHRChara* const this, int32_t arg2, uint8_t arg3, uint8_t arg4)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mAttachWep(class mHRChara* const this, class TGmf* arg2, enum eUDLR arg3, char* arg4)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mDetachWep(class mHRChara* const this, enum eUDLR arg2, char* arg3)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSemitransparentProcess(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mUpdateAtkColl(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mRenderShadowProc(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mRefreshFloorPosition(class mHRChara* const this, float arg2, uint8_t arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mDamageProc(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mRestoreDamage(class mHRChara* const this, int32_t arg2, float arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckAttack(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckCanAttack(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mGetTsubazeriaiPos(class mHRChara* const this, struct Vec* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetPcTsubaOuterMot(class mHRChara* const this)'
	// TODO: Function 'struct Vec __convention("thiscall") mHRChara::GetTsubaEffectPos(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckCanCatch(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckCanThrow(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mPlayThrownMotion(class mHRChara* const this, int32_t arg2, int32_t arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPlayMotionBlend(class mHRChara* const this, class TGan** arg2, char arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPlayMotionBlend(class mHRChara* const this, int32_t arg2, char arg3, uint8_t arg4, uint8_t arg5)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mBossDeadCommonProcess(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckCanLockOn(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::getLockOnCursorBasePosition(class mHRChara* const this, struct Vec* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetVisible(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetWepVisible(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetWepEffectVisible(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetVisibleDist(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mEffectInit(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetMirrorModel(class mHRChara* const this, uint8_t arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetAiAtk(class mHRChara* const this, int32_t arg2, int32_t arg3)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetWarpPos(class mHRChara* const this, struct Vec& arg2, uint8_t arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mHitCheckStage(class mHRChara* const this, class ghmGcCollObjCapsule* arg2, struct Vec* arg3, struct Vec* arg4, struct Vec* arg5, struct Vec* arg6, class ghmGcCollObj** arg7, class ghmGcCollObjHitResult** arg8, class ghmGcCollObjHitResultObj* arg9, struct WGclMaterialSpec** arg10, uint8_t* arg11, uint8_t arg12, float arg13)'
	// TODO: Function 'class TGan* __convention("thiscall") mHRChara::mpGetGan(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'class TGan** __convention("thiscall") mHRChara::mppGetGan(class mHRChara* const this, int32_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mRequestBloodSplash(class mHRChara* const this, char* arg2, int32_t arg3)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mCallKillPcProcess(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckComboing(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetAttackTableValue(class mHRChara* const this, int32_t arg2, int32_t arg3)'
	// TODO: Function 'float __convention("thiscall") mHRChara::mGetAttackDirection(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTestLowDmg(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCreatePiyori(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mTermPiyori(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mPiyoriProc(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetDamageAcceptFrame(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsMultiStep(class mHRChara* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::IsDownAttack(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::getFootShadowWidthHalf(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::getFootShadowDepthPlus(class mHRChara* const this)'
	// TODO: Function 'float __convention("thiscall") mHRChara::getFootShadowDepthMinus(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::OnStageUnload(class mHRChara* const this)'
	// TODO: Function 'void __convention("thiscall") mHRChara::setFootGroundTouchActFlagFromAI(class mHRChara* const this, uint8_t const arg2)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mPlayCamMot(class mHRChara* const this, class TGan* arg2, int32_t arg3, uint8_t arg4, struct Vec* arg5, float* arg6, uint8_t arg7)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mStopCamMotFromCharMot(class mHRChara* const this)'
	// TODO: Function 'uint8_t mHRChara::mRenderShadowProcAll()'
	// TODO: Function 'void __convention("thiscall") mHRChara::mSetRotY(class mHRChara* const this, float arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRChara::mCheckSegmentHitStage(class mHRChara* const this, int64_t arg2, int32_t, float arg4, uint8_t arg5, float* arg6, struct Vec* arg7)'
	// TODO: Function 'void __convention("thiscall") mHRChara::mEraseDispChara(class mHRChara* const this)'
	// TODO: Function 'class mHRChara* mHRChara::mGetCharaPtr(enum enCharaType arg1, uint32_t arg2)'
	// TODO: Function 'class mHRChara* mHRChara::mAllSearchPiyoZako()'
	// TODO: Function 'void mHRChara::OnStageUnloadAll()'

	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct stCharaStatus mStatus, offset 0x10>
	struct stCharaStatus mStatus;

	// <class stCharaFileData mResource, offset 0x3ac>
	class stCharaFileData mResource;

	// <struct stCharaEffect mEffect, offset 0x3e4>
	struct stCharaEffect mEffect;

	// <class CAmbientShadow m_inAmbientShadow, offset 0x508>
	class CAmbientShadow m_inAmbientShadow;

	// <class CStlVector<CStickShadow> m_ainFootShadow, offset 0x540>
	class std::vector<CStickShadow> m_ainFootShadow;

	// <enum enCharaInitProc mInitProc, offset 0x54c>
	enum enCharaInitProc mInitProc;

	// <class CharController* m_pCharController, offset 0x550>
	class CharController* m_pCharController;

	// <class ghmTriangle mWepColl, offset 0x554>
	class ghmTriangle mWepColl;

	// <int32_t motionInvincibilityFrames, offset 0x578>
	int32_t motionInvincibilityFrames;

	// <int32_t invincibileMotion, offset 0x57c>
	int32_t invincibileMotion;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRChara>("mHRChara")
			.addProperty("mStatus", &mHRChara::mStatus)
			.addProperty("mResource", &mHRChara::mResource)
			.addProperty("mEffect", &mHRChara::mEffect)
			.addProperty("m_inAmbientShadow", &mHRChara::m_inAmbientShadow)
			.addProperty("m_ainFootShadow", &mHRChara::m_ainFootShadow)
			.addProperty("mInitProc", &mHRChara::mInitProc)
			.addProperty("m_pCharController", &mHRChara::m_pCharController)
			.addProperty("mWepColl", &mHRChara::mWepColl)
			.addProperty("motionInvincibilityFrames", &mHRChara::motionInvincibilityFrames)
			.addProperty("invincibileMotion", &mHRChara::invincibileMotion)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRChara::mStatus) == 924, "expected mStatus to be size 924");
static_assert(sizeof(mHRChara::mResource) == 56, "expected mResource to be size 56");
static_assert(sizeof(mHRChara::mEffect) == 292, "expected mEffect to be size 292");
static_assert(sizeof(mHRChara::m_inAmbientShadow) == 56, "expected m_inAmbientShadow to be size 56");
static_assert(sizeof(mHRChara::m_ainFootShadow) == 12, "expected m_ainFootShadow to be size 12");
static_assert(sizeof(mHRChara::mInitProc) == 4, "expected mInitProc to be size 4");
static_assert(sizeof(mHRChara::m_pCharController) == 4, "expected m_pCharController to be size 4");
static_assert(sizeof(mHRChara::mWepColl) == 36, "expected mWepColl to be size 36");
static_assert(sizeof(mHRChara::motionInvincibilityFrames) == 4, "expected motionInvincibilityFrames to be size 4");
static_assert(sizeof(mHRChara::invincibileMotion) == 4, "expected invincibileMotion to be size 4");
static_assert(sizeof(class mHRChara) == 1408, "expected class mHRChara to be size 1408");

// class ghmAABB
// 1 dependencies: struct Vec
class ghmAABB
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mExtent, offset 0xc>
	struct Vec mExtent;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmAABB>("ghmAABB")
			.addProperty("mCenter", &ghmAABB::mCenter)
			.addProperty("mExtent", &ghmAABB::mExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmAABB::mCenter) == 12, "expected mCenter to be size 12");
static_assert(sizeof(ghmAABB::mExtent) == 12, "expected mExtent to be size 12");
static_assert(sizeof(class ghmAABB) == 24, "expected class ghmAABB to be size 24");

// class ghmGcOctTreeNode
// 2 dependencies: class ghmAABB, struct Vec
class ghmGcOctTreeNode
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class ghmGcOctTree* mpContainer, offset 0x4>
	class ghmGcOctTree* mpContainer;

	// <int32_t mDepthLevel, offset 0x8>
	int32_t mDepthLevel;

	// <int32_t mKey, offset 0xc>
	int32_t mKey;

	// <ghmGcOctTreeNode* mpParent, offset 0x10>
	ghmGcOctTreeNode* mpParent;

	// <ghmGcOctTreeNode* mpChildL[0x8], offset 0x14>
	ghmGcOctTreeNode* mpChildL[8];

	// <int32_t mNextKey[0x6], offset 0x34>
	int32_t mNextKey[6];

	// <class ghmGcOctTreeNodeObj* mpObjTop, offset 0x4c>
	class ghmGcOctTreeNodeObj* mpObjTop;

	// <class ghmAABB mShape, offset 0x50>
	class ghmAABB mShape;

	// <uint32_t mVisible, offset 0x68>
	uint32_t mVisible;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTreeNode>("ghmGcOctTreeNode")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTreeNode::field_0)
			.addProperty("mpContainer", &ghmGcOctTreeNode::mpContainer)
			.addProperty("mDepthLevel", &ghmGcOctTreeNode::mDepthLevel)
			.addProperty("mKey", &ghmGcOctTreeNode::mKey)
			.addProperty("mpParent", &ghmGcOctTreeNode::mpParent)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpChildL", &ghmGcOctTreeNode::mpChildL)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mNextKey", &ghmGcOctTreeNode::mNextKey)
			.addProperty("mpObjTop", &ghmGcOctTreeNode::mpObjTop)
			.addProperty("mShape", &ghmGcOctTreeNode::mShape)
			.addProperty("mVisible", &ghmGcOctTreeNode::mVisible)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTreeNode::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpContainer) == 4, "expected mpContainer to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mDepthLevel) == 4, "expected mDepthLevel to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mKey) == 4, "expected mKey to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpParent) == 4, "expected mpParent to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mpChildL) == 32, "expected mpChildL to be size 32");
static_assert(sizeof(ghmGcOctTreeNode::mNextKey) == 24, "expected mNextKey to be size 24");
static_assert(sizeof(ghmGcOctTreeNode::mpObjTop) == 4, "expected mpObjTop to be size 4");
static_assert(sizeof(ghmGcOctTreeNode::mShape) == 24, "expected mShape to be size 24");
static_assert(sizeof(ghmGcOctTreeNode::mVisible) == 4, "expected mVisible to be size 4");
static_assert(sizeof(class ghmGcOctTreeNode) == 108, "expected class ghmGcOctTreeNode to be size 108");

// class ghmGcOctTree
// no dependencies
class ghmGcOctTree
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <int32_t mMaxDepthLevel, offset 0x4>
	int32_t mMaxDepthLevel;

	// <class ghmGcOctTreeNode* mpRootNode, offset 0x8>
	class ghmGcOctTreeNode* mpRootNode;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcOctTree>("ghmGcOctTree")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcOctTree::field_0)
			.addProperty("mMaxDepthLevel", &ghmGcOctTree::mMaxDepthLevel)
			.addProperty("mpRootNode", &ghmGcOctTree::mpRootNode)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcOctTree::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmGcOctTree::mMaxDepthLevel) == 4, "expected mMaxDepthLevel to be size 4");
static_assert(sizeof(ghmGcOctTree::mpRootNode) == 4, "expected mpRootNode to be size 4");
static_assert(sizeof(class ghmGcOctTree) == 12, "expected class ghmGcOctTree to be size 12");

// class ghmGcCollObjHitResult
// no dependencies
class ghmGcCollObjHitResult
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[48];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcCollObjHitResult>("ghmGcCollObjHitResult")
		.endClass();
	}
#endif
};
static_assert(sizeof(class ghmGcCollObjHitResult) == 48, "expected class ghmGcCollObjHitResult to be size 48");

// struct WGclMaterialSpec
// no dependencies
struct WGclMaterialSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mEnable, offset 0x8>
	uint32_t mEnable;

	// <uint32_t mPad[0x5], offset 0xc>
	uint32_t mPad[5];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclMaterialSpec>("WGclMaterialSpec")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclMaterialSpec::mIDStr)
			.addProperty("mEnable", &WGclMaterialSpec::mEnable)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclMaterialSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclMaterialSpec::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGclMaterialSpec::mEnable) == 4, "expected mEnable to be size 4");
static_assert(sizeof(WGclMaterialSpec::mPad) == 20, "expected mPad to be size 20");
static_assert(sizeof(struct WGclMaterialSpec) == 32, "expected struct WGclMaterialSpec to be size 32");

// class EE::SmartPtr<EE::IFile>
// no dependencies
namespace EE
{
	template<typename T>
	class SmartPtr
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class EE::IFile* m_pObject, offset 0x0>
		class IFile* m_pObject;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EE::SmartPtr<EE::IFile>>("EE::SmartPtr<EE::IFile>")
				.addProperty("m_pObject", &EE::SmartPtr<EE::IFile>::m_pObject)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(EE::SmartPtr<EE::IFile>::m_pObject) == 4, "expected m_pObject to be size 4");
static_assert(sizeof(class EE::SmartPtr<EE::IFile>) == 4, "expected class EE::SmartPtr<EE::IFile> to be size 4");

// struct DVDCommandBlock
// no dependencies
struct DVDCommandBlock
{
public:
	/// No namespace types
	/// Struct member variables

	// <DVDCommandBlock* next, offset 0x0>
	DVDCommandBlock* next;

	// <DVDCommandBlock* prev, offset 0x4>
	DVDCommandBlock* prev;

	// <uint32_t command, offset 0x8>
	uint32_t command;

	// <int32_t volatile state, offset 0xc>
	int32_t volatile state;

	// <uint32_t offset, offset 0x10>
	uint32_t offset;

	// <uint32_t length, offset 0x14>
	uint32_t length;

	// <void* addr, offset 0x18>
	void* addr;

	// <uint32_t currTransferSize, offset 0x1c>
	uint32_t currTransferSize;

	// <uint32_t transferredSize, offset 0x20>
	uint32_t transferredSize;

	// <struct DVDDiskID* id, offset 0x24>
	struct DVDDiskID* id;

	// <void (* callback)(int32_t, DVDCommandBlock*), offset 0x28>
	void (* callback)(int32_t, DVDCommandBlock*);

	// <void* userData, offset 0x2c>
	void* userData;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDCommandBlock>("DVDCommandBlock")
			.addProperty("next", &DVDCommandBlock::next)
			.addProperty("prev", &DVDCommandBlock::prev)
			.addProperty("command", &DVDCommandBlock::command)
			// volatile not supported in LuaBridge and needs a getter
			//.addProperty("state", &DVDCommandBlock::state)
			.addProperty("offset", &DVDCommandBlock::offset)
			.addProperty("length", &DVDCommandBlock::length)
			// void type not supported in LuaBridge
			//.addProperty("addr", &DVDCommandBlock::addr)
			.addProperty("currTransferSize", &DVDCommandBlock::currTransferSize)
			.addProperty("transferredSize", &DVDCommandBlock::transferredSize)
			.addProperty("id", &DVDCommandBlock::id)
			// delegates are not supported in LuaBridge
			//.addProperty("callback", &DVDCommandBlock::callback)
			// void type not supported in LuaBridge
			//.addProperty("userData", &DVDCommandBlock::userData)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDCommandBlock::next) == 4, "expected next to be size 4");
static_assert(sizeof(DVDCommandBlock::prev) == 4, "expected prev to be size 4");
static_assert(sizeof(DVDCommandBlock::command) == 4, "expected command to be size 4");
static_assert(sizeof(DVDCommandBlock::state) == 4, "expected state to be size 4");
static_assert(sizeof(DVDCommandBlock::offset) == 4, "expected offset to be size 4");
static_assert(sizeof(DVDCommandBlock::length) == 4, "expected length to be size 4");
static_assert(sizeof(DVDCommandBlock::addr) == 4, "expected addr to be size 4");
static_assert(sizeof(DVDCommandBlock::currTransferSize) == 4, "expected currTransferSize to be size 4");
static_assert(sizeof(DVDCommandBlock::transferredSize) == 4, "expected transferredSize to be size 4");
static_assert(sizeof(DVDCommandBlock::id) == 4, "expected id to be size 4");
static_assert(sizeof(DVDCommandBlock::callback) == 4, "expected callback to be size 4");
static_assert(sizeof(DVDCommandBlock::userData) == 4, "expected userData to be size 4");
static_assert(sizeof(struct DVDCommandBlock) == 48, "expected struct DVDCommandBlock to be size 48");

// struct DVDFileInfo
// 2 dependencies: struct DVDCommandBlock, class EE::SmartPtr<EE::IFile>
struct DVDFileInfo
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct DVDCommandBlock cb, offset 0x0>
	struct DVDCommandBlock cb;

	// <uint32_t startAddr, offset 0x30>
	uint32_t startAddr;

	// <uint32_t length, offset 0x34>
	uint32_t length;

	// <void (* callback)(int32_t, DVDFileInfo*), offset 0x38>
	void (* callback)(int32_t, DVDFileInfo*);

	// <class EE::SmartPtr<EE::IFile> file, offset 0x3c>
	class EE::SmartPtr<EE::IFile> file;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDFileInfo>("DVDFileInfo")
			.addProperty("cb", &DVDFileInfo::cb)
			.addProperty("startAddr", &DVDFileInfo::startAddr)
			.addProperty("length", &DVDFileInfo::length)
			// delegates are not supported in LuaBridge
			//.addProperty("callback", &DVDFileInfo::callback)
			.addProperty("file", &DVDFileInfo::file)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDFileInfo::cb) == 48, "expected cb to be size 48");
static_assert(sizeof(DVDFileInfo::startAddr) == 4, "expected startAddr to be size 4");
static_assert(sizeof(DVDFileInfo::length) == 4, "expected length to be size 4");
static_assert(sizeof(DVDFileInfo::callback) == 4, "expected callback to be size 4");
static_assert(sizeof(DVDFileInfo::file) == 4, "expected file to be size 4");
static_assert(sizeof(struct DVDFileInfo) == 64, "expected struct DVDFileInfo to be size 64");

// class ghmGcFile
// 5 dependencies: struct ghmGcFile::ghmGcFileInfo, struct DVDFileInfo, struct DVDCommandBlock, class EE::SmartPtr<EE::IFile>, enum ghmGcFile::ghmGcFileState
class ghmGcFile
{
public:
	/// 2 namespace types: enum ghmGcFile::ghmGcFileState, struct ghmGcFile::ghmGcFileInfo

	// enum ghmGcFile::ghmGcFileState
	enum ghmGcFileState : uint32_t
	{
		// Enum values

		// <READFINISH = 0x1>
		READFINISH = 1,

		// <CANCELED = 0x1>
		CANCELED = 1,

		// <CLOSED = 0x0>
		CLOSED = 0,

		// <OPENED = 0x1>
		OPENED = 1,

		// <READ = 0x2>
		READ = 2,

		// <READRETRY = 0x3>
		READRETRY = 3

	};

	// struct ghmGcFile::ghmGcFileInfo
	// 4 dependencies: struct DVDFileInfo, struct DVDCommandBlock, class EE::SmartPtr<EE::IFile>, enum ghmGcFile::ghmGcFileState
	struct ghmGcFileInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <struct DVDFileInfo mFileInfo, offset 0x0>
		struct DVDFileInfo mFileInfo;

		// <int32_t mOffset, offset 0x40>
		int32_t mOffset;

		// <int32_t mLength, offset 0x44>
		int32_t mLength;

		// <int32_t mRequestNo, offset 0x48>
		int32_t mRequestNo;

		// <int32_t volatile mReadStatus, offset 0x4c>
		int32_t volatile mReadStatus;

		// <int32_t volatile mReadResult, offset 0x50>
		int32_t volatile mReadResult;

		// <enum ghmGcFile::ghmGcFileState mState, offset 0x54>
		enum ghmGcFileState mState;

		// <uint8_t mDivRead, offset 0x58>
		uint8_t mDivRead;

		// <Filler, offset 0x59>
		char _Filler8[3];

		// <int32_t mTotalReadLength, offset 0x5c>
		int32_t mTotalReadLength;

		// <int32_t mOneReadLength, offset 0x60>
		int32_t mOneReadLength;

		// <int32_t mReadOffset, offset 0x64>
		int32_t mReadOffset;

		// <void* mpBuffer, offset 0x68>
		void* mpBuffer;

		// <int32_t mReadCount, offset 0x6c>
		int32_t mReadCount;

		// <int32_t mDivNum, offset 0x70>
		int32_t mDivNum;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<ghmGcFile::ghmGcFileInfo>("ghmGcFile::ghmGcFileInfo")
				.addProperty("mFileInfo", &ghmGcFile::ghmGcFileInfo::mFileInfo)
				.addProperty("mOffset", &ghmGcFile::ghmGcFileInfo::mOffset)
				.addProperty("mLength", &ghmGcFile::ghmGcFileInfo::mLength)
				.addProperty("mRequestNo", &ghmGcFile::ghmGcFileInfo::mRequestNo)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("mReadStatus", &ghmGcFile::ghmGcFileInfo::mReadStatus)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("mReadResult", &ghmGcFile::ghmGcFileInfo::mReadResult)
				.addProperty("mState", &ghmGcFile::ghmGcFileInfo::mState)
				.addProperty("mDivRead", &ghmGcFile::ghmGcFileInfo::mDivRead)
				.addProperty("mTotalReadLength", &ghmGcFile::ghmGcFileInfo::mTotalReadLength)
				.addProperty("mOneReadLength", &ghmGcFile::ghmGcFileInfo::mOneReadLength)
				.addProperty("mReadOffset", &ghmGcFile::ghmGcFileInfo::mReadOffset)
				// void type not supported in LuaBridge
				//.addProperty("mpBuffer", &ghmGcFile::ghmGcFileInfo::mpBuffer)
				.addProperty("mReadCount", &ghmGcFile::ghmGcFileInfo::mReadCount)
				.addProperty("mDivNum", &ghmGcFile::ghmGcFileInfo::mDivNum)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mFileInfo) == 64, "expected mFileInfo to be size 64");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mOffset) == 4, "expected mOffset to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mLength) == 4, "expected mLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mRequestNo) == 4, "expected mRequestNo to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadStatus) == 4, "expected mReadStatus to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadResult) == 4, "expected mReadResult to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mState) == 4, "expected mState to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mDivRead) == 1, "expected mDivRead to be size 1");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mTotalReadLength) == 4, "expected mTotalReadLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mOneReadLength) == 4, "expected mOneReadLength to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadOffset) == 4, "expected mReadOffset to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mpBuffer) == 4, "expected mpBuffer to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mReadCount) == 4, "expected mReadCount to be size 4");
	static_assert(sizeof(ghmGcFile::ghmGcFileInfo::mDivNum) == 4, "expected mDivNum to be size 4");
	static_assert(sizeof(struct ghmGcFile::ghmGcFileInfo) == 116, "expected struct ghmGcFile::ghmGcFileInfo to be size 116");


	/// Struct member variables

	// <struct ghmGcFile::ghmGcFileInfo mInfo, offset 0x0>
	struct ghmGcFile::ghmGcFileInfo mInfo;

	// <ghmGcFile* mpPrev, offset 0x74>
	ghmGcFile* mpPrev;

	// <ghmGcFile* mpNext, offset 0x78>
	ghmGcFile* mpNext;

	// <char mFileName[0x40], offset 0x7c>
	char mFileName[64];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcFile>("ghmGcFile")
			.addProperty("mInfo", &ghmGcFile::mInfo)
			.addProperty("mpPrev", &ghmGcFile::mpPrev)
			.addProperty("mpNext", &ghmGcFile::mpNext)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mFileName", &ghmGcFile::mFileName)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcFile::mInfo) == 116, "expected mInfo to be size 116");
static_assert(sizeof(ghmGcFile::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(ghmGcFile::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(ghmGcFile::mFileName) == 64, "expected mFileName to be size 64");
static_assert(sizeof(class ghmGcFile) == 188, "expected class ghmGcFile to be size 188");

// struct DVDDiskID
// no dependencies
struct DVDDiskID
{
public:
	/// No namespace types
	/// Struct member variables

	// <char gameName[0x4], offset 0x0>
	char gameName[4];

	// <char company[0x2], offset 0x4>
	char company[2];

	// <uint8_t diskNumber, offset 0x6>
	uint8_t diskNumber;

	// <uint8_t gameVersion, offset 0x7>
	uint8_t gameVersion;

	// <uint8_t streaming, offset 0x8>
	uint8_t streaming;

	// <uint8_t streamingBufSize, offset 0x9>
	uint8_t streamingBufSize;

	// <uint8_t padding[0xe], offset 0xa>
	uint8_t padding[14];

	// <uint32_t rvlMagic, offset 0x18>
	uint32_t rvlMagic;

	// <uint32_t gcMagic, offset 0x1c>
	uint32_t gcMagic;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<DVDDiskID>("DVDDiskID")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("gameName", &DVDDiskID::gameName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("company", &DVDDiskID::company)
			.addProperty("diskNumber", &DVDDiskID::diskNumber)
			.addProperty("gameVersion", &DVDDiskID::gameVersion)
			.addProperty("streaming", &DVDDiskID::streaming)
			.addProperty("streamingBufSize", &DVDDiskID::streamingBufSize)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("padding", &DVDDiskID::padding)
			.addProperty("rvlMagic", &DVDDiskID::rvlMagic)
			.addProperty("gcMagic", &DVDDiskID::gcMagic)
		.endClass();
	}
#endif
};
static_assert(sizeof(DVDDiskID::gameName) == 4, "expected gameName to be size 4");
static_assert(sizeof(DVDDiskID::company) == 2, "expected company to be size 2");
static_assert(sizeof(DVDDiskID::diskNumber) == 1, "expected diskNumber to be size 1");
static_assert(sizeof(DVDDiskID::gameVersion) == 1, "expected gameVersion to be size 1");
static_assert(sizeof(DVDDiskID::streaming) == 1, "expected streaming to be size 1");
static_assert(sizeof(DVDDiskID::streamingBufSize) == 1, "expected streamingBufSize to be size 1");
static_assert(sizeof(DVDDiskID::padding) == 14, "expected padding to be size 14");
static_assert(sizeof(DVDDiskID::rvlMagic) == 4, "expected rvlMagic to be size 4");
static_assert(sizeof(DVDDiskID::gcMagic) == 4, "expected gcMagic to be size 4");
static_assert(sizeof(struct DVDDiskID) == 32, "expected struct DVDDiskID to be size 32");

// class EE::RefObject
// no dependencies
namespace EE
{
	class RefObject
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <void* (* field_0)[0x1], offset 0x0>
		void* (* field_0)[0x1];

		// <int32_t volatile refCount, offset 0x4>
		int32_t volatile refCount;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EE::RefObject>("EE::RefObject")
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &EE::RefObject::field_0)
				// volatile not supported in LuaBridge and needs a getter
				//.addProperty("refCount", &EE::RefObject::refCount)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(EE::RefObject::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(EE::RefObject::refCount) == 4, "expected refCount to be size 4");
static_assert(sizeof(class EE::RefObject) == 8, "expected class EE::RefObject to be size 8");

// class EE::IFile
// 4 dependencies: class EE::RefObject, class EE::String, class EE::StringBase<char,EE::String>, enum EE::StringBase<char,EE::String>::Storage
namespace EE
{
	class IFile : EE::RefObject
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class EE::RefObject field_0, offset 0x0>
		// class RefObject Super;

		// <class EE::String name, offset 0x8>
		class String name;

		// <uint8_t endianSwap, offset 0x14>
		uint8_t endianSwap;

		// <Filler, offset 0x15>
		char _Filler[3];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EE::IFile>("EE::IFile")
				.addProperty("name", &EE::IFile::name)
				.addProperty("endianSwap", &EE::IFile::endianSwap)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(EE::IFile::name) == 12, "expected name to be size 12");
static_assert(sizeof(EE::IFile::endianSwap) == 1, "expected endianSwap to be size 1");
static_assert(sizeof(class EE::IFile) == 24, "expected class EE::IFile to be size 24");

// class ghmResGroup
// no dependencies
class ghmResGroup
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint32_t mMagicNo, offset 0x0>
	uint32_t mMagicNo;

	// <uint32_t mResourceNum, offset 0x4>
	uint32_t mResourceNum;

	// <uint32_t mAttrOffset, offset 0x8>
	uint32_t mAttrOffset;

	// <uint32_t mVersion, offset 0xc>
	uint32_t mVersion;

	// <class ghmResStrTable* mpStrTablePtr, offset 0x10>
	class ghmResStrTable* mpStrTablePtr;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag;

	// <uint32_t mPad[0x3], offset 0x18>
	uint32_t mPad[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmResGroup>("ghmResGroup")
			.addProperty("mMagicNo", &ghmResGroup::mMagicNo)
			.addProperty("mResourceNum", &ghmResGroup::mResourceNum)
			.addProperty("mAttrOffset", &ghmResGroup::mAttrOffset)
			.addProperty("mVersion", &ghmResGroup::mVersion)
			.addProperty("mpStrTablePtr", &ghmResGroup::mpStrTablePtr)
			.addProperty("mFlag", &ghmResGroup::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmResGroup::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmResGroup::mMagicNo) == 4, "expected mMagicNo to be size 4");
static_assert(sizeof(ghmResGroup::mResourceNum) == 4, "expected mResourceNum to be size 4");
static_assert(sizeof(ghmResGroup::mAttrOffset) == 4, "expected mAttrOffset to be size 4");
static_assert(sizeof(ghmResGroup::mVersion) == 4, "expected mVersion to be size 4");
static_assert(sizeof(ghmResGroup::mpStrTablePtr) == 4, "expected mpStrTablePtr to be size 4");
static_assert(sizeof(ghmResGroup::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmResGroup::mPad) == 12, "expected mPad to be size 12");
static_assert(sizeof(class ghmResGroup) == 36, "expected class ghmResGroup to be size 36");

// class ghmResStrTable
// no dependencies
class ghmResStrTable
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint32_t mNum, offset 0x0>
	uint32_t mNum;

	// <char const** mppStrings, offset 0x4>
	char const** mppStrings;

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint32_t mPad[0x1], offset 0xc>
	uint32_t mPad[1];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmResStrTable>("ghmResStrTable")
			.addProperty("mNum", &ghmResStrTable::mNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppStrings", &ghmResStrTable::mppStrings)
			.addProperty("mFlag", &ghmResStrTable::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmResStrTable::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmResStrTable::mNum) == 4, "expected mNum to be size 4");
static_assert(sizeof(ghmResStrTable::mppStrings) == 4, "expected mppStrings to be size 4");
static_assert(sizeof(ghmResStrTable::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmResStrTable::mPad) == 4, "expected mPad to be size 4");
static_assert(sizeof(class ghmResStrTable) == 16, "expected class ghmResStrTable to be size 16");

// union __m128
// no dependencies
union __m128
{
public:
	/// No namespace types
	/// Struct member variables

	// <float m128_f32[0x4], offset 0x0>
	float m128_f32[4];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<__m128>("__m128")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m128_f32", &__m128::m128_f32)
		.endClass();
	}
#endif
};
static_assert(sizeof(__m128::m128_f32) == 16, "expected m128_f32 to be size 16");
static_assert(sizeof(union __m128) == 16, "expected union __m128 to be size 16");

// class vector4f
// no dependencies
class vector4f
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint32_t u[0x4], offset 0x0>
	uint32_t u[4];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<vector4f>("vector4f")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("u", &vector4f::u)
		.endClass();
	}
#endif
};
static_assert(sizeof(vector4f::u) == 16, "expected u to be size 16");
static_assert(sizeof(class vector4f) == 16, "expected class vector4f to be size 16");

// class vector4x
// 1 dependencies: class vector4f
class vector4x
{
public:
	/// No namespace types
	/// Struct member variables

	// <double sd[0x2], offset 0x0>
	double sd[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<vector4x>("vector4x")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("sd", &vector4x::sd)
		.endClass();
	}
#endif
};
static_assert(sizeof(vector4x::sd) == 16, "expected sd to be size 16");
static_assert(sizeof(class vector4x) == 16, "expected class vector4x to be size 16");

// class tiVector
// 3 dependencies: class vector4x, class vector4f, union __m128
class tiVector
{
public:
	/// No namespace types
	/// Struct member variables

	// <float x, offset 0x0>
	float x;

	// <float y, offset 0x4>
	float y;

	// <float z, offset 0x8>
	float z;

	// <float w, offset 0xc>
	float w;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tiVector>("tiVector")
			.addProperty("x", &tiVector::x)
			.addProperty("y", &tiVector::y)
			.addProperty("z", &tiVector::z)
			.addProperty("w", &tiVector::w)
		.endClass();
	}
#endif
};
static_assert(sizeof(tiVector::x) == 4, "expected x to be size 4");
static_assert(sizeof(tiVector::y) == 4, "expected y to be size 4");
static_assert(sizeof(tiVector::z) == 4, "expected z to be size 4");
static_assert(sizeof(tiVector::w) == 4, "expected w to be size 4");
static_assert(sizeof(class tiVector) == 16, "expected class tiVector to be size 16");

// class mot::IBoneEffectModel
// no dependencies
namespace mot
{
	class IBoneEffectModel
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <void* (* field_0)[0x1f], offset 0x0>
		void* (* field_0)[0x1f];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::IBoneEffectModel>("mot::IBoneEffectModel")
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &mot::IBoneEffectModel::field_0)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectModel::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(class mot::IBoneEffectModel) == 4, "expected class mot::IBoneEffectModel to be size 4");

// class mot::IBoneEffectModelPJ
// 5 dependencies: class mot::IBoneEffectModel, class tiVector, class vector4x, class vector4f, union __m128
namespace mot
{
	class IBoneEffectModelPJ : mot::IBoneEffectModel
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class mot::IBoneEffectModel field_0, offset 0x0>
		// class IBoneEffectModel Super;

		// <Filler, offset 0x4>
		char _Filler1[12];

		// <class tiVector m_inYureBonePosiOfst, offset 0x10>
		class tiVector m_inYureBonePosiOfst;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::IBoneEffectModelPJ>("mot::IBoneEffectModelPJ")
				.addProperty("m_inYureBonePosiOfst", &mot::IBoneEffectModelPJ::m_inYureBonePosiOfst)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectModelPJ::m_inYureBonePosiOfst) == 16, "expected m_inYureBonePosiOfst to be size 16");
static_assert(sizeof(class mot::IBoneEffectModelPJ) == 32, "expected class mot::IBoneEffectModelPJ to be size 32");

// class TGmf
// 7 dependencies: class mot::IBoneEffectModelPJ, class mot::IBoneEffectModel, class tiVector, class vector4x, class vector4f, union __m128, struct TGmf::tagMAIN
class TGmf : mot::IBoneEffectModelPJ
{
public:
	/// 1 namespace types: struct TGmf::tagMAIN

	// struct TGmf::tagMAIN
	// no dependencies
	struct tagMAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <Filler, offset 0x0>
		char _Filler[2284];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGmf::tagMAIN>("TGmf::tagMAIN")
			.endClass();
		}
#endif
	};
	static_assert(sizeof(struct TGmf::tagMAIN) == 2284, "expected struct TGmf::tagMAIN to be size 2284");


	/// Struct member variables

	// <class mot::IBoneEffectModelPJ field_0, offset 0x0>
	// class mot::IBoneEffectModelPJ Super;

	// <struct TGmf::tagMAIN dat, offset 0x20>
	struct TGmf::tagMAIN dat;

	// <uint8_t mUseLight, offset 0x90c>
	uint8_t mUseLight;

	// <Filler, offset 0x90d>
	char _Filler3[3];

	// <class TGanPlay* mpFrameInfoPlay, offset 0x910>
	class TGanPlay* mpFrameInfoPlay;

	// <class TGanPlayNode* mpFrameInfoNode, offset 0x914>
	class TGanPlayNode* mpFrameInfoNode;

	// <class TGanPlay* mpEffectInfoPlay, offset 0x918>
	class TGanPlay* mpEffectInfoPlay;

	// <class TGanPlayNode* mpSmokeParam1Node, offset 0x91c>
	class TGanPlayNode* mpSmokeParam1Node;

	// <class TGanPlayNode* mpSmokeParam2Node, offset 0x920>
	class TGanPlayNode* mpSmokeParam2Node;

	// <int32_t mHitFrameNum, offset 0x924>
	int32_t mHitFrameNum;

	// <int32_t mDmgMotNum, offset 0x928>
	int32_t mDmgMotNum;

	// <int32_t mGrdMotNum, offset 0x92c>
	int32_t mGrdMotNum;

	// <int32_t mNextGrdMotNum, offset 0x930>
	int32_t mNextGrdMotNum;

	// <int32_t mAtkDirec, offset 0x934>
	int32_t mAtkDirec;

	// <int32_t mEffectNum, offset 0x938>
	int32_t mEffectNum;

	// <float mIKBlendRate, offset 0x93c>
	float mIKBlendRate;

	// <float mSlowRate, offset 0x940>
	float mSlowRate;

	// <uint8_t mbDrawMirror, offset 0x944>
	uint8_t mbDrawMirror;

	// <uint8_t mbObj, offset 0x945>
	uint8_t mbObj;

	// <Filler, offset 0x946>
	char _Filler18[2];

	// <float m_fFadeAlpha, offset 0x948>
	float m_fFadeAlpha;

	// <class TGmfNode* m_pLocatorNode, offset 0x94c>
	class TGmfNode* m_pLocatorNode;

	// <int32_t m_nTotalModel, offset 0x950>
	int32_t m_nTotalModel;

	// <int32_t m_nCurModelIndex, offset 0x954>
	int32_t m_nCurModelIndex;

	// <class TGmfNode* m_pCurModelTopNode, offset 0x958>
	class TGmfNode* m_pCurModelTopNode;

	// <class TGmfNode* m_pBoneEffectTopNode, offset 0x95c>
	class TGmfNode* m_pBoneEffectTopNode;

	// <uint32_t m_bActedSetupRefMesh, offset 0x960>
	uint32_t m_bActedSetupRefMesh;

	// <uint32_t m_bActedRefreshRefMesh, offset 0x964>
	uint32_t m_bActedRefreshRefMesh;

	// <class mot::IBoneEffectPJ* m_pBoneEffect, offset 0x968>
	class mot::IBoneEffectPJ* m_pBoneEffect;

	// <uint8_t m_bActedBoneEffectInit, offset 0x96c>
	uint8_t m_bActedBoneEffectInit;

	// <uint8_t m_bActBoneEffectOnUpdate, offset 0x96d>
	uint8_t m_bActBoneEffectOnUpdate;

	// <Filler, offset 0x96e>
	char _Filler29[2];

	// <char const* m_sIDName, offset 0x970>
	char const* m_sIDName;

	// <int32_t m_nIDNum, offset 0x974>
	int32_t m_nIDNum;

	// <char const* m_sMotName, offset 0x978>
	char const* m_sMotName;

	// <int32_t m_nTotalCamVibTiming, offset 0x97c>
	int32_t m_nTotalCamVibTiming;

	// <class CCameraVibTiming* m_ainCamVibTiming, offset 0x980>
	class CCameraVibTiming* m_ainCamVibTiming;

	// <uint8_t m_bIsBootCamVib, offset 0x984>
	uint8_t m_bIsBootCamVib;

	// <Filler, offset 0x985>
	char _Filler[11];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGmf>("TGmf")
			.addProperty("dat", &TGmf::dat)
			.addProperty("mUseLight", &TGmf::mUseLight)
			.addProperty("mpFrameInfoPlay", &TGmf::mpFrameInfoPlay)
			.addProperty("mpFrameInfoNode", &TGmf::mpFrameInfoNode)
			.addProperty("mpEffectInfoPlay", &TGmf::mpEffectInfoPlay)
			.addProperty("mpSmokeParam1Node", &TGmf::mpSmokeParam1Node)
			.addProperty("mpSmokeParam2Node", &TGmf::mpSmokeParam2Node)
			.addProperty("mHitFrameNum", &TGmf::mHitFrameNum)
			.addProperty("mDmgMotNum", &TGmf::mDmgMotNum)
			.addProperty("mGrdMotNum", &TGmf::mGrdMotNum)
			.addProperty("mNextGrdMotNum", &TGmf::mNextGrdMotNum)
			.addProperty("mAtkDirec", &TGmf::mAtkDirec)
			.addProperty("mEffectNum", &TGmf::mEffectNum)
			.addProperty("mIKBlendRate", &TGmf::mIKBlendRate)
			.addProperty("mSlowRate", &TGmf::mSlowRate)
			.addProperty("mbDrawMirror", &TGmf::mbDrawMirror)
			.addProperty("mbObj", &TGmf::mbObj)
			.addProperty("m_fFadeAlpha", &TGmf::m_fFadeAlpha)
			.addProperty("m_pLocatorNode", &TGmf::m_pLocatorNode)
			.addProperty("m_nTotalModel", &TGmf::m_nTotalModel)
			.addProperty("m_nCurModelIndex", &TGmf::m_nCurModelIndex)
			.addProperty("m_pCurModelTopNode", &TGmf::m_pCurModelTopNode)
			.addProperty("m_pBoneEffectTopNode", &TGmf::m_pBoneEffectTopNode)
			.addProperty("m_bActedSetupRefMesh", &TGmf::m_bActedSetupRefMesh)
			.addProperty("m_bActedRefreshRefMesh", &TGmf::m_bActedRefreshRefMesh)
			.addProperty("m_pBoneEffect", &TGmf::m_pBoneEffect)
			.addProperty("m_bActedBoneEffectInit", &TGmf::m_bActedBoneEffectInit)
			.addProperty("m_bActBoneEffectOnUpdate", &TGmf::m_bActBoneEffectOnUpdate)
			.addProperty("m_sIDName", &TGmf::m_sIDName)
			.addProperty("m_nIDNum", &TGmf::m_nIDNum)
			.addProperty("m_sMotName", &TGmf::m_sMotName)
			.addProperty("m_nTotalCamVibTiming", &TGmf::m_nTotalCamVibTiming)
			.addProperty("m_ainCamVibTiming", &TGmf::m_ainCamVibTiming)
			.addProperty("m_bIsBootCamVib", &TGmf::m_bIsBootCamVib)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGmf::dat) == 2284, "expected dat to be size 2284");
static_assert(sizeof(TGmf::mUseLight) == 1, "expected mUseLight to be size 1");
static_assert(sizeof(TGmf::mpFrameInfoPlay) == 4, "expected mpFrameInfoPlay to be size 4");
static_assert(sizeof(TGmf::mpFrameInfoNode) == 4, "expected mpFrameInfoNode to be size 4");
static_assert(sizeof(TGmf::mpEffectInfoPlay) == 4, "expected mpEffectInfoPlay to be size 4");
static_assert(sizeof(TGmf::mpSmokeParam1Node) == 4, "expected mpSmokeParam1Node to be size 4");
static_assert(sizeof(TGmf::mpSmokeParam2Node) == 4, "expected mpSmokeParam2Node to be size 4");
static_assert(sizeof(TGmf::mHitFrameNum) == 4, "expected mHitFrameNum to be size 4");
static_assert(sizeof(TGmf::mDmgMotNum) == 4, "expected mDmgMotNum to be size 4");
static_assert(sizeof(TGmf::mGrdMotNum) == 4, "expected mGrdMotNum to be size 4");
static_assert(sizeof(TGmf::mNextGrdMotNum) == 4, "expected mNextGrdMotNum to be size 4");
static_assert(sizeof(TGmf::mAtkDirec) == 4, "expected mAtkDirec to be size 4");
static_assert(sizeof(TGmf::mEffectNum) == 4, "expected mEffectNum to be size 4");
static_assert(sizeof(TGmf::mIKBlendRate) == 4, "expected mIKBlendRate to be size 4");
static_assert(sizeof(TGmf::mSlowRate) == 4, "expected mSlowRate to be size 4");
static_assert(sizeof(TGmf::mbDrawMirror) == 1, "expected mbDrawMirror to be size 1");
static_assert(sizeof(TGmf::mbObj) == 1, "expected mbObj to be size 1");
static_assert(sizeof(TGmf::m_fFadeAlpha) == 4, "expected m_fFadeAlpha to be size 4");
static_assert(sizeof(TGmf::m_pLocatorNode) == 4, "expected m_pLocatorNode to be size 4");
static_assert(sizeof(TGmf::m_nTotalModel) == 4, "expected m_nTotalModel to be size 4");
static_assert(sizeof(TGmf::m_nCurModelIndex) == 4, "expected m_nCurModelIndex to be size 4");
static_assert(sizeof(TGmf::m_pCurModelTopNode) == 4, "expected m_pCurModelTopNode to be size 4");
static_assert(sizeof(TGmf::m_pBoneEffectTopNode) == 4, "expected m_pBoneEffectTopNode to be size 4");
static_assert(sizeof(TGmf::m_bActedSetupRefMesh) == 4, "expected m_bActedSetupRefMesh to be size 4");
static_assert(sizeof(TGmf::m_bActedRefreshRefMesh) == 4, "expected m_bActedRefreshRefMesh to be size 4");
static_assert(sizeof(TGmf::m_pBoneEffect) == 4, "expected m_pBoneEffect to be size 4");
static_assert(sizeof(TGmf::m_bActedBoneEffectInit) == 1, "expected m_bActedBoneEffectInit to be size 1");
static_assert(sizeof(TGmf::m_bActBoneEffectOnUpdate) == 1, "expected m_bActBoneEffectOnUpdate to be size 1");
static_assert(sizeof(TGmf::m_sIDName) == 4, "expected m_sIDName to be size 4");
static_assert(sizeof(TGmf::m_nIDNum) == 4, "expected m_nIDNum to be size 4");
static_assert(sizeof(TGmf::m_sMotName) == 4, "expected m_sMotName to be size 4");
static_assert(sizeof(TGmf::m_nTotalCamVibTiming) == 4, "expected m_nTotalCamVibTiming to be size 4");
static_assert(sizeof(TGmf::m_ainCamVibTiming) == 4, "expected m_ainCamVibTiming to be size 4");
static_assert(sizeof(TGmf::m_bIsBootCamVib) == 1, "expected m_bIsBootCamVib to be size 1");
static_assert(sizeof(class TGmf) == 2448, "expected class TGmf to be size 2448");

// class TGanPlay
// 1 dependencies: struct TGanPlay::MAIN
class TGanPlay
{
public:
	/// 1 namespace types: struct TGanPlay::MAIN

	// struct TGanPlay::MAIN
	// no dependencies
	struct MAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class TGan* pGan, offset 0x0>
		class TGan* pGan;

		// <class TGanPlayNode* pTopNode, offset 0x4>
		class TGanPlayNode* pTopNode;

		// <class TFAnm* pFAnm, offset 0x8>
		class TFAnm* pFAnm;

		// <int32_t FAnmNum, offset 0xc>
		int32_t FAnmNum;

		// <class TGanPlayNode* pNode, offset 0x10>
		class TGanPlayNode* pNode;

		// <int32_t NodeNum, offset 0x14>
		int32_t NodeNum;

		// <uint8_t Loop, offset 0x18>
		uint8_t Loop;

		// <uint8_t PlayTyokugoFlag, offset 0x19>
		uint8_t PlayTyokugoFlag;

		// <uint8_t PlayFlag, offset 0x1a>
		uint8_t PlayFlag;

		// <Filler, offset 0x1b>
		char _Filler9[1];

		// <float PlayTick, offset 0x1c>
		float PlayTick;

		// <float Rate, offset 0x20>
		float Rate;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGanPlay::MAIN>("TGanPlay::MAIN")
				.addProperty("pGan", &TGanPlay::MAIN::pGan)
				.addProperty("pTopNode", &TGanPlay::MAIN::pTopNode)
				.addProperty("pFAnm", &TGanPlay::MAIN::pFAnm)
				.addProperty("FAnmNum", &TGanPlay::MAIN::FAnmNum)
				.addProperty("pNode", &TGanPlay::MAIN::pNode)
				.addProperty("NodeNum", &TGanPlay::MAIN::NodeNum)
				.addProperty("Loop", &TGanPlay::MAIN::Loop)
				.addProperty("PlayTyokugoFlag", &TGanPlay::MAIN::PlayTyokugoFlag)
				.addProperty("PlayFlag", &TGanPlay::MAIN::PlayFlag)
				.addProperty("PlayTick", &TGanPlay::MAIN::PlayTick)
				.addProperty("Rate", &TGanPlay::MAIN::Rate)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGanPlay::MAIN::pGan) == 4, "expected pGan to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pTopNode) == 4, "expected pTopNode to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pFAnm) == 4, "expected pFAnm to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::FAnmNum) == 4, "expected FAnmNum to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::pNode) == 4, "expected pNode to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::NodeNum) == 4, "expected NodeNum to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::Loop) == 1, "expected Loop to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayTyokugoFlag) == 1, "expected PlayTyokugoFlag to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayFlag) == 1, "expected PlayFlag to be size 1");
	static_assert(sizeof(TGanPlay::MAIN::PlayTick) == 4, "expected PlayTick to be size 4");
	static_assert(sizeof(TGanPlay::MAIN::Rate) == 4, "expected Rate to be size 4");
	static_assert(sizeof(struct TGanPlay::MAIN) == 36, "expected struct TGanPlay::MAIN to be size 36");


	/// Struct member variables

	// <struct TGanPlay::MAIN dat, offset 0x0>
	struct TGanPlay::MAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGanPlay>("TGanPlay")
			.addProperty("dat", &TGanPlay::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGanPlay::dat) == 36, "expected dat to be size 36");
static_assert(sizeof(class TGanPlay) == 36, "expected class TGanPlay to be size 36");

// enum TGAN_STATE
enum TGAN_STATE : uint32_t
{
	// Enum values

	// <TGAN_STATE_INIT = 0x0>
	TGAN_STATE_INIT = 0,

	// <TGAN_STATE_STANDBY = 0x1>
	TGAN_STATE_STANDBY = 1,

	// <TGAN_STATE_ERROR = 0x2>
	TGAN_STATE_ERROR = 2

};

// class TGan
// 2 dependencies: struct TGan::tagMAIN, enum TGAN_STATE
class TGan
{
public:
	/// 1 namespace types: struct TGan::tagMAIN

	// struct TGan::tagMAIN
	// 1 dependencies: enum TGAN_STATE
	struct tagMAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint8_t ProcessBlock, offset 0x0>
		uint8_t ProcessBlock;

		// <uint8_t XYZLS16WKFlag, offset 0x1>
		uint8_t XYZLS16WKFlag;

		// <Filler, offset 0x2>
		char _Filler2[2];

		// <enum TGAN_STATE State, offset 0x4>
		enum TGAN_STATE State;

		// <struct WGanSpec* pSpec, offset 0x8>
		struct WGanSpec* pSpec;

		// <int32_t TimingSoundDataIndex, offset 0xc>
		int32_t TimingSoundDataIndex;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGan::tagMAIN>("TGan::tagMAIN")
				.addProperty("ProcessBlock", &TGan::tagMAIN::ProcessBlock)
				.addProperty("XYZLS16WKFlag", &TGan::tagMAIN::XYZLS16WKFlag)
				.addProperty("State", &TGan::tagMAIN::State)
				.addProperty("pSpec", &TGan::tagMAIN::pSpec)
				.addProperty("TimingSoundDataIndex", &TGan::tagMAIN::TimingSoundDataIndex)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGan::tagMAIN::ProcessBlock) == 1, "expected ProcessBlock to be size 1");
	static_assert(sizeof(TGan::tagMAIN::XYZLS16WKFlag) == 1, "expected XYZLS16WKFlag to be size 1");
	static_assert(sizeof(TGan::tagMAIN::State) == 4, "expected State to be size 4");
	static_assert(sizeof(TGan::tagMAIN::pSpec) == 4, "expected pSpec to be size 4");
	static_assert(sizeof(TGan::tagMAIN::TimingSoundDataIndex) == 4, "expected TimingSoundDataIndex to be size 4");
	static_assert(sizeof(struct TGan::tagMAIN) == 16, "expected struct TGan::tagMAIN to be size 16");


	/// Struct member variables

	// <struct TGan::tagMAIN dat, offset 0x0>
	struct TGan::tagMAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGan>("TGan")
			.addProperty("dat", &TGan::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGan::dat) == 16, "expected dat to be size 16");
static_assert(sizeof(class TGan) == 16, "expected class TGan to be size 16");

// struct WGanSpec
// no dependencies
struct WGanSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint32_t mID, offset 0x0>
	uint32_t mID;

	// <uint32_t mVersion, offset 0x4>
	uint32_t mVersion;

	// <uint32_t mStartTick, offset 0x8>
	uint32_t mStartTick;

	// <uint32_t mEndTick, offset 0xc>
	uint32_t mEndTick;

	// <uint32_t mFlag, offset 0x10>
	uint32_t mFlag;

	// <uint16_t mNodeCount, offset 0x14>
	uint16_t mNodeCount;

	// <uint16_t mMaterialCount, offset 0x16>
	uint16_t mMaterialCount;

	// <uint16_t mPad0[0x2], offset 0x18>
	uint16_t mPad0[2];

	// <struct WGanMaterialSpec* mpTopMaterial, offset 0x1c>
	struct WGanMaterialSpec* mpTopMaterial;

	// <struct WGanNodeSpec* mpTopNode, offset 0x20>
	struct WGanNodeSpec* mpTopNode;

	// <uint32_t mPad1[0x3], offset 0x24>
	uint32_t mPad1[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanSpec>("WGanSpec")
			.addProperty("mID", &WGanSpec::mID)
			.addProperty("mVersion", &WGanSpec::mVersion)
			.addProperty("mStartTick", &WGanSpec::mStartTick)
			.addProperty("mEndTick", &WGanSpec::mEndTick)
			.addProperty("mFlag", &WGanSpec::mFlag)
			.addProperty("mNodeCount", &WGanSpec::mNodeCount)
			.addProperty("mMaterialCount", &WGanSpec::mMaterialCount)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad0", &WGanSpec::mPad0)
			.addProperty("mpTopMaterial", &WGanSpec::mpTopMaterial)
			.addProperty("mpTopNode", &WGanSpec::mpTopNode)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanSpec::mID) == 4, "expected mID to be size 4");
static_assert(sizeof(WGanSpec::mVersion) == 4, "expected mVersion to be size 4");
static_assert(sizeof(WGanSpec::mStartTick) == 4, "expected mStartTick to be size 4");
static_assert(sizeof(WGanSpec::mEndTick) == 4, "expected mEndTick to be size 4");
static_assert(sizeof(WGanSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGanSpec::mNodeCount) == 2, "expected mNodeCount to be size 2");
static_assert(sizeof(WGanSpec::mMaterialCount) == 2, "expected mMaterialCount to be size 2");
static_assert(sizeof(WGanSpec::mPad0) == 4, "expected mPad0 to be size 4");
static_assert(sizeof(WGanSpec::mpTopMaterial) == 4, "expected mpTopMaterial to be size 4");
static_assert(sizeof(WGanSpec::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(WGanSpec::mPad1) == 12, "expected mPad1 to be size 12");
static_assert(sizeof(struct WGanSpec) == 48, "expected struct WGanSpec to be size 48");

// struct WGanMaterialSpec
// no dependencies
struct WGanMaterialSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint32_t mPad0, offset 0xc>
	uint32_t mPad0;

	// <WGanMaterialSpec* mpPrev, offset 0x10>
	WGanMaterialSpec* mpPrev;

	// <WGanMaterialSpec* mpNext, offset 0x14>
	WGanMaterialSpec* mpNext;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0x18>
	struct WGanFAnmSpec* mpFAnmSpec;

	// <struct WGanMaterialLayerSpec* mpTopLayer, offset 0x1c>
	struct WGanMaterialLayerSpec* mpTopLayer;

	// <uint32_t mPad1[0x4], offset 0x20>
	uint32_t mPad1[4];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanMaterialSpec>("WGanMaterialSpec")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGanMaterialSpec::mIDStr)
			.addProperty("mFlag", &WGanMaterialSpec::mFlag)
			.addProperty("mPad0", &WGanMaterialSpec::mPad0)
			.addProperty("mpPrev", &WGanMaterialSpec::mpPrev)
			.addProperty("mpNext", &WGanMaterialSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanMaterialSpec::mpFAnmSpec)
			.addProperty("mpTopLayer", &WGanMaterialSpec::mpTopLayer)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanMaterialSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanMaterialSpec::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGanMaterialSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGanMaterialSpec::mPad0) == 4, "expected mPad0 to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpFAnmSpec) == 4, "expected mpFAnmSpec to be size 4");
static_assert(sizeof(WGanMaterialSpec::mpTopLayer) == 4, "expected mpTopLayer to be size 4");
static_assert(sizeof(WGanMaterialSpec::mPad1) == 16, "expected mPad1 to be size 16");
static_assert(sizeof(struct WGanMaterialSpec) == 48, "expected struct WGanMaterialSpec to be size 48");

// struct WGanFAnmSpec
// no dependencies
struct WGanFAnmSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint16_t mFlag, offset 0x0>
	uint16_t mFlag;

	// <uint16_t mTFlag, offset 0x2>
	uint16_t mTFlag;

	// <uint32_t mStartTick, offset 0x4>
	uint32_t mStartTick;

	// <uint32_t mEndTick, offset 0x8>
	uint32_t mEndTick;

	// <uint32_t mHeaderCount, offset 0xc>
	uint32_t mHeaderCount;

	// <uint32_t mPad[0x3], offset 0x10>
	uint32_t mPad[3];

	// <struct _WFAnmObjHeader** mppHeader, offset 0x1c>
	struct _WFAnmObjHeader** mppHeader;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanFAnmSpec>("WGanFAnmSpec")
			.addProperty("mFlag", &WGanFAnmSpec::mFlag)
			.addProperty("mTFlag", &WGanFAnmSpec::mTFlag)
			.addProperty("mStartTick", &WGanFAnmSpec::mStartTick)
			.addProperty("mEndTick", &WGanFAnmSpec::mEndTick)
			.addProperty("mHeaderCount", &WGanFAnmSpec::mHeaderCount)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGanFAnmSpec::mPad)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppHeader", &WGanFAnmSpec::mppHeader)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanFAnmSpec::mFlag) == 2, "expected mFlag to be size 2");
static_assert(sizeof(WGanFAnmSpec::mTFlag) == 2, "expected mTFlag to be size 2");
static_assert(sizeof(WGanFAnmSpec::mStartTick) == 4, "expected mStartTick to be size 4");
static_assert(sizeof(WGanFAnmSpec::mEndTick) == 4, "expected mEndTick to be size 4");
static_assert(sizeof(WGanFAnmSpec::mHeaderCount) == 4, "expected mHeaderCount to be size 4");
static_assert(sizeof(WGanFAnmSpec::mPad) == 12, "expected mPad to be size 12");
static_assert(sizeof(WGanFAnmSpec::mppHeader) == 4, "expected mppHeader to be size 4");
static_assert(sizeof(struct WGanFAnmSpec) == 32, "expected struct WGanFAnmSpec to be size 32");

// struct _WFAnmObjHeader
// no dependencies
struct _WFAnmObjHeader
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint16_t mKeyListCount, offset 0x0>
	uint16_t mKeyListCount;

	// <uint16_t mType, offset 0x2>
	uint16_t mType;

	// <uint32_t mPad, offset 0x4>
	uint32_t mPad;

	// <struct _WFAnmObjKeyListHeader* mpListHeader[0x1], offset 0x8>
	struct _WFAnmObjKeyListHeader* mpListHeader[1];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmObjHeader>("_WFAnmObjHeader")
			.addProperty("mKeyListCount", &_WFAnmObjHeader::mKeyListCount)
			.addProperty("mType", &_WFAnmObjHeader::mType)
			.addProperty("mPad", &_WFAnmObjHeader::mPad)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpListHeader", &_WFAnmObjHeader::mpListHeader)
		.endClass();
	}
#endif
};
static_assert(sizeof(_WFAnmObjHeader::mKeyListCount) == 2, "expected mKeyListCount to be size 2");
static_assert(sizeof(_WFAnmObjHeader::mType) == 2, "expected mType to be size 2");
static_assert(sizeof(_WFAnmObjHeader::mPad) == 4, "expected mPad to be size 4");
static_assert(sizeof(_WFAnmObjHeader::mpListHeader) == 4, "expected mpListHeader to be size 4");
static_assert(sizeof(struct _WFAnmObjHeader) == 12, "expected struct _WFAnmObjHeader to be size 12");

// struct _WFAnmObjKeyListHeader
// no dependencies
struct _WFAnmObjKeyListHeader
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[20];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmObjKeyListHeader>("_WFAnmObjKeyListHeader")
		.endClass();
	}
#endif
};
static_assert(sizeof(struct _WFAnmObjKeyListHeader) == 20, "expected struct _WFAnmObjKeyListHeader to be size 20");

// struct WGanMaterialLayerSpec
// no dependencies
struct WGanMaterialLayerSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint32_t mFlag, offset 0x0>
	uint32_t mFlag;

	// <WGanMaterialLayerSpec* mpPrev, offset 0x4>
	WGanMaterialLayerSpec* mpPrev;

	// <WGanMaterialLayerSpec* mpNext, offset 0x8>
	WGanMaterialLayerSpec* mpNext;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0xc>
	struct WGanFAnmSpec* mpFAnmSpec;

	// <uint32_t mPad[0x4], offset 0x10>
	uint32_t mPad[4];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanMaterialLayerSpec>("WGanMaterialLayerSpec")
			.addProperty("mFlag", &WGanMaterialLayerSpec::mFlag)
			.addProperty("mpPrev", &WGanMaterialLayerSpec::mpPrev)
			.addProperty("mpNext", &WGanMaterialLayerSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanMaterialLayerSpec::mpFAnmSpec)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGanMaterialLayerSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanMaterialLayerSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mpFAnmSpec) == 4, "expected mpFAnmSpec to be size 4");
static_assert(sizeof(WGanMaterialLayerSpec::mPad) == 16, "expected mPad to be size 16");
static_assert(sizeof(struct WGanMaterialLayerSpec) == 32, "expected struct WGanMaterialLayerSpec to be size 32");

// struct WGanNodeSpec
// no dependencies
struct WGanNodeSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint32_t mPad0, offset 0xc>
	uint32_t mPad0;

	// <WGanNodeSpec* mpParent, offset 0x10>
	WGanNodeSpec* mpParent;

	// <WGanNodeSpec* mpChild, offset 0x14>
	WGanNodeSpec* mpChild;

	// <WGanNodeSpec* mpPrev, offset 0x18>
	WGanNodeSpec* mpPrev;

	// <WGanNodeSpec* mpNext, offset 0x1c>
	WGanNodeSpec* mpNext;

	// <struct WGanFAnmSpec* mpFAnmSpec, offset 0x20>
	struct WGanFAnmSpec* mpFAnmSpec;

	// <uint32_t mPad1[0x3], offset 0x24>
	uint32_t mPad1[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGanNodeSpec>("WGanNodeSpec")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGanNodeSpec::mIDStr)
			.addProperty("mFlag", &WGanNodeSpec::mFlag)
			.addProperty("mPad0", &WGanNodeSpec::mPad0)
			.addProperty("mpParent", &WGanNodeSpec::mpParent)
			.addProperty("mpChild", &WGanNodeSpec::mpChild)
			.addProperty("mpPrev", &WGanNodeSpec::mpPrev)
			.addProperty("mpNext", &WGanNodeSpec::mpNext)
			.addProperty("mpFAnmSpec", &WGanNodeSpec::mpFAnmSpec)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad1", &WGanNodeSpec::mPad1)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGanNodeSpec::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGanNodeSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGanNodeSpec::mPad0) == 4, "expected mPad0 to be size 4");
static_assert(sizeof(WGanNodeSpec::mpParent) == 4, "expected mpParent to be size 4");
static_assert(sizeof(WGanNodeSpec::mpChild) == 4, "expected mpChild to be size 4");
static_assert(sizeof(WGanNodeSpec::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGanNodeSpec::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGanNodeSpec::mpFAnmSpec) == 4, "expected mpFAnmSpec to be size 4");
static_assert(sizeof(WGanNodeSpec::mPad1) == 12, "expected mPad1 to be size 12");
static_assert(sizeof(struct WGanNodeSpec) == 48, "expected struct WGanNodeSpec to be size 48");

// class TGanPlayNode
// 1 dependencies: struct TGanPlayNode::MAIN
class TGanPlayNode
{
public:
	/// 1 namespace types: struct TGanPlayNode::MAIN

	// struct TGanPlayNode::MAIN
	// no dependencies
	struct MAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint8_t ValidAnm, offset 0x0>
		uint8_t ValidAnm;

		// <Filler, offset 0x1>
		char _Filler1[3];

		// <class TFAnm* pAnm, offset 0x4>
		class TFAnm* pAnm;

		// <struct WGanNodeSpec* pSpec, offset 0x8>
		struct WGanNodeSpec* pSpec;

		// <class TGanPlay* pGanPlay, offset 0xc>
		class TGanPlay* pGanPlay;

		// <class TGanPlayNode* pNext, offset 0x10>
		class TGanPlayNode* pNext;

		// <class TGanPlayNode* pPrev, offset 0x14>
		class TGanPlayNode* pPrev;

		// <class TGanPlayNode* pChild, offset 0x18>
		class TGanPlayNode* pChild;

		// <class TGanPlayNode* pParent, offset 0x1c>
		class TGanPlayNode* pParent;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGanPlayNode::MAIN>("TGanPlayNode::MAIN")
				.addProperty("ValidAnm", &TGanPlayNode::MAIN::ValidAnm)
				.addProperty("pAnm", &TGanPlayNode::MAIN::pAnm)
				.addProperty("pSpec", &TGanPlayNode::MAIN::pSpec)
				.addProperty("pGanPlay", &TGanPlayNode::MAIN::pGanPlay)
				.addProperty("pNext", &TGanPlayNode::MAIN::pNext)
				.addProperty("pPrev", &TGanPlayNode::MAIN::pPrev)
				.addProperty("pChild", &TGanPlayNode::MAIN::pChild)
				.addProperty("pParent", &TGanPlayNode::MAIN::pParent)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TGanPlayNode::MAIN::ValidAnm) == 1, "expected ValidAnm to be size 1");
	static_assert(sizeof(TGanPlayNode::MAIN::pAnm) == 4, "expected pAnm to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pSpec) == 4, "expected pSpec to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pGanPlay) == 4, "expected pGanPlay to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pNext) == 4, "expected pNext to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pPrev) == 4, "expected pPrev to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pChild) == 4, "expected pChild to be size 4");
	static_assert(sizeof(TGanPlayNode::MAIN::pParent) == 4, "expected pParent to be size 4");
	static_assert(sizeof(struct TGanPlayNode::MAIN) == 32, "expected struct TGanPlayNode::MAIN to be size 32");


	/// Struct member variables

	// <struct TGanPlayNode::MAIN dat, offset 0x0>
	struct TGanPlayNode::MAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGanPlayNode>("TGanPlayNode")
			.addProperty("dat", &TGanPlayNode::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGanPlayNode::dat) == 32, "expected dat to be size 32");
static_assert(sizeof(class TGanPlayNode) == 32, "expected class TGanPlayNode to be size 32");

// class TFAnm
// 1 dependencies: struct TFAnm::tagMAIN
class TFAnm
{
public:
	/// 1 namespace types: struct TFAnm::tagMAIN

	// struct TFAnm::tagMAIN
	// no dependencies
	struct tagMAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class TGmfNode* pGmfNode, offset 0x0>
		class TGmfNode* pGmfNode;

		// <class TFAnmObjF32_3* pAnmObj3, offset 0x4>
		class TFAnmObjF32_3* pAnmObj3;

		// <int32_t AnmObj3Num, offset 0x8>
		int32_t AnmObj3Num;

		// <class TFAnmObj* pAnmObj, offset 0xc>
		class TFAnmObj* pAnmObj;

		// <int32_t AnmObjNum, offset 0x10>
		int32_t AnmObjNum;

		// <float Rate, offset 0x14>
		float Rate;

		// <uint32_t Flag, offset 0x18>
		uint32_t Flag;

		// <float PlayTick, offset 0x1c>
		float PlayTick;

		// <float StartTick, offset 0x20>
		float StartTick;

		// <float EndTick, offset 0x24>
		float EndTick;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TFAnm::tagMAIN>("TFAnm::tagMAIN")
				.addProperty("pGmfNode", &TFAnm::tagMAIN::pGmfNode)
				.addProperty("pAnmObj3", &TFAnm::tagMAIN::pAnmObj3)
				.addProperty("AnmObj3Num", &TFAnm::tagMAIN::AnmObj3Num)
				.addProperty("pAnmObj", &TFAnm::tagMAIN::pAnmObj)
				.addProperty("AnmObjNum", &TFAnm::tagMAIN::AnmObjNum)
				.addProperty("Rate", &TFAnm::tagMAIN::Rate)
				.addProperty("Flag", &TFAnm::tagMAIN::Flag)
				.addProperty("PlayTick", &TFAnm::tagMAIN::PlayTick)
				.addProperty("StartTick", &TFAnm::tagMAIN::StartTick)
				.addProperty("EndTick", &TFAnm::tagMAIN::EndTick)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnm::tagMAIN::pGmfNode) == 4, "expected pGmfNode to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::pAnmObj3) == 4, "expected pAnmObj3 to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::AnmObj3Num) == 4, "expected AnmObj3Num to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::pAnmObj) == 4, "expected pAnmObj to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::AnmObjNum) == 4, "expected AnmObjNum to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::Rate) == 4, "expected Rate to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::Flag) == 4, "expected Flag to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::PlayTick) == 4, "expected PlayTick to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::StartTick) == 4, "expected StartTick to be size 4");
	static_assert(sizeof(TFAnm::tagMAIN::EndTick) == 4, "expected EndTick to be size 4");
	static_assert(sizeof(struct TFAnm::tagMAIN) == 40, "expected struct TFAnm::tagMAIN to be size 40");


	/// Struct member variables

	// <struct TFAnm::tagMAIN dat, offset 0x0>
	struct TFAnm::tagMAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnm>("TFAnm")
			.addProperty("dat", &TFAnm::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnm::dat) == 40, "expected dat to be size 40");
static_assert(sizeof(class TFAnm) == 40, "expected class TFAnm to be size 40");

// class TGmfNode
// 1 dependencies: struct TGmfNode::tagMAIN
class TGmfNode
{
public:
	/// 1 namespace types: struct TGmfNode::tagMAIN

	// struct TGmfNode::tagMAIN
	// no dependencies
	struct tagMAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <Filler, offset 0x0>
		char _Filler[244];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TGmfNode::tagMAIN>("TGmfNode::tagMAIN")
			.endClass();
		}
#endif
	};
	static_assert(sizeof(struct TGmfNode::tagMAIN) == 244, "expected struct TGmfNode::tagMAIN to be size 244");


	/// Struct member variables

	// <struct TGmfNode::tagMAIN dat, offset 0x0>
	struct TGmfNode::tagMAIN dat;

	// <uint8_t m_bIsAlwaysSetupMatrix, offset 0xf4>
	uint8_t m_bIsAlwaysSetupMatrix;

	// <Filler, offset 0xf5>
	char _Filler2[3];

	// <int32_t m_nPolyNum, offset 0xf8>
	int32_t m_nPolyNum;

	// <float m_inLocalMat[0x3][0x4], offset 0xfc>
	float m_inLocalMat[3][4];

	// <class CViewClipObjSphere* m_pViewClipObjSphere, offset 0x12c>
	class CViewClipObjSphere* m_pViewClipObjSphere;

	// <class CViewClipObjBox* m_pViewClipObjBox, offset 0x130>
	class CViewClipObjBox* m_pViewClipObjBox;

	// <float m_fClipDistSqu, offset 0x134>
	float m_fClipDistSqu;

	// <float m_inPreWorldMatMtx[0x3][0x4], offset 0x138>
	float m_inPreWorldMatMtx[3][4];

	// <class EfDestortion* mpDestortion, offset 0x168>
	class EfDestortion* mpDestortion;

	// <class CVertexAnimation* m_pVertexAnime, offset 0x16c>
	class CVertexAnimation* m_pVertexAnime;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGmfNode>("TGmfNode")
			.addProperty("dat", &TGmfNode::dat)
			.addProperty("m_bIsAlwaysSetupMatrix", &TGmfNode::m_bIsAlwaysSetupMatrix)
			.addProperty("m_nPolyNum", &TGmfNode::m_nPolyNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_inLocalMat", &TGmfNode::m_inLocalMat)
			.addProperty("m_pViewClipObjSphere", &TGmfNode::m_pViewClipObjSphere)
			.addProperty("m_pViewClipObjBox", &TGmfNode::m_pViewClipObjBox)
			.addProperty("m_fClipDistSqu", &TGmfNode::m_fClipDistSqu)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_inPreWorldMatMtx", &TGmfNode::m_inPreWorldMatMtx)
			.addProperty("mpDestortion", &TGmfNode::mpDestortion)
			.addProperty("m_pVertexAnime", &TGmfNode::m_pVertexAnime)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGmfNode::dat) == 244, "expected dat to be size 244");
static_assert(sizeof(TGmfNode::m_bIsAlwaysSetupMatrix) == 1, "expected m_bIsAlwaysSetupMatrix to be size 1");
static_assert(sizeof(TGmfNode::m_nPolyNum) == 4, "expected m_nPolyNum to be size 4");
static_assert(sizeof(TGmfNode::m_inLocalMat) == 48, "expected m_inLocalMat to be size 48");
static_assert(sizeof(TGmfNode::m_pViewClipObjSphere) == 4, "expected m_pViewClipObjSphere to be size 4");
static_assert(sizeof(TGmfNode::m_pViewClipObjBox) == 4, "expected m_pViewClipObjBox to be size 4");
static_assert(sizeof(TGmfNode::m_fClipDistSqu) == 4, "expected m_fClipDistSqu to be size 4");
static_assert(sizeof(TGmfNode::m_inPreWorldMatMtx) == 48, "expected m_inPreWorldMatMtx to be size 48");
static_assert(sizeof(TGmfNode::mpDestortion) == 4, "expected mpDestortion to be size 4");
static_assert(sizeof(TGmfNode::m_pVertexAnime) == 4, "expected m_pVertexAnime to be size 4");
static_assert(sizeof(class TGmfNode) == 368, "expected class TGmfNode to be size 368");

// class CViewClipObjSphere
// 4 dependencies: class tiVector, class vector4x, class vector4f, union __m128
class CViewClipObjSphere
{
public:
	/// No namespace types
	/// Struct member variables

	// <class tiVector m_inPosi, offset 0x0>
	class tiVector m_inPosi;

	// <float m_fRadius, offset 0x10>
	float m_fRadius;

	// <Filler, offset 0x14>
	char _Filler[12];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CViewClipObjSphere>("CViewClipObjSphere")
			.addProperty("m_inPosi", &CViewClipObjSphere::m_inPosi)
			.addProperty("m_fRadius", &CViewClipObjSphere::m_fRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(CViewClipObjSphere::m_inPosi) == 16, "expected m_inPosi to be size 16");
static_assert(sizeof(CViewClipObjSphere::m_fRadius) == 4, "expected m_fRadius to be size 4");
static_assert(sizeof(class CViewClipObjSphere) == 32, "expected class CViewClipObjSphere to be size 32");

// class CViewClipObjBox
// no dependencies
class CViewClipObjBox
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[64];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CViewClipObjBox>("CViewClipObjBox")
		.endClass();
	}
#endif
};
static_assert(sizeof(class CViewClipObjBox) == 64, "expected class CViewClipObjBox to be size 64");

// enum GHMR_PRIMTYPE
enum GHMR_PRIMTYPE : uint32_t
{
	// Enum values

	// <GHMR_PRIMTYPE_POINTLIST = 0x0>
	GHMR_PRIMTYPE_POINTLIST = 0,

	// <GHMR_PRIMTYPE_LINELIST = 0x1>
	GHMR_PRIMTYPE_LINELIST = 1,

	// <GHMR_PRIMTYPE_LINESTRIP = 0x2>
	GHMR_PRIMTYPE_LINESTRIP = 2,

	// <GHMR_PRIMTYPE_TRIANGLELIST = 0x3>
	GHMR_PRIMTYPE_TRIANGLELIST = 3,

	// <GHMR_PRIMTYPE_TRIANGLESTRIP = 0x4>
	GHMR_PRIMTYPE_TRIANGLESTRIP = 4,

	// <GHMR_PRIMTYPE_TRIANGLEFAN = 0x5>
	GHMR_PRIMTYPE_TRIANGLEFAN = 5,

	// <GHMR_PRIMTYPE_QUADLIST = 0x6>
	GHMR_PRIMTYPE_QUADLIST = 6

};

// enum GHMR_PROJECT
enum GHMR_PROJECT : uint32_t
{
	// Enum values

	// <GHMR_PROJECT_PERS = 0x0>
	GHMR_PROJECT_PERS = 0,

	// <GHMR_PROJECT_ORTHO = 0x1>
	GHMR_PROJECT_ORTHO = 1,

	// <GHMR_PROJECT_NUM = 0x2>
	GHMR_PROJECT_NUM = 2

};

// class rPrimUnific
// 2 dependencies: enum GHMR_PROJECT, enum GHMR_PRIMTYPE
class rPrimUnific
{
public:
	/// No namespace types
	/// Struct member variables

	// <class rPrimBase* m_pListTop, offset 0x0>
	class rPrimBase* m_pListTop;

	// <class rPrimBase* m_pListEnd, offset 0x4>
	class rPrimBase* m_pListEnd;

	// <enum GHMR_PROJECT m_ProjectMode, offset 0x8>
	enum GHMR_PROJECT m_ProjectMode;

	// <enum GHMR_PRIMTYPE m_PrimType, offset 0xc>
	enum GHMR_PRIMTYPE m_PrimType;

	// <uint32_t m_PrimNum, offset 0x10>
	uint32_t m_PrimNum;

	// <struct tagGHMR_TEX* m_pTex, offset 0x14>
	struct tagGHMR_TEX* m_pTex;

	// <struct tagGHMR_TEX* m_pMultiTex, offset 0x18>
	struct tagGHMR_TEX* m_pMultiTex;

	// <uint32_t m_BitFlag, offset 0x1c>
	uint32_t m_BitFlag;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rPrimUnific>("rPrimUnific")
			.addProperty("m_pListTop", &rPrimUnific::m_pListTop)
			.addProperty("m_pListEnd", &rPrimUnific::m_pListEnd)
			.addProperty("m_ProjectMode", &rPrimUnific::m_ProjectMode)
			.addProperty("m_PrimType", &rPrimUnific::m_PrimType)
			.addProperty("m_PrimNum", &rPrimUnific::m_PrimNum)
			.addProperty("m_pTex", &rPrimUnific::m_pTex)
			.addProperty("m_pMultiTex", &rPrimUnific::m_pMultiTex)
			.addProperty("m_BitFlag", &rPrimUnific::m_BitFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(rPrimUnific::m_pListTop) == 4, "expected m_pListTop to be size 4");
static_assert(sizeof(rPrimUnific::m_pListEnd) == 4, "expected m_pListEnd to be size 4");
static_assert(sizeof(rPrimUnific::m_ProjectMode) == 4, "expected m_ProjectMode to be size 4");
static_assert(sizeof(rPrimUnific::m_PrimType) == 4, "expected m_PrimType to be size 4");
static_assert(sizeof(rPrimUnific::m_PrimNum) == 4, "expected m_PrimNum to be size 4");
static_assert(sizeof(rPrimUnific::m_pTex) == 4, "expected m_pTex to be size 4");
static_assert(sizeof(rPrimUnific::m_pMultiTex) == 4, "expected m_pMultiTex to be size 4");
static_assert(sizeof(rPrimUnific::m_BitFlag) == 4, "expected m_BitFlag to be size 4");
static_assert(sizeof(class rPrimUnific) == 32, "expected class rPrimUnific to be size 32");

// class EfBase
// no dependencies
class EfBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t mBitFlag, offset 0x0>
	uint8_t mBitFlag;

	// <Filler, offset 0x1>
	char _Filler1[3];

	// <uint32_t mTick, offset 0x4>
	uint32_t mTick;

	// <uint32_t mBefFrameTick, offset 0x8>
	uint32_t mBefFrameTick;

	// <float mRate, offset 0xc>
	float mRate;

	// <uint32_t mSelectParam, offset 0x10>
	uint32_t mSelectParam;

	// <uint32_t mKeyWait, offset 0x14>
	uint32_t mKeyWait;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfBase>("EfBase")
			.addProperty("mBitFlag", &EfBase::mBitFlag)
			.addProperty("mTick", &EfBase::mTick)
			.addProperty("mBefFrameTick", &EfBase::mBefFrameTick)
			.addProperty("mRate", &EfBase::mRate)
			.addProperty("mSelectParam", &EfBase::mSelectParam)
			.addProperty("mKeyWait", &EfBase::mKeyWait)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfBase::mBitFlag) == 1, "expected mBitFlag to be size 1");
static_assert(sizeof(EfBase::mTick) == 4, "expected mTick to be size 4");
static_assert(sizeof(EfBase::mBefFrameTick) == 4, "expected mBefFrameTick to be size 4");
static_assert(sizeof(EfBase::mRate) == 4, "expected mRate to be size 4");
static_assert(sizeof(EfBase::mSelectParam) == 4, "expected mSelectParam to be size 4");
static_assert(sizeof(EfBase::mKeyWait) == 4, "expected mKeyWait to be size 4");
static_assert(sizeof(class EfBase) == 24, "expected class EfBase to be size 24");

// class HrTask
// no dependencies
class HrTask
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[80];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrTask>("HrTask")
		.endClass();
	}
#endif
};
static_assert(sizeof(class HrTask) == 80, "expected class HrTask to be size 80");

// class EfDestortion
// 6 dependencies: class HrTask, class EfBase, enum EfDestortion::UV_Type, class rPrimUnific, enum GHMR_PROJECT, enum GHMR_PRIMTYPE
class EfDestortion : HrTask
{
public:
	/// 1 namespace types: enum EfDestortion::UV_Type

	// enum EfDestortion::UV_Type
	enum UV_Type : uint32_t
	{
		// Enum values

		// <UV_Sin = 0x1>
		UV_Sin = 1,

		// <UV_Rand = 0x2>
		UV_Rand = 2

	};


	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <class TGmfNode* mpNode, offset 0x68>
	class TGmfNode* mpNode;

	// <struct TGMFMESH** mppMeshList, offset 0x6c>
	struct TGMFMESH** mppMeshList;

	// <uint32_t mTriangleNum, offset 0x70>
	uint32_t mTriangleNum;

	// <float mScreenWidthInv, offset 0x74>
	float mScreenWidthInv;

	// <float mAmplitude, offset 0x78>
	float mAmplitude;

	// <enum EfDestortion::UV_Type mType, offset 0x7c>
	enum EfDestortion::UV_Type mType;

	// <uint8_t* mpRandIdxAry, offset 0x80>
	uint8_t* mpRandIdxAry;

	// <class rTriangleList* mpTriangleAry, offset 0x84>
	class rTriangleList* mpTriangleAry;

	// <class rPrimUnific mTriangleUni, offset 0x88>
	class rPrimUnific mTriangleUni;

	// <uint8_t mbRenderWait, offset 0xa8>
	uint8_t mbRenderWait;

	// <Filler, offset 0xa9>
	char _Filler12[3];

	// <float mSinCnt[0x64], offset 0xac>
	float mSinCnt[100];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfDestortion>("EfDestortion")
			.addProperty("field_50", &EfDestortion::field_50)
			.addProperty("mpNode", &EfDestortion::mpNode)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppMeshList", &EfDestortion::mppMeshList)
			.addProperty("mTriangleNum", &EfDestortion::mTriangleNum)
			.addProperty("mScreenWidthInv", &EfDestortion::mScreenWidthInv)
			.addProperty("mAmplitude", &EfDestortion::mAmplitude)
			.addProperty("mType", &EfDestortion::mType)
			// native pointer type (uint8_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpRandIdxAry", &EfDestortion::mpRandIdxAry)
			.addProperty("mpTriangleAry", &EfDestortion::mpTriangleAry)
			.addProperty("mTriangleUni", &EfDestortion::mTriangleUni)
			.addProperty("mbRenderWait", &EfDestortion::mbRenderWait)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mSinCnt", &EfDestortion::mSinCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfDestortion::field_50) == 24, "expected field_50 to be size 24");
static_assert(sizeof(EfDestortion::mpNode) == 4, "expected mpNode to be size 4");
static_assert(sizeof(EfDestortion::mppMeshList) == 4, "expected mppMeshList to be size 4");
static_assert(sizeof(EfDestortion::mTriangleNum) == 4, "expected mTriangleNum to be size 4");
static_assert(sizeof(EfDestortion::mScreenWidthInv) == 4, "expected mScreenWidthInv to be size 4");
static_assert(sizeof(EfDestortion::mAmplitude) == 4, "expected mAmplitude to be size 4");
static_assert(sizeof(EfDestortion::mType) == 4, "expected mType to be size 4");
static_assert(sizeof(EfDestortion::mpRandIdxAry) == 4, "expected mpRandIdxAry to be size 4");
static_assert(sizeof(EfDestortion::mpTriangleAry) == 4, "expected mpTriangleAry to be size 4");
static_assert(sizeof(EfDestortion::mTriangleUni) == 32, "expected mTriangleUni to be size 32");
static_assert(sizeof(EfDestortion::mbRenderWait) == 1, "expected mbRenderWait to be size 1");
static_assert(sizeof(EfDestortion::mSinCnt) == 400, "expected mSinCnt to be size 400");
static_assert(sizeof(class EfDestortion) == 572, "expected class EfDestortion to be size 572");

// struct TGMFMESH
// no dependencies
struct TGMFMESH
{
public:
	/// No namespace types
	/// Struct member variables

	// <class TGmfNode* pNode, offset 0x0>
	class TGmfNode* pNode;

	// <struct tagGHMR_TEX* pTex, offset 0x4>
	struct tagGHMR_TEX* pTex;

	// <int32_t VertexNum, offset 0x8>
	int32_t VertexNum;

	// <int32_t PolyNum, offset 0xc>
	int32_t PolyNum;

	// <uint32_t VertexSize, offset 0x10>
	uint32_t VertexSize;

	// <uint32_t TransVertexSize, offset 0x14>
	uint32_t TransVertexSize;

	// <uint8_t HaveNormal, offset 0x18>
	uint8_t HaveNormal;

	// <uint8_t HaveColor, offset 0x19>
	uint8_t HaveColor;

	// <uint8_t HaveUV, offset 0x1a>
	uint8_t HaveUV;

	// <uint8_t Transform, offset 0x1b>
	uint8_t Transform;

	// <float TransMat[0x8][0x3][0x4], offset 0x1c>
	float TransMat[8][3][4];

	// <void* Vertex, offset 0x19c>
	void* Vertex;

	// <void* TransVertex, offset 0x1a0>
	void* TransVertex;

	// <uint32_t* PolyList, offset 0x1a4>
	uint32_t* PolyList;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TGMFMESH>("TGMFMESH")
			.addProperty("pNode", &TGMFMESH::pNode)
			.addProperty("pTex", &TGMFMESH::pTex)
			.addProperty("VertexNum", &TGMFMESH::VertexNum)
			.addProperty("PolyNum", &TGMFMESH::PolyNum)
			.addProperty("VertexSize", &TGMFMESH::VertexSize)
			.addProperty("TransVertexSize", &TGMFMESH::TransVertexSize)
			.addProperty("HaveNormal", &TGMFMESH::HaveNormal)
			.addProperty("HaveColor", &TGMFMESH::HaveColor)
			.addProperty("HaveUV", &TGMFMESH::HaveUV)
			.addProperty("Transform", &TGMFMESH::Transform)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("TransMat", &TGMFMESH::TransMat)
			// void type not supported in LuaBridge
			//.addProperty("Vertex", &TGMFMESH::Vertex)
			// void type not supported in LuaBridge
			//.addProperty("TransVertex", &TGMFMESH::TransVertex)
			// native pointer type (uint32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("PolyList", &TGMFMESH::PolyList)
		.endClass();
	}
#endif
};
static_assert(sizeof(TGMFMESH::pNode) == 4, "expected pNode to be size 4");
static_assert(sizeof(TGMFMESH::pTex) == 4, "expected pTex to be size 4");
static_assert(sizeof(TGMFMESH::VertexNum) == 4, "expected VertexNum to be size 4");
static_assert(sizeof(TGMFMESH::PolyNum) == 4, "expected PolyNum to be size 4");
static_assert(sizeof(TGMFMESH::VertexSize) == 4, "expected VertexSize to be size 4");
static_assert(sizeof(TGMFMESH::TransVertexSize) == 4, "expected TransVertexSize to be size 4");
static_assert(sizeof(TGMFMESH::HaveNormal) == 1, "expected HaveNormal to be size 1");
static_assert(sizeof(TGMFMESH::HaveColor) == 1, "expected HaveColor to be size 1");
static_assert(sizeof(TGMFMESH::HaveUV) == 1, "expected HaveUV to be size 1");
static_assert(sizeof(TGMFMESH::Transform) == 1, "expected Transform to be size 1");
static_assert(sizeof(TGMFMESH::TransMat) == 384, "expected TransMat to be size 384");
static_assert(sizeof(TGMFMESH::Vertex) == 4, "expected Vertex to be size 4");
static_assert(sizeof(TGMFMESH::TransVertex) == 4, "expected TransVertex to be size 4");
static_assert(sizeof(TGMFMESH::PolyList) == 4, "expected PolyList to be size 4");
static_assert(sizeof(struct TGMFMESH) == 424, "expected struct TGMFMESH to be size 424");

// enum GHMR_TEXDOT_ASPECT
enum GHMR_TEXDOT_ASPECT : uint32_t
{
	// Enum values

	// <GHMR_TEXDOT_ASPECT_1x1 = 0x0>
	GHMR_TEXDOT_ASPECT_1x1 = 0,

	// <GHMR_TEXDOT_ASPECT_CANCEL = 0x1>
	GHMR_TEXDOT_ASPECT_CANCEL = 1

};

// enum _GXTexFmt
enum _GXTexFmt : uint32_t
{
	// Enum values

	// <GX_TF_I4 = 0x0>
	GX_TF_I4 = 0,

	// <GX_TF_I8 = 0x1>
	GX_TF_I8 = 1,

	// <GX_TF_IA4 = 0x2>
	GX_TF_IA4 = 2,

	// <GX_TF_IA8 = 0x3>
	GX_TF_IA8 = 3,

	// <GX_TF_RGB565 = 0x4>
	GX_TF_RGB565 = 4,

	// <GX_TF_RGB5A3 = 0x5>
	GX_TF_RGB5A3 = 5,

	// <GX_TF_RGBA8 = 0x6>
	GX_TF_RGBA8 = 6,

	// <GX_TF_CMPR = 0xe>
	GX_TF_CMPR = 14,

	// <GX_CTF_R4 = 0x20>
	GX_CTF_R4 = 32,

	// <GX_CTF_RA4 = 0x22>
	GX_CTF_RA4 = 34,

	// <GX_CTF_RA8 = 0x23>
	GX_CTF_RA8 = 35,

	// <GX_CTF_YUVA8 = 0x26>
	GX_CTF_YUVA8 = 38,

	// <GX_CTF_A8 = 0x27>
	GX_CTF_A8 = 39,

	// <GX_CTF_R8 = 0x28>
	GX_CTF_R8 = 40,

	// <GX_CTF_G8 = 0x29>
	GX_CTF_G8 = 41,

	// <GX_CTF_B8 = 0x2a>
	GX_CTF_B8 = 42,

	// <GX_CTF_RG8 = 0x2b>
	GX_CTF_RG8 = 43,

	// <GX_CTF_GB8 = 0x2c>
	GX_CTF_GB8 = 44,

	// <GX_TF_Z8 = 0x11>
	GX_TF_Z8 = 17,

	// <GX_TF_Z16 = 0x13>
	GX_TF_Z16 = 19,

	// <GX_TF_Z24X8 = 0x16>
	GX_TF_Z24X8 = 22,

	// <GX_CTF_Z4 = 0x30>
	GX_CTF_Z4 = 48,

	// <GX_CTF_Z8M = 0x39>
	GX_CTF_Z8M = 57,

	// <GX_CTF_Z8L = 0x3a>
	GX_CTF_Z8L = 58,

	// <GX_CTF_Z16L = 0x3c>
	GX_CTF_Z16L = 60,

	// <GX_TF_A8 = 0x27>
	GX_TF_A8 = 39

};

// enum GHMR_TEXFILTER
enum GHMR_TEXFILTER : uint32_t
{
	// Enum values

	// <GHMR_TEXFILTER_NEAR = 0x0>
	GHMR_TEXFILTER_NEAR = 0,

	// <GHMR_TEXFILTER_LINEAR = 0x1>
	GHMR_TEXFILTER_LINEAR = 1

};

// enum GHMR_TEXADDRESS
enum GHMR_TEXADDRESS : uint32_t
{
	// Enum values

	// <GHMR_TEXADDRESS_CLAMP = 0x0>
	GHMR_TEXADDRESS_CLAMP = 0,

	// <GHMR_TEXADDRESS_REPEAT = 0x1>
	GHMR_TEXADDRESS_REPEAT = 1,

	// <GHMR_TEXADDRESS_MIRROR = 0x2>
	GHMR_TEXADDRESS_MIRROR = 2,

	// <GHMR_TEXADDRESS_REPEAT_FORCED = 0x3>
	GHMR_TEXADDRESS_REPEAT_FORCED = 3,

	// <GHMR_TEXADDRESS_MIRROR_FORCED = 0x4>
	GHMR_TEXADDRESS_MIRROR_FORCED = 4

};

// struct GXTexObj
// no dependencies
struct GXTexObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class GXTexture* pTex, offset 0x0>
	class GXTexture* pTex;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXTexObj>("GXTexObj")
			.addProperty("pTex", &GXTexObj::pTex)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXTexObj::pTex) == 4, "expected pTex to be size 4");
static_assert(sizeof(struct GXTexObj) == 4, "expected struct GXTexObj to be size 4");

// struct tagGHMR_TEX
// 5 dependencies: struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT
struct tagGHMR_TEX
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t TMEFlag, offset 0x0>
	uint8_t TMEFlag;

	// <uint8_t AlphaFlag, offset 0x1>
	uint8_t AlphaFlag;

	// <uint8_t ImageBufferFreeFlag, offset 0x2>
	uint8_t ImageBufferFreeFlag;

	// <Filler, offset 0x3>
	char _Filler3[1];

	// <void* FileImage, offset 0x4>
	void* FileImage;

	// <void* ImageBuffer, offset 0x8>
	void* ImageBuffer;

	// <uint16_t Width, offset 0xc>
	uint16_t Width;

	// <uint16_t Height, offset 0xe>
	uint16_t Height;

	// <struct GXTexObj TexObj, offset 0x10>
	struct GXTexObj TexObj;

	// <enum GHMR_TEXADDRESS AddressMode, offset 0x14>
	enum GHMR_TEXADDRESS AddressMode;

	// <enum GHMR_TEXFILTER FilterMode, offset 0x18>
	enum GHMR_TEXFILTER FilterMode;

	// <enum _GXTexFmt GetScreenImageFormat, offset 0x1c>
	enum _GXTexFmt GetScreenImageFormat;

	// <int32_t ImageSize, offset 0x20>
	int32_t ImageSize;

	// <enum GHMR_TEXDOT_ASPECT Aspect, offset 0x24>
	enum GHMR_TEXDOT_ASPECT Aspect;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagGHMR_TEX>("tagGHMR_TEX")
			.addProperty("TMEFlag", &tagGHMR_TEX::TMEFlag)
			.addProperty("AlphaFlag", &tagGHMR_TEX::AlphaFlag)
			.addProperty("ImageBufferFreeFlag", &tagGHMR_TEX::ImageBufferFreeFlag)
			// void type not supported in LuaBridge
			//.addProperty("FileImage", &tagGHMR_TEX::FileImage)
			// void type not supported in LuaBridge
			//.addProperty("ImageBuffer", &tagGHMR_TEX::ImageBuffer)
			.addProperty("Width", &tagGHMR_TEX::Width)
			.addProperty("Height", &tagGHMR_TEX::Height)
			.addProperty("TexObj", &tagGHMR_TEX::TexObj)
			.addProperty("AddressMode", &tagGHMR_TEX::AddressMode)
			.addProperty("FilterMode", &tagGHMR_TEX::FilterMode)
			.addProperty("GetScreenImageFormat", &tagGHMR_TEX::GetScreenImageFormat)
			.addProperty("ImageSize", &tagGHMR_TEX::ImageSize)
			.addProperty("Aspect", &tagGHMR_TEX::Aspect)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagGHMR_TEX::TMEFlag) == 1, "expected TMEFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::AlphaFlag) == 1, "expected AlphaFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::ImageBufferFreeFlag) == 1, "expected ImageBufferFreeFlag to be size 1");
static_assert(sizeof(tagGHMR_TEX::FileImage) == 4, "expected FileImage to be size 4");
static_assert(sizeof(tagGHMR_TEX::ImageBuffer) == 4, "expected ImageBuffer to be size 4");
static_assert(sizeof(tagGHMR_TEX::Width) == 2, "expected Width to be size 2");
static_assert(sizeof(tagGHMR_TEX::Height) == 2, "expected Height to be size 2");
static_assert(sizeof(tagGHMR_TEX::TexObj) == 4, "expected TexObj to be size 4");
static_assert(sizeof(tagGHMR_TEX::AddressMode) == 4, "expected AddressMode to be size 4");
static_assert(sizeof(tagGHMR_TEX::FilterMode) == 4, "expected FilterMode to be size 4");
static_assert(sizeof(tagGHMR_TEX::GetScreenImageFormat) == 4, "expected GetScreenImageFormat to be size 4");
static_assert(sizeof(tagGHMR_TEX::ImageSize) == 4, "expected ImageSize to be size 4");
static_assert(sizeof(tagGHMR_TEX::Aspect) == 4, "expected Aspect to be size 4");
static_assert(sizeof(struct tagGHMR_TEX) == 40, "expected struct tagGHMR_TEX to be size 40");

// union GXSamplerStuff
// no dependencies
union GXSamplerStuff
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint32_t wrapS, offset 0x0>
	uint32_t wrapS;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXSamplerStuff>("GXSamplerStuff")
			.addProperty("wrapS", &GXSamplerStuff::wrapS)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXSamplerStuff::wrapS) == 4, "expected wrapS to be size 4");
static_assert(sizeof(union GXSamplerStuff) == 4, "expected union GXSamplerStuff to be size 4");

// class GXTexture
// 9 dependencies: class EE::RefObject, union GXSamplerStuff, class EE::SmartPtr<ID3D11ShaderResourceView>, struct GXTexture::GXSpecs, enum _GXTexFmt, class EE::SmartPtr<ID3D11Texture2D>, class EE::SmartPtr<ID3D11RenderTargetView>, class EE::SmartPtr<ID3D11DepthStencilView>, struct D3D11_MAPPED_SUBRESOURCE
class GXTexture : EE::RefObject
{
public:
	/// 1 namespace types: struct GXTexture::GXSpecs

	// struct GXTexture::GXSpecs
	// 1 dependencies: enum _GXTexFmt
	struct GXSpecs
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint16_t width, offset 0x0>
		uint16_t width;

		// <uint16_t height, offset 0x2>
		uint16_t height;

		// <uint16_t rtWidth, offset 0x4>
		uint16_t rtWidth;

		// <uint16_t rtHeight, offset 0x6>
		uint16_t rtHeight;

		// <enum _GXTexFmt format, offset 0x8>
		enum _GXTexFmt format;

		// <uint8_t mipmap, offset 0xc>
		uint8_t mipmap;

		// <uint8_t bias_clamp, offset 0xd>
		uint8_t bias_clamp;

		// <uint8_t do_edge_lod, offset 0xe>
		uint8_t do_edge_lod;

		// <Filler, offset 0xf>
		char _Filler8[1];

		// <uint32_t hash, offset 0x10>
		uint32_t hash;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<GXTexture::GXSpecs>("GXTexture::GXSpecs")
				.addProperty("width", &GXTexture::GXSpecs::width)
				.addProperty("height", &GXTexture::GXSpecs::height)
				.addProperty("rtWidth", &GXTexture::GXSpecs::rtWidth)
				.addProperty("rtHeight", &GXTexture::GXSpecs::rtHeight)
				.addProperty("format", &GXTexture::GXSpecs::format)
				.addProperty("mipmap", &GXTexture::GXSpecs::mipmap)
				.addProperty("bias_clamp", &GXTexture::GXSpecs::bias_clamp)
				.addProperty("do_edge_lod", &GXTexture::GXSpecs::do_edge_lod)
				.addProperty("hash", &GXTexture::GXSpecs::hash)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(GXTexture::GXSpecs::width) == 2, "expected width to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::height) == 2, "expected height to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::rtWidth) == 2, "expected rtWidth to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::rtHeight) == 2, "expected rtHeight to be size 2");
	static_assert(sizeof(GXTexture::GXSpecs::format) == 4, "expected format to be size 4");
	static_assert(sizeof(GXTexture::GXSpecs::mipmap) == 1, "expected mipmap to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::bias_clamp) == 1, "expected bias_clamp to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::do_edge_lod) == 1, "expected do_edge_lod to be size 1");
	static_assert(sizeof(GXTexture::GXSpecs::hash) == 4, "expected hash to be size 4");
	static_assert(sizeof(struct GXTexture::GXSpecs) == 20, "expected struct GXTexture::GXSpecs to be size 20");


	/// Struct member variables

	// <class EE::RefObject field_0, offset 0x0>
	// class EE::RefObject Super;

	// <uint32_t marker, offset 0x8>
	uint32_t marker;

	// <union GXSamplerStuff sampler, offset 0xc>
	union GXSamplerStuff sampler;

	// <class EE::SmartPtr<ID3D11ShaderResourceView> textureView, offset 0x10>
	class EE::SmartPtr<ID3D11ShaderResourceView> textureView;

	// <uint32_t textureViewId, offset 0x14>
	uint32_t textureViewId;

	// <struct GXTexture::GXSpecs gxSpecs, offset 0x18>
	struct GXTexture::GXSpecs gxSpecs;

	// <class EE::SmartPtr<ID3D11Texture2D> texture, offset 0x2c>
	class EE::SmartPtr<ID3D11Texture2D> texture;

	// <class EE::SmartPtr<ID3D11RenderTargetView> renderTargetView, offset 0x30>
	class EE::SmartPtr<ID3D11RenderTargetView> renderTargetView;

	// <class EE::SmartPtr<ID3D11DepthStencilView> depthStencilView, offset 0x34>
	class EE::SmartPtr<ID3D11DepthStencilView> depthStencilView;

	// <class EE::SmartPtr<ID3D11Texture2D> stagingTex, offset 0x38>
	class EE::SmartPtr<ID3D11Texture2D> stagingTex;

	// <struct D3D11_MAPPED_SUBRESOURCE stagingTexMap, offset 0x3c>
	struct D3D11_MAPPED_SUBRESOURCE stagingTexMap;

	// <struct EE::OptListNode<GXTexture *> renderTargetListNode, offset 0x48>
	struct EE::OptListNode<GXTexture *> renderTargetListNode;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXTexture>("GXTexture")
			.addProperty("marker", &GXTexture::marker)
			.addProperty("sampler", &GXTexture::sampler)
			.addProperty("textureView", &GXTexture::textureView)
			.addProperty("textureViewId", &GXTexture::textureViewId)
			.addProperty("gxSpecs", &GXTexture::gxSpecs)
			.addProperty("texture", &GXTexture::texture)
			.addProperty("renderTargetView", &GXTexture::renderTargetView)
			.addProperty("depthStencilView", &GXTexture::depthStencilView)
			.addProperty("stagingTex", &GXTexture::stagingTex)
			.addProperty("stagingTexMap", &GXTexture::stagingTexMap)
			.addProperty("renderTargetListNode", &GXTexture::renderTargetListNode)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXTexture::marker) == 4, "expected marker to be size 4");
static_assert(sizeof(GXTexture::sampler) == 4, "expected sampler to be size 4");
static_assert(sizeof(GXTexture::textureView) == 4, "expected textureView to be size 4");
static_assert(sizeof(GXTexture::textureViewId) == 4, "expected textureViewId to be size 4");
static_assert(sizeof(GXTexture::gxSpecs) == 20, "expected gxSpecs to be size 20");
static_assert(sizeof(GXTexture::texture) == 4, "expected texture to be size 4");
static_assert(sizeof(GXTexture::renderTargetView) == 4, "expected renderTargetView to be size 4");
static_assert(sizeof(GXTexture::depthStencilView) == 4, "expected depthStencilView to be size 4");
static_assert(sizeof(GXTexture::stagingTex) == 4, "expected stagingTex to be size 4");
static_assert(sizeof(GXTexture::stagingTexMap) == 12, "expected stagingTexMap to be size 12");
static_assert(sizeof(GXTexture::renderTargetListNode) == 12, "expected renderTargetListNode to be size 12");
static_assert(sizeof(class GXTexture) == 84, "expected class GXTexture to be size 84");

// struct rAlphaAnime
// no dependencies
struct rAlphaAnime
{
public:
	/// No namespace types
	/// Struct member variables

	// <float Add, offset 0x0>
	float Add;

	// <float Target, offset 0x4>
	float Target;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rAlphaAnime>("rAlphaAnime")
			.addProperty("Add", &rAlphaAnime::Add)
			.addProperty("Target", &rAlphaAnime::Target)
		.endClass();
	}
#endif
};
static_assert(sizeof(rAlphaAnime::Add) == 4, "expected Add to be size 4");
static_assert(sizeof(rAlphaAnime::Target) == 4, "expected Target to be size 4");
static_assert(sizeof(struct rAlphaAnime) == 8, "expected struct rAlphaAnime to be size 8");

// struct rAnimeCounter
// no dependencies
struct rAnimeCounter
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint16_t Count, offset 0x0>
	uint16_t Count;

	// <uint16_t Frame, offset 0x2>
	uint16_t Frame;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rAnimeCounter>("rAnimeCounter")
			.addProperty("Count", &rAnimeCounter::Count)
			.addProperty("Frame", &rAnimeCounter::Frame)
		.endClass();
	}
#endif
};
static_assert(sizeof(rAnimeCounter::Count) == 2, "expected Count to be size 2");
static_assert(sizeof(rAnimeCounter::Frame) == 2, "expected Frame to be size 2");
static_assert(sizeof(struct rAnimeCounter) == 4, "expected struct rAnimeCounter to be size 4");

// struct rST
// no dependencies
struct rST
{
public:
	/// No namespace types
	/// Struct member variables

	// <float s, offset 0x0>
	float s;

	// <float t, offset 0x4>
	float t;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rST>("rST")
			.addProperty("s", &rST::s)
			.addProperty("t", &rST::t)
		.endClass();
	}
#endif
};
static_assert(sizeof(rST::s) == 4, "expected s to be size 4");
static_assert(sizeof(rST::t) == 4, "expected t to be size 4");
static_assert(sizeof(struct rST) == 8, "expected struct rST to be size 8");

// struct rColor
// no dependencies
struct rColor
{
public:
	/// No namespace types
	/// Struct member variables

	// <float r, offset 0x0>
	float r;

	// <float g, offset 0x4>
	float g;

	// <float b, offset 0x8>
	float b;

	// <float a, offset 0xc>
	float a;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rColor>("rColor")
			.addProperty("r", &rColor::r)
			.addProperty("g", &rColor::g)
			.addProperty("b", &rColor::b)
			.addProperty("a", &rColor::a)
		.endClass();
	}
#endif
};
static_assert(sizeof(rColor::r) == 4, "expected r to be size 4");
static_assert(sizeof(rColor::g) == 4, "expected g to be size 4");
static_assert(sizeof(rColor::b) == 4, "expected b to be size 4");
static_assert(sizeof(rColor::a) == 4, "expected a to be size 4");
static_assert(sizeof(struct rColor) == 16, "expected struct rColor to be size 16");

// class rPrimBase
// no dependencies
class rPrimBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x3], offset 0x0>
	void* (* field_0)[0x3];

	// <uint32_t m_BitFlag, offset 0x4>
	uint32_t m_BitFlag;

	// <rPrimBase* m_pPrev, offset 0x8>
	rPrimBase* m_pPrev;

	// <rPrimBase* m_pNext, offset 0xc>
	rPrimBase* m_pNext;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rPrimBase>("rPrimBase")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &rPrimBase::field_0)
			.addProperty("m_BitFlag", &rPrimBase::m_BitFlag)
			.addProperty("m_pPrev", &rPrimBase::m_pPrev)
			.addProperty("m_pNext", &rPrimBase::m_pNext)
		.endClass();
	}
#endif
};
static_assert(sizeof(rPrimBase::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(rPrimBase::m_BitFlag) == 4, "expected m_BitFlag to be size 4");
static_assert(sizeof(rPrimBase::m_pPrev) == 4, "expected m_pPrev to be size 4");
static_assert(sizeof(rPrimBase::m_pNext) == 4, "expected m_pNext to be size 4");
static_assert(sizeof(class rPrimBase) == 16, "expected class rPrimBase to be size 16");

// class rTriangleList
// 6 dependencies: class rPrimBase, struct Vec, struct rColor, struct rST, struct rAnimeCounter, struct rAlphaAnime
class rTriangleList : rPrimBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class rPrimBase field_0, offset 0x0>
	// class rPrimBase Super;

	// <struct Vec m_Position, offset 0x10>
	struct Vec m_Position;

	// <struct rColor m_Color, offset 0x1c>
	struct rColor m_Color;

	// <struct rST m_ST, offset 0x2c>
	struct rST m_ST;

	// <struct rAnimeCounter m_AnimeCounter, offset 0x34>
	struct rAnimeCounter m_AnimeCounter;

	// <struct rAlphaAnime m_ColorAnime, offset 0x38>
	struct rAlphaAnime m_ColorAnime;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rTriangleList>("rTriangleList")
			.addProperty("m_Position", &rTriangleList::m_Position)
			.addProperty("m_Color", &rTriangleList::m_Color)
			.addProperty("m_ST", &rTriangleList::m_ST)
			.addProperty("m_AnimeCounter", &rTriangleList::m_AnimeCounter)
			.addProperty("m_ColorAnime", &rTriangleList::m_ColorAnime)
		.endClass();
	}
#endif
};
static_assert(sizeof(rTriangleList::m_Position) == 12, "expected m_Position to be size 12");
static_assert(sizeof(rTriangleList::m_Color) == 16, "expected m_Color to be size 16");
static_assert(sizeof(rTriangleList::m_ST) == 8, "expected m_ST to be size 8");
static_assert(sizeof(rTriangleList::m_AnimeCounter) == 4, "expected m_AnimeCounter to be size 4");
static_assert(sizeof(rTriangleList::m_ColorAnime) == 8, "expected m_ColorAnime to be size 8");
static_assert(sizeof(class rTriangleList) == 64, "expected class rTriangleList to be size 64");

// class CVertexAnimation
// no dependencies
class CVertexAnimation
{
public:
	/// 1 namespace types: class CVertexAnimation::CVertex

	// class CVertexAnimation::CVertex
	// no dependencies
	class CVertex
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t m_nPosiIndex, offset 0x0>
		int32_t m_nPosiIndex;

		// <float m_fCenter, offset 0x4>
		float m_fCenter;

		// <int32_t m_nSinIndex, offset 0x8>
		int32_t m_nSinIndex;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CVertexAnimation::CVertex>("CVertexAnimation::CVertex")
				.addProperty("m_nPosiIndex", &CVertexAnimation::CVertex::m_nPosiIndex)
				.addProperty("m_fCenter", &CVertexAnimation::CVertex::m_fCenter)
				.addProperty("m_nSinIndex", &CVertexAnimation::CVertex::m_nSinIndex)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(CVertexAnimation::CVertex::m_nPosiIndex) == 4, "expected m_nPosiIndex to be size 4");
	static_assert(sizeof(CVertexAnimation::CVertex::m_fCenter) == 4, "expected m_fCenter to be size 4");
	static_assert(sizeof(CVertexAnimation::CVertex::m_nSinIndex) == 4, "expected m_nSinIndex to be size 4");
	static_assert(sizeof(class CVertexAnimation::CVertex) == 12, "expected class CVertexAnimation::CVertex to be size 12");


	/// Struct member variables

	// <uint8_t* m_pbyNewMem, offset 0x0>
	uint8_t* m_pbyNewMem;

	// <uint8_t* m_abyNodePosiBuf[0x2], offset 0x4>
	uint8_t* m_abyNodePosiBuf[2];

	// <uint32_t m_nBufSize, offset 0xc>
	uint32_t m_nBufSize;

	// <class CStlVector<CVertexAnimation::CVertex> m_ainVertex, offset 0x10>
	class std::vector<CVertexAnimation::CVertex> m_ainVertex;

	// <float m_fOfstMax, offset 0x1c>
	float m_fOfstMax;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CVertexAnimation>("CVertexAnimation")
			// native pointer type (uint8_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pbyNewMem", &CVertexAnimation::m_pbyNewMem)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_abyNodePosiBuf", &CVertexAnimation::m_abyNodePosiBuf)
			.addProperty("m_nBufSize", &CVertexAnimation::m_nBufSize)
			.addProperty("m_ainVertex", &CVertexAnimation::m_ainVertex)
			.addProperty("m_fOfstMax", &CVertexAnimation::m_fOfstMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(CVertexAnimation::m_pbyNewMem) == 4, "expected m_pbyNewMem to be size 4");
static_assert(sizeof(CVertexAnimation::m_abyNodePosiBuf) == 8, "expected m_abyNodePosiBuf to be size 8");
static_assert(sizeof(CVertexAnimation::m_nBufSize) == 4, "expected m_nBufSize to be size 4");
static_assert(sizeof(CVertexAnimation::m_ainVertex) == 12, "expected m_ainVertex to be size 12");
static_assert(sizeof(CVertexAnimation::m_fOfstMax) == 4, "expected m_fOfstMax to be size 4");
static_assert(sizeof(class CVertexAnimation) == 32, "expected class CVertexAnimation to be size 32");

// class TFAnmObjF32_3
// 1 dependencies: struct TFAnmObjF32_3::tagMAIN
class TFAnmObjF32_3
{
public:
	/// 1 namespace types: struct TFAnmObjF32_3::tagMAIN

	// struct TFAnmObjF32_3::tagMAIN
	// no dependencies
	struct tagMAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <Filler, offset 0x0>
		char _Filler[360];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TFAnmObjF32_3::tagMAIN>("TFAnmObjF32_3::tagMAIN")
			.endClass();
		}
#endif
	};
	static_assert(sizeof(struct TFAnmObjF32_3::tagMAIN) == 360, "expected struct TFAnmObjF32_3::tagMAIN to be size 360");


	/// Struct member variables

	// <struct TFAnmObjF32_3::tagMAIN dat, offset 0x0>
	struct TFAnmObjF32_3::tagMAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnmObjF32_3>("TFAnmObjF32_3")
			.addProperty("dat", &TFAnmObjF32_3::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnmObjF32_3::dat) == 360, "expected dat to be size 360");
static_assert(sizeof(class TFAnmObjF32_3) == 360, "expected class TFAnmObjF32_3 to be size 360");

// union _WFAnmVal
// no dependencies
union _WFAnmVal
{
public:
	/// No namespace types
	/// Struct member variables

	// <float mFVal, offset 0x0>
	float mFVal;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<_WFAnmVal>("_WFAnmVal")
			.addProperty("mFVal", &_WFAnmVal::mFVal)
		.endClass();
	}
#endif
};
static_assert(sizeof(_WFAnmVal::mFVal) == 4, "expected mFVal to be size 4");
static_assert(sizeof(union _WFAnmVal) == 4, "expected union _WFAnmVal to be size 4");

// enum TFANMOBJDATATYPE
enum TFANMOBJDATATYPE : uint32_t
{
	// Enum values

	// <TFANMOBJDATATYPE_NONE = 0x0>
	TFANMOBJDATATYPE_NONE = 0,

	// <TFANMOBJDATATYPE_FLOAT = 0x1>
	TFANMOBJDATATYPE_FLOAT = 1,

	// <TFANMOBJDATATYPE_ROT = 0x2>
	TFANMOBJDATATYPE_ROT = 2,

	// <TFANMOBJDATATYPE_BOOL = 0x3>
	TFANMOBJDATATYPE_BOOL = 3,

	// <TFANMOBJDATATYPE_COLOR = 0x4>
	TFANMOBJDATATYPE_COLOR = 4,

	// <TFANMOBJDATATYPE_INT = 0x5>
	TFANMOBJDATATYPE_INT = 5,

	// <TFANMOBJDATATYPE_CALLBACK = 0x6>
	TFANMOBJDATATYPE_CALLBACK = 6,

	// <TFANMOBJDATATYPE_XYZ_POS = 0x7>
	TFANMOBJDATATYPE_XYZ_POS = 7,

	// <TFANMOBJDATATYPE_XYZ_ROT = 0x8>
	TFANMOBJDATATYPE_XYZ_ROT = 8

};

// class TFAnmObj
// 4 dependencies: struct TFAnmObj::tagMAIN, enum TFANMOBJDATATYPE, union _WFAnmVal, struct TFAnmObj::tagGETA
class TFAnmObj
{
public:
	/// 2 namespace types: struct TFAnmObj::tagGETA, struct TFAnmObj::tagMAIN

	// struct TFAnmObj::tagGETA
	// no dependencies
	struct tagGETA
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <float Value, offset 0x0>
		float Value;

		// <float Wait, offset 0x4>
		float Wait;

		// <float LockWait, offset 0x8>
		float LockWait;

		// <float InSlope, offset 0xc>
		float InSlope;

		// <float OutSlope, offset 0x10>
		float OutSlope;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TFAnmObj::tagGETA>("TFAnmObj::tagGETA")
				.addProperty("Value", &TFAnmObj::tagGETA::Value)
				.addProperty("Wait", &TFAnmObj::tagGETA::Wait)
				.addProperty("LockWait", &TFAnmObj::tagGETA::LockWait)
				.addProperty("InSlope", &TFAnmObj::tagGETA::InSlope)
				.addProperty("OutSlope", &TFAnmObj::tagGETA::OutSlope)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnmObj::tagGETA::Value) == 4, "expected Value to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::Wait) == 4, "expected Wait to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::LockWait) == 4, "expected LockWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::InSlope) == 4, "expected InSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagGETA::OutSlope) == 4, "expected OutSlope to be size 4");
	static_assert(sizeof(struct TFAnmObj::tagGETA) == 20, "expected struct TFAnmObj::tagGETA to be size 20");

	// struct TFAnmObj::tagMAIN
	// 3 dependencies: enum TFANMOBJDATATYPE, union _WFAnmVal, struct TFAnmObj::tagGETA
	struct tagMAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <struct _WFAnmObjHeader* pAnmData, offset 0x0>
		struct _WFAnmObjHeader* pAnmData;

		// <enum TFANMOBJDATATYPE DataType, offset 0x4>
		enum TFANMOBJDATATYPE DataType;

		// <void* pData, offset 0x8>
		void* pData;

		// <void (* pCallback)(union _WFAnmVal*, void*), offset 0xc>
		void (* pCallback)(union _WFAnmVal*, void*);

		// <union _WFAnmVal NowValue, offset 0x10>
		union _WFAnmVal NowValue;

		// <uint32_t Flag, offset 0x14>
		uint32_t Flag;

		// <uint8_t NextType, offset 0x18>
		uint8_t NextType;

		// <uint8_t PrevType, offset 0x19>
		uint8_t PrevType;

		// <uint16_t KeyCount, offset 0x1a>
		uint16_t KeyCount;

		// <uint16_t KeyCountMax, offset 0x1c>
		uint16_t KeyCountMax;

		// <uint16_t KeyListCount, offset 0x1e>
		uint16_t KeyListCount;

		// <float Tick, offset 0x20>
		float Tick;

		// <float NextWait, offset 0x24>
		float NextWait;

		// <float PrevWait, offset 0x28>
		float PrevWait;

		// <void* pNextKey, offset 0x2c>
		void* pNextKey;

		// <void* pPrevKey, offset 0x30>
		void* pPrevKey;

		// <float NextValue, offset 0x34>
		float NextValue;

		// <float PrevValue, offset 0x38>
		float PrevValue;

		// <float NextSlope, offset 0x3c>
		float NextSlope;

		// <float PrevSlope, offset 0x40>
		float PrevSlope;

		// <struct TFAnmObj::tagGETA NextGeta, offset 0x44>
		struct tagGETA NextGeta;

		// <struct TFAnmObj::tagGETA PrevGeta, offset 0x58>
		struct tagGETA PrevGeta;

		// <struct _WFAnmObjKeyListHeader* pNowKeyListHeader, offset 0x6c>
		struct _WFAnmObjKeyListHeader* pNowKeyListHeader;

		// <struct TFAnmObj::tagGETA NowKeyGeta, offset 0x70>
		struct tagGETA NowKeyGeta;

		// <uint32_t NowKeyTypeSize, offset 0x84>
		uint32_t NowKeyTypeSize;

		// <void* pNowKey, offset 0x88>
		void* pNowKey;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<TFAnmObj::tagMAIN>("TFAnmObj::tagMAIN")
				.addProperty("pAnmData", &TFAnmObj::tagMAIN::pAnmData)
				.addProperty("DataType", &TFAnmObj::tagMAIN::DataType)
				// void type not supported in LuaBridge
				//.addProperty("pData", &TFAnmObj::tagMAIN::pData)
				// delegates are not supported in LuaBridge
				//.addProperty("pCallback", &TFAnmObj::tagMAIN::pCallback)
				.addProperty("NowValue", &TFAnmObj::tagMAIN::NowValue)
				.addProperty("Flag", &TFAnmObj::tagMAIN::Flag)
				.addProperty("NextType", &TFAnmObj::tagMAIN::NextType)
				.addProperty("PrevType", &TFAnmObj::tagMAIN::PrevType)
				.addProperty("KeyCount", &TFAnmObj::tagMAIN::KeyCount)
				.addProperty("KeyCountMax", &TFAnmObj::tagMAIN::KeyCountMax)
				.addProperty("KeyListCount", &TFAnmObj::tagMAIN::KeyListCount)
				.addProperty("Tick", &TFAnmObj::tagMAIN::Tick)
				.addProperty("NextWait", &TFAnmObj::tagMAIN::NextWait)
				.addProperty("PrevWait", &TFAnmObj::tagMAIN::PrevWait)
				// void type not supported in LuaBridge
				//.addProperty("pNextKey", &TFAnmObj::tagMAIN::pNextKey)
				// void type not supported in LuaBridge
				//.addProperty("pPrevKey", &TFAnmObj::tagMAIN::pPrevKey)
				.addProperty("NextValue", &TFAnmObj::tagMAIN::NextValue)
				.addProperty("PrevValue", &TFAnmObj::tagMAIN::PrevValue)
				.addProperty("NextSlope", &TFAnmObj::tagMAIN::NextSlope)
				.addProperty("PrevSlope", &TFAnmObj::tagMAIN::PrevSlope)
				.addProperty("NextGeta", &TFAnmObj::tagMAIN::NextGeta)
				.addProperty("PrevGeta", &TFAnmObj::tagMAIN::PrevGeta)
				.addProperty("pNowKeyListHeader", &TFAnmObj::tagMAIN::pNowKeyListHeader)
				.addProperty("NowKeyGeta", &TFAnmObj::tagMAIN::NowKeyGeta)
				.addProperty("NowKeyTypeSize", &TFAnmObj::tagMAIN::NowKeyTypeSize)
				// void type not supported in LuaBridge
				//.addProperty("pNowKey", &TFAnmObj::tagMAIN::pNowKey)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(TFAnmObj::tagMAIN::pAnmData) == 4, "expected pAnmData to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::DataType) == 4, "expected DataType to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pData) == 4, "expected pData to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pCallback) == 4, "expected pCallback to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowValue) == 4, "expected NowValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::Flag) == 4, "expected Flag to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextType) == 1, "expected NextType to be size 1");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevType) == 1, "expected PrevType to be size 1");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyCount) == 2, "expected KeyCount to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyCountMax) == 2, "expected KeyCountMax to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::KeyListCount) == 2, "expected KeyListCount to be size 2");
	static_assert(sizeof(TFAnmObj::tagMAIN::Tick) == 4, "expected Tick to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextWait) == 4, "expected NextWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevWait) == 4, "expected PrevWait to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNextKey) == 4, "expected pNextKey to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pPrevKey) == 4, "expected pPrevKey to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextValue) == 4, "expected NextValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevValue) == 4, "expected PrevValue to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextSlope) == 4, "expected NextSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevSlope) == 4, "expected PrevSlope to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NextGeta) == 20, "expected NextGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::PrevGeta) == 20, "expected PrevGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNowKeyListHeader) == 4, "expected pNowKeyListHeader to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowKeyGeta) == 20, "expected NowKeyGeta to be size 20");
	static_assert(sizeof(TFAnmObj::tagMAIN::NowKeyTypeSize) == 4, "expected NowKeyTypeSize to be size 4");
	static_assert(sizeof(TFAnmObj::tagMAIN::pNowKey) == 4, "expected pNowKey to be size 4");
	static_assert(sizeof(struct TFAnmObj::tagMAIN) == 140, "expected struct TFAnmObj::tagMAIN to be size 140");


	/// Struct member variables

	// <struct TFAnmObj::tagMAIN dat, offset 0x0>
	struct TFAnmObj::tagMAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<TFAnmObj>("TFAnmObj")
			.addProperty("dat", &TFAnmObj::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(TFAnmObj::dat) == 140, "expected dat to be size 140");
static_assert(sizeof(class TFAnmObj) == 140, "expected class TFAnmObj to be size 140");

// class mot::IBoneEffectPJ
// no dependencies
namespace mot
{
	class IBoneEffectPJ
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <void* (* field_0)[0x17], offset 0x0>
		void* (* field_0)[0x17];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::IBoneEffectPJ>("mot::IBoneEffectPJ")
				// delegates are not supported in LuaBridge
				//.addProperty("field_0", &mot::IBoneEffectPJ::field_0)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::IBoneEffectPJ::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(class mot::IBoneEffectPJ) == 4, "expected class mot::IBoneEffectPJ to be size 4");

// enum ECameraVibAnimeType
enum ECameraVibAnimeType : uint32_t
{
	// Enum values

	// <CAMERA_VIB_ANIME_TYPE_DAMAGE_HIT = 0x0>
	CAMERA_VIB_ANIME_TYPE_DAMAGE_HIT = 0,

	// <CAMERA_VIB_ANIME_TYPE_DAMAGE_FALL = 0x1>
	CAMERA_VIB_ANIME_TYPE_DAMAGE_FALL = 1,

	// <CAMERA_VIB_ANIME_TYPE_QUAKE = 0x2>
	CAMERA_VIB_ANIME_TYPE_QUAKE = 2,

	// <CAMERA_VIB_ANIME_TYPE_ATTACK = 0x3>
	CAMERA_VIB_ANIME_TYPE_ATTACK = 3,

	// <CAMERA_VIB_ANIME_TYPE_ATTACK_SIDE = 0x4>
	CAMERA_VIB_ANIME_TYPE_ATTACK_SIDE = 4,

	// <CAMERA_VIB_ANIME_TYPE_EXPLOSION = 0x5>
	CAMERA_VIB_ANIME_TYPE_EXPLOSION = 5,

	// <CAMERA_VIB_ANIME_TYPE_EXPLOSION_LONG = 0x6>
	CAMERA_VIB_ANIME_TYPE_EXPLOSION_LONG = 6,

	// <CAMERA_VIB_ANIME_TYPE_SHOCK = 0x7>
	CAMERA_VIB_ANIME_TYPE_SHOCK = 7,

	// <CAMERA_VIB_ANIME_TYPE_SHOCK_SIDE = 0x8>
	CAMERA_VIB_ANIME_TYPE_SHOCK_SIDE = 8,

	// <CAMERA_VIB_ANIME_TYPE_FILM_NOISE = 0x9>
	CAMERA_VIB_ANIME_TYPE_FILM_NOISE = 9,

	// <CAMERA_VIB_ANIME_TYPE_FILM_NOISE2 = 0xa>
	CAMERA_VIB_ANIME_TYPE_FILM_NOISE2 = 10,

	// <CAMERA_VIB_ANIME_TYPE_WIND_PRESS_SIDE = 0xb>
	CAMERA_VIB_ANIME_TYPE_WIND_PRESS_SIDE = 11,

	// <CAMERA_VIB_ANIME_TYPE_CRASH = 0xc>
	CAMERA_VIB_ANIME_TYPE_CRASH = 12,

	// <CAMERA_VIB_ANIME_TYPE_TURN_BANK = 0xd>
	CAMERA_VIB_ANIME_TYPE_TURN_BANK = 13,

	// <TOTAL_CAMERA_VIB_ANIME_TYPE = 0xe>
	TOTAL_CAMERA_VIB_ANIME_TYPE = 14

};

// class CCameraVibTiming
// 1 dependencies: enum ECameraVibAnimeType
class CCameraVibTiming
{
public:
	/// 1 namespace types: class CCameraVibTiming* CCameraVibTiming::getTable(int32_t* arg1, class mHRChara& arg2)

	// TODO: Function 'class CCameraVibTiming* CCameraVibTiming::getTable(int32_t* arg1, class mHRChara& arg2)'

	/// Struct member variables

	// <char const* m_sMotName, offset 0x0>
	char const* m_sMotName;

	// <float m_fMotFrame, offset 0x4>
	float m_fMotFrame;

	// <enum ECameraVibAnimeType m_eAnimeType, offset 0x8>
	enum ECameraVibAnimeType m_eAnimeType;

	// <float m_fAnimeScale, offset 0xc>
	float m_fAnimeScale;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraVibTiming>("CCameraVibTiming")
			.addProperty("m_sMotName", &CCameraVibTiming::m_sMotName)
			.addProperty("m_fMotFrame", &CCameraVibTiming::m_fMotFrame)
			.addProperty("m_eAnimeType", &CCameraVibTiming::m_eAnimeType)
			.addProperty("m_fAnimeScale", &CCameraVibTiming::m_fAnimeScale)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraVibTiming::m_sMotName) == 4, "expected m_sMotName to be size 4");
static_assert(sizeof(CCameraVibTiming::m_fMotFrame) == 4, "expected m_fMotFrame to be size 4");
static_assert(sizeof(CCameraVibTiming::m_eAnimeType) == 4, "expected m_eAnimeType to be size 4");
static_assert(sizeof(CCameraVibTiming::m_fAnimeScale) == 4, "expected m_fAnimeScale to be size 4");
static_assert(sizeof(class CCameraVibTiming) == 16, "expected class CCameraVibTiming to be size 16");

// enum eENVOICE
enum eENVOICE : uint32_t
{
	// Enum values

	// <eENVOICE_A = 0x0>
	eENVOICE_A = 0,

	// <eENVOICE_B = 0x5>
	eENVOICE_B = 5,

	// <eENVOICE_C = 0xa>
	eENVOICE_C = 10,

	// <eENVOICE_D = 0xf>
	eENVOICE_D = 15

};

// struct HRCHARAVOICE
// 1 dependencies: enum eENVOICE
struct HRCHARAVOICE
{
public:
	/// No namespace types
	/// Struct member variables

	// <char const* pFileName, offset 0x0>
	char const* pFileName;

	// <enum eENVOICE Voice, offset 0x4>
	enum eENVOICE Voice;

	// <uint32_t FileNameLength, offset 0x8>
	uint32_t FileNameLength;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HRCHARAVOICE>("HRCHARAVOICE")
			.addProperty("pFileName", &HRCHARAVOICE::pFileName)
			.addProperty("Voice", &HRCHARAVOICE::Voice)
			.addProperty("FileNameLength", &HRCHARAVOICE::FileNameLength)
		.endClass();
	}
#endif
};
static_assert(sizeof(HRCHARAVOICE::pFileName) == 4, "expected pFileName to be size 4");
static_assert(sizeof(HRCHARAVOICE::Voice) == 4, "expected Voice to be size 4");
static_assert(sizeof(HRCHARAVOICE::FileNameLength) == 4, "expected FileNameLength to be size 4");
static_assert(sizeof(struct HRCHARAVOICE) == 12, "expected struct HRCHARAVOICE to be size 12");

// class gameUtil::CPlane
// 4 dependencies: class tiVector, class vector4x, class vector4f, union __m128
namespace gameUtil
{
	class CPlane
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class tiVector m_inABCD, offset 0x0>
		class tiVector m_inABCD;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<gameUtil::CPlane>("gameUtil::CPlane")
				.addProperty("m_inABCD", &gameUtil::CPlane::m_inABCD)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(gameUtil::CPlane::m_inABCD) == 16, "expected m_inABCD to be size 16");
static_assert(sizeof(class gameUtil::CPlane) == 16, "expected class gameUtil::CPlane to be size 16");

// class CStickShadow
// 5 dependencies: class gameUtil::CPlane, class tiVector, class vector4x, class vector4f, union __m128
class CStickShadow
{
public:
	/// No namespace types
	/// Struct member variables

	// <class gameUtil::CPlane m_inProjPlane, offset 0x0>
	class gameUtil::CPlane m_inProjPlane;

	// <int32_t m_nBoneID, offset 0x10>
	int32_t m_nBoneID;

	// <float m_fWidthHalf, offset 0x14>
	float m_fWidthHalf;

	// <float m_fDepthPlus, offset 0x18>
	float m_fDepthPlus;

	// <float m_fDepthMinus, offset 0x1c>
	float m_fDepthMinus;

	// <float m_fAlphaMaxDist, offset 0x20>
	float m_fAlphaMaxDist;

	// <float m_fAlphaMinDist, offset 0x24>
	float m_fAlphaMinDist;

	// <Filler, offset 0x28>
	char _Filler[8];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CStickShadow>("CStickShadow")
			.addProperty("m_inProjPlane", &CStickShadow::m_inProjPlane)
			.addProperty("m_nBoneID", &CStickShadow::m_nBoneID)
			.addProperty("m_fWidthHalf", &CStickShadow::m_fWidthHalf)
			.addProperty("m_fDepthPlus", &CStickShadow::m_fDepthPlus)
			.addProperty("m_fDepthMinus", &CStickShadow::m_fDepthMinus)
			.addProperty("m_fAlphaMaxDist", &CStickShadow::m_fAlphaMaxDist)
			.addProperty("m_fAlphaMinDist", &CStickShadow::m_fAlphaMinDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(CStickShadow::m_inProjPlane) == 16, "expected m_inProjPlane to be size 16");
static_assert(sizeof(CStickShadow::m_nBoneID) == 4, "expected m_nBoneID to be size 4");
static_assert(sizeof(CStickShadow::m_fWidthHalf) == 4, "expected m_fWidthHalf to be size 4");
static_assert(sizeof(CStickShadow::m_fDepthPlus) == 4, "expected m_fDepthPlus to be size 4");
static_assert(sizeof(CStickShadow::m_fDepthMinus) == 4, "expected m_fDepthMinus to be size 4");
static_assert(sizeof(CStickShadow::m_fAlphaMaxDist) == 4, "expected m_fAlphaMaxDist to be size 4");
static_assert(sizeof(CStickShadow::m_fAlphaMinDist) == 4, "expected m_fAlphaMinDist to be size 4");
static_assert(sizeof(class CStickShadow) == 48, "expected class CStickShadow to be size 48");

// struct CharControlMotID
// no dependencies
struct CharControlMotID
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t WalkNeutral, offset 0x0>
	int32_t WalkNeutral;

	// <int32_t WalkFront, offset 0x4>
	int32_t WalkFront;

	// <int32_t WalkBack, offset 0x8>
	int32_t WalkBack;

	// <int32_t WalkSideLeft, offset 0xc>
	int32_t WalkSideLeft;

	// <int32_t WalkSideRight, offset 0x10>
	int32_t WalkSideRight;

	// <int32_t Run, offset 0x14>
	int32_t Run;

	// <int32_t EvacuateBack, offset 0x18>
	int32_t EvacuateBack;

	// <int32_t EvacuateLeft, offset 0x1c>
	int32_t EvacuateLeft;

	// <int32_t EvacuateRight, offset 0x20>
	int32_t EvacuateRight;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CharControlMotID>("CharControlMotID")
			.addProperty("WalkNeutral", &CharControlMotID::WalkNeutral)
			.addProperty("WalkFront", &CharControlMotID::WalkFront)
			.addProperty("WalkBack", &CharControlMotID::WalkBack)
			.addProperty("WalkSideLeft", &CharControlMotID::WalkSideLeft)
			.addProperty("WalkSideRight", &CharControlMotID::WalkSideRight)
			.addProperty("Run", &CharControlMotID::Run)
			.addProperty("EvacuateBack", &CharControlMotID::EvacuateBack)
			.addProperty("EvacuateLeft", &CharControlMotID::EvacuateLeft)
			.addProperty("EvacuateRight", &CharControlMotID::EvacuateRight)
		.endClass();
	}
#endif
};
static_assert(sizeof(CharControlMotID::WalkNeutral) == 4, "expected WalkNeutral to be size 4");
static_assert(sizeof(CharControlMotID::WalkFront) == 4, "expected WalkFront to be size 4");
static_assert(sizeof(CharControlMotID::WalkBack) == 4, "expected WalkBack to be size 4");
static_assert(sizeof(CharControlMotID::WalkSideLeft) == 4, "expected WalkSideLeft to be size 4");
static_assert(sizeof(CharControlMotID::WalkSideRight) == 4, "expected WalkSideRight to be size 4");
static_assert(sizeof(CharControlMotID::Run) == 4, "expected Run to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateBack) == 4, "expected EvacuateBack to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateLeft) == 4, "expected EvacuateLeft to be size 4");
static_assert(sizeof(CharControlMotID::EvacuateRight) == 4, "expected EvacuateRight to be size 4");
static_assert(sizeof(struct CharControlMotID) == 36, "expected struct CharControlMotID to be size 36");

// class CharController
// 3 dependencies: struct CharControlMotID, struct Vec, enum CharController::eChrCntrlMoveMode
class CharController
{
public:
	/// 2 namespace types: enum CharController::eChrCntrlMoveMode, void __convention("thiscall") CharController::CharController(class CharController* const this, class mHRChara* arg2)

	// enum CharController::eChrCntrlMoveMode
	enum eChrCntrlMoveMode : uint32_t
	{
		// Enum values

		// <eChrCntrlMoveMode_WalkSideLeft = 0x0>
		eChrCntrlMoveMode_WalkSideLeft = 0,

		// <eChrCntrlMoveMode_WalkSideRight = 0x1>
		eChrCntrlMoveMode_WalkSideRight = 1,

		// <eChrCntrlMoveMode_WalkForward = 0x2>
		eChrCntrlMoveMode_WalkForward = 2,

		// <eChrCntrlMoveMode_WalkBack = 0x3>
		eChrCntrlMoveMode_WalkBack = 3,

		// <eChrCntrlMoveMode_RunForward = 0x4>
		eChrCntrlMoveMode_RunForward = 4,

		// <eChrCntrlMoveMode_Idle = 0x5>
		eChrCntrlMoveMode_Idle = 5,

		// <eChrCntrlMoveMode_NumMax = 0x6>
		eChrCntrlMoveMode_NumMax = 6

	};

	// TODO: Function 'void __convention("thiscall") CharController::CharController(class CharController* const this, class mHRChara* arg2)'

	/// Struct member variables

	// <uint8_t m_boNowUnderControl, offset 0x0>
	uint8_t m_boNowUnderControl;

	// <uint8_t m_boEnableControl, offset 0x1>
	uint8_t m_boEnableControl;

	// <Filler, offset 0x2>
	char _Filler2[2];

	// <class mHRChara* m_pOwnerChar, offset 0x4>
	class mHRChara* m_pOwnerChar;

	// <struct CharControlMotID m_RegMotID, offset 0x8>
	struct CharControlMotID m_RegMotID;

	// <uint8_t m_boRegistMove, offset 0x2c>
	uint8_t m_boRegistMove;

	// <uint8_t m_boRegistAttack, offset 0x2d>
	uint8_t m_boRegistAttack;

	// <uint8_t m_boLockon, offset 0x2e>
	uint8_t m_boLockon;

	// <Filler, offset 0x2f>
	char _Filler7[1];

	// <struct Vec m_PcDirection, offset 0x30>
	struct Vec m_PcDirection;

	// <struct Vec m_MoveVec, offset 0x3c>
	struct Vec m_MoveVec;

	// <struct Vec m_VecStickL, offset 0x48>
	struct Vec m_VecStickL;

	// <float m_fStickInpRatio, offset 0x54>
	float m_fStickInpRatio;

	// <enum CharController::eChrCntrlMoveMode m_MoveMode, offset 0x58>
	enum CharController::eChrCntrlMoveMode m_MoveMode;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CharController>("CharController")
			.addProperty("m_boNowUnderControl", &CharController::m_boNowUnderControl)
			.addProperty("m_boEnableControl", &CharController::m_boEnableControl)
			.addProperty("m_pOwnerChar", &CharController::m_pOwnerChar)
			.addProperty("m_RegMotID", &CharController::m_RegMotID)
			.addProperty("m_boRegistMove", &CharController::m_boRegistMove)
			.addProperty("m_boRegistAttack", &CharController::m_boRegistAttack)
			.addProperty("m_boLockon", &CharController::m_boLockon)
			.addProperty("m_PcDirection", &CharController::m_PcDirection)
			.addProperty("m_MoveVec", &CharController::m_MoveVec)
			.addProperty("m_VecStickL", &CharController::m_VecStickL)
			.addProperty("m_fStickInpRatio", &CharController::m_fStickInpRatio)
			.addProperty("m_MoveMode", &CharController::m_MoveMode)
		.endClass();
	}
#endif
};
static_assert(sizeof(CharController::m_boNowUnderControl) == 1, "expected m_boNowUnderControl to be size 1");
static_assert(sizeof(CharController::m_boEnableControl) == 1, "expected m_boEnableControl to be size 1");
static_assert(sizeof(CharController::m_pOwnerChar) == 4, "expected m_pOwnerChar to be size 4");
static_assert(sizeof(CharController::m_RegMotID) == 36, "expected m_RegMotID to be size 36");
static_assert(sizeof(CharController::m_boRegistMove) == 1, "expected m_boRegistMove to be size 1");
static_assert(sizeof(CharController::m_boRegistAttack) == 1, "expected m_boRegistAttack to be size 1");
static_assert(sizeof(CharController::m_boLockon) == 1, "expected m_boLockon to be size 1");
static_assert(sizeof(CharController::m_PcDirection) == 12, "expected m_PcDirection to be size 12");
static_assert(sizeof(CharController::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(CharController::m_VecStickL) == 12, "expected m_VecStickL to be size 12");
static_assert(sizeof(CharController::m_fStickInpRatio) == 4, "expected m_fStickInpRatio to be size 4");
static_assert(sizeof(CharController::m_MoveMode) == 4, "expected m_MoveMode to be size 4");
static_assert(sizeof(class CharController) == 92, "expected class CharController to be size 92");

// class CTimeRatioInterpolate
// no dependencies
class CTimeRatioInterpolate
{
public:
	/// No namespace types
	/// Struct member variables

	// <float m_fOneRatioTime, offset 0x0>
	float m_fOneRatioTime;

	// <float m_fRatio, offset 0x4>
	float m_fRatio;

	// <float m_fTimer, offset 0x8>
	float m_fTimer;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CTimeRatioInterpolate>("CTimeRatioInterpolate")
			.addProperty("m_fOneRatioTime", &CTimeRatioInterpolate::m_fOneRatioTime)
			.addProperty("m_fRatio", &CTimeRatioInterpolate::m_fRatio)
			.addProperty("m_fTimer", &CTimeRatioInterpolate::m_fTimer)
		.endClass();
	}
#endif
};
static_assert(sizeof(CTimeRatioInterpolate::m_fOneRatioTime) == 4, "expected m_fOneRatioTime to be size 4");
static_assert(sizeof(CTimeRatioInterpolate::m_fRatio) == 4, "expected m_fRatio to be size 4");
static_assert(sizeof(CTimeRatioInterpolate::m_fTimer) == 4, "expected m_fTimer to be size 4");
static_assert(sizeof(class CTimeRatioInterpolate) == 12, "expected class CTimeRatioInterpolate to be size 12");

// enum enWepChangeProc
enum enWepChangeProc : uint32_t
{
	// Enum values

	// <eWepChangeInit = 0x0>
	eWepChangeInit = 0,

	// <eWepChangeWait = 0x1>
	eWepChangeWait = 1,

	// <eWepChangeMax = 0x2>
	eWepChangeMax = 2

};

// union uniSMflag
// no dependencies
union uniSMflag
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint16_t smBaceActivSubMission, offset 0x0>
	uint16_t smBaceActivSubMission;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<uniSMflag>("uniSMflag")
			.addProperty("smBaceActivSubMission", &uniSMflag::smBaceActivSubMission)
		.endClass();
	}
#endif
};
static_assert(sizeof(uniSMflag::smBaceActivSubMission) == 2, "expected smBaceActivSubMission to be size 2");
static_assert(sizeof(union uniSMflag) == 2, "expected union uniSMflag to be size 2");

// enum enScreenChangeKind
enum enScreenChangeKind : uint32_t
{
	// Enum values

	// <eScreenChangeStencil = 0x0>
	eScreenChangeStencil = 0,

	// <eScreenChangeFade = 0x1>
	eScreenChangeFade = 1,

	// <eScreenChangeMax = 0x2>
	eScreenChangeMax = 2

};

// struct stFade
// 1 dependencies: enum enScreenChangeKind
struct stFade
{
public:
	/// No namespace types
	/// Struct member variables

	// <enum enScreenChangeKind kind, offset 0x0>
	enum enScreenChangeKind kind;

	// <uint8_t requestStart, offset 0x4>
	uint8_t requestStart;

	// <uint8_t requestEnd, offset 0x5>
	uint8_t requestEnd;

	// <Filler, offset 0x6>
	char _Filler3[2];

	// <class HrOverLap* pOverLap, offset 0x8>
	class HrOverLap* pOverLap;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stFade>("stFade")
			.addProperty("kind", &stFade::kind)
			.addProperty("requestStart", &stFade::requestStart)
			.addProperty("requestEnd", &stFade::requestEnd)
			.addProperty("pOverLap", &stFade::pOverLap)
		.endClass();
	}
#endif
};
static_assert(sizeof(stFade::kind) == 4, "expected kind to be size 4");
static_assert(sizeof(stFade::requestStart) == 1, "expected requestStart to be size 1");
static_assert(sizeof(stFade::requestEnd) == 1, "expected requestEnd to be size 1");
static_assert(sizeof(stFade::pOverLap) == 4, "expected pOverLap to be size 4");
static_assert(sizeof(struct stFade) == 12, "expected struct stFade to be size 12");

// class HROBJDummy
// 26 dependencies: class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc
class HROBJDummy : mHRChara
{
public:
	/// No namespace types
	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HROBJDummy>("HROBJDummy")
		.endClass();
	}
#endif
};
static_assert(sizeof(class HROBJDummy) == 1408, "expected class HROBJDummy to be size 1408");

// struct stTiger
// 1 dependencies: struct Vec
struct stTiger
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t visible, offset 0x0>
	uint8_t visible;

	// <Filler, offset 0x1>
	char _Filler1[3];

	// <class TGmf* pGmf, offset 0x4>
	class TGmf* pGmf;

	// <class TGan* pGan[0x8], offset 0x8>
	class TGan* pGan[8];

	// <int32_t motNo, offset 0x28>
	int32_t motNo;

	// <char const* motName, offset 0x2c>
	char const* motName;

	// <uint8_t dispPc, offset 0x30>
	uint8_t dispPc;

	// <uint8_t dispTiger, offset 0x31>
	uint8_t dispTiger;

	// <Filler, offset 0x32>
	char _Filler7[2];

	// <struct Vec startPos, offset 0x34>
	struct Vec startPos;

	// <class CStlVector<CStickShadow> m_ainFootShadow, offset 0x40>
	class std::vector<CStickShadow> m_ainFootShadow;

	// <int32_t endFadeTick, offset 0x4c>
	int32_t endFadeTick;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stTiger>("stTiger")
			.addProperty("visible", &stTiger::visible)
			.addProperty("pGmf", &stTiger::pGmf)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pGan", &stTiger::pGan)
			.addProperty("motNo", &stTiger::motNo)
			.addProperty("motName", &stTiger::motName)
			.addProperty("dispPc", &stTiger::dispPc)
			.addProperty("dispTiger", &stTiger::dispTiger)
			.addProperty("startPos", &stTiger::startPos)
			.addProperty("m_ainFootShadow", &stTiger::m_ainFootShadow)
			.addProperty("endFadeTick", &stTiger::endFadeTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(stTiger::visible) == 1, "expected visible to be size 1");
static_assert(sizeof(stTiger::pGmf) == 4, "expected pGmf to be size 4");
static_assert(sizeof(stTiger::pGan) == 32, "expected pGan to be size 32");
static_assert(sizeof(stTiger::motNo) == 4, "expected motNo to be size 4");
static_assert(sizeof(stTiger::motName) == 4, "expected motName to be size 4");
static_assert(sizeof(stTiger::dispPc) == 1, "expected dispPc to be size 1");
static_assert(sizeof(stTiger::dispTiger) == 1, "expected dispTiger to be size 1");
static_assert(sizeof(stTiger::startPos) == 12, "expected startPos to be size 12");
static_assert(sizeof(stTiger::m_ainFootShadow) == 12, "expected m_ainFootShadow to be size 12");
static_assert(sizeof(stTiger::endFadeTick) == 4, "expected endFadeTick to be size 4");
static_assert(sizeof(struct stTiger) == 80, "expected struct stTiger to be size 80");

// struct stHugWalk
// no dependencies
struct stHugWalk
{
public:
	/// No namespace types
	/// Struct member variables

	// <class TGmf* pGmf, offset 0x0>
	class TGmf* pGmf;

	// <class TGan* pGan[0x6], offset 0x4>
	class TGan* pGan[6];

	// <int32_t motNo, offset 0x1c>
	int32_t motNo;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stHugWalk>("stHugWalk")
			.addProperty("pGmf", &stHugWalk::pGmf)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pGan", &stHugWalk::pGan)
			.addProperty("motNo", &stHugWalk::motNo)
		.endClass();
	}
#endif
};
static_assert(sizeof(stHugWalk::pGmf) == 4, "expected pGmf to be size 4");
static_assert(sizeof(stHugWalk::pGan) == 24, "expected pGan to be size 24");
static_assert(sizeof(stHugWalk::motNo) == 4, "expected motNo to be size 4");
static_assert(sizeof(struct stHugWalk) == 32, "expected struct stHugWalk to be size 32");

// struct stPcEffect
// no dependencies
struct stPcEffect
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[656];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcEffect>("stPcEffect")
		.endClass();
	}
#endif
};
static_assert(sizeof(struct stPcEffect) == 656, "expected struct stPcEffect to be size 656");

// enum enPcInputMode
enum enPcInputMode : uint32_t
{
	// Enum values

	// <ePcInputIdle = 0x0>
	ePcInputIdle = 0,

	// <ePcInputCamera = 0x1>
	ePcInputCamera = 1,

	// <ePcInputMove = 0x2>
	ePcInputMove = 2,

	// <ePcInputBattleMove = 0x3>
	ePcInputBattleMove = 3,

	// <ePcInputBattleIdle = 0x4>
	ePcInputBattleIdle = 4,

	// <ePcInputBike = 0x5>
	ePcInputBike = 5,

	// <ePcInputMenu = 0x6>
	ePcInputMenu = 6,

	// <ePcInputDamage = 0x7>
	ePcInputDamage = 7,

	// <ePcInputTiger = 0x8>
	ePcInputTiger = 8,

	// <ePcInputJump = 0x9>
	ePcInputJump = 9,

	// <ePcInputDash = 0xa>
	ePcInputDash = 10,

	// <ePcInputDigHole = 0xb>
	ePcInputDigHole = 11,

	// <ePcInputWepChange = 0xc>
	ePcInputWepChange = 12,

	// <ePcInputDeadFukki = 0xd>
	ePcInputDeadFukki = 13,

	// <ePcInputMax = 0xe>
	ePcInputMax = 14

};

// enum enSeReadProc
enum enSeReadProc : uint32_t
{
	// Enum values

	// <eSeRead = 0x0>
	eSeRead = 0,

	// <eSeReadWait = 0x1>
	eSeReadWait = 1,

	// <eSeReadMax = 0x2>
	eSeReadMax = 2

};

// struct stPcSndData
// 3 dependencies: enum enSeReadProc, class WAnimF, class WAnim
struct stPcSndData
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t seHdlLightsavorReady, offset 0x0>
	int32_t seHdlLightsavorReady;

	// <float seVolLightsavorReady, offset 0x4>
	float seVolLightsavorReady;

	// <uint8_t seDontPlaySeAgainLSReady, offset 0x8>
	uint8_t seDontPlaySeAgainLSReady;

	// <Filler, offset 0x9>
	char _Filler3[3];

	// <int32_t seHdlSlow, offset 0xc>
	int32_t seHdlSlow;

	// <float oldBgmVol, offset 0x10>
	float oldBgmVol;

	// <int32_t oldBgmHdl, offset 0x14>
	int32_t oldBgmHdl;

	// <int32_t oldBgmNo, offset 0x18>
	int32_t oldBgmNo;

	// <int32_t nowBgmHdl, offset 0x1c>
	int32_t nowBgmHdl;

	// <enum enSeReadProc seReadProc, offset 0x20>
	enum enSeReadProc seReadProc;

	// <class WAnimF pitchBgm, offset 0x24>
	class WAnimF pitchBgm;

	// <uint32_t oldFinishBgmVol, offset 0x44>
	uint32_t oldFinishBgmVol;

	// <uint32_t oldFinishSeVol, offset 0x48>
	uint32_t oldFinishSeVol;

	// <int32_t seHdlCharge, offset 0x4c>
	int32_t seHdlCharge;

	// <class WAnimF pitchCharge, offset 0x50>
	class WAnimF pitchCharge;

	// <int32_t seHdlChargeMax, offset 0x70>
	int32_t seHdlChargeMax;

	// <class WAnimF pitchChargeMax, offset 0x74>
	class WAnimF pitchChargeMax;

	// <int32_t seHdlAlarm, offset 0x94>
	int32_t seHdlAlarm;

	// <int32_t seHdlTel, offset 0x98>
	int32_t seHdlTel;

	// <int32_t seHdlDsBreath, offset 0x9c>
	int32_t seHdlDsBreath;

	// <int32_t seHdlTsubazeri, offset 0xa0>
	int32_t seHdlTsubazeri;

	// <int32_t seHdlSNBElecDmg, offset 0xa4>
	int32_t seHdlSNBElecDmg;

	// <int32_t seHdlPoison, offset 0xa8>
	int32_t seHdlPoison;

	// <uint8_t playBackAttackSe, offset 0xac>
	uint8_t playBackAttackSe;

	// <uint8_t playBackAttackPullSe, offset 0xad>
	uint8_t playBackAttackPullSe;

	// <Filler, offset 0xae>
	char _Filler[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcSndData>("stPcSndData")
			.addProperty("seHdlLightsavorReady", &stPcSndData::seHdlLightsavorReady)
			.addProperty("seVolLightsavorReady", &stPcSndData::seVolLightsavorReady)
			.addProperty("seDontPlaySeAgainLSReady", &stPcSndData::seDontPlaySeAgainLSReady)
			.addProperty("seHdlSlow", &stPcSndData::seHdlSlow)
			.addProperty("oldBgmVol", &stPcSndData::oldBgmVol)
			.addProperty("oldBgmHdl", &stPcSndData::oldBgmHdl)
			.addProperty("oldBgmNo", &stPcSndData::oldBgmNo)
			.addProperty("nowBgmHdl", &stPcSndData::nowBgmHdl)
			.addProperty("seReadProc", &stPcSndData::seReadProc)
			.addProperty("pitchBgm", &stPcSndData::pitchBgm)
			.addProperty("oldFinishBgmVol", &stPcSndData::oldFinishBgmVol)
			.addProperty("oldFinishSeVol", &stPcSndData::oldFinishSeVol)
			.addProperty("seHdlCharge", &stPcSndData::seHdlCharge)
			.addProperty("pitchCharge", &stPcSndData::pitchCharge)
			.addProperty("seHdlChargeMax", &stPcSndData::seHdlChargeMax)
			.addProperty("pitchChargeMax", &stPcSndData::pitchChargeMax)
			.addProperty("seHdlAlarm", &stPcSndData::seHdlAlarm)
			.addProperty("seHdlTel", &stPcSndData::seHdlTel)
			.addProperty("seHdlDsBreath", &stPcSndData::seHdlDsBreath)
			.addProperty("seHdlTsubazeri", &stPcSndData::seHdlTsubazeri)
			.addProperty("seHdlSNBElecDmg", &stPcSndData::seHdlSNBElecDmg)
			.addProperty("seHdlPoison", &stPcSndData::seHdlPoison)
			.addProperty("playBackAttackSe", &stPcSndData::playBackAttackSe)
			.addProperty("playBackAttackPullSe", &stPcSndData::playBackAttackPullSe)
		.endClass();
	}
#endif
};
static_assert(sizeof(stPcSndData::seHdlLightsavorReady) == 4, "expected seHdlLightsavorReady to be size 4");
static_assert(sizeof(stPcSndData::seVolLightsavorReady) == 4, "expected seVolLightsavorReady to be size 4");
static_assert(sizeof(stPcSndData::seDontPlaySeAgainLSReady) == 1, "expected seDontPlaySeAgainLSReady to be size 1");
static_assert(sizeof(stPcSndData::seHdlSlow) == 4, "expected seHdlSlow to be size 4");
static_assert(sizeof(stPcSndData::oldBgmVol) == 4, "expected oldBgmVol to be size 4");
static_assert(sizeof(stPcSndData::oldBgmHdl) == 4, "expected oldBgmHdl to be size 4");
static_assert(sizeof(stPcSndData::oldBgmNo) == 4, "expected oldBgmNo to be size 4");
static_assert(sizeof(stPcSndData::nowBgmHdl) == 4, "expected nowBgmHdl to be size 4");
static_assert(sizeof(stPcSndData::seReadProc) == 4, "expected seReadProc to be size 4");
static_assert(sizeof(stPcSndData::pitchBgm) == 32, "expected pitchBgm to be size 32");
static_assert(sizeof(stPcSndData::oldFinishBgmVol) == 4, "expected oldFinishBgmVol to be size 4");
static_assert(sizeof(stPcSndData::oldFinishSeVol) == 4, "expected oldFinishSeVol to be size 4");
static_assert(sizeof(stPcSndData::seHdlCharge) == 4, "expected seHdlCharge to be size 4");
static_assert(sizeof(stPcSndData::pitchCharge) == 32, "expected pitchCharge to be size 32");
static_assert(sizeof(stPcSndData::seHdlChargeMax) == 4, "expected seHdlChargeMax to be size 4");
static_assert(sizeof(stPcSndData::pitchChargeMax) == 32, "expected pitchChargeMax to be size 32");
static_assert(sizeof(stPcSndData::seHdlAlarm) == 4, "expected seHdlAlarm to be size 4");
static_assert(sizeof(stPcSndData::seHdlTel) == 4, "expected seHdlTel to be size 4");
static_assert(sizeof(stPcSndData::seHdlDsBreath) == 4, "expected seHdlDsBreath to be size 4");
static_assert(sizeof(stPcSndData::seHdlTsubazeri) == 4, "expected seHdlTsubazeri to be size 4");
static_assert(sizeof(stPcSndData::seHdlSNBElecDmg) == 4, "expected seHdlSNBElecDmg to be size 4");
static_assert(sizeof(stPcSndData::seHdlPoison) == 4, "expected seHdlPoison to be size 4");
static_assert(sizeof(stPcSndData::playBackAttackSe) == 1, "expected playBackAttackSe to be size 1");
static_assert(sizeof(stPcSndData::playBackAttackPullSe) == 1, "expected playBackAttackPullSe to be size 1");
static_assert(sizeof(struct stPcSndData) == 176, "expected struct stPcSndData to be size 176");

// struct stDarkSideInfo
// no dependencies
struct stDarkSideInfo
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[52];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stDarkSideInfo>("stDarkSideInfo")
		.endClass();
	}
#endif
};
static_assert(sizeof(struct stDarkSideInfo) == 52, "expected struct stDarkSideInfo to be size 52");

// struct stPcSaveData
// no dependencies
struct stPcSaveData
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[1636];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcSaveData>("stPcSaveData")
		.endClass();
	}
#endif
};
static_assert(sizeof(struct stPcSaveData) == 1636, "expected struct stPcSaveData to be size 1636");

// struct stMiniDemo
// no dependencies
struct stMiniDemo
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t play, offset 0x0>
	uint8_t play;

	// <uint8_t pauseStart, offset 0x1>
	uint8_t pauseStart;

	// <uint8_t fadeInPermission, offset 0x2>
	uint8_t fadeInPermission;

	// <Filler, offset 0x3>
	char _Filler3[1];

	// <int32_t warpWaitFrame, offset 0x4>
	int32_t warpWaitFrame;

	// <int32_t warpTargetIndex, offset 0x8>
	int32_t warpTargetIndex;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stMiniDemo>("stMiniDemo")
			.addProperty("play", &stMiniDemo::play)
			.addProperty("pauseStart", &stMiniDemo::pauseStart)
			.addProperty("fadeInPermission", &stMiniDemo::fadeInPermission)
			.addProperty("warpWaitFrame", &stMiniDemo::warpWaitFrame)
			.addProperty("warpTargetIndex", &stMiniDemo::warpTargetIndex)
		.endClass();
	}
#endif
};
static_assert(sizeof(stMiniDemo::play) == 1, "expected play to be size 1");
static_assert(sizeof(stMiniDemo::pauseStart) == 1, "expected pauseStart to be size 1");
static_assert(sizeof(stMiniDemo::fadeInPermission) == 1, "expected fadeInPermission to be size 1");
static_assert(sizeof(stMiniDemo::warpWaitFrame) == 4, "expected warpWaitFrame to be size 4");
static_assert(sizeof(stMiniDemo::warpTargetIndex) == 4, "expected warpTargetIndex to be size 4");
static_assert(sizeof(struct stMiniDemo) == 12, "expected struct stMiniDemo to be size 12");

// struct stPcStatus
// no dependencies
struct stPcStatus
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[2308];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stPcStatus>("stPcStatus")
		.endClass();
	}
#endif
};
static_assert(sizeof(struct stPcStatus) == 2308, "expected struct stPcStatus to be size 2308");

// class mHRPc
// 42 dependencies: class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, struct stPcStatus, struct stMiniDemo, struct stPcSaveData, struct stDarkSideInfo, struct stPcSndData, enum enSeReadProc, enum enPcInputMode, struct stPcEffect, struct stHugWalk, struct stTiger, class HROBJDummy, struct stFade, enum enScreenChangeKind, union uniSMflag, enum enWepChangeProc, class CTimeRatioInterpolate
class mHRPc : mHRChara
{
public:
	/// 43 namespace types: class mHRChara* __convention("thiscall") mHRPc::mGetTsubaNpc(class mHRPc* const this), class mHRChara* __convention("thiscall") mHRPc::mGetLockOnNpc(class mHRPc* const this), void __convention("thiscall") mHRPc::mSetLastAttackNpc(class mHRPc* const this, class mHRChara* arg2), class mHRChara* __convention("thiscall") mHRPc::mGetLastAttackNpc(class mHRPc* const this), void __convention("thiscall") mHRPc::mSetAttackFromBackNpc(class mHRPc* const this, class mHRChara* arg2), class mHRChara* __convention("thiscall") mHRPc::mGetAttackFromBackNpc(class mHRPc* const this), class mHRChara* __convention("thiscall") mHRPc::mGetLockOnDummyPtr(class mHRPc* const this), class mHRChara* __convention("thiscall") mHRPc::mGetCatchNpc(class mHRPc* const this), uint8_t __convention("thiscall") mHRPc::mTestCanDownAttack(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mCallFightAttackDmgEffect(class mHRPc* const this, class mHRChara* arg2), void __convention("thiscall") mHRPc::mCallNormalAttackEffect(class mHRPc* const this, class mHRChara* arg2), void __convention("thiscall") mHRPc::CreateCutMarkEffect(class mHRPc* const this, class mHRChara* arg2, enum eEfDmgLevel arg3), void __convention("thiscall") mHRPc::mSePlayChargeAttack(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mCallFinishAttackEffect(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mCheckFinishNpc(class mHRPc* const this, class mHRChara* arg2), class mHRChara* __convention("thiscall") mHRPc::mSearchRapidFinishNpc(class mHRPc* const this), uint8_t __convention("thiscall") mHRPc::mCheckResistRapidFinishNpc(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mSetRapidFinishNpc(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mCheckTargetObject(class mHRPc* const this, class mHRChara* arg2), class mHRChara* __convention("thiscall") mHRPc::mSearchAttackTargetNpc(class mHRPc* const this, float arg2, uint8_t arg3), class mHRChara* __convention("thiscall") mHRPc::mSearchDarkSideWarpTargetNpc(class mHRPc* const this), class mHRChara* __convention("thiscall") mHRPc::mSearchNearNpc(class mHRPc* const this, float arg2), class mHRChara* __convention("thiscall") mHRPc::mLookAttackTargetNpc(class mHRPc* const this), class mHRChara* __convention("thiscall") mHRPc::mLockNearNpc(class mHRPc* const this, float arg2, class mHRChara* arg3), class mHRChara* __convention("thiscall") mHRPc::mLockNearCatchNpc(class mHRPc* const this, float arg2, uint8_t arg3), void __convention("thiscall") mHRPc::mAddKillNpcCombo(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mPcMoveFrontOfNpc4DarkSideMode(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mPcMoveFrontOfNpc(class mHRPc* const this, class mHRChara* arg2, uint8_t arg3, int32_t arg4), class mHRChara* __convention("thiscall") mHRPc::mSearchNextNpc(class mHRPc* const this), uint8_t __convention("thiscall") mHRPc::mCheckFinishMode(class mHRPc* const this, class mHRChara* arg2), void __convention("thiscall") mHRPc::mPrepareInputFinish(class mHRPc* const this, class mHRChara* arg2), void __convention("thiscall") mHRPc::mSetIntoTsubazeriai(class mHRPc* const this, class mHRChara* arg2), void __convention("thiscall") mHRPc::mTrvStartDownAttack(class mHRPc* const this, class mHRChara* arg2), int32_t __convention("thiscall") mHRPc::mGetPcThrowMotNo(class mHRPc* const this, enum enThrowDir arg2, class mHRChara* arg3, int32_t* arg4), int32_t __convention("thiscall") mHRPc::mGetThrowDamageMotion(class mHRPc* const this, class mHRChara* arg2, int32_t* arg3), uint8_t __convention("thiscall") mHRPc::mCheckLastTarget(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mStartCatchAttack(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mHitCheck(class mHRPc* const this, class mHRChara* arg2), uint8_t __convention("thiscall") mHRPc::mSetElectricDamage(class mHRPc* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, int32_t arg11), uint8_t __convention("thiscall") mHRPc::mSetDamage(class mHRPc* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), int32_t __convention("thiscall") mHRPc::mConvertGuardMotion(class mHRPc* const this, int32_t arg2, class mHRChara* arg3), void __convention("thiscall") mHRPc::mSetDamageIK(class mHRPc* const this, class mHRChara* arg2, uint8_t arg3), uint8_t __convention("thiscall") mHRPc::mCallAttackEffect(class mHRPc* const this, enum enPcAttackEffect arg2, class mHRChara* arg3, uint8_t arg4, struct Vec* arg5)

	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mGetTsubaNpc(class mHRPc* const this)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mGetLockOnNpc(class mHRPc* const this)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mSetLastAttackNpc(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mGetLastAttackNpc(class mHRPc* const this)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mSetAttackFromBackNpc(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mGetAttackFromBackNpc(class mHRPc* const this)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mGetLockOnDummyPtr(class mHRPc* const this)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mGetCatchNpc(class mHRPc* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mTestCanDownAttack(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mCallFightAttackDmgEffect(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mCallNormalAttackEffect(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRPc::CreateCutMarkEffect(class mHRPc* const this, class mHRChara* arg2, enum eEfDmgLevel arg3)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mSePlayChargeAttack(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mCallFinishAttackEffect(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mCheckFinishNpc(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mSearchRapidFinishNpc(class mHRPc* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mCheckResistRapidFinishNpc(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mSetRapidFinishNpc(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mCheckTargetObject(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mSearchAttackTargetNpc(class mHRPc* const this, float arg2, uint8_t arg3)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mSearchDarkSideWarpTargetNpc(class mHRPc* const this)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mSearchNearNpc(class mHRPc* const this, float arg2)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mLookAttackTargetNpc(class mHRPc* const this)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mLockNearNpc(class mHRPc* const this, float arg2, class mHRChara* arg3)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mLockNearCatchNpc(class mHRPc* const this, float arg2, uint8_t arg3)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mAddKillNpcCombo(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mPcMoveFrontOfNpc4DarkSideMode(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mPcMoveFrontOfNpc(class mHRPc* const this, class mHRChara* arg2, uint8_t arg3, int32_t arg4)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRPc::mSearchNextNpc(class mHRPc* const this)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mCheckFinishMode(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mPrepareInputFinish(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mSetIntoTsubazeriai(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mTrvStartDownAttack(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'int32_t __convention("thiscall") mHRPc::mGetPcThrowMotNo(class mHRPc* const this, enum enThrowDir arg2, class mHRChara* arg3, int32_t* arg4)'
	// TODO: Function 'int32_t __convention("thiscall") mHRPc::mGetThrowDamageMotion(class mHRPc* const this, class mHRChara* arg2, int32_t* arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mCheckLastTarget(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mStartCatchAttack(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mHitCheck(class mHRPc* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mSetElectricDamage(class mHRPc* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, int32_t arg11)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mSetDamage(class mHRPc* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// TODO: Function 'int32_t __convention("thiscall") mHRPc::mConvertGuardMotion(class mHRPc* const this, int32_t arg2, class mHRChara* arg3)'
	// TODO: Function 'void __convention("thiscall") mHRPc::mSetDamageIK(class mHRPc* const this, class mHRChara* arg2, uint8_t arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRPc::mCallAttackEffect(class mHRPc* const this, enum enPcAttackEffect arg2, class mHRChara* arg3, uint8_t arg4, struct Vec* arg5)'

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <int32_t mEscapeActionInit, offset 0x580>
	int32_t mEscapeActionInit;

	// <struct stPcStatus mPcStatus, offset 0x584>
	struct stPcStatus mPcStatus;

	// <struct stMiniDemo mMiniDemo, offset 0xe88>
	struct stMiniDemo mMiniDemo;

	// <struct stPcSaveData mPcSaveData, offset 0xe94>
	struct stPcSaveData mPcSaveData;

	// <struct stDarkSideInfo mDarkSideInfo, offset 0x14f8>
	struct stDarkSideInfo mDarkSideInfo;

	// <class mHRBike* mpBike, offset 0x152c>
	class mHRBike* mpBike;

	// <struct stPcSndData mSnd, offset 0x1530>
	struct stPcSndData mSnd;

	// <enum enPcInputMode mInputMode, offset 0x15e0>
	enum enPcInputMode mInputMode;

	// <enum enPcInputMode mInputModeOld, offset 0x15e4>
	enum enPcInputMode mInputModeOld;

	// <enum enPcInputMode mInputModeBefore, offset 0x15e8>
	enum enPcInputMode mInputModeBefore;

	// <uint8_t mPauseAll, offset 0x15ec>
	uint8_t mPauseAll;

	// <uint8_t mPauseNpc, offset 0x15ed>
	uint8_t mPauseNpc;

	// <uint8_t mOperate, offset 0x15ee>
	uint8_t mOperate;

	// <uint8_t mOnlyMove, offset 0x15ef>
	uint8_t mOnlyMove;

	// <uint8_t mMotSpdAdj, offset 0x15f0>
	uint8_t mMotSpdAdj;

	// <uint8_t mDead, offset 0x15f1>
	uint8_t mDead;

	// <uint8_t mDeadPause, offset 0x15f2>
	uint8_t mDeadPause;

	// <uint8_t mCameraOperate, offset 0x15f3>
	uint8_t mCameraOperate;

	// <uint8_t mBattouDemoRequest, offset 0x15f4>
	uint8_t mBattouDemoRequest;

	// <uint8_t mStageChangeInitEnd, offset 0x15f5>
	uint8_t mStageChangeInitEnd;

	// <uint8_t mStageChangeTermEnd, offset 0x15f6>
	uint8_t mStageChangeTermEnd;

	// <uint8_t mStageChangeMuteki, offset 0x15f7>
	uint8_t mStageChangeMuteki;

	// <uint8_t mBanStatusScreen, offset 0x15f8>
	uint8_t mBanStatusScreen;

	// <Filler, offset 0x15f9>
	char _Filler24[3];

	// <int32_t mAtkPauseTime, offset 0x15fc>
	int32_t mAtkPauseTime;

	// <int32_t mStopRenderFrameNum, offset 0x1600>
	int32_t mStopRenderFrameNum;

	// <int32_t mWait1Frame, offset 0x1604>
	int32_t mWait1Frame;

	// <struct stPcEffect mPcEffect, offset 0x1608>
	struct stPcEffect mPcEffect;

	// <struct stHugWalk mPcHug, offset 0x1898>
	struct stHugWalk mPcHug;

	// <struct stTiger mTiger, offset 0x18b8>
	struct stTiger mTiger;

	// <struct Vec mLockOnPos, offset 0x1908>
	struct Vec mLockOnPos;

	// <class mHRChara* mpLockOnNpc, offset 0x1914>
	class mHRChara* mpLockOnNpc;

	// <class mHRChara* mpTsubaNpc, offset 0x1918>
	class mHRChara* mpTsubaNpc;

	// <class mHRChara* mpCatchNpc, offset 0x191c>
	class mHRChara* mpCatchNpc;

	// <class mHRChara* mpCatchReserveNpc, offset 0x1920>
	class mHRChara* mpCatchReserveNpc;

	// <class mHRChara* mpEscapeNpc, offset 0x1924>
	class mHRChara* mpEscapeNpc;

	// <class mHRChara* mpInitFinishNpc, offset 0x1928>
	class mHRChara* mpInitFinishNpc;

	// <class mHRChara* mpNextFinishNpc, offset 0x192c>
	class mHRChara* mpNextFinishNpc;

	// <class mHRChara* mpFinishNpc[0x8], offset 0x1930>
	class mHRChara* mpFinishNpc[8];

	// <class mHRChara* mpFinishReserveNpc, offset 0x1950>
	class mHRChara* mpFinishReserveNpc;

	// <class mHRChara* mpDSTargetNpc, offset 0x1954>
	class mHRChara* mpDSTargetNpc;

	// <class mHRChara* mpDwnAtkNpc, offset 0x1958>
	class mHRChara* mpDwnAtkNpc;

	// <class mHRChara* mpLastAtkNpc, offset 0x195c>
	class mHRChara* mpLastAtkNpc;

	// <class mHRChara* mpAttackFromBackNpc, offset 0x1960>
	class mHRChara* mpAttackFromBackNpc;

	// <class HROBJDummy mLockOnDummy, offset 0x1964>
	class HROBJDummy mLockOnDummy;

	// <uint8_t mSavehitOidashiDisEnable, offset 0x1ee4>
	uint8_t mSavehitOidashiDisEnable;

	// <Filler, offset 0x1ee5>
	char _Filler46[3];

	// <int32_t mSlowMotionSytemMotNo, offset 0x1ee8>
	int32_t mSlowMotionSytemMotNo;

	// <int32_t mSlowMotionSytemButton, offset 0x1eec>
	int32_t mSlowMotionSytemButton;

	// <class ghmTriangle mWepCollL, offset 0x1ef0>
	class ghmTriangle mWepCollL;

	// <class ghmTriangle* m_pAttackHitTriangle, offset 0x1f14>
	class ghmTriangle* m_pAttackHitTriangle;

	// <struct stFade mFade, offset 0x1f18>
	struct stFade mFade;

	// <union uniSMflag mSubMissionflag, offset 0x1f24>
	union uniSMflag mSubMissionflag;

	// <uint8_t mSubMissionPcPosStoreFlag, offset 0x1f26>
	uint8_t mSubMissionPcPosStoreFlag;

	// <Filler, offset 0x1f27>
	char _Filler53[1];

	// <struct Vec mSubMissionStorePos, offset 0x1f28>
	struct Vec mSubMissionStorePos;

	// <struct Vec mSubMissionStoreRot, offset 0x1f34>
	struct Vec mSubMissionStoreRot;

	// <uint8_t mSubMissionBikePosStoreFlag, offset 0x1f40>
	uint8_t mSubMissionBikePosStoreFlag;

	// <Filler, offset 0x1f41>
	char _Filler56[3];

	// <struct Vec mSubMissionStoreBikePos, offset 0x1f44>
	struct Vec mSubMissionStoreBikePos;

	// <struct Vec mSubMissionStoreBikeRot, offset 0x1f50>
	struct Vec mSubMissionStoreBikeRot;

	// <class EventAreaCamera* mpSubMissionJumpCameraHandle, offset 0x1f5c>
	class EventAreaCamera* mpSubMissionJumpCameraHandle;

	// <int32_t mDisEnableBtlPoseCalc, offset 0x1f60>
	int32_t mDisEnableBtlPoseCalc;

	// <uint8_t mTamePush, offset 0x1f64>
	uint8_t mTamePush;

	// <uint8_t mTameMax, offset 0x1f65>
	uint8_t mTameMax;

	// <uint8_t mTameSe, offset 0x1f66>
	uint8_t mTameSe;

	// <Filler, offset 0x1f67>
	char _Filler63[1];

	// <int32_t mDigAction, offset 0x1f68>
	int32_t mDigAction;

	// <enum enWepChangeProc mChangeWepProc, offset 0x1f6c>
	enum enWepChangeProc mChangeWepProc;

	// <int32_t mChangeWepKind, offset 0x1f70>
	int32_t mChangeWepKind;

	// <int32_t mMenuDisEnableFrame, offset 0x1f74>
	int32_t mMenuDisEnableFrame;

	// <char const* m_sMotName, offset 0x1f78>
	char const* m_sMotName;

	// <char const* m_sPreMotName, offset 0x1f7c>
	char const* m_sPreMotName;

	// <char m_sOutMotName[0x10], offset 0x1f80>
	char m_sOutMotName[16];

	// <uint8_t m_bIsBootStageHitEffect, offset 0x1f90>
	uint8_t m_bIsBootStageHitEffect;

	// <Filler, offset 0x1f91>
	char _Filler71[3];

	// <struct Vec m_inPreWeaponTopPosi, offset 0x1f94>
	struct Vec m_inPreWeaponTopPosi;

	// <uint8_t m_bIsPreTigerVisible, offset 0x1fa0>
	uint8_t m_bIsPreTigerVisible;

	// <uint8_t m_bIsPreFinishAttack, offset 0x1fa1>
	uint8_t m_bIsPreFinishAttack;

	// <uint8_t m_bIsBeginFinishAttack, offset 0x1fa2>
	uint8_t m_bIsBeginFinishAttack;

	// <uint8_t m_bIsPlayCamBankMotion, offset 0x1fa3>
	uint8_t m_bIsPlayCamBankMotion;

	// <class CTimeRatioInterpolate m_inWeaponLengthRatio, offset 0x1fa4>
	class CTimeRatioInterpolate m_inWeaponLengthRatio;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRPc>("mHRPc")
			.addProperty("mEscapeActionInit", &mHRPc::mEscapeActionInit)
			.addProperty("mPcStatus", &mHRPc::mPcStatus)
			.addProperty("mMiniDemo", &mHRPc::mMiniDemo)
			.addProperty("mPcSaveData", &mHRPc::mPcSaveData)
			.addProperty("mDarkSideInfo", &mHRPc::mDarkSideInfo)
			.addProperty("mpBike", &mHRPc::mpBike)
			.addProperty("mSnd", &mHRPc::mSnd)
			.addProperty("mInputMode", &mHRPc::mInputMode)
			.addProperty("mInputModeOld", &mHRPc::mInputModeOld)
			.addProperty("mInputModeBefore", &mHRPc::mInputModeBefore)
			.addProperty("mPauseAll", &mHRPc::mPauseAll)
			.addProperty("mPauseNpc", &mHRPc::mPauseNpc)
			.addProperty("mOperate", &mHRPc::mOperate)
			.addProperty("mOnlyMove", &mHRPc::mOnlyMove)
			.addProperty("mMotSpdAdj", &mHRPc::mMotSpdAdj)
			.addProperty("mDead", &mHRPc::mDead)
			.addProperty("mDeadPause", &mHRPc::mDeadPause)
			.addProperty("mCameraOperate", &mHRPc::mCameraOperate)
			.addProperty("mBattouDemoRequest", &mHRPc::mBattouDemoRequest)
			.addProperty("mStageChangeInitEnd", &mHRPc::mStageChangeInitEnd)
			.addProperty("mStageChangeTermEnd", &mHRPc::mStageChangeTermEnd)
			.addProperty("mStageChangeMuteki", &mHRPc::mStageChangeMuteki)
			.addProperty("mBanStatusScreen", &mHRPc::mBanStatusScreen)
			.addProperty("mAtkPauseTime", &mHRPc::mAtkPauseTime)
			.addProperty("mStopRenderFrameNum", &mHRPc::mStopRenderFrameNum)
			.addProperty("mWait1Frame", &mHRPc::mWait1Frame)
			.addProperty("mPcEffect", &mHRPc::mPcEffect)
			.addProperty("mPcHug", &mHRPc::mPcHug)
			.addProperty("mTiger", &mHRPc::mTiger)
			.addProperty("mLockOnPos", &mHRPc::mLockOnPos)
			.addProperty("mpLockOnNpc", &mHRPc::mpLockOnNpc)
			.addProperty("mpTsubaNpc", &mHRPc::mpTsubaNpc)
			.addProperty("mpCatchNpc", &mHRPc::mpCatchNpc)
			.addProperty("mpCatchReserveNpc", &mHRPc::mpCatchReserveNpc)
			.addProperty("mpEscapeNpc", &mHRPc::mpEscapeNpc)
			.addProperty("mpInitFinishNpc", &mHRPc::mpInitFinishNpc)
			.addProperty("mpNextFinishNpc", &mHRPc::mpNextFinishNpc)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpFinishNpc", &mHRPc::mpFinishNpc)
			.addProperty("mpFinishReserveNpc", &mHRPc::mpFinishReserveNpc)
			.addProperty("mpDSTargetNpc", &mHRPc::mpDSTargetNpc)
			.addProperty("mpDwnAtkNpc", &mHRPc::mpDwnAtkNpc)
			.addProperty("mpLastAtkNpc", &mHRPc::mpLastAtkNpc)
			.addProperty("mpAttackFromBackNpc", &mHRPc::mpAttackFromBackNpc)
			.addProperty("mLockOnDummy", &mHRPc::mLockOnDummy)
			.addProperty("mSavehitOidashiDisEnable", &mHRPc::mSavehitOidashiDisEnable)
			.addProperty("mSlowMotionSytemMotNo", &mHRPc::mSlowMotionSytemMotNo)
			.addProperty("mSlowMotionSytemButton", &mHRPc::mSlowMotionSytemButton)
			.addProperty("mWepCollL", &mHRPc::mWepCollL)
			.addProperty("m_pAttackHitTriangle", &mHRPc::m_pAttackHitTriangle)
			.addProperty("mFade", &mHRPc::mFade)
			.addProperty("mSubMissionflag", &mHRPc::mSubMissionflag)
			.addProperty("mSubMissionPcPosStoreFlag", &mHRPc::mSubMissionPcPosStoreFlag)
			.addProperty("mSubMissionStorePos", &mHRPc::mSubMissionStorePos)
			.addProperty("mSubMissionStoreRot", &mHRPc::mSubMissionStoreRot)
			.addProperty("mSubMissionBikePosStoreFlag", &mHRPc::mSubMissionBikePosStoreFlag)
			.addProperty("mSubMissionStoreBikePos", &mHRPc::mSubMissionStoreBikePos)
			.addProperty("mSubMissionStoreBikeRot", &mHRPc::mSubMissionStoreBikeRot)
			.addProperty("mpSubMissionJumpCameraHandle", &mHRPc::mpSubMissionJumpCameraHandle)
			.addProperty("mDisEnableBtlPoseCalc", &mHRPc::mDisEnableBtlPoseCalc)
			.addProperty("mTamePush", &mHRPc::mTamePush)
			.addProperty("mTameMax", &mHRPc::mTameMax)
			.addProperty("mTameSe", &mHRPc::mTameSe)
			.addProperty("mDigAction", &mHRPc::mDigAction)
			.addProperty("mChangeWepProc", &mHRPc::mChangeWepProc)
			.addProperty("mChangeWepKind", &mHRPc::mChangeWepKind)
			.addProperty("mMenuDisEnableFrame", &mHRPc::mMenuDisEnableFrame)
			.addProperty("m_sMotName", &mHRPc::m_sMotName)
			.addProperty("m_sPreMotName", &mHRPc::m_sPreMotName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_sOutMotName", &mHRPc::m_sOutMotName)
			.addProperty("m_bIsBootStageHitEffect", &mHRPc::m_bIsBootStageHitEffect)
			.addProperty("m_inPreWeaponTopPosi", &mHRPc::m_inPreWeaponTopPosi)
			.addProperty("m_bIsPreTigerVisible", &mHRPc::m_bIsPreTigerVisible)
			.addProperty("m_bIsPreFinishAttack", &mHRPc::m_bIsPreFinishAttack)
			.addProperty("m_bIsBeginFinishAttack", &mHRPc::m_bIsBeginFinishAttack)
			.addProperty("m_bIsPlayCamBankMotion", &mHRPc::m_bIsPlayCamBankMotion)
			.addProperty("m_inWeaponLengthRatio", &mHRPc::m_inWeaponLengthRatio)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRPc::mEscapeActionInit) == 4, "expected mEscapeActionInit to be size 4");
static_assert(sizeof(mHRPc::mPcStatus) == 2308, "expected mPcStatus to be size 2308");
static_assert(sizeof(mHRPc::mMiniDemo) == 12, "expected mMiniDemo to be size 12");
static_assert(sizeof(mHRPc::mPcSaveData) == 1636, "expected mPcSaveData to be size 1636");
static_assert(sizeof(mHRPc::mDarkSideInfo) == 52, "expected mDarkSideInfo to be size 52");
static_assert(sizeof(mHRPc::mpBike) == 4, "expected mpBike to be size 4");
static_assert(sizeof(mHRPc::mSnd) == 176, "expected mSnd to be size 176");
static_assert(sizeof(mHRPc::mInputMode) == 4, "expected mInputMode to be size 4");
static_assert(sizeof(mHRPc::mInputModeOld) == 4, "expected mInputModeOld to be size 4");
static_assert(sizeof(mHRPc::mInputModeBefore) == 4, "expected mInputModeBefore to be size 4");
static_assert(sizeof(mHRPc::mPauseAll) == 1, "expected mPauseAll to be size 1");
static_assert(sizeof(mHRPc::mPauseNpc) == 1, "expected mPauseNpc to be size 1");
static_assert(sizeof(mHRPc::mOperate) == 1, "expected mOperate to be size 1");
static_assert(sizeof(mHRPc::mOnlyMove) == 1, "expected mOnlyMove to be size 1");
static_assert(sizeof(mHRPc::mMotSpdAdj) == 1, "expected mMotSpdAdj to be size 1");
static_assert(sizeof(mHRPc::mDead) == 1, "expected mDead to be size 1");
static_assert(sizeof(mHRPc::mDeadPause) == 1, "expected mDeadPause to be size 1");
static_assert(sizeof(mHRPc::mCameraOperate) == 1, "expected mCameraOperate to be size 1");
static_assert(sizeof(mHRPc::mBattouDemoRequest) == 1, "expected mBattouDemoRequest to be size 1");
static_assert(sizeof(mHRPc::mStageChangeInitEnd) == 1, "expected mStageChangeInitEnd to be size 1");
static_assert(sizeof(mHRPc::mStageChangeTermEnd) == 1, "expected mStageChangeTermEnd to be size 1");
static_assert(sizeof(mHRPc::mStageChangeMuteki) == 1, "expected mStageChangeMuteki to be size 1");
static_assert(sizeof(mHRPc::mBanStatusScreen) == 1, "expected mBanStatusScreen to be size 1");
static_assert(sizeof(mHRPc::mAtkPauseTime) == 4, "expected mAtkPauseTime to be size 4");
static_assert(sizeof(mHRPc::mStopRenderFrameNum) == 4, "expected mStopRenderFrameNum to be size 4");
static_assert(sizeof(mHRPc::mWait1Frame) == 4, "expected mWait1Frame to be size 4");
static_assert(sizeof(mHRPc::mPcEffect) == 656, "expected mPcEffect to be size 656");
static_assert(sizeof(mHRPc::mPcHug) == 32, "expected mPcHug to be size 32");
static_assert(sizeof(mHRPc::mTiger) == 80, "expected mTiger to be size 80");
static_assert(sizeof(mHRPc::mLockOnPos) == 12, "expected mLockOnPos to be size 12");
static_assert(sizeof(mHRPc::mpLockOnNpc) == 4, "expected mpLockOnNpc to be size 4");
static_assert(sizeof(mHRPc::mpTsubaNpc) == 4, "expected mpTsubaNpc to be size 4");
static_assert(sizeof(mHRPc::mpCatchNpc) == 4, "expected mpCatchNpc to be size 4");
static_assert(sizeof(mHRPc::mpCatchReserveNpc) == 4, "expected mpCatchReserveNpc to be size 4");
static_assert(sizeof(mHRPc::mpEscapeNpc) == 4, "expected mpEscapeNpc to be size 4");
static_assert(sizeof(mHRPc::mpInitFinishNpc) == 4, "expected mpInitFinishNpc to be size 4");
static_assert(sizeof(mHRPc::mpNextFinishNpc) == 4, "expected mpNextFinishNpc to be size 4");
static_assert(sizeof(mHRPc::mpFinishNpc) == 32, "expected mpFinishNpc to be size 32");
static_assert(sizeof(mHRPc::mpFinishReserveNpc) == 4, "expected mpFinishReserveNpc to be size 4");
static_assert(sizeof(mHRPc::mpDSTargetNpc) == 4, "expected mpDSTargetNpc to be size 4");
static_assert(sizeof(mHRPc::mpDwnAtkNpc) == 4, "expected mpDwnAtkNpc to be size 4");
static_assert(sizeof(mHRPc::mpLastAtkNpc) == 4, "expected mpLastAtkNpc to be size 4");
static_assert(sizeof(mHRPc::mpAttackFromBackNpc) == 4, "expected mpAttackFromBackNpc to be size 4");
static_assert(sizeof(mHRPc::mLockOnDummy) == 1408, "expected mLockOnDummy to be size 1408");
static_assert(sizeof(mHRPc::mSavehitOidashiDisEnable) == 1, "expected mSavehitOidashiDisEnable to be size 1");
static_assert(sizeof(mHRPc::mSlowMotionSytemMotNo) == 4, "expected mSlowMotionSytemMotNo to be size 4");
static_assert(sizeof(mHRPc::mSlowMotionSytemButton) == 4, "expected mSlowMotionSytemButton to be size 4");
static_assert(sizeof(mHRPc::mWepCollL) == 36, "expected mWepCollL to be size 36");
static_assert(sizeof(mHRPc::m_pAttackHitTriangle) == 4, "expected m_pAttackHitTriangle to be size 4");
static_assert(sizeof(mHRPc::mFade) == 12, "expected mFade to be size 12");
static_assert(sizeof(mHRPc::mSubMissionflag) == 2, "expected mSubMissionflag to be size 2");
static_assert(sizeof(mHRPc::mSubMissionPcPosStoreFlag) == 1, "expected mSubMissionPcPosStoreFlag to be size 1");
static_assert(sizeof(mHRPc::mSubMissionStorePos) == 12, "expected mSubMissionStorePos to be size 12");
static_assert(sizeof(mHRPc::mSubMissionStoreRot) == 12, "expected mSubMissionStoreRot to be size 12");
static_assert(sizeof(mHRPc::mSubMissionBikePosStoreFlag) == 1, "expected mSubMissionBikePosStoreFlag to be size 1");
static_assert(sizeof(mHRPc::mSubMissionStoreBikePos) == 12, "expected mSubMissionStoreBikePos to be size 12");
static_assert(sizeof(mHRPc::mSubMissionStoreBikeRot) == 12, "expected mSubMissionStoreBikeRot to be size 12");
static_assert(sizeof(mHRPc::mpSubMissionJumpCameraHandle) == 4, "expected mpSubMissionJumpCameraHandle to be size 4");
static_assert(sizeof(mHRPc::mDisEnableBtlPoseCalc) == 4, "expected mDisEnableBtlPoseCalc to be size 4");
static_assert(sizeof(mHRPc::mTamePush) == 1, "expected mTamePush to be size 1");
static_assert(sizeof(mHRPc::mTameMax) == 1, "expected mTameMax to be size 1");
static_assert(sizeof(mHRPc::mTameSe) == 1, "expected mTameSe to be size 1");
static_assert(sizeof(mHRPc::mDigAction) == 4, "expected mDigAction to be size 4");
static_assert(sizeof(mHRPc::mChangeWepProc) == 4, "expected mChangeWepProc to be size 4");
static_assert(sizeof(mHRPc::mChangeWepKind) == 4, "expected mChangeWepKind to be size 4");
static_assert(sizeof(mHRPc::mMenuDisEnableFrame) == 4, "expected mMenuDisEnableFrame to be size 4");
static_assert(sizeof(mHRPc::m_sMotName) == 4, "expected m_sMotName to be size 4");
static_assert(sizeof(mHRPc::m_sPreMotName) == 4, "expected m_sPreMotName to be size 4");
static_assert(sizeof(mHRPc::m_sOutMotName) == 16, "expected m_sOutMotName to be size 16");
static_assert(sizeof(mHRPc::m_bIsBootStageHitEffect) == 1, "expected m_bIsBootStageHitEffect to be size 1");
static_assert(sizeof(mHRPc::m_inPreWeaponTopPosi) == 12, "expected m_inPreWeaponTopPosi to be size 12");
static_assert(sizeof(mHRPc::m_bIsPreTigerVisible) == 1, "expected m_bIsPreTigerVisible to be size 1");
static_assert(sizeof(mHRPc::m_bIsPreFinishAttack) == 1, "expected m_bIsPreFinishAttack to be size 1");
static_assert(sizeof(mHRPc::m_bIsBeginFinishAttack) == 1, "expected m_bIsBeginFinishAttack to be size 1");
static_assert(sizeof(mHRPc::m_bIsPlayCamBankMotion) == 1, "expected m_bIsPlayCamBankMotion to be size 1");
static_assert(sizeof(mHRPc::m_inWeaponLengthRatio) == 12, "expected m_inWeaponLengthRatio to be size 12");
static_assert(sizeof(class mHRPc) == 8112, "expected class mHRPc to be size 8112");

// class CObjectShadow
// 6 dependencies: struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT
class CObjectShadow
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct tagGHMR_TEX m_inUpTex, offset 0x0>
	struct tagGHMR_TEX m_inUpTex;

	// <struct tagGHMR_TEX m_inSideTex, offset 0x28>
	struct tagGHMR_TEX m_inSideTex;

	// <float m_fGroundOfst, offset 0x50>
	float m_fGroundOfst;

	// <float m_fUpWidthHalf, offset 0x54>
	float m_fUpWidthHalf;

	// <float m_fSideWidthHalfMax, offset 0x58>
	float m_fSideWidthHalfMax;

	// <float m_fSideWidthHalfMin, offset 0x5c>
	float m_fSideWidthHalfMin;

	// <float m_fDepthPlus, offset 0x60>
	float m_fDepthPlus;

	// <float m_fDepthMinus, offset 0x64>
	float m_fDepthMinus;

	// <float m_fDepthOfstMax, offset 0x68>
	float m_fDepthOfstMax;

	// <float m_fAlphaMulCoe, offset 0x6c>
	float m_fAlphaMulCoe;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CObjectShadow>("CObjectShadow")
			.addProperty("m_inUpTex", &CObjectShadow::m_inUpTex)
			.addProperty("m_inSideTex", &CObjectShadow::m_inSideTex)
			.addProperty("m_fGroundOfst", &CObjectShadow::m_fGroundOfst)
			.addProperty("m_fUpWidthHalf", &CObjectShadow::m_fUpWidthHalf)
			.addProperty("m_fSideWidthHalfMax", &CObjectShadow::m_fSideWidthHalfMax)
			.addProperty("m_fSideWidthHalfMin", &CObjectShadow::m_fSideWidthHalfMin)
			.addProperty("m_fDepthPlus", &CObjectShadow::m_fDepthPlus)
			.addProperty("m_fDepthMinus", &CObjectShadow::m_fDepthMinus)
			.addProperty("m_fDepthOfstMax", &CObjectShadow::m_fDepthOfstMax)
			.addProperty("m_fAlphaMulCoe", &CObjectShadow::m_fAlphaMulCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CObjectShadow::m_inUpTex) == 40, "expected m_inUpTex to be size 40");
static_assert(sizeof(CObjectShadow::m_inSideTex) == 40, "expected m_inSideTex to be size 40");
static_assert(sizeof(CObjectShadow::m_fGroundOfst) == 4, "expected m_fGroundOfst to be size 4");
static_assert(sizeof(CObjectShadow::m_fUpWidthHalf) == 4, "expected m_fUpWidthHalf to be size 4");
static_assert(sizeof(CObjectShadow::m_fSideWidthHalfMax) == 4, "expected m_fSideWidthHalfMax to be size 4");
static_assert(sizeof(CObjectShadow::m_fSideWidthHalfMin) == 4, "expected m_fSideWidthHalfMin to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthPlus) == 4, "expected m_fDepthPlus to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthMinus) == 4, "expected m_fDepthMinus to be size 4");
static_assert(sizeof(CObjectShadow::m_fDepthOfstMax) == 4, "expected m_fDepthOfstMax to be size 4");
static_assert(sizeof(CObjectShadow::m_fAlphaMulCoe) == 4, "expected m_fAlphaMulCoe to be size 4");
static_assert(sizeof(class CObjectShadow) == 112, "expected class CObjectShadow to be size 112");

// struct stBikeEffect
// 1 dependencies: struct Vec
struct stBikeEffect
{
public:
	/// No namespace types
	/// Struct member variables

	// <class EffectDriftMark* pDriftMark, offset 0x0>
	class EffectDriftMark* pDriftMark;

	// <class EffectKeepSmoke* pKeepSmoke, offset 0x4>
	class EffectKeepSmoke* pKeepSmoke;

	// <struct Vec posTireOldL, offset 0x8>
	struct Vec posTireOldL;

	// <struct Vec posTireOldR, offset 0x14>
	struct Vec posTireOldR;

	// <class EffectFixFire* pFixFire[0x2], offset 0x20>
	class EffectFixFire* pFixFire[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stBikeEffect>("stBikeEffect")
			.addProperty("pDriftMark", &stBikeEffect::pDriftMark)
			.addProperty("pKeepSmoke", &stBikeEffect::pKeepSmoke)
			.addProperty("posTireOldL", &stBikeEffect::posTireOldL)
			.addProperty("posTireOldR", &stBikeEffect::posTireOldR)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("pFixFire", &stBikeEffect::pFixFire)
		.endClass();
	}
#endif
};
static_assert(sizeof(stBikeEffect::pDriftMark) == 4, "expected pDriftMark to be size 4");
static_assert(sizeof(stBikeEffect::pKeepSmoke) == 4, "expected pKeepSmoke to be size 4");
static_assert(sizeof(stBikeEffect::posTireOldL) == 12, "expected posTireOldL to be size 12");
static_assert(sizeof(stBikeEffect::posTireOldR) == 12, "expected posTireOldR to be size 12");
static_assert(sizeof(stBikeEffect::pFixFire) == 8, "expected pFixFire to be size 8");
static_assert(sizeof(struct stBikeEffect) == 40, "expected struct stBikeEffect to be size 40");

// enum enBikeSpinDir
enum enBikeSpinDir : uint32_t
{
	// Enum values

	// <eBikeSpinL = 0x0>
	eBikeSpinL = 0,

	// <eBikeSpinR = 0x1>
	eBikeSpinR = 1,

	// <eBikeSpinMax = 0x2>
	eBikeSpinMax = 2

};

// enum enBikeFallProc
enum enBikeFallProc : uint32_t
{
	// Enum values

	// <eBikeFallSetMotel = 0x0>
	eBikeFallSetMotel = 0,

	// <eBikeFallWaitAreaLoad = 0x1>
	eBikeFallWaitAreaLoad = 1,

	// <eBikeFallMax = 0x2>
	eBikeFallMax = 2

};

// enum enBikeProc
enum enBikeProc : uint32_t
{
	// Enum values

	// <eBikeStopIdle = 0x0>
	eBikeStopIdle = 0,

	// <eBikeTrvRiding = 0x1>
	eBikeTrvRiding = 1,

	// <eBikeTrvIdle = 0x2>
	eBikeTrvIdle = 2,

	// <eBikeRun = 0x3>
	eBikeRun = 3,

	// <eBikeBack = 0x4>
	eBikeBack = 4,

	// <eBikeQStart = 0x5>
	eBikeQStart = 5,

	// <eBikeQStartWait = 0x6>
	eBikeQStartWait = 6,

	// <eBikeQBreak = 0x7>
	eBikeQBreak = 7,

	// <eBikeSpin = 0x8>
	eBikeSpin = 8,

	// <eBikeClash = 0x9>
	eBikeClash = 9,

	// <eBikePcClash2Stand = 0xa>
	eBikePcClash2Stand = 10,

	// <eBikeClash2Stand = 0xb>
	eBikeClash2Stand = 11,

	// <eBikeWaitStand = 0xc>
	eBikeWaitStand = 12,

	// <eBikeTrvGetOff = 0xd>
	eBikeTrvGetOff = 13,

	// <eBikeDamege = 0xe>
	eBikeDamege = 14,

	// <eBikeDead = 0xf>
	eBikeDead = 15,

	// <eBikeAccel = 0x10>
	eBikeAccel = 16,

	// <eBikeFall = 0x11>
	eBikeFall = 17,

	// <eBikeWaitSetMotel = 0x12>
	eBikeWaitSetMotel = 18,

	// <eBikeMax = 0x13>
	eBikeMax = 19

};

// struct stBike
// 24 dependencies: enum enBikeProc, enum enBikeFallProc, struct Vec, enum enBikeSpinDir, class WAnimF, class WAnim, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate
struct stBike
{
public:
	/// No namespace types
	/// Struct member variables

	// <class TGmf* pGmf, offset 0x0>
	class TGmf* pGmf;

	// <class TGan** pGan, offset 0x4>
	class TGan** pGan;

	// <enum enBikeProc process, offset 0x8>
	enum enBikeProc process;

	// <enum enBikeFallProc fallProcess, offset 0xc>
	enum enBikeFallProc fallProcess;

	// <int32_t motionNo, offset 0x10>
	int32_t motionNo;

	// <int32_t motionNumMax, offset 0x14>
	int32_t motionNumMax;

	// <int32_t motionBrendNum, offset 0x18>
	int32_t motionBrendNum;

	// <int32_t restoreMotionNo, offset 0x1c>
	int32_t restoreMotionNo;

	// <float rotPerf, offset 0x20>
	float rotPerf;

	// <float spdU, offset 0x24>
	float spdU;

	// <float spdV, offset 0x28>
	float spdV;

	// <float angSpd, offset 0x2c>
	float angSpd;

	// <float prevAngSpd, offset 0x30>
	float prevAngSpd;

	// <float forceU, offset 0x34>
	float forceU;

	// <float forceV, offset 0x38>
	float forceV;

	// <int32_t gripState, offset 0x3c>
	int32_t gripState;

	// <int32_t timerSlipTrigger, offset 0x40>
	int32_t timerSlipTrigger;

	// <int32_t timerMaxSlipTrigger, offset 0x44>
	int32_t timerMaxSlipTrigger;

	// <float slipRate, offset 0x48>
	float slipRate;

	// <float slipAngle, offset 0x4c>
	float slipAngle;

	// <float accelRate, offset 0x50>
	float accelRate;

	// <float brakeRate, offset 0x54>
	float brakeRate;

	// <float rudderAng, offset 0x58>
	float rudderAng;

	// <float length, offset 0x5c>
	float length;

	// <int32_t hitTame, offset 0x60>
	int32_t hitTame;

	// <struct Vec externForce, offset 0x64>
	struct Vec externForce;

	// <float posYF, offset 0x70>
	float posYF;

	// <float posYB, offset 0x74>
	float posYB;

	// <struct Vec pos, offset 0x78>
	struct Vec pos;

	// <struct Vec beforePos, offset 0x84>
	struct Vec beforePos;

	// <struct Vec beforePosF, offset 0x90>
	struct Vec beforePosF;

	// <struct Vec beforePosB, offset 0x9c>
	struct Vec beforePosB;

	// <struct Vec moveTempPos, offset 0xa8>
	struct Vec moveTempPos;

	// <struct Vec moveTempPosF, offset 0xb4>
	struct Vec moveTempPosF;

	// <struct Vec moveTempPosB, offset 0xc0>
	struct Vec moveTempPosB;

	// <struct Vec rot, offset 0xcc>
	struct Vec rot;

	// <struct Vec oldRot, offset 0xd8>
	struct Vec oldRot;

	// <float oldPosY, offset 0xe4>
	float oldPosY;

	// <float oldPosYF, offset 0xe8>
	float oldPosYF;

	// <float oldPosYB, offset 0xec>
	float oldPosYB;

	// <float adjustRotY, offset 0xf0>
	float adjustRotY;

	// <uint8_t hitCheck, offset 0xf4>
	uint8_t hitCheck;

	// <uint8_t clash, offset 0xf5>
	uint8_t clash;

	// <uint8_t hitWall, offset 0xf6>
	uint8_t hitWall;

	// <uint8_t hitWall4Spin, offset 0xf7>
	uint8_t hitWall4Spin;

	// <uint8_t alwaysCheckHitColl, offset 0xf8>
	uint8_t alwaysCheckHitColl;

	// <Filler, offset 0xf9>
	char _Filler46[3];

	// <int32_t hp, offset 0xfc>
	int32_t hp;

	// <int32_t bgmHdl, offset 0x100>
	int32_t bgmHdl;

	// <int32_t seHndlEngine, offset 0x104>
	int32_t seHndlEngine;

	// <int32_t seHndlEngineNeutral, offset 0x108>
	int32_t seHndlEngineNeutral;

	// <int32_t seHndlBreak, offset 0x10c>
	int32_t seHndlBreak;

	// <int32_t seHndlQBreak, offset 0x110>
	int32_t seHndlQBreak;

	// <int32_t seHndlAir, offset 0x114>
	int32_t seHndlAir;

	// <int32_t seHndlNitro, offset 0x118>
	int32_t seHndlNitro;

	// <int32_t seHndSqueal, offset 0x11c>
	int32_t seHndSqueal;

	// <float seVolEngine, offset 0x120>
	float seVolEngine;

	// <float seVolEngineNeutral, offset 0x124>
	float seVolEngineNeutral;

	// <float seVolBreak, offset 0x128>
	float seVolBreak;

	// <float seVolQBreak, offset 0x12c>
	float seVolQBreak;

	// <float seVolAir, offset 0x130>
	float seVolAir;

	// <float seVolNitro, offset 0x134>
	float seVolNitro;

	// <float seVolSqueal, offset 0x138>
	float seVolSqueal;

	// <int32_t command, offset 0x13c>
	int32_t command;

	// <float acc, offset 0x140>
	float acc;

	// <uint8_t useNitro, offset 0x144>
	uint8_t useNitro;

	// <Filler, offset 0x145>
	char _Filler65[3];

	// <float nitro, offset 0x148>
	float nitro;

	// <int32_t nitroStopTick, offset 0x14c>
	int32_t nitroStopTick;

	// <float turnVal, offset 0x150>
	float turnVal;

	// <float rimTurnVal, offset 0x154>
	float rimTurnVal;

	// <float qBreakRotY, offset 0x158>
	float qBreakRotY;

	// <enum enBikeSpinDir spinDir, offset 0x15c>
	enum enBikeSpinDir spinDir;

	// <float spinY, offset 0x160>
	float spinY;

	// <uint8_t wiry, offset 0x164>
	uint8_t wiry;

	// <uint8_t clashMySelf, offset 0x165>
	uint8_t clashMySelf;

	// <uint8_t battle, offset 0x166>
	uint8_t battle;

	// <uint8_t rideOnStart, offset 0x167>
	uint8_t rideOnStart;

	// <uint8_t initHitJudge, offset 0x168>
	uint8_t initHitJudge;

	// <uint8_t pushAcceling, offset 0x169>
	uint8_t pushAcceling;

	// <uint8_t pushBreaking, offset 0x16a>
	uint8_t pushBreaking;

	// <uint8_t cantRideOn, offset 0x16b>
	uint8_t cantRideOn;

	// <uint8_t cantGetOff, offset 0x16c>
	uint8_t cantGetOff;

	// <uint8_t cantHandling, offset 0x16d>
	uint8_t cantHandling;

	// <uint8_t dispCantGetOff, offset 0x16e>
	uint8_t dispCantGetOff;

	// <uint8_t crash2Stand, offset 0x16f>
	uint8_t crash2Stand;

	// <uint8_t changeVolEngine, offset 0x170>
	uint8_t changeVolEngine;

	// <uint8_t changeVolEngineIdle, offset 0x171>
	uint8_t changeVolEngineIdle;

	// <Filler, offset 0x172>
	char _Filler86[2];

	// <int32_t startWait, offset 0x174>
	int32_t startWait;

	// <float rateTbl[0x3], offset 0x178>
	float rateTbl[3];

	// <class WAnimF inputRelay, offset 0x184>
	class WAnimF inputRelay;

	// <class ghmGcCollObjCapsule hitColl, offset 0x1a4>
	class ghmGcCollObjCapsule hitColl;

	// <class ghmGcCollObjCapsule rideColl, offset 0x204>
	class ghmGcCollObjCapsule rideColl;

	// <class ghmGcCollObjCapsule hitStgColl, offset 0x264>
	class ghmGcCollObjCapsule hitStgColl;

	// <class ghmGcCollObjCapsule hitStgCollF, offset 0x2c4>
	class ghmGcCollObjCapsule hitStgCollF;

	// <class ghmGcCollObjCapsule hitStgCollB, offset 0x324>
	class ghmGcCollObjCapsule hitStgCollB;

	// <class ghmGcCollObj* footHitResultObj, offset 0x384>
	class ghmGcCollObj* footHitResultObj;

	// <class ghmGcCollObjHitResult* footHitResult, offset 0x388>
	class ghmGcCollObjHitResult* footHitResult;

	// <class ghmGcCollObjHitResultObj footHitResultObj2, offset 0x38c>
	class ghmGcCollObjHitResultObj footHitResultObj2;

	// <class EventAreaCircle* pEvIcn, offset 0x3d8>
	class EventAreaCircle* pEvIcn;

	// <struct tagGHMR_TEX texSpeed, offset 0x3dc>
	struct tagGHMR_TEX texSpeed;

	// <class WAnimF cameraLength, offset 0x404>
	class WAnimF cameraLength;

	// <class WAnimF cameraAngle, offset 0x424>
	class WAnimF cameraAngle;

	// <float rotZ, offset 0x444>
	float rotZ;

	// <uint8_t forceHitStage, offset 0x448>
	uint8_t forceHitStage;

	// <uint8_t crashFlag, offset 0x449>
	uint8_t crashFlag;

	// <Filler, offset 0x44a>
	char _Filler104[2];

	// <int32_t damageCount, offset 0x44c>
	int32_t damageCount;

	// <class WAnimF prj, offset 0x450>
	class WAnimF prj;

	// <class WAnimF modelAlpha, offset 0x470>
	class WAnimF modelAlpha;

	// <class CAmbientShadow m_inAmbientShadow, offset 0x490>
	class CAmbientShadow m_inAmbientShadow;

	// <uint8_t muteSe, offset 0x4c8>
	uint8_t muteSe;

	// <Filler, offset 0x4c9>
	char _Filler109[3];

	// <int32_t seLoadNoiseNo, offset 0x4cc>
	int32_t seLoadNoiseNo;

	// <int32_t seLoadNoiseHandle, offset 0x4d0>
	int32_t seLoadNoiseHandle;

	// <float seLoadNoisePitch, offset 0x4d4>
	float seLoadNoisePitch;

	// <float seLoadNoiseVolume, offset 0x4d8>
	float seLoadNoiseVolume;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<stBike>("stBike")
			.addProperty("pGmf", &stBike::pGmf)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("pGan", &stBike::pGan)
			.addProperty("process", &stBike::process)
			.addProperty("fallProcess", &stBike::fallProcess)
			.addProperty("motionNo", &stBike::motionNo)
			.addProperty("motionNumMax", &stBike::motionNumMax)
			.addProperty("motionBrendNum", &stBike::motionBrendNum)
			.addProperty("restoreMotionNo", &stBike::restoreMotionNo)
			.addProperty("rotPerf", &stBike::rotPerf)
			.addProperty("spdU", &stBike::spdU)
			.addProperty("spdV", &stBike::spdV)
			.addProperty("angSpd", &stBike::angSpd)
			.addProperty("prevAngSpd", &stBike::prevAngSpd)
			.addProperty("forceU", &stBike::forceU)
			.addProperty("forceV", &stBike::forceV)
			.addProperty("gripState", &stBike::gripState)
			.addProperty("timerSlipTrigger", &stBike::timerSlipTrigger)
			.addProperty("timerMaxSlipTrigger", &stBike::timerMaxSlipTrigger)
			.addProperty("slipRate", &stBike::slipRate)
			.addProperty("slipAngle", &stBike::slipAngle)
			.addProperty("accelRate", &stBike::accelRate)
			.addProperty("brakeRate", &stBike::brakeRate)
			.addProperty("rudderAng", &stBike::rudderAng)
			.addProperty("length", &stBike::length)
			.addProperty("hitTame", &stBike::hitTame)
			.addProperty("externForce", &stBike::externForce)
			.addProperty("posYF", &stBike::posYF)
			.addProperty("posYB", &stBike::posYB)
			.addProperty("pos", &stBike::pos)
			.addProperty("beforePos", &stBike::beforePos)
			.addProperty("beforePosF", &stBike::beforePosF)
			.addProperty("beforePosB", &stBike::beforePosB)
			.addProperty("moveTempPos", &stBike::moveTempPos)
			.addProperty("moveTempPosF", &stBike::moveTempPosF)
			.addProperty("moveTempPosB", &stBike::moveTempPosB)
			.addProperty("rot", &stBike::rot)
			.addProperty("oldRot", &stBike::oldRot)
			.addProperty("oldPosY", &stBike::oldPosY)
			.addProperty("oldPosYF", &stBike::oldPosYF)
			.addProperty("oldPosYB", &stBike::oldPosYB)
			.addProperty("adjustRotY", &stBike::adjustRotY)
			.addProperty("hitCheck", &stBike::hitCheck)
			.addProperty("clash", &stBike::clash)
			.addProperty("hitWall", &stBike::hitWall)
			.addProperty("hitWall4Spin", &stBike::hitWall4Spin)
			.addProperty("alwaysCheckHitColl", &stBike::alwaysCheckHitColl)
			.addProperty("hp", &stBike::hp)
			.addProperty("bgmHdl", &stBike::bgmHdl)
			.addProperty("seHndlEngine", &stBike::seHndlEngine)
			.addProperty("seHndlEngineNeutral", &stBike::seHndlEngineNeutral)
			.addProperty("seHndlBreak", &stBike::seHndlBreak)
			.addProperty("seHndlQBreak", &stBike::seHndlQBreak)
			.addProperty("seHndlAir", &stBike::seHndlAir)
			.addProperty("seHndlNitro", &stBike::seHndlNitro)
			.addProperty("seHndSqueal", &stBike::seHndSqueal)
			.addProperty("seVolEngine", &stBike::seVolEngine)
			.addProperty("seVolEngineNeutral", &stBike::seVolEngineNeutral)
			.addProperty("seVolBreak", &stBike::seVolBreak)
			.addProperty("seVolQBreak", &stBike::seVolQBreak)
			.addProperty("seVolAir", &stBike::seVolAir)
			.addProperty("seVolNitro", &stBike::seVolNitro)
			.addProperty("seVolSqueal", &stBike::seVolSqueal)
			.addProperty("command", &stBike::command)
			.addProperty("acc", &stBike::acc)
			.addProperty("useNitro", &stBike::useNitro)
			.addProperty("nitro", &stBike::nitro)
			.addProperty("nitroStopTick", &stBike::nitroStopTick)
			.addProperty("turnVal", &stBike::turnVal)
			.addProperty("rimTurnVal", &stBike::rimTurnVal)
			.addProperty("qBreakRotY", &stBike::qBreakRotY)
			.addProperty("spinDir", &stBike::spinDir)
			.addProperty("spinY", &stBike::spinY)
			.addProperty("wiry", &stBike::wiry)
			.addProperty("clashMySelf", &stBike::clashMySelf)
			.addProperty("battle", &stBike::battle)
			.addProperty("rideOnStart", &stBike::rideOnStart)
			.addProperty("initHitJudge", &stBike::initHitJudge)
			.addProperty("pushAcceling", &stBike::pushAcceling)
			.addProperty("pushBreaking", &stBike::pushBreaking)
			.addProperty("cantRideOn", &stBike::cantRideOn)
			.addProperty("cantGetOff", &stBike::cantGetOff)
			.addProperty("cantHandling", &stBike::cantHandling)
			.addProperty("dispCantGetOff", &stBike::dispCantGetOff)
			.addProperty("crash2Stand", &stBike::crash2Stand)
			.addProperty("changeVolEngine", &stBike::changeVolEngine)
			.addProperty("changeVolEngineIdle", &stBike::changeVolEngineIdle)
			.addProperty("startWait", &stBike::startWait)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("rateTbl", &stBike::rateTbl)
			.addProperty("inputRelay", &stBike::inputRelay)
			.addProperty("hitColl", &stBike::hitColl)
			.addProperty("rideColl", &stBike::rideColl)
			.addProperty("hitStgColl", &stBike::hitStgColl)
			.addProperty("hitStgCollF", &stBike::hitStgCollF)
			.addProperty("hitStgCollB", &stBike::hitStgCollB)
			.addProperty("footHitResultObj", &stBike::footHitResultObj)
			.addProperty("footHitResult", &stBike::footHitResult)
			.addProperty("footHitResultObj2", &stBike::footHitResultObj2)
			.addProperty("pEvIcn", &stBike::pEvIcn)
			.addProperty("texSpeed", &stBike::texSpeed)
			.addProperty("cameraLength", &stBike::cameraLength)
			.addProperty("cameraAngle", &stBike::cameraAngle)
			.addProperty("rotZ", &stBike::rotZ)
			.addProperty("forceHitStage", &stBike::forceHitStage)
			.addProperty("crashFlag", &stBike::crashFlag)
			.addProperty("damageCount", &stBike::damageCount)
			.addProperty("prj", &stBike::prj)
			.addProperty("modelAlpha", &stBike::modelAlpha)
			.addProperty("m_inAmbientShadow", &stBike::m_inAmbientShadow)
			.addProperty("muteSe", &stBike::muteSe)
			.addProperty("seLoadNoiseNo", &stBike::seLoadNoiseNo)
			.addProperty("seLoadNoiseHandle", &stBike::seLoadNoiseHandle)
			.addProperty("seLoadNoisePitch", &stBike::seLoadNoisePitch)
			.addProperty("seLoadNoiseVolume", &stBike::seLoadNoiseVolume)
		.endClass();
	}
#endif
};
static_assert(sizeof(stBike::pGmf) == 4, "expected pGmf to be size 4");
static_assert(sizeof(stBike::pGan) == 4, "expected pGan to be size 4");
static_assert(sizeof(stBike::process) == 4, "expected process to be size 4");
static_assert(sizeof(stBike::fallProcess) == 4, "expected fallProcess to be size 4");
static_assert(sizeof(stBike::motionNo) == 4, "expected motionNo to be size 4");
static_assert(sizeof(stBike::motionNumMax) == 4, "expected motionNumMax to be size 4");
static_assert(sizeof(stBike::motionBrendNum) == 4, "expected motionBrendNum to be size 4");
static_assert(sizeof(stBike::restoreMotionNo) == 4, "expected restoreMotionNo to be size 4");
static_assert(sizeof(stBike::rotPerf) == 4, "expected rotPerf to be size 4");
static_assert(sizeof(stBike::spdU) == 4, "expected spdU to be size 4");
static_assert(sizeof(stBike::spdV) == 4, "expected spdV to be size 4");
static_assert(sizeof(stBike::angSpd) == 4, "expected angSpd to be size 4");
static_assert(sizeof(stBike::prevAngSpd) == 4, "expected prevAngSpd to be size 4");
static_assert(sizeof(stBike::forceU) == 4, "expected forceU to be size 4");
static_assert(sizeof(stBike::forceV) == 4, "expected forceV to be size 4");
static_assert(sizeof(stBike::gripState) == 4, "expected gripState to be size 4");
static_assert(sizeof(stBike::timerSlipTrigger) == 4, "expected timerSlipTrigger to be size 4");
static_assert(sizeof(stBike::timerMaxSlipTrigger) == 4, "expected timerMaxSlipTrigger to be size 4");
static_assert(sizeof(stBike::slipRate) == 4, "expected slipRate to be size 4");
static_assert(sizeof(stBike::slipAngle) == 4, "expected slipAngle to be size 4");
static_assert(sizeof(stBike::accelRate) == 4, "expected accelRate to be size 4");
static_assert(sizeof(stBike::brakeRate) == 4, "expected brakeRate to be size 4");
static_assert(sizeof(stBike::rudderAng) == 4, "expected rudderAng to be size 4");
static_assert(sizeof(stBike::length) == 4, "expected length to be size 4");
static_assert(sizeof(stBike::hitTame) == 4, "expected hitTame to be size 4");
static_assert(sizeof(stBike::externForce) == 12, "expected externForce to be size 12");
static_assert(sizeof(stBike::posYF) == 4, "expected posYF to be size 4");
static_assert(sizeof(stBike::posYB) == 4, "expected posYB to be size 4");
static_assert(sizeof(stBike::pos) == 12, "expected pos to be size 12");
static_assert(sizeof(stBike::beforePos) == 12, "expected beforePos to be size 12");
static_assert(sizeof(stBike::beforePosF) == 12, "expected beforePosF to be size 12");
static_assert(sizeof(stBike::beforePosB) == 12, "expected beforePosB to be size 12");
static_assert(sizeof(stBike::moveTempPos) == 12, "expected moveTempPos to be size 12");
static_assert(sizeof(stBike::moveTempPosF) == 12, "expected moveTempPosF to be size 12");
static_assert(sizeof(stBike::moveTempPosB) == 12, "expected moveTempPosB to be size 12");
static_assert(sizeof(stBike::rot) == 12, "expected rot to be size 12");
static_assert(sizeof(stBike::oldRot) == 12, "expected oldRot to be size 12");
static_assert(sizeof(stBike::oldPosY) == 4, "expected oldPosY to be size 4");
static_assert(sizeof(stBike::oldPosYF) == 4, "expected oldPosYF to be size 4");
static_assert(sizeof(stBike::oldPosYB) == 4, "expected oldPosYB to be size 4");
static_assert(sizeof(stBike::adjustRotY) == 4, "expected adjustRotY to be size 4");
static_assert(sizeof(stBike::hitCheck) == 1, "expected hitCheck to be size 1");
static_assert(sizeof(stBike::clash) == 1, "expected clash to be size 1");
static_assert(sizeof(stBike::hitWall) == 1, "expected hitWall to be size 1");
static_assert(sizeof(stBike::hitWall4Spin) == 1, "expected hitWall4Spin to be size 1");
static_assert(sizeof(stBike::alwaysCheckHitColl) == 1, "expected alwaysCheckHitColl to be size 1");
static_assert(sizeof(stBike::hp) == 4, "expected hp to be size 4");
static_assert(sizeof(stBike::bgmHdl) == 4, "expected bgmHdl to be size 4");
static_assert(sizeof(stBike::seHndlEngine) == 4, "expected seHndlEngine to be size 4");
static_assert(sizeof(stBike::seHndlEngineNeutral) == 4, "expected seHndlEngineNeutral to be size 4");
static_assert(sizeof(stBike::seHndlBreak) == 4, "expected seHndlBreak to be size 4");
static_assert(sizeof(stBike::seHndlQBreak) == 4, "expected seHndlQBreak to be size 4");
static_assert(sizeof(stBike::seHndlAir) == 4, "expected seHndlAir to be size 4");
static_assert(sizeof(stBike::seHndlNitro) == 4, "expected seHndlNitro to be size 4");
static_assert(sizeof(stBike::seHndSqueal) == 4, "expected seHndSqueal to be size 4");
static_assert(sizeof(stBike::seVolEngine) == 4, "expected seVolEngine to be size 4");
static_assert(sizeof(stBike::seVolEngineNeutral) == 4, "expected seVolEngineNeutral to be size 4");
static_assert(sizeof(stBike::seVolBreak) == 4, "expected seVolBreak to be size 4");
static_assert(sizeof(stBike::seVolQBreak) == 4, "expected seVolQBreak to be size 4");
static_assert(sizeof(stBike::seVolAir) == 4, "expected seVolAir to be size 4");
static_assert(sizeof(stBike::seVolNitro) == 4, "expected seVolNitro to be size 4");
static_assert(sizeof(stBike::seVolSqueal) == 4, "expected seVolSqueal to be size 4");
static_assert(sizeof(stBike::command) == 4, "expected command to be size 4");
static_assert(sizeof(stBike::acc) == 4, "expected acc to be size 4");
static_assert(sizeof(stBike::useNitro) == 1, "expected useNitro to be size 1");
static_assert(sizeof(stBike::nitro) == 4, "expected nitro to be size 4");
static_assert(sizeof(stBike::nitroStopTick) == 4, "expected nitroStopTick to be size 4");
static_assert(sizeof(stBike::turnVal) == 4, "expected turnVal to be size 4");
static_assert(sizeof(stBike::rimTurnVal) == 4, "expected rimTurnVal to be size 4");
static_assert(sizeof(stBike::qBreakRotY) == 4, "expected qBreakRotY to be size 4");
static_assert(sizeof(stBike::spinDir) == 4, "expected spinDir to be size 4");
static_assert(sizeof(stBike::spinY) == 4, "expected spinY to be size 4");
static_assert(sizeof(stBike::wiry) == 1, "expected wiry to be size 1");
static_assert(sizeof(stBike::clashMySelf) == 1, "expected clashMySelf to be size 1");
static_assert(sizeof(stBike::battle) == 1, "expected battle to be size 1");
static_assert(sizeof(stBike::rideOnStart) == 1, "expected rideOnStart to be size 1");
static_assert(sizeof(stBike::initHitJudge) == 1, "expected initHitJudge to be size 1");
static_assert(sizeof(stBike::pushAcceling) == 1, "expected pushAcceling to be size 1");
static_assert(sizeof(stBike::pushBreaking) == 1, "expected pushBreaking to be size 1");
static_assert(sizeof(stBike::cantRideOn) == 1, "expected cantRideOn to be size 1");
static_assert(sizeof(stBike::cantGetOff) == 1, "expected cantGetOff to be size 1");
static_assert(sizeof(stBike::cantHandling) == 1, "expected cantHandling to be size 1");
static_assert(sizeof(stBike::dispCantGetOff) == 1, "expected dispCantGetOff to be size 1");
static_assert(sizeof(stBike::crash2Stand) == 1, "expected crash2Stand to be size 1");
static_assert(sizeof(stBike::changeVolEngine) == 1, "expected changeVolEngine to be size 1");
static_assert(sizeof(stBike::changeVolEngineIdle) == 1, "expected changeVolEngineIdle to be size 1");
static_assert(sizeof(stBike::startWait) == 4, "expected startWait to be size 4");
static_assert(sizeof(stBike::rateTbl) == 12, "expected rateTbl to be size 12");
static_assert(sizeof(stBike::inputRelay) == 32, "expected inputRelay to be size 32");
static_assert(sizeof(stBike::hitColl) == 96, "expected hitColl to be size 96");
static_assert(sizeof(stBike::rideColl) == 96, "expected rideColl to be size 96");
static_assert(sizeof(stBike::hitStgColl) == 96, "expected hitStgColl to be size 96");
static_assert(sizeof(stBike::hitStgCollF) == 96, "expected hitStgCollF to be size 96");
static_assert(sizeof(stBike::hitStgCollB) == 96, "expected hitStgCollB to be size 96");
static_assert(sizeof(stBike::footHitResultObj) == 4, "expected footHitResultObj to be size 4");
static_assert(sizeof(stBike::footHitResult) == 4, "expected footHitResult to be size 4");
static_assert(sizeof(stBike::footHitResultObj2) == 76, "expected footHitResultObj2 to be size 76");
static_assert(sizeof(stBike::pEvIcn) == 4, "expected pEvIcn to be size 4");
static_assert(sizeof(stBike::texSpeed) == 40, "expected texSpeed to be size 40");
static_assert(sizeof(stBike::cameraLength) == 32, "expected cameraLength to be size 32");
static_assert(sizeof(stBike::cameraAngle) == 32, "expected cameraAngle to be size 32");
static_assert(sizeof(stBike::rotZ) == 4, "expected rotZ to be size 4");
static_assert(sizeof(stBike::forceHitStage) == 1, "expected forceHitStage to be size 1");
static_assert(sizeof(stBike::crashFlag) == 1, "expected crashFlag to be size 1");
static_assert(sizeof(stBike::damageCount) == 4, "expected damageCount to be size 4");
static_assert(sizeof(stBike::prj) == 32, "expected prj to be size 32");
static_assert(sizeof(stBike::modelAlpha) == 32, "expected modelAlpha to be size 32");
static_assert(sizeof(stBike::m_inAmbientShadow) == 56, "expected m_inAmbientShadow to be size 56");
static_assert(sizeof(stBike::muteSe) == 1, "expected muteSe to be size 1");
static_assert(sizeof(stBike::seLoadNoiseNo) == 4, "expected seLoadNoiseNo to be size 4");
static_assert(sizeof(stBike::seLoadNoiseHandle) == 4, "expected seLoadNoiseHandle to be size 4");
static_assert(sizeof(stBike::seLoadNoisePitch) == 4, "expected seLoadNoisePitch to be size 4");
static_assert(sizeof(stBike::seLoadNoiseVolume) == 4, "expected seLoadNoiseVolume to be size 4");
static_assert(sizeof(struct stBike) == 1244, "expected struct stBike to be size 1244");

// class mHRBike
// 27 dependencies: struct stBike, enum enBikeProc, enum enBikeFallProc, struct Vec, enum enBikeSpinDir, class WAnimF, class WAnim, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, struct stBikeEffect, class CObjectShadow
class mHRBike
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct stBike mBike, offset 0x0>
	struct stBike mBike;

	// <struct stBikeEffect mBikeEffect, offset 0x4dc>
	struct stBikeEffect mBikeEffect;

	// <uint8_t mhitStage, offset 0x504>
	uint8_t mhitStage;

	// <Filler, offset 0x505>
	char _Filler3[3];

	// <float mWryRate, offset 0x508>
	float mWryRate;

	// <float mBankRate, offset 0x50c>
	float mBankRate;

	// <struct Vec mDamegeDir, offset 0x510>
	struct Vec mDamegeDir;

	// <float mDamegeRotY, offset 0x51c>
	float mDamegeRotY;

	// <float mAccel, offset 0x520>
	float mAccel;

	// <struct Vec mPassRot, offset 0x524>
	struct Vec mPassRot;

	// <int32_t mFireSEID, offset 0x530>
	int32_t mFireSEID;

	// <float mHitWait, offset 0x534>
	float mHitWait;

	// <uint8_t mRotLock, offset 0x538>
	uint8_t mRotLock;

	// <uint8_t mBkAtkOk, offset 0x539>
	uint8_t mBkAtkOk;

	// <uint8_t m_bIsDrawShadow, offset 0x53a>
	uint8_t m_bIsDrawShadow;

	// <uint8_t m_boForceDisableDrawShadow, offset 0x53b>
	uint8_t m_boForceDisableDrawShadow;

	// <class CObjectShadow m_inObjectShadow, offset 0x53c>
	class CObjectShadow m_inObjectShadow;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRBike>("mHRBike")
			.addProperty("mBike", &mHRBike::mBike)
			.addProperty("mBikeEffect", &mHRBike::mBikeEffect)
			.addProperty("mhitStage", &mHRBike::mhitStage)
			.addProperty("mWryRate", &mHRBike::mWryRate)
			.addProperty("mBankRate", &mHRBike::mBankRate)
			.addProperty("mDamegeDir", &mHRBike::mDamegeDir)
			.addProperty("mDamegeRotY", &mHRBike::mDamegeRotY)
			.addProperty("mAccel", &mHRBike::mAccel)
			.addProperty("mPassRot", &mHRBike::mPassRot)
			.addProperty("mFireSEID", &mHRBike::mFireSEID)
			.addProperty("mHitWait", &mHRBike::mHitWait)
			.addProperty("mRotLock", &mHRBike::mRotLock)
			.addProperty("mBkAtkOk", &mHRBike::mBkAtkOk)
			.addProperty("m_bIsDrawShadow", &mHRBike::m_bIsDrawShadow)
			.addProperty("m_boForceDisableDrawShadow", &mHRBike::m_boForceDisableDrawShadow)
			.addProperty("m_inObjectShadow", &mHRBike::m_inObjectShadow)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRBike::mBike) == 1244, "expected mBike to be size 1244");
static_assert(sizeof(mHRBike::mBikeEffect) == 40, "expected mBikeEffect to be size 40");
static_assert(sizeof(mHRBike::mhitStage) == 1, "expected mhitStage to be size 1");
static_assert(sizeof(mHRBike::mWryRate) == 4, "expected mWryRate to be size 4");
static_assert(sizeof(mHRBike::mBankRate) == 4, "expected mBankRate to be size 4");
static_assert(sizeof(mHRBike::mDamegeDir) == 12, "expected mDamegeDir to be size 12");
static_assert(sizeof(mHRBike::mDamegeRotY) == 4, "expected mDamegeRotY to be size 4");
static_assert(sizeof(mHRBike::mAccel) == 4, "expected mAccel to be size 4");
static_assert(sizeof(mHRBike::mPassRot) == 12, "expected mPassRot to be size 12");
static_assert(sizeof(mHRBike::mFireSEID) == 4, "expected mFireSEID to be size 4");
static_assert(sizeof(mHRBike::mHitWait) == 4, "expected mHitWait to be size 4");
static_assert(sizeof(mHRBike::mRotLock) == 1, "expected mRotLock to be size 1");
static_assert(sizeof(mHRBike::mBkAtkOk) == 1, "expected mBkAtkOk to be size 1");
static_assert(sizeof(mHRBike::m_bIsDrawShadow) == 1, "expected m_bIsDrawShadow to be size 1");
static_assert(sizeof(mHRBike::m_boForceDisableDrawShadow) == 1, "expected m_boForceDisableDrawShadow to be size 1");
static_assert(sizeof(mHRBike::m_inObjectShadow) == 112, "expected m_inObjectShadow to be size 112");
static_assert(sizeof(class mHRBike) == 1452, "expected class mHRBike to be size 1452");

// class EventAreaCircle
// 2 dependencies: class ghmListObj, struct Vec
class EventAreaCircle : ghmListObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <int32_t m_Kind, offset 0x10>
	int32_t m_Kind;

	// <struct Vec m_Center, offset 0x14>
	struct Vec m_Center;

	// <float m_sRadius, offset 0x20>
	float m_sRadius;

	// <float m_Rot, offset 0x24>
	float m_Rot;

	// <float m_Scale, offset 0x28>
	float m_Scale;

	// <float m_ScaleHoshi, offset 0x2c>
	float m_ScaleHoshi;

	// <float m_MinScale, offset 0x30>
	float m_MinScale;

	// <float m_MaxScale, offset 0x34>
	float m_MaxScale;

	// <int32_t m_Alpha, offset 0x38>
	int32_t m_Alpha;

	// <uint8_t m_Done, offset 0x3c>
	uint8_t m_Done;

	// <uint8_t m_PcPlayMotionDone, offset 0x3d>
	uint8_t m_PcPlayMotionDone;

	// <uint8_t m_PcMoveDone, offset 0x3e>
	uint8_t m_PcMoveDone;

	// <uint8_t m_firsttouch, offset 0x3f>
	uint8_t m_firsttouch;

	// <uint8_t m_nowtouch, offset 0x40>
	uint8_t m_nowtouch;

	// <char m_EventName[0x20], offset 0x41>
	char m_EventName[32];

	// <char m_StageName[0x10], offset 0x61>
	char m_StageName[16];

	// <Filler, offset 0x71>
	char _Filler17[3];

	// <uint32_t m_HrScriptHandle, offset 0x74>
	uint32_t m_HrScriptHandle;

	// <uint8_t m_PlayBossCornMotionFlag, offset 0x78>
	uint8_t m_PlayBossCornMotionFlag;

	// <Filler, offset 0x79>
	char _Filler19[3];

	// <class TGmf* m_pCornGmf, offset 0x7c>
	class TGmf* m_pCornGmf;

	// <class TGmf* m_pCornSleepGmf, offset 0x80>
	class TGmf* m_pCornSleepGmf;

	// <class TGmf* m_pCornShadowGmf, offset 0x84>
	class TGmf* m_pCornShadowGmf;

	// <int32_t m_pCornShadowGanNum, offset 0x88>
	int32_t m_pCornShadowGanNum;

	// <class TGan** m_pCornShadowGan, offset 0x8c>
	class TGan** m_pCornShadowGan;

	// <uint8_t m_PlaySe[0x2], offset 0x90>
	uint8_t m_PlaySe[2];

	// <Filler, offset 0x92>
	char _Filler25[2];

	// <int32_t m_MakerType, offset 0x94>
	int32_t m_MakerType;

	// <int32_t m_SignboardType, offset 0x98>
	int32_t m_SignboardType;

	// <int32_t m_Sleep, offset 0x9c>
	int32_t m_Sleep;

	// <int32_t m_SleepAlpha, offset 0xa0>
	int32_t m_SleepAlpha;

	// <int32_t m_SleepTick, offset 0xa4>
	int32_t m_SleepTick;

	// <uint8_t m_WakeUpCameraEffect, offset 0xa8>
	uint8_t m_WakeUpCameraEffect;

	// <uint8_t m_Visible, offset 0xa9>
	uint8_t m_Visible;

	// <Filler, offset 0xaa>
	char _Filler32[2];

	// <int32_t m_SleepMessage, offset 0xac>
	int32_t m_SleepMessage;

	// <int32_t m_SleepMessageProc, offset 0xb0>
	int32_t m_SleepMessageProc;

	// <int32_t mBackDispStatusDisEnable, offset 0xb4>
	int32_t mBackDispStatusDisEnable;

	// <int32_t m_EventRunEffectProcess, offset 0xb8>
	int32_t m_EventRunEffectProcess;

	// <int32_t m_EventRunEffectBit, offset 0xbc>
	int32_t m_EventRunEffectBit;

	// <uint8_t m_CameraOff, offset 0xc0>
	uint8_t m_CameraOff;

	// <uint8_t mCameraPosSetType, offset 0xc1>
	uint8_t mCameraPosSetType;

	// <Filler, offset 0xc2>
	char _Filler39[2];

	// <struct Vec mCameraPos, offset 0xc4>
	struct Vec mCameraPos;

	// <struct Vec mCameraTargetPos, offset 0xd0>
	struct Vec mCameraTargetPos;

	// <uint8_t mPcPosSetType, offset 0xdc>
	uint8_t mPcPosSetType;

	// <Filler, offset 0xdd>
	char _Filler42[3];

	// <struct Vec mPcPos, offset 0xe0>
	struct Vec mPcPos;

	// <float mCenterRotY, offset 0xec>
	float mCenterRotY;

	// <float mPcRotY, offset 0xf0>
	float mPcRotY;

	// <class HrScriptFunc* mpEventAreaCircleScriptFunc, offset 0xf4>
	class HrScriptFunc* mpEventAreaCircleScriptFunc;

	// <int32_t mFunctionCallCount, offset 0xf8>
	int32_t mFunctionCallCount;

	// <int32_t mFunctionCallType, offset 0xfc>
	int32_t mFunctionCallType;

	// <int32_t mPcMotionID, offset 0x100>
	int32_t mPcMotionID;

	// <int32_t mPcMoveFrame, offset 0x104>
	int32_t mPcMoveFrame;

	// <uint8_t mDelete, offset 0x108>
	uint8_t mDelete;

	// <Filler, offset 0x109>
	char _Filler51[3];

	// <class EveCorn* mpEveCorn, offset 0x10c>
	class EveCorn* mpEveCorn;

	// <uint8_t mEveCornVisible, offset 0x110>
	uint8_t mEveCornVisible;

	// <Filler, offset 0x111>
	char _Filler53[3];

	// <int32_t mEveCornRefreshCnt, offset 0x114>
	int32_t mEveCornRefreshCnt;

	// <uint8_t mEventEndCameraHold, offset 0x118>
	uint8_t mEventEndCameraHold;

	// <uint8_t mFlash, offset 0x119>
	uint8_t mFlash;

	// <uint8_t mFlashSE, offset 0x11a>
	uint8_t mFlashSE;

	// <Filler, offset 0x11b>
	char _Filler57[1];

	// <int32_t mFlashCounter, offset 0x11c>
	int32_t mFlashCounter;

	// <uint8_t mBikeRide, offset 0x120>
	uint8_t mBikeRide;

	// <Filler, offset 0x121>
	char _Filler59[3];

	// <class EventAreaCamera* mpEventAreaCamera, offset 0x124>
	class EventAreaCamera* mpEventAreaCamera;

	// <class EventAreaCamera* mpSleepWakeUpCamera, offset 0x128>
	class EventAreaCamera* mpSleepWakeUpCamera;

	// <uint32_t m_AreaCircleEventHandle, offset 0x12c>
	uint32_t m_AreaCircleEventHandle;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EventAreaCircle>("EventAreaCircle")
			.addProperty("m_Kind", &EventAreaCircle::m_Kind)
			.addProperty("m_Center", &EventAreaCircle::m_Center)
			.addProperty("m_sRadius", &EventAreaCircle::m_sRadius)
			.addProperty("m_Rot", &EventAreaCircle::m_Rot)
			.addProperty("m_Scale", &EventAreaCircle::m_Scale)
			.addProperty("m_ScaleHoshi", &EventAreaCircle::m_ScaleHoshi)
			.addProperty("m_MinScale", &EventAreaCircle::m_MinScale)
			.addProperty("m_MaxScale", &EventAreaCircle::m_MaxScale)
			.addProperty("m_Alpha", &EventAreaCircle::m_Alpha)
			.addProperty("m_Done", &EventAreaCircle::m_Done)
			.addProperty("m_PcPlayMotionDone", &EventAreaCircle::m_PcPlayMotionDone)
			.addProperty("m_PcMoveDone", &EventAreaCircle::m_PcMoveDone)
			.addProperty("m_firsttouch", &EventAreaCircle::m_firsttouch)
			.addProperty("m_nowtouch", &EventAreaCircle::m_nowtouch)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_EventName", &EventAreaCircle::m_EventName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StageName", &EventAreaCircle::m_StageName)
			.addProperty("m_HrScriptHandle", &EventAreaCircle::m_HrScriptHandle)
			.addProperty("m_PlayBossCornMotionFlag", &EventAreaCircle::m_PlayBossCornMotionFlag)
			.addProperty("m_pCornGmf", &EventAreaCircle::m_pCornGmf)
			.addProperty("m_pCornSleepGmf", &EventAreaCircle::m_pCornSleepGmf)
			.addProperty("m_pCornShadowGmf", &EventAreaCircle::m_pCornShadowGmf)
			.addProperty("m_pCornShadowGanNum", &EventAreaCircle::m_pCornShadowGanNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("m_pCornShadowGan", &EventAreaCircle::m_pCornShadowGan)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_PlaySe", &EventAreaCircle::m_PlaySe)
			.addProperty("m_MakerType", &EventAreaCircle::m_MakerType)
			.addProperty("m_SignboardType", &EventAreaCircle::m_SignboardType)
			.addProperty("m_Sleep", &EventAreaCircle::m_Sleep)
			.addProperty("m_SleepAlpha", &EventAreaCircle::m_SleepAlpha)
			.addProperty("m_SleepTick", &EventAreaCircle::m_SleepTick)
			.addProperty("m_WakeUpCameraEffect", &EventAreaCircle::m_WakeUpCameraEffect)
			.addProperty("m_Visible", &EventAreaCircle::m_Visible)
			.addProperty("m_SleepMessage", &EventAreaCircle::m_SleepMessage)
			.addProperty("m_SleepMessageProc", &EventAreaCircle::m_SleepMessageProc)
			.addProperty("mBackDispStatusDisEnable", &EventAreaCircle::mBackDispStatusDisEnable)
			.addProperty("m_EventRunEffectProcess", &EventAreaCircle::m_EventRunEffectProcess)
			.addProperty("m_EventRunEffectBit", &EventAreaCircle::m_EventRunEffectBit)
			.addProperty("m_CameraOff", &EventAreaCircle::m_CameraOff)
			.addProperty("mCameraPosSetType", &EventAreaCircle::mCameraPosSetType)
			.addProperty("mCameraPos", &EventAreaCircle::mCameraPos)
			.addProperty("mCameraTargetPos", &EventAreaCircle::mCameraTargetPos)
			.addProperty("mPcPosSetType", &EventAreaCircle::mPcPosSetType)
			.addProperty("mPcPos", &EventAreaCircle::mPcPos)
			.addProperty("mCenterRotY", &EventAreaCircle::mCenterRotY)
			.addProperty("mPcRotY", &EventAreaCircle::mPcRotY)
			.addProperty("mpEventAreaCircleScriptFunc", &EventAreaCircle::mpEventAreaCircleScriptFunc)
			.addProperty("mFunctionCallCount", &EventAreaCircle::mFunctionCallCount)
			.addProperty("mFunctionCallType", &EventAreaCircle::mFunctionCallType)
			.addProperty("mPcMotionID", &EventAreaCircle::mPcMotionID)
			.addProperty("mPcMoveFrame", &EventAreaCircle::mPcMoveFrame)
			.addProperty("mDelete", &EventAreaCircle::mDelete)
			.addProperty("mpEveCorn", &EventAreaCircle::mpEveCorn)
			.addProperty("mEveCornVisible", &EventAreaCircle::mEveCornVisible)
			.addProperty("mEveCornRefreshCnt", &EventAreaCircle::mEveCornRefreshCnt)
			.addProperty("mEventEndCameraHold", &EventAreaCircle::mEventEndCameraHold)
			.addProperty("mFlash", &EventAreaCircle::mFlash)
			.addProperty("mFlashSE", &EventAreaCircle::mFlashSE)
			.addProperty("mFlashCounter", &EventAreaCircle::mFlashCounter)
			.addProperty("mBikeRide", &EventAreaCircle::mBikeRide)
			.addProperty("mpEventAreaCamera", &EventAreaCircle::mpEventAreaCamera)
			.addProperty("mpSleepWakeUpCamera", &EventAreaCircle::mpSleepWakeUpCamera)
			.addProperty("m_AreaCircleEventHandle", &EventAreaCircle::m_AreaCircleEventHandle)
		.endClass();
	}
#endif
};
static_assert(sizeof(EventAreaCircle::m_Kind) == 4, "expected m_Kind to be size 4");
static_assert(sizeof(EventAreaCircle::m_Center) == 12, "expected m_Center to be size 12");
static_assert(sizeof(EventAreaCircle::m_sRadius) == 4, "expected m_sRadius to be size 4");
static_assert(sizeof(EventAreaCircle::m_Rot) == 4, "expected m_Rot to be size 4");
static_assert(sizeof(EventAreaCircle::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EventAreaCircle::m_ScaleHoshi) == 4, "expected m_ScaleHoshi to be size 4");
static_assert(sizeof(EventAreaCircle::m_MinScale) == 4, "expected m_MinScale to be size 4");
static_assert(sizeof(EventAreaCircle::m_MaxScale) == 4, "expected m_MaxScale to be size 4");
static_assert(sizeof(EventAreaCircle::m_Alpha) == 4, "expected m_Alpha to be size 4");
static_assert(sizeof(EventAreaCircle::m_Done) == 1, "expected m_Done to be size 1");
static_assert(sizeof(EventAreaCircle::m_PcPlayMotionDone) == 1, "expected m_PcPlayMotionDone to be size 1");
static_assert(sizeof(EventAreaCircle::m_PcMoveDone) == 1, "expected m_PcMoveDone to be size 1");
static_assert(sizeof(EventAreaCircle::m_firsttouch) == 1, "expected m_firsttouch to be size 1");
static_assert(sizeof(EventAreaCircle::m_nowtouch) == 1, "expected m_nowtouch to be size 1");
static_assert(sizeof(EventAreaCircle::m_EventName) == 32, "expected m_EventName to be size 32");
static_assert(sizeof(EventAreaCircle::m_StageName) == 16, "expected m_StageName to be size 16");
static_assert(sizeof(EventAreaCircle::m_HrScriptHandle) == 4, "expected m_HrScriptHandle to be size 4");
static_assert(sizeof(EventAreaCircle::m_PlayBossCornMotionFlag) == 1, "expected m_PlayBossCornMotionFlag to be size 1");
static_assert(sizeof(EventAreaCircle::m_pCornGmf) == 4, "expected m_pCornGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornSleepGmf) == 4, "expected m_pCornSleepGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGmf) == 4, "expected m_pCornShadowGmf to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGanNum) == 4, "expected m_pCornShadowGanNum to be size 4");
static_assert(sizeof(EventAreaCircle::m_pCornShadowGan) == 4, "expected m_pCornShadowGan to be size 4");
static_assert(sizeof(EventAreaCircle::m_PlaySe) == 2, "expected m_PlaySe to be size 2");
static_assert(sizeof(EventAreaCircle::m_MakerType) == 4, "expected m_MakerType to be size 4");
static_assert(sizeof(EventAreaCircle::m_SignboardType) == 4, "expected m_SignboardType to be size 4");
static_assert(sizeof(EventAreaCircle::m_Sleep) == 4, "expected m_Sleep to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepAlpha) == 4, "expected m_SleepAlpha to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepTick) == 4, "expected m_SleepTick to be size 4");
static_assert(sizeof(EventAreaCircle::m_WakeUpCameraEffect) == 1, "expected m_WakeUpCameraEffect to be size 1");
static_assert(sizeof(EventAreaCircle::m_Visible) == 1, "expected m_Visible to be size 1");
static_assert(sizeof(EventAreaCircle::m_SleepMessage) == 4, "expected m_SleepMessage to be size 4");
static_assert(sizeof(EventAreaCircle::m_SleepMessageProc) == 4, "expected m_SleepMessageProc to be size 4");
static_assert(sizeof(EventAreaCircle::mBackDispStatusDisEnable) == 4, "expected mBackDispStatusDisEnable to be size 4");
static_assert(sizeof(EventAreaCircle::m_EventRunEffectProcess) == 4, "expected m_EventRunEffectProcess to be size 4");
static_assert(sizeof(EventAreaCircle::m_EventRunEffectBit) == 4, "expected m_EventRunEffectBit to be size 4");
static_assert(sizeof(EventAreaCircle::m_CameraOff) == 1, "expected m_CameraOff to be size 1");
static_assert(sizeof(EventAreaCircle::mCameraPosSetType) == 1, "expected mCameraPosSetType to be size 1");
static_assert(sizeof(EventAreaCircle::mCameraPos) == 12, "expected mCameraPos to be size 12");
static_assert(sizeof(EventAreaCircle::mCameraTargetPos) == 12, "expected mCameraTargetPos to be size 12");
static_assert(sizeof(EventAreaCircle::mPcPosSetType) == 1, "expected mPcPosSetType to be size 1");
static_assert(sizeof(EventAreaCircle::mPcPos) == 12, "expected mPcPos to be size 12");
static_assert(sizeof(EventAreaCircle::mCenterRotY) == 4, "expected mCenterRotY to be size 4");
static_assert(sizeof(EventAreaCircle::mPcRotY) == 4, "expected mPcRotY to be size 4");
static_assert(sizeof(EventAreaCircle::mpEventAreaCircleScriptFunc) == 4, "expected mpEventAreaCircleScriptFunc to be size 4");
static_assert(sizeof(EventAreaCircle::mFunctionCallCount) == 4, "expected mFunctionCallCount to be size 4");
static_assert(sizeof(EventAreaCircle::mFunctionCallType) == 4, "expected mFunctionCallType to be size 4");
static_assert(sizeof(EventAreaCircle::mPcMotionID) == 4, "expected mPcMotionID to be size 4");
static_assert(sizeof(EventAreaCircle::mPcMoveFrame) == 4, "expected mPcMoveFrame to be size 4");
static_assert(sizeof(EventAreaCircle::mDelete) == 1, "expected mDelete to be size 1");
static_assert(sizeof(EventAreaCircle::mpEveCorn) == 4, "expected mpEveCorn to be size 4");
static_assert(sizeof(EventAreaCircle::mEveCornVisible) == 1, "expected mEveCornVisible to be size 1");
static_assert(sizeof(EventAreaCircle::mEveCornRefreshCnt) == 4, "expected mEveCornRefreshCnt to be size 4");
static_assert(sizeof(EventAreaCircle::mEventEndCameraHold) == 1, "expected mEventEndCameraHold to be size 1");
static_assert(sizeof(EventAreaCircle::mFlash) == 1, "expected mFlash to be size 1");
static_assert(sizeof(EventAreaCircle::mFlashSE) == 1, "expected mFlashSE to be size 1");
static_assert(sizeof(EventAreaCircle::mFlashCounter) == 4, "expected mFlashCounter to be size 4");
static_assert(sizeof(EventAreaCircle::mBikeRide) == 1, "expected mBikeRide to be size 1");
static_assert(sizeof(EventAreaCircle::mpEventAreaCamera) == 4, "expected mpEventAreaCamera to be size 4");
static_assert(sizeof(EventAreaCircle::mpSleepWakeUpCamera) == 4, "expected mpSleepWakeUpCamera to be size 4");
static_assert(sizeof(EventAreaCircle::m_AreaCircleEventHandle) == 4, "expected m_AreaCircleEventHandle to be size 4");
static_assert(sizeof(class EventAreaCircle) == 304, "expected class EventAreaCircle to be size 304");

// class ghmScriptVariables
// no dependencies
class ghmScriptVariables
{
public:
	/// No namespace types
	/// Struct member variables

	// <char* mpChar, offset 0x0>
	char* mpChar;

	// <int32_t mCharNum, offset 0x4>
	int32_t mCharNum;

	// <int16_t* mpShort, offset 0x8>
	int16_t* mpShort;

	// <int32_t mShortNum, offset 0xc>
	int32_t mShortNum;

	// <int32_t* mpInt, offset 0x10>
	int32_t* mpInt;

	// <int32_t mIntNum, offset 0x14>
	int32_t mIntNum;

	// <int64_t* mpLong, offset 0x18>
	int64_t* mpLong;

	// <int32_t mLongNum, offset 0x1c>
	int32_t mLongNum;

	// <float* mpFloat, offset 0x20>
	float* mpFloat;

	// <int32_t mFloatNum, offset 0x24>
	int32_t mFloatNum;

	// <class ghmString* mpString, offset 0x28>
	class ghmString* mpString;

	// <int32_t mStringNum, offset 0x2c>
	int32_t mStringNum;

	// <uint8_t mAdjustEnable, offset 0x30>
	uint8_t mAdjustEnable;

	// <Filler, offset 0x31>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptVariables>("ghmScriptVariables")
			// native pointer type (char*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpChar", &ghmScriptVariables::mpChar)
			.addProperty("mCharNum", &ghmScriptVariables::mCharNum)
			// native pointer type (int16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpShort", &ghmScriptVariables::mpShort)
			.addProperty("mShortNum", &ghmScriptVariables::mShortNum)
			// native pointer type (int32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpInt", &ghmScriptVariables::mpInt)
			.addProperty("mIntNum", &ghmScriptVariables::mIntNum)
			// native pointer type (int64_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpLong", &ghmScriptVariables::mpLong)
			.addProperty("mLongNum", &ghmScriptVariables::mLongNum)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpFloat", &ghmScriptVariables::mpFloat)
			.addProperty("mFloatNum", &ghmScriptVariables::mFloatNum)
			.addProperty("mpString", &ghmScriptVariables::mpString)
			.addProperty("mStringNum", &ghmScriptVariables::mStringNum)
			.addProperty("mAdjustEnable", &ghmScriptVariables::mAdjustEnable)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptVariables::mpChar) == 4, "expected mpChar to be size 4");
static_assert(sizeof(ghmScriptVariables::mCharNum) == 4, "expected mCharNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpShort) == 4, "expected mpShort to be size 4");
static_assert(sizeof(ghmScriptVariables::mShortNum) == 4, "expected mShortNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpInt) == 4, "expected mpInt to be size 4");
static_assert(sizeof(ghmScriptVariables::mIntNum) == 4, "expected mIntNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpLong) == 4, "expected mpLong to be size 4");
static_assert(sizeof(ghmScriptVariables::mLongNum) == 4, "expected mLongNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpFloat) == 4, "expected mpFloat to be size 4");
static_assert(sizeof(ghmScriptVariables::mFloatNum) == 4, "expected mFloatNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mpString) == 4, "expected mpString to be size 4");
static_assert(sizeof(ghmScriptVariables::mStringNum) == 4, "expected mStringNum to be size 4");
static_assert(sizeof(ghmScriptVariables::mAdjustEnable) == 1, "expected mAdjustEnable to be size 1");
static_assert(sizeof(class ghmScriptVariables) == 52, "expected class ghmScriptVariables to be size 52");

// class ghmScript
// 2 dependencies: class ghmListObj, class ghmScriptVariables
class ghmScript : ghmListObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct ghmScriptObjectType* mpObjectType, offset 0x10>
	struct ghmScriptObjectType* mpObjectType;

	// <int32_t mObjectTypeNum, offset 0x14>
	int32_t mObjectTypeNum;

	// <class ghmScriptObject* mpObject, offset 0x18>
	class ghmScriptObject* mpObject;

	// <class ghmScriptVariables mLocalVariables, offset 0x1c>
	class ghmScriptVariables mLocalVariables;

	// <uint32_t* mpLocalFlag, offset 0x50>
	uint32_t* mpLocalFlag;

	// <uint32_t mLocalFlagNum, offset 0x54>
	uint32_t mLocalFlagNum;

	// <struct ghmScrHeader* mpHeader, offset 0x58>
	struct ghmScrHeader* mpHeader;

	// <class ghmScriptProgFunc* mpProgFunc, offset 0x5c>
	class ghmScriptProgFunc* mpProgFunc;

	// <class ghmListObj mContextAnchor, offset 0x60>
	class ghmListObj mContextAnchor;

	// <class ghmScriptContext* mpContext, offset 0x70>
	class ghmScriptContext* mpContext;

	// <uint8_t mconvendian, offset 0x74>
	uint8_t mconvendian;

	// <Filler, offset 0x75>
	char _Filler12[3];

	// <uint32_t mFlag, offset 0x78>
	uint32_t mFlag;

	// <uint32_t mParam[0x4], offset 0x7c>
	uint32_t mParam[4];

	// <class ghmListObj mFuncAnchor, offset 0x8c>
	class ghmListObj mFuncAnchor;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScript>("ghmScript")
			.addProperty("mpObjectType", &ghmScript::mpObjectType)
			.addProperty("mObjectTypeNum", &ghmScript::mObjectTypeNum)
			.addProperty("mpObject", &ghmScript::mpObject)
			.addProperty("mLocalVariables", &ghmScript::mLocalVariables)
			// native pointer type (uint32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpLocalFlag", &ghmScript::mpLocalFlag)
			.addProperty("mLocalFlagNum", &ghmScript::mLocalFlagNum)
			.addProperty("mpHeader", &ghmScript::mpHeader)
			.addProperty("mpProgFunc", &ghmScript::mpProgFunc)
			.addProperty("mContextAnchor", &ghmScript::mContextAnchor)
			.addProperty("mpContext", &ghmScript::mpContext)
			.addProperty("mconvendian", &ghmScript::mconvendian)
			.addProperty("mFlag", &ghmScript::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mParam", &ghmScript::mParam)
			.addProperty("mFuncAnchor", &ghmScript::mFuncAnchor)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScript::mpObjectType) == 4, "expected mpObjectType to be size 4");
static_assert(sizeof(ghmScript::mObjectTypeNum) == 4, "expected mObjectTypeNum to be size 4");
static_assert(sizeof(ghmScript::mpObject) == 4, "expected mpObject to be size 4");
static_assert(sizeof(ghmScript::mLocalVariables) == 52, "expected mLocalVariables to be size 52");
static_assert(sizeof(ghmScript::mpLocalFlag) == 4, "expected mpLocalFlag to be size 4");
static_assert(sizeof(ghmScript::mLocalFlagNum) == 4, "expected mLocalFlagNum to be size 4");
static_assert(sizeof(ghmScript::mpHeader) == 4, "expected mpHeader to be size 4");
static_assert(sizeof(ghmScript::mpProgFunc) == 4, "expected mpProgFunc to be size 4");
static_assert(sizeof(ghmScript::mContextAnchor) == 16, "expected mContextAnchor to be size 16");
static_assert(sizeof(ghmScript::mpContext) == 4, "expected mpContext to be size 4");
static_assert(sizeof(ghmScript::mconvendian) == 1, "expected mconvendian to be size 1");
static_assert(sizeof(ghmScript::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmScript::mParam) == 16, "expected mParam to be size 16");
static_assert(sizeof(ghmScript::mFuncAnchor) == 16, "expected mFuncAnchor to be size 16");
static_assert(sizeof(class ghmScript) == 156, "expected class ghmScript to be size 156");

// class ghmScriptFunc
// 1 dependencies: class ghmListObj
class ghmScriptFunc : ghmListObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <char mName[0x40], offset 0x10>
	char mName[64];

	// <uint16_t mReturnType, offset 0x50>
	uint16_t mReturnType;

	// <Filler, offset 0x52>
	char _Filler3[2];

	// <class ghmScriptFuncArgBase* mpReturnValue, offset 0x54>
	class ghmScriptFuncArgBase* mpReturnValue;

	// <uint16_t mArgNum, offset 0x58>
	uint16_t mArgNum;

	// <uint16_t mArgs[0x12], offset 0x5a>
	uint16_t mArgs[18];

	// <Filler, offset 0x7e>
	char _Filler6[2];

	// <class ghmScriptFuncArgBase* mpArgs[0x12], offset 0x80>
	class ghmScriptFuncArgBase* mpArgs[18];

	// <class ghmScript* mpCallScript, offset 0xc8>
	class ghmScript* mpCallScript;

	// <uint32_t mFlag, offset 0xcc>
	uint32_t mFlag;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptFunc>("ghmScriptFunc")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mName", &ghmScriptFunc::mName)
			.addProperty("mReturnType", &ghmScriptFunc::mReturnType)
			.addProperty("mpReturnValue", &ghmScriptFunc::mpReturnValue)
			.addProperty("mArgNum", &ghmScriptFunc::mArgNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mArgs", &ghmScriptFunc::mArgs)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpArgs", &ghmScriptFunc::mpArgs)
			.addProperty("mpCallScript", &ghmScriptFunc::mpCallScript)
			.addProperty("mFlag", &ghmScriptFunc::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptFunc::mName) == 64, "expected mName to be size 64");
static_assert(sizeof(ghmScriptFunc::mReturnType) == 2, "expected mReturnType to be size 2");
static_assert(sizeof(ghmScriptFunc::mpReturnValue) == 4, "expected mpReturnValue to be size 4");
static_assert(sizeof(ghmScriptFunc::mArgNum) == 2, "expected mArgNum to be size 2");
static_assert(sizeof(ghmScriptFunc::mArgs) == 36, "expected mArgs to be size 36");
static_assert(sizeof(ghmScriptFunc::mpArgs) == 72, "expected mpArgs to be size 72");
static_assert(sizeof(ghmScriptFunc::mpCallScript) == 4, "expected mpCallScript to be size 4");
static_assert(sizeof(ghmScriptFunc::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(class ghmScriptFunc) == 208, "expected class ghmScriptFunc to be size 208");

// class HrScriptFunc
// 5 dependencies: class ghmScriptFunc, class ghmListObj, enum HrScriptFunc::SCRIPTFUNC_STS, class ghmScript, class ghmScriptVariables
class HrScriptFunc : ghmScriptFunc
{
public:
	/// 1 namespace types: enum HrScriptFunc::SCRIPTFUNC_STS

	// enum HrScriptFunc::SCRIPTFUNC_STS
	enum SCRIPTFUNC_STS : uint32_t
	{
		// Enum values

		// <SCRIPTFUNC_INIT = 0x0>
		SCRIPTFUNC_INIT = 0,

		// <SCRIPTFUNC_IDLE = 0x1>
		SCRIPTFUNC_IDLE = 1,

		// <SCRIPTFUNC_TERM = 0x2>
		SCRIPTFUNC_TERM = 2,

		// <SCRIPTFUNC_MAX = 0x3>
		SCRIPTFUNC_MAX = 3

	};


	/// Struct member variables

	// <class ghmScriptFunc field_0, offset 0x0>
	// class ghmScriptFunc Super;

	// <enum HrScriptFunc::SCRIPTFUNC_STS m_Status, offset 0xd0>
	enum HrScriptFunc::SCRIPTFUNC_STS m_Status;

	// <uint8_t m_WaitVsync, offset 0xd4>
	uint8_t m_WaitVsync;

	// <Filler, offset 0xd5>
	char _Filler3[3];

	// <void* m_pScrData, offset 0xd8>
	void* m_pScrData;

	// <class ghmScript m_Script, offset 0xdc>
	class ghmScript m_Script;

	// <char m_SubName[0x10], offset 0x178>
	char m_SubName[16];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrScriptFunc>("HrScriptFunc")
			.addProperty("m_Status", &HrScriptFunc::m_Status)
			.addProperty("m_WaitVsync", &HrScriptFunc::m_WaitVsync)
			// void type not supported in LuaBridge
			//.addProperty("m_pScrData", &HrScriptFunc::m_pScrData)
			.addProperty("m_Script", &HrScriptFunc::m_Script)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_SubName", &HrScriptFunc::m_SubName)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrScriptFunc::m_Status) == 4, "expected m_Status to be size 4");
static_assert(sizeof(HrScriptFunc::m_WaitVsync) == 1, "expected m_WaitVsync to be size 1");
static_assert(sizeof(HrScriptFunc::m_pScrData) == 4, "expected m_pScrData to be size 4");
static_assert(sizeof(HrScriptFunc::m_Script) == 156, "expected m_Script to be size 156");
static_assert(sizeof(HrScriptFunc::m_SubName) == 16, "expected m_SubName to be size 16");
static_assert(sizeof(class HrScriptFunc) == 392, "expected class HrScriptFunc to be size 392");

// class ghmScriptBase
// no dependencies
class ghmScriptBase
{
public:
	/// No namespace types
	/// Struct member variables

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptBase>("ghmScriptBase")
		.endClass();
	}
#endif
};
static_assert(sizeof(class ghmScriptBase) == 1, "expected class ghmScriptBase to be size 1");

// class CCameraCollision
// no dependencies
class CCameraCollision
{
public:
	/// No namespace types
	/// Struct member variables

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraCollision>("CCameraCollision")
		.endClass();
	}
#endif
};
static_assert(sizeof(class CCameraCollision) == 1, "expected class CCameraCollision to be size 1");

// class FkPjLib
// no dependencies
class FkPjLib
{
public:
	/// 4 namespace types: float FkPjLib::GetCharaNowPlayMotionTick(class mHRChara* arg1), uint8_t FkPjLib::CheckValidCharaPtr(class mHRChara* arg1), uint8_t FkPjLib::CheckCharSurroundStageCollisionAndAdjustSafetyPos(class mHRChara* arg1, float arg2, float arg3), class mHRChara* FkPjLib::GetCharaPtrByNpcID(int32_t const arg1, uint8_t const arg2)

	// TODO: Function 'float FkPjLib::GetCharaNowPlayMotionTick(class mHRChara* arg1)'
	// TODO: Function 'uint8_t FkPjLib::CheckValidCharaPtr(class mHRChara* arg1)'
	// TODO: Function 'uint8_t FkPjLib::CheckCharSurroundStageCollisionAndAdjustSafetyPos(class mHRChara* arg1, float arg2, float arg3)'
	// TODO: Function 'class mHRChara* FkPjLib::GetCharaPtrByNpcID(int32_t const arg1, uint8_t const arg2)'

	/// Struct member variables

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkPjLib>("FkPjLib")
		.endClass();
	}
#endif
};
static_assert(sizeof(class FkPjLib) == 1, "expected class FkPjLib to be size 1");

// class ghmScriptFuncArgBase
// 1 dependencies: class ghmScriptBase
class ghmScriptFuncArgBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0xe], offset 0x0>
	void* (* field_0)[0xe];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptFuncArgBase>("ghmScriptFuncArgBase")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmScriptFuncArgBase::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptFuncArgBase::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(class ghmScriptFuncArgBase) == 4, "expected class ghmScriptFuncArgBase to be size 4");

// struct ghmScriptObjectType
// no dependencies
struct ghmScriptObjectType
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t (* mpMethod)(class ghmScript*, uint16_t, uint16_t), offset 0x0>
	uint8_t (* mpMethod)(class ghmScript*, uint16_t, uint16_t);

	// <int32_t mObjectNum, offset 0x4>
	int32_t mObjectNum;

	// <int32_t mPropCharNum, offset 0x8>
	int32_t mPropCharNum;

	// <int32_t mPropShortNum, offset 0xc>
	int32_t mPropShortNum;

	// <int32_t mPropIntNum, offset 0x10>
	int32_t mPropIntNum;

	// <int32_t mPropLongNum, offset 0x14>
	int32_t mPropLongNum;

	// <int32_t mPropFloatNum, offset 0x18>
	int32_t mPropFloatNum;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptObjectType>("ghmScriptObjectType")
			// delegates are not supported in LuaBridge
			//.addProperty("mpMethod", &ghmScriptObjectType::mpMethod)
			.addProperty("mObjectNum", &ghmScriptObjectType::mObjectNum)
			.addProperty("mPropCharNum", &ghmScriptObjectType::mPropCharNum)
			.addProperty("mPropShortNum", &ghmScriptObjectType::mPropShortNum)
			.addProperty("mPropIntNum", &ghmScriptObjectType::mPropIntNum)
			.addProperty("mPropLongNum", &ghmScriptObjectType::mPropLongNum)
			.addProperty("mPropFloatNum", &ghmScriptObjectType::mPropFloatNum)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptObjectType::mpMethod) == 4, "expected mpMethod to be size 4");
static_assert(sizeof(ghmScriptObjectType::mObjectNum) == 4, "expected mObjectNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropCharNum) == 4, "expected mPropCharNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropShortNum) == 4, "expected mPropShortNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropIntNum) == 4, "expected mPropIntNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropLongNum) == 4, "expected mPropLongNum to be size 4");
static_assert(sizeof(ghmScriptObjectType::mPropFloatNum) == 4, "expected mPropFloatNum to be size 4");
static_assert(sizeof(struct ghmScriptObjectType) == 28, "expected struct ghmScriptObjectType to be size 28");

// class ghmScriptObject
// no dependencies
class ghmScriptObject
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmScriptVariables* mpProperty, offset 0x0>
	class ghmScriptVariables* mpProperty;

	// <struct ghmScriptObjectType* mpType, offset 0x4>
	struct ghmScriptObjectType* mpType;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptObject>("ghmScriptObject")
			.addProperty("mpProperty", &ghmScriptObject::mpProperty)
			.addProperty("mpType", &ghmScriptObject::mpType)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptObject::mpProperty) == 4, "expected mpProperty to be size 4");
static_assert(sizeof(ghmScriptObject::mpType) == 4, "expected mpType to be size 4");
static_assert(sizeof(class ghmScriptObject) == 8, "expected class ghmScriptObject to be size 8");

// class ghmString
// no dependencies
class ghmString
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <char* mpBuff, offset 0x4>
	char* mpBuff;

	// <int32_t mAllocSize, offset 0x8>
	int32_t mAllocSize;

	// <int32_t mLength, offset 0xc>
	int32_t mLength;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmString>("ghmString")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmString::field_0)
			// native pointer type (char*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpBuff", &ghmString::mpBuff)
			.addProperty("mAllocSize", &ghmString::mAllocSize)
			.addProperty("mLength", &ghmString::mLength)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmString::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmString::mpBuff) == 4, "expected mpBuff to be size 4");
static_assert(sizeof(ghmString::mAllocSize) == 4, "expected mAllocSize to be size 4");
static_assert(sizeof(ghmString::mLength) == 4, "expected mLength to be size 4");
static_assert(sizeof(class ghmString) == 16, "expected class ghmString to be size 16");

// struct ghmScrHeader
// no dependencies
struct ghmScrHeader
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t mMagicNoStr[0x4], offset 0x0>
	uint8_t mMagicNoStr[4];

	// <uint32_t mFlag, offset 0x4>
	uint32_t mFlag;

	// <uint16_t mIntFuncNum, offset 0x8>
	uint16_t mIntFuncNum;

	// <uint16_t mExtFuncNum, offset 0xa>
	uint16_t mExtFuncNum;

	// <struct ghmScrFuncHeader** mppIntFuncTable, offset 0xc>
	struct ghmScrFuncHeader** mppIntFuncTable;

	// <struct ghmScrFuncHeader** mppExtFuncTable, offset 0x10>
	struct ghmScrFuncHeader** mppExtFuncTable;

	// <uint16_t mStringNum, offset 0x14>
	uint16_t mStringNum;

	// <uint16_t mStringNumPad, offset 0x16>
	uint16_t mStringNumPad;

	// <char const** mppString, offset 0x18>
	char const** mppString;

	// <uint32_t mPad[0x1], offset 0x1c>
	uint32_t mPad[1];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScrHeader>("ghmScrHeader")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mMagicNoStr", &ghmScrHeader::mMagicNoStr)
			.addProperty("mFlag", &ghmScrHeader::mFlag)
			.addProperty("mIntFuncNum", &ghmScrHeader::mIntFuncNum)
			.addProperty("mExtFuncNum", &ghmScrHeader::mExtFuncNum)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppIntFuncTable", &ghmScrHeader::mppIntFuncTable)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppExtFuncTable", &ghmScrHeader::mppExtFuncTable)
			.addProperty("mStringNum", &ghmScrHeader::mStringNum)
			.addProperty("mStringNumPad", &ghmScrHeader::mStringNumPad)
			// pointer to pointer is not supported in LuaBridge
			//.addProperty("mppString", &ghmScrHeader::mppString)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmScrHeader::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScrHeader::mMagicNoStr) == 4, "expected mMagicNoStr to be size 4");
static_assert(sizeof(ghmScrHeader::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmScrHeader::mIntFuncNum) == 2, "expected mIntFuncNum to be size 2");
static_assert(sizeof(ghmScrHeader::mExtFuncNum) == 2, "expected mExtFuncNum to be size 2");
static_assert(sizeof(ghmScrHeader::mppIntFuncTable) == 4, "expected mppIntFuncTable to be size 4");
static_assert(sizeof(ghmScrHeader::mppExtFuncTable) == 4, "expected mppExtFuncTable to be size 4");
static_assert(sizeof(ghmScrHeader::mStringNum) == 2, "expected mStringNum to be size 2");
static_assert(sizeof(ghmScrHeader::mStringNumPad) == 2, "expected mStringNumPad to be size 2");
static_assert(sizeof(ghmScrHeader::mppString) == 4, "expected mppString to be size 4");
static_assert(sizeof(ghmScrHeader::mPad) == 4, "expected mPad to be size 4");
static_assert(sizeof(struct ghmScrHeader) == 32, "expected struct ghmScrHeader to be size 32");

// struct ghmScrFuncHeader
// no dependencies
struct ghmScrFuncHeader
{
public:
	/// No namespace types
	/// Struct member variables

	// <char const* mpName, offset 0x0>
	char const* mpName;

	// <uint16_t mReturnType, offset 0x4>
	uint16_t mReturnType;

	// <uint16_t mArgNum, offset 0x6>
	uint16_t mArgNum;

	// <uint16_t* mpArgs, offset 0x8>
	uint16_t* mpArgs;

	// <uint16_t* mpDataTop, offset 0xc>
	uint16_t* mpDataTop;

	// <uint32_t mDataSize, offset 0x10>
	uint32_t mDataSize;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag;

	// <uint32_t mPad[0x2], offset 0x18>
	uint32_t mPad[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScrFuncHeader>("ghmScrFuncHeader")
			.addProperty("mpName", &ghmScrFuncHeader::mpName)
			.addProperty("mReturnType", &ghmScrFuncHeader::mReturnType)
			.addProperty("mArgNum", &ghmScrFuncHeader::mArgNum)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpArgs", &ghmScrFuncHeader::mpArgs)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpDataTop", &ghmScrFuncHeader::mpDataTop)
			.addProperty("mDataSize", &ghmScrFuncHeader::mDataSize)
			.addProperty("mFlag", &ghmScrFuncHeader::mFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &ghmScrFuncHeader::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScrFuncHeader::mpName) == 4, "expected mpName to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mReturnType) == 2, "expected mReturnType to be size 2");
static_assert(sizeof(ghmScrFuncHeader::mArgNum) == 2, "expected mArgNum to be size 2");
static_assert(sizeof(ghmScrFuncHeader::mpArgs) == 4, "expected mpArgs to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mpDataTop) == 4, "expected mpDataTop to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mDataSize) == 4, "expected mDataSize to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(ghmScrFuncHeader::mPad) == 8, "expected mPad to be size 8");
static_assert(sizeof(struct ghmScrFuncHeader) == 32, "expected struct ghmScrFuncHeader to be size 32");

// class ghmScriptProgFunc
// 3 dependencies: class ghmListObj, class ghmScriptBase, class ghmScriptFunc
class ghmScriptProgFunc : ghmListObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class ghmScriptFunc mFunc, offset 0x10>
	class ghmScriptFunc mFunc;

	// <uint8_t (* mpCallback)(class ghmScriptFunc*), offset 0xe0>
	uint8_t (* mpCallback)(class ghmScriptFunc*);

	// <uint32_t mHashKey, offset 0xe4>
	uint32_t mHashKey;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptProgFunc>("ghmScriptProgFunc")
			.addProperty("mFunc", &ghmScriptProgFunc::mFunc)
			// delegates are not supported in LuaBridge
			//.addProperty("mpCallback", &ghmScriptProgFunc::mpCallback)
			.addProperty("mHashKey", &ghmScriptProgFunc::mHashKey)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptProgFunc::mFunc) == 208, "expected mFunc to be size 208");
static_assert(sizeof(ghmScriptProgFunc::mpCallback) == 4, "expected mpCallback to be size 4");
static_assert(sizeof(ghmScriptProgFunc::mHashKey) == 4, "expected mHashKey to be size 4");
static_assert(sizeof(class ghmScriptProgFunc) == 232, "expected class ghmScriptProgFunc to be size 232");

// struct ghmScriptStackData
// 1 dependencies: class ghmString
struct ghmScriptStackData
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint16_t mData[0x5], offset 0x0>
	uint16_t mData[5];

	// <uint8_t mSize, offset 0xa>
	uint8_t mSize;

	// <uint8_t mType, offset 0xb>
	uint8_t mType;

	// <Filler, offset 0xc>
	char _Filler3[4];

	// <float mFloat, offset 0x10>
	float mFloat;

	// <Filler, offset 0x14>
	char _Filler4[4];

	// <class ghmString mString, offset 0x18>
	class ghmString mString;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptStackData>("ghmScriptStackData")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mData", &ghmScriptStackData::mData)
			.addProperty("mSize", &ghmScriptStackData::mSize)
			.addProperty("mType", &ghmScriptStackData::mType)
			.addProperty("mFloat", &ghmScriptStackData::mFloat)
			.addProperty("mString", &ghmScriptStackData::mString)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptStackData::mData) == 10, "expected mData to be size 10");
static_assert(sizeof(ghmScriptStackData::mSize) == 1, "expected mSize to be size 1");
static_assert(sizeof(ghmScriptStackData::mType) == 1, "expected mType to be size 1");
static_assert(sizeof(ghmScriptStackData::mFloat) == 4, "expected mFloat to be size 4");
static_assert(sizeof(ghmScriptStackData::mString) == 16, "expected mString to be size 16");
static_assert(sizeof(struct ghmScriptStackData) == 40, "expected struct ghmScriptStackData to be size 40");

// class ghmScriptStack
// no dependencies
class ghmScriptStack
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[744];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptStack>("ghmScriptStack")
		.endClass();
	}
#endif
};
static_assert(sizeof(class ghmScriptStack) == 744, "expected class ghmScriptStack to be size 744");

// class ghmScriptContext
// 5 dependencies: class ghmListObj, class ghmScriptVariables, class ghmScriptStack, struct ghmScriptStackData, class ghmString
class ghmScriptContext : ghmListObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class ghmScript* mpContainer, offset 0x10>
	class ghmScript* mpContainer;

	// <class ghmScript* mpDataSource, offset 0x14>
	class ghmScript* mpDataSource;

	// <class ghmScriptVariables mAutoVariables, offset 0x18>
	class ghmScriptVariables mAutoVariables;

	// <struct ghmScrFuncHeader* mpFuncHeader, offset 0x4c>
	struct ghmScrFuncHeader* mpFuncHeader;

	// <uint16_t* mpCode, offset 0x50>
	uint16_t* mpCode;

	// <int32_t mCodeCnt, offset 0x54>
	int32_t mCodeCnt;

	// <class ghmScriptStack mStack, offset 0x58>
	class ghmScriptStack mStack;

	// <struct ghmScriptStackData mReturnData, offset 0x340>
	struct ghmScriptStackData mReturnData;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmScriptContext>("ghmScriptContext")
			.addProperty("mpContainer", &ghmScriptContext::mpContainer)
			.addProperty("mpDataSource", &ghmScriptContext::mpDataSource)
			.addProperty("mAutoVariables", &ghmScriptContext::mAutoVariables)
			.addProperty("mpFuncHeader", &ghmScriptContext::mpFuncHeader)
			// native pointer type (uint16_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("mpCode", &ghmScriptContext::mpCode)
			.addProperty("mCodeCnt", &ghmScriptContext::mCodeCnt)
			.addProperty("mStack", &ghmScriptContext::mStack)
			.addProperty("mReturnData", &ghmScriptContext::mReturnData)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmScriptContext::mpContainer) == 4, "expected mpContainer to be size 4");
static_assert(sizeof(ghmScriptContext::mpDataSource) == 4, "expected mpDataSource to be size 4");
static_assert(sizeof(ghmScriptContext::mAutoVariables) == 52, "expected mAutoVariables to be size 52");
static_assert(sizeof(ghmScriptContext::mpFuncHeader) == 4, "expected mpFuncHeader to be size 4");
static_assert(sizeof(ghmScriptContext::mpCode) == 4, "expected mpCode to be size 4");
static_assert(sizeof(ghmScriptContext::mCodeCnt) == 4, "expected mCodeCnt to be size 4");
static_assert(sizeof(ghmScriptContext::mStack) == 744, "expected mStack to be size 744");
static_assert(sizeof(ghmScriptContext::mReturnData) == 40, "expected mReturnData to be size 40");
static_assert(sizeof(class ghmScriptContext) == 872, "expected class ghmScriptContext to be size 872");

// class EveCorn
// 1 dependencies: struct Vec
class EveCorn
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t flag, offset 0x0>
	uint8_t flag;

	// <Filler, offset 0x1>
	char _Filler1[3];

	// <float mScale, offset 0x4>
	float mScale;

	// <uint32_t mColor, offset 0x8>
	uint32_t mColor;

	// <struct Vec mRootPosition, offset 0xc>
	struct Vec mRootPosition;

	// <float mRootRotY, offset 0x18>
	float mRootRotY;

	// <float mRootRotY2, offset 0x1c>
	float mRootRotY2;

	// <int32_t mMoveProcess, offset 0x20>
	int32_t mMoveProcess;

	// <int32_t mMakerType, offset 0x24>
	int32_t mMakerType;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EveCorn>("EveCorn")
			.addProperty("flag", &EveCorn::flag)
			.addProperty("mScale", &EveCorn::mScale)
			.addProperty("mColor", &EveCorn::mColor)
			.addProperty("mRootPosition", &EveCorn::mRootPosition)
			.addProperty("mRootRotY", &EveCorn::mRootRotY)
			.addProperty("mRootRotY2", &EveCorn::mRootRotY2)
			.addProperty("mMoveProcess", &EveCorn::mMoveProcess)
			.addProperty("mMakerType", &EveCorn::mMakerType)
		.endClass();
	}
#endif
};
static_assert(sizeof(EveCorn::flag) == 1, "expected flag to be size 1");
static_assert(sizeof(EveCorn::mScale) == 4, "expected mScale to be size 4");
static_assert(sizeof(EveCorn::mColor) == 4, "expected mColor to be size 4");
static_assert(sizeof(EveCorn::mRootPosition) == 12, "expected mRootPosition to be size 12");
static_assert(sizeof(EveCorn::mRootRotY) == 4, "expected mRootRotY to be size 4");
static_assert(sizeof(EveCorn::mRootRotY2) == 4, "expected mRootRotY2 to be size 4");
static_assert(sizeof(EveCorn::mMoveProcess) == 4, "expected mMoveProcess to be size 4");
static_assert(sizeof(EveCorn::mMakerType) == 4, "expected mMakerType to be size 4");
static_assert(sizeof(class EveCorn) == 40, "expected class EveCorn to be size 40");

// class EventAreaCamera
// 1 dependencies: class ghmListObj
class EventAreaCamera : ghmListObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <struct EVENTAREACAMERA_DATA* pd, offset 0x10>
	struct EVENTAREACAMERA_DATA* pd;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EventAreaCamera>("EventAreaCamera")
			.addProperty("pd", &EventAreaCamera::pd)
		.endClass();
	}
#endif
};
static_assert(sizeof(EventAreaCamera::pd) == 4, "expected pd to be size 4");
static_assert(sizeof(class EventAreaCamera) == 20, "expected class EventAreaCamera to be size 20");

// enum HRCAMERA_MODE
enum HRCAMERA_MODE : uint32_t
{
	// Enum values

	// <HRCAMERA_MODE_NONE = 0xffffffffffffffff>
	HRCAMERA_MODE_NONE = UINT32_MAX,

	// <HRCAMERA_MODE_RAIL = 0x0>
	HRCAMERA_MODE_RAIL = 0,

	// <HRCAMERA_MODE_TEPPEI = 0x1>
	HRCAMERA_MODE_TEPPEI = 1,

	// <HRCAMERA_MODE_MOTION = 0x2>
	HRCAMERA_MODE_MOTION = 2,

	// <HRCAMERA_MODE_NORMAL = 0x3>
	HRCAMERA_MODE_NORMAL = 3,

	// <HRCAMERA_MODE_FREE = 0x4>
	HRCAMERA_MODE_FREE = 4

};

// struct EVENTAREACAMERA_DATA
// 2 dependencies: struct Vec, enum HRCAMERA_MODE
struct EVENTAREACAMERA_DATA
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct Vec mCenter, offset 0x0>
	struct Vec mCenter;

	// <struct Vec mCameraPos, offset 0xc>
	struct Vec mCameraPos;

	// <struct Vec mTargetPos, offset 0x18>
	struct Vec mTargetPos;

	// <struct Vec mCameraDirec, offset 0x24>
	struct Vec mCameraDirec;

	// <float mCameraDist, offset 0x30>
	float mCameraDist;

	// <float mRadius, offset 0x34>
	float mRadius;

	// <int32_t mWalkWait, offset 0x38>
	int32_t mWalkWait;

	// <uint32_t mScriptHandle, offset 0x3c>
	uint32_t mScriptHandle;

	// <uint8_t mDone, offset 0x40>
	uint8_t mDone;

	// <uint8_t mFirstTouch, offset 0x41>
	uint8_t mFirstTouch;

	// <char mStageName[0x10], offset 0x42>
	char mStageName[16];

	// <Filler, offset 0x52>
	char _Filler11[2];

	// <int32_t mStatus, offset 0x54>
	int32_t mStatus;

	// <enum HRCAMERA_MODE mCameraModeSave, offset 0x58>
	enum HRCAMERA_MODE mCameraModeSave;

	// <int32_t mType, offset 0x5c>
	int32_t mType;

	// <class EventAreaCircle* mpEvAreaCircle, offset 0x60>
	class EventAreaCircle* mpEvAreaCircle;

	// <class TGmf* mpGmfTgt, offset 0x64>
	class TGmf* mpGmfTgt;

	// <uint8_t mEventEndCameraHold, offset 0x68>
	uint8_t mEventEndCameraHold;

	// <uint8_t mEventEndPcNoRefresh, offset 0x69>
	uint8_t mEventEndPcNoRefresh;

	// <Filler, offset 0x6a>
	char _Filler[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EVENTAREACAMERA_DATA>("EVENTAREACAMERA_DATA")
			.addProperty("mCenter", &EVENTAREACAMERA_DATA::mCenter)
			.addProperty("mCameraPos", &EVENTAREACAMERA_DATA::mCameraPos)
			.addProperty("mTargetPos", &EVENTAREACAMERA_DATA::mTargetPos)
			.addProperty("mCameraDirec", &EVENTAREACAMERA_DATA::mCameraDirec)
			.addProperty("mCameraDist", &EVENTAREACAMERA_DATA::mCameraDist)
			.addProperty("mRadius", &EVENTAREACAMERA_DATA::mRadius)
			.addProperty("mWalkWait", &EVENTAREACAMERA_DATA::mWalkWait)
			.addProperty("mScriptHandle", &EVENTAREACAMERA_DATA::mScriptHandle)
			.addProperty("mDone", &EVENTAREACAMERA_DATA::mDone)
			.addProperty("mFirstTouch", &EVENTAREACAMERA_DATA::mFirstTouch)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mStageName", &EVENTAREACAMERA_DATA::mStageName)
			.addProperty("mStatus", &EVENTAREACAMERA_DATA::mStatus)
			.addProperty("mCameraModeSave", &EVENTAREACAMERA_DATA::mCameraModeSave)
			.addProperty("mType", &EVENTAREACAMERA_DATA::mType)
			.addProperty("mpEvAreaCircle", &EVENTAREACAMERA_DATA::mpEvAreaCircle)
			.addProperty("mpGmfTgt", &EVENTAREACAMERA_DATA::mpGmfTgt)
			.addProperty("mEventEndCameraHold", &EVENTAREACAMERA_DATA::mEventEndCameraHold)
			.addProperty("mEventEndPcNoRefresh", &EVENTAREACAMERA_DATA::mEventEndPcNoRefresh)
		.endClass();
	}
#endif
};
static_assert(sizeof(EVENTAREACAMERA_DATA::mCenter) == 12, "expected mCenter to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraPos) == 12, "expected mCameraPos to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mTargetPos) == 12, "expected mTargetPos to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraDirec) == 12, "expected mCameraDirec to be size 12");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraDist) == 4, "expected mCameraDist to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mRadius) == 4, "expected mRadius to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mWalkWait) == 4, "expected mWalkWait to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mScriptHandle) == 4, "expected mScriptHandle to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mDone) == 1, "expected mDone to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mFirstTouch) == 1, "expected mFirstTouch to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mStageName) == 16, "expected mStageName to be size 16");
static_assert(sizeof(EVENTAREACAMERA_DATA::mStatus) == 4, "expected mStatus to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mCameraModeSave) == 4, "expected mCameraModeSave to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mType) == 4, "expected mType to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mpEvAreaCircle) == 4, "expected mpEvAreaCircle to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mpGmfTgt) == 4, "expected mpGmfTgt to be size 4");
static_assert(sizeof(EVENTAREACAMERA_DATA::mEventEndCameraHold) == 1, "expected mEventEndCameraHold to be size 1");
static_assert(sizeof(EVENTAREACAMERA_DATA::mEventEndPcNoRefresh) == 1, "expected mEventEndPcNoRefresh to be size 1");
static_assert(sizeof(struct EVENTAREACAMERA_DATA) == 108, "expected struct EVENTAREACAMERA_DATA to be size 108");

// class EffectDriftMark
// no dependencies
class EffectDriftMark
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[388];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectDriftMark>("EffectDriftMark")
		.endClass();
	}
#endif
};
static_assert(sizeof(class EffectDriftMark) == 388, "expected class EffectDriftMark to be size 388");

// class EffectKeepSmoke
// 10 dependencies: class HrTask, class rPrimUnific, enum GHMR_PROJECT, enum GHMR_PRIMTYPE, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT
class EffectKeepSmoke : HrTask
{
public:
	/// No namespace types
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Filler, offset 0x51>
	char _Filler2[3];

	// <class rPrimUnific m_QuadUni, offset 0x54>
	class rPrimUnific m_QuadUni;

	// <class rQuad* m_pQuadArray, offset 0x74>
	class rQuad* m_pQuadArray;

	// <struct tagGHMR_TEX m_SubTex, offset 0x78>
	struct tagGHMR_TEX m_SubTex;

	// <struct Vec* m_pMoveVecArray, offset 0xa0>
	struct Vec* m_pMoveVecArray;

	// <int32_t* m_pCountArray, offset 0xa4>
	int32_t* m_pCountArray;

	// <float* m_pSpeedArray, offset 0xa8>
	float* m_pSpeedArray;

	// <int32_t m_PrimNum, offset 0xac>
	int32_t m_PrimNum;

	// <float m_Scale, offset 0xb0>
	float m_Scale;

	// <int32_t m_FadeTime, offset 0xb4>
	int32_t m_FadeTime;

	// <void* m_pRes, offset 0xb8>
	void* m_pRes;

	// <float m_TimeCount, offset 0xbc>
	float m_TimeCount;

	// <int32_t m_TimeFrame, offset 0xc0>
	int32_t m_TimeFrame;

	// <float m_TimeRate, offset 0xc4>
	float m_TimeRate;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectKeepSmoke>("EffectKeepSmoke")
			.addProperty("m_Flag", &EffectKeepSmoke::m_Flag)
			.addProperty("m_QuadUni", &EffectKeepSmoke::m_QuadUni)
			.addProperty("m_pQuadArray", &EffectKeepSmoke::m_pQuadArray)
			.addProperty("m_SubTex", &EffectKeepSmoke::m_SubTex)
			.addProperty("m_pMoveVecArray", &EffectKeepSmoke::m_pMoveVecArray)
			// native pointer type (int32_t*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pCountArray", &EffectKeepSmoke::m_pCountArray)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pSpeedArray", &EffectKeepSmoke::m_pSpeedArray)
			.addProperty("m_PrimNum", &EffectKeepSmoke::m_PrimNum)
			.addProperty("m_Scale", &EffectKeepSmoke::m_Scale)
			.addProperty("m_FadeTime", &EffectKeepSmoke::m_FadeTime)
			// void type not supported in LuaBridge
			//.addProperty("m_pRes", &EffectKeepSmoke::m_pRes)
			.addProperty("m_TimeCount", &EffectKeepSmoke::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectKeepSmoke::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectKeepSmoke::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectKeepSmoke::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectKeepSmoke::m_QuadUni) == 32, "expected m_QuadUni to be size 32");
static_assert(sizeof(EffectKeepSmoke::m_pQuadArray) == 4, "expected m_pQuadArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_SubTex) == 40, "expected m_SubTex to be size 40");
static_assert(sizeof(EffectKeepSmoke::m_pMoveVecArray) == 4, "expected m_pMoveVecArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pCountArray) == 4, "expected m_pCountArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pSpeedArray) == 4, "expected m_pSpeedArray to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_PrimNum) == 4, "expected m_PrimNum to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_FadeTime) == 4, "expected m_FadeTime to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_pRes) == 4, "expected m_pRes to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeFrame) == 4, "expected m_TimeFrame to be size 4");
static_assert(sizeof(EffectKeepSmoke::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(class EffectKeepSmoke) == 200, "expected class EffectKeepSmoke to be size 200");

// class rQuad
// no dependencies
class rQuad
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[172];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rQuad>("rQuad")
		.endClass();
	}
#endif
};
static_assert(sizeof(class rQuad) == 172, "expected class rQuad to be size 172");

// struct GXColor
// no dependencies
struct GXColor
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint32_t PackedValue, offset 0x0>
	uint32_t PackedValue;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GXColor>("GXColor")
			.addProperty("PackedValue", &GXColor::PackedValue)
		.endClass();
	}
#endif
};
static_assert(sizeof(GXColor::PackedValue) == 4, "expected PackedValue to be size 4");
static_assert(sizeof(struct GXColor) == 4, "expected struct GXColor to be size 4");

// enum GHMR_BLEND
enum GHMR_BLEND : uint32_t
{
	// Enum values

	// <GHMR_BLEND_ADD = 0x0>
	GHMR_BLEND_ADD = 0,

	// <GHMR_BLEND_SUB = 0x1>
	GHMR_BLEND_SUB = 1,

	// <GHMR_BLEND_MUL = 0x2>
	GHMR_BLEND_MUL = 2,

	// <GHMR_BLEND_ALPHA = 0x3>
	GHMR_BLEND_ALPHA = 3,

	// <GHMR_BLEND_NONE = 0x4>
	GHMR_BLEND_NONE = 4,

	// <GHMR_BLEND_NUM = 0x5>
	GHMR_BLEND_NUM = 5

};

// class EffectFixFire
// 11 dependencies: class HrTask, struct EffectFixFire::Object, struct Vec, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, enum GHMR_BLEND, struct GXColor
class EffectFixFire : HrTask
{
public:
	/// 1 namespace types: struct EffectFixFire::Object

	// struct EffectFixFire::Object
	// 1 dependencies: struct Vec
	struct Object
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <EffectFixFire::Object* m_pNext, offset 0x0>
		Object* m_pNext;

		// <EffectFixFire::Object* m_pPrev, offset 0x4>
		Object* m_pPrev;

		// <uint8_t m_Fade, offset 0x8>
		uint8_t m_Fade;

		// <Filler, offset 0x9>
		char _Filler3[3];

		// <struct Vec m_MoveVec, offset 0xc>
		struct Vec m_MoveVec;

		// <struct Vec m_LocalPos, offset 0x18>
		struct Vec m_LocalPos;

		// <float m_Scale, offset 0x24>
		float m_Scale;

		// <float m_u, offset 0x28>
		float m_u;

		// <float m_v, offset 0x2c>
		float m_v;

		// <int32_t m_Alpha, offset 0x30>
		int32_t m_Alpha;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectFixFire::Object>("EffectFixFire::Object")
				.addProperty("m_pNext", &EffectFixFire::Object::m_pNext)
				.addProperty("m_pPrev", &EffectFixFire::Object::m_pPrev)
				.addProperty("m_Fade", &EffectFixFire::Object::m_Fade)
				.addProperty("m_MoveVec", &EffectFixFire::Object::m_MoveVec)
				.addProperty("m_LocalPos", &EffectFixFire::Object::m_LocalPos)
				.addProperty("m_Scale", &EffectFixFire::Object::m_Scale)
				.addProperty("m_u", &EffectFixFire::Object::m_u)
				.addProperty("m_v", &EffectFixFire::Object::m_v)
				.addProperty("m_Alpha", &EffectFixFire::Object::m_Alpha)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFixFire::Object::m_pNext) == 4, "expected m_pNext to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_pPrev) == 4, "expected m_pPrev to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_Fade) == 1, "expected m_Fade to be size 1");
	static_assert(sizeof(EffectFixFire::Object::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
	static_assert(sizeof(EffectFixFire::Object::m_LocalPos) == 12, "expected m_LocalPos to be size 12");
	static_assert(sizeof(EffectFixFire::Object::m_Scale) == 4, "expected m_Scale to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_u) == 4, "expected m_u to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_v) == 4, "expected m_v to be size 4");
	static_assert(sizeof(EffectFixFire::Object::m_Alpha) == 4, "expected m_Alpha to be size 4");
	static_assert(sizeof(struct EffectFixFire::Object) == 52, "expected struct EffectFixFire::Object to be size 52");


	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Filler, offset 0x51>
	char _Filler2[3];

	// <struct EffectFixFire::Object* m_pObject, offset 0x54>
	struct EffectFixFire::Object* m_pObject;

	// <struct EffectFixFire::Object m_ValidFirst, offset 0x58>
	struct EffectFixFire::Object m_ValidFirst;

	// <struct EffectFixFire::Object m_ValidLast, offset 0x8c>
	struct EffectFixFire::Object m_ValidLast;

	// <struct EffectFixFire::Object m_FreeFirst, offset 0xc0>
	struct EffectFixFire::Object m_FreeFirst;

	// <struct EffectFixFire::Object m_FreeLast, offset 0xf4>
	struct EffectFixFire::Object m_FreeLast;

	// <struct tagGHMR_TEX m_Tex, offset 0x128>
	struct tagGHMR_TEX m_Tex;

	// <enum GHMR_BLEND m_BlendMode, offset 0x150>
	enum GHMR_BLEND m_BlendMode;

	// <int32_t m_FadeAlphaSpeed, offset 0x154>
	int32_t m_FadeAlphaSpeed;

	// <int32_t m_PrimNum, offset 0x158>
	int32_t m_PrimNum;

	// <int32_t m_ValidPrimNum, offset 0x15c>
	int32_t m_ValidPrimNum;

	// <struct Vec m_CenterPos, offset 0x160>
	struct Vec m_CenterPos;

	// <struct Vec m_Direc, offset 0x16c>
	struct Vec m_Direc;

	// <struct Vec m_RotRange, offset 0x178>
	struct Vec m_RotRange;

	// <float m_Speed, offset 0x184>
	float m_Speed;

	// <struct GXColor m_Color, offset 0x188>
	struct GXColor m_Color;

	// <float m_Scale, offset 0x18c>
	float m_Scale;

	// <float m_ScaleAnime, offset 0x190>
	float m_ScaleAnime;

	// <float m_TimeCount, offset 0x194>
	float m_TimeCount;

	// <int32_t m_TimeFrame, offset 0x198>
	int32_t m_TimeFrame;

	// <float m_TimeRate, offset 0x19c>
	float m_TimeRate;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectFixFire>("EffectFixFire")
			.addProperty("m_Flag", &EffectFixFire::m_Flag)
			.addProperty("m_pObject", &EffectFixFire::m_pObject)
			.addProperty("m_ValidFirst", &EffectFixFire::m_ValidFirst)
			.addProperty("m_ValidLast", &EffectFixFire::m_ValidLast)
			.addProperty("m_FreeFirst", &EffectFixFire::m_FreeFirst)
			.addProperty("m_FreeLast", &EffectFixFire::m_FreeLast)
			.addProperty("m_Tex", &EffectFixFire::m_Tex)
			.addProperty("m_BlendMode", &EffectFixFire::m_BlendMode)
			.addProperty("m_FadeAlphaSpeed", &EffectFixFire::m_FadeAlphaSpeed)
			.addProperty("m_PrimNum", &EffectFixFire::m_PrimNum)
			.addProperty("m_ValidPrimNum", &EffectFixFire::m_ValidPrimNum)
			.addProperty("m_CenterPos", &EffectFixFire::m_CenterPos)
			.addProperty("m_Direc", &EffectFixFire::m_Direc)
			.addProperty("m_RotRange", &EffectFixFire::m_RotRange)
			.addProperty("m_Speed", &EffectFixFire::m_Speed)
			.addProperty("m_Color", &EffectFixFire::m_Color)
			.addProperty("m_Scale", &EffectFixFire::m_Scale)
			.addProperty("m_ScaleAnime", &EffectFixFire::m_ScaleAnime)
			.addProperty("m_TimeCount", &EffectFixFire::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectFixFire::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectFixFire::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectFixFire::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectFixFire::m_pObject) == 4, "expected m_pObject to be size 4");
static_assert(sizeof(EffectFixFire::m_ValidFirst) == 52, "expected m_ValidFirst to be size 52");
static_assert(sizeof(EffectFixFire::m_ValidLast) == 52, "expected m_ValidLast to be size 52");
static_assert(sizeof(EffectFixFire::m_FreeFirst) == 52, "expected m_FreeFirst to be size 52");
static_assert(sizeof(EffectFixFire::m_FreeLast) == 52, "expected m_FreeLast to be size 52");
static_assert(sizeof(EffectFixFire::m_Tex) == 40, "expected m_Tex to be size 40");
static_assert(sizeof(EffectFixFire::m_BlendMode) == 4, "expected m_BlendMode to be size 4");
static_assert(sizeof(EffectFixFire::m_FadeAlphaSpeed) == 4, "expected m_FadeAlphaSpeed to be size 4");
static_assert(sizeof(EffectFixFire::m_PrimNum) == 4, "expected m_PrimNum to be size 4");
static_assert(sizeof(EffectFixFire::m_ValidPrimNum) == 4, "expected m_ValidPrimNum to be size 4");
static_assert(sizeof(EffectFixFire::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(EffectFixFire::m_Direc) == 12, "expected m_Direc to be size 12");
static_assert(sizeof(EffectFixFire::m_RotRange) == 12, "expected m_RotRange to be size 12");
static_assert(sizeof(EffectFixFire::m_Speed) == 4, "expected m_Speed to be size 4");
static_assert(sizeof(EffectFixFire::m_Color) == 4, "expected m_Color to be size 4");
static_assert(sizeof(EffectFixFire::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EffectFixFire::m_ScaleAnime) == 4, "expected m_ScaleAnime to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeFrame) == 4, "expected m_TimeFrame to be size 4");
static_assert(sizeof(EffectFixFire::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(class EffectFixFire) == 416, "expected class EffectFixFire to be size 416");

// class HrOverLap
// 6 dependencies: struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT
class HrOverLap
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t mAlloc, offset 0x0>
	uint8_t mAlloc;

	// <Filler, offset 0x1>
	char _Filler1[3];

	// <int32_t mStatus, offset 0x4>
	int32_t mStatus;

	// <float mAlpha, offset 0x8>
	float mAlpha;

	// <float mSpeed, offset 0xc>
	float mSpeed;

	// <struct tagGHMR_TEX mTex, offset 0x10>
	struct tagGHMR_TEX mTex;

	// <uint8_t mbVisible, offset 0x38>
	uint8_t mbVisible;

	// <Filler, offset 0x39>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrOverLap>("HrOverLap")
			.addProperty("mAlloc", &HrOverLap::mAlloc)
			.addProperty("mStatus", &HrOverLap::mStatus)
			.addProperty("mAlpha", &HrOverLap::mAlpha)
			.addProperty("mSpeed", &HrOverLap::mSpeed)
			.addProperty("mTex", &HrOverLap::mTex)
			.addProperty("mbVisible", &HrOverLap::mbVisible)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrOverLap::mAlloc) == 1, "expected mAlloc to be size 1");
static_assert(sizeof(HrOverLap::mStatus) == 4, "expected mStatus to be size 4");
static_assert(sizeof(HrOverLap::mAlpha) == 4, "expected mAlpha to be size 4");
static_assert(sizeof(HrOverLap::mSpeed) == 4, "expected mSpeed to be size 4");
static_assert(sizeof(HrOverLap::mTex) == 40, "expected mTex to be size 40");
static_assert(sizeof(HrOverLap::mbVisible) == 1, "expected mbVisible to be size 1");
static_assert(sizeof(class HrOverLap) == 60, "expected class HrOverLap to be size 60");

// class WGcl
// 2 dependencies: class ghmListObj, struct Vec
class WGcl : ghmListObj
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <int32_t mState, offset 0x10>
	int32_t mState;

	// <uint32_t mFlag, offset 0x14>
	uint32_t mFlag;

	// <struct WGclSpec* mpSpec, offset 0x18>
	struct WGclSpec* mpSpec;

	// <class ghmGcColl* mpEntryColl, offset 0x1c>
	class ghmGcColl* mpEntryColl;

	// <class WGclNode* mpTopNode, offset 0x20>
	class WGclNode* mpTopNode;

	// <struct Vec mRootPosition, offset 0x24>
	struct Vec mRootPosition;

	// <struct Vec mRootRotation, offset 0x30>
	struct Vec mRootRotation;

	// <float mRootMatrix[0x3][0x4], offset 0x3c>
	float mRootMatrix[3][4];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGcl>("WGcl")
			.addProperty("mState", &WGcl::mState)
			.addProperty("mFlag", &WGcl::mFlag)
			.addProperty("mpSpec", &WGcl::mpSpec)
			.addProperty("mpEntryColl", &WGcl::mpEntryColl)
			.addProperty("mpTopNode", &WGcl::mpTopNode)
			.addProperty("mRootPosition", &WGcl::mRootPosition)
			.addProperty("mRootRotation", &WGcl::mRootRotation)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mRootMatrix", &WGcl::mRootMatrix)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGcl::mState) == 4, "expected mState to be size 4");
static_assert(sizeof(WGcl::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGcl::mpSpec) == 4, "expected mpSpec to be size 4");
static_assert(sizeof(WGcl::mpEntryColl) == 4, "expected mpEntryColl to be size 4");
static_assert(sizeof(WGcl::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(WGcl::mRootPosition) == 12, "expected mRootPosition to be size 12");
static_assert(sizeof(WGcl::mRootRotation) == 12, "expected mRootRotation to be size 12");
static_assert(sizeof(WGcl::mRootMatrix) == 48, "expected mRootMatrix to be size 48");
static_assert(sizeof(class WGcl) == 108, "expected class WGcl to be size 108");

// class commonObj
// 28 dependencies: class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate
class commonObj : mHRChara
{
public:
	/// 2 namespace types: uint8_t __convention("thiscall") commonObj::mSetDamage(class commonObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), uint8_t __convention("thiscall") commonObj::mSetDamage(class commonObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)

	// TODO: Function 'uint8_t __convention("thiscall") commonObj::mSetDamage(class commonObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// TODO: Function 'uint8_t __convention("thiscall") commonObj::mSetDamage(class commonObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)'

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <uint8_t mCallMotionProcFlag, offset 0x580>
	uint8_t mCallMotionProcFlag;

	// <Filler, offset 0x581>
	char _Filler2[3];

	// <class WGcl mGcl, offset 0x584>
	class WGcl mGcl;

	// <uint8_t m_bIsGclExist, offset 0x5f0>
	uint8_t m_bIsGclExist;

	// <uint8_t m_bIsUseGcl, offset 0x5f1>
	uint8_t m_bIsUseGcl;

	// <uint8_t m_bActFadeInOut, offset 0x5f2>
	uint8_t m_bActFadeInOut;

	// <uint8_t m_bIsNotRequestDelete, offset 0x5f3>
	uint8_t m_bIsNotRequestDelete;

	// <class CTimeRatioInterpolate m_inFadeInOutAlpha, offset 0x5f4>
	class CTimeRatioInterpolate m_inFadeInOutAlpha;

	// <uint8_t m_bActVisibleFade, offset 0x600>
	uint8_t m_bActVisibleFade;

	// <Filler, offset 0x601>
	char _Filler9[3];

	// <float m_FadeDist, offset 0x604>
	float m_FadeDist;

	// <int32_t m_eRigidMaterialID, offset 0x608>
	int32_t m_eRigidMaterialID;

	// <uint8_t m_bActDeleteByDestroy, offset 0x60c>
	uint8_t m_bActDeleteByDestroy;

	// <uint8_t m_bIsNeedSetupMatrix, offset 0x60d>
	uint8_t m_bIsNeedSetupMatrix;

	// <Filler, offset 0x60e>
	char _Filler13[2];

	// <float m_fDestroyTimer, offset 0x610>
	float m_fDestroyTimer;

	// <uint8_t m_bIsDestroyMotLoop, offset 0x614>
	uint8_t m_bIsDestroyMotLoop;

	// <uint8_t m_bIsMiniDemoDamage, offset 0x615>
	uint8_t m_bIsMiniDemoDamage;

	// <Filler, offset 0x616>
	char _Filler16[2];

	// <float m_fDamagePower, offset 0x618>
	float m_fDamagePower;

	// <float m_fDamageYaw, offset 0x61c>
	float m_fDamageYaw;

	// <float m_fDamagePitch, offset 0x620>
	float m_fDamagePitch;

	// <uint8_t m_bIsSpreadBreak, offset 0x624>
	uint8_t m_bIsSpreadBreak;

	// <Filler, offset 0x625>
	char _Filler20[3];

	// <struct Vec m_inSpreadBreakSrcPosiOfst, offset 0x628>
	struct Vec m_inSpreadBreakSrcPosiOfst;

	// <uint8_t m_bIsSetGroundColPlane, offset 0x634>
	uint8_t m_bIsSetGroundColPlane;

	// <Filler, offset 0x635>
	char _Filler22[3];

	// <class ghmPlane m_inGroundColPlane, offset 0x638>
	class ghmPlane m_inGroundColPlane;

	// <uint8_t mbDistEraseDisable, offset 0x648>
	uint8_t mbDistEraseDisable;

	// <Filler, offset 0x649>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<commonObj>("commonObj")
			.addProperty("mCallMotionProcFlag", &commonObj::mCallMotionProcFlag)
			.addProperty("mGcl", &commonObj::mGcl)
			.addProperty("m_bIsGclExist", &commonObj::m_bIsGclExist)
			.addProperty("m_bIsUseGcl", &commonObj::m_bIsUseGcl)
			.addProperty("m_bActFadeInOut", &commonObj::m_bActFadeInOut)
			.addProperty("m_bIsNotRequestDelete", &commonObj::m_bIsNotRequestDelete)
			.addProperty("m_inFadeInOutAlpha", &commonObj::m_inFadeInOutAlpha)
			.addProperty("m_bActVisibleFade", &commonObj::m_bActVisibleFade)
			.addProperty("m_FadeDist", &commonObj::m_FadeDist)
			.addProperty("m_eRigidMaterialID", &commonObj::m_eRigidMaterialID)
			.addProperty("m_bActDeleteByDestroy", &commonObj::m_bActDeleteByDestroy)
			.addProperty("m_bIsNeedSetupMatrix", &commonObj::m_bIsNeedSetupMatrix)
			.addProperty("m_fDestroyTimer", &commonObj::m_fDestroyTimer)
			.addProperty("m_bIsDestroyMotLoop", &commonObj::m_bIsDestroyMotLoop)
			.addProperty("m_bIsMiniDemoDamage", &commonObj::m_bIsMiniDemoDamage)
			.addProperty("m_fDamagePower", &commonObj::m_fDamagePower)
			.addProperty("m_fDamageYaw", &commonObj::m_fDamageYaw)
			.addProperty("m_fDamagePitch", &commonObj::m_fDamagePitch)
			.addProperty("m_bIsSpreadBreak", &commonObj::m_bIsSpreadBreak)
			.addProperty("m_inSpreadBreakSrcPosiOfst", &commonObj::m_inSpreadBreakSrcPosiOfst)
			.addProperty("m_bIsSetGroundColPlane", &commonObj::m_bIsSetGroundColPlane)
			.addProperty("m_inGroundColPlane", &commonObj::m_inGroundColPlane)
			.addProperty("mbDistEraseDisable", &commonObj::mbDistEraseDisable)
		.endClass();
	}
#endif
};
static_assert(sizeof(commonObj::mCallMotionProcFlag) == 1, "expected mCallMotionProcFlag to be size 1");
static_assert(sizeof(commonObj::mGcl) == 108, "expected mGcl to be size 108");
static_assert(sizeof(commonObj::m_bIsGclExist) == 1, "expected m_bIsGclExist to be size 1");
static_assert(sizeof(commonObj::m_bIsUseGcl) == 1, "expected m_bIsUseGcl to be size 1");
static_assert(sizeof(commonObj::m_bActFadeInOut) == 1, "expected m_bActFadeInOut to be size 1");
static_assert(sizeof(commonObj::m_bIsNotRequestDelete) == 1, "expected m_bIsNotRequestDelete to be size 1");
static_assert(sizeof(commonObj::m_inFadeInOutAlpha) == 12, "expected m_inFadeInOutAlpha to be size 12");
static_assert(sizeof(commonObj::m_bActVisibleFade) == 1, "expected m_bActVisibleFade to be size 1");
static_assert(sizeof(commonObj::m_FadeDist) == 4, "expected m_FadeDist to be size 4");
static_assert(sizeof(commonObj::m_eRigidMaterialID) == 4, "expected m_eRigidMaterialID to be size 4");
static_assert(sizeof(commonObj::m_bActDeleteByDestroy) == 1, "expected m_bActDeleteByDestroy to be size 1");
static_assert(sizeof(commonObj::m_bIsNeedSetupMatrix) == 1, "expected m_bIsNeedSetupMatrix to be size 1");
static_assert(sizeof(commonObj::m_fDestroyTimer) == 4, "expected m_fDestroyTimer to be size 4");
static_assert(sizeof(commonObj::m_bIsDestroyMotLoop) == 1, "expected m_bIsDestroyMotLoop to be size 1");
static_assert(sizeof(commonObj::m_bIsMiniDemoDamage) == 1, "expected m_bIsMiniDemoDamage to be size 1");
static_assert(sizeof(commonObj::m_fDamagePower) == 4, "expected m_fDamagePower to be size 4");
static_assert(sizeof(commonObj::m_fDamageYaw) == 4, "expected m_fDamageYaw to be size 4");
static_assert(sizeof(commonObj::m_fDamagePitch) == 4, "expected m_fDamagePitch to be size 4");
static_assert(sizeof(commonObj::m_bIsSpreadBreak) == 1, "expected m_bIsSpreadBreak to be size 1");
static_assert(sizeof(commonObj::m_inSpreadBreakSrcPosiOfst) == 12, "expected m_inSpreadBreakSrcPosiOfst to be size 12");
static_assert(sizeof(commonObj::m_bIsSetGroundColPlane) == 1, "expected m_bIsSetGroundColPlane to be size 1");
static_assert(sizeof(commonObj::m_inGroundColPlane) == 16, "expected m_inGroundColPlane to be size 16");
static_assert(sizeof(commonObj::mbDistEraseDisable) == 1, "expected mbDistEraseDisable to be size 1");
static_assert(sizeof(class commonObj) == 1612, "expected class commonObj to be size 1612");

// class CustomColliderObj
// 29 dependencies: class commonObj, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate
class CustomColliderObj : commonObj
{
public:
	/// 3 namespace types: uint8_t __convention("thiscall") CustomColliderObj::mSetDamage(class CustomColliderObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11), uint8_t __convention("thiscall") CustomColliderObj::mSetDamage(class CustomColliderObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), uint8_t __convention("thiscall") CustomColliderObj::mHitCheck(class CustomColliderObj* const this, class mHRChara* arg2)

	// TODO: Function 'uint8_t __convention("thiscall") CustomColliderObj::mSetDamage(class CustomColliderObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)'
	// TODO: Function 'uint8_t __convention("thiscall") CustomColliderObj::mSetDamage(class CustomColliderObj* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// TODO: Function 'uint8_t __convention("thiscall") CustomColliderObj::mHitCheck(class CustomColliderObj* const this, class mHRChara* arg2)'

	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class ghmGcCollObjCapsule* capsuleCollider, offset 0x64c>
	class ghmGcCollObjCapsule* capsuleCollider;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CustomColliderObj>("CustomColliderObj")
			.addProperty("capsuleCollider", &CustomColliderObj::capsuleCollider)
		.endClass();
	}
#endif
};
static_assert(sizeof(CustomColliderObj::capsuleCollider) == 4, "expected capsuleCollider to be size 4");
static_assert(sizeof(class CustomColliderObj) == 1616, "expected class CustomColliderObj to be size 1616");

// struct WGclSpec
// no dependencies
struct WGclSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint32_t mID, offset 0x0>
	uint32_t mID;

	// <uint32_t mVersion, offset 0x4>
	uint32_t mVersion;

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint16_t mNodeCount, offset 0xc>
	uint16_t mNodeCount;

	// <uint16_t mMaterialCount, offset 0xe>
	uint16_t mMaterialCount;

	// <struct WGclNodeSpec* mpTopNode, offset 0x10>
	struct WGclNodeSpec* mpTopNode;

	// <struct WGclMaterialSpec* mpTopMaterial, offset 0x14>
	struct WGclMaterialSpec* mpTopMaterial;

	// <uint32_t mConvVersion, offset 0x18>
	uint32_t mConvVersion;

	// <uint32_t mPad[0x5], offset 0x1c>
	uint32_t mPad[5];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclSpec>("WGclSpec")
			.addProperty("mID", &WGclSpec::mID)
			.addProperty("mVersion", &WGclSpec::mVersion)
			.addProperty("mFlag", &WGclSpec::mFlag)
			.addProperty("mNodeCount", &WGclSpec::mNodeCount)
			.addProperty("mMaterialCount", &WGclSpec::mMaterialCount)
			.addProperty("mpTopNode", &WGclSpec::mpTopNode)
			.addProperty("mpTopMaterial", &WGclSpec::mpTopMaterial)
			.addProperty("mConvVersion", &WGclSpec::mConvVersion)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclSpec::mID) == 4, "expected mID to be size 4");
static_assert(sizeof(WGclSpec::mVersion) == 4, "expected mVersion to be size 4");
static_assert(sizeof(WGclSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGclSpec::mNodeCount) == 2, "expected mNodeCount to be size 2");
static_assert(sizeof(WGclSpec::mMaterialCount) == 2, "expected mMaterialCount to be size 2");
static_assert(sizeof(WGclSpec::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(WGclSpec::mpTopMaterial) == 4, "expected mpTopMaterial to be size 4");
static_assert(sizeof(WGclSpec::mConvVersion) == 4, "expected mConvVersion to be size 4");
static_assert(sizeof(WGclSpec::mPad) == 20, "expected mPad to be size 20");
static_assert(sizeof(struct WGclSpec) == 48, "expected struct WGclSpec to be size 48");

// struct WGclNodeSpec
// 1 dependencies: struct Vec
struct WGclNodeSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <char mIDStr[0x8], offset 0x0>
	char mIDStr[8];

	// <uint32_t mFlag, offset 0x8>
	uint32_t mFlag;

	// <uint32_t mType, offset 0xc>
	uint32_t mType;

	// <WGclNodeSpec* mpParent, offset 0x10>
	WGclNodeSpec* mpParent;

	// <WGclNodeSpec* mpChild, offset 0x14>
	WGclNodeSpec* mpChild;

	// <WGclNodeSpec* mpPrev, offset 0x18>
	WGclNodeSpec* mpPrev;

	// <WGclNodeSpec* mpNext, offset 0x1c>
	WGclNodeSpec* mpNext;

	// <struct Vec mPosition, offset 0x20>
	struct Vec mPosition;

	// <struct Vec mRotation, offset 0x2c>
	struct Vec mRotation;

	// <struct WGclNodeShapeMeshSpec* mpMesh, offset 0x38>
	struct WGclNodeShapeMeshSpec* mpMesh;

	// <uint32_t mPad[0x5], offset 0x3c>
	uint32_t mPad[5];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeSpec>("WGclNodeSpec")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclNodeSpec::mIDStr)
			.addProperty("mFlag", &WGclNodeSpec::mFlag)
			.addProperty("mType", &WGclNodeSpec::mType)
			.addProperty("mpParent", &WGclNodeSpec::mpParent)
			.addProperty("mpChild", &WGclNodeSpec::mpChild)
			.addProperty("mpPrev", &WGclNodeSpec::mpPrev)
			.addProperty("mpNext", &WGclNodeSpec::mpNext)
			.addProperty("mPosition", &WGclNodeSpec::mPosition)
			.addProperty("mRotation", &WGclNodeSpec::mRotation)
			.addProperty("mpMesh", &WGclNodeSpec::mpMesh)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mPad", &WGclNodeSpec::mPad)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeSpec::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGclNodeSpec::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(WGclNodeSpec::mType) == 4, "expected mType to be size 4");
static_assert(sizeof(WGclNodeSpec::mpParent) == 4, "expected mpParent to be size 4");
static_assert(sizeof(WGclNodeSpec::mpChild) == 4, "expected mpChild to be size 4");
static_assert(sizeof(WGclNodeSpec::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGclNodeSpec::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGclNodeSpec::mPosition) == 12, "expected mPosition to be size 12");
static_assert(sizeof(WGclNodeSpec::mRotation) == 12, "expected mRotation to be size 12");
static_assert(sizeof(WGclNodeSpec::mpMesh) == 4, "expected mpMesh to be size 4");
static_assert(sizeof(WGclNodeSpec::mPad) == 20, "expected mPad to be size 20");
static_assert(sizeof(struct WGclNodeSpec) == 80, "expected struct WGclNodeSpec to be size 80");

// struct WGclNodeShapeMeshSpec
// 1 dependencies: struct Vec
struct WGclNodeShapeMeshSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct WGclNodeShapeMeshBspNodeSpec* mpBspTree, offset 0x0>
	struct WGclNodeShapeMeshBspNodeSpec* mpBspTree;

	// <struct WGclNodeShapeTriangleSpec* mpTriangles, offset 0x4>
	struct WGclNodeShapeTriangleSpec* mpTriangles;

	// <int32_t mNodeCount, offset 0x8>
	int32_t mNodeCount;

	// <int32_t mTriangleCount, offset 0xc>
	int32_t mTriangleCount;

	// <struct Vec mBoundingBoxCenter, offset 0x10>
	struct Vec mBoundingBoxCenter;

	// <struct Vec mBoundingBoxExtent, offset 0x1c>
	struct Vec mBoundingBoxExtent;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeMeshSpec>("WGclNodeShapeMeshSpec")
			.addProperty("mpBspTree", &WGclNodeShapeMeshSpec::mpBspTree)
			.addProperty("mpTriangles", &WGclNodeShapeMeshSpec::mpTriangles)
			.addProperty("mNodeCount", &WGclNodeShapeMeshSpec::mNodeCount)
			.addProperty("mTriangleCount", &WGclNodeShapeMeshSpec::mTriangleCount)
			.addProperty("mBoundingBoxCenter", &WGclNodeShapeMeshSpec::mBoundingBoxCenter)
			.addProperty("mBoundingBoxExtent", &WGclNodeShapeMeshSpec::mBoundingBoxExtent)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeShapeMeshSpec::mpBspTree) == 4, "expected mpBspTree to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mpTriangles) == 4, "expected mpTriangles to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mNodeCount) == 4, "expected mNodeCount to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mTriangleCount) == 4, "expected mTriangleCount to be size 4");
static_assert(sizeof(WGclNodeShapeMeshSpec::mBoundingBoxCenter) == 12, "expected mBoundingBoxCenter to be size 12");
static_assert(sizeof(WGclNodeShapeMeshSpec::mBoundingBoxExtent) == 12, "expected mBoundingBoxExtent to be size 12");
static_assert(sizeof(struct WGclNodeShapeMeshSpec) == 40, "expected struct WGclNodeShapeMeshSpec to be size 40");

// struct WGclNodeShapeMeshBspNodeSpec
// 2 dependencies: class ghmPlane, struct Vec
struct WGclNodeShapeMeshBspNodeSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <WGclNodeShapeMeshBspNodeSpec* mpFront, offset 0x0>
	WGclNodeShapeMeshBspNodeSpec* mpFront;

	// <WGclNodeShapeMeshBspNodeSpec* mpBack, offset 0x4>
	WGclNodeShapeMeshBspNodeSpec* mpBack;

	// <struct WGclNodeShapeTriangleSpec* mpTriangle, offset 0x8>
	struct WGclNodeShapeTriangleSpec* mpTriangle;

	// <uint16_t mTriangleCount, offset 0xc>
	uint16_t mTriangleCount;

	// <uint16_t mFlag, offset 0xe>
	uint16_t mFlag;

	// <struct Vec mNormal, offset 0x10>
	struct Vec mNormal;

	// <float mDist, offset 0x1c>
	float mDist;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeMeshBspNodeSpec>("WGclNodeShapeMeshBspNodeSpec")
			.addProperty("mpFront", &WGclNodeShapeMeshBspNodeSpec::mpFront)
			.addProperty("mpBack", &WGclNodeShapeMeshBspNodeSpec::mpBack)
			.addProperty("mpTriangle", &WGclNodeShapeMeshBspNodeSpec::mpTriangle)
			.addProperty("mTriangleCount", &WGclNodeShapeMeshBspNodeSpec::mTriangleCount)
			.addProperty("mFlag", &WGclNodeShapeMeshBspNodeSpec::mFlag)
			.addProperty("mNormal", &WGclNodeShapeMeshBspNodeSpec::mNormal)
			.addProperty("mDist", &WGclNodeShapeMeshBspNodeSpec::mDist)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpFront) == 4, "expected mpFront to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpBack) == 4, "expected mpBack to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mpTriangle) == 4, "expected mpTriangle to be size 4");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mTriangleCount) == 2, "expected mTriangleCount to be size 2");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mFlag) == 2, "expected mFlag to be size 2");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mNormal) == 12, "expected mNormal to be size 12");
static_assert(sizeof(WGclNodeShapeMeshBspNodeSpec::mDist) == 4, "expected mDist to be size 4");
static_assert(sizeof(struct WGclNodeShapeMeshBspNodeSpec) == 32, "expected struct WGclNodeShapeMeshBspNodeSpec to be size 32");

// struct WGclNodeShapeTriangleSpec
// no dependencies
struct WGclNodeShapeTriangleSpec
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[48];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNodeShapeTriangleSpec>("WGclNodeShapeTriangleSpec")
		.endClass();
	}
#endif
};
static_assert(sizeof(struct WGclNodeShapeTriangleSpec) == 48, "expected struct WGclNodeShapeTriangleSpec to be size 48");

// class ghmGcColl
// 1 dependencies: class ghmGcOctTree
class ghmGcColl
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class ghmGcOctTree mOctTree, offset 0x4>
	class ghmGcOctTree mOctTree;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ghmGcColl>("ghmGcColl")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ghmGcColl::field_0)
			.addProperty("mOctTree", &ghmGcColl::mOctTree)
		.endClass();
	}
#endif
};
static_assert(sizeof(ghmGcColl::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ghmGcColl::mOctTree) == 12, "expected mOctTree to be size 12");
static_assert(sizeof(class ghmGcColl) == 16, "expected class ghmGcColl to be size 16");

// class WGclNode
// 1 dependencies: struct Vec
class WGclNode
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <Filler, offset 0x4>
	char _Filler1[4];

	// <char mIDStr[0x8], offset 0x8>
	char mIDStr[8];

	// <class WGcl* mpContainer, offset 0x10>
	class WGcl* mpContainer;

	// <struct WGclNodeSpec* mpSpec, offset 0x14>
	struct WGclNodeSpec* mpSpec;

	// <class ghmGcCollObj* mpCollObj, offset 0x18>
	class ghmGcCollObj* mpCollObj;

	// <WGclNode* mpParent, offset 0x1c>
	WGclNode* mpParent;

	// <WGclNode* mpChild, offset 0x20>
	WGclNode* mpChild;

	// <WGclNode* mpNext, offset 0x24>
	WGclNode* mpNext;

	// <WGclNode* mpPrev, offset 0x28>
	WGclNode* mpPrev;

	// <struct Vec mPosition, offset 0x2c>
	struct Vec mPosition;

	// <struct Vec mRotation, offset 0x38>
	struct Vec mRotation;

	// <float mLocalWorldMatrix[0x3][0x4], offset 0x44>
	float mLocalWorldMatrix[3][4];

	// <float mWorldLocalMatrix[0x3][0x4], offset 0x74>
	float mWorldLocalMatrix[3][4];

	// <uint32_t mFlag, offset 0xa4>
	uint32_t mFlag;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<WGclNode>("WGclNode")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &WGclNode::field_0)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mIDStr", &WGclNode::mIDStr)
			.addProperty("mpContainer", &WGclNode::mpContainer)
			.addProperty("mpSpec", &WGclNode::mpSpec)
			.addProperty("mpCollObj", &WGclNode::mpCollObj)
			.addProperty("mpParent", &WGclNode::mpParent)
			.addProperty("mpChild", &WGclNode::mpChild)
			.addProperty("mpNext", &WGclNode::mpNext)
			.addProperty("mpPrev", &WGclNode::mpPrev)
			.addProperty("mPosition", &WGclNode::mPosition)
			.addProperty("mRotation", &WGclNode::mRotation)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mLocalWorldMatrix", &WGclNode::mLocalWorldMatrix)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mWorldLocalMatrix", &WGclNode::mWorldLocalMatrix)
			.addProperty("mFlag", &WGclNode::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(WGclNode::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(WGclNode::mIDStr) == 8, "expected mIDStr to be size 8");
static_assert(sizeof(WGclNode::mpContainer) == 4, "expected mpContainer to be size 4");
static_assert(sizeof(WGclNode::mpSpec) == 4, "expected mpSpec to be size 4");
static_assert(sizeof(WGclNode::mpCollObj) == 4, "expected mpCollObj to be size 4");
static_assert(sizeof(WGclNode::mpParent) == 4, "expected mpParent to be size 4");
static_assert(sizeof(WGclNode::mpChild) == 4, "expected mpChild to be size 4");
static_assert(sizeof(WGclNode::mpNext) == 4, "expected mpNext to be size 4");
static_assert(sizeof(WGclNode::mpPrev) == 4, "expected mpPrev to be size 4");
static_assert(sizeof(WGclNode::mPosition) == 12, "expected mPosition to be size 12");
static_assert(sizeof(WGclNode::mRotation) == 12, "expected mRotation to be size 12");
static_assert(sizeof(WGclNode::mLocalWorldMatrix) == 48, "expected mLocalWorldMatrix to be size 48");
static_assert(sizeof(WGclNode::mWorldLocalMatrix) == 48, "expected mWorldLocalMatrix to be size 48");
static_assert(sizeof(WGclNode::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(class WGclNode) == 168, "expected class WGclNode to be size 168");

// TODO: Function 'enum mot::CBoneEffectDamageData::EAttackType __convention("thiscall") mot::CBoneEffectPJ::getAttackType(class mot::CBoneEffectPJ* const this, class mHRChara* arg2)'
// class mot::CBoneEffectDamageData
// 2 dependencies: enum mot::CBoneEffectDamageData::EAttackType, enum mot::CBoneEffectDamageData::EAttackPart
namespace mot
{
	class CBoneEffectDamageData
	{
	public:
		/// 2 namespace types: enum mot::CBoneEffectDamageData::EAttackType, enum mot::CBoneEffectDamageData::EAttackPart

		// enum mot::CBoneEffectDamageData::EAttackType
		enum EAttackType : uint32_t
		{
			// Enum values

			// <ATTACK_TYPE_NONE = 0x0>
			ATTACK_TYPE_NONE = 0,

			// <ATTACK_TYPE_STRAIGHT = 0x1>
			ATTACK_TYPE_STRAIGHT = 1,

			// <ATTACK_TYPE_LEFT_STRAIGHT = 0x2>
			ATTACK_TYPE_LEFT_STRAIGHT = 2,

			// <ATTACK_TYPE_RIGHT_STRAIGHT = 0x3>
			ATTACK_TYPE_RIGHT_STRAIGHT = 3,

			// <ATTACK_TYPE_LEFT_HOOK = 0x4>
			ATTACK_TYPE_LEFT_HOOK = 4,

			// <ATTACK_TYPE_RIGHT_HOOK = 0x5>
			ATTACK_TYPE_RIGHT_HOOK = 5,

			// <ATTACK_TYPE_UPPER = 0x6>
			ATTACK_TYPE_UPPER = 6,

			// <ATTACK_TYPE_LEFT_UPPER = 0x7>
			ATTACK_TYPE_LEFT_UPPER = 7,

			// <ATTACK_TYPE_RIGHT_UPPER = 0x8>
			ATTACK_TYPE_RIGHT_UPPER = 8,

			// <ATTACK_TYPE_CHOP = 0x9>
			ATTACK_TYPE_CHOP = 9,

			// <ATTACK_TYPE_LEFT_CHOP = 0xa>
			ATTACK_TYPE_LEFT_CHOP = 10,

			// <ATTACK_TYPE_RIGHT_CHOP = 0xb>
			ATTACK_TYPE_RIGHT_CHOP = 11

		};

		// enum mot::CBoneEffectDamageData::EAttackPart
		enum EAttackPart : uint32_t
		{
			// Enum values

			// <ATTACK_PART_FACE = 0x0>
			ATTACK_PART_FACE = 0,

			// <ATTACK_PART_BODY = 0x1>
			ATTACK_PART_BODY = 1,

			// <ATTACK_PART_FOOT = 0x2>
			ATTACK_PART_FOOT = 2

		};


		/// Struct member variables

		// <uint8_t m_bIsHit, offset 0x0>
		uint8_t m_bIsHit;

		// <uint8_t m_bIsSuccessDefense, offset 0x1>
		uint8_t m_bIsSuccessDefense;

		// <uint8_t m_bIsKeepMyAttack, offset 0x2>
		uint8_t m_bIsKeepMyAttack;

		// <Filler, offset 0x3>
		char _Filler3[1];

		// <class mHRChara* m_pAttackChara, offset 0x4>
		class mHRChara* m_pAttackChara;

		// <enum mot::CBoneEffectDamageData::EAttackType m_eAttackType, offset 0x8>
		enum CBoneEffectDamageData::EAttackType m_eAttackType;

		// <enum mot::CBoneEffectDamageData::EAttackPart m_eAttackPart, offset 0xc>
		enum CBoneEffectDamageData::EAttackPart m_eAttackPart;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<mot::CBoneEffectDamageData>("mot::CBoneEffectDamageData")
				.addProperty("m_bIsHit", &mot::CBoneEffectDamageData::m_bIsHit)
				.addProperty("m_bIsSuccessDefense", &mot::CBoneEffectDamageData::m_bIsSuccessDefense)
				.addProperty("m_bIsKeepMyAttack", &mot::CBoneEffectDamageData::m_bIsKeepMyAttack)
				.addProperty("m_pAttackChara", &mot::CBoneEffectDamageData::m_pAttackChara)
				.addProperty("m_eAttackType", &mot::CBoneEffectDamageData::m_eAttackType)
				.addProperty("m_eAttackPart", &mot::CBoneEffectDamageData::m_eAttackPart)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsHit) == 1, "expected m_bIsHit to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsSuccessDefense) == 1, "expected m_bIsSuccessDefense to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_bIsKeepMyAttack) == 1, "expected m_bIsKeepMyAttack to be size 1");
static_assert(sizeof(mot::CBoneEffectDamageData::m_pAttackChara) == 4, "expected m_pAttackChara to be size 4");
static_assert(sizeof(mot::CBoneEffectDamageData::m_eAttackType) == 4, "expected m_eAttackType to be size 4");
static_assert(sizeof(mot::CBoneEffectDamageData::m_eAttackPart) == 4, "expected m_eAttackPart to be size 4");
static_assert(sizeof(class mot::CBoneEffectDamageData) == 16, "expected class mot::CBoneEffectDamageData to be size 16");

// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnFinishDemo(class mHRChara* const this, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4)'
// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnFinishDemo(class mHRChara* const this, enum HrBattleIcon::D_TODOME_DIRECT arg2)'
// class mHRLockOnList
// 1 dependencies: class ghmListObj
class mHRLockOnList : ghmListObj
{
public:
	/// 6 namespace types: class mHRChara* __convention("thiscall") mHRLockOnList::mGetCharaPtr(class mHRLockOnList* const this), void __convention("thiscall") mHRLockOnList::mHRLockOnList(class mHRLockOnList* const this, class mHRChara* arg2), uint8_t mHRLockOnList::mCheckEntry(class mHRChara* arg1), void mHRLockOnList::mAddList(class mHRChara* arg1), void mHRLockOnList::mDelList(class mHRChara* arg1), class mHRLockOnList* mHRLockOnList::mGetNextTatget(class mHRChara* arg1)

	// TODO: Function 'class mHRChara* __convention("thiscall") mHRLockOnList::mGetCharaPtr(class mHRLockOnList* const this)'
	// TODO: Function 'void __convention("thiscall") mHRLockOnList::mHRLockOnList(class mHRLockOnList* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t mHRLockOnList::mCheckEntry(class mHRChara* arg1)'
	// TODO: Function 'void mHRLockOnList::mAddList(class mHRChara* arg1)'
	// TODO: Function 'void mHRLockOnList::mDelList(class mHRChara* arg1)'
	// TODO: Function 'class mHRLockOnList* mHRLockOnList::mGetNextTatget(class mHRChara* arg1)'

	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <class mHRChara* mpChara, offset 0x10>
	class mHRChara* mpChara;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRLockOnList>("mHRLockOnList")
			.addProperty("mpChara", &mHRLockOnList::mpChara)
		.endClass();
	}
#endif
};
static_assert(sizeof(mHRLockOnList::mpChara) == 4, "expected mpChara to be size 4");
static_assert(sizeof(class mHRLockOnList) == 20, "expected class mHRLockOnList to be size 20");

// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnFinish(class mHRChara* const this, enum HrBattleIcon::D_TODOME_DIRECT arg2)'
// TODO: Function 'void __convention("thiscall") mHRChara::mChgBtlIcnFinish(class mHRChara* const this, enum HrBattleIcon::E_CON_ACT_ID arg2, enum HrBattleIcon::E_CON_ACT_ID arg3, uint8_t arg4)'
// class NYPhase
// no dependencies
class NYPhase
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t m_phase, offset 0x0>
	int32_t m_phase;

	// <float m_frame, offset 0x4>
	float m_frame;

	// <float m_frameMax, offset 0x8>
	float m_frameMax;

	// <uint8_t m_useNext, offset 0xc>
	uint8_t m_useNext;

	// <Filler, offset 0xd>
	char _Filler4[3];

	// <int32_t m_nextPhase, offset 0x10>
	int32_t m_nextPhase;

	// <float m_nextFrame, offset 0x14>
	float m_nextFrame;

	// <float m_nextFrameMax, offset 0x18>
	float m_nextFrameMax;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NYPhase>("NYPhase")
			.addProperty("m_phase", &NYPhase::m_phase)
			.addProperty("m_frame", &NYPhase::m_frame)
			.addProperty("m_frameMax", &NYPhase::m_frameMax)
			.addProperty("m_useNext", &NYPhase::m_useNext)
			.addProperty("m_nextPhase", &NYPhase::m_nextPhase)
			.addProperty("m_nextFrame", &NYPhase::m_nextFrame)
			.addProperty("m_nextFrameMax", &NYPhase::m_nextFrameMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYPhase::m_phase) == 4, "expected m_phase to be size 4");
static_assert(sizeof(NYPhase::m_frame) == 4, "expected m_frame to be size 4");
static_assert(sizeof(NYPhase::m_frameMax) == 4, "expected m_frameMax to be size 4");
static_assert(sizeof(NYPhase::m_useNext) == 1, "expected m_useNext to be size 1");
static_assert(sizeof(NYPhase::m_nextPhase) == 4, "expected m_nextPhase to be size 4");
static_assert(sizeof(NYPhase::m_nextFrame) == 4, "expected m_nextFrame to be size 4");
static_assert(sizeof(NYPhase::m_nextFrameMax) == 4, "expected m_nextFrameMax to be size 4");
static_assert(sizeof(class NYPhase) == 28, "expected class NYPhase to be size 28");

// class NYApproachToTargetVal
// 1 dependencies: enum NYApproachToTargetVal::CHANGE_TYPE
class NYApproachToTargetVal
{
public:
	/// 1 namespace types: enum NYApproachToTargetVal::CHANGE_TYPE

	// enum NYApproachToTargetVal::CHANGE_TYPE
	enum CHANGE_TYPE : uint32_t
	{
		// Enum values

		// <CHANGE_TYPE_INCREASED = 0x0>
		CHANGE_TYPE_INCREASED = 0,

		// <CHANGE_TYPE_DECREASED = 0x1>
		CHANGE_TYPE_DECREASED = 1,

		// <CHANGE_TYPE_APPROACHED = 0x2>
		CHANGE_TYPE_APPROACHED = 2,

		// <CHANGE_TYPE_NO_CHANGED = 0x3>
		CHANGE_TYPE_NO_CHANGED = 3

	};


	/// Struct member variables

	// <float m_val, offset 0x0>
	float m_val;

	// <float m_targetVal, offset 0x4>
	float m_targetVal;

	// <enum NYApproachToTargetVal::CHANGE_TYPE m_lastChangeType, offset 0x8>
	enum NYApproachToTargetVal::CHANGE_TYPE m_lastChangeType;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<NYApproachToTargetVal>("NYApproachToTargetVal")
			.addProperty("m_val", &NYApproachToTargetVal::m_val)
			.addProperty("m_targetVal", &NYApproachToTargetVal::m_targetVal)
			.addProperty("m_lastChangeType", &NYApproachToTargetVal::m_lastChangeType)
		.endClass();
	}
#endif
};
static_assert(sizeof(NYApproachToTargetVal::m_val) == 4, "expected m_val to be size 4");
static_assert(sizeof(NYApproachToTargetVal::m_targetVal) == 4, "expected m_targetVal to be size 4");
static_assert(sizeof(NYApproachToTargetVal::m_lastChangeType) == 4, "expected m_lastChangeType to be size 4");
static_assert(sizeof(class NYApproachToTargetVal) == 12, "expected class NYApproachToTargetVal to be size 12");

// class HrBattleIcon
// 8 dependencies: class HrTask, class NYApproachToTargetVal, enum NYApproachToTargetVal::CHANGE_TYPE, enum HrBattleIcon::D_BICON_STAT, struct Vec, enum HrBattleIcon::D_TODOME_DIRECT, class HrBattleIcon::CHrHpGauge, class NYPhase
class HrBattleIcon : HrTask
{
public:
	/// 5 namespace types: enum HrBattleIcon::D_BICON_STAT, enum HrBattleIcon::D_TODOME_DIRECT, class HrBattleIcon::CHrHpGauge, void __convention("thiscall") HrBattleIcon::OnCharacterTerminate(class HrBattleIcon* const this, class mHRChara* arg2), void __convention("thiscall") HrBattleIcon::Initialize(class HrBattleIcon* const this, class mHRChara* arg2, uint8_t arg3)

	// enum HrBattleIcon::D_BICON_STAT
	enum D_BICON_STAT : uint32_t
	{
		// Enum values

		// <D_BICON_NONE = 0x0>
		D_BICON_NONE = 0,

		// <D_BICON_MINI = 0x1>
		D_BICON_MINI = 1,

		// <D_BICON_MINI_TO_SKULL = 0x2>
		D_BICON_MINI_TO_SKULL = 2,

		// <D_BICON_SKULL_TO_MINI = 0x3>
		D_BICON_SKULL_TO_MINI = 3,

		// <D_BICON_SKULL = 0x4>
		D_BICON_SKULL = 4,

		// <D_BICON_TODOME_DO = 0x5>
		D_BICON_TODOME_DO = 5,

		// <D_BICON_TODOME_ED = 0x6>
		D_BICON_TODOME_ED = 6,

		// <D_BICON_CONTROLLER_ACT = 0x7>
		D_BICON_CONTROLLER_ACT = 7,

		// <D_BICON_TUBAZERI = 0x8>
		D_BICON_TUBAZERI = 8

	};

	// enum HrBattleIcon::D_TODOME_DIRECT
	enum D_TODOME_DIRECT : uint32_t
	{
		// Enum values

		// <D_TODOME_RIGHT = 0x0>
		D_TODOME_RIGHT = 0,

		// <D_TODOME_DOWN = 0x1>
		D_TODOME_DOWN = 1,

		// <D_TODOME_LEFT = 0x2>
		D_TODOME_LEFT = 2,

		// <D_TODOME_UP = 0x3>
		D_TODOME_UP = 3,

		// <D_TODOME_360 = 0x4>
		D_TODOME_360 = 4,

		// <D_TODOME_2RIGHTDOWN = 0x5>
		D_TODOME_2RIGHTDOWN = 5,

		// <D_TODOME_2LEFTDOWN = 0x6>
		D_TODOME_2LEFTDOWN = 6

	};

	// class HrBattleIcon::CHrHpGauge
	// 1 dependencies: class NYPhase
	class CHrHpGauge
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class NYPhase m_Phase, offset 0x0>
		class NYPhase m_Phase;

		// <void (* m_pPhaseProc[0x7][0x2])(HrBattleIcon::CHrHpGauge* const this), offset 0x1c>
		void (* m_pPhaseProc[0x7][0x2])(HrBattleIcon::CHrHpGauge* const ThisPtr);

		// <class mHRChara* m_pTargetChara, offset 0x54>
		class mHRChara* m_pTargetChara;

		// <int16_t const mc_Height, offset 0x58>
		int16_t const mc_Height;

		// <int16_t const mc_FrameEdge_Width, offset 0x5a>
		int16_t const mc_FrameEdge_Width;

		// <int16_t const mc_DrawOffsetY, offset 0x5c>
		int16_t const mc_DrawOffsetY;

		// <Filler, offset 0x5e>
		char _Filler6[2];

		// <float m_DrawWidth, offset 0x60>
		float m_DrawWidth;

		// <float m_DrawHeight, offset 0x64>
		float m_DrawHeight;

		// <float m_DrawAlpha, offset 0x68>
		float m_DrawAlpha;

		// <float m_HpRate, offset 0x6c>
		float m_HpRate;

		// <int16_t m_SlashFadeCounter, offset 0x70>
		int16_t m_SlashFadeCounter;

		// <Filler, offset 0x72>
		char _Filler[2];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<HrBattleIcon::CHrHpGauge>("HrBattleIcon::CHrHpGauge")
				.addProperty("m_Phase", &HrBattleIcon::CHrHpGauge::m_Phase)
				// void type not supported in LuaBridge
				//.addProperty("m_pPhaseProc", &HrBattleIcon::CHrHpGauge::m_pPhaseProc)
				.addProperty("m_pTargetChara", &HrBattleIcon::CHrHpGauge::m_pTargetChara)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_Height", &HrBattleIcon::CHrHpGauge::mc_Height)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_FrameEdge_Width", &HrBattleIcon::CHrHpGauge::mc_FrameEdge_Width)
				// const not supported in LuaBridge and needs a getter
				//.addProperty("mc_DrawOffsetY", &HrBattleIcon::CHrHpGauge::mc_DrawOffsetY)
				.addProperty("m_DrawWidth", &HrBattleIcon::CHrHpGauge::m_DrawWidth)
				.addProperty("m_DrawHeight", &HrBattleIcon::CHrHpGauge::m_DrawHeight)
				.addProperty("m_DrawAlpha", &HrBattleIcon::CHrHpGauge::m_DrawAlpha)
				.addProperty("m_HpRate", &HrBattleIcon::CHrHpGauge::m_HpRate)
				.addProperty("m_SlashFadeCounter", &HrBattleIcon::CHrHpGauge::m_SlashFadeCounter)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_Phase) == 28, "expected m_Phase to be size 28");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_pPhaseProc) == 56, "expected m_pPhaseProc to be size 56");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_pTargetChara) == 4, "expected m_pTargetChara to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_Height) == 2, "expected mc_Height to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_FrameEdge_Width) == 2, "expected mc_FrameEdge_Width to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::mc_DrawOffsetY) == 2, "expected mc_DrawOffsetY to be size 2");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawWidth) == 4, "expected m_DrawWidth to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawHeight) == 4, "expected m_DrawHeight to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_DrawAlpha) == 4, "expected m_DrawAlpha to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_HpRate) == 4, "expected m_HpRate to be size 4");
	static_assert(sizeof(HrBattleIcon::CHrHpGauge::m_SlashFadeCounter) == 2, "expected m_SlashFadeCounter to be size 2");
	static_assert(sizeof(class HrBattleIcon::CHrHpGauge) == 116, "expected class HrBattleIcon::CHrHpGauge to be size 116");

	// TODO: Function 'void __convention("thiscall") HrBattleIcon::OnCharacterTerminate(class HrBattleIcon* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") HrBattleIcon::Initialize(class HrBattleIcon* const this, class mHRChara* arg2, uint8_t arg3)'

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class NYApproachToTargetVal m_HPVal, offset 0x50>
	class NYApproachToTargetVal m_HPVal;

	// <float m_damagedCounter, offset 0x5c>
	float m_damagedCounter;

	// <enum HrBattleIcon::D_BICON_STAT m_IconStat, offset 0x60>
	enum HrBattleIcon::D_BICON_STAT m_IconStat;

	// <enum HrBattleIcon::D_BICON_STAT m_YoyakuIcon, offset 0x64>
	enum HrBattleIcon::D_BICON_STAT m_YoyakuIcon;

	// <float m_LockOnDist, offset 0x68>
	float m_LockOnDist;

	// <float m_LockOnCircleSize, offset 0x6c>
	float m_LockOnCircleSize;

	// <float m_BIcon_Block_Size, offset 0x70>
	float m_BIcon_Block_Size;

	// <uint8_t m_blockcolor[0x3], offset 0x74>
	uint8_t m_blockcolor[3];

	// <uint8_t m_ColorType, offset 0x77>
	uint8_t m_ColorType;

	// <enum m_ConActID[0x2], offset 0x78>
	uint32_t m_ConActID[2];

	// <int16_t m_ConActCount[0x2], offset 0x80>
	int16_t m_ConActCount[2];

	// <int16_t m_Counter, offset 0x84>
	int16_t m_Counter;

	// <int16_t m_DelCounter, offset 0x86>
	int16_t m_DelCounter;

	// <uint32_t m_Rotate_AnimCnt, offset 0x88>
	uint32_t m_Rotate_AnimCnt;

	// <struct Vec m_TmpJstVec, offset 0x8c>
	struct Vec m_TmpJstVec;

	// <int16_t m_PyokoCnt, offset 0x98>
	int16_t m_PyokoCnt;

	// <int16_t m_PyokoFlag, offset 0x9a>
	int16_t m_PyokoFlag;

	// <float m_PyokoRatio, offset 0x9c>
	float m_PyokoRatio;

	// <uint8_t m_PyokoAlpha, offset 0xa0>
	uint8_t m_PyokoAlpha;

	// <uint8_t m_DrawHitCmbFlag, offset 0xa1>
	uint8_t m_DrawHitCmbFlag;

	// <Filler, offset 0xa2>
	char _Filler21[2];

	// <float m_TsubaRatio[0x24], offset 0xa4>
	float m_TsubaRatio[36];

	// <struct Vec* m_pPosition[0x2], offset 0x134>
	struct Vec* m_pPosition[2];

	// <class mHRChara* m_pTargetChara, offset 0x13c>
	class mHRChara* m_pTargetChara;

	// <int16_t m_HpBerCounter, offset 0x140>
	int16_t m_HpBerCounter;

	// <int16_t m_LineCounter, offset 0x142>
	int16_t m_LineCounter;

	// <char m_MeterCounter, offset 0x144>
	char m_MeterCounter;

	// <Filler, offset 0x145>
	char _Filler27[3];

	// <float m_Tension[0x2], offset 0x148>
	float m_Tension[2];

	// <float m_TMeterRevPos[0x2], offset 0x150>
	float m_TMeterRevPos[2];

	// <int16_t m_GetMoney[0x2], offset 0x158>
	int16_t m_GetMoney[2];

	// <int16_t m_HitNum[0x2], offset 0x15c>
	int16_t m_HitNum[2];

	// <float m_HP[0x3], offset 0x160>
	float m_HP[3];

	// <int16_t m_SlashFadeCounter, offset 0x16c>
	int16_t m_SlashFadeCounter;

	// <int16_t m_BottanCounter[0x4], offset 0x16e>
	int16_t m_BottanCounter[4];

	// <int16_t m_TergetIconCount, offset 0x176>
	int16_t m_TergetIconCount;

	// <enum HrBattleIcon::D_TODOME_DIRECT m_Direct, offset 0x178>
	enum HrBattleIcon::D_TODOME_DIRECT m_Direct;

	// <int32_t m_Angle, offset 0x17c>
	int32_t m_Angle;

	// <int32_t m_Soundid, offset 0x180>
	int32_t m_Soundid;

	// <uint16_t flag, offset 0x184>
	uint16_t flag;

	// <uint8_t m_bDemo, offset 0x186>
	uint8_t m_bDemo;

	// <Filler, offset 0x187>
	char _Filler40[1];

	// <class HrBattleIcon::CHrHpGauge m_HpGauge, offset 0x188>
	class HrBattleIcon::CHrHpGauge m_HpGauge;

	// <int32_t m_SlashSEStatus, offset 0x1fc>
	int32_t m_SlashSEStatus;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrBattleIcon>("HrBattleIcon")
			.addProperty("m_HPVal", &HrBattleIcon::m_HPVal)
			.addProperty("m_damagedCounter", &HrBattleIcon::m_damagedCounter)
			.addProperty("m_IconStat", &HrBattleIcon::m_IconStat)
			.addProperty("m_YoyakuIcon", &HrBattleIcon::m_YoyakuIcon)
			.addProperty("m_LockOnDist", &HrBattleIcon::m_LockOnDist)
			.addProperty("m_LockOnCircleSize", &HrBattleIcon::m_LockOnCircleSize)
			.addProperty("m_BIcon_Block_Size", &HrBattleIcon::m_BIcon_Block_Size)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_blockcolor", &HrBattleIcon::m_blockcolor)
			.addProperty("m_ColorType", &HrBattleIcon::m_ColorType)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_ConActID", &HrBattleIcon::m_ConActID)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_ConActCount", &HrBattleIcon::m_ConActCount)
			.addProperty("m_Counter", &HrBattleIcon::m_Counter)
			.addProperty("m_DelCounter", &HrBattleIcon::m_DelCounter)
			.addProperty("m_Rotate_AnimCnt", &HrBattleIcon::m_Rotate_AnimCnt)
			.addProperty("m_TmpJstVec", &HrBattleIcon::m_TmpJstVec)
			.addProperty("m_PyokoCnt", &HrBattleIcon::m_PyokoCnt)
			.addProperty("m_PyokoFlag", &HrBattleIcon::m_PyokoFlag)
			.addProperty("m_PyokoRatio", &HrBattleIcon::m_PyokoRatio)
			.addProperty("m_PyokoAlpha", &HrBattleIcon::m_PyokoAlpha)
			.addProperty("m_DrawHitCmbFlag", &HrBattleIcon::m_DrawHitCmbFlag)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_TsubaRatio", &HrBattleIcon::m_TsubaRatio)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pPosition", &HrBattleIcon::m_pPosition)
			.addProperty("m_pTargetChara", &HrBattleIcon::m_pTargetChara)
			.addProperty("m_HpBerCounter", &HrBattleIcon::m_HpBerCounter)
			.addProperty("m_LineCounter", &HrBattleIcon::m_LineCounter)
			.addProperty("m_MeterCounter", &HrBattleIcon::m_MeterCounter)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_Tension", &HrBattleIcon::m_Tension)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_TMeterRevPos", &HrBattleIcon::m_TMeterRevPos)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_GetMoney", &HrBattleIcon::m_GetMoney)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_HitNum", &HrBattleIcon::m_HitNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_HP", &HrBattleIcon::m_HP)
			.addProperty("m_SlashFadeCounter", &HrBattleIcon::m_SlashFadeCounter)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_BottanCounter", &HrBattleIcon::m_BottanCounter)
			.addProperty("m_TergetIconCount", &HrBattleIcon::m_TergetIconCount)
			.addProperty("m_Direct", &HrBattleIcon::m_Direct)
			.addProperty("m_Angle", &HrBattleIcon::m_Angle)
			.addProperty("m_Soundid", &HrBattleIcon::m_Soundid)
			.addProperty("flag", &HrBattleIcon::flag)
			.addProperty("m_bDemo", &HrBattleIcon::m_bDemo)
			//.addProperty("m_HpGauge", &HrBattleIcon::m_HpGauge)
			.addProperty("m_SlashSEStatus", &HrBattleIcon::m_SlashSEStatus)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrBattleIcon::m_HPVal) == 12, "expected m_HPVal to be size 12");
static_assert(sizeof(HrBattleIcon::m_damagedCounter) == 4, "expected m_damagedCounter to be size 4");
static_assert(sizeof(HrBattleIcon::m_IconStat) == 4, "expected m_IconStat to be size 4");
static_assert(sizeof(HrBattleIcon::m_YoyakuIcon) == 4, "expected m_YoyakuIcon to be size 4");
static_assert(sizeof(HrBattleIcon::m_LockOnDist) == 4, "expected m_LockOnDist to be size 4");
static_assert(sizeof(HrBattleIcon::m_LockOnCircleSize) == 4, "expected m_LockOnCircleSize to be size 4");
static_assert(sizeof(HrBattleIcon::m_BIcon_Block_Size) == 4, "expected m_BIcon_Block_Size to be size 4");
static_assert(sizeof(HrBattleIcon::m_blockcolor) == 3, "expected m_blockcolor to be size 3");
static_assert(sizeof(HrBattleIcon::m_ColorType) == 1, "expected m_ColorType to be size 1");
static_assert(sizeof(HrBattleIcon::m_ConActID) == 8, "expected m_ConActID to be size 8");
static_assert(sizeof(HrBattleIcon::m_ConActCount) == 4, "expected m_ConActCount to be size 4");
static_assert(sizeof(HrBattleIcon::m_Counter) == 2, "expected m_Counter to be size 2");
static_assert(sizeof(HrBattleIcon::m_DelCounter) == 2, "expected m_DelCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_Rotate_AnimCnt) == 4, "expected m_Rotate_AnimCnt to be size 4");
static_assert(sizeof(HrBattleIcon::m_TmpJstVec) == 12, "expected m_TmpJstVec to be size 12");
static_assert(sizeof(HrBattleIcon::m_PyokoCnt) == 2, "expected m_PyokoCnt to be size 2");
static_assert(sizeof(HrBattleIcon::m_PyokoFlag) == 2, "expected m_PyokoFlag to be size 2");
static_assert(sizeof(HrBattleIcon::m_PyokoRatio) == 4, "expected m_PyokoRatio to be size 4");
static_assert(sizeof(HrBattleIcon::m_PyokoAlpha) == 1, "expected m_PyokoAlpha to be size 1");
static_assert(sizeof(HrBattleIcon::m_DrawHitCmbFlag) == 1, "expected m_DrawHitCmbFlag to be size 1");
static_assert(sizeof(HrBattleIcon::m_TsubaRatio) == 144, "expected m_TsubaRatio to be size 144");
static_assert(sizeof(HrBattleIcon::m_pPosition) == 8, "expected m_pPosition to be size 8");
static_assert(sizeof(HrBattleIcon::m_pTargetChara) == 4, "expected m_pTargetChara to be size 4");
static_assert(sizeof(HrBattleIcon::m_HpBerCounter) == 2, "expected m_HpBerCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_LineCounter) == 2, "expected m_LineCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_MeterCounter) == 1, "expected m_MeterCounter to be size 1");
static_assert(sizeof(HrBattleIcon::m_Tension) == 8, "expected m_Tension to be size 8");
static_assert(sizeof(HrBattleIcon::m_TMeterRevPos) == 8, "expected m_TMeterRevPos to be size 8");
static_assert(sizeof(HrBattleIcon::m_GetMoney) == 4, "expected m_GetMoney to be size 4");
static_assert(sizeof(HrBattleIcon::m_HitNum) == 4, "expected m_HitNum to be size 4");
static_assert(sizeof(HrBattleIcon::m_HP) == 12, "expected m_HP to be size 12");
static_assert(sizeof(HrBattleIcon::m_SlashFadeCounter) == 2, "expected m_SlashFadeCounter to be size 2");
static_assert(sizeof(HrBattleIcon::m_BottanCounter) == 8, "expected m_BottanCounter to be size 8");
static_assert(sizeof(HrBattleIcon::m_TergetIconCount) == 2, "expected m_TergetIconCount to be size 2");
static_assert(sizeof(HrBattleIcon::m_Direct) == 4, "expected m_Direct to be size 4");
static_assert(sizeof(HrBattleIcon::m_Angle) == 4, "expected m_Angle to be size 4");
static_assert(sizeof(HrBattleIcon::m_Soundid) == 4, "expected m_Soundid to be size 4");
static_assert(sizeof(HrBattleIcon::flag) == 2, "expected flag to be size 2");
static_assert(sizeof(HrBattleIcon::m_bDemo) == 1, "expected m_bDemo to be size 1");
static_assert(sizeof(HrBattleIcon::m_HpGauge) == 116, "expected m_HpGauge to be size 116");
static_assert(sizeof(HrBattleIcon::m_SlashSEStatus) == 4, "expected m_SlashSEStatus to be size 4");
static_assert(sizeof(class HrBattleIcon) == 512, "expected class HrBattleIcon to be size 512");

// enum
enum : uint32_t
{
	// Enum values

	// <E_CON_ACT_NONE = 0xffffffffffffffff>
	E_CON_ACT_NONE = UINT32_MAX,

	// <E_CON_ACT_FURIAGE = 0x0>
	E_CON_ACT_FURIAGE = 0,

	// <E_CON_ACT_UP = 0x1>
	E_CON_ACT_UP = 1,

	// <E_CON_ACT_DOWN = 0x2>
	E_CON_ACT_DOWN = 2,

	// <E_CON_ACT_PUSH = 0x3>
	E_CON_ACT_PUSH = 3,

	// <E_CON_ACT_PULL = 0x4>
	E_CON_ACT_PULL = 4,

	// <E_CON_ACT_RBLOW = 0x5>
	E_CON_ACT_RBLOW = 5,

	// <E_CON_ACT_LBLOW = 0x6>
	E_CON_ACT_LBLOW = 6,

	// <E_CON_ACT_ROTATE = 0x7>
	E_CON_ACT_ROTATE = 7,

	// <E_COM_ACT_CROSS = 0x8>
	E_COM_ACT_CROSS = 8

};

// TODO: Function 'void __convention("thiscall") mot::CBoneEffectDamageData::setup(class mot::CBoneEffectDamageData* const this, class mHRChara* arg2)'
// class HrMap
// no dependencies
class HrMap
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") HrMap::IsDied(class HrMap* const this, class mHRChara* arg2)

	// TODO: Function 'uint8_t __convention("thiscall") HrMap::IsDied(class HrMap* const this, class mHRChara* arg2)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[7844];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrMap>("HrMap")
		.endClass();
	}
#endif
};
static_assert(sizeof(class HrMap) == 7844, "expected class HrMap to be size 7844");

// class ACameraModeBase
// 1 dependencies: class CTimeRatioInterpolate
class ACameraModeBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class CTimeRatioInterpolate m_inRatio, offset 0x4>
	class CTimeRatioInterpolate m_inRatio;

	// <uint8_t m_bIsInitRatioOne, offset 0x10>
	uint8_t m_bIsInitRatioOne;

	// <Filler, offset 0x11>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ACameraModeBase>("ACameraModeBase")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &ACameraModeBase::field_0)
			.addProperty("m_inRatio", &ACameraModeBase::m_inRatio)
			.addProperty("m_bIsInitRatioOne", &ACameraModeBase::m_bIsInitRatioOne)
		.endClass();
	}
#endif
};
static_assert(sizeof(ACameraModeBase::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(ACameraModeBase::m_inRatio) == 12, "expected m_inRatio to be size 12");
static_assert(sizeof(ACameraModeBase::m_bIsInitRatioOne) == 1, "expected m_bIsInitRatioOne to be size 1");
static_assert(sizeof(class ACameraModeBase) == 20, "expected class ACameraModeBase to be size 20");

// class CCameraModeLockOn
// 8 dependencies: class ACameraModeBase, class CTimeRatioInterpolate, class CDoubleSpringInterpolate, class CSpringInterpolate, class tiVector, class vector4x, class vector4f, union __m128
class CCameraModeLockOn : ACameraModeBase
{
public:
	/// 1 namespace types: class mHRChara* __convention("thiscall") CCameraModeLockOn::getLockOnCharacter(class CCameraModeLockOn* const this)

	// TODO: Function 'class mHRChara* __convention("thiscall") CCameraModeLockOn::getLockOnCharacter(class CCameraModeLockOn* const this)'

	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <class CDoubleSpringInterpolate m_inYaw, offset 0x14>
	class CDoubleSpringInterpolate m_inYaw;

	// <class CDoubleSpringInterpolate m_inPitch, offset 0x44>
	class CDoubleSpringInterpolate m_inPitch;

	// <float m_fHopeYaw, offset 0x74>
	float m_fHopeYaw;

	// <float m_fHopePitch, offset 0x78>
	float m_fHopePitch;

	// <Filler, offset 0x7c>
	char _Filler5[4];

	// <class tiVector m_inLockOnPosi, offset 0x80>
	class tiVector m_inLockOnPosi;

	// <float m_fLockOnDist, offset 0x90>
	float m_fLockOnDist;

	// <float m_fEnemySiegeRatio, offset 0x94>
	float m_fEnemySiegeRatio;

	// <uint8_t m_bIsChangeLockOnChara, offset 0x98>
	uint8_t m_bIsChangeLockOnChara;

	// <Filler, offset 0x99>
	char _Filler9[3];

	// <class mHRChara* m_pLockOnChara, offset 0x9c>
	class mHRChara* m_pLockOnChara;

	// <uint8_t m_bStgHit, offset 0xa0>
	uint8_t m_bStgHit;

	// <Filler, offset 0xa1>
	char _Filler[15];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeLockOn>("CCameraModeLockOn")
			.addProperty("m_inYaw", &CCameraModeLockOn::m_inYaw)
			.addProperty("m_inPitch", &CCameraModeLockOn::m_inPitch)
			.addProperty("m_fHopeYaw", &CCameraModeLockOn::m_fHopeYaw)
			.addProperty("m_fHopePitch", &CCameraModeLockOn::m_fHopePitch)
			.addProperty("m_inLockOnPosi", &CCameraModeLockOn::m_inLockOnPosi)
			.addProperty("m_fLockOnDist", &CCameraModeLockOn::m_fLockOnDist)
			.addProperty("m_fEnemySiegeRatio", &CCameraModeLockOn::m_fEnemySiegeRatio)
			.addProperty("m_bIsChangeLockOnChara", &CCameraModeLockOn::m_bIsChangeLockOnChara)
			.addProperty("m_pLockOnChara", &CCameraModeLockOn::m_pLockOnChara)
			.addProperty("m_bStgHit", &CCameraModeLockOn::m_bStgHit)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeLockOn::m_inYaw) == 48, "expected m_inYaw to be size 48");
static_assert(sizeof(CCameraModeLockOn::m_inPitch) == 48, "expected m_inPitch to be size 48");
static_assert(sizeof(CCameraModeLockOn::m_fHopeYaw) == 4, "expected m_fHopeYaw to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_fHopePitch) == 4, "expected m_fHopePitch to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_inLockOnPosi) == 16, "expected m_inLockOnPosi to be size 16");
static_assert(sizeof(CCameraModeLockOn::m_fLockOnDist) == 4, "expected m_fLockOnDist to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_fEnemySiegeRatio) == 4, "expected m_fEnemySiegeRatio to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_bIsChangeLockOnChara) == 1, "expected m_bIsChangeLockOnChara to be size 1");
static_assert(sizeof(CCameraModeLockOn::m_pLockOnChara) == 4, "expected m_pLockOnChara to be size 4");
static_assert(sizeof(CCameraModeLockOn::m_bStgHit) == 1, "expected m_bStgHit to be size 1");
static_assert(sizeof(class CCameraModeLockOn) == 176, "expected class CCameraModeLockOn to be size 176");

// class CCameraVibManager
// no dependencies
class CCameraVibManager
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[576];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraVibManager>("CCameraVibManager")
		.endClass();
	}
#endif
};
static_assert(sizeof(class CCameraVibManager) == 576, "expected class CCameraVibManager to be size 576");

// class CCameraBank
// 2 dependencies: class CDoubleSpringInterpolate, class CSpringInterpolate
class CCameraBank
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inOfst, offset 0x0>
	class CDoubleSpringInterpolate m_inOfst;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraBank>("CCameraBank")
			.addProperty("m_inOfst", &CCameraBank::m_inOfst)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraBank::m_inOfst) == 48, "expected m_inOfst to be size 48");
static_assert(sizeof(class CCameraBank) == 48, "expected class CCameraBank to be size 48");

// class CCameraModeSubjective
// 6 dependencies: class ACameraModeBase, class CTimeRatioInterpolate, class tiVector, class vector4x, class vector4f, union __m128
class CCameraModeSubjective : ACameraModeBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <float m_fTimer, offset 0x14>
	float m_fTimer;

	// <float m_fDisappearTimer, offset 0x18>
	float m_fDisappearTimer;

	// <Filler, offset 0x1c>
	char _Filler3[4];

	// <class tiVector m_inSrcLookAtPosi, offset 0x20>
	class tiVector m_inSrcLookAtPosi;

	// <class tiVector m_inInterpLookAtPosi, offset 0x30>
	class tiVector m_inInterpLookAtPosi;

	// <float m_fSrcDistToLookAt, offset 0x40>
	float m_fSrcDistToLookAt;

	// <float m_fInterpDistToLookAt, offset 0x44>
	float m_fInterpDistToLookAt;

	// <float m_fSrcYaw, offset 0x48>
	float m_fSrcYaw;

	// <float m_fInterpYaw, offset 0x4c>
	float m_fInterpYaw;

	// <float m_fPitch, offset 0x50>
	float m_fPitch;

	// <Filler, offset 0x54>
	char _Filler[12];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeSubjective>("CCameraModeSubjective")
			.addProperty("m_fTimer", &CCameraModeSubjective::m_fTimer)
			.addProperty("m_fDisappearTimer", &CCameraModeSubjective::m_fDisappearTimer)
			.addProperty("m_inSrcLookAtPosi", &CCameraModeSubjective::m_inSrcLookAtPosi)
			.addProperty("m_inInterpLookAtPosi", &CCameraModeSubjective::m_inInterpLookAtPosi)
			.addProperty("m_fSrcDistToLookAt", &CCameraModeSubjective::m_fSrcDistToLookAt)
			.addProperty("m_fInterpDistToLookAt", &CCameraModeSubjective::m_fInterpDistToLookAt)
			.addProperty("m_fSrcYaw", &CCameraModeSubjective::m_fSrcYaw)
			.addProperty("m_fInterpYaw", &CCameraModeSubjective::m_fInterpYaw)
			.addProperty("m_fPitch", &CCameraModeSubjective::m_fPitch)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeSubjective::m_fTimer) == 4, "expected m_fTimer to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fDisappearTimer) == 4, "expected m_fDisappearTimer to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_inSrcLookAtPosi) == 16, "expected m_inSrcLookAtPosi to be size 16");
static_assert(sizeof(CCameraModeSubjective::m_inInterpLookAtPosi) == 16, "expected m_inInterpLookAtPosi to be size 16");
static_assert(sizeof(CCameraModeSubjective::m_fSrcDistToLookAt) == 4, "expected m_fSrcDistToLookAt to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fInterpDistToLookAt) == 4, "expected m_fInterpDistToLookAt to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fSrcYaw) == 4, "expected m_fSrcYaw to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fInterpYaw) == 4, "expected m_fInterpYaw to be size 4");
static_assert(sizeof(CCameraModeSubjective::m_fPitch) == 4, "expected m_fPitch to be size 4");
static_assert(sizeof(class CCameraModeSubjective) == 96, "expected class CCameraModeSubjective to be size 96");

// class CSpringInterpolate3D
// 4 dependencies: class tiVector, class vector4x, class vector4f, union __m128
class CSpringInterpolate3D
{
public:
	/// No namespace types
	/// Struct member variables

	// <float m_fSpringCoe, offset 0x0>
	float m_fSpringCoe;

	// <float m_fMaxVel, offset 0x4>
	float m_fMaxVel;

	// <float m_fMinVel, offset 0x8>
	float m_fMinVel;

	// <uint8_t m_bIsRadiInterp, offset 0xc>
	uint8_t m_bIsRadiInterp;

	// <Filler, offset 0xd>
	char _Filler4[3];

	// <float m_fEpsilon, offset 0x10>
	float m_fEpsilon;

	// <float m_fW, offset 0x14>
	float m_fW;

	// <Filler, offset 0x18>
	char _Filler6[8];

	// <class tiVector m_inValue, offset 0x20>
	class tiVector m_inValue;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CSpringInterpolate3D>("CSpringInterpolate3D")
			.addProperty("m_fSpringCoe", &CSpringInterpolate3D::m_fSpringCoe)
			.addProperty("m_fMaxVel", &CSpringInterpolate3D::m_fMaxVel)
			.addProperty("m_fMinVel", &CSpringInterpolate3D::m_fMinVel)
			.addProperty("m_bIsRadiInterp", &CSpringInterpolate3D::m_bIsRadiInterp)
			.addProperty("m_fEpsilon", &CSpringInterpolate3D::m_fEpsilon)
			.addProperty("m_fW", &CSpringInterpolate3D::m_fW)
			.addProperty("m_inValue", &CSpringInterpolate3D::m_inValue)
		.endClass();
	}
#endif
};
static_assert(sizeof(CSpringInterpolate3D::m_fSpringCoe) == 4, "expected m_fSpringCoe to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fMaxVel) == 4, "expected m_fMaxVel to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fMinVel) == 4, "expected m_fMinVel to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_bIsRadiInterp) == 1, "expected m_bIsRadiInterp to be size 1");
static_assert(sizeof(CSpringInterpolate3D::m_fEpsilon) == 4, "expected m_fEpsilon to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_fW) == 4, "expected m_fW to be size 4");
static_assert(sizeof(CSpringInterpolate3D::m_inValue) == 16, "expected m_inValue to be size 16");
static_assert(sizeof(class CSpringInterpolate3D) == 48, "expected class CSpringInterpolate3D to be size 48");

// class CDoubleSpringInterpolate3D
// 5 dependencies: class CSpringInterpolate3D, class tiVector, class vector4x, class vector4f, union __m128
class CDoubleSpringInterpolate3D
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CSpringInterpolate3D m_inHopeInterp, offset 0x0>
	class CSpringInterpolate3D m_inHopeInterp;

	// <class CSpringInterpolate3D m_inCurInterp, offset 0x30>
	class CSpringInterpolate3D m_inCurInterp;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CDoubleSpringInterpolate3D>("CDoubleSpringInterpolate3D")
			.addProperty("m_inHopeInterp", &CDoubleSpringInterpolate3D::m_inHopeInterp)
			.addProperty("m_inCurInterp", &CDoubleSpringInterpolate3D::m_inCurInterp)
		.endClass();
	}
#endif
};
static_assert(sizeof(CDoubleSpringInterpolate3D::m_inHopeInterp) == 48, "expected m_inHopeInterp to be size 48");
static_assert(sizeof(CDoubleSpringInterpolate3D::m_inCurInterp) == 48, "expected m_inCurInterp to be size 48");
static_assert(sizeof(class CDoubleSpringInterpolate3D) == 96, "expected class CDoubleSpringInterpolate3D to be size 96");

// class CCameraModePetitMovie
// 8 dependencies: class ACameraModeBase, class CTimeRatioInterpolate, class CDoubleSpringInterpolate3D, class CSpringInterpolate3D, class tiVector, class vector4x, class vector4f, union __m128
class CCameraModePetitMovie : ACameraModeBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <Filler, offset 0x14>
	char _Filler1[12];

	// <class CDoubleSpringInterpolate3D m_inAngle, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAngle;

	// <uint8_t m_bAct, offset 0x80>
	uint8_t m_bAct;

	// <Filler, offset 0x81>
	char _Filler3[3];

	// <float m_fLookAtOfstX, offset 0x84>
	float m_fLookAtOfstX;

	// <float m_fLookAtOfstY, offset 0x88>
	float m_fLookAtOfstY;

	// <float m_fDistToLookAt, offset 0x8c>
	float m_fDistToLookAt;

	// <float m_fYawOfst, offset 0x90>
	float m_fYawOfst;

	// <float m_fPitchOfst, offset 0x94>
	float m_fPitchOfst;

	// <Filler, offset 0x98>
	char _Filler[8];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModePetitMovie>("CCameraModePetitMovie")
			.addProperty("m_inAngle", &CCameraModePetitMovie::m_inAngle)
			.addProperty("m_bAct", &CCameraModePetitMovie::m_bAct)
			.addProperty("m_fLookAtOfstX", &CCameraModePetitMovie::m_fLookAtOfstX)
			.addProperty("m_fLookAtOfstY", &CCameraModePetitMovie::m_fLookAtOfstY)
			.addProperty("m_fDistToLookAt", &CCameraModePetitMovie::m_fDistToLookAt)
			.addProperty("m_fYawOfst", &CCameraModePetitMovie::m_fYawOfst)
			.addProperty("m_fPitchOfst", &CCameraModePetitMovie::m_fPitchOfst)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModePetitMovie::m_inAngle) == 96, "expected m_inAngle to be size 96");
static_assert(sizeof(CCameraModePetitMovie::m_bAct) == 1, "expected m_bAct to be size 1");
static_assert(sizeof(CCameraModePetitMovie::m_fLookAtOfstX) == 4, "expected m_fLookAtOfstX to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fLookAtOfstY) == 4, "expected m_fLookAtOfstY to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fDistToLookAt) == 4, "expected m_fDistToLookAt to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fYawOfst) == 4, "expected m_fYawOfst to be size 4");
static_assert(sizeof(CCameraModePetitMovie::m_fPitchOfst) == 4, "expected m_fPitchOfst to be size 4");
static_assert(sizeof(class CCameraModePetitMovie) == 160, "expected class CCameraModePetitMovie to be size 160");

// class CCameraModeCircle
// 2 dependencies: class ACameraModeBase, class CTimeRatioInterpolate
class CCameraModeCircle : ACameraModeBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <uint8_t m_bIsPlusRot, offset 0x14>
	uint8_t m_bIsPlusRot;

	// <Filler, offset 0x15>
	char _Filler2[3];

	// <float m_fRotVel, offset 0x18>
	float m_fRotVel;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeCircle>("CCameraModeCircle")
			.addProperty("m_bIsPlusRot", &CCameraModeCircle::m_bIsPlusRot)
			.addProperty("m_fRotVel", &CCameraModeCircle::m_fRotVel)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeCircle::m_bIsPlusRot) == 1, "expected m_bIsPlusRot to be size 1");
static_assert(sizeof(CCameraModeCircle::m_fRotVel) == 4, "expected m_fRotVel to be size 4");
static_assert(sizeof(class CCameraModeCircle) == 28, "expected class CCameraModeCircle to be size 28");

// class CCameraModeDefaultAngle
// 8 dependencies: class ACameraModeBase, class CTimeRatioInterpolate, class CDoubleSpringInterpolate3D, class CSpringInterpolate3D, class tiVector, class vector4x, class vector4f, union __m128
class CCameraModeDefaultAngle : ACameraModeBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <Filler, offset 0x14>
	char _Filler1[12];

	// <class CDoubleSpringInterpolate3D m_inAngle, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAngle;

	// <class tiVector m_inHopeAngle, offset 0x80>
	class tiVector m_inHopeAngle;

	// <uint8_t m_bIsInputButton, offset 0x90>
	uint8_t m_bIsInputButton;

	// <Filler, offset 0x91>
	char _Filler[15];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeDefaultAngle>("CCameraModeDefaultAngle")
			.addProperty("m_inAngle", &CCameraModeDefaultAngle::m_inAngle)
			.addProperty("m_inHopeAngle", &CCameraModeDefaultAngle::m_inHopeAngle)
			.addProperty("m_bIsInputButton", &CCameraModeDefaultAngle::m_bIsInputButton)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeDefaultAngle::m_inAngle) == 96, "expected m_inAngle to be size 96");
static_assert(sizeof(CCameraModeDefaultAngle::m_inHopeAngle) == 16, "expected m_inHopeAngle to be size 16");
static_assert(sizeof(CCameraModeDefaultAngle::m_bIsInputButton) == 1, "expected m_bIsInputButton to be size 1");
static_assert(sizeof(class CCameraModeDefaultAngle) == 160, "expected class CCameraModeDefaultAngle to be size 160");

// class CCameraModeFree
// 8 dependencies: class ACameraModeBase, class CTimeRatioInterpolate, class CDoubleSpringInterpolate3D, class CSpringInterpolate3D, class tiVector, class vector4x, class vector4f, union __m128
class CCameraModeFree : ACameraModeBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <float m_fInputYaw, offset 0x14>
	float m_fInputYaw;

	// <float m_fInputPitch, offset 0x18>
	float m_fInputPitch;

	// <float m_fKeepTimer, offset 0x1c>
	float m_fKeepTimer;

	// <class CDoubleSpringInterpolate3D m_inAddYP, offset 0x20>
	class CDoubleSpringInterpolate3D m_inAddYP;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeFree>("CCameraModeFree")
			.addProperty("m_fInputYaw", &CCameraModeFree::m_fInputYaw)
			.addProperty("m_fInputPitch", &CCameraModeFree::m_fInputPitch)
			.addProperty("m_fKeepTimer", &CCameraModeFree::m_fKeepTimer)
			.addProperty("m_inAddYP", &CCameraModeFree::m_inAddYP)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeFree::m_fInputYaw) == 4, "expected m_fInputYaw to be size 4");
static_assert(sizeof(CCameraModeFree::m_fInputPitch) == 4, "expected m_fInputPitch to be size 4");
static_assert(sizeof(CCameraModeFree::m_fKeepTimer) == 4, "expected m_fKeepTimer to be size 4");
static_assert(sizeof(CCameraModeFree::m_inAddYP) == 96, "expected m_inAddYP to be size 96");
static_assert(sizeof(class CCameraModeFree) == 128, "expected class CCameraModeFree to be size 128");

// class CCameraModeNormal
// 4 dependencies: class ACameraModeBase, class CTimeRatioInterpolate, class CDoubleSpringInterpolate, class CSpringInterpolate
class CCameraModeNormal : ACameraModeBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <class CDoubleSpringInterpolate m_inYaw, offset 0x14>
	class CDoubleSpringInterpolate m_inYaw;

	// <class CDoubleSpringInterpolate m_inPitch, offset 0x44>
	class CDoubleSpringInterpolate m_inPitch;

	// <float m_fHopeYaw, offset 0x74>
	float m_fHopeYaw;

	// <class CTimeRatioInterpolate m_inYawRatio, offset 0x78>
	class CTimeRatioInterpolate m_inYawRatio;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeNormal>("CCameraModeNormal")
			.addProperty("m_inYaw", &CCameraModeNormal::m_inYaw)
			.addProperty("m_inPitch", &CCameraModeNormal::m_inPitch)
			.addProperty("m_fHopeYaw", &CCameraModeNormal::m_fHopeYaw)
			.addProperty("m_inYawRatio", &CCameraModeNormal::m_inYawRatio)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeNormal::m_inYaw) == 48, "expected m_inYaw to be size 48");
static_assert(sizeof(CCameraModeNormal::m_inPitch) == 48, "expected m_inPitch to be size 48");
static_assert(sizeof(CCameraModeNormal::m_fHopeYaw) == 4, "expected m_fHopeYaw to be size 4");
static_assert(sizeof(CCameraModeNormal::m_inYawRatio) == 12, "expected m_inYawRatio to be size 12");
static_assert(sizeof(class CCameraModeNormal) == 132, "expected class CCameraModeNormal to be size 132");

// class CCameraModeReset
// 2 dependencies: class ACameraModeBase, class CTimeRatioInterpolate
class CCameraModeReset : ACameraModeBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ACameraModeBase field_0, offset 0x0>
	// class ACameraModeBase Super;

	// <uint8_t m_bIsSetResetYaw, offset 0x14>
	uint8_t m_bIsSetResetYaw;

	// <Filler, offset 0x15>
	char _Filler2[3];

	// <float m_fResetYaw, offset 0x18>
	float m_fResetYaw;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeReset>("CCameraModeReset")
			.addProperty("m_bIsSetResetYaw", &CCameraModeReset::m_bIsSetResetYaw)
			.addProperty("m_fResetYaw", &CCameraModeReset::m_fResetYaw)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeReset::m_bIsSetResetYaw) == 1, "expected m_bIsSetResetYaw to be size 1");
static_assert(sizeof(CCameraModeReset::m_fResetYaw) == 4, "expected m_fResetYaw to be size 4");
static_assert(sizeof(class CCameraModeReset) == 28, "expected class CCameraModeReset to be size 28");

// class CCameraDistToLookAt
// 2 dependencies: class CDoubleSpringInterpolate, class CSpringInterpolate
class CCameraDistToLookAt
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CDoubleSpringInterpolate m_inDistToLookAt, offset 0x0>
	class CDoubleSpringInterpolate m_inDistToLookAt;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDistToLookAt>("CCameraDistToLookAt")
			.addProperty("m_inDistToLookAt", &CCameraDistToLookAt::m_inDistToLookAt)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDistToLookAt::m_inDistToLookAt) == 48, "expected m_inDistToLookAt to be size 48");
static_assert(sizeof(class CCameraDistToLookAt) == 48, "expected class CCameraDistToLookAt to be size 48");

// class CCameraFollowRot
// 6 dependencies: class CDoubleSpringInterpolate3D, class CSpringInterpolate3D, class tiVector, class vector4x, class vector4f, union __m128
class CCameraFollowRot
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CDoubleSpringInterpolate3D m_inMove, offset 0x0>
	class CDoubleSpringInterpolate3D m_inMove;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraFollowRot>("CCameraFollowRot")
			.addProperty("m_inMove", &CCameraFollowRot::m_inMove)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraFollowRot::m_inMove) == 96, "expected m_inMove to be size 96");
static_assert(sizeof(class CCameraFollowRot) == 96, "expected class CCameraFollowRot to be size 96");

// class CCameraLookAtOffset
// 7 dependencies: class CTimeRatioInterpolate, class CDoubleSpringInterpolate3D, class CSpringInterpolate3D, class tiVector, class vector4x, class vector4f, union __m128
class CCameraLookAtOffset
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CTimeRatioInterpolate m_inInterpCoeRatio, offset 0x0>
	class CTimeRatioInterpolate m_inInterpCoeRatio;

	// <Filler, offset 0xc>
	char _Filler1[4];

	// <class CDoubleSpringInterpolate3D m_inLocalOfst, offset 0x10>
	class CDoubleSpringInterpolate3D m_inLocalOfst;

	// <class tiVector m_inHopeLocalOfst, offset 0x70>
	class tiVector m_inHopeLocalOfst;

	// <float m_fOfstXTimer, offset 0x80>
	float m_fOfstXTimer;

	// <uint8_t m_bIsOfstRayHit, offset 0x84>
	uint8_t m_bIsOfstRayHit;

	// <Filler, offset 0x85>
	char _Filler5[3];

	// <float m_fOfstRayHitTimer, offset 0x88>
	float m_fOfstRayHitTimer;

	// <float m_fOfstRayHitOfstX, offset 0x8c>
	float m_fOfstRayHitOfstX;

	// <class tiVector m_inCamAxisX, offset 0x90>
	class tiVector m_inCamAxisX;

	// <class tiVector m_inCamAxisY, offset 0xa0>
	class tiVector m_inCamAxisY;

	// <class tiVector m_inCamAxisZ, offset 0xb0>
	class tiVector m_inCamAxisZ;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLookAtOffset>("CCameraLookAtOffset")
			.addProperty("m_inInterpCoeRatio", &CCameraLookAtOffset::m_inInterpCoeRatio)
			.addProperty("m_inLocalOfst", &CCameraLookAtOffset::m_inLocalOfst)
			.addProperty("m_inHopeLocalOfst", &CCameraLookAtOffset::m_inHopeLocalOfst)
			.addProperty("m_fOfstXTimer", &CCameraLookAtOffset::m_fOfstXTimer)
			.addProperty("m_bIsOfstRayHit", &CCameraLookAtOffset::m_bIsOfstRayHit)
			.addProperty("m_fOfstRayHitTimer", &CCameraLookAtOffset::m_fOfstRayHitTimer)
			.addProperty("m_fOfstRayHitOfstX", &CCameraLookAtOffset::m_fOfstRayHitOfstX)
			.addProperty("m_inCamAxisX", &CCameraLookAtOffset::m_inCamAxisX)
			.addProperty("m_inCamAxisY", &CCameraLookAtOffset::m_inCamAxisY)
			.addProperty("m_inCamAxisZ", &CCameraLookAtOffset::m_inCamAxisZ)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLookAtOffset::m_inInterpCoeRatio) == 12, "expected m_inInterpCoeRatio to be size 12");
static_assert(sizeof(CCameraLookAtOffset::m_inLocalOfst) == 96, "expected m_inLocalOfst to be size 96");
static_assert(sizeof(CCameraLookAtOffset::m_inHopeLocalOfst) == 16, "expected m_inHopeLocalOfst to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstXTimer) == 4, "expected m_fOfstXTimer to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_bIsOfstRayHit) == 1, "expected m_bIsOfstRayHit to be size 1");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstRayHitTimer) == 4, "expected m_fOfstRayHitTimer to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_fOfstRayHitOfstX) == 4, "expected m_fOfstRayHitOfstX to be size 4");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisX) == 16, "expected m_inCamAxisX to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisY) == 16, "expected m_inCamAxisY to be size 16");
static_assert(sizeof(CCameraLookAtOffset::m_inCamAxisZ) == 16, "expected m_inCamAxisZ to be size 16");
static_assert(sizeof(class CCameraLookAtOffset) == 192, "expected class CCameraLookAtOffset to be size 192");

// class CCameraLookAtBase
// 6 dependencies: class tiVector, class vector4x, class vector4f, union __m128, class CDoubleSpringInterpolate3D, class CSpringInterpolate3D
class CCameraLookAtBase
{
public:
	/// No namespace types
	/// Struct member variables

	// <class tiVector m_inPosi, offset 0x0>
	class tiVector m_inPosi;

	// <class tiVector m_inPrePosi, offset 0x10>
	class tiVector m_inPrePosi;

	// <class tiVector m_inPreHopePosi, offset 0x20>
	class tiVector m_inPreHopePosi;

	// <class CDoubleSpringInterpolate3D m_inSpringCoe, offset 0x30>
	class CDoubleSpringInterpolate3D m_inSpringCoe;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLookAtBase>("CCameraLookAtBase")
			.addProperty("m_inPosi", &CCameraLookAtBase::m_inPosi)
			.addProperty("m_inPrePosi", &CCameraLookAtBase::m_inPrePosi)
			.addProperty("m_inPreHopePosi", &CCameraLookAtBase::m_inPreHopePosi)
			.addProperty("m_inSpringCoe", &CCameraLookAtBase::m_inSpringCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLookAtBase::m_inPosi) == 16, "expected m_inPosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inPrePosi) == 16, "expected m_inPrePosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inPreHopePosi) == 16, "expected m_inPreHopePosi to be size 16");
static_assert(sizeof(CCameraLookAtBase::m_inSpringCoe) == 96, "expected m_inSpringCoe to be size 96");
static_assert(sizeof(class CCameraLookAtBase) == 144, "expected class CCameraLookAtBase to be size 144");

// class CCameraDefaultAngle
// 4 dependencies: class tiVector, class vector4x, class vector4f, union __m128
class CCameraDefaultAngle
{
public:
	/// No namespace types
	/// Struct member variables

	// <class tiVector m_inDefaultYP, offset 0x0>
	class tiVector m_inDefaultYP;

	// <uint8_t m_bActYawRot, offset 0x10>
	uint8_t m_bActYawRot;

	// <uint8_t m_bIsDownAttackPitchUp, offset 0x11>
	uint8_t m_bIsDownAttackPitchUp;

	// <Filler, offset 0x12>
	char _Filler3[2];

	// <float m_fSlopeCheckDelayTimer, offset 0x14>
	float m_fSlopeCheckDelayTimer;

	// <float m_fSlopeCheckPitchOfst, offset 0x18>
	float m_fSlopeCheckPitchOfst;

	// <int32_t m_nSlopeCheckPhase, offset 0x1c>
	int32_t m_nSlopeCheckPhase;

	// <class tiVector m_inSlopeCheckPosi, offset 0x20>
	class tiVector m_inSlopeCheckPosi;

	// <float m_fSlopeCheckYaw, offset 0x30>
	float m_fSlopeCheckYaw;

	// <Filler, offset 0x34>
	char _Filler8[12];

	// <class tiVector m_inSlopeCheckDir, offset 0x40>
	class tiVector m_inSlopeCheckDir;

	// <class tiVector m_inSlopeCheckTopPosi, offset 0x50>
	class tiVector m_inSlopeCheckTopPosi;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDefaultAngle>("CCameraDefaultAngle")
			.addProperty("m_inDefaultYP", &CCameraDefaultAngle::m_inDefaultYP)
			.addProperty("m_bActYawRot", &CCameraDefaultAngle::m_bActYawRot)
			.addProperty("m_bIsDownAttackPitchUp", &CCameraDefaultAngle::m_bIsDownAttackPitchUp)
			.addProperty("m_fSlopeCheckDelayTimer", &CCameraDefaultAngle::m_fSlopeCheckDelayTimer)
			.addProperty("m_fSlopeCheckPitchOfst", &CCameraDefaultAngle::m_fSlopeCheckPitchOfst)
			.addProperty("m_nSlopeCheckPhase", &CCameraDefaultAngle::m_nSlopeCheckPhase)
			.addProperty("m_inSlopeCheckPosi", &CCameraDefaultAngle::m_inSlopeCheckPosi)
			.addProperty("m_fSlopeCheckYaw", &CCameraDefaultAngle::m_fSlopeCheckYaw)
			.addProperty("m_inSlopeCheckDir", &CCameraDefaultAngle::m_inSlopeCheckDir)
			.addProperty("m_inSlopeCheckTopPosi", &CCameraDefaultAngle::m_inSlopeCheckTopPosi)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDefaultAngle::m_inDefaultYP) == 16, "expected m_inDefaultYP to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_bActYawRot) == 1, "expected m_bActYawRot to be size 1");
static_assert(sizeof(CCameraDefaultAngle::m_bIsDownAttackPitchUp) == 1, "expected m_bIsDownAttackPitchUp to be size 1");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckDelayTimer) == 4, "expected m_fSlopeCheckDelayTimer to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckPitchOfst) == 4, "expected m_fSlopeCheckPitchOfst to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_nSlopeCheckPhase) == 4, "expected m_nSlopeCheckPhase to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckPosi) == 16, "expected m_inSlopeCheckPosi to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_fSlopeCheckYaw) == 4, "expected m_fSlopeCheckYaw to be size 4");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckDir) == 16, "expected m_inSlopeCheckDir to be size 16");
static_assert(sizeof(CCameraDefaultAngle::m_inSlopeCheckTopPosi) == 16, "expected m_inSlopeCheckTopPosi to be size 16");
static_assert(sizeof(class CCameraDefaultAngle) == 96, "expected class CCameraDefaultAngle to be size 96");

// class CCameraLockOnModeData
// no dependencies
class CCameraLockOnModeData
{
public:
	/// No namespace types
	/// Struct member variables

	// <float m_fLookAtOfstMinX, offset 0x0>
	float m_fLookAtOfstMinX;

	// <float m_fLookAtOfstRatioX, offset 0x4>
	float m_fLookAtOfstRatioX;

	// <float m_fLookAtOfstMinY, offset 0x8>
	float m_fLookAtOfstMinY;

	// <float m_fLookAtOfstRatioY, offset 0xc>
	float m_fLookAtOfstRatioY;

	// <float m_fYawOfstMin, offset 0x10>
	float m_fYawOfstMin;

	// <float m_fYawOfstMax, offset 0x14>
	float m_fYawOfstMax;

	// <float m_fPitchMax, offset 0x18>
	float m_fPitchMax;

	// <float m_fPitchMin, offset 0x1c>
	float m_fPitchMin;

	// <float m_fDistToLookAtMin, offset 0x20>
	float m_fDistToLookAtMin;

	// <float m_fDistToLookAtMax, offset 0x24>
	float m_fDistToLookAtMax;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraLockOnModeData>("CCameraLockOnModeData")
			.addProperty("m_fLookAtOfstMinX", &CCameraLockOnModeData::m_fLookAtOfstMinX)
			.addProperty("m_fLookAtOfstRatioX", &CCameraLockOnModeData::m_fLookAtOfstRatioX)
			.addProperty("m_fLookAtOfstMinY", &CCameraLockOnModeData::m_fLookAtOfstMinY)
			.addProperty("m_fLookAtOfstRatioY", &CCameraLockOnModeData::m_fLookAtOfstRatioY)
			.addProperty("m_fYawOfstMin", &CCameraLockOnModeData::m_fYawOfstMin)
			.addProperty("m_fYawOfstMax", &CCameraLockOnModeData::m_fYawOfstMax)
			.addProperty("m_fPitchMax", &CCameraLockOnModeData::m_fPitchMax)
			.addProperty("m_fPitchMin", &CCameraLockOnModeData::m_fPitchMin)
			.addProperty("m_fDistToLookAtMin", &CCameraLockOnModeData::m_fDistToLookAtMin)
			.addProperty("m_fDistToLookAtMax", &CCameraLockOnModeData::m_fDistToLookAtMax)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstMinX) == 4, "expected m_fLookAtOfstMinX to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstRatioX) == 4, "expected m_fLookAtOfstRatioX to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstMinY) == 4, "expected m_fLookAtOfstMinY to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fLookAtOfstRatioY) == 4, "expected m_fLookAtOfstRatioY to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fYawOfstMin) == 4, "expected m_fYawOfstMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fYawOfstMax) == 4, "expected m_fYawOfstMax to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fPitchMax) == 4, "expected m_fPitchMax to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fPitchMin) == 4, "expected m_fPitchMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fDistToLookAtMin) == 4, "expected m_fDistToLookAtMin to be size 4");
static_assert(sizeof(CCameraLockOnModeData::m_fDistToLookAtMax) == 4, "expected m_fDistToLookAtMax to be size 4");
static_assert(sizeof(class CCameraLockOnModeData) == 40, "expected class CCameraLockOnModeData to be size 40");

// class CCameraNormalModeData
// no dependencies
class CCameraNormalModeData
{
public:
	/// No namespace types
	/// Struct member variables

	// <float m_fFollowRotCoe, offset 0x0>
	float m_fFollowRotCoe;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraNormalModeData>("CCameraNormalModeData")
			.addProperty("m_fFollowRotCoe", &CCameraNormalModeData::m_fFollowRotCoe)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraNormalModeData::m_fFollowRotCoe) == 4, "expected m_fFollowRotCoe to be size 4");
static_assert(sizeof(class CCameraNormalModeData) == 4, "expected class CCameraNormalModeData to be size 4");

// class CCameraModeCommonData
// no dependencies
class CCameraModeCommonData
{
public:
	/// No namespace types
	/// Struct member variables

	// <float m_fLookAtOfstMinX, offset 0x0>
	float m_fLookAtOfstMinX;

	// <float m_fLookAtOfstRatioX, offset 0x4>
	float m_fLookAtOfstRatioX;

	// <float m_fLookAtOfstMinY, offset 0x8>
	float m_fLookAtOfstMinY;

	// <float m_fLookAtOfstRatioY, offset 0xc>
	float m_fLookAtOfstRatioY;

	// <float m_fLookAtOfstYDistZero, offset 0x10>
	float m_fLookAtOfstYDistZero;

	// <float m_fDefaultPitchOfst, offset 0x14>
	float m_fDefaultPitchOfst;

	// <int32_t m_bIsAddSlopePitchOfst, offset 0x18>
	int32_t m_bIsAddSlopePitchOfst;

	// <float m_fDistToLookAt, offset 0x1c>
	float m_fDistToLookAt;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraModeCommonData>("CCameraModeCommonData")
			.addProperty("m_fLookAtOfstMinX", &CCameraModeCommonData::m_fLookAtOfstMinX)
			.addProperty("m_fLookAtOfstRatioX", &CCameraModeCommonData::m_fLookAtOfstRatioX)
			.addProperty("m_fLookAtOfstMinY", &CCameraModeCommonData::m_fLookAtOfstMinY)
			.addProperty("m_fLookAtOfstRatioY", &CCameraModeCommonData::m_fLookAtOfstRatioY)
			.addProperty("m_fLookAtOfstYDistZero", &CCameraModeCommonData::m_fLookAtOfstYDistZero)
			.addProperty("m_fDefaultPitchOfst", &CCameraModeCommonData::m_fDefaultPitchOfst)
			.addProperty("m_bIsAddSlopePitchOfst", &CCameraModeCommonData::m_bIsAddSlopePitchOfst)
			.addProperty("m_fDistToLookAt", &CCameraModeCommonData::m_fDistToLookAt)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstMinX) == 4, "expected m_fLookAtOfstMinX to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstRatioX) == 4, "expected m_fLookAtOfstRatioX to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstMinY) == 4, "expected m_fLookAtOfstMinY to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstRatioY) == 4, "expected m_fLookAtOfstRatioY to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fLookAtOfstYDistZero) == 4, "expected m_fLookAtOfstYDistZero to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fDefaultPitchOfst) == 4, "expected m_fDefaultPitchOfst to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_bIsAddSlopePitchOfst) == 4, "expected m_bIsAddSlopePitchOfst to be size 4");
static_assert(sizeof(CCameraModeCommonData::m_fDistToLookAt) == 4, "expected m_fDistToLookAt to be size 4");
static_assert(sizeof(class CCameraModeCommonData) == 32, "expected class CCameraModeCommonData to be size 32");

// class CGameDataLink
// no dependencies
class CGameDataLink
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CGameData* m_pData, offset 0x0>
	class CGameData* m_pData;

	// <int32_t m_nDataIndex, offset 0x4>
	int32_t m_nDataIndex;

	// <class CGameDataManager* m_pDataManager, offset 0x8>
	class CGameDataManager* m_pDataManager;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameDataLink>("CGameDataLink")
			.addProperty("m_pData", &CGameDataLink::m_pData)
			.addProperty("m_nDataIndex", &CGameDataLink::m_nDataIndex)
			.addProperty("m_pDataManager", &CGameDataLink::m_pDataManager)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameDataLink::m_pData) == 4, "expected m_pData to be size 4");
static_assert(sizeof(CGameDataLink::m_nDataIndex) == 4, "expected m_nDataIndex to be size 4");
static_assert(sizeof(CGameDataLink::m_pDataManager) == 4, "expected m_pDataManager to be size 4");
static_assert(sizeof(class CGameDataLink) == 12, "expected class CGameDataLink to be size 12");

// class CCameraDataManager
// 4 dependencies: class CGameDataLink, class CCameraModeCommonData, class CCameraNormalModeData, class CCameraLockOnModeData
class CCameraDataManager
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t m_eEventCond, offset 0x0>
	int32_t m_eEventCond;

	// <class CGameDataLink m_inModeManagerDataLink, offset 0x4>
	class CGameDataLink m_inModeManagerDataLink;

	// <class CGameDataLink m_inModeCommonDataLink, offset 0x10>
	class CGameDataLink m_inModeCommonDataLink;

	// <class CGameDataLink m_inNormalModeDataLink, offset 0x1c>
	class CGameDataLink m_inNormalModeDataLink;

	// <class CGameDataLink m_inLockOnModeDataLink, offset 0x28>
	class CGameDataLink m_inLockOnModeDataLink;

	// <class CCameraModeCommonData m_inModeCommonData, offset 0x34>
	class CCameraModeCommonData m_inModeCommonData;

	// <class CCameraNormalModeData m_inNormalModeData, offset 0x54>
	class CCameraNormalModeData m_inNormalModeData;

	// <class CCameraLockOnModeData m_inLockOnModeData, offset 0x58>
	class CCameraLockOnModeData m_inLockOnModeData;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraDataManager>("CCameraDataManager")
			.addProperty("m_eEventCond", &CCameraDataManager::m_eEventCond)
			.addProperty("m_inModeManagerDataLink", &CCameraDataManager::m_inModeManagerDataLink)
			.addProperty("m_inModeCommonDataLink", &CCameraDataManager::m_inModeCommonDataLink)
			.addProperty("m_inNormalModeDataLink", &CCameraDataManager::m_inNormalModeDataLink)
			.addProperty("m_inLockOnModeDataLink", &CCameraDataManager::m_inLockOnModeDataLink)
			.addProperty("m_inModeCommonData", &CCameraDataManager::m_inModeCommonData)
			.addProperty("m_inNormalModeData", &CCameraDataManager::m_inNormalModeData)
			.addProperty("m_inLockOnModeData", &CCameraDataManager::m_inLockOnModeData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraDataManager::m_eEventCond) == 4, "expected m_eEventCond to be size 4");
static_assert(sizeof(CCameraDataManager::m_inModeManagerDataLink) == 12, "expected m_inModeManagerDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inModeCommonDataLink) == 12, "expected m_inModeCommonDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inNormalModeDataLink) == 12, "expected m_inNormalModeDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inLockOnModeDataLink) == 12, "expected m_inLockOnModeDataLink to be size 12");
static_assert(sizeof(CCameraDataManager::m_inModeCommonData) == 32, "expected m_inModeCommonData to be size 32");
static_assert(sizeof(CCameraDataManager::m_inNormalModeData) == 4, "expected m_inNormalModeData to be size 4");
static_assert(sizeof(CCameraDataManager::m_inLockOnModeData) == 40, "expected m_inLockOnModeData to be size 40");
static_assert(sizeof(class CCameraDataManager) == 128, "expected class CCameraDataManager to be size 128");

// class CCameraAreaManager
// no dependencies
class CCameraAreaManager
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[4336];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraAreaManager>("CCameraAreaManager")
		.endClass();
	}
#endif
};
static_assert(sizeof(class CCameraAreaManager) == 4336, "expected class CCameraAreaManager to be size 4336");

// class gameUtil::CPositionControl
// 4 dependencies: class tiVector, class vector4x, class vector4f, union __m128
namespace gameUtil
{
	class CPositionControl
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class tiVector m_inPosi, offset 0x0>
		class tiVector m_inPosi;

		// <float m_fUpdateDistSqu, offset 0x10>
		float m_fUpdateDistSqu;

		// <Filler, offset 0x14>
		char _Filler[12];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<gameUtil::CPositionControl>("gameUtil::CPositionControl")
				.addProperty("m_inPosi", &gameUtil::CPositionControl::m_inPosi)
				.addProperty("m_fUpdateDistSqu", &gameUtil::CPositionControl::m_fUpdateDistSqu)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(gameUtil::CPositionControl::m_inPosi) == 16, "expected m_inPosi to be size 16");
static_assert(sizeof(gameUtil::CPositionControl::m_fUpdateDistSqu) == 4, "expected m_fUpdateDistSqu to be size 4");
static_assert(sizeof(class gameUtil::CPositionControl) == 32, "expected class gameUtil::CPositionControl to be size 32");

// class CCameraTarget
// 5 dependencies: class tiVector, class vector4x, class vector4f, union __m128, class gameUtil::CPositionControl
class CCameraTarget
{
public:
	/// No namespace types
	/// Struct member variables

	// <class mot::IBoneEffectModel* m_pModel, offset 0x0>
	class mot::IBoneEffectModel* m_pModel;

	// <Filler, offset 0x4>
	char _Filler1[12];

	// <class tiVector m_inCenterPosi, offset 0x10>
	class tiVector m_inCenterPosi;

	// <float m_fYaw, offset 0x20>
	float m_fYaw;

	// <float m_fPitch, offset 0x24>
	float m_fPitch;

	// <uint8_t m_bIsIdleTime, offset 0x28>
	uint8_t m_bIsIdleTime;

	// <uint8_t m_bIsVisible, offset 0x29>
	uint8_t m_bIsVisible;

	// <uint8_t m_bIsVisibleYawExist, offset 0x2a>
	uint8_t m_bIsVisibleYawExist;

	// <Filler, offset 0x2b>
	char _Filler7[1];

	// <float m_fVisibleYaw, offset 0x2c>
	float m_fVisibleYaw;

	// <class gameUtil::CPositionControl m_inVisibleCheckPosi, offset 0x30>
	class gameUtil::CPositionControl m_inVisibleCheckPosi;

	// <float m_fVisiblePosiInterpTimer, offset 0x50>
	float m_fVisiblePosiInterpTimer;

	// <Filler, offset 0x54>
	char _Filler[12];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraTarget>("CCameraTarget")
			.addProperty("m_pModel", &CCameraTarget::m_pModel)
			.addProperty("m_inCenterPosi", &CCameraTarget::m_inCenterPosi)
			.addProperty("m_fYaw", &CCameraTarget::m_fYaw)
			.addProperty("m_fPitch", &CCameraTarget::m_fPitch)
			.addProperty("m_bIsIdleTime", &CCameraTarget::m_bIsIdleTime)
			.addProperty("m_bIsVisible", &CCameraTarget::m_bIsVisible)
			.addProperty("m_bIsVisibleYawExist", &CCameraTarget::m_bIsVisibleYawExist)
			.addProperty("m_fVisibleYaw", &CCameraTarget::m_fVisibleYaw)
			.addProperty("m_inVisibleCheckPosi", &CCameraTarget::m_inVisibleCheckPosi)
			.addProperty("m_fVisiblePosiInterpTimer", &CCameraTarget::m_fVisiblePosiInterpTimer)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraTarget::m_pModel) == 4, "expected m_pModel to be size 4");
static_assert(sizeof(CCameraTarget::m_inCenterPosi) == 16, "expected m_inCenterPosi to be size 16");
static_assert(sizeof(CCameraTarget::m_fYaw) == 4, "expected m_fYaw to be size 4");
static_assert(sizeof(CCameraTarget::m_fPitch) == 4, "expected m_fPitch to be size 4");
static_assert(sizeof(CCameraTarget::m_bIsIdleTime) == 1, "expected m_bIsIdleTime to be size 1");
static_assert(sizeof(CCameraTarget::m_bIsVisible) == 1, "expected m_bIsVisible to be size 1");
static_assert(sizeof(CCameraTarget::m_bIsVisibleYawExist) == 1, "expected m_bIsVisibleYawExist to be size 1");
static_assert(sizeof(CCameraTarget::m_fVisibleYaw) == 4, "expected m_fVisibleYaw to be size 4");
static_assert(sizeof(CCameraTarget::m_inVisibleCheckPosi) == 32, "expected m_inVisibleCheckPosi to be size 32");
static_assert(sizeof(CCameraTarget::m_fVisiblePosiInterpTimer) == 4, "expected m_fVisiblePosiInterpTimer to be size 4");
static_assert(sizeof(class CCameraTarget) == 96, "expected class CCameraTarget to be size 96");

// enum EGameCameraMode
enum EGameCameraMode : uint32_t
{
	// Enum values

	// <GAME_CAMERA_MODE_NONE = 0xffffffffffffffff>
	GAME_CAMERA_MODE_NONE = UINT32_MAX,

	// <GAME_CAMERA_MODE_RESET = 0x0>
	GAME_CAMERA_MODE_RESET = 0,

	// <GAME_CAMERA_MODE_NORMAL = 0x1>
	GAME_CAMERA_MODE_NORMAL = 1,

	// <GAME_CAMERA_MODE_FREE = 0x2>
	GAME_CAMERA_MODE_FREE = 2,

	// <GAME_CAMERA_MODE_DEFAULT_ANGLE = 0x3>
	GAME_CAMERA_MODE_DEFAULT_ANGLE = 3,

	// <GAME_CAMERA_MODE_LOCK_ON = 0x4>
	GAME_CAMERA_MODE_LOCK_ON = 4,

	// <GAME_CAMERA_MODE_CIRCLE = 0x5>
	GAME_CAMERA_MODE_CIRCLE = 5,

	// <GAME_CAMERA_MODE_PETIT_MOVIE = 0x6>
	GAME_CAMERA_MODE_PETIT_MOVIE = 6,

	// <GAME_CAMERA_MODE_SUBJECTIVE = 0x7>
	GAME_CAMERA_MODE_SUBJECTIVE = 7

};

// class ti::CCamera
// 5 dependencies: class tiVector, class vector4x, class vector4f, union __m128, class tiMatrix
namespace ti
{
	class CCamera
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class tiVector m_inPosi, offset 0x0>
		class tiVector m_inPosi;

		// <class tiVector m_inDir, offset 0x10>
		class tiVector m_inDir;

		// <class tiVector m_inUpDir, offset 0x20>
		class tiVector m_inUpDir;

		// <class tiVector m_inLookAtPosi, offset 0x30>
		class tiVector m_inLookAtPosi;

		// <float m_fDistToLookAt, offset 0x40>
		float m_fDistToLookAt;

		// <float m_fYaw, offset 0x44>
		float m_fYaw;

		// <float m_fPitch, offset 0x48>
		float m_fPitch;

		// <float m_fBank, offset 0x4c>
		float m_fBank;

		// <float m_fViewAngleRadi, offset 0x50>
		float m_fViewAngleRadi;

		// <float m_fAspectRatio, offset 0x54>
		float m_fAspectRatio;

		// <Filler, offset 0x58>
		char _Filler10[8];

		// <class tiMatrix m_inWorldMat, offset 0x60>
		class tiMatrix m_inWorldMat;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<ti::CCamera>("ti::CCamera")
				.addProperty("m_inPosi", &ti::CCamera::m_inPosi)
				.addProperty("m_inDir", &ti::CCamera::m_inDir)
				.addProperty("m_inUpDir", &ti::CCamera::m_inUpDir)
				.addProperty("m_inLookAtPosi", &ti::CCamera::m_inLookAtPosi)
				.addProperty("m_fDistToLookAt", &ti::CCamera::m_fDistToLookAt)
				.addProperty("m_fYaw", &ti::CCamera::m_fYaw)
				.addProperty("m_fPitch", &ti::CCamera::m_fPitch)
				.addProperty("m_fBank", &ti::CCamera::m_fBank)
				.addProperty("m_fViewAngleRadi", &ti::CCamera::m_fViewAngleRadi)
				.addProperty("m_fAspectRatio", &ti::CCamera::m_fAspectRatio)
				.addProperty("m_inWorldMat", &ti::CCamera::m_inWorldMat)
			.endClass();
		}
#endif
	};
}
static_assert(sizeof(ti::CCamera::m_inPosi) == 16, "expected m_inPosi to be size 16");
static_assert(sizeof(ti::CCamera::m_inDir) == 16, "expected m_inDir to be size 16");
static_assert(sizeof(ti::CCamera::m_inUpDir) == 16, "expected m_inUpDir to be size 16");
static_assert(sizeof(ti::CCamera::m_inLookAtPosi) == 16, "expected m_inLookAtPosi to be size 16");
static_assert(sizeof(ti::CCamera::m_fDistToLookAt) == 4, "expected m_fDistToLookAt to be size 4");
static_assert(sizeof(ti::CCamera::m_fYaw) == 4, "expected m_fYaw to be size 4");
static_assert(sizeof(ti::CCamera::m_fPitch) == 4, "expected m_fPitch to be size 4");
static_assert(sizeof(ti::CCamera::m_fBank) == 4, "expected m_fBank to be size 4");
static_assert(sizeof(ti::CCamera::m_fViewAngleRadi) == 4, "expected m_fViewAngleRadi to be size 4");
static_assert(sizeof(ti::CCamera::m_fAspectRatio) == 4, "expected m_fAspectRatio to be size 4");
static_assert(sizeof(ti::CCamera::m_inWorldMat) == 64, "expected m_inWorldMat to be size 64");
static_assert(sizeof(class ti::CCamera) == 160, "expected class ti::CCamera to be size 160");

// class CGameCamera
// 37 dependencies: class ti::CCamera, class tiVector, class vector4x, class vector4f, union __m128, class tiMatrix, enum EGameCameraMode, class CCameraTarget, class gameUtil::CPositionControl, class CCameraAreaManager, class CCameraDataManager, class CGameDataLink, class CCameraModeCommonData, class CCameraNormalModeData, class CCameraLockOnModeData, class CCameraDefaultAngle, class CCameraLookAtBase, class CDoubleSpringInterpolate3D, class CSpringInterpolate3D, class CCameraLookAtOffset, class CTimeRatioInterpolate, class CCameraFollowRot, class CCameraDistToLookAt, class CDoubleSpringInterpolate, class CSpringInterpolate, class CCameraModeReset, class ACameraModeBase, class CCameraModeNormal, class CCameraModeFree, class CCameraModeDefaultAngle, class CCameraModeLockOn, class CCameraModeCircle, class CCameraModePetitMovie, class CCameraModeSubjective, class CCameraCollision, class CCameraBank, class CCameraVibManager
class CGameCamera
{
public:
	/// No namespace types
	/// Struct member variables

	// <class ti::CCamera m_inCamera, offset 0x0>
	class ti::CCamera m_inCamera;

	// <float m_fYawVel, offset 0xa0>
	float m_fYawVel;

	// <enum EGameCameraMode m_eMode, offset 0xa4>
	enum EGameCameraMode m_eMode;

	// <int32_t m_nResetModeCounter, offset 0xa8>
	int32_t m_nResetModeCounter;

	// <uint8_t m_bActCircle, offset 0xac>
	uint8_t m_bActCircle;

	// <Filler, offset 0xad>
	char _Filler5[3];

	// <float m_fSearchAreaTimer, offset 0xb0>
	float m_fSearchAreaTimer;

	// <Filler, offset 0xb4>
	char _Filler6[12];

	// <class CCameraTarget m_inTarget, offset 0xc0>
	class CCameraTarget m_inTarget;

	// <class CCameraAreaManager m_inAreaManager, offset 0x120>
	class CCameraAreaManager m_inAreaManager;

	// <class CCameraDataManager m_inDataManager, offset 0x1210>
	class CCameraDataManager m_inDataManager;

	// <class CCameraDefaultAngle m_inDefaultAngle, offset 0x1290>
	class CCameraDefaultAngle m_inDefaultAngle;

	// <class CCameraLookAtBase m_inLookAtBase, offset 0x12f0>
	class CCameraLookAtBase m_inLookAtBase;

	// <class CCameraLookAtOffset m_inLookAtOffset, offset 0x1380>
	class CCameraLookAtOffset m_inLookAtOffset;

	// <class CCameraFollowRot m_inFollowRot, offset 0x1440>
	class CCameraFollowRot m_inFollowRot;

	// <class CCameraDistToLookAt m_inDistToLookAt, offset 0x14a0>
	class CCameraDistToLookAt m_inDistToLookAt;

	// <class CCameraModeReset m_inResetMode, offset 0x14d0>
	class CCameraModeReset m_inResetMode;

	// <class CCameraModeNormal m_inNormalMode, offset 0x14ec>
	class CCameraModeNormal m_inNormalMode;

	// <class CCameraModeFree m_inFreeMode, offset 0x1570>
	class CCameraModeFree m_inFreeMode;

	// <class CCameraModeDefaultAngle m_inDefaultAngleMode, offset 0x15f0>
	class CCameraModeDefaultAngle m_inDefaultAngleMode;

	// <class CCameraModeLockOn m_inLockOnMode, offset 0x1690>
	class CCameraModeLockOn m_inLockOnMode;

	// <class CCameraModeCircle m_inCircleMode, offset 0x1740>
	class CCameraModeCircle m_inCircleMode;

	// <Filler, offset 0x175c>
	char _Filler20[4];

	// <class CCameraModePetitMovie m_inPetitMovieMode, offset 0x1760>
	class CCameraModePetitMovie m_inPetitMovieMode;

	// <class CCameraModeSubjective m_inSubjectiveMode, offset 0x1800>
	class CCameraModeSubjective m_inSubjectiveMode;

	// <class CCameraCollision m_inCollision, offset 0x1860>
	class CCameraCollision m_inCollision;

	// <Filler, offset 0x1861>
	char _Filler23[3];

	// <class CCameraBank m_inBank, offset 0x1864>
	class CCameraBank m_inBank;

	// <Filler, offset 0x1894>
	char _Filler24[12];

	// <class CCameraVibManager m_inVibManager, offset 0x18a0>
	class CCameraVibManager m_inVibManager;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameCamera>("CGameCamera")
			.addProperty("m_inCamera", &CGameCamera::m_inCamera)
			.addProperty("m_fYawVel", &CGameCamera::m_fYawVel)
			.addProperty("m_eMode", &CGameCamera::m_eMode)
			.addProperty("m_nResetModeCounter", &CGameCamera::m_nResetModeCounter)
			.addProperty("m_bActCircle", &CGameCamera::m_bActCircle)
			.addProperty("m_fSearchAreaTimer", &CGameCamera::m_fSearchAreaTimer)
			.addProperty("m_inTarget", &CGameCamera::m_inTarget)
			.addProperty("m_inAreaManager", &CGameCamera::m_inAreaManager)
			.addProperty("m_inDataManager", &CGameCamera::m_inDataManager)
			.addProperty("m_inDefaultAngle", &CGameCamera::m_inDefaultAngle)
			.addProperty("m_inLookAtBase", &CGameCamera::m_inLookAtBase)
			.addProperty("m_inLookAtOffset", &CGameCamera::m_inLookAtOffset)
			.addProperty("m_inFollowRot", &CGameCamera::m_inFollowRot)
			.addProperty("m_inDistToLookAt", &CGameCamera::m_inDistToLookAt)
			.addProperty("m_inResetMode", &CGameCamera::m_inResetMode)
			.addProperty("m_inNormalMode", &CGameCamera::m_inNormalMode)
			.addProperty("m_inFreeMode", &CGameCamera::m_inFreeMode)
			.addProperty("m_inDefaultAngleMode", &CGameCamera::m_inDefaultAngleMode)
			.addProperty("m_inLockOnMode", &CGameCamera::m_inLockOnMode)
			.addProperty("m_inCircleMode", &CGameCamera::m_inCircleMode)
			.addProperty("m_inPetitMovieMode", &CGameCamera::m_inPetitMovieMode)
			.addProperty("m_inSubjectiveMode", &CGameCamera::m_inSubjectiveMode)
			.addProperty("m_inCollision", &CGameCamera::m_inCollision)
			.addProperty("m_inBank", &CGameCamera::m_inBank)
			.addProperty("m_inVibManager", &CGameCamera::m_inVibManager)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameCamera::m_inCamera) == 160, "expected m_inCamera to be size 160");
static_assert(sizeof(CGameCamera::m_fYawVel) == 4, "expected m_fYawVel to be size 4");
static_assert(sizeof(CGameCamera::m_eMode) == 4, "expected m_eMode to be size 4");
static_assert(sizeof(CGameCamera::m_nResetModeCounter) == 4, "expected m_nResetModeCounter to be size 4");
static_assert(sizeof(CGameCamera::m_bActCircle) == 1, "expected m_bActCircle to be size 1");
static_assert(sizeof(CGameCamera::m_fSearchAreaTimer) == 4, "expected m_fSearchAreaTimer to be size 4");
static_assert(sizeof(CGameCamera::m_inTarget) == 96, "expected m_inTarget to be size 96");
static_assert(sizeof(CGameCamera::m_inAreaManager) == 4336, "expected m_inAreaManager to be size 4336");
static_assert(sizeof(CGameCamera::m_inDataManager) == 128, "expected m_inDataManager to be size 128");
static_assert(sizeof(CGameCamera::m_inDefaultAngle) == 96, "expected m_inDefaultAngle to be size 96");
static_assert(sizeof(CGameCamera::m_inLookAtBase) == 144, "expected m_inLookAtBase to be size 144");
static_assert(sizeof(CGameCamera::m_inLookAtOffset) == 192, "expected m_inLookAtOffset to be size 192");
static_assert(sizeof(CGameCamera::m_inFollowRot) == 96, "expected m_inFollowRot to be size 96");
static_assert(sizeof(CGameCamera::m_inDistToLookAt) == 48, "expected m_inDistToLookAt to be size 48");
static_assert(sizeof(CGameCamera::m_inResetMode) == 28, "expected m_inResetMode to be size 28");
static_assert(sizeof(CGameCamera::m_inNormalMode) == 132, "expected m_inNormalMode to be size 132");
static_assert(sizeof(CGameCamera::m_inFreeMode) == 128, "expected m_inFreeMode to be size 128");
static_assert(sizeof(CGameCamera::m_inDefaultAngleMode) == 160, "expected m_inDefaultAngleMode to be size 160");
static_assert(sizeof(CGameCamera::m_inLockOnMode) == 176, "expected m_inLockOnMode to be size 176");
static_assert(sizeof(CGameCamera::m_inCircleMode) == 28, "expected m_inCircleMode to be size 28");
static_assert(sizeof(CGameCamera::m_inPetitMovieMode) == 160, "expected m_inPetitMovieMode to be size 160");
static_assert(sizeof(CGameCamera::m_inSubjectiveMode) == 96, "expected m_inSubjectiveMode to be size 96");
static_assert(sizeof(CGameCamera::m_inCollision) == 1, "expected m_inCollision to be size 1");
static_assert(sizeof(CGameCamera::m_inBank) == 48, "expected m_inBank to be size 48");
static_assert(sizeof(CGameCamera::m_inVibManager) == 576, "expected m_inVibManager to be size 576");
static_assert(sizeof(class CGameCamera) == 6880, "expected class CGameCamera to be size 6880");

// enum ECameraResetType
enum ECameraResetType : uint32_t
{
	// Enum values

	// <CAMERA_RESET_TYPE_NONE = 0x0>
	CAMERA_RESET_TYPE_NONE = 0,

	// <CAMERA_RESET_TYPE_NORMAL = 0x1>
	CAMERA_RESET_TYPE_NORMAL = 1,

	// <CAMERA_RESET_TYPE_SEAMLESS = 0x2>
	CAMERA_RESET_TYPE_SEAMLESS = 2,

	// <CAMERA_RESET_TYPE_SET_YAW = 0x3>
	CAMERA_RESET_TYPE_SET_YAW = 3

};

// class CCameraman
// 41 dependencies: class ti::CCamera, class tiVector, class vector4x, class vector4f, union __m128, class tiMatrix, enum ECameraResetType, enum CCameraman::ECameraMode, class CGameCamera, enum EGameCameraMode, class CCameraTarget, class gameUtil::CPositionControl, class CCameraAreaManager, class CCameraDataManager, class CGameDataLink, class CCameraModeCommonData, class CCameraNormalModeData, class CCameraLockOnModeData, class CCameraDefaultAngle, class CCameraLookAtBase, class CDoubleSpringInterpolate3D, class CSpringInterpolate3D, class CCameraLookAtOffset, class CTimeRatioInterpolate, class CCameraFollowRot, class CCameraDistToLookAt, class CDoubleSpringInterpolate, class CSpringInterpolate, class CCameraModeReset, class ACameraModeBase, class CCameraModeNormal, class CCameraModeFree, class CCameraModeDefaultAngle, class CCameraModeLockOn, class CCameraModeCircle, class CCameraModePetitMovie, class CCameraModeSubjective, class CCameraCollision, class CCameraBank, class CCameraVibManager, enum enCharaType
class CCameraman
{
public:
	/// 2 namespace types: void __convention("thiscall") CCameraman::beginTsubazeriai(class CCameraman* const this, class mHRChara* arg2, float const arg3), enum CCameraman::ECameraMode

	// TODO: Function 'void __convention("thiscall") CCameraman::beginTsubazeriai(class CCameraman* const this, class mHRChara* arg2, float const arg3)'
	// enum CCameraman::ECameraMode
	enum ECameraMode : uint32_t
	{
		// Enum values

		// <CAMERA_MODE_NONE = 0xffffffffffffffff>
		CAMERA_MODE_NONE = UINT32_MAX,

		// <CAMERA_MODE_GAME = 0x0>
		CAMERA_MODE_GAME = 0,

		// <CAMERA_MODE_DEBUG_GLOBAL = 0x1>
		CAMERA_MODE_DEBUG_GLOBAL = 1

	};


	/// Struct member variables

	// <class ti::CCamera m_inCamera, offset 0x0>
	class ti::CCamera m_inCamera;

	// <uint8_t m_bIsCalledOnUpdate, offset 0xa0>
	uint8_t m_bIsCalledOnUpdate;

	// <Filler, offset 0xa1>
	char _Filler2[3];

	// <enum ECameraResetType m_eResetType, offset 0xa4>
	enum ECameraResetType m_eResetType;

	// <enum CCameraman::ECameraMode m_eCamMode, offset 0xa8>
	enum CCameraman::ECameraMode m_eCamMode;

	// <class mot::IBoneEffectModel* m_pTarget, offset 0xac>
	class mot::IBoneEffectModel* m_pTarget;

	// <class CGameCamera m_inGameCamera, offset 0xb0>
	class CGameCamera m_inGameCamera;

	// <uint8_t m_bIsTsubazeriai, offset 0x1b90>
	uint8_t m_bIsTsubazeriai;

	// <Filler, offset 0x1b91>
	char _Filler7[3];

	// <enum enCharaType m_eTsubaTarget, offset 0x1b94>
	enum enCharaType m_eTsubaTarget;

	// <float m_fTsubaSuperiorRatio, offset 0x1b98>
	float m_fTsubaSuperiorRatio;

	// <uint8_t m_bIsTsubaYawPlus, offset 0x1b9c>
	uint8_t m_bIsTsubaYawPlus;

	// <Filler, offset 0x1b9d>
	char _Filler10[3];

	// <int32_t m_nTsubaCamVibID, offset 0x1ba0>
	int32_t m_nTsubaCamVibID;

	// <Filler, offset 0x1ba4>
	char _Filler[12];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CCameraman>("CCameraman")
			.addProperty("m_inCamera", &CCameraman::m_inCamera)
			.addProperty("m_bIsCalledOnUpdate", &CCameraman::m_bIsCalledOnUpdate)
			.addProperty("m_eResetType", &CCameraman::m_eResetType)
			.addProperty("m_eCamMode", &CCameraman::m_eCamMode)
			.addProperty("m_pTarget", &CCameraman::m_pTarget)
			.addProperty("m_inGameCamera", &CCameraman::m_inGameCamera)
			.addProperty("m_bIsTsubazeriai", &CCameraman::m_bIsTsubazeriai)
			.addProperty("m_eTsubaTarget", &CCameraman::m_eTsubaTarget)
			.addProperty("m_fTsubaSuperiorRatio", &CCameraman::m_fTsubaSuperiorRatio)
			.addProperty("m_bIsTsubaYawPlus", &CCameraman::m_bIsTsubaYawPlus)
			.addProperty("m_nTsubaCamVibID", &CCameraman::m_nTsubaCamVibID)
		.endClass();
	}
#endif
};
static_assert(sizeof(CCameraman::m_inCamera) == 160, "expected m_inCamera to be size 160");
static_assert(sizeof(CCameraman::m_bIsCalledOnUpdate) == 1, "expected m_bIsCalledOnUpdate to be size 1");
static_assert(sizeof(CCameraman::m_eResetType) == 4, "expected m_eResetType to be size 4");
static_assert(sizeof(CCameraman::m_eCamMode) == 4, "expected m_eCamMode to be size 4");
static_assert(sizeof(CCameraman::m_pTarget) == 4, "expected m_pTarget to be size 4");
static_assert(sizeof(CCameraman::m_inGameCamera) == 6880, "expected m_inGameCamera to be size 6880");
static_assert(sizeof(CCameraman::m_bIsTsubazeriai) == 1, "expected m_bIsTsubazeriai to be size 1");
static_assert(sizeof(CCameraman::m_eTsubaTarget) == 4, "expected m_eTsubaTarget to be size 4");
static_assert(sizeof(CCameraman::m_fTsubaSuperiorRatio) == 4, "expected m_fTsubaSuperiorRatio to be size 4");
static_assert(sizeof(CCameraman::m_bIsTsubaYawPlus) == 1, "expected m_bIsTsubaYawPlus to be size 1");
static_assert(sizeof(CCameraman::m_nTsubaCamVibID) == 4, "expected m_nTsubaCamVibID to be size 4");
static_assert(sizeof(class CCameraman) == 7088, "expected class CCameraman to be size 7088");

// class CGameData
// no dependencies
class CGameData
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t m_nID, offset 0x0>
	int32_t m_nID;

	// <int32_t m_nRefCounter, offset 0x4>
	int32_t m_nRefCounter;

	// <class CPackFileDataElement* m_pData, offset 0x8>
	class CPackFileDataElement* m_pData;

	// <int32_t m_nDataClassSize, offset 0xc>
	int32_t m_nDataClassSize;

	// <int32_t m_nTotalDataClass, offset 0x10>
	int32_t m_nTotalDataClass;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameData>("CGameData")
			.addProperty("m_nID", &CGameData::m_nID)
			.addProperty("m_nRefCounter", &CGameData::m_nRefCounter)
			.addProperty("m_pData", &CGameData::m_pData)
			.addProperty("m_nDataClassSize", &CGameData::m_nDataClassSize)
			.addProperty("m_nTotalDataClass", &CGameData::m_nTotalDataClass)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameData::m_nID) == 4, "expected m_nID to be size 4");
static_assert(sizeof(CGameData::m_nRefCounter) == 4, "expected m_nRefCounter to be size 4");
static_assert(sizeof(CGameData::m_pData) == 4, "expected m_pData to be size 4");
static_assert(sizeof(CGameData::m_nDataClassSize) == 4, "expected m_nDataClassSize to be size 4");
static_assert(sizeof(CGameData::m_nTotalDataClass) == 4, "expected m_nTotalDataClass to be size 4");
static_assert(sizeof(class CGameData) == 20, "expected class CGameData to be size 20");

// class CPackFileDataElement
// no dependencies
class CPackFileDataElement
{
public:
	/// No namespace types
	/// Struct member variables

	// <char const* m_sName, offset 0x0>
	char const* m_sName;

	// <uint32_t m_nSize, offset 0x4>
	uint32_t m_nSize;

	// <void const* m_pContent, offset 0x8>
	void const* m_pContent;

	// <uint8_t m_endianSwapped, offset 0xc>
	uint8_t m_endianSwapped;

	// <Filler, offset 0xd>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CPackFileDataElement>("CPackFileDataElement")
			.addProperty("m_sName", &CPackFileDataElement::m_sName)
			.addProperty("m_nSize", &CPackFileDataElement::m_nSize)
			// void type not supported in LuaBridge
			//.addProperty("m_pContent", &CPackFileDataElement::m_pContent)
			.addProperty("m_endianSwapped", &CPackFileDataElement::m_endianSwapped)
		.endClass();
	}
#endif
};
static_assert(sizeof(CPackFileDataElement::m_sName) == 4, "expected m_sName to be size 4");
static_assert(sizeof(CPackFileDataElement::m_nSize) == 4, "expected m_nSize to be size 4");
static_assert(sizeof(CPackFileDataElement::m_pContent) == 4, "expected m_pContent to be size 4");
static_assert(sizeof(CPackFileDataElement::m_endianSwapped) == 1, "expected m_endianSwapped to be size 1");
static_assert(sizeof(class CPackFileDataElement) == 16, "expected class CPackFileDataElement to be size 16");

// class CFileData
// no dependencies
class CFileData
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t m_nSize, offset 0x0>
	int32_t m_nSize;

	// <void* m_pData, offset 0x4>
	void* m_pData;

	// <class CStlVector<unsigned char> m_abyData, offset 0x8>
	class std::vector<unsigned char> m_abyData;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CFileData>("CFileData")
			.addProperty("m_nSize", &CFileData::m_nSize)
			// void type not supported in LuaBridge
			//.addProperty("m_pData", &CFileData::m_pData)
			.addProperty("m_abyData", &CFileData::m_abyData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CFileData::m_nSize) == 4, "expected m_nSize to be size 4");
static_assert(sizeof(CFileData::m_pData) == 4, "expected m_pData to be size 4");
static_assert(sizeof(CFileData::m_abyData) == 12, "expected m_abyData to be size 12");
static_assert(sizeof(class CFileData) == 20, "expected class CFileData to be size 20");

// class CPackFileData
// 1 dependencies: class CFileData
class CPackFileData
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CFileData m_inPackData, offset 0x0>
	class CFileData m_inPackData;

	// <class CStlVector<CPackFileDataElement> m_ainElement, offset 0x14>
	class std::vector<CPackFileDataElement> m_ainElement;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CPackFileData>("CPackFileData")
			.addProperty("m_inPackData", &CPackFileData::m_inPackData)
			.addProperty("m_ainElement", &CPackFileData::m_ainElement)
		.endClass();
	}
#endif
};
static_assert(sizeof(CPackFileData::m_inPackData) == 20, "expected m_inPackData to be size 20");
static_assert(sizeof(CPackFileData::m_ainElement) == 12, "expected m_ainElement to be size 12");
static_assert(sizeof(class CPackFileData) == 32, "expected class CPackFileData to be size 32");

// class CGameDataManager
// 2 dependencies: class CPackFileData, class CFileData
class CGameDataManager
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CPackFileData m_inGDPackData, offset 0x0>
	class CPackFileData m_inGDPackData;

	// <class CStlVector<CGameData> m_ainData, offset 0x20>
	class std::vector<CGameData> m_ainData;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CGameDataManager>("CGameDataManager")
			.addProperty("m_inGDPackData", &CGameDataManager::m_inGDPackData)
			.addProperty("m_ainData", &CGameDataManager::m_ainData)
		.endClass();
	}
#endif
};
static_assert(sizeof(CGameDataManager::m_inGDPackData) == 32, "expected m_inGDPackData to be size 32");
static_assert(sizeof(CGameDataManager::m_ainData) == 12, "expected m_ainData to be size 12");
static_assert(sizeof(class CGameDataManager) == 44, "expected class CGameDataManager to be size 44");

// class mHRBattle
// no dependencies
class mHRBattle
{
public:
	/// 8 namespace types: class mHRChara* __convention("thiscall") mHRBattle::GetNpc(class mHRBattle* const this, int32_t arg2), uint8_t __convention("thiscall") mHRBattle::mSetInitCharaPos(class mHRBattle* const this, class mHRChara* arg2, struct Vec& arg3, struct Vec& arg4), uint8_t __convention("thiscall") mHRBattle::mTestNpcType(class mHRBattle* const this, class mHRChara* arg2), int32_t __convention("thiscall") mHRBattle::GetNpcDatIndexByCharPtr(class mHRBattle* const this, class mHRChara* arg2), class mHRChara* __convention("thiscall") mHRBattle::mGetNpcPtr(class mHRBattle* const this, int32_t arg2), class mHRChara* __convention("thiscall") mHRBattle::mGetNpcPtrFromCharaType(class mHRBattle* const this, enum enCharaType arg2), class mHRChara* __convention("thiscall") mHRBattle::mGetObjPtr(class mHRBattle* const this, int32_t arg2, char* arg3), float __convention("thiscall") mHRBattle::mGetNpcMotionSpd(class mHRBattle* const this, class mHRChara* arg2)

	// TODO: Function 'class mHRChara* __convention("thiscall") mHRBattle::GetNpc(class mHRBattle* const this, int32_t arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRBattle::mSetInitCharaPos(class mHRBattle* const this, class mHRChara* arg2, struct Vec& arg3, struct Vec& arg4)'
	// TODO: Function 'uint8_t __convention("thiscall") mHRBattle::mTestNpcType(class mHRBattle* const this, class mHRChara* arg2)'
	// TODO: Function 'int32_t __convention("thiscall") mHRBattle::GetNpcDatIndexByCharPtr(class mHRBattle* const this, class mHRChara* arg2)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRBattle::mGetNpcPtr(class mHRBattle* const this, int32_t arg2)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRBattle::mGetNpcPtrFromCharaType(class mHRBattle* const this, enum enCharaType arg2)'
	// TODO: Function 'class mHRChara* __convention("thiscall") mHRBattle::mGetObjPtr(class mHRBattle* const this, int32_t arg2, char* arg3)'
	// TODO: Function 'float __convention("thiscall") mHRBattle::mGetNpcMotionSpd(class mHRBattle* const this, class mHRChara* arg2)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[146492];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<mHRBattle>("mHRBattle")
		.endClass();
	}
#endif
};
static_assert(sizeof(class mHRBattle) == 146492, "expected class mHRBattle to be size 146492");

// class HrMiniDemoObj
// 3 dependencies: class ghmListObj, enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID, enum HrMiniDemoObj::MDEMO_OBJ_STS
class HrMiniDemoObj : ghmListObj
{
public:
	/// 2 namespace types: enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID, enum HrMiniDemoObj::MDEMO_OBJ_STS

	// enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID
	enum HRMINIDEMOOBJ_KIND_ID : uint32_t
	{
		// Enum values

		// <MDEMO_KIND_TRV = 0x0>
		MDEMO_KIND_TRV = 0,

		// <MDEMO_KIND_MODEL = 0x1>
		MDEMO_KIND_MODEL = 1,

		// <MDEMO_KIND_CAMERA = 0x2>
		MDEMO_KIND_CAMERA = 2,

		// <MDEMO_KIND_SOUND = 0x3>
		MDEMO_KIND_SOUND = 3,

		// <MDEMO_KIND_EFFECT = 0x4>
		MDEMO_KIND_EFFECT = 4,

		// <MDEMO_KIND_MESSAGE = 0x5>
		MDEMO_KIND_MESSAGE = 5,

		// <MDEMO_KIND_BIKE = 0x6>
		MDEMO_KIND_BIKE = 6,

		// <MDEMO_KIND_MAX = 0x7>
		MDEMO_KIND_MAX = 7

	};

	// enum HrMiniDemoObj::MDEMO_OBJ_STS
	enum MDEMO_OBJ_STS : uint32_t
	{
		// Enum values

		// <MDEMO_OBJ_INIT = 0x0>
		MDEMO_OBJ_INIT = 0,

		// <MDEMO_OBJ_IDLE = 0x1>
		MDEMO_OBJ_IDLE = 1,

		// <MDEMO_OBJ_PLAY = 0x2>
		MDEMO_OBJ_PLAY = 2,

		// <MDEMO_OBJ_FIN = 0x3>
		MDEMO_OBJ_FIN = 3,

		// <MDEMO_OBJ_PAUSE = 0x4>
		MDEMO_OBJ_PAUSE = 4,

		// <MDEMO_OBJ_EXIT = 0x5>
		MDEMO_OBJ_EXIT = 5,

		// <MDEMO_OBJ_MAX = 0x6>
		MDEMO_OBJ_MAX = 6

	};


	/// Struct member variables

	// <class ghmListObj field_0, offset 0x0>
	// class ghmListObj Super;

	// <enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID mKind, offset 0x10>
	enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID mKind;

	// <class TGan* mpGan, offset 0x14>
	class TGan* mpGan;

	// <float mStartTick, offset 0x18>
	float mStartTick;

	// <enum HrMiniDemoObj::MDEMO_OBJ_STS mStatus, offset 0x1c>
	enum HrMiniDemoObj::MDEMO_OBJ_STS mStatus;

	// <uint8_t mPause, offset 0x20>
	uint8_t mPause;

	// <uint8_t mEndPause, offset 0x21>
	uint8_t mEndPause;

	// <uint8_t mEndPauseDo, offset 0x22>
	uint8_t mEndPauseDo;

	// <Filler, offset 0x23>
	char _Filler8[5];

	// <uint64_t mName, offset 0x28>
	uint64_t mName;

	// <char mNameStr[0x10], offset 0x30>
	char mNameStr[16];

	// <uint8_t mSHeightflg, offset 0x40>
	uint8_t mSHeightflg;

	// <Filler, offset 0x41>
	char _Filler11[3];

	// <float mSHeight, offset 0x44>
	float mSHeight;

	// <uint8_t mbDrawMirror, offset 0x48>
	uint8_t mbDrawMirror;

	// <uint8_t mbShadowDraw, offset 0x49>
	uint8_t mbShadowDraw;

	// <Filler, offset 0x4a>
	char _Filler[6];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrMiniDemoObj>("HrMiniDemoObj")
			.addProperty("mKind", &HrMiniDemoObj::mKind)
			.addProperty("mpGan", &HrMiniDemoObj::mpGan)
			.addProperty("mStartTick", &HrMiniDemoObj::mStartTick)
			.addProperty("mStatus", &HrMiniDemoObj::mStatus)
			.addProperty("mPause", &HrMiniDemoObj::mPause)
			.addProperty("mEndPause", &HrMiniDemoObj::mEndPause)
			.addProperty("mEndPauseDo", &HrMiniDemoObj::mEndPauseDo)
			.addProperty("mName", &HrMiniDemoObj::mName)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mNameStr", &HrMiniDemoObj::mNameStr)
			.addProperty("mSHeightflg", &HrMiniDemoObj::mSHeightflg)
			.addProperty("mSHeight", &HrMiniDemoObj::mSHeight)
			.addProperty("mbDrawMirror", &HrMiniDemoObj::mbDrawMirror)
			.addProperty("mbShadowDraw", &HrMiniDemoObj::mbShadowDraw)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemoObj::mKind) == 4, "expected mKind to be size 4");
static_assert(sizeof(HrMiniDemoObj::mpGan) == 4, "expected mpGan to be size 4");
static_assert(sizeof(HrMiniDemoObj::mStartTick) == 4, "expected mStartTick to be size 4");
static_assert(sizeof(HrMiniDemoObj::mStatus) == 4, "expected mStatus to be size 4");
static_assert(sizeof(HrMiniDemoObj::mPause) == 1, "expected mPause to be size 1");
static_assert(sizeof(HrMiniDemoObj::mEndPause) == 1, "expected mEndPause to be size 1");
static_assert(sizeof(HrMiniDemoObj::mEndPauseDo) == 1, "expected mEndPauseDo to be size 1");
static_assert(sizeof(HrMiniDemoObj::mName) == 8, "expected mName to be size 8");
static_assert(sizeof(HrMiniDemoObj::mNameStr) == 16, "expected mNameStr to be size 16");
static_assert(sizeof(HrMiniDemoObj::mSHeightflg) == 1, "expected mSHeightflg to be size 1");
static_assert(sizeof(HrMiniDemoObj::mSHeight) == 4, "expected mSHeight to be size 4");
static_assert(sizeof(HrMiniDemoObj::mbDrawMirror) == 1, "expected mbDrawMirror to be size 1");
static_assert(sizeof(HrMiniDemoObj::mbShadowDraw) == 1, "expected mbShadowDraw to be size 1");
static_assert(sizeof(class HrMiniDemoObj) == 80, "expected class HrMiniDemoObj to be size 80");

// class HrMiniDemoModel
// 5 dependencies: class HrMiniDemoObj, class ghmListObj, enum HrMiniDemoObj::HRMINIDEMOOBJ_KIND_ID, enum HrMiniDemoObj::MDEMO_OBJ_STS, struct Vec
class HrMiniDemoModel : HrMiniDemoObj
{
public:
	/// 1 namespace types: void __convention("thiscall") HrMiniDemoModel::HrMiniDemoModel(class HrMiniDemoModel* const this, class TGan* arg2, struct WGanNodeSpec* arg3, class mHRChara* arg4)

	// TODO: Function 'void __convention("thiscall") HrMiniDemoModel::HrMiniDemoModel(class HrMiniDemoModel* const this, class TGan* arg2, struct WGanNodeSpec* arg3, class mHRChara* arg4)'

	/// Struct member variables

	// <class HrMiniDemoObj field_0, offset 0x0>
	// class HrMiniDemoObj Super;

	// <struct WGanNodeSpec* mpGanNodeSpec, offset 0x50>
	struct WGanNodeSpec* mpGanNodeSpec;

	// <class TGmf* mpGmf, offset 0x54>
	class TGmf* mpGmf;

	// <class mHRChara* mpChara, offset 0x58>
	class mHRChara* mpChara;

	// <struct Vec mPos, offset 0x5c>
	struct Vec mPos;

	// <struct Vec mRot, offset 0x68>
	struct Vec mRot;

	// <uint8_t mUseTexShadow, offset 0x74>
	uint8_t mUseTexShadow;

	// <Filler, offset 0x75>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<HrMiniDemoModel>("HrMiniDemoModel")
			.addProperty("mpGanNodeSpec", &HrMiniDemoModel::mpGanNodeSpec)
			.addProperty("mpGmf", &HrMiniDemoModel::mpGmf)
			.addProperty("mpChara", &HrMiniDemoModel::mpChara)
			.addProperty("mPos", &HrMiniDemoModel::mPos)
			.addProperty("mRot", &HrMiniDemoModel::mRot)
			.addProperty("mUseTexShadow", &HrMiniDemoModel::mUseTexShadow)
		.endClass();
	}
#endif
};
static_assert(sizeof(HrMiniDemoModel::mpGanNodeSpec) == 4, "expected mpGanNodeSpec to be size 4");
static_assert(sizeof(HrMiniDemoModel::mpGmf) == 4, "expected mpGmf to be size 4");
static_assert(sizeof(HrMiniDemoModel::mpChara) == 4, "expected mpChara to be size 4");
static_assert(sizeof(HrMiniDemoModel::mPos) == 12, "expected mPos to be size 12");
static_assert(sizeof(HrMiniDemoModel::mRot) == 12, "expected mRot to be size 12");
static_assert(sizeof(HrMiniDemoModel::mUseTexShadow) == 1, "expected mUseTexShadow to be size 1");
static_assert(sizeof(class HrMiniDemoModel) == 120, "expected class HrMiniDemoModel to be size 120");

// TODO: Function 'int32_t sub_4467e6(int32_t* arg1 @ ebp, class mHRPc* arg2 @ esi, class mHRChara* arg3 @ edi)'
// class STG0202
// no dependencies
class STG0202
{
public:
	/// 1 namespace types: void __convention("thiscall") STG0202::CharMoveByConbeyor(class STG0202* const this, class mHRChara* arg2)

	// TODO: Function 'void __convention("thiscall") STG0202::CharMoveByConbeyor(class STG0202* const this, class mHRChara* arg2)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[96];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<STG0202>("STG0202")
		.endClass();
	}
#endif
};
static_assert(sizeof(class STG0202) == 96, "expected class STG0202 to be size 96");

// TODO: Function 'class mot::IBoneEffectPJ* __convention("thiscall") mHRChara::getBoneEffect(class mHRChara* const this)'
// TODO: Function 'class mot::CBoneEffectDamageData* __convention("thiscall") mHRChara::getBoneEffectDamageData(class mHRChara* const this)'
// class PJTateshi
// no dependencies
class PJTateshi
{
public:
	/// 2 namespace types: void __convention("thiscall") PJTateshi::SetZakoAllFuttobiFromPc(class PJTateshi* const this, class mHRChara* arg2), void __convention("thiscall") PJTateshi::SetDemoDamage2PC(class PJTateshi* const this, float const arg2, class mHRChara* arg3)

	// TODO: Function 'void __convention("thiscall") PJTateshi::SetZakoAllFuttobiFromPc(class PJTateshi* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") PJTateshi::SetDemoDamage2PC(class PJTateshi* const this, float const arg2, class mHRChara* arg3)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[492];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJTateshi>("PJTateshi")
		.endClass();
	}
#endif
};
static_assert(sizeof(class PJTateshi) == 492, "expected class PJTateshi to be size 492");

// TODO: Function 'void __convention("thiscall") HrBattleIcon::CHrHpGauge::Initialize(class HrBattleIcon::CHrHpGauge* const this, class mHRChara* arg2)'
// class PJState
// no dependencies
class PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x5], offset 0x0>
	void* (* field_0)[0x5];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJState>("PJState")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &PJState::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJState::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(class PJState) == 4, "expected class PJState to be size 4");

// class ZkState_DownAttack
// 2 dependencies: class PJState, enum ZkState_DownAttack::eStat
class ZkState_DownAttack : PJState
{
public:
	/// 1 namespace types: enum ZkState_DownAttack::eStat

	// enum ZkState_DownAttack::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_Close = 0x0>
		eStat_Close = 0,

		// <eStat_Attacking = 0x1>
		eStat_Attacking = 1

	};


	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum ZkState_DownAttack::eStat m_eStat, offset 0x4>
	enum ZkState_DownAttack::eStat m_eStat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkState_DownAttack>("ZkState_DownAttack")
			.addProperty("m_eStat", &ZkState_DownAttack::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkState_DownAttack::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(class ZkState_DownAttack) == 8, "expected class ZkState_DownAttack to be size 8");

// class State_AwayAfterAttack
// 1 dependencies: class PJState
class State_AwayAfterAttack : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_AwayAfterAttack>("State_AwayAfterAttack")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_AwayAfterAttack) == 4, "expected class State_AwayAfterAttack to be size 4");

// class State_CloseBeforeAttack
// 1 dependencies: class PJState
class State_CloseBeforeAttack : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_CloseBeforeAttack>("State_CloseBeforeAttack")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_CloseBeforeAttack) == 4, "expected class State_CloseBeforeAttack to be size 4");

// class State_StepInAttack
// 1 dependencies: class PJState
class State_StepInAttack : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_StepInAttack>("State_StepInAttack")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_StepInAttack) == 4, "expected class State_StepInAttack to be size 4");

// class State_DownDamage
// 1 dependencies: class PJState
class State_DownDamage : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_DownDamage>("State_DownDamage")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_DownDamage) == 4, "expected class State_DownDamage to be size 4");

// class State_TojoBaseState
// 1 dependencies: class PJState
class State_TojoBaseState : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_TojoBaseState>("State_TojoBaseState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_TojoBaseState) == 4, "expected class State_TojoBaseState to be size 4");

// class State_LeadPcWayPointMove
// 1 dependencies: class PJState
class State_LeadPcWayPointMove : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_LeadPcWayPointMove>("State_LeadPcWayPointMove")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_LeadPcWayPointMove) == 4, "expected class State_LeadPcWayPointMove to be size 4");

// class State_FixTurret
// 1 dependencies: class PJState
class State_FixTurret : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_FixTurret>("State_FixTurret")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_FixTurret) == 4, "expected class State_FixTurret to be size 4");

// class State_WayPointMoveAfterPop
// 1 dependencies: class PJState
class State_WayPointMoveAfterPop : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_WayPointMoveAfterPop>("State_WayPointMoveAfterPop")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_WayPointMoveAfterPop) == 4, "expected class State_WayPointMoveAfterPop to be size 4");

// class State_Tojo_RoomRunner
// 3 dependencies: class State_TojoBaseState, class PJState, enum State_Tojo_RoomRunner::eStat
class State_Tojo_RoomRunner : State_TojoBaseState
{
public:
	/// 1 namespace types: enum State_Tojo_RoomRunner::eStat

	// enum State_Tojo_RoomRunner::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_Ready = 0x1>
		eStat_Ready = 1

	};


	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_RoomRunner::eStat m_eStat, offset 0x4>
	enum State_Tojo_RoomRunner::eStat m_eStat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_RoomRunner>("State_Tojo_RoomRunner")
			.addProperty("m_eStat", &State_Tojo_RoomRunner::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_RoomRunner::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(class State_Tojo_RoomRunner) == 8, "expected class State_Tojo_RoomRunner to be size 8");

// class State_Tojo_AeroBike
// 3 dependencies: class State_TojoBaseState, class PJState, enum State_Tojo_AeroBike::eStat
class State_Tojo_AeroBike : State_TojoBaseState
{
public:
	/// 1 namespace types: enum State_Tojo_AeroBike::eStat

	// enum State_Tojo_AeroBike::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_Ready = 0x1>
		eStat_Ready = 1

	};


	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_AeroBike::eStat m_eStat, offset 0x4>
	enum State_Tojo_AeroBike::eStat m_eStat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_AeroBike>("State_Tojo_AeroBike")
			.addProperty("m_eStat", &State_Tojo_AeroBike::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_AeroBike::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(class State_Tojo_AeroBike) == 8, "expected class State_Tojo_AeroBike to be size 8");

// class State_Tojo_BreakCmnObj
// 3 dependencies: class State_TojoBaseState, class PJState, enum State_Tojo_BreakCmnObj::eStat
class State_Tojo_BreakCmnObj : State_TojoBaseState
{
public:
	/// 1 namespace types: enum State_Tojo_BreakCmnObj::eStat

	// enum State_Tojo_BreakCmnObj::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_WaitBreak = 0x0>
		eStat_WaitBreak = 0,

		// <eStat_BreakMotionPlay = 0x1>
		eStat_BreakMotionPlay = 1

	};


	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_BreakCmnObj::eStat m_eStat, offset 0x4>
	enum State_Tojo_BreakCmnObj::eStat m_eStat;

	// <uint8_t m_boAttacked, offset 0x8>
	uint8_t m_boAttacked;

	// <Filler, offset 0x9>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_BreakCmnObj>("State_Tojo_BreakCmnObj")
			.addProperty("m_eStat", &State_Tojo_BreakCmnObj::m_eStat)
			.addProperty("m_boAttacked", &State_Tojo_BreakCmnObj::m_boAttacked)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_BreakCmnObj::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Tojo_BreakCmnObj::m_boAttacked) == 1, "expected m_boAttacked to be size 1");
static_assert(sizeof(class State_Tojo_BreakCmnObj) == 12, "expected class State_Tojo_BreakCmnObj to be size 12");

// class State_Tojo_JumpOff
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Tojo_JumpOff : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <float m_fSpdY, offset 0x4>
	float m_fSpdY;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_JumpOff>("State_Tojo_JumpOff")
			.addProperty("m_fSpdY", &State_Tojo_JumpOff::m_fSpdY)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_JumpOff::m_fSpdY) == 4, "expected m_fSpdY to be size 4");
static_assert(sizeof(class State_Tojo_JumpOff) == 8, "expected class State_Tojo_JumpOff to be size 8");

// class State_Tojo_Car
// 3 dependencies: class State_TojoBaseState, class PJState, enum State_Tojo_Car::eStat
class State_Tojo_Car : State_TojoBaseState
{
public:
	/// 1 namespace types: enum State_Tojo_Car::eStat

	// enum State_Tojo_Car::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_GetOff = 0x1>
		eStat_GetOff = 1

	};


	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

	// <enum State_Tojo_Car::eStat m_eStat, offset 0x4>
	enum State_Tojo_Car::eStat m_eStat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_Car>("State_Tojo_Car")
			.addProperty("m_eStat", &State_Tojo_Car::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Car::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(class State_Tojo_Car) == 8, "expected class State_Tojo_Car to be size 8");

// class State_Tojo_RunAndTurnPc
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Tojo_RunAndTurnPc : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_RunAndTurnPc>("State_Tojo_RunAndTurnPc")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Tojo_RunAndTurnPc) == 4, "expected class State_Tojo_RunAndTurnPc to be size 4");

// class State_Idle
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Idle : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Idle>("State_Idle")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Idle) == 4, "expected class State_Idle to be size 4");

// class State_Tojo_AgainstWall
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Tojo_AgainstWall : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_AgainstWall>("State_Tojo_AgainstWall")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Tojo_AgainstWall) == 4, "expected class State_Tojo_AgainstWall to be size 4");

// class State_Tojo_LookAround
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Tojo_LookAround : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_LookAround>("State_Tojo_LookAround")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Tojo_LookAround) == 4, "expected class State_Tojo_LookAround to be size 4");

// class State_Tojo_Stand
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Tojo_Stand : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_Stand>("State_Tojo_Stand")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Tojo_Stand) == 4, "expected class State_Tojo_Stand to be size 4");

// class State_Tojo_Bench
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Tojo_Bench : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_Bench>("State_Tojo_Bench")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Tojo_Bench) == 4, "expected class State_Tojo_Bench to be size 4");

// class State_Tojo_Sit
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Tojo_Sit : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_Sit>("State_Tojo_Sit")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Tojo_Sit) == 4, "expected class State_Tojo_Sit to be size 4");

// class State_Tojo_SuddenAttack
// 2 dependencies: class State_TojoBaseState, class PJState
class State_Tojo_SuddenAttack : State_TojoBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_TojoBaseState field_0, offset 0x0>
	// class State_TojoBaseState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_SuddenAttack>("State_Tojo_SuddenAttack")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Tojo_SuddenAttack) == 4, "expected class State_Tojo_SuddenAttack to be size 4");

// class State_ReleaseWaitIdle
// 3 dependencies: class State_Idle, class State_TojoBaseState, class PJState
class State_ReleaseWaitIdle : State_Idle
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_Idle field_0, offset 0x0>
	// class State_Idle Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_ReleaseWaitIdle>("State_ReleaseWaitIdle")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_ReleaseWaitIdle) == 4, "expected class State_ReleaseWaitIdle to be size 4");

// class State_Scare_Base
// 1 dependencies: class PJState
class State_Scare_Base : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_Cnt, offset 0x4>
	int32_t m_Cnt;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Scare_Base>("State_Scare_Base")
			.addProperty("m_Cnt", &State_Scare_Base::m_Cnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Scare_Base::m_Cnt) == 4, "expected m_Cnt to be size 4");
static_assert(sizeof(class State_Scare_Base) == 8, "expected class State_Scare_Base to be size 8");

// class State_Scare_Kosinukasi
// 2 dependencies: class State_Scare_Base, class PJState
class State_Scare_Kosinukasi : State_Scare_Base
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Scare_Kosinukasi>("State_Scare_Kosinukasi")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Scare_Kosinukasi) == 8, "expected class State_Scare_Kosinukasi to be size 8");

// class State_Scare_Run
// 2 dependencies: class State_Scare_Base, class PJState
class State_Scare_Run : State_Scare_Base
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Scare_Run>("State_Scare_Run")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Scare_Run) == 8, "expected class State_Scare_Run to be size 8");

// class State_WayPointMove
// 2 dependencies: class PJState, enum State_WayPointMove::eWaypointSbSt
class State_WayPointMove : PJState
{
public:
	/// 1 namespace types: enum State_WayPointMove::eWaypointSbSt

	// enum State_WayPointMove::eWaypointSbSt
	enum eWaypointSbSt : uint32_t
	{
		// Enum values

		// <eWaypointSbSt_UNKNOWN = 0xffffffffffffffff>
		eWaypointSbSt_UNKNOWN = UINT32_MAX,

		// <eWaypointSbSt_WayPoint = 0x0>
		eWaypointSbSt_WayPoint = 0,

		// <eWaypointSbSt_ClosePc = 0x1>
		eWaypointSbSt_ClosePc = 1

	};


	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_WayPointMove::eWaypointSbSt m_eStat, offset 0x4>
	enum State_WayPointMove::eWaypointSbSt m_eStat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_WayPointMove>("State_WayPointMove")
			.addProperty("m_eStat", &State_WayPointMove::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_WayPointMove::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(class State_WayPointMove) == 8, "expected class State_WayPointMove to be size 8");

// class State_Pressure
// 2 dependencies: class PJState, enum State_Pressure::eStat
class State_Pressure : PJState
{
public:
	/// 1 namespace types: enum State_Pressure::eStat

	// enum State_Pressure::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_CLOSE = 0x0>
		eStat_CLOSE = 0,

		// <eStat_WAIT = 0x1>
		eStat_WAIT = 1,

		// <eStat_AWAY = 0x2>
		eStat_AWAY = 2

	};


	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_Pressure::eStat m_eStat, offset 0x4>
	enum State_Pressure::eStat m_eStat;

	// <int32_t m_WaitCnt, offset 0x8>
	int32_t m_WaitCnt;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Pressure>("State_Pressure")
			.addProperty("m_eStat", &State_Pressure::m_eStat)
			.addProperty("m_WaitCnt", &State_Pressure::m_WaitCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Pressure::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Pressure::m_WaitCnt) == 4, "expected m_WaitCnt to be size 4");
static_assert(sizeof(class State_Pressure) == 12, "expected class State_Pressure to be size 12");

// class State_ThroughDamage
// 1 dependencies: class PJState
class State_ThroughDamage : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <uint8_t m_boHitSword, offset 0x4>
	uint8_t m_boHitSword;

	// <Filler, offset 0x5>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_ThroughDamage>("State_ThroughDamage")
			.addProperty("m_boHitSword", &State_ThroughDamage::m_boHitSword)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ThroughDamage::m_boHitSword) == 1, "expected m_boHitSword to be size 1");
static_assert(sizeof(class State_ThroughDamage) == 8, "expected class State_ThroughDamage to be size 8");

// enum eMoveDir
enum eMoveDir : uint32_t
{
	// Enum values

	// <eMoveDir_Left = 0x0>
	eMoveDir_Left = 0,

	// <eMoveDir_Right = 0x1>
	eMoveDir_Right = 1,

	// <eMoveDir_Forward = 0x2>
	eMoveDir_Forward = 2,

	// <eMoveDir_Back = 0x3>
	eMoveDir_Back = 3,

	// <eMoveDir_Idle = 0x4>
	eMoveDir_Idle = 4,

	// <eMoveDir_NumMax = 0x5>
	eMoveDir_NumMax = 5

};

// class State_Defence
// 2 dependencies: class PJState, enum eMoveDir
class State_Defence : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum eMoveDir m_eStateMovDir, offset 0x4>
	enum eMoveDir m_eStateMovDir;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Defence>("State_Defence")
			.addProperty("m_eStateMovDir", &State_Defence::m_eStateMovDir)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Defence::m_eStateMovDir) == 4, "expected m_eStateMovDir to be size 4");
static_assert(sizeof(class State_Defence) == 8, "expected class State_Defence to be size 8");

// class State_Evacuate
// 1 dependencies: class PJState
class State_Evacuate : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_nContinueEvacuate, offset 0x4>
	int32_t m_nContinueEvacuate;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Evacuate>("State_Evacuate")
			.addProperty("m_nContinueEvacuate", &State_Evacuate::m_nContinueEvacuate)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Evacuate::m_nContinueEvacuate) == 4, "expected m_nContinueEvacuate to be size 4");
static_assert(sizeof(class State_Evacuate) == 8, "expected class State_Evacuate to be size 8");

// class State_ComboAttack
// 2 dependencies: class PJState, enum State_ComboAttack::eStat
class State_ComboAttack : PJState
{
public:
	/// 1 namespace types: enum State_ComboAttack::eStat

	// enum State_ComboAttack::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_ATTACKSTART = 0x0>
		eStat_ATTACKSTART = 0,

		// <eStat_ATTACKING = 0x1>
		eStat_ATTACKING = 1

	};


	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum State_ComboAttack::eStat m_eStat, offset 0x4>
	enum State_ComboAttack::eStat m_eStat;

	// <uint8_t m_ComboRequest, offset 0x8>
	uint8_t m_ComboRequest;

	// <Filler, offset 0x9>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_ComboAttack>("State_ComboAttack")
			.addProperty("m_eStat", &State_ComboAttack::m_eStat)
			.addProperty("m_ComboRequest", &State_ComboAttack::m_ComboRequest)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_ComboAttack::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_ComboAttack::m_ComboRequest) == 1, "expected m_ComboRequest to be size 1");
static_assert(sizeof(class State_ComboAttack) == 12, "expected class State_ComboAttack to be size 12");

// class State_Damage
// 2 dependencies: class PJState, enum State_Damage::eStat
class State_Damage : PJState
{
public:
	/// 1 namespace types: enum State_Damage::eStat

	// enum State_Damage::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_Init = 0xffffffffffffffff>
		eStat_Init = UINT32_MAX,

		// <eStat_DmgNormal = 0x0>
		eStat_DmgNormal = 0,

		// <eStat_DmgUchiage = 0x1>
		eStat_DmgUchiage = 1,

		// <eStat_Dmg2Down = 0x2>
		eStat_Dmg2Down = 2,

		// <eStat_DmgDownLoop = 0x3>
		eStat_DmgDownLoop = 3,

		// <eStat_DmgWakeUp = 0x4>
		eStat_DmgWakeUp = 4,

		// <eStat_DmgPiyori = 0x5>
		eStat_DmgPiyori = 5,

		// <eStat_ExitDamageState = 0x6>
		eStat_ExitDamageState = 6

	};


	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <int32_t m_DownCnt, offset 0x4>
	int32_t m_DownCnt;

	// <enum State_Damage::eStat m_eStat, offset 0x8>
	enum State_Damage::eStat m_eStat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Damage>("State_Damage")
			.addProperty("m_DownCnt", &State_Damage::m_DownCnt)
			.addProperty("m_eStat", &State_Damage::m_eStat)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Damage::m_DownCnt) == 4, "expected m_DownCnt to be size 4");
static_assert(sizeof(State_Damage::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(class State_Damage) == 12, "expected class State_Damage to be size 12");

// struct CollInfo
// no dependencies
struct CollInfo
{
public:
	/// No namespace types
	/// Struct member variables

	// <float fDistLeft, offset 0x0>
	float fDistLeft;

	// <float fDistRight, offset 0x4>
	float fDistRight;

	// <float fDistBack, offset 0x8>
	float fDistBack;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CollInfo>("CollInfo")
			.addProperty("fDistLeft", &CollInfo::fDistLeft)
			.addProperty("fDistRight", &CollInfo::fDistRight)
			.addProperty("fDistBack", &CollInfo::fDistBack)
		.endClass();
	}
#endif
};
static_assert(sizeof(CollInfo::fDistLeft) == 4, "expected fDistLeft to be size 4");
static_assert(sizeof(CollInfo::fDistRight) == 4, "expected fDistRight to be size 4");
static_assert(sizeof(CollInfo::fDistBack) == 4, "expected fDistBack to be size 4");
static_assert(sizeof(struct CollInfo) == 12, "expected struct CollInfo to be size 12");

// struct tagHRTASKCHECK
// no dependencies
struct tagHRTASKCHECK
{
public:
	/// No namespace types
	/// Struct member variables

	// <class HrTask* Task, offset 0x0>
	class HrTask* Task;

	// <uint32_t MagicNumber, offset 0x4>
	uint32_t MagicNumber;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagHRTASKCHECK>("tagHRTASKCHECK")
			.addProperty("Task", &tagHRTASKCHECK::Task)
			.addProperty("MagicNumber", &tagHRTASKCHECK::MagicNumber)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagHRTASKCHECK::Task) == 4, "expected Task to be size 4");
static_assert(sizeof(tagHRTASKCHECK::MagicNumber) == 4, "expected MagicNumber to be size 4");
static_assert(sizeof(struct tagHRTASKCHECK) == 8, "expected struct tagHRTASKCHECK to be size 8");

// enum eScareType
enum eScareType : uint32_t
{
	// Enum values

	// <eScareType_NO_SCARE = 0xffffffffffffffff>
	eScareType_NO_SCARE = UINT32_MAX,

	// <eScareType_Tiger = 0x0>
	eScareType_Tiger = 0,

	// <eScareType_FriendDead = 0x1>
	eScareType_FriendDead = 1

};

// enum eZkStat
enum eZkStat : uint32_t
{
	// Enum values

	// <eZkCmnStat_INVALID = 0xffffffffffffffff>
	eZkCmnStat_INVALID = UINT32_MAX,

	// <eZkCmnStat_IDLE = 0x0>
	eZkCmnStat_IDLE = 0,

	// <eZkCmnStat_GLOBAL = 0x1>
	eZkCmnStat_GLOBAL = 1,

	// <eZkCmnStat_CLOSE = 0x2>
	eZkCmnStat_CLOSE = 2,

	// <eZkCmnStat_OBSERV = 0x3>
	eZkCmnStat_OBSERV = 3,

	// <eZkCmnStat_SIDEMOVE = 0x4>
	eZkCmnStat_SIDEMOVE = 4,

	// <eZkCmnStat_CloseBeforeATK = 0x5>
	eZkCmnStat_CloseBeforeATK = 5,

	// <eZkCmnStat_AwayAfterATK = 0x6>
	eZkCmnStat_AwayAfterATK = 6,

	// <eZkCmnStat_StepInATK = 0x7>
	eZkCmnStat_StepInATK = 7,

	// <eZkCmnStat_ComboATK = 0x8>
	eZkCmnStat_ComboATK = 8,

	// <eZkCmnStat_RUNAWAY = 0x9>
	eZkCmnStat_RUNAWAY = 9,

	// <eZkCmnStat_DEFENCE = 0xa>
	eZkCmnStat_DEFENCE = 10,

	// <eZkCmnStat_RANDOMMOVE = 0xb>
	eZkCmnStat_RANDOMMOVE = 11,

	// <eZkCmnStat_EVACUATION = 0xc>
	eZkCmnStat_EVACUATION = 12,

	// <eZkCmnStat_DAMAGE = 0xd>
	eZkCmnStat_DAMAGE = 13,

	// <eZkCmnStat_THROUGHDAMAGE = 0xe>
	eZkCmnStat_THROUGHDAMAGE = 14,

	// <eZkCmnStat_DOWNDAMAGE = 0xf>
	eZkCmnStat_DOWNDAMAGE = 15,

	// <eZkCmnStat_GUARD = 0x10>
	eZkCmnStat_GUARD = 16,

	// <eZkCmnStat_DYING = 0x11>
	eZkCmnStat_DYING = 17,

	// <eZkCmnStat_DEBUG = 0x12>
	eZkCmnStat_DEBUG = 18,

	// <eZkCmnStat_GETPCBEHIND = 0x13>
	eZkCmnStat_GETPCBEHIND = 19,

	// <eZkCmnStat_GO2FIGHTLINE = 0x14>
	eZkCmnStat_GO2FIGHTLINE = 20,

	// <eZkCmnStat_OUTFIELD = 0x15>
	eZkCmnStat_OUTFIELD = 21,

	// <eZkCmnStat_CAUTION = 0x16>
	eZkCmnStat_CAUTION = 22,

	// <eZkCmnStat_NOPROC = 0x17>
	eZkCmnStat_NOPROC = 23,

	// <eZkCmnStat_PRESSURE = 0x18>
	eZkCmnStat_PRESSURE = 24,

	// <eZkCmnStat_PATHFIND2PC = 0x19>
	eZkCmnStat_PATHFIND2PC = 25,

	// <eZkCmnStat_WAYPOINTMOVE = 0x1a>
	eZkCmnStat_WAYPOINTMOVE = 26,

	// <eZkCmnStat_LeadPcWayPointMove = 0x1b>
	eZkCmnStat_LeadPcWayPointMove = 27,

	// <eZkCmnStat_FixTurret = 0x1c>
	eZkCmnStat_FixTurret = 28,

	// <eZkCmnStat_WayPointMoveAfterPop = 0x1d>
	eZkCmnStat_WayPointMoveAfterPop = 29,

	// <eZkCmnStat_DownAttack = 0x1e>
	eZkCmnStat_DownAttack = 30,

	// <eZkCmnStat_SCARE_RUN = 0x1f>
	eZkCmnStat_SCARE_RUN = 31,

	// <eZkCmnStat_SCARE_KOSINUKASI = 0x20>
	eZkCmnStat_SCARE_KOSINUKASI = 32,

	// <eZkCmnStat_SCARE_YOTUNBAI = 0x21>
	eZkCmnStat_SCARE_YOTUNBAI = 33,

	// <eZkCmnStat_SCARE_STAND = 0x22>
	eZkCmnStat_SCARE_STAND = 34,

	// <eZkCmnStat_PerformIll = 0x23>
	eZkCmnStat_PerformIll = 35,

	// <eZkCmnStat_RELEASEWAIT_IDLE = 0x24>
	eZkCmnStat_RELEASEWAIT_IDLE = 36,

	// <eZkCmnStat_TOJO_RunAndTurnPc = 0x25>
	eZkCmnStat_TOJO_RunAndTurnPc = 37,

	// <eZkCmnStat_TOJO_AgainstWall = 0x26>
	eZkCmnStat_TOJO_AgainstWall = 38,

	// <eZkCmnStat_TOJO_LookAround = 0x27>
	eZkCmnStat_TOJO_LookAround = 39,

	// <eZkCmnStat_TOJO_Stand = 0x28>
	eZkCmnStat_TOJO_Stand = 40,

	// <eZkCmnStat_TOJO_Bench = 0x29>
	eZkCmnStat_TOJO_Bench = 41,

	// <eZkCmnStat_TOJO_Sit = 0x2a>
	eZkCmnStat_TOJO_Sit = 42,

	// <eZkCmnStat_TOJO_Car = 0x2b>
	eZkCmnStat_TOJO_Car = 43,

	// <eZkCmnStat_TOJO_JumpOff = 0x2c>
	eZkCmnStat_TOJO_JumpOff = 44,

	// <eZkCmnStat_TOJO_BreakCmnObj = 0x2d>
	eZkCmnStat_TOJO_BreakCmnObj = 45,

	// <eZkCmnStat_TOJO_AeroBike = 0x2e>
	eZkCmnStat_TOJO_AeroBike = 46,

	// <eZkCmnStat_TOJO_RoomRunner = 0x2f>
	eZkCmnStat_TOJO_RoomRunner = 47,

	// <eZkCmnStat_TOJO_SuddenAttack = 0x30>
	eZkCmnStat_TOJO_SuddenAttack = 48,

	// <eZkCmnStat_UNDERCTRL_MOVE = 0x31>
	eZkCmnStat_UNDERCTRL_MOVE = 49,

	// <eZkCmnStat_UNDERCTRL_ATTACK = 0x32>
	eZkCmnStat_UNDERCTRL_ATTACK = 50,

	// <eZkCmnStat_UNDERCTRL_EVACUATE = 0x33>
	eZkCmnStat_UNDERCTRL_EVACUATE = 51,

	// <eZkCmnStat_UNDERCTRL_GUARD = 0x34>
	eZkCmnStat_UNDERCTRL_GUARD = 52,

	// <eZkCmnStat_UNDERCTRL_DAMAGE = 0x35>
	eZkCmnStat_UNDERCTRL_DAMAGE = 53,

	// <eZkCmnStat_NUM = 0x36>
	eZkCmnStat_NUM = 54

};

// enum FightSpirit
enum FightSpirit : uint32_t
{
	// Enum values

	// <e_Defensive = 0x0>
	e_Defensive = 0,

	// <e_Offensive = 0x1>
	e_Offensive = 1,

	// <e_FsStatNum = 0x2>
	e_FsStatNum = 2

};

// enum eFightLine
enum eFightLine : uint32_t
{
	// Enum values

	// <eFightLine_Init = 0xffffffffffffffff>
	eFightLine_Init = UINT32_MAX,

	// <eFightLine_Defence = 0x0>
	eFightLine_Defence = 0,

	// <eFightLine_SideMove = 0x1>
	eFightLine_SideMove = 1,

	// <eFightLine_OutField = 0x2>
	eFightLine_OutField = 2,

	// <eFightLine_NUM = 0x3>
	eFightLine_NUM = 3

};

// struct ZkGuardParam
// no dependencies
struct ZkGuardParam
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t GrdCnt, offset 0x0>
	int32_t GrdCnt;

	// <int32_t nGrdCombo, offset 0x4>
	int32_t nGrdCombo;

	// <int32_t GrdStiffCnt, offset 0x8>
	int32_t GrdStiffCnt;

	// <uint8_t boGrdStiff, offset 0xc>
	uint8_t boGrdStiff;

	// <Filler, offset 0xd>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkGuardParam>("ZkGuardParam")
			.addProperty("GrdCnt", &ZkGuardParam::GrdCnt)
			.addProperty("nGrdCombo", &ZkGuardParam::nGrdCombo)
			.addProperty("GrdStiffCnt", &ZkGuardParam::GrdStiffCnt)
			.addProperty("boGrdStiff", &ZkGuardParam::boGrdStiff)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkGuardParam::GrdCnt) == 4, "expected GrdCnt to be size 4");
static_assert(sizeof(ZkGuardParam::nGrdCombo) == 4, "expected nGrdCombo to be size 4");
static_assert(sizeof(ZkGuardParam::GrdStiffCnt) == 4, "expected GrdStiffCnt to be size 4");
static_assert(sizeof(ZkGuardParam::boGrdStiff) == 1, "expected boGrdStiff to be size 1");
static_assert(sizeof(struct ZkGuardParam) == 16, "expected struct ZkGuardParam to be size 16");

// struct ZkEvacuateParam
// no dependencies
struct ZkEvacuateParam
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t EvcCnt, offset 0x0>
	int32_t EvcCnt;

	// <int32_t nEvcCombo, offset 0x4>
	int32_t nEvcCombo;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkEvacuateParam>("ZkEvacuateParam")
			.addProperty("EvcCnt", &ZkEvacuateParam::EvcCnt)
			.addProperty("nEvcCombo", &ZkEvacuateParam::nEvcCombo)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkEvacuateParam::EvcCnt) == 4, "expected EvcCnt to be size 4");
static_assert(sizeof(ZkEvacuateParam::nEvcCombo) == 4, "expected nEvcCombo to be size 4");
static_assert(sizeof(struct ZkEvacuateParam) == 8, "expected struct ZkEvacuateParam to be size 8");

// enum eDownDir
enum eDownDir : uint32_t
{
	// Enum values

	// <eDownDir_UNKNOWN = 0xffffffffffffffff>
	eDownDir_UNKNOWN = UINT32_MAX,

	// <eDownDir_UP = 0x0>
	eDownDir_UP = 0,

	// <eDownDir_DOWN = 0x1>
	eDownDir_DOWN = 1

};

// enum enPcPose
enum enPcPose : uint32_t
{
	// Enum values

	// <ePcPoseUpper = 0x0>
	ePcPoseUpper = 0,

	// <ePcPoseBottom = 0x1>
	ePcPoseBottom = 1,

	// <ePcPoseMax = 0x2>
	ePcPoseMax = 2

};

// enum eZkCarSheet
enum eZkCarSheet : uint32_t
{
	// Enum values

	// <eZkCarSheet_UNKONOWN = 0xffffffffffffffff>
	eZkCarSheet_UNKONOWN = UINT32_MAX,

	// <eZkCarSheet_FR = 0x0>
	eZkCarSheet_FR = 0,

	// <eZkCarSheet_FL = 0x1>
	eZkCarSheet_FL = 1,

	// <eZkCarSheet_BR = 0x2>
	eZkCarSheet_BR = 2,

	// <eZkCarSheet_BL = 0x3>
	eZkCarSheet_BL = 3,

	// <eZkCarSheet_VAN = 0x4>
	eZkCarSheet_VAN = 4,

	// <eZkCarSheet_NUM = 0x5>
	eZkCarSheet_NUM = 5

};

// class FkCounter
// no dependencies
class FkCounter
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t NowCnt, offset 0x0>
	int32_t NowCnt;

	// <int32_t MaxCnt, offset 0x4>
	int32_t MaxCnt;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkCounter>("FkCounter")
			.addProperty("NowCnt", &FkCounter::NowCnt)
			.addProperty("MaxCnt", &FkCounter::MaxCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkCounter::NowCnt) == 4, "expected NowCnt to be size 4");
static_assert(sizeof(FkCounter::MaxCnt) == 4, "expected MaxCnt to be size 4");
static_assert(sizeof(class FkCounter) == 8, "expected class FkCounter to be size 8");

// enum ePcSideFromMe
enum ePcSideFromMe : uint32_t
{
	// Enum values

	// <ePcSideFromMe_Unknown = 0xffffffffffffffff>
	ePcSideFromMe_Unknown = UINT32_MAX,

	// <ePcSideFromMe_Left = 0x0>
	ePcSideFromMe_Left = 0,

	// <ePcSideFromMe_Right = 0x1>
	ePcSideFromMe_Right = 1

};

// enum eSideFromPc
enum eSideFromPc : uint32_t
{
	// Enum values

	// <eSideFromPC_Left = 0x0>
	eSideFromPC_Left = 0,

	// <eSideFromPC_Right = 0x1>
	eSideFromPC_Right = 1

};

// struct ZkSetDamageInfo
// no dependencies
struct ZkSetDamageInfo
{
public:
	/// No namespace types
	/// Struct member variables

	// <uint8_t boCounterHit, offset 0x0>
	uint8_t boCounterHit;

	// <uint8_t boFollowThroughHit, offset 0x1>
	uint8_t boFollowThroughHit;

	// <uint8_t boNoConvertMotionTypeDamage, offset 0x2>
	uint8_t boNoConvertMotionTypeDamage;

	// <uint8_t boGuard, offset 0x3>
	uint8_t boGuard;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkSetDamageInfo>("ZkSetDamageInfo")
			.addProperty("boCounterHit", &ZkSetDamageInfo::boCounterHit)
			.addProperty("boFollowThroughHit", &ZkSetDamageInfo::boFollowThroughHit)
			.addProperty("boNoConvertMotionTypeDamage", &ZkSetDamageInfo::boNoConvertMotionTypeDamage)
			.addProperty("boGuard", &ZkSetDamageInfo::boGuard)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkSetDamageInfo::boCounterHit) == 1, "expected boCounterHit to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boFollowThroughHit) == 1, "expected boFollowThroughHit to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boNoConvertMotionTypeDamage) == 1, "expected boNoConvertMotionTypeDamage to be size 1");
static_assert(sizeof(ZkSetDamageInfo::boGuard) == 1, "expected boGuard to be size 1");
static_assert(sizeof(struct ZkSetDamageInfo) == 4, "expected struct ZkSetDamageInfo to be size 4");

// enum eZkBoneScale
enum eZkBoneScale : uint32_t
{
	// Enum values

	// <eZkBoneScale_UNKNOWN = 0xffffffffffffffff>
	eZkBoneScale_UNKNOWN = UINT32_MAX,

	// <eZkBoneScale_A = 0x0>
	eZkBoneScale_A = 0,

	// <eZkBoneScale_B = 0x1>
	eZkBoneScale_B = 1,

	// <eZkBoneScale_C = 0x2>
	eZkBoneScale_C = 2,

	// <eZkBoneScale_D = 0x3>
	eZkBoneScale_D = 3,

	// <eZkBoneScale_Five = 0x4>
	eZkBoneScale_Five = 4,

	// <eZkBoneScaleNum = 0x5>
	eZkBoneScaleNum = 5

};

// class State_Scare_Yotunbai
// 2 dependencies: class State_Scare_Base, class PJState
class State_Scare_Yotunbai : State_Scare_Base
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Scare_Yotunbai>("State_Scare_Yotunbai")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Scare_Yotunbai) == 8, "expected class State_Scare_Yotunbai to be size 8");

// class State_Scare_Stand
// 2 dependencies: class State_Scare_Base, class PJState
class State_Scare_Stand : State_Scare_Base
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Scare_Stand>("State_Scare_Stand")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_Scare_Stand) == 8, "expected class State_Scare_Stand to be size 8");

// class State_RandomMove
// 2 dependencies: class PJState, enum eMoveDir
class State_RandomMove : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <enum eMoveDir m_eStateMovDir, offset 0x4>
	enum eMoveDir m_eStateMovDir;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_RandomMove>("State_RandomMove")
			.addProperty("m_eStateMovDir", &State_RandomMove::m_eStateMovDir)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_RandomMove::m_eStateMovDir) == 4, "expected m_eStateMovDir to be size 4");
static_assert(sizeof(class State_RandomMove) == 8, "expected class State_RandomMove to be size 8");

// class State_PerformIll
// 2 dependencies: class State_Scare_Base, class PJState
class State_PerformIll : State_Scare_Base
{
public:
	/// No namespace types
	/// Struct member variables

	// <class State_Scare_Base field_0, offset 0x0>
	// class State_Scare_Base Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_PerformIll>("State_PerformIll")
		.endClass();
	}
#endif
};
static_assert(sizeof(class State_PerformIll) == 8, "expected class State_PerformIll to be size 8");

// class PJZAKO
// 106 dependencies: class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, enum eZkBoneScale, struct ZkSetDamageInfo, struct PJZAKO::ZakoInfo, enum eMoveDir, enum eSideFromPc, enum ePcSideFromMe, class FkCounter, struct PJZAKO::MotionInfo, struct PJZAKO::TojoInfo, enum eZkCarSheet, struct PJZAKO::PcInfo, enum enPcPose, struct PJZAKO::DmgInfo, enum eDownDir, struct PJZAKO::AiInfo, struct ZkEvacuateParam, struct ZkGuardParam, enum eFightLine, enum FightSpirit, enum eZkStat, enum eScareType, struct PJZAKO::EfDanmen, struct tagHRTASKCHECK, class FkStlVector<Vec>, enum PJZAKO::eSuddenAtkPopDir, enum PJZAKO::eTimeShare, struct CollInfo, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, class FkStlList<commonObj *>, class State_Damage, class PJState, enum State_Damage::eStat, class State_CloseBeforeAttack, class State_AwayAfterAttack, class State_ComboAttack, enum State_ComboAttack::eStat, class State_StepInAttack, class State_Defence, class State_Evacuate, class State_RandomMove, class State_ThroughDamage, class State_DownDamage, class State_Pressure, enum State_Pressure::eStat, class State_WayPointMove, enum State_WayPointMove::eWaypointSbSt, class State_Scare_Run, class State_Scare_Base, class State_Scare_Kosinukasi, class State_Scare_Yotunbai, class State_Scare_Stand, class State_PerformIll, class State_ReleaseWaitIdle, class State_Idle, class State_TojoBaseState, class State_Tojo_RunAndTurnPc, class State_Tojo_AgainstWall, class State_Tojo_LookAround, class State_Tojo_Stand, class State_Tojo_Bench, class State_Tojo_Sit, class State_Tojo_Car, enum State_Tojo_Car::eStat, class State_Tojo_JumpOff, class State_Tojo_BreakCmnObj, enum State_Tojo_BreakCmnObj::eStat, class State_Tojo_AeroBike, enum State_Tojo_AeroBike::eStat, class State_Tojo_RoomRunner, enum State_Tojo_RoomRunner::eStat, class State_LeadPcWayPointMove, class State_FixTurret, class State_WayPointMoveAfterPop, class ZkState_DownAttack, enum ZkState_DownAttack::eStat
class PJZAKO : mHRChara
{
public:
	/// 20 namespace types: uint8_t __convention("thiscall") PJZAKO::IsAtkObj(class PJZAKO* const this, class mHRChara* arg2), struct PJZAKO::ZakoInfo, struct PJZAKO::MotionInfo, struct PJZAKO::TojoInfo, struct PJZAKO::PcInfo, struct PJZAKO::DmgInfo, struct PJZAKO::AiInfo, struct PJZAKO::EfDanmen, enum PJZAKO::eSuddenAtkPopDir, enum PJZAKO::eTimeShare, uint8_t __convention("thiscall") PJZAKO::IsSetDamageFromPcThroughAttack(class PJZAKO* const this, class mHRChara* arg2), void __convention("thiscall") PJZAKO::mSetDamage_Dead(class PJZAKO* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4), void __convention("thiscall") PJZAKO::mSetDamage_CutDamage(class PJZAKO* const this, class mHRChara* arg2, int32_t arg3), void __convention("thiscall") PJZAKO::mSetDamage_NoStateChangeDamage(class PJZAKO* const this, class mHRChara* arg2), void __convention("thiscall") PJZAKO::mSetDamage_DamageCounterProc(class PJZAKO* const this, int32_t* arg2, class mHRChara* arg3), void __convention("thiscall") PJZAKO::mSetDamage_InitDamageReaction(class PJZAKO* const this, class mHRChara* arg2, int32_t const arg3), void __convention("thiscall") PJZAKO::mSetDamage_Initialize(class PJZAKO* const this, class mHRChara* arg2, int32_t const arg3), uint8_t __convention("thiscall") PJZAKO::mSetDamage(class PJZAKO* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), void __convention("thiscall") PJZAKO::CheckSetDmgFuncGarbageInData(class PJZAKO* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), int32_t __convention("thiscall") PJZAKO::ConvertDmgMot(class PJZAKO* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4)

	// TODO: Function 'uint8_t __convention("thiscall") PJZAKO::IsAtkObj(class PJZAKO* const this, class mHRChara* arg2)'
	// struct PJZAKO::ZakoInfo
	// 5 dependencies: enum eMoveDir, enum eSideFromPc, enum ePcSideFromMe, class FkCounter, struct Vec
	struct ZakoInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t m_ComboAtkTbl[0x4], offset 0x0>
		int32_t m_ComboAtkTbl[4];

		// <int32_t m_NowComboAtkNo, offset 0x10>
		int32_t m_NowComboAtkNo;

		// <uint8_t m_ComboAtkReq, offset 0x14>
		uint8_t m_ComboAtkReq;

		// <Filler, offset 0x15>
		char _Filler3[3];

		// <int32_t m_nMaxComboAtk, offset 0x18>
		int32_t m_nMaxComboAtk;

		// <enum eMoveDir m_eMaaiMovDir, offset 0x1c>
		enum eMoveDir m_eMaaiMovDir;

		// <enum eSideFromPc m_SideFromPc, offset 0x20>
		enum eSideFromPc m_SideFromPc;

		// <enum ePcSideFromMe m_PcSideFromMe, offset 0x24>
		enum ePcSideFromMe m_PcSideFromMe;

		// <class FkCounter m_MoveCnt, offset 0x28>
		class FkCounter m_MoveCnt;

		// <struct Vec m_MoveVec, offset 0x30>
		struct Vec m_MoveVec;

		// <struct Vec m_FrontVec, offset 0x3c>
		struct Vec m_FrontVec;

		// <float m_EnmSubAngle, offset 0x48>
		float m_EnmSubAngle;

		// <float m_fMaaiTbl[0x8], offset 0x4c>
		float m_fMaaiTbl[8];

		// <float m_fMovSpd[0x1], offset 0x6c>
		float m_fMovSpd[1];

		// <int32_t m_CirclePcPointHnd, offset 0x70>
		int32_t m_CirclePcPointHnd;

		// <struct Vec m_PrevPos, offset 0x74>
		struct Vec m_PrevPos;

		// <float m_fWayPointMoveLength, offset 0x80>
		float m_fWayPointMoveLength;

		// <int32_t m_WayPointCnt, offset 0x84>
		int32_t m_WayPointCnt;

		// <uint8_t m_boWaypointMoveStopping, offset 0x88>
		uint8_t m_boWaypointMoveStopping;

		// <Filler, offset 0x89>
		char _Filler18[3];

		// <int32_t m_GoPointKuruKuruCnt, offset 0x8c>
		int32_t m_GoPointKuruKuruCnt;

		// <uint8_t m_boLookPC, offset 0x90>
		uint8_t m_boLookPC;

		// <Filler, offset 0x91>
		char _Filler[3];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::ZakoInfo>("PJZAKO::ZakoInfo")
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_ComboAtkTbl", &PJZAKO::ZakoInfo::m_ComboAtkTbl)
				.addProperty("m_NowComboAtkNo", &PJZAKO::ZakoInfo::m_NowComboAtkNo)
				.addProperty("m_ComboAtkReq", &PJZAKO::ZakoInfo::m_ComboAtkReq)
				.addProperty("m_nMaxComboAtk", &PJZAKO::ZakoInfo::m_nMaxComboAtk)
				.addProperty("m_eMaaiMovDir", &PJZAKO::ZakoInfo::m_eMaaiMovDir)
				.addProperty("m_SideFromPc", &PJZAKO::ZakoInfo::m_SideFromPc)
				.addProperty("m_PcSideFromMe", &PJZAKO::ZakoInfo::m_PcSideFromMe)
				.addProperty("m_MoveCnt", &PJZAKO::ZakoInfo::m_MoveCnt)
				.addProperty("m_MoveVec", &PJZAKO::ZakoInfo::m_MoveVec)
				.addProperty("m_FrontVec", &PJZAKO::ZakoInfo::m_FrontVec)
				.addProperty("m_EnmSubAngle", &PJZAKO::ZakoInfo::m_EnmSubAngle)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_fMaaiTbl", &PJZAKO::ZakoInfo::m_fMaaiTbl)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("m_fMovSpd", &PJZAKO::ZakoInfo::m_fMovSpd)
				.addProperty("m_CirclePcPointHnd", &PJZAKO::ZakoInfo::m_CirclePcPointHnd)
				.addProperty("m_PrevPos", &PJZAKO::ZakoInfo::m_PrevPos)
				.addProperty("m_fWayPointMoveLength", &PJZAKO::ZakoInfo::m_fWayPointMoveLength)
				.addProperty("m_WayPointCnt", &PJZAKO::ZakoInfo::m_WayPointCnt)
				.addProperty("m_boWaypointMoveStopping", &PJZAKO::ZakoInfo::m_boWaypointMoveStopping)
				.addProperty("m_GoPointKuruKuruCnt", &PJZAKO::ZakoInfo::m_GoPointKuruKuruCnt)
				.addProperty("m_boLookPC", &PJZAKO::ZakoInfo::m_boLookPC)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::ZakoInfo::m_ComboAtkTbl) == 16, "expected m_ComboAtkTbl to be size 16");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_NowComboAtkNo) == 4, "expected m_NowComboAtkNo to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_ComboAtkReq) == 1, "expected m_ComboAtkReq to be size 1");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_nMaxComboAtk) == 4, "expected m_nMaxComboAtk to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_eMaaiMovDir) == 4, "expected m_eMaaiMovDir to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_SideFromPc) == 4, "expected m_SideFromPc to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_PcSideFromMe) == 4, "expected m_PcSideFromMe to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_MoveCnt) == 8, "expected m_MoveCnt to be size 8");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_FrontVec) == 12, "expected m_FrontVec to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_EnmSubAngle) == 4, "expected m_EnmSubAngle to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fMaaiTbl) == 32, "expected m_fMaaiTbl to be size 32");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fMovSpd) == 4, "expected m_fMovSpd to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_CirclePcPointHnd) == 4, "expected m_CirclePcPointHnd to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_PrevPos) == 12, "expected m_PrevPos to be size 12");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_fWayPointMoveLength) == 4, "expected m_fWayPointMoveLength to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_WayPointCnt) == 4, "expected m_WayPointCnt to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_boWaypointMoveStopping) == 1, "expected m_boWaypointMoveStopping to be size 1");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_GoPointKuruKuruCnt) == 4, "expected m_GoPointKuruKuruCnt to be size 4");
	static_assert(sizeof(PJZAKO::ZakoInfo::m_boLookPC) == 1, "expected m_boLookPC to be size 1");
	static_assert(sizeof(struct PJZAKO::ZakoInfo) == 148, "expected struct PJZAKO::ZakoInfo to be size 148");

	// struct PJZAKO::MotionInfo
	// no dependencies
	struct MotionInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t m_MotionFrame, offset 0x0>
		int32_t m_MotionFrame;

		// <float m_fMotSpd, offset 0x4>
		float m_fMotSpd;

		// <int32_t m_nMaxCommonMot, offset 0x8>
		int32_t m_nMaxCommonMot;

		// <int32_t m_nMaxWepMot, offset 0xc>
		int32_t m_nMaxWepMot;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::MotionInfo>("PJZAKO::MotionInfo")
				.addProperty("m_MotionFrame", &PJZAKO::MotionInfo::m_MotionFrame)
				.addProperty("m_fMotSpd", &PJZAKO::MotionInfo::m_fMotSpd)
				.addProperty("m_nMaxCommonMot", &PJZAKO::MotionInfo::m_nMaxCommonMot)
				.addProperty("m_nMaxWepMot", &PJZAKO::MotionInfo::m_nMaxWepMot)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::MotionInfo::m_MotionFrame) == 4, "expected m_MotionFrame to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_fMotSpd) == 4, "expected m_fMotSpd to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_nMaxCommonMot) == 4, "expected m_nMaxCommonMot to be size 4");
	static_assert(sizeof(PJZAKO::MotionInfo::m_nMaxWepMot) == 4, "expected m_nMaxWepMot to be size 4");
	static_assert(sizeof(struct PJZAKO::MotionInfo) == 16, "expected struct PJZAKO::MotionInfo to be size 16");

	// struct PJZAKO::TojoInfo
	// 1 dependencies: enum eZkCarSheet
	struct TojoInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint8_t m_boWaitReleaseIdleState, offset 0x0>
		uint8_t m_boWaitReleaseIdleState;

		// <Filler, offset 0x1>
		char _Filler1[3];

		// <class commonObj* m_pSyncStgObj, offset 0x4>
		class commonObj* m_pSyncStgObj;

		// <uint8_t m_boGetOffCar, offset 0x8>
		uint8_t m_boGetOffCar;

		// <Filler, offset 0x9>
		char _Filler3[3];

		// <enum eZkCarSheet m_eCarSheet, offset 0xc>
		enum eZkCarSheet m_eCarSheet;

		// <uint8_t m_boBreakPopCmnObjStart, offset 0x10>
		uint8_t m_boBreakPopCmnObjStart;

		// <Filler, offset 0x11>
		char _Filler[3];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::TojoInfo>("PJZAKO::TojoInfo")
				.addProperty("m_boWaitReleaseIdleState", &PJZAKO::TojoInfo::m_boWaitReleaseIdleState)
				.addProperty("m_pSyncStgObj", &PJZAKO::TojoInfo::m_pSyncStgObj)
				.addProperty("m_boGetOffCar", &PJZAKO::TojoInfo::m_boGetOffCar)
				.addProperty("m_eCarSheet", &PJZAKO::TojoInfo::m_eCarSheet)
				.addProperty("m_boBreakPopCmnObjStart", &PJZAKO::TojoInfo::m_boBreakPopCmnObjStart)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::TojoInfo::m_boWaitReleaseIdleState) == 1, "expected m_boWaitReleaseIdleState to be size 1");
	static_assert(sizeof(PJZAKO::TojoInfo::m_pSyncStgObj) == 4, "expected m_pSyncStgObj to be size 4");
	static_assert(sizeof(PJZAKO::TojoInfo::m_boGetOffCar) == 1, "expected m_boGetOffCar to be size 1");
	static_assert(sizeof(PJZAKO::TojoInfo::m_eCarSheet) == 4, "expected m_eCarSheet to be size 4");
	static_assert(sizeof(PJZAKO::TojoInfo::m_boBreakPopCmnObjStart) == 1, "expected m_boBreakPopCmnObjStart to be size 1");
	static_assert(sizeof(struct PJZAKO::TojoInfo) == 20, "expected struct PJZAKO::TojoInfo to be size 20");

	// struct PJZAKO::PcInfo
	// 2 dependencies: struct Vec, enum enPcPose
	struct PcInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <struct Vec m_PcPosition, offset 0x0>
		struct Vec m_PcPosition;

		// <struct Vec m_PcDirection, offset 0xc>
		struct Vec m_PcDirection;

		// <struct Vec m_PcNavel, offset 0x18>
		struct Vec m_PcNavel;

		// <float m_PcDistance, offset 0x24>
		float m_PcDistance;

		// <struct Vec m_PcRot, offset 0x28>
		struct Vec m_PcRot;

		// <float m_PcSubAngle, offset 0x34>
		float m_PcSubAngle;

		// <enum enPcPose m_PcPose, offset 0x38>
		enum enPcPose m_PcPose;

		// <uint8_t m_LockonPc, offset 0x3c>
		uint8_t m_LockonPc;

		// <uint8_t m_boPcInSight, offset 0x3d>
		uint8_t m_boPcInSight;

		// <Filler, offset 0x3e>
		char _Filler[2];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::PcInfo>("PJZAKO::PcInfo")
				.addProperty("m_PcPosition", &PJZAKO::PcInfo::m_PcPosition)
				.addProperty("m_PcDirection", &PJZAKO::PcInfo::m_PcDirection)
				.addProperty("m_PcNavel", &PJZAKO::PcInfo::m_PcNavel)
				.addProperty("m_PcDistance", &PJZAKO::PcInfo::m_PcDistance)
				.addProperty("m_PcRot", &PJZAKO::PcInfo::m_PcRot)
				.addProperty("m_PcSubAngle", &PJZAKO::PcInfo::m_PcSubAngle)
				.addProperty("m_PcPose", &PJZAKO::PcInfo::m_PcPose)
				.addProperty("m_LockonPc", &PJZAKO::PcInfo::m_LockonPc)
				.addProperty("m_boPcInSight", &PJZAKO::PcInfo::m_boPcInSight)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::PcInfo::m_PcPosition) == 12, "expected m_PcPosition to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcDirection) == 12, "expected m_PcDirection to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcNavel) == 12, "expected m_PcNavel to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcDistance) == 4, "expected m_PcDistance to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcRot) == 12, "expected m_PcRot to be size 12");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcSubAngle) == 4, "expected m_PcSubAngle to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_PcPose) == 4, "expected m_PcPose to be size 4");
	static_assert(sizeof(PJZAKO::PcInfo::m_LockonPc) == 1, "expected m_LockonPc to be size 1");
	static_assert(sizeof(PJZAKO::PcInfo::m_boPcInSight) == 1, "expected m_boPcInSight to be size 1");
	static_assert(sizeof(struct PJZAKO::PcInfo) == 64, "expected struct PJZAKO::PcInfo to be size 64");

	// struct PJZAKO::DmgInfo
	// 2 dependencies: enum eDownDir, struct Vec
	struct DmgInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t mLoseSightTick, offset 0x0>
		int32_t mLoseSightTick;

		// <int32_t m_PiyoDuration, offset 0x4>
		int32_t m_PiyoDuration;

		// <int32_t m_mSetDmgDir, offset 0x8>
		int32_t m_mSetDmgDir;

		// <enum eDownDir m_eDownDir, offset 0xc>
		enum eDownDir m_eDownDir;

		// <int32_t m_FuttobiDur, offset 0x10>
		int32_t m_FuttobiDur;

		// <int32_t m_DagekiCounterCnt, offset 0x14>
		int32_t m_DagekiCounterCnt;

		// <uint8_t m_boDagekiCounterAttack, offset 0x18>
		uint8_t m_boDagekiCounterAttack;

		// <Filler, offset 0x19>
		char _Filler7[3];

		// <int32_t m_PiyoTick, offset 0x1c>
		int32_t m_PiyoTick;

		// <int32_t m_RestStompDropMoneyTime, offset 0x20>
		int32_t m_RestStompDropMoneyTime;

		// <float m_fKnockBackDist, offset 0x24>
		float m_fKnockBackDist;

		// <float m_fKnockBackSpd, offset 0x28>
		float m_fKnockBackSpd;

		// <float m_fDbgKnockBackSum, offset 0x2c>
		float m_fDbgKnockBackSum;

		// <struct Vec m_VecKnocBack, offset 0x30>
		struct Vec m_VecKnocBack;

		// <float m_fInAtkRotY, offset 0x3c>
		float m_fInAtkRotY;

		// <uint8_t m_boCantCreaatedDeadModelByNoMemory, offset 0x40>
		uint8_t m_boCantCreaatedDeadModelByNoMemory;

		// <Filler, offset 0x41>
		char _Filler[3];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::DmgInfo>("PJZAKO::DmgInfo")
				.addProperty("mLoseSightTick", &PJZAKO::DmgInfo::mLoseSightTick)
				.addProperty("m_PiyoDuration", &PJZAKO::DmgInfo::m_PiyoDuration)
				.addProperty("m_mSetDmgDir", &PJZAKO::DmgInfo::m_mSetDmgDir)
				.addProperty("m_eDownDir", &PJZAKO::DmgInfo::m_eDownDir)
				.addProperty("m_FuttobiDur", &PJZAKO::DmgInfo::m_FuttobiDur)
				.addProperty("m_DagekiCounterCnt", &PJZAKO::DmgInfo::m_DagekiCounterCnt)
				.addProperty("m_boDagekiCounterAttack", &PJZAKO::DmgInfo::m_boDagekiCounterAttack)
				.addProperty("m_PiyoTick", &PJZAKO::DmgInfo::m_PiyoTick)
				.addProperty("m_RestStompDropMoneyTime", &PJZAKO::DmgInfo::m_RestStompDropMoneyTime)
				.addProperty("m_fKnockBackDist", &PJZAKO::DmgInfo::m_fKnockBackDist)
				.addProperty("m_fKnockBackSpd", &PJZAKO::DmgInfo::m_fKnockBackSpd)
				.addProperty("m_fDbgKnockBackSum", &PJZAKO::DmgInfo::m_fDbgKnockBackSum)
				.addProperty("m_VecKnocBack", &PJZAKO::DmgInfo::m_VecKnocBack)
				.addProperty("m_fInAtkRotY", &PJZAKO::DmgInfo::m_fInAtkRotY)
				.addProperty("m_boCantCreaatedDeadModelByNoMemory", &PJZAKO::DmgInfo::m_boCantCreaatedDeadModelByNoMemory)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::DmgInfo::mLoseSightTick) == 4, "expected mLoseSightTick to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_PiyoDuration) == 4, "expected m_PiyoDuration to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_mSetDmgDir) == 4, "expected m_mSetDmgDir to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_eDownDir) == 4, "expected m_eDownDir to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_FuttobiDur) == 4, "expected m_FuttobiDur to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_DagekiCounterCnt) == 4, "expected m_DagekiCounterCnt to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_boDagekiCounterAttack) == 1, "expected m_boDagekiCounterAttack to be size 1");
	static_assert(sizeof(PJZAKO::DmgInfo::m_PiyoTick) == 4, "expected m_PiyoTick to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_RestStompDropMoneyTime) == 4, "expected m_RestStompDropMoneyTime to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fKnockBackDist) == 4, "expected m_fKnockBackDist to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fKnockBackSpd) == 4, "expected m_fKnockBackSpd to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fDbgKnockBackSum) == 4, "expected m_fDbgKnockBackSum to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_VecKnocBack) == 12, "expected m_VecKnocBack to be size 12");
	static_assert(sizeof(PJZAKO::DmgInfo::m_fInAtkRotY) == 4, "expected m_fInAtkRotY to be size 4");
	static_assert(sizeof(PJZAKO::DmgInfo::m_boCantCreaatedDeadModelByNoMemory) == 1, "expected m_boCantCreaatedDeadModelByNoMemory to be size 1");
	static_assert(sizeof(struct PJZAKO::DmgInfo) == 68, "expected struct PJZAKO::DmgInfo to be size 68");

	// struct PJZAKO::AiInfo
	// 5 dependencies: struct ZkEvacuateParam, struct ZkGuardParam, enum eFightLine, class FkCounter, enum FightSpirit
	struct AiInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint8_t m_boCutAi, offset 0x0>
		uint8_t m_boCutAi;

		// <Filler, offset 0x1>
		char _Filler1[3];

		// <int32_t m_ThinkCnt, offset 0x4>
		int32_t m_ThinkCnt;

		// <struct ZkEvacuateParam m_EvacuateParam, offset 0x8>
		struct ZkEvacuateParam m_EvacuateParam;

		// <struct ZkGuardParam m_GuardParam, offset 0x10>
		struct ZkGuardParam m_GuardParam;

		// <enum eFightLine m_FightLine, offset 0x20>
		enum eFightLine m_FightLine;

		// <class FkCounter m_AtkCnt, offset 0x24>
		class FkCounter m_AtkCnt;

		// <int32_t m_OffensiveMol, offset 0x2c>
		int32_t m_OffensiveMol;

		// <enum FightSpirit m_FS, offset 0x30>
		enum FightSpirit m_FS;

		// <int32_t m_boHitPrevAttack, offset 0x34>
		int32_t m_boHitPrevAttack;

		// <int32_t m_AtkAiLvRand, offset 0x38>
		int32_t m_AtkAiLvRand;

		// <class FkCounter m_PressureCnt, offset 0x3c>
		class FkCounter m_PressureCnt;

		// <int32_t m_ReactRatio, offset 0x44>
		int32_t m_ReactRatio;

		// <int32_t m_PathFindIntervalCnt, offset 0x48>
		int32_t m_PathFindIntervalCnt;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::AiInfo>("PJZAKO::AiInfo")
				.addProperty("m_boCutAi", &PJZAKO::AiInfo::m_boCutAi)
				.addProperty("m_ThinkCnt", &PJZAKO::AiInfo::m_ThinkCnt)
				.addProperty("m_EvacuateParam", &PJZAKO::AiInfo::m_EvacuateParam)
				.addProperty("m_GuardParam", &PJZAKO::AiInfo::m_GuardParam)
				.addProperty("m_FightLine", &PJZAKO::AiInfo::m_FightLine)
				.addProperty("m_AtkCnt", &PJZAKO::AiInfo::m_AtkCnt)
				.addProperty("m_OffensiveMol", &PJZAKO::AiInfo::m_OffensiveMol)
				.addProperty("m_FS", &PJZAKO::AiInfo::m_FS)
				.addProperty("m_boHitPrevAttack", &PJZAKO::AiInfo::m_boHitPrevAttack)
				.addProperty("m_AtkAiLvRand", &PJZAKO::AiInfo::m_AtkAiLvRand)
				.addProperty("m_PressureCnt", &PJZAKO::AiInfo::m_PressureCnt)
				.addProperty("m_ReactRatio", &PJZAKO::AiInfo::m_ReactRatio)
				.addProperty("m_PathFindIntervalCnt", &PJZAKO::AiInfo::m_PathFindIntervalCnt)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::AiInfo::m_boCutAi) == 1, "expected m_boCutAi to be size 1");
	static_assert(sizeof(PJZAKO::AiInfo::m_ThinkCnt) == 4, "expected m_ThinkCnt to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_EvacuateParam) == 8, "expected m_EvacuateParam to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_GuardParam) == 16, "expected m_GuardParam to be size 16");
	static_assert(sizeof(PJZAKO::AiInfo::m_FightLine) == 4, "expected m_FightLine to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_AtkCnt) == 8, "expected m_AtkCnt to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_OffensiveMol) == 4, "expected m_OffensiveMol to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_FS) == 4, "expected m_FS to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_boHitPrevAttack) == 4, "expected m_boHitPrevAttack to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_AtkAiLvRand) == 4, "expected m_AtkAiLvRand to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_PressureCnt) == 8, "expected m_PressureCnt to be size 8");
	static_assert(sizeof(PJZAKO::AiInfo::m_ReactRatio) == 4, "expected m_ReactRatio to be size 4");
	static_assert(sizeof(PJZAKO::AiInfo::m_PathFindIntervalCnt) == 4, "expected m_PathFindIntervalCnt to be size 4");
	static_assert(sizeof(struct PJZAKO::AiInfo) == 76, "expected struct PJZAKO::AiInfo to be size 76");

	// struct PJZAKO::EfDanmen
	// 1 dependencies: struct tagHRTASKCHECK
	struct EfDanmen
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class EffectDanmenFlash* pEf, offset 0x0>
		class EffectDanmenFlash* pEf;

		// <struct tagHRTASKCHECK taskCheck, offset 0x4>
		struct tagHRTASKCHECK taskCheck;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<PJZAKO::EfDanmen>("PJZAKO::EfDanmen")
				.addProperty("pEf", &PJZAKO::EfDanmen::pEf)
				.addProperty("taskCheck", &PJZAKO::EfDanmen::taskCheck)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(PJZAKO::EfDanmen::pEf) == 4, "expected pEf to be size 4");
	static_assert(sizeof(PJZAKO::EfDanmen::taskCheck) == 8, "expected taskCheck to be size 8");
	static_assert(sizeof(struct PJZAKO::EfDanmen) == 12, "expected struct PJZAKO::EfDanmen to be size 12");

	// enum PJZAKO::eSuddenAtkPopDir
	enum eSuddenAtkPopDir : uint32_t
	{
		// Enum values

		// <eSuddenAtkPopDir_UNKNOWN = 0xffffffffffffffff>
		eSuddenAtkPopDir_UNKNOWN = UINT32_MAX,

		// <eSuddenAtkPopDir_Above = 0x0>
		eSuddenAtkPopDir_Above = 0,

		// <eSuddenAtkPopDir_FromR = 0x1>
		eSuddenAtkPopDir_FromR = 1,

		// <eSuddenAtkPopDir_FromL = 0x2>
		eSuddenAtkPopDir_FromL = 2

	};

	// enum PJZAKO::eTimeShare
	enum eTimeShare : uint32_t
	{
		// Enum values

		// <eTimeShare_Begin = 0x0>
		eTimeShare_Begin = 0,

		// <eTimeShare_ColBack = 0x1>
		eTimeShare_ColBack = 1,

		// <eTimeShare_ColLeft = 0x2>
		eTimeShare_ColLeft = 2,

		// <eTimeShare_ColRight = 0x3>
		eTimeShare_ColRight = 3,

		// <eTimeShare_PcInSight = 0x4>
		eTimeShare_PcInSight = 4,

		// <eTimeShare_End = 0x5>
		eTimeShare_End = 5

	};

	// TODO: Function 'uint8_t __convention("thiscall") PJZAKO::IsSetDamageFromPcThroughAttack(class PJZAKO* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") PJZAKO::mSetDamage_Dead(class PJZAKO* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4)'
	// TODO: Function 'void __convention("thiscall") PJZAKO::mSetDamage_CutDamage(class PJZAKO* const this, class mHRChara* arg2, int32_t arg3)'
	// TODO: Function 'void __convention("thiscall") PJZAKO::mSetDamage_NoStateChangeDamage(class PJZAKO* const this, class mHRChara* arg2)'
	// TODO: Function 'void __convention("thiscall") PJZAKO::mSetDamage_DamageCounterProc(class PJZAKO* const this, int32_t* arg2, class mHRChara* arg3)'
	// TODO: Function 'void __convention("thiscall") PJZAKO::mSetDamage_InitDamageReaction(class PJZAKO* const this, class mHRChara* arg2, int32_t const arg3)'
	// TODO: Function 'void __convention("thiscall") PJZAKO::mSetDamage_Initialize(class PJZAKO* const this, class mHRChara* arg2, int32_t const arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") PJZAKO::mSetDamage(class PJZAKO* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// TODO: Function 'void __convention("thiscall") PJZAKO::CheckSetDmgFuncGarbageInData(class PJZAKO* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// TODO: Function 'int32_t __convention("thiscall") PJZAKO::ConvertDmgMot(class PJZAKO* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4)'

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <class PJState* m_StatePtrArr[0x3c], offset 0x580>
	class PJState* m_StatePtrArr[60];

	// <enum eZkBoneScale m_BoneScale, offset 0x670>
	enum eZkBoneScale m_BoneScale;

	// <struct ZkSetDamageInfo m_SetDamageInfo, offset 0x674>
	struct ZkSetDamageInfo m_SetDamageInfo;

	// <struct PJZAKO::ZakoInfo m_ZakoInfo, offset 0x678>
	struct PJZAKO::ZakoInfo m_ZakoInfo;

	// <struct PJZAKO::MotionInfo m_MotionInfo, offset 0x70c>
	struct PJZAKO::MotionInfo m_MotionInfo;

	// <struct PJZAKO::TojoInfo m_TojoInfo, offset 0x71c>
	struct PJZAKO::TojoInfo m_TojoInfo;

	// <struct PJZAKO::PcInfo m_PcInfo, offset 0x730>
	struct PJZAKO::PcInfo m_PcInfo;

	// <struct PJZAKO::DmgInfo m_DmgInfo, offset 0x770>
	struct PJZAKO::DmgInfo m_DmgInfo;

	// <struct PJZAKO::AiInfo m_AiInfo, offset 0x7b4>
	struct PJZAKO::AiInfo m_AiInfo;

	// <int32_t m_Counter, offset 0x800>
	int32_t m_Counter;

	// <int32_t m_CheckCanHitPrevCnt, offset 0x804>
	int32_t m_CheckCanHitPrevCnt;

	// <int32_t m_AddKillNumWaitCounter, offset 0x808>
	int32_t m_AddKillNumWaitCounter;

	// <uint8_t m_boAddedKillNum, offset 0x80c>
	uint8_t m_boAddedKillNum;

	// <uint8_t m_boMoveTurretFlag, offset 0x80d>
	uint8_t m_boMoveTurretFlag;

	// <uint8_t m_boWayPointMoveAfterPop, offset 0x80e>
	uint8_t m_boWayPointMoveAfterPop;

	// <Filler, offset 0x80f>
	char _Filler16[1];

	// <class PJStateMachine* m_pStateMachine, offset 0x810>
	class PJStateMachine* m_pStateMachine;

	// <enum eZkStat m_eNowStateIdx, offset 0x814>
	enum eZkStat m_eNowStateIdx;

	// <enum eZkStat m_ePrevStateIdx, offset 0x818>
	enum eZkStat m_ePrevStateIdx;

	// <enum eScareType m_eScareType, offset 0x81c>
	enum eScareType m_eScareType;

	// <float mTargetDirec, offset 0x820>
	float mTargetDirec;

	// <float mNowDirecY, offset 0x824>
	float mNowDirecY;

	// <int32_t mDeadModelType, offset 0x828>
	int32_t mDeadModelType;

	// <struct PJZAKO::EfDanmen m_EfDanmen, offset 0x82c>
	struct PJZAKO::EfDanmen m_EfDanmen;

	// <class EffectCutMark* m_pCutMark, offset 0x838>
	class EffectCutMark* m_pCutMark;

	// <class EffectQuestion* mpEfQuestion, offset 0x83c>
	class EffectQuestion* mpEfQuestion;

	// <class PJZakoMotMng* m_pMotMng, offset 0x840>
	class PJZakoMotMng* m_pMotMng;

	// <class FkStlVector<Vec> m_WayPointArry, offset 0x844>
	class FkStlVector<Vec> m_WayPointArry;

	// <int32_t m_iWayPoint, offset 0x858>
	int32_t m_iWayPoint;

	// <class PathPlanner* m_pPathPlanner, offset 0x85c>
	class PathPlanner* m_pPathPlanner;

	// <uint8_t m_boUseObstacleSensor, offset 0x860>
	uint8_t m_boUseObstacleSensor;

	// <uint8_t m_boDisableInterestIK, offset 0x861>
	uint8_t m_boDisableInterestIK;

	// <uint8_t m_boBerserkAtk, offset 0x862>
	uint8_t m_boBerserkAtk;

	// <uint8_t m_boRequestDeathOutOfCamera, offset 0x863>
	uint8_t m_boRequestDeathOutOfCamera;

	// <uint8_t m_boFirstBombDeadFxPlay, offset 0x864>
	uint8_t m_boFirstBombDeadFxPlay;

	// <Filler, offset 0x865>
	char _Filler35[3];

	// <struct Vec m_JumpOffTojoLandingPos, offset 0x868>
	struct Vec m_JumpOffTojoLandingPos;

	// <uint8_t m_boFixTurret, offset 0x874>
	uint8_t m_boFixTurret;

	// <Filler, offset 0x875>
	char _Filler37[3];

	// <enum PJZAKO::eSuddenAtkPopDir m_eSdnAtkPopDir, offset 0x878>
	enum PJZAKO::eSuddenAtkPopDir m_eSdnAtkPopDir;

	// <class FkDynamicParam* m_pDP, offset 0x87c>
	class FkDynamicParam* m_pDP;

	// <class FkObstacleSensor* m_pObsSens, offset 0x880>
	class FkObstacleSensor* m_pObsSens;

	// <int32_t m_Atk2PcHitAfterCnt, offset 0x884>
	int32_t m_Atk2PcHitAfterCnt;

	// <uint8_t m_boPcDownLaugh, offset 0x888>
	uint8_t m_boPcDownLaugh;

	// <Filler, offset 0x889>
	char _Filler42[3];

	// <class FkBulletManager* m_pBulletManager, offset 0x88c>
	class FkBulletManager* m_pBulletManager;

	// <uint8_t m_boPhysicDeadProc, offset 0x890>
	uint8_t m_boPhysicDeadProc;

	// <uint8_t m_bIsHeadPhysicsEnd, offset 0x891>
	uint8_t m_bIsHeadPhysicsEnd;

	// <Filler, offset 0x892>
	char _Filler45[2];

	// <class TGmf* m_pPhysicDeadGmf, offset 0x894>
	class TGmf* m_pPhysicDeadGmf;

	// <uint8_t m_boTodomeDead, offset 0x898>
	uint8_t m_boTodomeDead;

	// <uint8_t m_boDeadEffectReq, offset 0x899>
	uint8_t m_boDeadEffectReq;

	// <Filler, offset 0x89a>
	char _Filler48[2];

	// <int32_t m_DeadEffectCountCown, offset 0x89c>
	int32_t m_DeadEffectCountCown;

	// <int32_t m_ParticleDeadZakoTerminateWaitTick, offset 0x8a0>
	int32_t m_ParticleDeadZakoTerminateWaitTick;

	// <class mot::CBoneEffectDamageData* m_pBnFxDmgDat, offset 0x8a4>
	class mot::CBoneEffectDamageData* m_pBnFxDmgDat;

	// <uint8_t m_boTimeShareUpdate, offset 0x8a8>
	uint8_t m_boTimeShareUpdate;

	// <Filler, offset 0x8a9>
	char _Filler52[3];

	// <enum PJZAKO::eTimeShare m_eTimeShareStat, offset 0x8ac>
	enum PJZAKO::eTimeShare m_eTimeShareStat;

	// <struct CollInfo m_CollInfo, offset 0x8b0>
	struct CollInfo m_CollInfo;

	// <struct tagGHMR_TEX m_Tex, offset 0x8bc>
	struct tagGHMR_TEX m_Tex;

	// <int32_t m_ChangeStateLimitTick, offset 0x8e4>
	int32_t m_ChangeStateLimitTick;

	// <float m_fRotSpd, offset 0x8e8>
	float m_fRotSpd;

	// <class FkStlList<commonObj *> m_BreakPopCmnObjPtrList, offset 0x8ec>
	class FkStlList<commonObj *> m_BreakPopCmnObjPtrList;

	// <class commonObj* m_pSyncPopCmnObj, offset 0x8f8>
	class commonObj* m_pSyncPopCmnObj;

	// <uint8_t m_boCalledNoGuardEfOnce, offset 0x8fc>
	uint8_t m_boCalledNoGuardEfOnce;

	// <Filler, offset 0x8fd>
	char _Filler60[3];

	// <int32_t m_OutOfCameraIkakuShootTime, offset 0x900>
	int32_t m_OutOfCameraIkakuShootTime;

	// <class State_Damage m_State_Damage, offset 0x904>
	class State_Damage m_State_Damage;

	// <class State_CloseBeforeAttack m_State_CloseForAtk, offset 0x910>
	class State_CloseBeforeAttack m_State_CloseForAtk;

	// <class State_AwayAfterAttack m_State_AwayAfterAtk, offset 0x914>
	class State_AwayAfterAttack m_State_AwayAfterAtk;

	// <class State_ComboAttack m_State_ComboAttack, offset 0x918>
	class State_ComboAttack m_State_ComboAttack;

	// <class State_StepInAttack m_State_StepInAttack, offset 0x924>
	class State_StepInAttack m_State_StepInAttack;

	// <class State_Defence m_State_Defence, offset 0x928>
	class State_Defence m_State_Defence;

	// <class State_Evacuate m_State_Evacuate, offset 0x930>
	class State_Evacuate m_State_Evacuate;

	// <class State_RandomMove m_State_RandomMove, offset 0x938>
	class State_RandomMove m_State_RandomMove;

	// <class State_ThroughDamage m_State_ThroughDamage, offset 0x940>
	class State_ThroughDamage m_State_ThroughDamage;

	// <class State_DownDamage m_State_DownDamage, offset 0x948>
	class State_DownDamage m_State_DownDamage;

	// <class State_Pressure m_State_Pressure, offset 0x94c>
	class State_Pressure m_State_Pressure;

	// <class State_WayPointMove m_State_WayPointMove, offset 0x958>
	class State_WayPointMove m_State_WayPointMove;

	// <class State_Scare_Run m_State_Run, offset 0x960>
	class State_Scare_Run m_State_Run;

	// <class State_Scare_Kosinukasi m_State_Kosinukasi, offset 0x968>
	class State_Scare_Kosinukasi m_State_Kosinukasi;

	// <class State_Scare_Yotunbai m_State_Yotunbai, offset 0x970>
	class State_Scare_Yotunbai m_State_Yotunbai;

	// <class State_Scare_Stand m_State_Stand, offset 0x978>
	class State_Scare_Stand m_State_Stand;

	// <class State_PerformIll m_StatePerformIll, offset 0x980>
	class State_PerformIll m_StatePerformIll;

	// <class State_ReleaseWaitIdle m_ReleaseWaitIdle, offset 0x988>
	class State_ReleaseWaitIdle m_ReleaseWaitIdle;

	// <class State_Tojo_RunAndTurnPc m_State_Tojo_RunAndTurnPc, offset 0x98c>
	class State_Tojo_RunAndTurnPc m_State_Tojo_RunAndTurnPc;

	// <class State_Tojo_AgainstWall m_State_Tojo_AgainstWall, offset 0x990>
	class State_Tojo_AgainstWall m_State_Tojo_AgainstWall;

	// <class State_Tojo_LookAround m_State_Tojo_LookAround, offset 0x994>
	class State_Tojo_LookAround m_State_Tojo_LookAround;

	// <class State_Tojo_Stand m_State_Tojo_Stand, offset 0x998>
	class State_Tojo_Stand m_State_Tojo_Stand;

	// <class State_Tojo_Bench m_State_Tojo_Bench, offset 0x99c>
	class State_Tojo_Bench m_State_Tojo_Bench;

	// <class State_Tojo_Sit m_State_Tojo_Sit, offset 0x9a0>
	class State_Tojo_Sit m_State_Tojo_Sit;

	// <class State_Tojo_Car m_State_Tojo_Car, offset 0x9a4>
	class State_Tojo_Car m_State_Tojo_Car;

	// <class State_Tojo_JumpOff m_State_Tojo_JumpOff, offset 0x9ac>
	class State_Tojo_JumpOff m_State_Tojo_JumpOff;

	// <class State_Tojo_BreakCmnObj m_State_Tojo_BreakCmnObj, offset 0x9b4>
	class State_Tojo_BreakCmnObj m_State_Tojo_BreakCmnObj;

	// <class State_Tojo_AeroBike m_State_Tojo_AeroBike, offset 0x9c0>
	class State_Tojo_AeroBike m_State_Tojo_AeroBike;

	// <class State_Tojo_RoomRunner m_State_Tojo_RoomRunner, offset 0x9c8>
	class State_Tojo_RoomRunner m_State_Tojo_RoomRunner;

	// <class State_LeadPcWayPointMove m_State_LeadPcWayPointMove, offset 0x9d0>
	class State_LeadPcWayPointMove m_State_LeadPcWayPointMove;

	// <class State_FixTurret m_State_FixTurret, offset 0x9d4>
	class State_FixTurret m_State_FixTurret;

	// <class State_WayPointMoveAfterPop m_State_WayPointMoveAfterPop, offset 0x9d8>
	class State_WayPointMoveAfterPop m_State_WayPointMoveAfterPop;

	// <class ZkState_DownAttack m_State_DownAttack, offset 0x9dc>
	class ZkState_DownAttack m_State_DownAttack;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJZAKO>("PJZAKO")
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StatePtrArr", &PJZAKO::m_StatePtrArr)
			.addProperty("m_BoneScale", &PJZAKO::m_BoneScale)
			.addProperty("m_SetDamageInfo", &PJZAKO::m_SetDamageInfo)
			.addProperty("m_ZakoInfo", &PJZAKO::m_ZakoInfo)
			.addProperty("m_MotionInfo", &PJZAKO::m_MotionInfo)
			.addProperty("m_TojoInfo", &PJZAKO::m_TojoInfo)
			.addProperty("m_PcInfo", &PJZAKO::m_PcInfo)
			.addProperty("m_DmgInfo", &PJZAKO::m_DmgInfo)
			.addProperty("m_AiInfo", &PJZAKO::m_AiInfo)
			.addProperty("m_Counter", &PJZAKO::m_Counter)
			.addProperty("m_CheckCanHitPrevCnt", &PJZAKO::m_CheckCanHitPrevCnt)
			.addProperty("m_AddKillNumWaitCounter", &PJZAKO::m_AddKillNumWaitCounter)
			.addProperty("m_boAddedKillNum", &PJZAKO::m_boAddedKillNum)
			.addProperty("m_boMoveTurretFlag", &PJZAKO::m_boMoveTurretFlag)
			.addProperty("m_boWayPointMoveAfterPop", &PJZAKO::m_boWayPointMoveAfterPop)
			.addProperty("m_pStateMachine", &PJZAKO::m_pStateMachine)
			.addProperty("m_eNowStateIdx", &PJZAKO::m_eNowStateIdx)
			.addProperty("m_ePrevStateIdx", &PJZAKO::m_ePrevStateIdx)
			.addProperty("m_eScareType", &PJZAKO::m_eScareType)
			.addProperty("mTargetDirec", &PJZAKO::mTargetDirec)
			.addProperty("mNowDirecY", &PJZAKO::mNowDirecY)
			.addProperty("mDeadModelType", &PJZAKO::mDeadModelType)
			.addProperty("m_EfDanmen", &PJZAKO::m_EfDanmen)
			.addProperty("m_pCutMark", &PJZAKO::m_pCutMark)
			.addProperty("mpEfQuestion", &PJZAKO::mpEfQuestion)
			.addProperty("m_pMotMng", &PJZAKO::m_pMotMng)
			.addProperty("m_WayPointArry", &PJZAKO::m_WayPointArry)
			.addProperty("m_iWayPoint", &PJZAKO::m_iWayPoint)
			.addProperty("m_pPathPlanner", &PJZAKO::m_pPathPlanner)
			.addProperty("m_boUseObstacleSensor", &PJZAKO::m_boUseObstacleSensor)
			.addProperty("m_boDisableInterestIK", &PJZAKO::m_boDisableInterestIK)
			.addProperty("m_boBerserkAtk", &PJZAKO::m_boBerserkAtk)
			.addProperty("m_boRequestDeathOutOfCamera", &PJZAKO::m_boRequestDeathOutOfCamera)
			.addProperty("m_boFirstBombDeadFxPlay", &PJZAKO::m_boFirstBombDeadFxPlay)
			.addProperty("m_JumpOffTojoLandingPos", &PJZAKO::m_JumpOffTojoLandingPos)
			.addProperty("m_boFixTurret", &PJZAKO::m_boFixTurret)
			.addProperty("m_eSdnAtkPopDir", &PJZAKO::m_eSdnAtkPopDir)
			.addProperty("m_pDP", &PJZAKO::m_pDP)
			.addProperty("m_pObsSens", &PJZAKO::m_pObsSens)
			.addProperty("m_Atk2PcHitAfterCnt", &PJZAKO::m_Atk2PcHitAfterCnt)
			.addProperty("m_boPcDownLaugh", &PJZAKO::m_boPcDownLaugh)
			.addProperty("m_pBulletManager", &PJZAKO::m_pBulletManager)
			.addProperty("m_boPhysicDeadProc", &PJZAKO::m_boPhysicDeadProc)
			.addProperty("m_bIsHeadPhysicsEnd", &PJZAKO::m_bIsHeadPhysicsEnd)
			.addProperty("m_pPhysicDeadGmf", &PJZAKO::m_pPhysicDeadGmf)
			.addProperty("m_boTodomeDead", &PJZAKO::m_boTodomeDead)
			.addProperty("m_boDeadEffectReq", &PJZAKO::m_boDeadEffectReq)
			.addProperty("m_DeadEffectCountCown", &PJZAKO::m_DeadEffectCountCown)
			.addProperty("m_ParticleDeadZakoTerminateWaitTick", &PJZAKO::m_ParticleDeadZakoTerminateWaitTick)
			.addProperty("m_pBnFxDmgDat", &PJZAKO::m_pBnFxDmgDat)
			.addProperty("m_boTimeShareUpdate", &PJZAKO::m_boTimeShareUpdate)
			.addProperty("m_eTimeShareStat", &PJZAKO::m_eTimeShareStat)
			.addProperty("m_CollInfo", &PJZAKO::m_CollInfo)
			.addProperty("m_Tex", &PJZAKO::m_Tex)
			.addProperty("m_ChangeStateLimitTick", &PJZAKO::m_ChangeStateLimitTick)
			.addProperty("m_fRotSpd", &PJZAKO::m_fRotSpd)
			.addProperty("m_BreakPopCmnObjPtrList", &PJZAKO::m_BreakPopCmnObjPtrList)
			.addProperty("m_pSyncPopCmnObj", &PJZAKO::m_pSyncPopCmnObj)
			.addProperty("m_boCalledNoGuardEfOnce", &PJZAKO::m_boCalledNoGuardEfOnce)
			.addProperty("m_OutOfCameraIkakuShootTime", &PJZAKO::m_OutOfCameraIkakuShootTime)
			.addProperty("m_State_Damage", &PJZAKO::m_State_Damage)
			.addProperty("m_State_CloseForAtk", &PJZAKO::m_State_CloseForAtk)
			.addProperty("m_State_AwayAfterAtk", &PJZAKO::m_State_AwayAfterAtk)
			.addProperty("m_State_ComboAttack", &PJZAKO::m_State_ComboAttack)
			.addProperty("m_State_StepInAttack", &PJZAKO::m_State_StepInAttack)
			.addProperty("m_State_Defence", &PJZAKO::m_State_Defence)
			.addProperty("m_State_Evacuate", &PJZAKO::m_State_Evacuate)
			.addProperty("m_State_RandomMove", &PJZAKO::m_State_RandomMove)
			.addProperty("m_State_ThroughDamage", &PJZAKO::m_State_ThroughDamage)
			.addProperty("m_State_DownDamage", &PJZAKO::m_State_DownDamage)
			.addProperty("m_State_Pressure", &PJZAKO::m_State_Pressure)
			.addProperty("m_State_WayPointMove", &PJZAKO::m_State_WayPointMove)
			.addProperty("m_State_Run", &PJZAKO::m_State_Run)
			.addProperty("m_State_Kosinukasi", &PJZAKO::m_State_Kosinukasi)
			.addProperty("m_State_Yotunbai", &PJZAKO::m_State_Yotunbai)
			.addProperty("m_State_Stand", &PJZAKO::m_State_Stand)
			.addProperty("m_StatePerformIll", &PJZAKO::m_StatePerformIll)
			.addProperty("m_ReleaseWaitIdle", &PJZAKO::m_ReleaseWaitIdle)
			.addProperty("m_State_Tojo_RunAndTurnPc", &PJZAKO::m_State_Tojo_RunAndTurnPc)
			.addProperty("m_State_Tojo_AgainstWall", &PJZAKO::m_State_Tojo_AgainstWall)
			.addProperty("m_State_Tojo_LookAround", &PJZAKO::m_State_Tojo_LookAround)
			.addProperty("m_State_Tojo_Stand", &PJZAKO::m_State_Tojo_Stand)
			.addProperty("m_State_Tojo_Bench", &PJZAKO::m_State_Tojo_Bench)
			.addProperty("m_State_Tojo_Sit", &PJZAKO::m_State_Tojo_Sit)
			.addProperty("m_State_Tojo_Car", &PJZAKO::m_State_Tojo_Car)
			.addProperty("m_State_Tojo_JumpOff", &PJZAKO::m_State_Tojo_JumpOff)
			.addProperty("m_State_Tojo_BreakCmnObj", &PJZAKO::m_State_Tojo_BreakCmnObj)
			.addProperty("m_State_Tojo_AeroBike", &PJZAKO::m_State_Tojo_AeroBike)
			.addProperty("m_State_Tojo_RoomRunner", &PJZAKO::m_State_Tojo_RoomRunner)
			.addProperty("m_State_LeadPcWayPointMove", &PJZAKO::m_State_LeadPcWayPointMove)
			.addProperty("m_State_FixTurret", &PJZAKO::m_State_FixTurret)
			.addProperty("m_State_WayPointMoveAfterPop", &PJZAKO::m_State_WayPointMoveAfterPop)
			.addProperty("m_State_DownAttack", &PJZAKO::m_State_DownAttack)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZAKO::m_StatePtrArr) == 240, "expected m_StatePtrArr to be size 240");
static_assert(sizeof(PJZAKO::m_BoneScale) == 4, "expected m_BoneScale to be size 4");
static_assert(sizeof(PJZAKO::m_SetDamageInfo) == 4, "expected m_SetDamageInfo to be size 4");
static_assert(sizeof(PJZAKO::m_ZakoInfo) == 148, "expected m_ZakoInfo to be size 148");
static_assert(sizeof(PJZAKO::m_MotionInfo) == 16, "expected m_MotionInfo to be size 16");
static_assert(sizeof(PJZAKO::m_TojoInfo) == 20, "expected m_TojoInfo to be size 20");
static_assert(sizeof(PJZAKO::m_PcInfo) == 64, "expected m_PcInfo to be size 64");
static_assert(sizeof(PJZAKO::m_DmgInfo) == 68, "expected m_DmgInfo to be size 68");
static_assert(sizeof(PJZAKO::m_AiInfo) == 76, "expected m_AiInfo to be size 76");
static_assert(sizeof(PJZAKO::m_Counter) == 4, "expected m_Counter to be size 4");
static_assert(sizeof(PJZAKO::m_CheckCanHitPrevCnt) == 4, "expected m_CheckCanHitPrevCnt to be size 4");
static_assert(sizeof(PJZAKO::m_AddKillNumWaitCounter) == 4, "expected m_AddKillNumWaitCounter to be size 4");
static_assert(sizeof(PJZAKO::m_boAddedKillNum) == 1, "expected m_boAddedKillNum to be size 1");
static_assert(sizeof(PJZAKO::m_boMoveTurretFlag) == 1, "expected m_boMoveTurretFlag to be size 1");
static_assert(sizeof(PJZAKO::m_boWayPointMoveAfterPop) == 1, "expected m_boWayPointMoveAfterPop to be size 1");
static_assert(sizeof(PJZAKO::m_pStateMachine) == 4, "expected m_pStateMachine to be size 4");
static_assert(sizeof(PJZAKO::m_eNowStateIdx) == 4, "expected m_eNowStateIdx to be size 4");
static_assert(sizeof(PJZAKO::m_ePrevStateIdx) == 4, "expected m_ePrevStateIdx to be size 4");
static_assert(sizeof(PJZAKO::m_eScareType) == 4, "expected m_eScareType to be size 4");
static_assert(sizeof(PJZAKO::mTargetDirec) == 4, "expected mTargetDirec to be size 4");
static_assert(sizeof(PJZAKO::mNowDirecY) == 4, "expected mNowDirecY to be size 4");
static_assert(sizeof(PJZAKO::mDeadModelType) == 4, "expected mDeadModelType to be size 4");
static_assert(sizeof(PJZAKO::m_EfDanmen) == 12, "expected m_EfDanmen to be size 12");
static_assert(sizeof(PJZAKO::m_pCutMark) == 4, "expected m_pCutMark to be size 4");
static_assert(sizeof(PJZAKO::mpEfQuestion) == 4, "expected mpEfQuestion to be size 4");
static_assert(sizeof(PJZAKO::m_pMotMng) == 4, "expected m_pMotMng to be size 4");
static_assert(sizeof(PJZAKO::m_WayPointArry) == 20, "expected m_WayPointArry to be size 20");
static_assert(sizeof(PJZAKO::m_iWayPoint) == 4, "expected m_iWayPoint to be size 4");
static_assert(sizeof(PJZAKO::m_pPathPlanner) == 4, "expected m_pPathPlanner to be size 4");
static_assert(sizeof(PJZAKO::m_boUseObstacleSensor) == 1, "expected m_boUseObstacleSensor to be size 1");
static_assert(sizeof(PJZAKO::m_boDisableInterestIK) == 1, "expected m_boDisableInterestIK to be size 1");
static_assert(sizeof(PJZAKO::m_boBerserkAtk) == 1, "expected m_boBerserkAtk to be size 1");
static_assert(sizeof(PJZAKO::m_boRequestDeathOutOfCamera) == 1, "expected m_boRequestDeathOutOfCamera to be size 1");
static_assert(sizeof(PJZAKO::m_boFirstBombDeadFxPlay) == 1, "expected m_boFirstBombDeadFxPlay to be size 1");
static_assert(sizeof(PJZAKO::m_JumpOffTojoLandingPos) == 12, "expected m_JumpOffTojoLandingPos to be size 12");
static_assert(sizeof(PJZAKO::m_boFixTurret) == 1, "expected m_boFixTurret to be size 1");
static_assert(sizeof(PJZAKO::m_eSdnAtkPopDir) == 4, "expected m_eSdnAtkPopDir to be size 4");
static_assert(sizeof(PJZAKO::m_pDP) == 4, "expected m_pDP to be size 4");
static_assert(sizeof(PJZAKO::m_pObsSens) == 4, "expected m_pObsSens to be size 4");
static_assert(sizeof(PJZAKO::m_Atk2PcHitAfterCnt) == 4, "expected m_Atk2PcHitAfterCnt to be size 4");
static_assert(sizeof(PJZAKO::m_boPcDownLaugh) == 1, "expected m_boPcDownLaugh to be size 1");
static_assert(sizeof(PJZAKO::m_pBulletManager) == 4, "expected m_pBulletManager to be size 4");
static_assert(sizeof(PJZAKO::m_boPhysicDeadProc) == 1, "expected m_boPhysicDeadProc to be size 1");
static_assert(sizeof(PJZAKO::m_bIsHeadPhysicsEnd) == 1, "expected m_bIsHeadPhysicsEnd to be size 1");
static_assert(sizeof(PJZAKO::m_pPhysicDeadGmf) == 4, "expected m_pPhysicDeadGmf to be size 4");
static_assert(sizeof(PJZAKO::m_boTodomeDead) == 1, "expected m_boTodomeDead to be size 1");
static_assert(sizeof(PJZAKO::m_boDeadEffectReq) == 1, "expected m_boDeadEffectReq to be size 1");
static_assert(sizeof(PJZAKO::m_DeadEffectCountCown) == 4, "expected m_DeadEffectCountCown to be size 4");
static_assert(sizeof(PJZAKO::m_ParticleDeadZakoTerminateWaitTick) == 4, "expected m_ParticleDeadZakoTerminateWaitTick to be size 4");
static_assert(sizeof(PJZAKO::m_pBnFxDmgDat) == 4, "expected m_pBnFxDmgDat to be size 4");
static_assert(sizeof(PJZAKO::m_boTimeShareUpdate) == 1, "expected m_boTimeShareUpdate to be size 1");
static_assert(sizeof(PJZAKO::m_eTimeShareStat) == 4, "expected m_eTimeShareStat to be size 4");
static_assert(sizeof(PJZAKO::m_CollInfo) == 12, "expected m_CollInfo to be size 12");
static_assert(sizeof(PJZAKO::m_Tex) == 40, "expected m_Tex to be size 40");
static_assert(sizeof(PJZAKO::m_ChangeStateLimitTick) == 4, "expected m_ChangeStateLimitTick to be size 4");
static_assert(sizeof(PJZAKO::m_fRotSpd) == 4, "expected m_fRotSpd to be size 4");
static_assert(sizeof(PJZAKO::m_BreakPopCmnObjPtrList) == 12, "expected m_BreakPopCmnObjPtrList to be size 12");
static_assert(sizeof(PJZAKO::m_pSyncPopCmnObj) == 4, "expected m_pSyncPopCmnObj to be size 4");
static_assert(sizeof(PJZAKO::m_boCalledNoGuardEfOnce) == 1, "expected m_boCalledNoGuardEfOnce to be size 1");
static_assert(sizeof(PJZAKO::m_OutOfCameraIkakuShootTime) == 4, "expected m_OutOfCameraIkakuShootTime to be size 4");
static_assert(sizeof(PJZAKO::m_State_Damage) == 12, "expected m_State_Damage to be size 12");
static_assert(sizeof(PJZAKO::m_State_CloseForAtk) == 4, "expected m_State_CloseForAtk to be size 4");
static_assert(sizeof(PJZAKO::m_State_AwayAfterAtk) == 4, "expected m_State_AwayAfterAtk to be size 4");
static_assert(sizeof(PJZAKO::m_State_ComboAttack) == 12, "expected m_State_ComboAttack to be size 12");
static_assert(sizeof(PJZAKO::m_State_StepInAttack) == 4, "expected m_State_StepInAttack to be size 4");
static_assert(sizeof(PJZAKO::m_State_Defence) == 8, "expected m_State_Defence to be size 8");
static_assert(sizeof(PJZAKO::m_State_Evacuate) == 8, "expected m_State_Evacuate to be size 8");
static_assert(sizeof(PJZAKO::m_State_RandomMove) == 8, "expected m_State_RandomMove to be size 8");
static_assert(sizeof(PJZAKO::m_State_ThroughDamage) == 8, "expected m_State_ThroughDamage to be size 8");
static_assert(sizeof(PJZAKO::m_State_DownDamage) == 4, "expected m_State_DownDamage to be size 4");
static_assert(sizeof(PJZAKO::m_State_Pressure) == 12, "expected m_State_Pressure to be size 12");
static_assert(sizeof(PJZAKO::m_State_WayPointMove) == 8, "expected m_State_WayPointMove to be size 8");
static_assert(sizeof(PJZAKO::m_State_Run) == 8, "expected m_State_Run to be size 8");
static_assert(sizeof(PJZAKO::m_State_Kosinukasi) == 8, "expected m_State_Kosinukasi to be size 8");
static_assert(sizeof(PJZAKO::m_State_Yotunbai) == 8, "expected m_State_Yotunbai to be size 8");
static_assert(sizeof(PJZAKO::m_State_Stand) == 8, "expected m_State_Stand to be size 8");
static_assert(sizeof(PJZAKO::m_StatePerformIll) == 8, "expected m_StatePerformIll to be size 8");
static_assert(sizeof(PJZAKO::m_ReleaseWaitIdle) == 4, "expected m_ReleaseWaitIdle to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_RunAndTurnPc) == 4, "expected m_State_Tojo_RunAndTurnPc to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_AgainstWall) == 4, "expected m_State_Tojo_AgainstWall to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_LookAround) == 4, "expected m_State_Tojo_LookAround to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Stand) == 4, "expected m_State_Tojo_Stand to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Bench) == 4, "expected m_State_Tojo_Bench to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Sit) == 4, "expected m_State_Tojo_Sit to be size 4");
static_assert(sizeof(PJZAKO::m_State_Tojo_Car) == 8, "expected m_State_Tojo_Car to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_JumpOff) == 8, "expected m_State_Tojo_JumpOff to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_BreakCmnObj) == 12, "expected m_State_Tojo_BreakCmnObj to be size 12");
static_assert(sizeof(PJZAKO::m_State_Tojo_AeroBike) == 8, "expected m_State_Tojo_AeroBike to be size 8");
static_assert(sizeof(PJZAKO::m_State_Tojo_RoomRunner) == 8, "expected m_State_Tojo_RoomRunner to be size 8");
static_assert(sizeof(PJZAKO::m_State_LeadPcWayPointMove) == 4, "expected m_State_LeadPcWayPointMove to be size 4");
static_assert(sizeof(PJZAKO::m_State_FixTurret) == 4, "expected m_State_FixTurret to be size 4");
static_assert(sizeof(PJZAKO::m_State_WayPointMoveAfterPop) == 4, "expected m_State_WayPointMoveAfterPop to be size 4");
static_assert(sizeof(PJZAKO::m_State_DownAttack) == 8, "expected m_State_DownAttack to be size 8");
static_assert(sizeof(class PJZAKO) == 2532, "expected class PJZAKO to be size 2532");

// class PJStateMachine
// no dependencies
class PJStateMachine
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <class PJZAKO* m_pOwner, offset 0x4>
	class PJZAKO* m_pOwner;

	// <class PJState* m_pCurrentState, offset 0x8>
	class PJState* m_pCurrentState;

	// <class PJState* m_pPreviousState, offset 0xc>
	class PJState* m_pPreviousState;

	// <class PJState* m_pGlobalState, offset 0x10>
	class PJState* m_pGlobalState;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJStateMachine>("PJStateMachine")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &PJStateMachine::field_0)
			.addProperty("m_pOwner", &PJStateMachine::m_pOwner)
			.addProperty("m_pCurrentState", &PJStateMachine::m_pCurrentState)
			.addProperty("m_pPreviousState", &PJStateMachine::m_pPreviousState)
			.addProperty("m_pGlobalState", &PJStateMachine::m_pGlobalState)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJStateMachine::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(PJStateMachine::m_pOwner) == 4, "expected m_pOwner to be size 4");
static_assert(sizeof(PJStateMachine::m_pCurrentState) == 4, "expected m_pCurrentState to be size 4");
static_assert(sizeof(PJStateMachine::m_pPreviousState) == 4, "expected m_pPreviousState to be size 4");
static_assert(sizeof(PJStateMachine::m_pGlobalState) == 4, "expected m_pGlobalState to be size 4");
static_assert(sizeof(class PJStateMachine) == 20, "expected class PJStateMachine to be size 20");

// class EffectDanmenFlash
// no dependencies
class EffectDanmenFlash
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[604];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectDanmenFlash>("EffectDanmenFlash")
		.endClass();
	}
#endif
};
static_assert(sizeof(class EffectDanmenFlash) == 604, "expected class EffectDanmenFlash to be size 604");

// class EffectCutMark
// no dependencies
class EffectCutMark
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[21812];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectCutMark>("EffectCutMark")
		.endClass();
	}
#endif
};
static_assert(sizeof(class EffectCutMark) == 21812, "expected class EffectCutMark to be size 21812");

// class EffectQuestion
// 12 dependencies: class HrTask, class rPrimUnific, enum GHMR_PROJECT, enum GHMR_PRIMTYPE, class rQuad, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, struct Vec
class EffectQuestion : HrTask
{
public:
	/// No namespace types
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Filler, offset 0x51>
	char _Filler2[3];

	// <class rPrimUnific m_StarUni, offset 0x54>
	class rPrimUnific m_StarUni;

	// <class rQuad m_Star, offset 0x74>
	class rQuad m_Star;

	// <struct tagGHMR_TEX m_StarTex, offset 0x120>
	struct tagGHMR_TEX m_StarTex;

	// <struct Vec m_Pos, offset 0x148>
	struct Vec m_Pos;

	// <float m_Speed, offset 0x154>
	float m_Speed;

	// <float m_Up, offset 0x158>
	float m_Up;

	// <float m_Add, offset 0x15c>
	float m_Add;

	// <float m_TimeCount, offset 0x160>
	float m_TimeCount;

	// <int32_t m_TimeFrame, offset 0x164>
	int32_t m_TimeFrame;

	// <float m_TimeRate, offset 0x168>
	float m_TimeRate;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectQuestion>("EffectQuestion")
			.addProperty("m_Flag", &EffectQuestion::m_Flag)
			.addProperty("m_StarUni", &EffectQuestion::m_StarUni)
			.addProperty("m_Star", &EffectQuestion::m_Star)
			.addProperty("m_StarTex", &EffectQuestion::m_StarTex)
			.addProperty("m_Pos", &EffectQuestion::m_Pos)
			.addProperty("m_Speed", &EffectQuestion::m_Speed)
			.addProperty("m_Up", &EffectQuestion::m_Up)
			.addProperty("m_Add", &EffectQuestion::m_Add)
			.addProperty("m_TimeCount", &EffectQuestion::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectQuestion::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectQuestion::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectQuestion::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectQuestion::m_StarUni) == 32, "expected m_StarUni to be size 32");
static_assert(sizeof(EffectQuestion::m_Star) == 172, "expected m_Star to be size 172");
static_assert(sizeof(EffectQuestion::m_StarTex) == 40, "expected m_StarTex to be size 40");
static_assert(sizeof(EffectQuestion::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectQuestion::m_Speed) == 4, "expected m_Speed to be size 4");
static_assert(sizeof(EffectQuestion::m_Up) == 4, "expected m_Up to be size 4");
static_assert(sizeof(EffectQuestion::m_Add) == 4, "expected m_Add to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeFrame) == 4, "expected m_TimeFrame to be size 4");
static_assert(sizeof(EffectQuestion::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(class EffectQuestion) == 364, "expected class EffectQuestion to be size 364");

// class PJZakoMotMng
// 3 dependencies: struct Vec, enum PJZakoMotMng::MotMode, enum eMoveDir
class PJZakoMotMng
{
public:
	/// 1 namespace types: enum PJZakoMotMng::MotMode

	// enum PJZakoMotMng::MotMode
	enum MotMode : uint32_t
	{
		// Enum values

		// <MotMode_Init = 0x0>
		MotMode_Init = 0,

		// <MotMode_Walk = 0x1>
		MotMode_Walk = 1,

		// <MotMode_Run = 0x2>
		MotMode_Run = 2,

		// <MotMode_Evacuate = 0x3>
		MotMode_Evacuate = 3,

		// <MotMode_Attack = 0x4>
		MotMode_Attack = 4,

		// <MotMode_Damage = 0x5>
		MotMode_Damage = 5,

		// <MotMode_Guard = 0x6>
		MotMode_Guard = 6,

		// <MotMode_Debug = 0x7>
		MotMode_Debug = 7,

		// <MotMode_Misc = 0x8>
		MotMode_Misc = 8,

		// <MotMode_NUM = 0x9>
		MotMode_NUM = 9

	};


	/// Struct member variables

	// <struct Vec m_MoveVec, offset 0x0>
	struct Vec m_MoveVec;

	// <float m_fCharRotY, offset 0xc>
	float m_fCharRotY;

	// <float m_fMoveSpd, offset 0x10>
	float m_fMoveSpd;

	// <float m_fMotSpd, offset 0x14>
	float m_fMotSpd;

	// <enum PJZakoMotMng::MotMode m_MotMode, offset 0x18>
	enum PJZakoMotMng::MotMode m_MotMode;

	// <class PJZAKO* m_pOwnerChar, offset 0x1c>
	class PJZAKO* m_pOwnerChar;

	// <enum eMoveDir m_MoveDir, offset 0x20>
	enum eMoveDir m_MoveDir;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJZakoMotMng>("PJZakoMotMng")
			.addProperty("m_MoveVec", &PJZakoMotMng::m_MoveVec)
			.addProperty("m_fCharRotY", &PJZakoMotMng::m_fCharRotY)
			.addProperty("m_fMoveSpd", &PJZakoMotMng::m_fMoveSpd)
			.addProperty("m_fMotSpd", &PJZakoMotMng::m_fMotSpd)
			.addProperty("m_MotMode", &PJZakoMotMng::m_MotMode)
			.addProperty("m_pOwnerChar", &PJZakoMotMng::m_pOwnerChar)
			.addProperty("m_MoveDir", &PJZakoMotMng::m_MoveDir)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoMotMng::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(PJZakoMotMng::m_fCharRotY) == 4, "expected m_fCharRotY to be size 4");
static_assert(sizeof(PJZakoMotMng::m_fMoveSpd) == 4, "expected m_fMoveSpd to be size 4");
static_assert(sizeof(PJZakoMotMng::m_fMotSpd) == 4, "expected m_fMotSpd to be size 4");
static_assert(sizeof(PJZakoMotMng::m_MotMode) == 4, "expected m_MotMode to be size 4");
static_assert(sizeof(PJZakoMotMng::m_pOwnerChar) == 4, "expected m_pOwnerChar to be size 4");
static_assert(sizeof(PJZakoMotMng::m_MoveDir) == 4, "expected m_MoveDir to be size 4");
static_assert(sizeof(class PJZakoMotMng) == 36, "expected class PJZakoMotMng to be size 36");

// class PathPlanner
// no dependencies
class PathPlanner
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[1220];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PathPlanner>("PathPlanner")
		.endClass();
	}
#endif
};
static_assert(sizeof(class PathPlanner) == 1220, "expected class PathPlanner to be size 1220");

// class FkDynamicParam
// 2 dependencies: class FkStlVector<FkDynamicParam::DynamicParam>, enum FkDynamicParam::DP_STAT
class FkDynamicParam
{
public:
	/// 2 namespace types: struct FkDynamicParam::DynamicParam, enum FkDynamicParam::DP_STAT

	// struct FkDynamicParam::DynamicParam
	// no dependencies
	struct DynamicParam
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <char* strParamName, offset 0x0>
		char* strParamName;

		// <float fParam, offset 0x4>
		float fParam;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkDynamicParam::DynamicParam>("FkDynamicParam::DynamicParam")
				// native pointer type (char*) not supported in LuaBridge (needs wrapper function)
				//.addProperty("strParamName", &FkDynamicParam::DynamicParam::strParamName)
				.addProperty("fParam", &FkDynamicParam::DynamicParam::fParam)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkDynamicParam::DynamicParam::strParamName) == 4, "expected strParamName to be size 4");
	static_assert(sizeof(FkDynamicParam::DynamicParam::fParam) == 4, "expected fParam to be size 4");
	static_assert(sizeof(struct FkDynamicParam::DynamicParam) == 8, "expected struct FkDynamicParam::DynamicParam to be size 8");

	// enum FkDynamicParam::DP_STAT
	enum DP_STAT : uint32_t
	{
		// Enum values

		// <eDP_STAT_INIT = 0xffffffffffffffff>
		eDP_STAT_INIT = UINT32_MAX,

		// <eDP_STAT_STANDBY = 0x0>
		eDP_STAT_STANDBY = 0

	};


	/// Struct member variables

	// <class FkStlVector<FkDynamicParam::DynamicParam> m_DP, offset 0x0>
	class FkStlVector<FkDynamicParam::DynamicParam> m_DP;

	// <char m_StrFilePath[0x104], offset 0x14>
	char m_StrFilePath[260];

	// <int32_t m_nParam, offset 0x118>
	int32_t m_nParam;

	// <enum FkDynamicParam::DP_STAT m_Stat, offset 0x11c>
	enum FkDynamicParam::DP_STAT m_Stat;

	// <char* m_pReadBuffer, offset 0x120>
	char* m_pReadBuffer;

	// <char* m_pReadHead, offset 0x124>
	char* m_pReadHead;

	// <uint32_t m_BufferSize, offset 0x128>
	uint32_t m_BufferSize;

	// <uint32_t m_HeadSize, offset 0x12c>
	uint32_t m_HeadSize;

	// <uint8_t m_boEOF, offset 0x130>
	uint8_t m_boEOF;

	// <Filler, offset 0x131>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkDynamicParam>("FkDynamicParam")
			.addProperty("m_DP", &FkDynamicParam::m_DP)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_StrFilePath", &FkDynamicParam::m_StrFilePath)
			.addProperty("m_nParam", &FkDynamicParam::m_nParam)
			.addProperty("m_Stat", &FkDynamicParam::m_Stat)
			// native pointer type (char*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pReadBuffer", &FkDynamicParam::m_pReadBuffer)
			// native pointer type (char*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_pReadHead", &FkDynamicParam::m_pReadHead)
			.addProperty("m_BufferSize", &FkDynamicParam::m_BufferSize)
			.addProperty("m_HeadSize", &FkDynamicParam::m_HeadSize)
			.addProperty("m_boEOF", &FkDynamicParam::m_boEOF)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkDynamicParam::m_DP) == 20, "expected m_DP to be size 20");
static_assert(sizeof(FkDynamicParam::m_StrFilePath) == 260, "expected m_StrFilePath to be size 260");
static_assert(sizeof(FkDynamicParam::m_nParam) == 4, "expected m_nParam to be size 4");
static_assert(sizeof(FkDynamicParam::m_Stat) == 4, "expected m_Stat to be size 4");
static_assert(sizeof(FkDynamicParam::m_pReadBuffer) == 4, "expected m_pReadBuffer to be size 4");
static_assert(sizeof(FkDynamicParam::m_pReadHead) == 4, "expected m_pReadHead to be size 4");
static_assert(sizeof(FkDynamicParam::m_BufferSize) == 4, "expected m_BufferSize to be size 4");
static_assert(sizeof(FkDynamicParam::m_HeadSize) == 4, "expected m_HeadSize to be size 4");
static_assert(sizeof(FkDynamicParam::m_boEOF) == 1, "expected m_boEOF to be size 1");
static_assert(sizeof(class FkDynamicParam) == 308, "expected class FkDynamicParam to be size 308");

// class FkObstacleSensor
// no dependencies
class FkObstacleSensor
{
public:
	/// 1 namespace types: void __convention("thiscall") FkObstacleSensor::FkObstacleSensor(class FkObstacleSensor* const this, class mHRChara* arg2)

	// TODO: Function 'void __convention("thiscall") FkObstacleSensor::FkObstacleSensor(class FkObstacleSensor* const this, class mHRChara* arg2)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[52];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkObstacleSensor>("FkObstacleSensor")
		.endClass();
	}
#endif
};
static_assert(sizeof(class FkObstacleSensor) == 52, "expected class FkObstacleSensor to be size 52");

// class FkBulletManager
// 2 dependencies: class FkStlVector<FkBulletManager::stEfBullet>, struct FkBulletManager::DmgInfo
class FkBulletManager
{
public:
	/// 3 namespace types: struct FkBulletManager::stEfBullet, struct FkBulletManager::DmgInfo, void __convention("thiscall") FkBulletManager::AddManageBullet(class FkBulletManager* const this, class HrTask* arg2, class EffectFkTobiDoguBase* arg3, class mHRChara* arg4, float arg5, float arg6, int32_t arg7, float arg8, uint8_t arg9, int32_t arg10)

	// struct FkBulletManager::stEfBullet
	// 1 dependencies: struct tagHRTASKCHECK
	struct stEfBullet
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint8_t fireFlag, offset 0x0>
		uint8_t fireFlag;

		// <Filler, offset 0x1>
		char _Filler1[3];

		// <class HrTask* pTask, offset 0x4>
		class HrTask* pTask;

		// <struct tagHRTASKCHECK taskCheckBullet, offset 0x8>
		struct tagHRTASKCHECK taskCheckBullet;

		// <class EffectFkTobiDoguBase* pTobiDoguBase, offset 0x10>
		class EffectFkTobiDoguBase* pTobiDoguBase;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkBulletManager::stEfBullet>("FkBulletManager::stEfBullet")
				.addProperty("fireFlag", &FkBulletManager::stEfBullet::fireFlag)
				.addProperty("pTask", &FkBulletManager::stEfBullet::pTask)
				.addProperty("taskCheckBullet", &FkBulletManager::stEfBullet::taskCheckBullet)
				.addProperty("pTobiDoguBase", &FkBulletManager::stEfBullet::pTobiDoguBase)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBulletManager::stEfBullet::fireFlag) == 1, "expected fireFlag to be size 1");
	static_assert(sizeof(FkBulletManager::stEfBullet::pTask) == 4, "expected pTask to be size 4");
	static_assert(sizeof(FkBulletManager::stEfBullet::taskCheckBullet) == 8, "expected taskCheckBullet to be size 8");
	static_assert(sizeof(FkBulletManager::stEfBullet::pTobiDoguBase) == 4, "expected pTobiDoguBase to be size 4");
	static_assert(sizeof(struct FkBulletManager::stEfBullet) == 20, "expected struct FkBulletManager::stEfBullet to be size 20");

	// struct FkBulletManager::DmgInfo
	// no dependencies
	struct DmgInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <float fDmg, offset 0x0>
		float fDmg;

		// <float fKnockBack, offset 0x4>
		float fKnockBack;

		// <int32_t AtkKind, offset 0x8>
		int32_t AtkKind;

		// <float fSubBatteryRatio, offset 0xc>
		float fSubBatteryRatio;

		// <uint8_t boDownAtk, offset 0x10>
		uint8_t boDownAtk;

		// <Filler, offset 0x11>
		char _Filler5[3];

		// <class mHRChara* pOwner, offset 0x14>
		class mHRChara* pOwner;

		// <int32_t CharaHitSeID, offset 0x18>
		int32_t CharaHitSeID;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkBulletManager::DmgInfo>("FkBulletManager::DmgInfo")
				.addProperty("fDmg", &FkBulletManager::DmgInfo::fDmg)
				.addProperty("fKnockBack", &FkBulletManager::DmgInfo::fKnockBack)
				.addProperty("AtkKind", &FkBulletManager::DmgInfo::AtkKind)
				.addProperty("fSubBatteryRatio", &FkBulletManager::DmgInfo::fSubBatteryRatio)
				.addProperty("boDownAtk", &FkBulletManager::DmgInfo::boDownAtk)
				.addProperty("pOwner", &FkBulletManager::DmgInfo::pOwner)
				.addProperty("CharaHitSeID", &FkBulletManager::DmgInfo::CharaHitSeID)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBulletManager::DmgInfo::fDmg) == 4, "expected fDmg to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::fKnockBack) == 4, "expected fKnockBack to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::AtkKind) == 4, "expected AtkKind to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::fSubBatteryRatio) == 4, "expected fSubBatteryRatio to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::boDownAtk) == 1, "expected boDownAtk to be size 1");
	static_assert(sizeof(FkBulletManager::DmgInfo::pOwner) == 4, "expected pOwner to be size 4");
	static_assert(sizeof(FkBulletManager::DmgInfo::CharaHitSeID) == 4, "expected CharaHitSeID to be size 4");
	static_assert(sizeof(struct FkBulletManager::DmgInfo) == 28, "expected struct FkBulletManager::DmgInfo to be size 28");

	// TODO: Function 'void __convention("thiscall") FkBulletManager::AddManageBullet(class FkBulletManager* const this, class HrTask* arg2, class EffectFkTobiDoguBase* arg3, class mHRChara* arg4, float arg5, float arg6, int32_t arg7, float arg8, uint8_t arg9, int32_t arg10)'

	/// Struct member variables

	// <class FkStlVector<FkBulletManager::stEfBullet> mEfBulletArr, offset 0x0>
	class FkStlVector<FkBulletManager::stEfBullet> mEfBulletArr;

	// <int32_t m_nBulletMax, offset 0x14>
	int32_t m_nBulletMax;

	// <struct FkBulletManager::DmgInfo m_DmgInfo, offset 0x18>
	struct FkBulletManager::DmgInfo m_DmgInfo;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkBulletManager>("FkBulletManager")
			.addProperty("mEfBulletArr", &FkBulletManager::mEfBulletArr)
			.addProperty("m_nBulletMax", &FkBulletManager::m_nBulletMax)
			.addProperty("m_DmgInfo", &FkBulletManager::m_DmgInfo)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkBulletManager::mEfBulletArr) == 20, "expected mEfBulletArr to be size 20");
static_assert(sizeof(FkBulletManager::m_nBulletMax) == 4, "expected m_nBulletMax to be size 4");
static_assert(sizeof(FkBulletManager::m_DmgInfo) == 28, "expected m_DmgInfo to be size 28");
static_assert(sizeof(class FkBulletManager) == 52, "expected class FkBulletManager to be size 52");

// class EffectFkTobiDoguBase
// 5 dependencies: struct Vec, struct tagHRTASKCHECK, struct EffectFkTobiDoguBase::strHitCheck, struct EffectFkTobiDoguBase::HitObjInfo, enum EffectFkTobiDoguBase::eHitObjType
class EffectFkTobiDoguBase
{
public:
	/// 3 namespace types: struct EffectFkTobiDoguBase::strHitCheck, enum EffectFkTobiDoguBase::eHitObjType, struct EffectFkTobiDoguBase::HitObjInfo

	// struct EffectFkTobiDoguBase::strHitCheck
	// no dependencies
	struct strHitCheck
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <float fTgtRadius, offset 0x0>
		float fTgtRadius;

		// <struct Vec* pTgtPos, offset 0x4>
		struct Vec* pTgtPos;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectFkTobiDoguBase::strHitCheck>("EffectFkTobiDoguBase::strHitCheck")
				.addProperty("fTgtRadius", &EffectFkTobiDoguBase::strHitCheck::fTgtRadius)
				.addProperty("pTgtPos", &EffectFkTobiDoguBase::strHitCheck::pTgtPos)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFkTobiDoguBase::strHitCheck::fTgtRadius) == 4, "expected fTgtRadius to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::strHitCheck::pTgtPos) == 4, "expected pTgtPos to be size 4");
	static_assert(sizeof(struct EffectFkTobiDoguBase::strHitCheck) == 8, "expected struct EffectFkTobiDoguBase::strHitCheck to be size 8");

	// enum EffectFkTobiDoguBase::eHitObjType
	enum eHitObjType : uint32_t
	{
		// Enum values

		// <eHitObjType_Unknown = 0xffffffffffffffff>
		eHitObjType_Unknown = UINT32_MAX,

		// <eHitObjType_Stage = 0x0>
		eHitObjType_Stage = 0,

		// <eHitObjType_Char = 0x1>
		eHitObjType_Char = 1

	};

	// struct EffectFkTobiDoguBase::HitObjInfo
	// 2 dependencies: enum EffectFkTobiDoguBase::eHitObjType, struct Vec
	struct HitObjInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint8_t boHit, offset 0x0>
		uint8_t boHit;

		// <Filler, offset 0x1>
		char _Filler1[3];

		// <enum EffectFkTobiDoguBase::eHitObjType eHitObjType, offset 0x4>
		enum eHitObjType eHitObjType;

		// <struct Vec HitPos, offset 0x8>
		struct Vec HitPos;

		// <float fSqDistFromLaunch, offset 0x14>
		float fSqDistFromLaunch;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectFkTobiDoguBase::HitObjInfo>("EffectFkTobiDoguBase::HitObjInfo")
				.addProperty("boHit", &EffectFkTobiDoguBase::HitObjInfo::boHit)
				.addProperty("eHitObjType", &EffectFkTobiDoguBase::HitObjInfo::eHitObjType)
				.addProperty("HitPos", &EffectFkTobiDoguBase::HitObjInfo::HitPos)
				.addProperty("fSqDistFromLaunch", &EffectFkTobiDoguBase::HitObjInfo::fSqDistFromLaunch)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::boHit) == 1, "expected boHit to be size 1");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::eHitObjType) == 4, "expected eHitObjType to be size 4");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::HitPos) == 12, "expected HitPos to be size 12");
	static_assert(sizeof(EffectFkTobiDoguBase::HitObjInfo::fSqDistFromLaunch) == 4, "expected fSqDistFromLaunch to be size 4");
	static_assert(sizeof(struct EffectFkTobiDoguBase::HitObjInfo) == 24, "expected struct EffectFkTobiDoguBase::HitObjInfo to be size 24");


	/// Struct member variables

	// <void* (* field_0)[0x3], offset 0x0>
	void* (* field_0)[0x3];

	// <uint8_t m_Flag, offset 0x4>
	uint8_t m_Flag;

	// <Filler, offset 0x5>
	char _Filler2[3];

	// <float m_TimeCount, offset 0x8>
	float m_TimeCount;

	// <float m_TimeRate, offset 0xc>
	float m_TimeRate;

	// <uint32_t m_Counter, offset 0x10>
	uint32_t m_Counter;

	// <int32_t m_PcDmgMotNo, offset 0x14>
	int32_t m_PcDmgMotNo;

	// <int32_t m_PcGrdMotNo, offset 0x18>
	int32_t m_PcGrdMotNo;

	// <float m_Damage, offset 0x1c>
	float m_Damage;

	// <float m_RotY, offset 0x20>
	float m_RotY;

	// <struct Vec m_TgtPos, offset 0x24>
	struct Vec m_TgtPos;

	// <float m_Speed, offset 0x30>
	float m_Speed;

	// <float m_BackBlow, offset 0x34>
	float m_BackBlow;

	// <uint8_t m_Reverse, offset 0x38>
	uint8_t m_Reverse;

	// <uint8_t m_bHitExp, offset 0x39>
	uint8_t m_bHitExp;

	// <uint8_t m_boDeleteRequest, offset 0x3a>
	uint8_t m_boDeleteRequest;

	// <Filler, offset 0x3b>
	char _Filler15[1];

	// <struct Vec m_LancPos, offset 0x3c>
	struct Vec m_LancPos;

	// <struct Vec m_Pos, offset 0x48>
	struct Vec m_Pos;

	// <struct Vec m_MoveVec, offset 0x54>
	struct Vec m_MoveVec;

	// <struct Vec m_BeforePos, offset 0x60>
	struct Vec m_BeforePos;

	// <struct Vec m_MoveDir, offset 0x6c>
	struct Vec m_MoveDir;

	// <class EffectGunTrack* m_pGunTrack, offset 0x78>
	class EffectGunTrack* m_pGunTrack;

	// <struct tagHRTASKCHECK m_TrackCheck, offset 0x7c>
	struct tagHRTASKCHECK m_TrackCheck;

	// <struct Vec m_DbgColSegA, offset 0x84>
	struct Vec m_DbgColSegA;

	// <struct Vec m_DbgColSegB, offset 0x90>
	struct Vec m_DbgColSegB;

	// <int32_t mStgHitSeID, offset 0x9c>
	int32_t mStgHitSeID;

	// <struct EffectFkTobiDoguBase::strHitCheck m_HitCheckInfo, offset 0xa0>
	struct EffectFkTobiDoguBase::strHitCheck m_HitCheckInfo;

	// <class WGcl* m_pGcl, offset 0xa8>
	class WGcl* m_pGcl;

	// <struct EffectFkTobiDoguBase::HitObjInfo m_HitInfo, offset 0xac>
	struct EffectFkTobiDoguBase::HitObjInfo m_HitInfo;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectFkTobiDoguBase>("EffectFkTobiDoguBase")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &EffectFkTobiDoguBase::field_0)
			.addProperty("m_Flag", &EffectFkTobiDoguBase::m_Flag)
			.addProperty("m_TimeCount", &EffectFkTobiDoguBase::m_TimeCount)
			.addProperty("m_TimeRate", &EffectFkTobiDoguBase::m_TimeRate)
			.addProperty("m_Counter", &EffectFkTobiDoguBase::m_Counter)
			.addProperty("m_PcDmgMotNo", &EffectFkTobiDoguBase::m_PcDmgMotNo)
			.addProperty("m_PcGrdMotNo", &EffectFkTobiDoguBase::m_PcGrdMotNo)
			.addProperty("m_Damage", &EffectFkTobiDoguBase::m_Damage)
			.addProperty("m_RotY", &EffectFkTobiDoguBase::m_RotY)
			.addProperty("m_TgtPos", &EffectFkTobiDoguBase::m_TgtPos)
			.addProperty("m_Speed", &EffectFkTobiDoguBase::m_Speed)
			.addProperty("m_BackBlow", &EffectFkTobiDoguBase::m_BackBlow)
			.addProperty("m_Reverse", &EffectFkTobiDoguBase::m_Reverse)
			.addProperty("m_bHitExp", &EffectFkTobiDoguBase::m_bHitExp)
			.addProperty("m_boDeleteRequest", &EffectFkTobiDoguBase::m_boDeleteRequest)
			.addProperty("m_LancPos", &EffectFkTobiDoguBase::m_LancPos)
			.addProperty("m_Pos", &EffectFkTobiDoguBase::m_Pos)
			.addProperty("m_MoveVec", &EffectFkTobiDoguBase::m_MoveVec)
			.addProperty("m_BeforePos", &EffectFkTobiDoguBase::m_BeforePos)
			.addProperty("m_MoveDir", &EffectFkTobiDoguBase::m_MoveDir)
			.addProperty("m_pGunTrack", &EffectFkTobiDoguBase::m_pGunTrack)
			.addProperty("m_TrackCheck", &EffectFkTobiDoguBase::m_TrackCheck)
			.addProperty("m_DbgColSegA", &EffectFkTobiDoguBase::m_DbgColSegA)
			.addProperty("m_DbgColSegB", &EffectFkTobiDoguBase::m_DbgColSegB)
			.addProperty("mStgHitSeID", &EffectFkTobiDoguBase::mStgHitSeID)
			.addProperty("m_HitCheckInfo", &EffectFkTobiDoguBase::m_HitCheckInfo)
			.addProperty("m_pGcl", &EffectFkTobiDoguBase::m_pGcl)
			.addProperty("m_HitInfo", &EffectFkTobiDoguBase::m_HitInfo)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectFkTobiDoguBase::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Counter) == 4, "expected m_Counter to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_PcDmgMotNo) == 4, "expected m_PcDmgMotNo to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_PcGrdMotNo) == 4, "expected m_PcGrdMotNo to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Damage) == 4, "expected m_Damage to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_RotY) == 4, "expected m_RotY to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TgtPos) == 12, "expected m_TgtPos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_Speed) == 4, "expected m_Speed to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_BackBlow) == 4, "expected m_BackBlow to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_Reverse) == 1, "expected m_Reverse to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_bHitExp) == 1, "expected m_bHitExp to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_boDeleteRequest) == 1, "expected m_boDeleteRequest to be size 1");
static_assert(sizeof(EffectFkTobiDoguBase::m_LancPos) == 12, "expected m_LancPos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_BeforePos) == 12, "expected m_BeforePos to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_MoveDir) == 12, "expected m_MoveDir to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_pGunTrack) == 4, "expected m_pGunTrack to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_TrackCheck) == 8, "expected m_TrackCheck to be size 8");
static_assert(sizeof(EffectFkTobiDoguBase::m_DbgColSegA) == 12, "expected m_DbgColSegA to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::m_DbgColSegB) == 12, "expected m_DbgColSegB to be size 12");
static_assert(sizeof(EffectFkTobiDoguBase::mStgHitSeID) == 4, "expected mStgHitSeID to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_HitCheckInfo) == 8, "expected m_HitCheckInfo to be size 8");
static_assert(sizeof(EffectFkTobiDoguBase::m_pGcl) == 4, "expected m_pGcl to be size 4");
static_assert(sizeof(EffectFkTobiDoguBase::m_HitInfo) == 24, "expected m_HitInfo to be size 24");
static_assert(sizeof(class EffectFkTobiDoguBase) == 196, "expected class EffectFkTobiDoguBase to be size 196");

// class rQuadEx
// no dependencies
class rQuadEx
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[220];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rQuadEx>("rQuadEx")
		.endClass();
	}
#endif
};
static_assert(sizeof(class rQuadEx) == 220, "expected class rQuadEx to be size 220");

// class EffectGunTrack
// 5 dependencies: class HrTask, class rPrimUnific, enum GHMR_PROJECT, enum GHMR_PRIMTYPE, class rQuadEx
class EffectGunTrack : HrTask
{
public:
	/// No namespace types
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Filler, offset 0x51>
	char _Filler2[3];

	// <class rPrimUnific m_SmokeUni, offset 0x54>
	class rPrimUnific m_SmokeUni;

	// <class rQuadEx* m_pWidth, offset 0x74>
	class rQuadEx* m_pWidth;

	// <class rQuadEx* m_pHeight, offset 0x78>
	class rQuadEx* m_pHeight;

	// <class rPrimUnific m_LightUni, offset 0x7c>
	class rPrimUnific m_LightUni;

	// <class rQuadEx m_LightWidth, offset 0x9c>
	class rQuadEx m_LightWidth;

	// <class rQuadEx m_LightHeight, offset 0x178>
	class rQuadEx m_LightHeight;

	// <struct Vec* m_pSlashPoint, offset 0x254>
	struct Vec* m_pSlashPoint;

	// <uint32_t m_PointAddCount, offset 0x258>
	uint32_t m_PointAddCount;

	// <uint32_t m_MaxPoint, offset 0x25c>
	uint32_t m_MaxPoint;

	// <uint32_t m_PolyMax, offset 0x260>
	uint32_t m_PolyMax;

	// <uint32_t m_DeleteCount, offset 0x264>
	uint32_t m_DeleteCount;

	// <float m_RotY, offset 0x268>
	float m_RotY;

	// <float m_Scale, offset 0x26c>
	float m_Scale;

	// <float m_Anime, offset 0x270>
	float m_Anime;

	// <float* m_RandU, offset 0x274>
	float* m_RandU;

	// <float m_OnePiece, offset 0x278>
	float m_OnePiece;

	// <float m_TimeCount, offset 0x27c>
	float m_TimeCount;

	// <int32_t m_TimeFrame, offset 0x280>
	int32_t m_TimeFrame;

	// <float m_TimeRate, offset 0x284>
	float m_TimeRate;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectGunTrack>("EffectGunTrack")
			.addProperty("m_Flag", &EffectGunTrack::m_Flag)
			.addProperty("m_SmokeUni", &EffectGunTrack::m_SmokeUni)
			.addProperty("m_pWidth", &EffectGunTrack::m_pWidth)
			.addProperty("m_pHeight", &EffectGunTrack::m_pHeight)
			.addProperty("m_LightUni", &EffectGunTrack::m_LightUni)
			.addProperty("m_LightWidth", &EffectGunTrack::m_LightWidth)
			.addProperty("m_LightHeight", &EffectGunTrack::m_LightHeight)
			.addProperty("m_pSlashPoint", &EffectGunTrack::m_pSlashPoint)
			.addProperty("m_PointAddCount", &EffectGunTrack::m_PointAddCount)
			.addProperty("m_MaxPoint", &EffectGunTrack::m_MaxPoint)
			.addProperty("m_PolyMax", &EffectGunTrack::m_PolyMax)
			.addProperty("m_DeleteCount", &EffectGunTrack::m_DeleteCount)
			.addProperty("m_RotY", &EffectGunTrack::m_RotY)
			.addProperty("m_Scale", &EffectGunTrack::m_Scale)
			.addProperty("m_Anime", &EffectGunTrack::m_Anime)
			// native pointer type (float*) not supported in LuaBridge (needs wrapper function)
			//.addProperty("m_RandU", &EffectGunTrack::m_RandU)
			.addProperty("m_OnePiece", &EffectGunTrack::m_OnePiece)
			.addProperty("m_TimeCount", &EffectGunTrack::m_TimeCount)
			.addProperty("m_TimeFrame", &EffectGunTrack::m_TimeFrame)
			.addProperty("m_TimeRate", &EffectGunTrack::m_TimeRate)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectGunTrack::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectGunTrack::m_SmokeUni) == 32, "expected m_SmokeUni to be size 32");
static_assert(sizeof(EffectGunTrack::m_pWidth) == 4, "expected m_pWidth to be size 4");
static_assert(sizeof(EffectGunTrack::m_pHeight) == 4, "expected m_pHeight to be size 4");
static_assert(sizeof(EffectGunTrack::m_LightUni) == 32, "expected m_LightUni to be size 32");
static_assert(sizeof(EffectGunTrack::m_LightWidth) == 220, "expected m_LightWidth to be size 220");
static_assert(sizeof(EffectGunTrack::m_LightHeight) == 220, "expected m_LightHeight to be size 220");
static_assert(sizeof(EffectGunTrack::m_pSlashPoint) == 4, "expected m_pSlashPoint to be size 4");
static_assert(sizeof(EffectGunTrack::m_PointAddCount) == 4, "expected m_PointAddCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_MaxPoint) == 4, "expected m_MaxPoint to be size 4");
static_assert(sizeof(EffectGunTrack::m_PolyMax) == 4, "expected m_PolyMax to be size 4");
static_assert(sizeof(EffectGunTrack::m_DeleteCount) == 4, "expected m_DeleteCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_RotY) == 4, "expected m_RotY to be size 4");
static_assert(sizeof(EffectGunTrack::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EffectGunTrack::m_Anime) == 4, "expected m_Anime to be size 4");
static_assert(sizeof(EffectGunTrack::m_RandU) == 4, "expected m_RandU to be size 4");
static_assert(sizeof(EffectGunTrack::m_OnePiece) == 4, "expected m_OnePiece to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeCount) == 4, "expected m_TimeCount to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeFrame) == 4, "expected m_TimeFrame to be size 4");
static_assert(sizeof(EffectGunTrack::m_TimeRate) == 4, "expected m_TimeRate to be size 4");
static_assert(sizeof(class EffectGunTrack) == 648, "expected class EffectGunTrack to be size 648");

// class pcSNB
// no dependencies
class pcSNB
{
public:
	/// 1 namespace types: class mHRChara* __convention("thiscall") pcSNB::mGetSerchNearJumpAttackTarget(class pcSNB* const this)

	// TODO: Function 'class mHRChara* __convention("thiscall") pcSNB::mGetSerchNearJumpAttackTarget(class pcSNB* const this)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[8252];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<pcSNB>("pcSNB")
		.endClass();
	}
#endif
};
static_assert(sizeof(class pcSNB) == 8252, "expected class pcSNB to be size 8252");

// class State_Tojo_Knife_SuddenAttack
// 5 dependencies: class State_Tojo_SuddenAttack, class State_TojoBaseState, class PJState, enum State_Tojo_Knife_SuddenAttack::eStat, struct Vec
class State_Tojo_Knife_SuddenAttack : State_Tojo_SuddenAttack
{
public:
	/// 1 namespace types: enum State_Tojo_Knife_SuddenAttack::eStat

	// enum State_Tojo_Knife_SuddenAttack::eStat
	enum eStat : uint32_t
	{
		// Enum values

		// <eStat_Init = 0x0>
		eStat_Init = 0,

		// <eStat_WaitPcClose = 0x1>
		eStat_WaitPcClose = 1,

		// <eStat_Attack = 0x2>
		eStat_Attack = 2

	};


	/// Struct member variables

	// <class State_Tojo_SuddenAttack field_0, offset 0x0>
	// class State_Tojo_SuddenAttack Super;

	// <enum State_Tojo_Knife_SuddenAttack::eStat m_eStat, offset 0x4>
	enum State_Tojo_Knife_SuddenAttack::eStat m_eStat;

	// <struct Vec m_TrapPos, offset 0x8>
	struct Vec m_TrapPos;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<State_Tojo_Knife_SuddenAttack>("State_Tojo_Knife_SuddenAttack")
			.addProperty("m_eStat", &State_Tojo_Knife_SuddenAttack::m_eStat)
			.addProperty("m_TrapPos", &State_Tojo_Knife_SuddenAttack::m_TrapPos)
		.endClass();
	}
#endif
};
static_assert(sizeof(State_Tojo_Knife_SuddenAttack::m_eStat) == 4, "expected m_eStat to be size 4");
static_assert(sizeof(State_Tojo_Knife_SuddenAttack::m_TrapPos) == 12, "expected m_TrapPos to be size 12");
static_assert(sizeof(class State_Tojo_Knife_SuddenAttack) == 20, "expected class State_Tojo_Knife_SuddenAttack to be size 20");

// class ZkKnifeState_ThroughKnife
// 1 dependencies: class PJState
class ZkKnifeState_ThroughKnife : PJState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJState field_0, offset 0x0>
	// class PJState Super;

	// <uint8_t m_boTrigger, offset 0x4>
	uint8_t m_boTrigger;

	// <Filler, offset 0x5>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<ZkKnifeState_ThroughKnife>("ZkKnifeState_ThroughKnife")
			.addProperty("m_boTrigger", &ZkKnifeState_ThroughKnife::m_boTrigger)
		.endClass();
	}
#endif
};
static_assert(sizeof(ZkKnifeState_ThroughKnife::m_boTrigger) == 1, "expected m_boTrigger to be size 1");
static_assert(sizeof(class ZkKnifeState_ThroughKnife) == 8, "expected class ZkKnifeState_ThroughKnife to be size 8");

// class PJZAKOBoneB
// 107 dependencies: class PJZAKO, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, enum eZkBoneScale, struct ZkSetDamageInfo, struct PJZAKO::ZakoInfo, enum eMoveDir, enum eSideFromPc, enum ePcSideFromMe, class FkCounter, struct PJZAKO::MotionInfo, struct PJZAKO::TojoInfo, enum eZkCarSheet, struct PJZAKO::PcInfo, enum enPcPose, struct PJZAKO::DmgInfo, enum eDownDir, struct PJZAKO::AiInfo, struct ZkEvacuateParam, struct ZkGuardParam, enum eFightLine, enum FightSpirit, enum eZkStat, enum eScareType, struct PJZAKO::EfDanmen, struct tagHRTASKCHECK, class FkStlVector<Vec>, enum PJZAKO::eSuddenAtkPopDir, enum PJZAKO::eTimeShare, struct CollInfo, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, class FkStlList<commonObj *>, class State_Damage, class PJState, enum State_Damage::eStat, class State_CloseBeforeAttack, class State_AwayAfterAttack, class State_ComboAttack, enum State_ComboAttack::eStat, class State_StepInAttack, class State_Defence, class State_Evacuate, class State_RandomMove, class State_ThroughDamage, class State_DownDamage, class State_Pressure, enum State_Pressure::eStat, class State_WayPointMove, enum State_WayPointMove::eWaypointSbSt, class State_Scare_Run, class State_Scare_Base, class State_Scare_Kosinukasi, class State_Scare_Yotunbai, class State_Scare_Stand, class State_PerformIll, class State_ReleaseWaitIdle, class State_Idle, class State_TojoBaseState, class State_Tojo_RunAndTurnPc, class State_Tojo_AgainstWall, class State_Tojo_LookAround, class State_Tojo_Stand, class State_Tojo_Bench, class State_Tojo_Sit, class State_Tojo_Car, enum State_Tojo_Car::eStat, class State_Tojo_JumpOff, class State_Tojo_BreakCmnObj, enum State_Tojo_BreakCmnObj::eStat, class State_Tojo_AeroBike, enum State_Tojo_AeroBike::eStat, class State_Tojo_RoomRunner, enum State_Tojo_RoomRunner::eStat, class State_LeadPcWayPointMove, class State_FixTurret, class State_WayPointMoveAfterPop, class ZkState_DownAttack, enum ZkState_DownAttack::eStat
class PJZAKOBoneB : PJZAKO
{
public:
	/// No namespace types
	/// Struct member variables

	// <class PJZAKO field_0, offset 0x0>
	// class PJZAKO Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJZAKOBoneB>("PJZAKOBoneB")
		.endClass();
	}
#endif
};
static_assert(sizeof(class PJZAKOBoneB) == 2532, "expected class PJZAKOBoneB to be size 2532");

// class PJZakoKnife
// 112 dependencies: class PJZAKOBoneB, class PJZAKO, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, enum eZkBoneScale, struct ZkSetDamageInfo, struct PJZAKO::ZakoInfo, enum eMoveDir, enum eSideFromPc, enum ePcSideFromMe, class FkCounter, struct PJZAKO::MotionInfo, struct PJZAKO::TojoInfo, enum eZkCarSheet, struct PJZAKO::PcInfo, enum enPcPose, struct PJZAKO::DmgInfo, enum eDownDir, struct PJZAKO::AiInfo, struct ZkEvacuateParam, struct ZkGuardParam, enum eFightLine, enum FightSpirit, enum eZkStat, enum eScareType, struct PJZAKO::EfDanmen, struct tagHRTASKCHECK, class FkStlVector<Vec>, enum PJZAKO::eSuddenAtkPopDir, enum PJZAKO::eTimeShare, struct CollInfo, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, class FkStlList<commonObj *>, class State_Damage, class PJState, enum State_Damage::eStat, class State_CloseBeforeAttack, class State_AwayAfterAttack, class State_ComboAttack, enum State_ComboAttack::eStat, class State_StepInAttack, class State_Defence, class State_Evacuate, class State_RandomMove, class State_ThroughDamage, class State_DownDamage, class State_Pressure, enum State_Pressure::eStat, class State_WayPointMove, enum State_WayPointMove::eWaypointSbSt, class State_Scare_Run, class State_Scare_Base, class State_Scare_Kosinukasi, class State_Scare_Yotunbai, class State_Scare_Stand, class State_PerformIll, class State_ReleaseWaitIdle, class State_Idle, class State_TojoBaseState, class State_Tojo_RunAndTurnPc, class State_Tojo_AgainstWall, class State_Tojo_LookAround, class State_Tojo_Stand, class State_Tojo_Bench, class State_Tojo_Sit, class State_Tojo_Car, enum State_Tojo_Car::eStat, class State_Tojo_JumpOff, class State_Tojo_BreakCmnObj, enum State_Tojo_BreakCmnObj::eStat, class State_Tojo_AeroBike, enum State_Tojo_AeroBike::eStat, class State_Tojo_RoomRunner, enum State_Tojo_RoomRunner::eStat, class State_LeadPcWayPointMove, class State_FixTurret, class State_WayPointMoveAfterPop, class ZkState_DownAttack, enum ZkState_DownAttack::eStat, class ZkKnifeState_ThroughKnife, class State_Tojo_Knife_SuddenAttack, class State_Tojo_SuddenAttack, enum State_Tojo_Knife_SuddenAttack::eStat
class PJZakoKnife : PJZAKOBoneB
{
public:
	/// 1 namespace types: int32_t __convention("thiscall") PJZakoKnife::ConvertDmgMot(class PJZakoKnife* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4)

	// TODO: Function 'int32_t __convention("thiscall") PJZakoKnife::ConvertDmgMot(class PJZakoKnife* const this, int32_t const arg2, int32_t const arg3, class mHRChara* arg4)'

	/// Struct member variables

	// <class PJZAKOBoneB field_0, offset 0x0>
	// class PJZAKOBoneB Super;

	// <class ZkKnifeState_ThroughKnife m_State_ThroughKnife, offset 0x9e4>
	class ZkKnifeState_ThroughKnife m_State_ThroughKnife;

	// <class State_Tojo_Knife_SuddenAttack m_State_SdnAtk, offset 0x9ec>
	class State_Tojo_Knife_SuddenAttack m_State_SdnAtk;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJZakoKnife>("PJZakoKnife")
			.addProperty("m_State_ThroughKnife", &PJZakoKnife::m_State_ThroughKnife)
			.addProperty("m_State_SdnAtk", &PJZakoKnife::m_State_SdnAtk)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJZakoKnife::m_State_ThroughKnife) == 8, "expected m_State_ThroughKnife to be size 8");
static_assert(sizeof(PJZakoKnife::m_State_SdnAtk) == 20, "expected m_State_SdnAtk to be size 20");
static_assert(sizeof(class PJZakoKnife) == 2560, "expected class PJZakoKnife to be size 2560");

// class bsSKE
// no dependencies
class bsSKE
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") bsSKE::mSetDamage(class bsSKE* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") bsSKE::mSetDamage(class bsSKE* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[3684];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsSKE>("bsSKE")
		.endClass();
	}
#endif
};
static_assert(sizeof(class bsSKE) == 3684, "expected class bsSKE to be size 3684");

// class bsLEZ
// no dependencies
class bsLEZ
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") bsLEZ::mSetDamage(class bsLEZ* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") bsLEZ::mSetDamage(class bsLEZ* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[4412];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsLEZ>("bsLEZ")
		.endClass();
	}
#endif
};
static_assert(sizeof(class bsLEZ) == 4412, "expected class bsLEZ to be size 4412");

// class bsCEW
// no dependencies
class bsCEW
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") bsCEW::mSetDamage(class bsCEW* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") bsCEW::mSetDamage(class bsCEW* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[4232];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsCEW>("bsCEW")
		.endClass();
	}
#endif
};
static_assert(sizeof(class bsCEW) == 4232, "expected class bsCEW to be size 4232");

// class bsAST
// no dependencies
class bsAST
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") bsAST::mSetDamage(class bsAST* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") bsAST::mSetDamage(class bsAST* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[4352];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsAST>("bsAST")
		.endClass();
	}
#endif
};
static_assert(sizeof(class bsAST) == 4352, "expected class bsAST to be size 4352");

// class bsRKT
// no dependencies
class bsRKT
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") bsRKT::mSetDamage(class bsRKT* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") bsRKT::mSetDamage(class bsRKT* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[4672];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsRKT>("bsRKT")
		.endClass();
	}
#endif
};
static_assert(sizeof(class bsRKT) == 4672, "expected class bsRKT to be size 4672");

// class KrBaseState<bsBasic>
// no dependencies
template<typename T>
class KrBaseState
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x7], offset 0x0>
	void* (* field_0)[0x7];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<KrBaseState<bsBasic>>("KrBaseState<bsBasic>")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &KrBaseState<bsBasic>::field_0)
		.endClass();
	}
#endif
};
static_assert(sizeof(KrBaseState<bsBasic>::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(class KrBaseState<bsBasic>) == 4, "expected class KrBaseState<bsBasic> to be size 4");

// class GLBDeathState
// 1 dependencies: class KrBaseState<pcGLB>
class GLBDeathState : KrBaseState<pcGLB>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <int32_t mExpCnt, offset 0x4>
	int32_t mExpCnt;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBDeathState>("GLBDeathState")
			.addProperty("mExpCnt", &GLBDeathState::mExpCnt)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBDeathState::mExpCnt) == 4, "expected mExpCnt to be size 4");
static_assert(sizeof(class GLBDeathState) == 8, "expected class GLBDeathState to be size 8");

// class GLBWalkState
// 1 dependencies: class KrBaseState<pcGLB>
class GLBWalkState : KrBaseState<pcGLB>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBWalkState>("GLBWalkState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class GLBWalkState) == 4, "expected class GLBWalkState to be size 4");

// class GLBComboState
// 1 dependencies: class KrBaseState<pcGLB>
class GLBComboState : KrBaseState<pcGLB>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <uint8_t mbCancel, offset 0x4>
	uint8_t mbCancel;

	// <Filler, offset 0x5>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBComboState>("GLBComboState")
			.addProperty("mbCancel", &GLBComboState::mbCancel)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBComboState::mbCancel) == 1, "expected mbCancel to be size 1");
static_assert(sizeof(class GLBComboState) == 8, "expected class GLBComboState to be size 8");

// class GLBIdleState
// 1 dependencies: class KrBaseState<pcGLB>
class GLBIdleState : KrBaseState<pcGLB>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBIdleState>("GLBIdleState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class GLBIdleState) == 4, "expected class GLBIdleState to be size 4");

// class GLBJampState
// 1 dependencies: class KrBaseState<pcGLB>
class GLBJampState : KrBaseState<pcGLB>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

	// <int32_t JumpTick, offset 0x4>
	int32_t JumpTick;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBJampState>("GLBJampState")
			.addProperty("JumpTick", &GLBJampState::JumpTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(GLBJampState::JumpTick) == 4, "expected JumpTick to be size 4");
static_assert(sizeof(class GLBJampState) == 8, "expected class GLBJampState to be size 8");

// class KrStateMachine<pcGLB,32>
// no dependencies
template<typename T1, int T2>
class KrStateMachine
{
public:
	/// No namespace types
	/// Struct member variables

	// <class pcGLB* mpOwner, offset 0x0>
	T1* mpOwner;

	// <int32_t mpCurrentIdx, offset 0x4>
	int32_t mpCurrentIdx;

	// <int32_t mpPreviousIdx, offset 0x8>
	int32_t mpPreviousIdx;

	// <int32_t mpGlobalIdx, offset 0xc>
	int32_t mpGlobalIdx;

	// <class KrBaseState<pcGLB>* mpState[0x20], offset 0x10>
	class KrBaseState<T1>* mpState[T2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<KrStateMachine<pcGLB,32>>("KrStateMachine<pcGLB,32>")
			.addProperty("mpOwner", &KrStateMachine<pcGLB,32>::mpOwner)
			.addProperty("mpCurrentIdx", &KrStateMachine<pcGLB,32>::mpCurrentIdx)
			.addProperty("mpPreviousIdx", &KrStateMachine<pcGLB,32>::mpPreviousIdx)
			.addProperty("mpGlobalIdx", &KrStateMachine<pcGLB,32>::mpGlobalIdx)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("mpState", &KrStateMachine<pcGLB,32>::mpState)
		.endClass();
	}
#endif
};
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpOwner) == 4, "expected mpOwner to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpCurrentIdx) == 4, "expected mpCurrentIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpPreviousIdx) == 4, "expected mpPreviousIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpGlobalIdx) == 4, "expected mpGlobalIdx to be size 4");
static_assert(sizeof(KrStateMachine<pcGLB,32>::mpState) == 128, "expected mpState to be size 128");
static_assert(sizeof(class KrStateMachine<pcGLB,32>) == 144, "expected class KrStateMachine<pcGLB,32> to be size 144");

// class rSideScrollCamera
// 1 dependencies: struct Vec
class rSideScrollCamera
{
public:
	/// No namespace types
	/// Struct member variables

	// <void* (* field_0)[0x1], offset 0x0>
	void* (* field_0)[0x1];

	// <struct Vec mPos, offset 0x4>
	struct Vec mPos;

	// <struct Vec mTarget, offset 0x10>
	struct Vec mTarget;

	// <float mInterpolateSpd, offset 0x1c>
	float mInterpolateSpd;

	// <float mPosDist, offset 0x20>
	float mPosDist;

	// <float mXAngle, offset 0x24>
	float mXAngle;

	// <float mYAngle, offset 0x28>
	float mYAngle;

	// <float mAdjustYAngle, offset 0x2c>
	float mAdjustYAngle;

	// <uint8_t mbZoom, offset 0x30>
	uint8_t mbZoom;

	// <Filler, offset 0x31>
	char _Filler9[3];

	// <float mZoomDist, offset 0x34>
	float mZoomDist;

	// <float mZoomSpeed, offset 0x38>
	float mZoomSpeed;

	// <struct Vec mZoomDirec, offset 0x3c>
	struct Vec mZoomDirec;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<rSideScrollCamera>("rSideScrollCamera")
			// delegates are not supported in LuaBridge
			//.addProperty("field_0", &rSideScrollCamera::field_0)
			.addProperty("mPos", &rSideScrollCamera::mPos)
			.addProperty("mTarget", &rSideScrollCamera::mTarget)
			.addProperty("mInterpolateSpd", &rSideScrollCamera::mInterpolateSpd)
			.addProperty("mPosDist", &rSideScrollCamera::mPosDist)
			.addProperty("mXAngle", &rSideScrollCamera::mXAngle)
			.addProperty("mYAngle", &rSideScrollCamera::mYAngle)
			.addProperty("mAdjustYAngle", &rSideScrollCamera::mAdjustYAngle)
			.addProperty("mbZoom", &rSideScrollCamera::mbZoom)
			.addProperty("mZoomDist", &rSideScrollCamera::mZoomDist)
			.addProperty("mZoomSpeed", &rSideScrollCamera::mZoomSpeed)
			.addProperty("mZoomDirec", &rSideScrollCamera::mZoomDirec)
		.endClass();
	}
#endif
};
static_assert(sizeof(rSideScrollCamera::field_0) == 4, "expected field_0 to be size 4");
static_assert(sizeof(rSideScrollCamera::mPos) == 12, "expected mPos to be size 12");
static_assert(sizeof(rSideScrollCamera::mTarget) == 12, "expected mTarget to be size 12");
static_assert(sizeof(rSideScrollCamera::mInterpolateSpd) == 4, "expected mInterpolateSpd to be size 4");
static_assert(sizeof(rSideScrollCamera::mPosDist) == 4, "expected mPosDist to be size 4");
static_assert(sizeof(rSideScrollCamera::mXAngle) == 4, "expected mXAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mYAngle) == 4, "expected mYAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mAdjustYAngle) == 4, "expected mAdjustYAngle to be size 4");
static_assert(sizeof(rSideScrollCamera::mbZoom) == 1, "expected mbZoom to be size 1");
static_assert(sizeof(rSideScrollCamera::mZoomDist) == 4, "expected mZoomDist to be size 4");
static_assert(sizeof(rSideScrollCamera::mZoomSpeed) == 4, "expected mZoomSpeed to be size 4");
static_assert(sizeof(rSideScrollCamera::mZoomDirec) == 12, "expected mZoomDirec to be size 12");
static_assert(sizeof(class rSideScrollCamera) == 72, "expected class rSideScrollCamera to be size 72");

// class GLBDamageState
// 1 dependencies: class KrBaseState<pcGLB>
class GLBDamageState : KrBaseState<pcGLB>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBDamageState>("GLBDamageState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class GLBDamageState) == 4, "expected class GLBDamageState to be size 4");

// class GLBGuardState
// 1 dependencies: class KrBaseState<pcGLB>
class GLBGuardState : KrBaseState<pcGLB>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBGuardState>("GLBGuardState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class GLBGuardState) == 4, "expected class GLBGuardState to be size 4");

// class GLBAirKickState
// 1 dependencies: class KrBaseState<pcGLB>
class GLBAirKickState : KrBaseState<pcGLB>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<pcGLB> field_0, offset 0x0>
	// class KrBaseState<pcGLB> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<GLBAirKickState>("GLBAirKickState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class GLBAirKickState) == 4, "expected class GLBAirKickState to be size 4");

// class pcGLB
// 40 dependencies: class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class rSideScrollCamera, class KrStateMachine<pcGLB,32>, class GLBIdleState, class KrBaseState<pcGLB>, class GLBWalkState, class GLBJampState, class GLBDamageState, class GLBGuardState, class GLBComboState, class GLBAirKickState, class GLBDeathState, struct pcGLB::DmgInfo, struct pcGLB::TickCnt, enum pcGLB::MiniDemoEnum
class pcGLB : mHRChara
{
public:
	/// 6 namespace types: uint8_t __convention("thiscall") pcGLB::IsAtkObj(class pcGLB* const this, class mHRChara* arg2), struct pcGLB::DmgInfo, struct pcGLB::TickCnt, enum pcGLB::MiniDemoEnum, void __convention("thiscall") pcGLB::SetDamageIK(class pcGLB* const this, class mHRChara* arg2, uint8_t arg3), uint8_t __convention("thiscall") pcGLB::mSetDamage(class pcGLB* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") pcGLB::IsAtkObj(class pcGLB* const this, class mHRChara* arg2)'
	// struct pcGLB::DmgInfo
	// no dependencies
	struct DmgInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint32_t Kind, offset 0x0>
		uint32_t Kind;

		// <uint32_t DirecKind, offset 0x4>
		uint32_t DirecKind;

		// <float Direc, offset 0x8>
		float Direc;

		// <uint32_t FinishHitNum, offset 0xc>
		uint32_t FinishHitNum;

		// <uint32_t DownFinishHitMax, offset 0x10>
		uint32_t DownFinishHitMax;

		// <float AccumuAmount, offset 0x14>
		float AccumuAmount;

		// <float AccumuMax, offset 0x18>
		float AccumuMax;

		// <float AccumuRecovery, offset 0x1c>
		float AccumuRecovery;

		// <float GroggyAmount, offset 0x20>
		float GroggyAmount;

		// <float GroggyMax, offset 0x24>
		float GroggyMax;

		// <float GroggyRecovery, offset 0x28>
		float GroggyRecovery;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<pcGLB::DmgInfo>("pcGLB::DmgInfo")
				.addProperty("Kind", &pcGLB::DmgInfo::Kind)
				.addProperty("DirecKind", &pcGLB::DmgInfo::DirecKind)
				.addProperty("Direc", &pcGLB::DmgInfo::Direc)
				.addProperty("FinishHitNum", &pcGLB::DmgInfo::FinishHitNum)
				.addProperty("DownFinishHitMax", &pcGLB::DmgInfo::DownFinishHitMax)
				.addProperty("AccumuAmount", &pcGLB::DmgInfo::AccumuAmount)
				.addProperty("AccumuMax", &pcGLB::DmgInfo::AccumuMax)
				.addProperty("AccumuRecovery", &pcGLB::DmgInfo::AccumuRecovery)
				.addProperty("GroggyAmount", &pcGLB::DmgInfo::GroggyAmount)
				.addProperty("GroggyMax", &pcGLB::DmgInfo::GroggyMax)
				.addProperty("GroggyRecovery", &pcGLB::DmgInfo::GroggyRecovery)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(pcGLB::DmgInfo::Kind) == 4, "expected Kind to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::DirecKind) == 4, "expected DirecKind to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::Direc) == 4, "expected Direc to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::FinishHitNum) == 4, "expected FinishHitNum to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::DownFinishHitMax) == 4, "expected DownFinishHitMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuAmount) == 4, "expected AccumuAmount to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuMax) == 4, "expected AccumuMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::AccumuRecovery) == 4, "expected AccumuRecovery to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyAmount) == 4, "expected GroggyAmount to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyMax) == 4, "expected GroggyMax to be size 4");
	static_assert(sizeof(pcGLB::DmgInfo::GroggyRecovery) == 4, "expected GroggyRecovery to be size 4");
	static_assert(sizeof(struct pcGLB::DmgInfo) == 44, "expected struct pcGLB::DmgInfo to be size 44");

	// struct pcGLB::TickCnt
	// no dependencies
	struct TickCnt
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t Motion, offset 0x0>
		int32_t Motion;

		// <int32_t AtkWait, offset 0x4>
		int32_t AtkWait;

		// <int32_t Loop, offset 0x8>
		int32_t Loop;

		// <int32_t State, offset 0xc>
		int32_t State;

		// <int32_t DmgWait, offset 0x10>
		int32_t DmgWait;

		// <int32_t DmgPlayAccept, offset 0x14>
		int32_t DmgPlayAccept;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<pcGLB::TickCnt>("pcGLB::TickCnt")
				.addProperty("Motion", &pcGLB::TickCnt::Motion)
				.addProperty("AtkWait", &pcGLB::TickCnt::AtkWait)
				.addProperty("Loop", &pcGLB::TickCnt::Loop)
				.addProperty("State", &pcGLB::TickCnt::State)
				.addProperty("DmgWait", &pcGLB::TickCnt::DmgWait)
				.addProperty("DmgPlayAccept", &pcGLB::TickCnt::DmgPlayAccept)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(pcGLB::TickCnt::Motion) == 4, "expected Motion to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::AtkWait) == 4, "expected AtkWait to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::Loop) == 4, "expected Loop to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::State) == 4, "expected State to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::DmgWait) == 4, "expected DmgWait to be size 4");
	static_assert(sizeof(pcGLB::TickCnt::DmgPlayAccept) == 4, "expected DmgPlayAccept to be size 4");
	static_assert(sizeof(struct pcGLB::TickCnt) == 24, "expected struct pcGLB::TickCnt to be size 24");

	// enum pcGLB::MiniDemoEnum
	enum MiniDemoEnum : uint32_t
	{
		// Enum values

		// <MD_Init = 0xffffffffffffffff>
		MD_Init = UINT32_MAX,

		// <MD_Strawberry = 0x0>
		MD_Strawberry = 0,

		// <MD_London = 0x1>
		MD_London = 1,

		// <MD_Ragvy = 0x2>
		MD_Ragvy = 2

	};

	// TODO: Function 'void __convention("thiscall") pcGLB::SetDamageIK(class pcGLB* const this, class mHRChara* arg2, uint8_t arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") pcGLB::mSetDamage(class pcGLB* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <uint8_t mCanOperate, offset 0x580>
	uint8_t mCanOperate;

	// <uint8_t mTestOnCanOperate, offset 0x581>
	uint8_t mTestOnCanOperate;

	// <Filler, offset 0x582>
	char _Filler3[2];

	// <class rSideScrollCamera mSideCamera, offset 0x584>
	class rSideScrollCamera mSideCamera;

	// <class EfRoboInterface* mpInterface, offset 0x5cc>
	class EfRoboInterface* mpInterface;

	// <class bsSDP* mpSDP, offset 0x5d0>
	class bsSDP* mpSDP;

	// <class KrStateMachine<pcGLB,32> mStateMachine, offset 0x5d4>
	class KrStateMachine<pcGLB,32> mStateMachine;

	// <class GLBIdleState mIdleState, offset 0x664>
	class GLBIdleState mIdleState;

	// <class GLBWalkState mWalkState, offset 0x668>
	class GLBWalkState mWalkState;

	// <class GLBJampState mJampState, offset 0x66c>
	class GLBJampState mJampState;

	// <class GLBDamageState mDamageState, offset 0x674>
	class GLBDamageState mDamageState;

	// <class GLBGuardState mGuardState, offset 0x678>
	class GLBGuardState mGuardState;

	// <class GLBComboState mComboState, offset 0x67c>
	class GLBComboState mComboState;

	// <class GLBAirKickState mAirKickState, offset 0x684>
	class GLBAirKickState mAirKickState;

	// <class GLBDeathState mDeathState, offset 0x688>
	class GLBDeathState mDeathState;

	// <struct pcGLB::DmgInfo mDmgInfo, offset 0x690>
	struct pcGLB::DmgInfo mDmgInfo;

	// <struct pcGLB::TickCnt mTickCnt, offset 0x6bc>
	struct pcGLB::TickCnt mTickCnt;

	// <float mAirY, offset 0x6d4>
	float mAirY;

	// <float mAirPower, offset 0x6d8>
	float mAirPower;

	// <uint8_t mbAir, offset 0x6dc>
	uint8_t mbAir;

	// <Filler, offset 0x6dd>
	char _Filler20[3];

	// <float mTension, offset 0x6e0>
	float mTension;

	// <struct Vec mBefPos, offset 0x6e4>
	struct Vec mBefPos;

	// <enum pcGLB::MiniDemoEnum mMDemoNo, offset 0x6f0>
	enum pcGLB::MiniDemoEnum mMDemoNo;

	// <int32_t mPhase, offset 0x6f4>
	int32_t mPhase;

	// <uint32_t mBeamColor, offset 0x6f8>
	uint32_t mBeamColor;

	// <uint8_t mbDemoWait, offset 0x6fc>
	uint8_t mbDemoWait;

	// <Filler, offset 0x6fd>
	char _Filler26[3];

	// <class TGmfNode* mpWristLNode, offset 0x700>
	class TGmfNode* mpWristLNode;

	// <class EffectModelBeam* mpWepBeam, offset 0x704>
	class EffectModelBeam* mpWepBeam;

	// <uint8_t mbCanKick, offset 0x708>
	uint8_t mbCanKick;

	// <Filler, offset 0x709>
	char _Filler29[3];

	// <int32_t mhVernierSE, offset 0x70c>
	int32_t mhVernierSE;

	// <int32_t mMDFlag, offset 0x710>
	int32_t mMDFlag;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<pcGLB>("pcGLB")
			.addProperty("mCanOperate", &pcGLB::mCanOperate)
			.addProperty("mTestOnCanOperate", &pcGLB::mTestOnCanOperate)
			.addProperty("mSideCamera", &pcGLB::mSideCamera)
			.addProperty("mpInterface", &pcGLB::mpInterface)
			.addProperty("mpSDP", &pcGLB::mpSDP)
			.addProperty("mStateMachine", &pcGLB::mStateMachine)
			.addProperty("mIdleState", &pcGLB::mIdleState)
			.addProperty("mWalkState", &pcGLB::mWalkState)
			.addProperty("mJampState", &pcGLB::mJampState)
			.addProperty("mDamageState", &pcGLB::mDamageState)
			.addProperty("mGuardState", &pcGLB::mGuardState)
			.addProperty("mComboState", &pcGLB::mComboState)
			.addProperty("mAirKickState", &pcGLB::mAirKickState)
			.addProperty("mDeathState", &pcGLB::mDeathState)
			.addProperty("mDmgInfo", &pcGLB::mDmgInfo)
			.addProperty("mTickCnt", &pcGLB::mTickCnt)
			.addProperty("mAirY", &pcGLB::mAirY)
			.addProperty("mAirPower", &pcGLB::mAirPower)
			.addProperty("mbAir", &pcGLB::mbAir)
			.addProperty("mTension", &pcGLB::mTension)
			.addProperty("mBefPos", &pcGLB::mBefPos)
			.addProperty("mMDemoNo", &pcGLB::mMDemoNo)
			.addProperty("mPhase", &pcGLB::mPhase)
			.addProperty("mBeamColor", &pcGLB::mBeamColor)
			.addProperty("mbDemoWait", &pcGLB::mbDemoWait)
			.addProperty("mpWristLNode", &pcGLB::mpWristLNode)
			.addProperty("mpWepBeam", &pcGLB::mpWepBeam)
			.addProperty("mbCanKick", &pcGLB::mbCanKick)
			.addProperty("mhVernierSE", &pcGLB::mhVernierSE)
			.addProperty("mMDFlag", &pcGLB::mMDFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(pcGLB::mCanOperate) == 1, "expected mCanOperate to be size 1");
static_assert(sizeof(pcGLB::mTestOnCanOperate) == 1, "expected mTestOnCanOperate to be size 1");
static_assert(sizeof(pcGLB::mSideCamera) == 72, "expected mSideCamera to be size 72");
static_assert(sizeof(pcGLB::mpInterface) == 4, "expected mpInterface to be size 4");
static_assert(sizeof(pcGLB::mpSDP) == 4, "expected mpSDP to be size 4");
static_assert(sizeof(pcGLB::mStateMachine) == 144, "expected mStateMachine to be size 144");
static_assert(sizeof(pcGLB::mIdleState) == 4, "expected mIdleState to be size 4");
static_assert(sizeof(pcGLB::mWalkState) == 4, "expected mWalkState to be size 4");
static_assert(sizeof(pcGLB::mJampState) == 8, "expected mJampState to be size 8");
static_assert(sizeof(pcGLB::mDamageState) == 4, "expected mDamageState to be size 4");
static_assert(sizeof(pcGLB::mGuardState) == 4, "expected mGuardState to be size 4");
static_assert(sizeof(pcGLB::mComboState) == 8, "expected mComboState to be size 8");
static_assert(sizeof(pcGLB::mAirKickState) == 4, "expected mAirKickState to be size 4");
static_assert(sizeof(pcGLB::mDeathState) == 8, "expected mDeathState to be size 8");
static_assert(sizeof(pcGLB::mDmgInfo) == 44, "expected mDmgInfo to be size 44");
static_assert(sizeof(pcGLB::mTickCnt) == 24, "expected mTickCnt to be size 24");
static_assert(sizeof(pcGLB::mAirY) == 4, "expected mAirY to be size 4");
static_assert(sizeof(pcGLB::mAirPower) == 4, "expected mAirPower to be size 4");
static_assert(sizeof(pcGLB::mbAir) == 1, "expected mbAir to be size 1");
static_assert(sizeof(pcGLB::mTension) == 4, "expected mTension to be size 4");
static_assert(sizeof(pcGLB::mBefPos) == 12, "expected mBefPos to be size 12");
static_assert(sizeof(pcGLB::mMDemoNo) == 4, "expected mMDemoNo to be size 4");
static_assert(sizeof(pcGLB::mPhase) == 4, "expected mPhase to be size 4");
static_assert(sizeof(pcGLB::mBeamColor) == 4, "expected mBeamColor to be size 4");
static_assert(sizeof(pcGLB::mbDemoWait) == 1, "expected mbDemoWait to be size 1");
static_assert(sizeof(pcGLB::mpWristLNode) == 4, "expected mpWristLNode to be size 4");
static_assert(sizeof(pcGLB::mpWepBeam) == 4, "expected mpWepBeam to be size 4");
static_assert(sizeof(pcGLB::mbCanKick) == 1, "expected mbCanKick to be size 1");
static_assert(sizeof(pcGLB::mhVernierSE) == 4, "expected mhVernierSE to be size 4");
static_assert(sizeof(pcGLB::mMDFlag) == 4, "expected mMDFlag to be size 4");
static_assert(sizeof(class pcGLB) == 1812, "expected class pcGLB to be size 1812");

// class EfRoboInterface
// 9 dependencies: class HrTask, class EfBase, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, enum EfRoboInterface::InterfaceState
class EfRoboInterface : HrTask
{
public:
	/// 1 namespace types: enum EfRoboInterface::InterfaceState

	// enum EfRoboInterface::InterfaceState
	enum InterfaceState : uint32_t
	{
		// Enum values

		// <State_Init = 0x0>
		State_Init = 0,

		// <State_FadeIn = 0x1>
		State_FadeIn = 1,

		// <State_Active = 0x2>
		State_Active = 2,

		// <State_FadeOut = 0x3>
		State_FadeOut = 3

	};


	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class EfBase field_50, offset 0x50>
	class EfBase field_50;

	// <class EffectSpeedBlur* mpBlur, offset 0x68>
	class EffectSpeedBlur* mpBlur;

	// <struct tagGHMR_TEX mInputCZTex, offset 0x6c>
	struct tagGHMR_TEX mInputCZTex;

	// <struct tagGHMR_TEX mInputLineTex, offset 0x94>
	struct tagGHMR_TEX mInputLineTex;

	// <struct tagGHMR_TEX mPcHpFrameTex, offset 0xbc>
	struct tagGHMR_TEX mPcHpFrameTex;

	// <struct tagGHMR_TEX mEnemyHpFrameTex, offset 0xe4>
	struct tagGHMR_TEX mEnemyHpFrameTex;

	// <struct tagGHMR_TEX mHpTex, offset 0x10c>
	struct tagGHMR_TEX mHpTex;

	// <struct tagGHMR_TEX mFrameDamageTex, offset 0x134>
	struct tagGHMR_TEX mFrameDamageTex;

	// <struct tagGHMR_TEX mFrameTrvDmgTex, offset 0x15c>
	struct tagGHMR_TEX mFrameTrvDmgTex;

	// <struct tagGHMR_TEX mFrameSdpDmgTex, offset 0x184>
	struct tagGHMR_TEX mFrameSdpDmgTex;

	// <struct tagGHMR_TEX mFrameNoiseTex, offset 0x1ac>
	struct tagGHMR_TEX mFrameNoiseTex;

	// <struct tagGHMR_TEX mPcTensionFrameTex, offset 0x1d4>
	struct tagGHMR_TEX mPcTensionFrameTex;

	// <struct tagGHMR_TEX mEnemyTensionFrameTex, offset 0x1fc>
	struct tagGHMR_TEX mEnemyTensionFrameTex;

	// <struct tagGHMR_TEX mTensionTex, offset 0x224>
	struct tagGHMR_TEX mTensionTex;

	// <struct tagGHMR_TEX mPcTensionMaxTex, offset 0x24c>
	struct tagGHMR_TEX mPcTensionMaxTex;

	// <struct tagGHMR_TEX mEnemeyTensionMaxTex, offset 0x274>
	struct tagGHMR_TEX mEnemeyTensionMaxTex;

	// <struct tagGHMR_TEX mLTigerTex, offset 0x29c>
	struct tagGHMR_TEX mLTigerTex;

	// <struct tagGHMR_TEX mLBackTex, offset 0x2c4>
	struct tagGHMR_TEX mLBackTex;

	// <struct tagGHMR_TEX mRTigerTex, offset 0x2ec>
	struct tagGHMR_TEX mRTigerTex;

	// <struct tagGHMR_TEX mRBackTex, offset 0x314>
	struct tagGHMR_TEX mRBackTex;

	// <enum EfRoboInterface::InterfaceState mInputCState, offset 0x33c>
	enum EfRoboInterface::InterfaceState mInputCState;

	// <float mInputCSlide, offset 0x340>
	float mInputCSlide;

	// <uint8_t mbInputCVisble, offset 0x344>
	uint8_t mbInputCVisble;

	// <Filler, offset 0x345>
	char _Filler24[3];

	// <float mInputCAlpha, offset 0x348>
	float mInputCAlpha;

	// <enum EfRoboInterface::InterfaceState mBlackState, offset 0x34c>
	enum EfRoboInterface::InterfaceState mBlackState;

	// <float mBlackAlpha, offset 0x350>
	float mBlackAlpha;

	// <enum EfRoboInterface::InterfaceState mPcFlashState, offset 0x354>
	enum EfRoboInterface::InterfaceState mPcFlashState;

	// <int32_t mPcFlashAnimeCnt, offset 0x358>
	int32_t mPcFlashAnimeCnt;

	// <int32_t mPcFlashCnt, offset 0x35c>
	int32_t mPcFlashCnt;

	// <float mPcFlashAlpha, offset 0x360>
	float mPcFlashAlpha;

	// <enum EfRoboInterface::InterfaceState mEnemyFlashState, offset 0x364>
	enum EfRoboInterface::InterfaceState mEnemyFlashState;

	// <int32_t mEnemyFlashAnimeCnt, offset 0x368>
	int32_t mEnemyFlashAnimeCnt;

	// <int32_t mEnemyFlashCnt, offset 0x36c>
	int32_t mEnemyFlashCnt;

	// <float mEnemyFlashAlpha, offset 0x370>
	float mEnemyFlashAlpha;

	// <float mPcHpRate, offset 0x374>
	float mPcHpRate;

	// <float mPcHpRateTarget, offset 0x378>
	float mPcHpRateTarget;

	// <float mBefPcHpRateTarget, offset 0x37c>
	float mBefPcHpRateTarget;

	// <float mPcDmgSubRate, offset 0x380>
	float mPcDmgSubRate;

	// <float mEnemyHpRate, offset 0x384>
	float mEnemyHpRate;

	// <float mEnemyHpRateTarget, offset 0x388>
	float mEnemyHpRateTarget;

	// <float mBefEnemyHpRateTarget, offset 0x38c>
	float mBefEnemyHpRateTarget;

	// <float mEnemyDmgSubRate, offset 0x390>
	float mEnemyDmgSubRate;

	// <float mPcHpWait, offset 0x394>
	float mPcHpWait;

	// <float mEnemyHpWait, offset 0x398>
	float mEnemyHpWait;

	// <float mPcTensionRate, offset 0x39c>
	float mPcTensionRate;

	// <float mPcTensionRateTarget, offset 0x3a0>
	float mPcTensionRateTarget;

	// <float mEnemyTensionRate, offset 0x3a4>
	float mEnemyTensionRate;

	// <float mEnemyTensionRateTarget, offset 0x3a8>
	float mEnemyTensionRateTarget;

	// <float mTensionSlide, offset 0x3ac>
	float mTensionSlide;

	// <uint8_t mbPcMaxVisible, offset 0x3b0>
	uint8_t mbPcMaxVisible;

	// <uint8_t mbEnemyMaxVisible, offset 0x3b1>
	uint8_t mbEnemyMaxVisible;

	// <Filler, offset 0x3b2>
	char _Filler52[2];

	// <uint32_t mDmgAnimeCnt, offset 0x3b4>
	uint32_t mDmgAnimeCnt;

	// <uint8_t mbFinish, offset 0x3b8>
	uint8_t mbFinish;

	// <Filler, offset 0x3b9>
	char _Filler54[3];

	// <float mBlurAlpha, offset 0x3bc>
	float mBlurAlpha;

	// <uint8_t mBlurValid, offset 0x3c0>
	uint8_t mBlurValid;

	// <Filler, offset 0x3c1>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfRoboInterface>("EfRoboInterface")
			.addProperty("field_50", &EfRoboInterface::field_50)
			.addProperty("mpBlur", &EfRoboInterface::mpBlur)
			.addProperty("mInputCZTex", &EfRoboInterface::mInputCZTex)
			.addProperty("mInputLineTex", &EfRoboInterface::mInputLineTex)
			.addProperty("mPcHpFrameTex", &EfRoboInterface::mPcHpFrameTex)
			.addProperty("mEnemyHpFrameTex", &EfRoboInterface::mEnemyHpFrameTex)
			.addProperty("mHpTex", &EfRoboInterface::mHpTex)
			.addProperty("mFrameDamageTex", &EfRoboInterface::mFrameDamageTex)
			.addProperty("mFrameTrvDmgTex", &EfRoboInterface::mFrameTrvDmgTex)
			.addProperty("mFrameSdpDmgTex", &EfRoboInterface::mFrameSdpDmgTex)
			.addProperty("mFrameNoiseTex", &EfRoboInterface::mFrameNoiseTex)
			.addProperty("mPcTensionFrameTex", &EfRoboInterface::mPcTensionFrameTex)
			.addProperty("mEnemyTensionFrameTex", &EfRoboInterface::mEnemyTensionFrameTex)
			.addProperty("mTensionTex", &EfRoboInterface::mTensionTex)
			.addProperty("mPcTensionMaxTex", &EfRoboInterface::mPcTensionMaxTex)
			.addProperty("mEnemeyTensionMaxTex", &EfRoboInterface::mEnemeyTensionMaxTex)
			.addProperty("mLTigerTex", &EfRoboInterface::mLTigerTex)
			.addProperty("mLBackTex", &EfRoboInterface::mLBackTex)
			.addProperty("mRTigerTex", &EfRoboInterface::mRTigerTex)
			.addProperty("mRBackTex", &EfRoboInterface::mRBackTex)
			.addProperty("mInputCState", &EfRoboInterface::mInputCState)
			.addProperty("mInputCSlide", &EfRoboInterface::mInputCSlide)
			.addProperty("mbInputCVisble", &EfRoboInterface::mbInputCVisble)
			.addProperty("mInputCAlpha", &EfRoboInterface::mInputCAlpha)
			.addProperty("mBlackState", &EfRoboInterface::mBlackState)
			.addProperty("mBlackAlpha", &EfRoboInterface::mBlackAlpha)
			.addProperty("mPcFlashState", &EfRoboInterface::mPcFlashState)
			.addProperty("mPcFlashAnimeCnt", &EfRoboInterface::mPcFlashAnimeCnt)
			.addProperty("mPcFlashCnt", &EfRoboInterface::mPcFlashCnt)
			.addProperty("mPcFlashAlpha", &EfRoboInterface::mPcFlashAlpha)
			.addProperty("mEnemyFlashState", &EfRoboInterface::mEnemyFlashState)
			.addProperty("mEnemyFlashAnimeCnt", &EfRoboInterface::mEnemyFlashAnimeCnt)
			.addProperty("mEnemyFlashCnt", &EfRoboInterface::mEnemyFlashCnt)
			.addProperty("mEnemyFlashAlpha", &EfRoboInterface::mEnemyFlashAlpha)
			.addProperty("mPcHpRate", &EfRoboInterface::mPcHpRate)
			.addProperty("mPcHpRateTarget", &EfRoboInterface::mPcHpRateTarget)
			.addProperty("mBefPcHpRateTarget", &EfRoboInterface::mBefPcHpRateTarget)
			.addProperty("mPcDmgSubRate", &EfRoboInterface::mPcDmgSubRate)
			.addProperty("mEnemyHpRate", &EfRoboInterface::mEnemyHpRate)
			.addProperty("mEnemyHpRateTarget", &EfRoboInterface::mEnemyHpRateTarget)
			.addProperty("mBefEnemyHpRateTarget", &EfRoboInterface::mBefEnemyHpRateTarget)
			.addProperty("mEnemyDmgSubRate", &EfRoboInterface::mEnemyDmgSubRate)
			.addProperty("mPcHpWait", &EfRoboInterface::mPcHpWait)
			.addProperty("mEnemyHpWait", &EfRoboInterface::mEnemyHpWait)
			.addProperty("mPcTensionRate", &EfRoboInterface::mPcTensionRate)
			.addProperty("mPcTensionRateTarget", &EfRoboInterface::mPcTensionRateTarget)
			.addProperty("mEnemyTensionRate", &EfRoboInterface::mEnemyTensionRate)
			.addProperty("mEnemyTensionRateTarget", &EfRoboInterface::mEnemyTensionRateTarget)
			.addProperty("mTensionSlide", &EfRoboInterface::mTensionSlide)
			.addProperty("mbPcMaxVisible", &EfRoboInterface::mbPcMaxVisible)
			.addProperty("mbEnemyMaxVisible", &EfRoboInterface::mbEnemyMaxVisible)
			.addProperty("mDmgAnimeCnt", &EfRoboInterface::mDmgAnimeCnt)
			.addProperty("mbFinish", &EfRoboInterface::mbFinish)
			.addProperty("mBlurAlpha", &EfRoboInterface::mBlurAlpha)
			.addProperty("mBlurValid", &EfRoboInterface::mBlurValid)
		.endClass();
	}
#endif
};
static_assert(sizeof(EfRoboInterface::field_50) == 24, "expected field_50 to be size 24");
static_assert(sizeof(EfRoboInterface::mpBlur) == 4, "expected mpBlur to be size 4");
static_assert(sizeof(EfRoboInterface::mInputCZTex) == 40, "expected mInputCZTex to be size 40");
static_assert(sizeof(EfRoboInterface::mInputLineTex) == 40, "expected mInputLineTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcHpFrameTex) == 40, "expected mPcHpFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemyHpFrameTex) == 40, "expected mEnemyHpFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mHpTex) == 40, "expected mHpTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameDamageTex) == 40, "expected mFrameDamageTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameTrvDmgTex) == 40, "expected mFrameTrvDmgTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameSdpDmgTex) == 40, "expected mFrameSdpDmgTex to be size 40");
static_assert(sizeof(EfRoboInterface::mFrameNoiseTex) == 40, "expected mFrameNoiseTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcTensionFrameTex) == 40, "expected mPcTensionFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemyTensionFrameTex) == 40, "expected mEnemyTensionFrameTex to be size 40");
static_assert(sizeof(EfRoboInterface::mTensionTex) == 40, "expected mTensionTex to be size 40");
static_assert(sizeof(EfRoboInterface::mPcTensionMaxTex) == 40, "expected mPcTensionMaxTex to be size 40");
static_assert(sizeof(EfRoboInterface::mEnemeyTensionMaxTex) == 40, "expected mEnemeyTensionMaxTex to be size 40");
static_assert(sizeof(EfRoboInterface::mLTigerTex) == 40, "expected mLTigerTex to be size 40");
static_assert(sizeof(EfRoboInterface::mLBackTex) == 40, "expected mLBackTex to be size 40");
static_assert(sizeof(EfRoboInterface::mRTigerTex) == 40, "expected mRTigerTex to be size 40");
static_assert(sizeof(EfRoboInterface::mRBackTex) == 40, "expected mRBackTex to be size 40");
static_assert(sizeof(EfRoboInterface::mInputCState) == 4, "expected mInputCState to be size 4");
static_assert(sizeof(EfRoboInterface::mInputCSlide) == 4, "expected mInputCSlide to be size 4");
static_assert(sizeof(EfRoboInterface::mbInputCVisble) == 1, "expected mbInputCVisble to be size 1");
static_assert(sizeof(EfRoboInterface::mInputCAlpha) == 4, "expected mInputCAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mBlackState) == 4, "expected mBlackState to be size 4");
static_assert(sizeof(EfRoboInterface::mBlackAlpha) == 4, "expected mBlackAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashState) == 4, "expected mPcFlashState to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashAnimeCnt) == 4, "expected mPcFlashAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashCnt) == 4, "expected mPcFlashCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mPcFlashAlpha) == 4, "expected mPcFlashAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashState) == 4, "expected mEnemyFlashState to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashAnimeCnt) == 4, "expected mEnemyFlashAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashCnt) == 4, "expected mEnemyFlashCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyFlashAlpha) == 4, "expected mEnemyFlashAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpRate) == 4, "expected mPcHpRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpRateTarget) == 4, "expected mPcHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mBefPcHpRateTarget) == 4, "expected mBefPcHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mPcDmgSubRate) == 4, "expected mPcDmgSubRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpRate) == 4, "expected mEnemyHpRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpRateTarget) == 4, "expected mEnemyHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mBefEnemyHpRateTarget) == 4, "expected mBefEnemyHpRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyDmgSubRate) == 4, "expected mEnemyDmgSubRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcHpWait) == 4, "expected mPcHpWait to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyHpWait) == 4, "expected mEnemyHpWait to be size 4");
static_assert(sizeof(EfRoboInterface::mPcTensionRate) == 4, "expected mPcTensionRate to be size 4");
static_assert(sizeof(EfRoboInterface::mPcTensionRateTarget) == 4, "expected mPcTensionRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyTensionRate) == 4, "expected mEnemyTensionRate to be size 4");
static_assert(sizeof(EfRoboInterface::mEnemyTensionRateTarget) == 4, "expected mEnemyTensionRateTarget to be size 4");
static_assert(sizeof(EfRoboInterface::mTensionSlide) == 4, "expected mTensionSlide to be size 4");
static_assert(sizeof(EfRoboInterface::mbPcMaxVisible) == 1, "expected mbPcMaxVisible to be size 1");
static_assert(sizeof(EfRoboInterface::mbEnemyMaxVisible) == 1, "expected mbEnemyMaxVisible to be size 1");
static_assert(sizeof(EfRoboInterface::mDmgAnimeCnt) == 4, "expected mDmgAnimeCnt to be size 4");
static_assert(sizeof(EfRoboInterface::mbFinish) == 1, "expected mbFinish to be size 1");
static_assert(sizeof(EfRoboInterface::mBlurAlpha) == 4, "expected mBlurAlpha to be size 4");
static_assert(sizeof(EfRoboInterface::mBlurValid) == 1, "expected mBlurValid to be size 1");
static_assert(sizeof(class EfRoboInterface) == 964, "expected class EfRoboInterface to be size 964");

// class EffectSpeedBlur
// 1 dependencies: class HrTask
class EffectSpeedBlur : HrTask
{
public:
	/// No namespace types
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <uint8_t m_Flag, offset 0x50>
	uint8_t m_Flag;

	// <Filler, offset 0x51>
	char _Filler2[3];

	// <float m_BlurValue, offset 0x54>
	float m_BlurValue;

	// <float m_Scale, offset 0x58>
	float m_Scale;

	// <int32_t m_RepNum, offset 0x5c>
	int32_t m_RepNum;

	// <uint8_t m_Wait, offset 0x60>
	uint8_t m_Wait;

	// <Filler, offset 0x61>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectSpeedBlur>("EffectSpeedBlur")
			.addProperty("m_Flag", &EffectSpeedBlur::m_Flag)
			.addProperty("m_BlurValue", &EffectSpeedBlur::m_BlurValue)
			.addProperty("m_Scale", &EffectSpeedBlur::m_Scale)
			.addProperty("m_RepNum", &EffectSpeedBlur::m_RepNum)
			.addProperty("m_Wait", &EffectSpeedBlur::m_Wait)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSpeedBlur::m_Flag) == 1, "expected m_Flag to be size 1");
static_assert(sizeof(EffectSpeedBlur::m_BlurValue) == 4, "expected m_BlurValue to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_Scale) == 4, "expected m_Scale to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_RepNum) == 4, "expected m_RepNum to be size 4");
static_assert(sizeof(EffectSpeedBlur::m_Wait) == 1, "expected m_Wait to be size 1");
static_assert(sizeof(class EffectSpeedBlur) == 100, "expected class EffectSpeedBlur to be size 100");

// class CmDeathState
// 1 dependencies: class KrBaseState<bsBasic>
class CmDeathState : KrBaseState<bsBasic>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <uint8_t mbDeadScriptCall, offset 0x4>
	uint8_t mbDeadScriptCall;

	// <Filler, offset 0x5>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmDeathState>("CmDeathState")
			.addProperty("mbDeadScriptCall", &CmDeathState::mbDeadScriptCall)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmDeathState::mbDeadScriptCall) == 1, "expected mbDeadScriptCall to be size 1");
static_assert(sizeof(class CmDeathState) == 8, "expected class CmDeathState to be size 8");

// class SDPDeathState
// 2 dependencies: class CmDeathState, class KrBaseState<bsBasic>
class SDPDeathState : CmDeathState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CmDeathState field_0, offset 0x0>
	// class CmDeathState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPDeathState>("SDPDeathState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class SDPDeathState) == 8, "expected class SDPDeathState to be size 8");

// class SDPComboState
// 1 dependencies: class KrBaseState<bsBasic>
class SDPComboState : KrBaseState<bsBasic>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPComboState>("SDPComboState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class SDPComboState) == 4, "expected class SDPComboState to be size 4");

// class CmDamageState
// 1 dependencies: class KrBaseState<bsBasic>
class CmDamageState : KrBaseState<bsBasic>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <int32_t mDownTick, offset 0x4>
	int32_t mDownTick;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmDamageState>("CmDamageState")
			.addProperty("mDownTick", &CmDamageState::mDownTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmDamageState::mDownTick) == 4, "expected mDownTick to be size 4");
static_assert(sizeof(class CmDamageState) == 8, "expected class CmDamageState to be size 8");

// class SDPDamageState
// 2 dependencies: class CmDamageState, class KrBaseState<bsBasic>
class SDPDamageState : CmDamageState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CmDamageState field_0, offset 0x0>
	// class CmDamageState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPDamageState>("SDPDamageState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class SDPDamageState) == 8, "expected class SDPDamageState to be size 8");

// class SDPBeamState
// 1 dependencies: class KrBaseState<bsBasic>
class SDPBeamState : KrBaseState<bsBasic>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPBeamState>("SDPBeamState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class SDPBeamState) == 4, "expected class SDPBeamState to be size 4");

// class CmIdleState
// 1 dependencies: class KrBaseState<bsBasic>
class CmIdleState : KrBaseState<bsBasic>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

	// <int32_t mContinuTick, offset 0x4>
	int32_t mContinuTick;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CmIdleState>("CmIdleState")
			.addProperty("mContinuTick", &CmIdleState::mContinuTick)
		.endClass();
	}
#endif
};
static_assert(sizeof(CmIdleState::mContinuTick) == 4, "expected mContinuTick to be size 4");
static_assert(sizeof(class CmIdleState) == 8, "expected class CmIdleState to be size 8");

// class SDPIdleState
// 2 dependencies: class CmIdleState, class KrBaseState<bsBasic>
class SDPIdleState : CmIdleState
{
public:
	/// No namespace types
	/// Struct member variables

	// <class CmIdleState field_0, offset 0x0>
	// class CmIdleState Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPIdleState>("SDPIdleState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class SDPIdleState) == 8, "expected class SDPIdleState to be size 8");

// class bsBasic
// 34 dependencies: class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, struct bsBasic::PcInfo, struct bsBasic::SurroundInfo, struct bsBasic::DistSense, struct bsBasic::TickCnt, struct bsBasic::BattleParam, struct bsBasic::DmgInfo, class KrStateMachine<bsBasic,32>, class PathPlanner
class bsBasic : mHRChara
{
public:
	/// 9 namespace types: struct bsBasic::PcInfo, struct bsBasic::SurroundInfo, struct bsBasic::DistSense, struct bsBasic::TickCnt, struct bsBasic::BattleParam, struct bsBasic::DmgInfo, void __convention("thiscall") bsBasic::SetDamageIK(class bsBasic* const this, class mHRChara* arg2, uint8_t arg3), uint8_t __convention("thiscall") bsBasic::mSetDamage(class bsBasic* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), uint8_t __convention("thiscall") bsBasic::IsAtkObj(class bsBasic* const this, class mHRChara* arg2)

	// struct bsBasic::PcInfo
	// 1 dependencies: struct Vec
	struct PcInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <struct Vec Pos, offset 0x0>
		struct Vec Pos;

		// <struct Vec NavelPos, offset 0xc>
		struct Vec NavelPos;

		// <struct Vec Direc, offset 0x18>
		struct Vec Direc;

		// <float DirecY, offset 0x24>
		float DirecY;

		// <float Dist, offset 0x28>
		float Dist;

		// <float SubAngle, offset 0x2c>
		float SubAngle;

		// <float RotY, offset 0x30>
		float RotY;

		// <uint8_t bObstacle, offset 0x34>
		uint8_t bObstacle;

		// <Filler, offset 0x35>
		char _Filler[3];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::PcInfo>("bsBasic::PcInfo")
				.addProperty("Pos", &bsBasic::PcInfo::Pos)
				.addProperty("NavelPos", &bsBasic::PcInfo::NavelPos)
				.addProperty("Direc", &bsBasic::PcInfo::Direc)
				.addProperty("DirecY", &bsBasic::PcInfo::DirecY)
				.addProperty("Dist", &bsBasic::PcInfo::Dist)
				.addProperty("SubAngle", &bsBasic::PcInfo::SubAngle)
				.addProperty("RotY", &bsBasic::PcInfo::RotY)
				.addProperty("bObstacle", &bsBasic::PcInfo::bObstacle)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::PcInfo::Pos) == 12, "expected Pos to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::NavelPos) == 12, "expected NavelPos to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::Direc) == 12, "expected Direc to be size 12");
	static_assert(sizeof(bsBasic::PcInfo::DirecY) == 4, "expected DirecY to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::Dist) == 4, "expected Dist to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::SubAngle) == 4, "expected SubAngle to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::RotY) == 4, "expected RotY to be size 4");
	static_assert(sizeof(bsBasic::PcInfo::bObstacle) == 1, "expected bObstacle to be size 1");
	static_assert(sizeof(struct bsBasic::PcInfo) == 56, "expected struct bsBasic::PcInfo to be size 56");

	// struct bsBasic::SurroundInfo
	// 1 dependencies: struct Vec
	struct SurroundInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <float SearchDist, offset 0x0>
		float SearchDist;

		// <float FrontDist, offset 0x4>
		float FrontDist;

		// <float BackDist, offset 0x8>
		float BackDist;

		// <float RightDist, offset 0xc>
		float RightDist;

		// <float LeftDist, offset 0x10>
		float LeftDist;

		// <struct Vec FrontPos, offset 0x14>
		struct Vec FrontPos;

		// <struct Vec BackPos, offset 0x20>
		struct Vec BackPos;

		// <struct Vec RightPos, offset 0x2c>
		struct Vec RightPos;

		// <struct Vec LeftPos, offset 0x38>
		struct Vec LeftPos;

		// <float StageFrontDist, offset 0x44>
		float StageFrontDist;

		// <float StageBackDist, offset 0x48>
		float StageBackDist;

		// <float StageRightDist, offset 0x4c>
		float StageRightDist;

		// <float StageLeftDist, offset 0x50>
		float StageLeftDist;

		// <struct Vec StageFrontPos, offset 0x54>
		struct Vec StageFrontPos;

		// <struct Vec StageBackPos, offset 0x60>
		struct Vec StageBackPos;

		// <struct Vec StageRightPos, offset 0x6c>
		struct Vec StageRightPos;

		// <struct Vec StageLeftPos, offset 0x78>
		struct Vec StageLeftPos;

		// <float CharaFrontDist, offset 0x84>
		float CharaFrontDist;

		// <float CharaBackDist, offset 0x88>
		float CharaBackDist;

		// <float CharaRightDist, offset 0x8c>
		float CharaRightDist;

		// <float CharaLeftDist, offset 0x90>
		float CharaLeftDist;

		// <struct Vec CharaFrontPos, offset 0x94>
		struct Vec CharaFrontPos;

		// <struct Vec CharaBackPos, offset 0xa0>
		struct Vec CharaBackPos;

		// <struct Vec CharaRightPos, offset 0xac>
		struct Vec CharaRightPos;

		// <struct Vec CharaLeftPos, offset 0xb8>
		struct Vec CharaLeftPos;

		// <float TargetDist, offset 0xc4>
		float TargetDist;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::SurroundInfo>("bsBasic::SurroundInfo")
				.addProperty("SearchDist", &bsBasic::SurroundInfo::SearchDist)
				.addProperty("FrontDist", &bsBasic::SurroundInfo::FrontDist)
				.addProperty("BackDist", &bsBasic::SurroundInfo::BackDist)
				.addProperty("RightDist", &bsBasic::SurroundInfo::RightDist)
				.addProperty("LeftDist", &bsBasic::SurroundInfo::LeftDist)
				.addProperty("FrontPos", &bsBasic::SurroundInfo::FrontPos)
				.addProperty("BackPos", &bsBasic::SurroundInfo::BackPos)
				.addProperty("RightPos", &bsBasic::SurroundInfo::RightPos)
				.addProperty("LeftPos", &bsBasic::SurroundInfo::LeftPos)
				.addProperty("StageFrontDist", &bsBasic::SurroundInfo::StageFrontDist)
				.addProperty("StageBackDist", &bsBasic::SurroundInfo::StageBackDist)
				.addProperty("StageRightDist", &bsBasic::SurroundInfo::StageRightDist)
				.addProperty("StageLeftDist", &bsBasic::SurroundInfo::StageLeftDist)
				.addProperty("StageFrontPos", &bsBasic::SurroundInfo::StageFrontPos)
				.addProperty("StageBackPos", &bsBasic::SurroundInfo::StageBackPos)
				.addProperty("StageRightPos", &bsBasic::SurroundInfo::StageRightPos)
				.addProperty("StageLeftPos", &bsBasic::SurroundInfo::StageLeftPos)
				.addProperty("CharaFrontDist", &bsBasic::SurroundInfo::CharaFrontDist)
				.addProperty("CharaBackDist", &bsBasic::SurroundInfo::CharaBackDist)
				.addProperty("CharaRightDist", &bsBasic::SurroundInfo::CharaRightDist)
				.addProperty("CharaLeftDist", &bsBasic::SurroundInfo::CharaLeftDist)
				.addProperty("CharaFrontPos", &bsBasic::SurroundInfo::CharaFrontPos)
				.addProperty("CharaBackPos", &bsBasic::SurroundInfo::CharaBackPos)
				.addProperty("CharaRightPos", &bsBasic::SurroundInfo::CharaRightPos)
				.addProperty("CharaLeftPos", &bsBasic::SurroundInfo::CharaLeftPos)
				.addProperty("TargetDist", &bsBasic::SurroundInfo::TargetDist)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::SurroundInfo::SearchDist) == 4, "expected SearchDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::FrontDist) == 4, "expected FrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::BackDist) == 4, "expected BackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::RightDist) == 4, "expected RightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::LeftDist) == 4, "expected LeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::FrontPos) == 12, "expected FrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::BackPos) == 12, "expected BackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::RightPos) == 12, "expected RightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::LeftPos) == 12, "expected LeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageFrontDist) == 4, "expected StageFrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageBackDist) == 4, "expected StageBackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageRightDist) == 4, "expected StageRightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageLeftDist) == 4, "expected StageLeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::StageFrontPos) == 12, "expected StageFrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageBackPos) == 12, "expected StageBackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageRightPos) == 12, "expected StageRightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::StageLeftPos) == 12, "expected StageLeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaFrontDist) == 4, "expected CharaFrontDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaBackDist) == 4, "expected CharaBackDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaRightDist) == 4, "expected CharaRightDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaLeftDist) == 4, "expected CharaLeftDist to be size 4");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaFrontPos) == 12, "expected CharaFrontPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaBackPos) == 12, "expected CharaBackPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaRightPos) == 12, "expected CharaRightPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::CharaLeftPos) == 12, "expected CharaLeftPos to be size 12");
	static_assert(sizeof(bsBasic::SurroundInfo::TargetDist) == 4, "expected TargetDist to be size 4");
	static_assert(sizeof(struct bsBasic::SurroundInfo) == 200, "expected struct bsBasic::SurroundInfo to be size 200");

	// struct bsBasic::DistSense
	// no dependencies
	struct DistSense
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <float Base, offset 0x0>
		float Base;

		// <float Small, offset 0x4>
		float Small;

		// <float Middle, offset 0x8>
		float Middle;

		// <float Long, offset 0xc>
		float Long;

		// <float Allowance, offset 0x10>
		float Allowance;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::DistSense>("bsBasic::DistSense")
				.addProperty("Base", &bsBasic::DistSense::Base)
				.addProperty("Small", &bsBasic::DistSense::Small)
				.addProperty("Middle", &bsBasic::DistSense::Middle)
				.addProperty("Long", &bsBasic::DistSense::Long)
				.addProperty("Allowance", &bsBasic::DistSense::Allowance)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::DistSense::Base) == 4, "expected Base to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Small) == 4, "expected Small to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Middle) == 4, "expected Middle to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Long) == 4, "expected Long to be size 4");
	static_assert(sizeof(bsBasic::DistSense::Allowance) == 4, "expected Allowance to be size 4");
	static_assert(sizeof(struct bsBasic::DistSense) == 20, "expected struct bsBasic::DistSense to be size 20");

	// struct bsBasic::TickCnt
	// no dependencies
	struct TickCnt
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t Motion, offset 0x0>
		int32_t Motion;

		// <int32_t AtkWait, offset 0x4>
		int32_t AtkWait;

		// <int32_t Loop, offset 0x8>
		int32_t Loop;

		// <int32_t State, offset 0xc>
		int32_t State;

		// <int32_t DmgWait, offset 0x10>
		int32_t DmgWait;

		// <int32_t DmgPlayAccept, offset 0x14>
		int32_t DmgPlayAccept;

		// <int32_t PreAvoid, offset 0x18>
		int32_t PreAvoid;

		// <int32_t Piyori, offset 0x1c>
		int32_t Piyori;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::TickCnt>("bsBasic::TickCnt")
				.addProperty("Motion", &bsBasic::TickCnt::Motion)
				.addProperty("AtkWait", &bsBasic::TickCnt::AtkWait)
				.addProperty("Loop", &bsBasic::TickCnt::Loop)
				.addProperty("State", &bsBasic::TickCnt::State)
				.addProperty("DmgWait", &bsBasic::TickCnt::DmgWait)
				.addProperty("DmgPlayAccept", &bsBasic::TickCnt::DmgPlayAccept)
				.addProperty("PreAvoid", &bsBasic::TickCnt::PreAvoid)
				.addProperty("Piyori", &bsBasic::TickCnt::Piyori)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::TickCnt::Motion) == 4, "expected Motion to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::AtkWait) == 4, "expected AtkWait to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::Loop) == 4, "expected Loop to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::State) == 4, "expected State to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::DmgWait) == 4, "expected DmgWait to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::DmgPlayAccept) == 4, "expected DmgPlayAccept to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::PreAvoid) == 4, "expected PreAvoid to be size 4");
	static_assert(sizeof(bsBasic::TickCnt::Piyori) == 4, "expected Piyori to be size 4");
	static_assert(sizeof(struct bsBasic::TickCnt) == 32, "expected struct bsBasic::TickCnt to be size 32");

	// struct bsBasic::BattleParam
	// 1 dependencies: struct Vec
	struct BattleParam
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <struct Vec TargetPos, offset 0x0>
		struct Vec TargetPos;

		// <uint32_t AtkPercent, offset 0xc>
		uint32_t AtkPercent;

		// <uint32_t GrdPercent, offset 0x10>
		uint32_t GrdPercent;

		// <int32_t TsubaTick, offset 0x14>
		int32_t TsubaTick;

		// <uint8_t TsubaRotNum, offset 0x18>
		uint8_t TsubaRotNum;

		// <Filler, offset 0x19>
		char _Filler5[3];

		// <int32_t HpPhase, offset 0x1c>
		int32_t HpPhase;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::BattleParam>("bsBasic::BattleParam")
				.addProperty("TargetPos", &bsBasic::BattleParam::TargetPos)
				.addProperty("AtkPercent", &bsBasic::BattleParam::AtkPercent)
				.addProperty("GrdPercent", &bsBasic::BattleParam::GrdPercent)
				.addProperty("TsubaTick", &bsBasic::BattleParam::TsubaTick)
				.addProperty("TsubaRotNum", &bsBasic::BattleParam::TsubaRotNum)
				.addProperty("HpPhase", &bsBasic::BattleParam::HpPhase)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::BattleParam::TargetPos) == 12, "expected TargetPos to be size 12");
	static_assert(sizeof(bsBasic::BattleParam::AtkPercent) == 4, "expected AtkPercent to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::GrdPercent) == 4, "expected GrdPercent to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::TsubaTick) == 4, "expected TsubaTick to be size 4");
	static_assert(sizeof(bsBasic::BattleParam::TsubaRotNum) == 1, "expected TsubaRotNum to be size 1");
	static_assert(sizeof(bsBasic::BattleParam::HpPhase) == 4, "expected HpPhase to be size 4");
	static_assert(sizeof(struct bsBasic::BattleParam) == 32, "expected struct bsBasic::BattleParam to be size 32");

	// struct bsBasic::DmgInfo
	// no dependencies
	struct DmgInfo
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <uint32_t Kind, offset 0x0>
		uint32_t Kind;

		// <uint32_t DirecKind, offset 0x4>
		uint32_t DirecKind;

		// <float Direc, offset 0x8>
		float Direc;

		// <uint32_t FinishHitNum, offset 0xc>
		uint32_t FinishHitNum;

		// <uint32_t DownFinishHitMax, offset 0x10>
		uint32_t DownFinishHitMax;

		// <float AccumuAmount, offset 0x14>
		float AccumuAmount;

		// <float AccumuMax, offset 0x18>
		float AccumuMax;

		// <float AccumuRecovery, offset 0x1c>
		float AccumuRecovery;

		// <float GroggyAmount, offset 0x20>
		float GroggyAmount;

		// <float GroggyMax, offset 0x24>
		float GroggyMax;

		// <float GroggyRecovery, offset 0x28>
		float GroggyRecovery;

		// <int32_t PiyoriTick, offset 0x2c>
		int32_t PiyoriTick;

		// <float DamagePower, offset 0x30>
		float DamagePower;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<bsBasic::DmgInfo>("bsBasic::DmgInfo")
				.addProperty("Kind", &bsBasic::DmgInfo::Kind)
				.addProperty("DirecKind", &bsBasic::DmgInfo::DirecKind)
				.addProperty("Direc", &bsBasic::DmgInfo::Direc)
				.addProperty("FinishHitNum", &bsBasic::DmgInfo::FinishHitNum)
				.addProperty("DownFinishHitMax", &bsBasic::DmgInfo::DownFinishHitMax)
				.addProperty("AccumuAmount", &bsBasic::DmgInfo::AccumuAmount)
				.addProperty("AccumuMax", &bsBasic::DmgInfo::AccumuMax)
				.addProperty("AccumuRecovery", &bsBasic::DmgInfo::AccumuRecovery)
				.addProperty("GroggyAmount", &bsBasic::DmgInfo::GroggyAmount)
				.addProperty("GroggyMax", &bsBasic::DmgInfo::GroggyMax)
				.addProperty("GroggyRecovery", &bsBasic::DmgInfo::GroggyRecovery)
				.addProperty("PiyoriTick", &bsBasic::DmgInfo::PiyoriTick)
				.addProperty("DamagePower", &bsBasic::DmgInfo::DamagePower)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(bsBasic::DmgInfo::Kind) == 4, "expected Kind to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DirecKind) == 4, "expected DirecKind to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::Direc) == 4, "expected Direc to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::FinishHitNum) == 4, "expected FinishHitNum to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DownFinishHitMax) == 4, "expected DownFinishHitMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuAmount) == 4, "expected AccumuAmount to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuMax) == 4, "expected AccumuMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::AccumuRecovery) == 4, "expected AccumuRecovery to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyAmount) == 4, "expected GroggyAmount to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyMax) == 4, "expected GroggyMax to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::GroggyRecovery) == 4, "expected GroggyRecovery to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::PiyoriTick) == 4, "expected PiyoriTick to be size 4");
	static_assert(sizeof(bsBasic::DmgInfo::DamagePower) == 4, "expected DamagePower to be size 4");
	static_assert(sizeof(struct bsBasic::DmgInfo) == 52, "expected struct bsBasic::DmgInfo to be size 52");

	// TODO: Function 'void __convention("thiscall") bsBasic::SetDamageIK(class bsBasic* const this, class mHRChara* arg2, uint8_t arg3)'
	// TODO: Function 'uint8_t __convention("thiscall") bsBasic::mSetDamage(class bsBasic* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// TODO: Function 'uint8_t __convention("thiscall") bsBasic::IsAtkObj(class bsBasic* const this, class mHRChara* arg2)'

	/// Struct member variables

	// <class mHRChara field_0, offset 0x0>
	// class mHRChara Super;

	// <float mRotSpeed, offset 0x580>
	float mRotSpeed;

	// <struct bsBasic::PcInfo mPcInfo, offset 0x584>
	struct bsBasic::PcInfo mPcInfo;

	// <struct bsBasic::SurroundInfo mSurroundInfo, offset 0x5bc>
	struct bsBasic::SurroundInfo mSurroundInfo;

	// <struct bsBasic::DistSense mDistSense, offset 0x684>
	struct bsBasic::DistSense mDistSense;

	// <struct bsBasic::TickCnt mTickCnt, offset 0x698>
	struct bsBasic::TickCnt mTickCnt;

	// <struct bsBasic::BattleParam mBattleParam, offset 0x6b8>
	struct bsBasic::BattleParam mBattleParam;

	// <struct bsBasic::DmgInfo mDmgInfo, offset 0x6d8>
	struct bsBasic::DmgInfo mDmgInfo;

	// <class KrStateMachine<bsBasic,32> mStateMachine, offset 0x70c>
	class KrStateMachine<bsBasic,32> mStateMachine;

	// <class PathPlanner mPathPlan, offset 0x79c>
	class PathPlanner mPathPlan;

	// <int32_t mVoiceID, offset 0xc60>
	int32_t mVoiceID;

	// <uint8_t mbDownVoice, offset 0xc64>
	uint8_t mbDownVoice;

	// <Filler, offset 0xc65>
	char _Filler12[3];

	// <int32_t mMiniDemoNum, offset 0xc68>
	int32_t mMiniDemoNum;

	// <class TGmf* mpLowModelGmf, offset 0xc6c>
	class TGmf* mpLowModelGmf;

	// <class EffectModelBeam* m_pEffectModelBeam, offset 0xc70>
	class EffectModelBeam* m_pEffectModelBeam;

	// <class FkObstacleSensor* m_pObsSens, offset 0xc74>
	class FkObstacleSensor* m_pObsSens;

	// <uint8_t m_boUseObsSens, offset 0xc78>
	uint8_t m_boUseObsSens;

	// <uint8_t m_boCalledNoGuardEfOnce, offset 0xc79>
	uint8_t m_boCalledNoGuardEfOnce;

	// <Filler, offset 0xc7a>
	char _Filler18[2];

	// <float m_fCheckSrroundHeight, offset 0xc7c>
	float m_fCheckSrroundHeight;

	// <uint32_t mFlag, offset 0xc80>
	uint32_t mFlag;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsBasic>("bsBasic")
			.addProperty("mRotSpeed", &bsBasic::mRotSpeed)
			.addProperty("mPcInfo", &bsBasic::mPcInfo)
			.addProperty("mSurroundInfo", &bsBasic::mSurroundInfo)
			.addProperty("mDistSense", &bsBasic::mDistSense)
			.addProperty("mTickCnt", &bsBasic::mTickCnt)
			.addProperty("mBattleParam", &bsBasic::mBattleParam)
			.addProperty("mDmgInfo", &bsBasic::mDmgInfo)
			.addProperty("mStateMachine", &bsBasic::mStateMachine)
			.addProperty("mPathPlan", &bsBasic::mPathPlan)
			.addProperty("mVoiceID", &bsBasic::mVoiceID)
			.addProperty("mbDownVoice", &bsBasic::mbDownVoice)
			.addProperty("mMiniDemoNum", &bsBasic::mMiniDemoNum)
			.addProperty("mpLowModelGmf", &bsBasic::mpLowModelGmf)
			.addProperty("m_pEffectModelBeam", &bsBasic::m_pEffectModelBeam)
			.addProperty("m_pObsSens", &bsBasic::m_pObsSens)
			.addProperty("m_boUseObsSens", &bsBasic::m_boUseObsSens)
			.addProperty("m_boCalledNoGuardEfOnce", &bsBasic::m_boCalledNoGuardEfOnce)
			.addProperty("m_fCheckSrroundHeight", &bsBasic::m_fCheckSrroundHeight)
			.addProperty("mFlag", &bsBasic::mFlag)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsBasic::mRotSpeed) == 4, "expected mRotSpeed to be size 4");
static_assert(sizeof(bsBasic::mPcInfo) == 56, "expected mPcInfo to be size 56");
static_assert(sizeof(bsBasic::mSurroundInfo) == 200, "expected mSurroundInfo to be size 200");
static_assert(sizeof(bsBasic::mDistSense) == 20, "expected mDistSense to be size 20");
static_assert(sizeof(bsBasic::mTickCnt) == 32, "expected mTickCnt to be size 32");
static_assert(sizeof(bsBasic::mBattleParam) == 32, "expected mBattleParam to be size 32");
static_assert(sizeof(bsBasic::mDmgInfo) == 52, "expected mDmgInfo to be size 52");
static_assert(sizeof(bsBasic::mStateMachine) == 144, "expected mStateMachine to be size 144");
static_assert(sizeof(bsBasic::mPathPlan) == 1220, "expected mPathPlan to be size 1220");
static_assert(sizeof(bsBasic::mVoiceID) == 4, "expected mVoiceID to be size 4");
static_assert(sizeof(bsBasic::mbDownVoice) == 1, "expected mbDownVoice to be size 1");
static_assert(sizeof(bsBasic::mMiniDemoNum) == 4, "expected mMiniDemoNum to be size 4");
static_assert(sizeof(bsBasic::mpLowModelGmf) == 4, "expected mpLowModelGmf to be size 4");
static_assert(sizeof(bsBasic::m_pEffectModelBeam) == 4, "expected m_pEffectModelBeam to be size 4");
static_assert(sizeof(bsBasic::m_pObsSens) == 4, "expected m_pObsSens to be size 4");
static_assert(sizeof(bsBasic::m_boUseObsSens) == 1, "expected m_boUseObsSens to be size 1");
static_assert(sizeof(bsBasic::m_boCalledNoGuardEfOnce) == 1, "expected m_boCalledNoGuardEfOnce to be size 1");
static_assert(sizeof(bsBasic::m_fCheckSrroundHeight) == 4, "expected m_fCheckSrroundHeight to be size 4");
static_assert(sizeof(bsBasic::mFlag) == 4, "expected mFlag to be size 4");
static_assert(sizeof(class bsBasic) == 3204, "expected class bsBasic to be size 3204");

// class SDPMoveState
// 1 dependencies: class KrBaseState<bsBasic>
class SDPMoveState : KrBaseState<bsBasic>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPMoveState>("SDPMoveState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class SDPMoveState) == 4, "expected class SDPMoveState to be size 4");

// class SDPGuardState
// 1 dependencies: class KrBaseState<bsBasic>
class SDPGuardState : KrBaseState<bsBasic>
{
public:
	/// No namespace types
	/// Struct member variables

	// <class KrBaseState<bsBasic> field_0, offset 0x0>
	// class KrBaseState<bsBasic> Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<SDPGuardState>("SDPGuardState")
		.endClass();
	}
#endif
};
static_assert(sizeof(class SDPGuardState) == 4, "expected class SDPGuardState to be size 4");

// class bsSDP
// 46 dependencies: class bsBasic, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, struct bsBasic::PcInfo, struct bsBasic::SurroundInfo, struct bsBasic::DistSense, struct bsBasic::TickCnt, struct bsBasic::BattleParam, struct bsBasic::DmgInfo, class KrStateMachine<bsBasic,32>, class PathPlanner, class SDPIdleState, class CmIdleState, class KrBaseState<bsBasic>, class SDPComboState, class SDPBeamState, class SDPGuardState, class SDPDamageState, class CmDamageState, class SDPMoveState, class SDPDeathState, class CmDeathState
class bsSDP : bsBasic
{
public:
	/// 2 namespace types: uint8_t __convention("thiscall") bsSDP::IsAtkObj(class bsSDP* const this, class mHRChara* arg2), uint8_t __convention("thiscall") bsSDP::mSetDamage(class bsSDP* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") bsSDP::IsAtkObj(class bsSDP* const this, class mHRChara* arg2)'
	// TODO: Function 'uint8_t __convention("thiscall") bsSDP::mSetDamage(class bsSDP* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <class bsBasic field_0, offset 0x0>
	// class bsBasic Super;

	// <class EfRoboInterface* mpIntarface, offset 0xc84>
	class EfRoboInterface* mpIntarface;

	// <class pcGLB* mpGLB, offset 0xc88>
	class pcGLB* mpGLB;

	// <class EfGeneralBeam* mpGeneralBeam, offset 0xc8c>
	class EfGeneralBeam* mpGeneralBeam;

	// <class TGmfNode* mpBeamLaunchNode, offset 0xc90>
	class TGmfNode* mpBeamLaunchNode;

	// <class TGmfNode* mpWristRNode, offset 0xc94>
	class TGmfNode* mpWristRNode;

	// <float mTension, offset 0xc98>
	float mTension;

	// <class SDPIdleState mIdleState, offset 0xc9c>
	class SDPIdleState mIdleState;

	// <class SDPComboState mComboState, offset 0xca4>
	class SDPComboState mComboState;

	// <class SDPBeamState mBeamState, offset 0xca8>
	class SDPBeamState mBeamState;

	// <class SDPGuardState mGuardState, offset 0xcac>
	class SDPGuardState mGuardState;

	// <class SDPDamageState mDamageState, offset 0xcb0>
	class SDPDamageState mDamageState;

	// <class SDPMoveState mMoveState, offset 0xcb8>
	class SDPMoveState mMoveState;

	// <class SDPDeathState mDeathState, offset 0xcbc>
	class SDPDeathState mDeathState;

	// <struct Vec mBefPos, offset 0xcc4>
	struct Vec mBefPos;

	// <uint8_t mbDemoWait, offset 0xcd0>
	uint8_t mbDemoWait;

	// <uint8_t mbDeadScriptCall, offset 0xcd1>
	uint8_t mbDeadScriptCall;

	// <uint8_t mbFirstSE, offset 0xcd2>
	uint8_t mbFirstSE;

	// <uint8_t mbGLBSE, offset 0xcd3>
	uint8_t mbGLBSE;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<bsSDP>("bsSDP")
			.addProperty("mpIntarface", &bsSDP::mpIntarface)
			.addProperty("mpGLB", &bsSDP::mpGLB)
			.addProperty("mpGeneralBeam", &bsSDP::mpGeneralBeam)
			.addProperty("mpBeamLaunchNode", &bsSDP::mpBeamLaunchNode)
			.addProperty("mpWristRNode", &bsSDP::mpWristRNode)
			.addProperty("mTension", &bsSDP::mTension)
			.addProperty("mIdleState", &bsSDP::mIdleState)
			.addProperty("mComboState", &bsSDP::mComboState)
			.addProperty("mBeamState", &bsSDP::mBeamState)
			.addProperty("mGuardState", &bsSDP::mGuardState)
			.addProperty("mDamageState", &bsSDP::mDamageState)
			.addProperty("mMoveState", &bsSDP::mMoveState)
			.addProperty("mDeathState", &bsSDP::mDeathState)
			.addProperty("mBefPos", &bsSDP::mBefPos)
			.addProperty("mbDemoWait", &bsSDP::mbDemoWait)
			.addProperty("mbDeadScriptCall", &bsSDP::mbDeadScriptCall)
			.addProperty("mbFirstSE", &bsSDP::mbFirstSE)
			.addProperty("mbGLBSE", &bsSDP::mbGLBSE)
		.endClass();
	}
#endif
};
static_assert(sizeof(bsSDP::mpIntarface) == 4, "expected mpIntarface to be size 4");
static_assert(sizeof(bsSDP::mpGLB) == 4, "expected mpGLB to be size 4");
static_assert(sizeof(bsSDP::mpGeneralBeam) == 4, "expected mpGeneralBeam to be size 4");
static_assert(sizeof(bsSDP::mpBeamLaunchNode) == 4, "expected mpBeamLaunchNode to be size 4");
static_assert(sizeof(bsSDP::mpWristRNode) == 4, "expected mpWristRNode to be size 4");
static_assert(sizeof(bsSDP::mTension) == 4, "expected mTension to be size 4");
static_assert(sizeof(bsSDP::mIdleState) == 8, "expected mIdleState to be size 8");
static_assert(sizeof(bsSDP::mComboState) == 4, "expected mComboState to be size 4");
static_assert(sizeof(bsSDP::mBeamState) == 4, "expected mBeamState to be size 4");
static_assert(sizeof(bsSDP::mGuardState) == 4, "expected mGuardState to be size 4");
static_assert(sizeof(bsSDP::mDamageState) == 8, "expected mDamageState to be size 8");
static_assert(sizeof(bsSDP::mMoveState) == 4, "expected mMoveState to be size 4");
static_assert(sizeof(bsSDP::mDeathState) == 8, "expected mDeathState to be size 8");
static_assert(sizeof(bsSDP::mBefPos) == 12, "expected mBefPos to be size 12");
static_assert(sizeof(bsSDP::mbDemoWait) == 1, "expected mbDemoWait to be size 1");
static_assert(sizeof(bsSDP::mbDeadScriptCall) == 1, "expected mbDeadScriptCall to be size 1");
static_assert(sizeof(bsSDP::mbFirstSE) == 1, "expected mbFirstSE to be size 1");
static_assert(sizeof(bsSDP::mbGLBSE) == 1, "expected mbGLBSE to be size 1");
static_assert(sizeof(class bsSDP) == 3284, "expected class bsSDP to be size 3284");

// class FkTriangleList
// 1 dependencies: class FkStlVector<FkVtx>
class FkTriangleList
{
public:
	/// No namespace types
	/// Struct member variables

	// <class FkStlVector<FkVtx> m_VtxArr, offset 0x0>
	class FkStlVector<FkVtx> m_VtxArr;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkTriangleList>("FkTriangleList")
			.addProperty("m_VtxArr", &FkTriangleList::m_VtxArr)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkTriangleList::m_VtxArr) == 20, "expected m_VtxArr to be size 20");
static_assert(sizeof(class FkTriangleList) == 20, "expected class FkTriangleList to be size 20");

// class EffectModelBeam
// 3 dependencies: class HrTask, class FkTriangleList, class FkStlVector<FkVtx>
class EffectModelBeam : HrTask
{
public:
	/// No namespace types
	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class FkTriangleList m_TriangleList, offset 0x50>
	class FkTriangleList m_TriangleList;

	// <class TGmf* m_pGmf, offset 0x64>
	class TGmf* m_pGmf;

	// <class TGmfNode* m_pBeamNode, offset 0x68>
	class TGmfNode* m_pBeamNode;

	// <uint32_t m_Color, offset 0x6c>
	uint32_t m_Color;

	// <uint8_t m_boVisible, offset 0x70>
	uint8_t m_boVisible;

	// <Filler, offset 0x71>
	char _Filler6[3];

	// <float m_fScale, offset 0x74>
	float m_fScale;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectModelBeam>("EffectModelBeam")
			.addProperty("m_TriangleList", &EffectModelBeam::m_TriangleList)
			.addProperty("m_pGmf", &EffectModelBeam::m_pGmf)
			.addProperty("m_pBeamNode", &EffectModelBeam::m_pBeamNode)
			.addProperty("m_Color", &EffectModelBeam::m_Color)
			.addProperty("m_boVisible", &EffectModelBeam::m_boVisible)
			.addProperty("m_fScale", &EffectModelBeam::m_fScale)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectModelBeam::m_TriangleList) == 20, "expected m_TriangleList to be size 20");
static_assert(sizeof(EffectModelBeam::m_pGmf) == 4, "expected m_pGmf to be size 4");
static_assert(sizeof(EffectModelBeam::m_pBeamNode) == 4, "expected m_pBeamNode to be size 4");
static_assert(sizeof(EffectModelBeam::m_Color) == 4, "expected m_Color to be size 4");
static_assert(sizeof(EffectModelBeam::m_boVisible) == 1, "expected m_boVisible to be size 1");
static_assert(sizeof(EffectModelBeam::m_fScale) == 4, "expected m_fScale to be size 4");
static_assert(sizeof(class EffectModelBeam) == 120, "expected class EffectModelBeam to be size 120");

// struct FkVtx
// 1 dependencies: struct Vec
struct FkVtx
{
public:
	/// No namespace types
	/// Struct member variables

	// <struct Vec Pos, offset 0x0>
	struct Vec Pos;

	// <struct Vec Norm, offset 0xc>
	struct Vec Norm;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkVtx>("FkVtx")
			.addProperty("Pos", &FkVtx::Pos)
			.addProperty("Norm", &FkVtx::Norm)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkVtx::Pos) == 12, "expected Pos to be size 12");
static_assert(sizeof(FkVtx::Norm) == 12, "expected Norm to be size 12");
static_assert(sizeof(struct FkVtx) == 24, "expected struct FkVtx to be size 24");

// class EfGeneralBeam
// no dependencies
class EfGeneralBeam
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[54968];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EfGeneralBeam>("EfGeneralBeam")
		.endClass();
	}
#endif
};
static_assert(sizeof(class EfGeneralBeam) == 54968, "expected class EfGeneralBeam to be size 54968");

// class PJOBJ0029
// 29 dependencies: class commonObj, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate
class PJOBJ0029 : commonObj
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") PJOBJ0029::mSetDamage(class PJOBJ0029* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)

	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0029::mSetDamage(class PJOBJ0029* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)'

	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class TGmfNode* mpTopNode, offset 0x64c>
	class TGmfNode* mpTopNode;

	// <uint8_t mbBreak, offset 0x650>
	uint8_t mbBreak;

	// <Filler, offset 0x651>
	char _Filler3[3];

	// <float mRadius, offset 0x654>
	float mRadius;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJOBJ0029>("PJOBJ0029")
			.addProperty("mpTopNode", &PJOBJ0029::mpTopNode)
			.addProperty("mbBreak", &PJOBJ0029::mbBreak)
			.addProperty("mRadius", &PJOBJ0029::mRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0029::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(PJOBJ0029::mbBreak) == 1, "expected mbBreak to be size 1");
static_assert(sizeof(PJOBJ0029::mRadius) == 4, "expected mRadius to be size 4");
static_assert(sizeof(class PJOBJ0029) == 1624, "expected class PJOBJ0029 to be size 1624");

// class PJOBJ0033
// 31 dependencies: class commonObj, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate, class FkStlVector<TGmfNode const *>, class FkStlVector<EffectModelFire *>
class PJOBJ0033 : commonObj
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") PJOBJ0033::mSetDamage(class PJOBJ0033* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)

	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0033::mSetDamage(class PJOBJ0033* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)'

	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <int32_t m_BreakCnt, offset 0x64c>
	int32_t m_BreakCnt;

	// <uint8_t m_Dead, offset 0x650>
	uint8_t m_Dead;

	// <uint8_t m_Motion, offset 0x651>
	uint8_t m_Motion;

	// <uint8_t m_Off, offset 0x652>
	uint8_t m_Off;

	// <Filler, offset 0x653>
	char _Filler5[1];

	// <struct Vec m_CenterPos, offset 0x654>
	struct Vec m_CenterPos;

	// <float m_fAccumDmg, offset 0x660>
	float m_fAccumDmg;

	// <float m_fMaxAccumDmg, offset 0x664>
	float m_fMaxAccumDmg;

	// <uint8_t m_boGetBreakNode, offset 0x668>
	uint8_t m_boGetBreakNode;

	// <uint8_t m_boCreateFire, offset 0x669>
	uint8_t m_boCreateFire;

	// <Filler, offset 0x66a>
	char _Filler10[2];

	// <int32_t m_BlinkCnt, offset 0x66c>
	int32_t m_BlinkCnt;

	// <uint8_t m_boBlink, offset 0x670>
	uint8_t m_boBlink;

	// <Filler, offset 0x671>
	char _Filler12[3];

	// <class FkStlVector<TGmfNode const *> m_apNode, offset 0x674>
	class FkStlVector<TGmfNode const *> m_apNode;

	// <class FkStlVector<EffectModelFire *> m_pModelFireArr, offset 0x688>
	class FkStlVector<EffectModelFire *> m_pModelFireArr;

	// <int32_t m_SeHnd, offset 0x69c>
	int32_t m_SeHnd;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJOBJ0033>("PJOBJ0033")
			.addProperty("m_BreakCnt", &PJOBJ0033::m_BreakCnt)
			.addProperty("m_Dead", &PJOBJ0033::m_Dead)
			.addProperty("m_Motion", &PJOBJ0033::m_Motion)
			.addProperty("m_Off", &PJOBJ0033::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0033::m_CenterPos)
			.addProperty("m_fAccumDmg", &PJOBJ0033::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0033::m_fMaxAccumDmg)
			.addProperty("m_boGetBreakNode", &PJOBJ0033::m_boGetBreakNode)
			.addProperty("m_boCreateFire", &PJOBJ0033::m_boCreateFire)
			.addProperty("m_BlinkCnt", &PJOBJ0033::m_BlinkCnt)
			.addProperty("m_boBlink", &PJOBJ0033::m_boBlink)
			.addProperty("m_apNode", &PJOBJ0033::m_apNode)
			.addProperty("m_pModelFireArr", &PJOBJ0033::m_pModelFireArr)
			.addProperty("m_SeHnd", &PJOBJ0033::m_SeHnd)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0033::m_BreakCnt) == 4, "expected m_BreakCnt to be size 4");
static_assert(sizeof(PJOBJ0033::m_Dead) == 1, "expected m_Dead to be size 1");
static_assert(sizeof(PJOBJ0033::m_Motion) == 1, "expected m_Motion to be size 1");
static_assert(sizeof(PJOBJ0033::m_Off) == 1, "expected m_Off to be size 1");
static_assert(sizeof(PJOBJ0033::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0033::m_fAccumDmg) == 4, "expected m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0033::m_fMaxAccumDmg) == 4, "expected m_fMaxAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0033::m_boGetBreakNode) == 1, "expected m_boGetBreakNode to be size 1");
static_assert(sizeof(PJOBJ0033::m_boCreateFire) == 1, "expected m_boCreateFire to be size 1");
static_assert(sizeof(PJOBJ0033::m_BlinkCnt) == 4, "expected m_BlinkCnt to be size 4");
static_assert(sizeof(PJOBJ0033::m_boBlink) == 1, "expected m_boBlink to be size 1");
static_assert(sizeof(PJOBJ0033::m_apNode) == 20, "expected m_apNode to be size 20");
static_assert(sizeof(PJOBJ0033::m_pModelFireArr) == 20, "expected m_pModelFireArr to be size 20");
static_assert(sizeof(PJOBJ0033::m_SeHnd) == 4, "expected m_SeHnd to be size 4");
static_assert(sizeof(class PJOBJ0033) == 1696, "expected class PJOBJ0033 to be size 1696");

// struct EFFECTSIMPLEOBJ3PARAM
// no dependencies
struct EFFECTSIMPLEOBJ3PARAM
{
public:
	/// No namespace types
	/// Struct member variables

	// <int32_t MaxObjNum, offset 0x0>
	int32_t MaxObjNum;

	// <float SpeedUpSpeed, offset 0x4>
	float SpeedUpSpeed;

	// <float SideSpeedDownRate, offset 0x8>
	float SideSpeedDownRate;

	// <int16_t MaxVisibleTime, offset 0xc>
	int16_t MaxVisibleTime;

	// <int16_t MinVisibleTime, offset 0xe>
	int16_t MinVisibleTime;

	// <int16_t MaxFadeInSpeed, offset 0x10>
	int16_t MaxFadeInSpeed;

	// <int16_t MinFadeInSpeed, offset 0x12>
	int16_t MinFadeInSpeed;

	// <int16_t MaxFadeOutSpeed, offset 0x14>
	int16_t MaxFadeOutSpeed;

	// <int16_t MinFadeOutSpeed, offset 0x16>
	int16_t MinFadeOutSpeed;

	// <float MaxSideSpeed, offset 0x18>
	float MaxSideSpeed;

	// <float MinSideSpeed, offset 0x1c>
	float MinSideSpeed;

	// <float InitMaxSpeed, offset 0x20>
	float InitMaxSpeed;

	// <float InitMinSpeed, offset 0x24>
	float InitMinSpeed;

	// <float MaxWidth, offset 0x28>
	float MaxWidth;

	// <float MinWidth, offset 0x2c>
	float MinWidth;

	// <uint32_t Color, offset 0x30>
	uint32_t Color;

	// <int32_t ColorRand, offset 0x34>
	int32_t ColorRand;

	// <struct tagGHMR_TEX* pTexture, offset 0x38>
	struct tagGHMR_TEX* pTexture;

	// <int32_t TexDivX, offset 0x3c>
	int32_t TexDivX;

	// <int32_t TexDivY, offset 0x40>
	int32_t TexDivY;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EFFECTSIMPLEOBJ3PARAM>("EFFECTSIMPLEOBJ3PARAM")
			.addProperty("MaxObjNum", &EFFECTSIMPLEOBJ3PARAM::MaxObjNum)
			.addProperty("SpeedUpSpeed", &EFFECTSIMPLEOBJ3PARAM::SpeedUpSpeed)
			.addProperty("SideSpeedDownRate", &EFFECTSIMPLEOBJ3PARAM::SideSpeedDownRate)
			.addProperty("MaxVisibleTime", &EFFECTSIMPLEOBJ3PARAM::MaxVisibleTime)
			.addProperty("MinVisibleTime", &EFFECTSIMPLEOBJ3PARAM::MinVisibleTime)
			.addProperty("MaxFadeInSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxFadeInSpeed)
			.addProperty("MinFadeInSpeed", &EFFECTSIMPLEOBJ3PARAM::MinFadeInSpeed)
			.addProperty("MaxFadeOutSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxFadeOutSpeed)
			.addProperty("MinFadeOutSpeed", &EFFECTSIMPLEOBJ3PARAM::MinFadeOutSpeed)
			.addProperty("MaxSideSpeed", &EFFECTSIMPLEOBJ3PARAM::MaxSideSpeed)
			.addProperty("MinSideSpeed", &EFFECTSIMPLEOBJ3PARAM::MinSideSpeed)
			.addProperty("InitMaxSpeed", &EFFECTSIMPLEOBJ3PARAM::InitMaxSpeed)
			.addProperty("InitMinSpeed", &EFFECTSIMPLEOBJ3PARAM::InitMinSpeed)
			.addProperty("MaxWidth", &EFFECTSIMPLEOBJ3PARAM::MaxWidth)
			.addProperty("MinWidth", &EFFECTSIMPLEOBJ3PARAM::MinWidth)
			.addProperty("Color", &EFFECTSIMPLEOBJ3PARAM::Color)
			.addProperty("ColorRand", &EFFECTSIMPLEOBJ3PARAM::ColorRand)
			.addProperty("pTexture", &EFFECTSIMPLEOBJ3PARAM::pTexture)
			.addProperty("TexDivX", &EFFECTSIMPLEOBJ3PARAM::TexDivX)
			.addProperty("TexDivY", &EFFECTSIMPLEOBJ3PARAM::TexDivY)
		.endClass();
	}
#endif
};
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxObjNum) == 4, "expected MaxObjNum to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::SpeedUpSpeed) == 4, "expected SpeedUpSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::SideSpeedDownRate) == 4, "expected SideSpeedDownRate to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxVisibleTime) == 2, "expected MaxVisibleTime to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinVisibleTime) == 2, "expected MinVisibleTime to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxFadeInSpeed) == 2, "expected MaxFadeInSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinFadeInSpeed) == 2, "expected MinFadeInSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxFadeOutSpeed) == 2, "expected MaxFadeOutSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinFadeOutSpeed) == 2, "expected MinFadeOutSpeed to be size 2");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxSideSpeed) == 4, "expected MaxSideSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinSideSpeed) == 4, "expected MinSideSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::InitMaxSpeed) == 4, "expected InitMaxSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::InitMinSpeed) == 4, "expected InitMinSpeed to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MaxWidth) == 4, "expected MaxWidth to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::MinWidth) == 4, "expected MinWidth to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::Color) == 4, "expected Color to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::ColorRand) == 4, "expected ColorRand to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::pTexture) == 4, "expected pTexture to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::TexDivX) == 4, "expected TexDivX to be size 4");
static_assert(sizeof(EFFECTSIMPLEOBJ3PARAM::TexDivY) == 4, "expected TexDivY to be size 4");
static_assert(sizeof(struct EFFECTSIMPLEOBJ3PARAM) == 68, "expected struct EFFECTSIMPLEOBJ3PARAM to be size 68");

// struct EFFECTMODELFIREPARAM
// 1 dependencies: struct EFFECTSIMPLEOBJ3PARAM
struct EFFECTMODELFIREPARAM
{
public:
	/// No namespace types
	/// Struct member variables

	// <float CreateRate, offset 0x0>
	float CreateRate;

	// <float CreateArea, offset 0x4>
	float CreateArea;

	// <struct EFFECTSIMPLEOBJ3PARAM Obj3Param, offset 0x8>
	struct EFFECTSIMPLEOBJ3PARAM Obj3Param;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EFFECTMODELFIREPARAM>("EFFECTMODELFIREPARAM")
			.addProperty("CreateRate", &EFFECTMODELFIREPARAM::CreateRate)
			.addProperty("CreateArea", &EFFECTMODELFIREPARAM::CreateArea)
			.addProperty("Obj3Param", &EFFECTMODELFIREPARAM::Obj3Param)
		.endClass();
	}
#endif
};
static_assert(sizeof(EFFECTMODELFIREPARAM::CreateRate) == 4, "expected CreateRate to be size 4");
static_assert(sizeof(EFFECTMODELFIREPARAM::CreateArea) == 4, "expected CreateArea to be size 4");
static_assert(sizeof(EFFECTMODELFIREPARAM::Obj3Param) == 68, "expected Obj3Param to be size 68");
static_assert(sizeof(struct EFFECTMODELFIREPARAM) == 76, "expected struct EFFECTMODELFIREPARAM to be size 76");

// class EffectModelFire
// 4 dependencies: class HrTask, struct EffectModelFire::MAIN, struct EFFECTMODELFIREPARAM, struct EFFECTSIMPLEOBJ3PARAM
class EffectModelFire : HrTask
{
public:
	/// 1 namespace types: struct EffectModelFire::MAIN

	// struct EffectModelFire::MAIN
	// 2 dependencies: struct EFFECTMODELFIREPARAM, struct EFFECTSIMPLEOBJ3PARAM
	struct MAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class TGmf* pGmf, offset 0x0>
		class TGmf* pGmf;

		// <class TGmfNode* pGmfNode, offset 0x4>
		class TGmfNode* pGmfNode;

		// <float CreateCounter, offset 0x8>
		float CreateCounter;

		// <int32_t SinCounter[0x3], offset 0xc>
		int32_t SinCounter[3];

		// <int32_t SinSpeed[0x3], offset 0x18>
		int32_t SinSpeed[3];

		// <float NowCreateRate, offset 0x24>
		float NowCreateRate;

		// <float MinY, offset 0x28>
		float MinY;

		// <float MaxY, offset 0x2c>
		float MaxY;

		// <float BoarderY, offset 0x30>
		float BoarderY;

		// <float OutRate, offset 0x34>
		float OutRate;

		// <int32_t SoundID, offset 0x38>
		int32_t SoundID;

		// <int32_t SoundHandle, offset 0x3c>
		int32_t SoundHandle;

		// <struct EFFECTMODELFIREPARAM Param, offset 0x40>
		struct EFFECTMODELFIREPARAM Param;

		// <class EffectSimpleObj3* pObj3, offset 0x8c>
		class EffectSimpleObj3* pObj3;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectModelFire::MAIN>("EffectModelFire::MAIN")
				.addProperty("pGmf", &EffectModelFire::MAIN::pGmf)
				.addProperty("pGmfNode", &EffectModelFire::MAIN::pGmfNode)
				.addProperty("CreateCounter", &EffectModelFire::MAIN::CreateCounter)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("SinCounter", &EffectModelFire::MAIN::SinCounter)
				// static arrays are not supported in LuaBridge (only std::vector)
				//.addProperty("SinSpeed", &EffectModelFire::MAIN::SinSpeed)
				.addProperty("NowCreateRate", &EffectModelFire::MAIN::NowCreateRate)
				.addProperty("MinY", &EffectModelFire::MAIN::MinY)
				.addProperty("MaxY", &EffectModelFire::MAIN::MaxY)
				.addProperty("BoarderY", &EffectModelFire::MAIN::BoarderY)
				.addProperty("OutRate", &EffectModelFire::MAIN::OutRate)
				.addProperty("SoundID", &EffectModelFire::MAIN::SoundID)
				.addProperty("SoundHandle", &EffectModelFire::MAIN::SoundHandle)
				.addProperty("Param", &EffectModelFire::MAIN::Param)
				.addProperty("pObj3", &EffectModelFire::MAIN::pObj3)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectModelFire::MAIN::pGmf) == 4, "expected pGmf to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::pGmfNode) == 4, "expected pGmfNode to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::CreateCounter) == 4, "expected CreateCounter to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SinCounter) == 12, "expected SinCounter to be size 12");
	static_assert(sizeof(EffectModelFire::MAIN::SinSpeed) == 12, "expected SinSpeed to be size 12");
	static_assert(sizeof(EffectModelFire::MAIN::NowCreateRate) == 4, "expected NowCreateRate to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::MinY) == 4, "expected MinY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::MaxY) == 4, "expected MaxY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::BoarderY) == 4, "expected BoarderY to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::OutRate) == 4, "expected OutRate to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SoundID) == 4, "expected SoundID to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::SoundHandle) == 4, "expected SoundHandle to be size 4");
	static_assert(sizeof(EffectModelFire::MAIN::Param) == 76, "expected Param to be size 76");
	static_assert(sizeof(EffectModelFire::MAIN::pObj3) == 4, "expected pObj3 to be size 4");
	static_assert(sizeof(struct EffectModelFire::MAIN) == 144, "expected struct EffectModelFire::MAIN to be size 144");


	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectModelFire::MAIN dat, offset 0x50>
	struct EffectModelFire::MAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectModelFire>("EffectModelFire")
			.addProperty("dat", &EffectModelFire::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectModelFire::dat) == 144, "expected dat to be size 144");
static_assert(sizeof(class EffectModelFire) == 224, "expected class EffectModelFire to be size 224");

// class EffectSimpleObj3
// 3 dependencies: class HrTask, struct EffectSimpleObj3::MAIN, struct EFFECTSIMPLEOBJ3PARAM
class EffectSimpleObj3 : HrTask
{
public:
	/// 2 namespace types: struct EffectSimpleObj3::MAIN, struct EffectSimpleObj3::OBJECT

	// struct EffectSimpleObj3::MAIN
	// 1 dependencies: struct EFFECTSIMPLEOBJ3PARAM
	struct MAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t ObjNum, offset 0x0>
		int32_t ObjNum;

		// <struct EffectSimpleObj3::OBJECT* Obj, offset 0x4>
		struct OBJECT* Obj;

		// <struct tagTLIST* ValidFirstObj, offset 0x8>
		struct tagTLIST* ValidFirstObj;

		// <struct tagTLIST* FreeFirstObj, offset 0xc>
		struct tagTLIST* FreeFirstObj;

		// <struct EFFECTSIMPLEOBJ3PARAM Param, offset 0x10>
		struct EFFECTSIMPLEOBJ3PARAM Param;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectSimpleObj3::MAIN>("EffectSimpleObj3::MAIN")
				.addProperty("ObjNum", &EffectSimpleObj3::MAIN::ObjNum)
				.addProperty("Obj", &EffectSimpleObj3::MAIN::Obj)
				.addProperty("ValidFirstObj", &EffectSimpleObj3::MAIN::ValidFirstObj)
				.addProperty("FreeFirstObj", &EffectSimpleObj3::MAIN::FreeFirstObj)
				.addProperty("Param", &EffectSimpleObj3::MAIN::Param)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectSimpleObj3::MAIN::ObjNum) == 4, "expected ObjNum to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::Obj) == 4, "expected Obj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::ValidFirstObj) == 4, "expected ValidFirstObj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::FreeFirstObj) == 4, "expected FreeFirstObj to be size 4");
	static_assert(sizeof(EffectSimpleObj3::MAIN::Param) == 68, "expected Param to be size 68");
	static_assert(sizeof(struct EffectSimpleObj3::MAIN) == 84, "expected struct EffectSimpleObj3::MAIN to be size 84");

	// struct EffectSimpleObj3::OBJECT
	// no dependencies
	struct OBJECT
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <Filler, offset 0x0>
		char _Filler[68];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectSimpleObj3::OBJECT>("EffectSimpleObj3::OBJECT")
			.endClass();
		}
#endif
	};
	static_assert(sizeof(struct EffectSimpleObj3::OBJECT) == 68, "expected struct EffectSimpleObj3::OBJECT to be size 68");


	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectSimpleObj3::MAIN dat, offset 0x50>
	struct EffectSimpleObj3::MAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectSimpleObj3>("EffectSimpleObj3")
			.addProperty("dat", &EffectSimpleObj3::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSimpleObj3::dat) == 84, "expected dat to be size 84");
static_assert(sizeof(class EffectSimpleObj3) == 164, "expected class EffectSimpleObj3 to be size 164");

// struct tagTLIST
// no dependencies
struct tagTLIST
{
public:
	/// No namespace types
	/// Struct member variables

	// <tagTLIST* Prev, offset 0x0>
	tagTLIST* Prev;

	// <tagTLIST* Next, offset 0x4>
	tagTLIST* Next;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<tagTLIST>("tagTLIST")
			.addProperty("Prev", &tagTLIST::Prev)
			.addProperty("Next", &tagTLIST::Next)
		.endClass();
	}
#endif
};
static_assert(sizeof(tagTLIST::Prev) == 4, "expected Prev to be size 4");
static_assert(sizeof(tagTLIST::Next) == 4, "expected Next to be size 4");
static_assert(sizeof(struct tagTLIST) == 8, "expected struct tagTLIST to be size 8");

// class PJOBJ0036
// 36 dependencies: class commonObj, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT, class FkStlVector<TGmfNode const *>
class PJOBJ0036 : commonObj
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") PJOBJ0036::mSetDamage(class PJOBJ0036* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0036::mSetDamage(class PJOBJ0036* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <uint8_t m_Dead, offset 0x64c>
	uint8_t m_Dead;

	// <uint8_t m_Motion, offset 0x64d>
	uint8_t m_Motion;

	// <uint8_t m_Off, offset 0x64e>
	uint8_t m_Off;

	// <Filler, offset 0x64f>
	char _Filler4[1];

	// <struct Vec m_CenterPos, offset 0x650>
	struct Vec m_CenterPos;

	// <int32_t m_Cnt, offset 0x65c>
	int32_t m_Cnt;

	// <float m_fAccumDmg, offset 0x660>
	float m_fAccumDmg;

	// <float m_fMaxAccumDmg, offset 0x664>
	float m_fMaxAccumDmg;

	// <uint8_t m_boGetBreakNode, offset 0x668>
	uint8_t m_boGetBreakNode;

	// <Filler, offset 0x669>
	char _Filler9[3];

	// <struct tagGHMR_TEX m_Tex, offset 0x66c>
	struct tagGHMR_TEX m_Tex;

	// <class FkStlVector<TGmfNode const *> m_apNode, offset 0x694>
	class FkStlVector<TGmfNode const *> m_apNode;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJOBJ0036>("PJOBJ0036")
			.addProperty("m_Dead", &PJOBJ0036::m_Dead)
			.addProperty("m_Motion", &PJOBJ0036::m_Motion)
			.addProperty("m_Off", &PJOBJ0036::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0036::m_CenterPos)
			.addProperty("m_Cnt", &PJOBJ0036::m_Cnt)
			.addProperty("m_fAccumDmg", &PJOBJ0036::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0036::m_fMaxAccumDmg)
			.addProperty("m_boGetBreakNode", &PJOBJ0036::m_boGetBreakNode)
			.addProperty("m_Tex", &PJOBJ0036::m_Tex)
			.addProperty("m_apNode", &PJOBJ0036::m_apNode)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0036::m_Dead) == 1, "expected m_Dead to be size 1");
static_assert(sizeof(PJOBJ0036::m_Motion) == 1, "expected m_Motion to be size 1");
static_assert(sizeof(PJOBJ0036::m_Off) == 1, "expected m_Off to be size 1");
static_assert(sizeof(PJOBJ0036::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0036::m_Cnt) == 4, "expected m_Cnt to be size 4");
static_assert(sizeof(PJOBJ0036::m_fAccumDmg) == 4, "expected m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0036::m_fMaxAccumDmg) == 4, "expected m_fMaxAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0036::m_boGetBreakNode) == 1, "expected m_boGetBreakNode to be size 1");
static_assert(sizeof(PJOBJ0036::m_Tex) == 40, "expected m_Tex to be size 40");
static_assert(sizeof(PJOBJ0036::m_apNode) == 20, "expected m_apNode to be size 20");
static_assert(sizeof(class PJOBJ0036) == 1704, "expected class PJOBJ0036 to be size 1704");

// class PJOBJ0037
// 29 dependencies: class commonObj, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate
class PJOBJ0037 : commonObj
{
public:
	/// 2 namespace types: uint8_t __convention("thiscall") PJOBJ0037::mSetDamage(class PJOBJ0037* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), uint8_t __convention("thiscall") PJOBJ0037::IsHitChar(class PJOBJ0037* const this, class mHRChara* arg2)

	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0037::mSetDamage(class PJOBJ0037* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0037::IsHitChar(class PJOBJ0037* const this, class mHRChara* arg2)'

	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJOBJ0037>("PJOBJ0037")
		.endClass();
	}
#endif
};
static_assert(sizeof(class PJOBJ0037) == 1612, "expected class PJOBJ0037 to be size 1612");

// class PJOBJ0104
// 29 dependencies: class commonObj, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate
class PJOBJ0104 : commonObj
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") PJOBJ0104::mSetDamage(class PJOBJ0104* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0104::mSetDamage(class PJOBJ0104* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <uint8_t m_Dead, offset 0x64c>
	uint8_t m_Dead;

	// <uint8_t m_Motion, offset 0x64d>
	uint8_t m_Motion;

	// <uint8_t m_Off, offset 0x64e>
	uint8_t m_Off;

	// <Filler, offset 0x64f>
	char _Filler4[1];

	// <struct Vec m_CenterPos, offset 0x650>
	struct Vec m_CenterPos;

	// <class TGmf* m_DamageModel[0x3], offset 0x65c>
	class TGmf* m_DamageModel[3];

	// <class TGan* m_BreakMotion, offset 0x668>
	class TGan* m_BreakMotion;

	// <float m_fAccumDmg, offset 0x66c>
	float m_fAccumDmg;

	// <float m_fMaxAccumDmg, offset 0x670>
	float m_fMaxAccumDmg;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJOBJ0104>("PJOBJ0104")
			.addProperty("m_Dead", &PJOBJ0104::m_Dead)
			.addProperty("m_Motion", &PJOBJ0104::m_Motion)
			.addProperty("m_Off", &PJOBJ0104::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0104::m_CenterPos)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_DamageModel", &PJOBJ0104::m_DamageModel)
			.addProperty("m_BreakMotion", &PJOBJ0104::m_BreakMotion)
			.addProperty("m_fAccumDmg", &PJOBJ0104::m_fAccumDmg)
			.addProperty("m_fMaxAccumDmg", &PJOBJ0104::m_fMaxAccumDmg)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0104::m_Dead) == 1, "expected m_Dead to be size 1");
static_assert(sizeof(PJOBJ0104::m_Motion) == 1, "expected m_Motion to be size 1");
static_assert(sizeof(PJOBJ0104::m_Off) == 1, "expected m_Off to be size 1");
static_assert(sizeof(PJOBJ0104::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0104::m_DamageModel) == 12, "expected m_DamageModel to be size 12");
static_assert(sizeof(PJOBJ0104::m_BreakMotion) == 4, "expected m_BreakMotion to be size 4");
static_assert(sizeof(PJOBJ0104::m_fAccumDmg) == 4, "expected m_fAccumDmg to be size 4");
static_assert(sizeof(PJOBJ0104::m_fMaxAccumDmg) == 4, "expected m_fMaxAccumDmg to be size 4");
static_assert(sizeof(class PJOBJ0104) == 1652, "expected class PJOBJ0104 to be size 1652");

// class PJOBJ0155
// 35 dependencies: class commonObj, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate, struct tagGHMR_TEX, struct GXTexObj, enum GHMR_TEXADDRESS, enum GHMR_TEXFILTER, enum _GXTexFmt, enum GHMR_TEXDOT_ASPECT
class PJOBJ0155 : commonObj
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") PJOBJ0155::mSetDamage(class PJOBJ0155* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0155::mSetDamage(class PJOBJ0155* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <int32_t m_AlphaVisibleCnt, offset 0x64c>
	int32_t m_AlphaVisibleCnt;

	// <int32_t m_AlphaVisibleFrmMax, offset 0x650>
	int32_t m_AlphaVisibleFrmMax;

	// <uint8_t m_Dead, offset 0x654>
	uint8_t m_Dead;

	// <uint8_t m_Motion, offset 0x655>
	uint8_t m_Motion;

	// <uint8_t m_Off, offset 0x656>
	uint8_t m_Off;

	// <Filler, offset 0x657>
	char _Filler6[1];

	// <struct Vec m_CenterPos, offset 0x658>
	struct Vec m_CenterPos;

	// <int32_t m_Counter, offset 0x664>
	int32_t m_Counter;

	// <int32_t m_nPipe, offset 0x668>
	int32_t m_nPipe;

	// <struct tagGHMR_TEX m_Tex, offset 0x66c>
	struct tagGHMR_TEX m_Tex;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJOBJ0155>("PJOBJ0155")
			.addProperty("m_AlphaVisibleCnt", &PJOBJ0155::m_AlphaVisibleCnt)
			.addProperty("m_AlphaVisibleFrmMax", &PJOBJ0155::m_AlphaVisibleFrmMax)
			.addProperty("m_Dead", &PJOBJ0155::m_Dead)
			.addProperty("m_Motion", &PJOBJ0155::m_Motion)
			.addProperty("m_Off", &PJOBJ0155::m_Off)
			.addProperty("m_CenterPos", &PJOBJ0155::m_CenterPos)
			.addProperty("m_Counter", &PJOBJ0155::m_Counter)
			.addProperty("m_nPipe", &PJOBJ0155::m_nPipe)
			.addProperty("m_Tex", &PJOBJ0155::m_Tex)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0155::m_AlphaVisibleCnt) == 4, "expected m_AlphaVisibleCnt to be size 4");
static_assert(sizeof(PJOBJ0155::m_AlphaVisibleFrmMax) == 4, "expected m_AlphaVisibleFrmMax to be size 4");
static_assert(sizeof(PJOBJ0155::m_Dead) == 1, "expected m_Dead to be size 1");
static_assert(sizeof(PJOBJ0155::m_Motion) == 1, "expected m_Motion to be size 1");
static_assert(sizeof(PJOBJ0155::m_Off) == 1, "expected m_Off to be size 1");
static_assert(sizeof(PJOBJ0155::m_CenterPos) == 12, "expected m_CenterPos to be size 12");
static_assert(sizeof(PJOBJ0155::m_Counter) == 4, "expected m_Counter to be size 4");
static_assert(sizeof(PJOBJ0155::m_nPipe) == 4, "expected m_nPipe to be size 4");
static_assert(sizeof(PJOBJ0155::m_Tex) == 40, "expected m_Tex to be size 40");
static_assert(sizeof(class PJOBJ0155) == 1684, "expected class PJOBJ0155 to be size 1684");

// class PJOBJ0190
// 29 dependencies: class commonObj, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, class WGcl, class CTimeRatioInterpolate
class PJOBJ0190 : commonObj
{
public:
	/// 2 namespace types: uint8_t __convention("thiscall") PJOBJ0190::mSetDamage(class PJOBJ0190* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11), uint8_t __convention("thiscall") PJOBJ0190::mSetDamage(class PJOBJ0190* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0190::mSetDamage(class PJOBJ0190* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10, float arg11)'
	// TODO: Function 'uint8_t __convention("thiscall") PJOBJ0190::mSetDamage(class PJOBJ0190* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <class commonObj field_0, offset 0x0>
	// class commonObj Super;

	// <class TGmfNode* mpTopNode, offset 0x64c>
	class TGmfNode* mpTopNode;

	// <uint8_t mbBreak, offset 0x650>
	uint8_t mbBreak;

	// <Filler, offset 0x651>
	char _Filler3[3];

	// <float mRadius, offset 0x654>
	float mRadius;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJOBJ0190>("PJOBJ0190")
			.addProperty("mpTopNode", &PJOBJ0190::mpTopNode)
			.addProperty("mbBreak", &PJOBJ0190::mbBreak)
			.addProperty("mRadius", &PJOBJ0190::mRadius)
		.endClass();
	}
#endif
};
static_assert(sizeof(PJOBJ0190::mpTopNode) == 4, "expected mpTopNode to be size 4");
static_assert(sizeof(PJOBJ0190::mbBreak) == 1, "expected mbBreak to be size 1");
static_assert(sizeof(PJOBJ0190::mRadius) == 4, "expected mRadius to be size 4");
static_assert(sizeof(class PJOBJ0190) == 1624, "expected class PJOBJ0190 to be size 1624");

// class PJPTR
// no dependencies
class PJPTR
{
public:
	/// 1 namespace types: uint8_t __convention("thiscall") PJPTR::mSetDamage(class PJPTR* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)

	// TODO: Function 'uint8_t __convention("thiscall") PJPTR::mSetDamage(class PJPTR* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[1668];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<PJPTR>("PJPTR")
		.endClass();
	}
#endif
};
static_assert(sizeof(class PJPTR) == 1668, "expected class PJPTR to be size 1668");

// TODO: Function 'class EffectCutMark* EffectCutMark::Create(class TGmf* arg1, class mHRChara* arg2, struct Vec* arg3, uint32_t const arg4, enum eEfDmgLevel& arg5, enum EffectCutMark::eCutMarkType& arg6, float const arg7)'
// class EffectEnemyDamage
// 1 dependencies: class HrTask
class EffectEnemyDamage : HrTask
{
public:
	/// 1 namespace types: class EffectEnemyDamage* EffectEnemyDamage::Create(class mHRChara* arg1, class TGmf* arg2, int32_t arg3, uint32_t const arg4)

	// TODO: Function 'class EffectEnemyDamage* EffectEnemyDamage::Create(class mHRChara* arg1, class TGmf* arg2, int32_t arg3, uint32_t const arg4)'

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pChara, offset 0x50>
	class mHRChara* m_pChara;

	// <class TGmf* m_pGmf, offset 0x54>
	class TGmf* m_pGmf;

	// <int32_t m_nUpSpeed, offset 0x58>
	int32_t m_nUpSpeed;

	// <uint32_t m_nColorMin, offset 0x5c>
	uint32_t m_nColorMin;

	// <int32_t m_nBright, offset 0x60>
	int32_t m_nBright;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectEnemyDamage>("EffectEnemyDamage")
			.addProperty("m_pChara", &EffectEnemyDamage::m_pChara)
			.addProperty("m_pGmf", &EffectEnemyDamage::m_pGmf)
			.addProperty("m_nUpSpeed", &EffectEnemyDamage::m_nUpSpeed)
			.addProperty("m_nColorMin", &EffectEnemyDamage::m_nColorMin)
			.addProperty("m_nBright", &EffectEnemyDamage::m_nBright)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectEnemyDamage::m_pChara) == 4, "expected m_pChara to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_pGmf) == 4, "expected m_pGmf to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nUpSpeed) == 4, "expected m_nUpSpeed to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nColorMin) == 4, "expected m_nColorMin to be size 4");
static_assert(sizeof(EffectEnemyDamage::m_nBright) == 4, "expected m_nBright to be size 4");
static_assert(sizeof(class EffectEnemyDamage) == 100, "expected class EffectEnemyDamage to be size 100");

// TODO: Function 'void mHRCharaVoiceTable_Initialize()'
// struct FkDbgInfo_EventArea
// 1 dependencies: struct Vec
struct FkDbgInfo_EventArea
{
public:
	/// No namespace types
	/// Struct member variables

	// <float fRadius, offset 0x0>
	float fRadius;

	// <struct Vec CenterPos, offset 0x4>
	struct Vec CenterPos;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkDbgInfo_EventArea>("FkDbgInfo_EventArea")
			.addProperty("fRadius", &FkDbgInfo_EventArea::fRadius)
			.addProperty("CenterPos", &FkDbgInfo_EventArea::CenterPos)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkDbgInfo_EventArea::fRadius) == 4, "expected fRadius to be size 4");
static_assert(sizeof(FkDbgInfo_EventArea::CenterPos) == 12, "expected CenterPos to be size 12");
static_assert(sizeof(struct FkDbgInfo_EventArea) == 16, "expected struct FkDbgInfo_EventArea to be size 16");

// class FkGlobalDBG
// 3 dependencies: struct FkDbgInfo_EventArea, struct Vec, struct FkGlobalDBG::CommonObjSetInf
class FkGlobalDBG
{
public:
	/// 2 namespace types: void __convention("thiscall") FkGlobalDBG::ReleaseCtrlChar(class FkGlobalDBG* const this, class mHRChara* arg2), struct FkGlobalDBG::CommonObjSetInf

	// TODO: Function 'void __convention("thiscall") FkGlobalDBG::ReleaseCtrlChar(class FkGlobalDBG* const this, class mHRChara* arg2)'
	// struct FkGlobalDBG::CommonObjSetInf
	// 1 dependencies: struct Vec
	struct CommonObjSetInf
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t iNowCursor, offset 0x0>
		int32_t iNowCursor;

		// <uint32_t nObjRegist, offset 0x4>
		uint32_t nObjRegist;

		// <struct Vec SetPos, offset 0x8>
		struct Vec SetPos;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkGlobalDBG::CommonObjSetInf>("FkGlobalDBG::CommonObjSetInf")
				.addProperty("iNowCursor", &FkGlobalDBG::CommonObjSetInf::iNowCursor)
				.addProperty("nObjRegist", &FkGlobalDBG::CommonObjSetInf::nObjRegist)
				.addProperty("SetPos", &FkGlobalDBG::CommonObjSetInf::SetPos)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::iNowCursor) == 4, "expected iNowCursor to be size 4");
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::nObjRegist) == 4, "expected nObjRegist to be size 4");
	static_assert(sizeof(FkGlobalDBG::CommonObjSetInf::SetPos) == 12, "expected SetPos to be size 12");
	static_assert(sizeof(struct FkGlobalDBG::CommonObjSetInf) == 20, "expected struct FkGlobalDBG::CommonObjSetInf to be size 20");


	/// Struct member variables

	// <struct FkDbgInfo_EventArea m_EventAreaDbgInfo, offset 0x0>
	struct FkDbgInfo_EventArea m_EventAreaDbgInfo;

	// <class PathPlanner* m_pPathPlanner, offset 0x10>
	class PathPlanner* m_pPathPlanner;

	// <Filler, offset 0x14>
	char _Filler2[4];

	// <uint64_t m_PathPlanningTime, offset 0x18>
	uint64_t m_PathPlanningTime;

	// <class mHRChara* m_pCtrlChar, offset 0x20>
	class mHRChara* m_pCtrlChar;

	// <struct FkGlobalDBG::CommonObjSetInf m_CmnObjSetInf, offset 0x24>
	struct FkGlobalDBG::CommonObjSetInf m_CmnObjSetInf;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkGlobalDBG>("FkGlobalDBG")
			.addProperty("m_EventAreaDbgInfo", &FkGlobalDBG::m_EventAreaDbgInfo)
			.addProperty("m_pPathPlanner", &FkGlobalDBG::m_pPathPlanner)
			.addProperty("m_PathPlanningTime", &FkGlobalDBG::m_PathPlanningTime)
			.addProperty("m_pCtrlChar", &FkGlobalDBG::m_pCtrlChar)
			.addProperty("m_CmnObjSetInf", &FkGlobalDBG::m_CmnObjSetInf)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkGlobalDBG::m_EventAreaDbgInfo) == 16, "expected m_EventAreaDbgInfo to be size 16");
static_assert(sizeof(FkGlobalDBG::m_pPathPlanner) == 4, "expected m_pPathPlanner to be size 4");
static_assert(sizeof(FkGlobalDBG::m_PathPlanningTime) == 8, "expected m_PathPlanningTime to be size 8");
static_assert(sizeof(FkGlobalDBG::m_pCtrlChar) == 4, "expected m_pCtrlChar to be size 4");
static_assert(sizeof(FkGlobalDBG::m_CmnObjSetInf) == 20, "expected m_CmnObjSetInf to be size 20");
static_assert(sizeof(class FkGlobalDBG) == 56, "expected class FkGlobalDBG to be size 56");

// class EffectBloodSplash
// 3 dependencies: class HrTask, struct EffectBloodSplash::MAIN, struct Vec
class EffectBloodSplash : HrTask
{
public:
	/// 3 namespace types: class EffectBloodSplash* EffectBloodSplash::Create(class TGmfNode* arg1, int32_t arg2, int32_t arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13, float arg14, int32_t arg15, float arg16, int32_t arg17, float arg18, float arg19, float arg20, float arg21, float arg22, float arg23, float arg24, float arg25, float arg26, float arg27, uint32_t arg28, uint8_t arg29, class mHRChara* arg30), struct EffectBloodSplash::MAIN, class EffectBloodSplash* EffectBloodSplash::Create2(class TGmfNode* arg1, float arg2, float arg3, float arg4, float arg5, int32_t arg6, uint8_t arg7, class mHRChara* arg8)

	// TODO: Function 'class EffectBloodSplash* EffectBloodSplash::Create(class TGmfNode* arg1, int32_t arg2, int32_t arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13, float arg14, int32_t arg15, float arg16, int32_t arg17, float arg18, float arg19, float arg20, float arg21, float arg22, float arg23, float arg24, float arg25, float arg26, float arg27, uint32_t arg28, uint8_t arg29, class mHRChara* arg30)'
	// struct EffectBloodSplash::MAIN
	// 1 dependencies: struct Vec
	struct MAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <class TGmfNode* Node, offset 0x0>
		class TGmfNode* Node;

		// <class EffectSimpleObj2* Line, offset 0x4>
		class EffectSimpleObj2* Line;

		// <struct TGMFMESH** MeshList, offset 0x8>
		struct TGMFMESH** MeshList;

		// <float AreaSize, offset 0xc>
		float AreaSize;

		// <float MaxSpeed, offset 0x10>
		float MaxSpeed;

		// <float MinSpeed, offset 0x14>
		float MinSpeed;

		// <float MaxWidth, offset 0x18>
		float MaxWidth;

		// <float MinWidth, offset 0x1c>
		float MinWidth;

		// <float MaxSize, offset 0x20>
		float MaxSize;

		// <float MinSize, offset 0x24>
		float MinSize;

		// <float Length, offset 0x28>
		float Length;

		// <float Width, offset 0x2c>
		float Width;

		// <float CreateRate, offset 0x30>
		float CreateRate;

		// <float TimeCounter, offset 0x34>
		float TimeCounter;

		// <float Time, offset 0x38>
		float Time;

		// <float FadeTime, offset 0x3c>
		float FadeTime;

		// <float SpeedRate, offset 0x40>
		float SpeedRate;

		// <float SpeedRate2, offset 0x44>
		float SpeedRate2;

		// <int32_t MinRangeCounter, offset 0x48>
		int32_t MinRangeCounter;

		// <int32_t MinRangeSpeed, offset 0x4c>
		int32_t MinRangeSpeed;

		// <int32_t MinRangeSpeedTime, offset 0x50>
		int32_t MinRangeSpeedTime;

		// <float MinRimitSpeed, offset 0x54>
		float MinRimitSpeed;

		// <float MinCreateRate, offset 0x58>
		float MinCreateRate;

		// <float CenterRate, offset 0x5c>
		float CenterRate;

		// <float FadeSpeed, offset 0x60>
		float FadeSpeed;

		// <float FadeSpeed2, offset 0x64>
		float FadeSpeed2;

		// <float MinRange, offset 0x68>
		float MinRange;

		// <float DirRange, offset 0x6c>
		float DirRange;

		// <float FadeTime2CreateRate, offset 0x70>
		float FadeTime2CreateRate;

		// <float FadeTime2SpeedRate, offset 0x74>
		float FadeTime2SpeedRate;

		// <float FadeTime2, offset 0x78>
		float FadeTime2;

		// <struct Vec Pos, offset 0x7c>
		struct Vec Pos;

		// <struct Vec Dir, offset 0x88>
		struct Vec Dir;

		// <uint8_t DirValid, offset 0x94>
		uint8_t DirValid;

		// <uint8_t AddStopFlag, offset 0x95>
		uint8_t AddStopFlag;

		// <Filler, offset 0x96>
		char _Filler35[2];

		// <int32_t id, offset 0x98>
		int32_t id;

		// <class mHRChara* pOwner, offset 0x9c>
		class mHRChara* pOwner;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectBloodSplash::MAIN>("EffectBloodSplash::MAIN")
				.addProperty("Node", &EffectBloodSplash::MAIN::Node)
				.addProperty("Line", &EffectBloodSplash::MAIN::Line)
				// pointer to pointer is not supported in LuaBridge
				//.addProperty("MeshList", &EffectBloodSplash::MAIN::MeshList)
				.addProperty("AreaSize", &EffectBloodSplash::MAIN::AreaSize)
				.addProperty("MaxSpeed", &EffectBloodSplash::MAIN::MaxSpeed)
				.addProperty("MinSpeed", &EffectBloodSplash::MAIN::MinSpeed)
				.addProperty("MaxWidth", &EffectBloodSplash::MAIN::MaxWidth)
				.addProperty("MinWidth", &EffectBloodSplash::MAIN::MinWidth)
				.addProperty("MaxSize", &EffectBloodSplash::MAIN::MaxSize)
				.addProperty("MinSize", &EffectBloodSplash::MAIN::MinSize)
				.addProperty("Length", &EffectBloodSplash::MAIN::Length)
				.addProperty("Width", &EffectBloodSplash::MAIN::Width)
				.addProperty("CreateRate", &EffectBloodSplash::MAIN::CreateRate)
				.addProperty("TimeCounter", &EffectBloodSplash::MAIN::TimeCounter)
				.addProperty("Time", &EffectBloodSplash::MAIN::Time)
				.addProperty("FadeTime", &EffectBloodSplash::MAIN::FadeTime)
				.addProperty("SpeedRate", &EffectBloodSplash::MAIN::SpeedRate)
				.addProperty("SpeedRate2", &EffectBloodSplash::MAIN::SpeedRate2)
				.addProperty("MinRangeCounter", &EffectBloodSplash::MAIN::MinRangeCounter)
				.addProperty("MinRangeSpeed", &EffectBloodSplash::MAIN::MinRangeSpeed)
				.addProperty("MinRangeSpeedTime", &EffectBloodSplash::MAIN::MinRangeSpeedTime)
				.addProperty("MinRimitSpeed", &EffectBloodSplash::MAIN::MinRimitSpeed)
				.addProperty("MinCreateRate", &EffectBloodSplash::MAIN::MinCreateRate)
				.addProperty("CenterRate", &EffectBloodSplash::MAIN::CenterRate)
				.addProperty("FadeSpeed", &EffectBloodSplash::MAIN::FadeSpeed)
				.addProperty("FadeSpeed2", &EffectBloodSplash::MAIN::FadeSpeed2)
				.addProperty("MinRange", &EffectBloodSplash::MAIN::MinRange)
				.addProperty("DirRange", &EffectBloodSplash::MAIN::DirRange)
				.addProperty("FadeTime2CreateRate", &EffectBloodSplash::MAIN::FadeTime2CreateRate)
				.addProperty("FadeTime2SpeedRate", &EffectBloodSplash::MAIN::FadeTime2SpeedRate)
				.addProperty("FadeTime2", &EffectBloodSplash::MAIN::FadeTime2)
				.addProperty("Pos", &EffectBloodSplash::MAIN::Pos)
				.addProperty("Dir", &EffectBloodSplash::MAIN::Dir)
				.addProperty("DirValid", &EffectBloodSplash::MAIN::DirValid)
				.addProperty("AddStopFlag", &EffectBloodSplash::MAIN::AddStopFlag)
				.addProperty("id", &EffectBloodSplash::MAIN::id)
				.addProperty("pOwner", &EffectBloodSplash::MAIN::pOwner)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(EffectBloodSplash::MAIN::Node) == 4, "expected Node to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Line) == 4, "expected Line to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MeshList) == 4, "expected MeshList to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::AreaSize) == 4, "expected AreaSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxSpeed) == 4, "expected MaxSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinSpeed) == 4, "expected MinSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxWidth) == 4, "expected MaxWidth to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinWidth) == 4, "expected MinWidth to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MaxSize) == 4, "expected MaxSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinSize) == 4, "expected MinSize to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Length) == 4, "expected Length to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Width) == 4, "expected Width to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::CreateRate) == 4, "expected CreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::TimeCounter) == 4, "expected TimeCounter to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Time) == 4, "expected Time to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime) == 4, "expected FadeTime to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::SpeedRate) == 4, "expected SpeedRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::SpeedRate2) == 4, "expected SpeedRate2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeCounter) == 4, "expected MinRangeCounter to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeSpeed) == 4, "expected MinRangeSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRangeSpeedTime) == 4, "expected MinRangeSpeedTime to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRimitSpeed) == 4, "expected MinRimitSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinCreateRate) == 4, "expected MinCreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::CenterRate) == 4, "expected CenterRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeSpeed) == 4, "expected FadeSpeed to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeSpeed2) == 4, "expected FadeSpeed2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::MinRange) == 4, "expected MinRange to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::DirRange) == 4, "expected DirRange to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2CreateRate) == 4, "expected FadeTime2CreateRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2SpeedRate) == 4, "expected FadeTime2SpeedRate to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::FadeTime2) == 4, "expected FadeTime2 to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::Pos) == 12, "expected Pos to be size 12");
	static_assert(sizeof(EffectBloodSplash::MAIN::Dir) == 12, "expected Dir to be size 12");
	static_assert(sizeof(EffectBloodSplash::MAIN::DirValid) == 1, "expected DirValid to be size 1");
	static_assert(sizeof(EffectBloodSplash::MAIN::AddStopFlag) == 1, "expected AddStopFlag to be size 1");
	static_assert(sizeof(EffectBloodSplash::MAIN::id) == 4, "expected id to be size 4");
	static_assert(sizeof(EffectBloodSplash::MAIN::pOwner) == 4, "expected pOwner to be size 4");
	static_assert(sizeof(struct EffectBloodSplash::MAIN) == 160, "expected struct EffectBloodSplash::MAIN to be size 160");

	// TODO: Function 'class EffectBloodSplash* EffectBloodSplash::Create2(class TGmfNode* arg1, float arg2, float arg3, float arg4, float arg5, int32_t arg6, uint8_t arg7, class mHRChara* arg8)'

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <float m_fCreateNum, offset 0x50>
	float m_fCreateNum;

	// <struct EffectBloodSplash::MAIN dat, offset 0x54>
	struct EffectBloodSplash::MAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectBloodSplash>("EffectBloodSplash")
			.addProperty("m_fCreateNum", &EffectBloodSplash::m_fCreateNum)
			.addProperty("dat", &EffectBloodSplash::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectBloodSplash::m_fCreateNum) == 4, "expected m_fCreateNum to be size 4");
static_assert(sizeof(EffectBloodSplash::dat) == 160, "expected dat to be size 160");
static_assert(sizeof(class EffectBloodSplash) == 244, "expected class EffectBloodSplash to be size 244");

// class EffectSimpleObj2
// 2 dependencies: class HrTask, struct EffectSimpleObj2::MAIN
class EffectSimpleObj2 : HrTask
{
public:
	/// 1 namespace types: struct EffectSimpleObj2::MAIN

	// struct EffectSimpleObj2::MAIN
	// no dependencies
	struct MAIN
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <Filler, offset 0x0>
		char _Filler[176];

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<EffectSimpleObj2::MAIN>("EffectSimpleObj2::MAIN")
			.endClass();
		}
#endif
	};
	static_assert(sizeof(struct EffectSimpleObj2::MAIN) == 176, "expected struct EffectSimpleObj2::MAIN to be size 176");


	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct EffectSimpleObj2::MAIN dat, offset 0x50>
	struct EffectSimpleObj2::MAIN dat;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectSimpleObj2>("EffectSimpleObj2")
			.addProperty("dat", &EffectSimpleObj2::dat)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSimpleObj2::dat) == 176, "expected dat to be size 176");
static_assert(sizeof(class EffectSimpleObj2) == 256, "expected class EffectSimpleObj2 to be size 256");

// enum eEfDmgLevel
enum eEfDmgLevel : uint32_t
{
	// Enum values

	// <eEfDmgLevel_UNKNOWN = 0xffffffffffffffff>
	eEfDmgLevel_UNKNOWN = UINT32_MAX,

	// <eEfDmgLevel_Small = 0x0>
	eEfDmgLevel_Small = 0,

	// <eEfDmgLevel_Big = 0x1>
	eEfDmgLevel_Big = 1,

	// <eEfDmgLevel_Slash = 0x2>
	eEfDmgLevel_Slash = 2,

	// <eEfDmgLevel_NUM = 0x3>
	eEfDmgLevel_NUM = 3

};

// class EffectSlashHit
// 3 dependencies: class HrTask, struct Vec, enum eEfDmgLevel
class EffectSlashHit : HrTask
{
public:
	/// 1 namespace types: class EffectSlashHit* EffectSlashHit::Create(struct Vec& arg1, struct Vec& arg2, class mHRChara* arg3, float const arg4)

	// TODO: Function 'class EffectSlashHit* EffectSlashHit::Create(struct Vec& arg1, struct Vec& arg2, class mHRChara* arg3, float const arg4)'

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <struct Vec m_SlashVec, offset 0x50>
	struct Vec m_SlashVec;

	// <struct Vec m_SlashPlnNrm, offset 0x5c>
	struct Vec m_SlashPlnNrm;

	// <class mHRChara* m_pChara, offset 0x68>
	class mHRChara* m_pChara;

	// <struct Vec m_Pos, offset 0x6c>
	struct Vec m_Pos;

	// <enum eEfDmgLevel m_eDamageLevel, offset 0x78>
	enum eEfDmgLevel m_eDamageLevel;

	// <uint32_t m_nColor, offset 0x7c>
	uint32_t m_nColor;

	// <int32_t m_nCounter, offset 0x80>
	int32_t m_nCounter;

	// <float m_fScale, offset 0x84>
	float m_fScale;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectSlashHit>("EffectSlashHit")
			.addProperty("m_SlashVec", &EffectSlashHit::m_SlashVec)
			.addProperty("m_SlashPlnNrm", &EffectSlashHit::m_SlashPlnNrm)
			.addProperty("m_pChara", &EffectSlashHit::m_pChara)
			.addProperty("m_Pos", &EffectSlashHit::m_Pos)
			.addProperty("m_eDamageLevel", &EffectSlashHit::m_eDamageLevel)
			.addProperty("m_nColor", &EffectSlashHit::m_nColor)
			.addProperty("m_nCounter", &EffectSlashHit::m_nCounter)
			.addProperty("m_fScale", &EffectSlashHit::m_fScale)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectSlashHit::m_SlashVec) == 12, "expected m_SlashVec to be size 12");
static_assert(sizeof(EffectSlashHit::m_SlashPlnNrm) == 12, "expected m_SlashPlnNrm to be size 12");
static_assert(sizeof(EffectSlashHit::m_pChara) == 4, "expected m_pChara to be size 4");
static_assert(sizeof(EffectSlashHit::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectSlashHit::m_eDamageLevel) == 4, "expected m_eDamageLevel to be size 4");
static_assert(sizeof(EffectSlashHit::m_nColor) == 4, "expected m_nColor to be size 4");
static_assert(sizeof(EffectSlashHit::m_nCounter) == 4, "expected m_nCounter to be size 4");
static_assert(sizeof(EffectSlashHit::m_fScale) == 4, "expected m_fScale to be size 4");
static_assert(sizeof(class EffectSlashHit) == 136, "expected class EffectSlashHit to be size 136");

// class FkBoss
// 39 dependencies: class bsBasic, class mHRChara, class ghmListObj, struct stCharaStatus, enum enCharaType, struct Vec, struct Quaternion, struct stVec, class WAnimF, class WAnim, enum enCharaCondition, class ghmGcCollObjHitResultObj, class ghmPlane, class ghmTriangle, struct stDamageInfo, class ghmGcCollObjCapsule, class ghmGcCollObj, class ghmGcOctTreeNodeObj, enum ghmGcCollObj::Type, class ghmCapsule, class ghmSegment, class stCharaFileData, struct stCharaEffect, class CAmbientShadow, class CDoubleSpringInterpolate, class CSpringInterpolate, enum enCharaInitProc, struct bsBasic::PcInfo, struct bsBasic::SurroundInfo, struct bsBasic::DistSense, struct bsBasic::TickCnt, struct bsBasic::BattleParam, struct bsBasic::DmgInfo, class KrStateMachine<bsBasic,32>, class PathPlanner, struct FkBoss::GuardParam, enum FightSpirit, enum FkBoss::eReqAvoidDir, class FkStlVector<Vec>
class FkBoss : bsBasic
{
public:
	/// 3 namespace types: uint8_t __convention("thiscall") FkBoss::mSetDamage(class FkBoss* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10), struct FkBoss::GuardParam, enum FkBoss::eReqAvoidDir

	// TODO: Function 'uint8_t __convention("thiscall") FkBoss::mSetDamage(class FkBoss* const this, float arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6, int32_t arg7, float arg8, float arg9, class mHRChara* arg10)'
	// struct FkBoss::GuardParam
	// no dependencies
	struct GuardParam
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t GuardBeginCnt, offset 0x0>
		int32_t GuardBeginCnt;

		// <int32_t GuardContinueCnt, offset 0x4>
		int32_t GuardContinueCnt;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<FkBoss::GuardParam>("FkBoss::GuardParam")
				.addProperty("GuardBeginCnt", &FkBoss::GuardParam::GuardBeginCnt)
				.addProperty("GuardContinueCnt", &FkBoss::GuardParam::GuardContinueCnt)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(FkBoss::GuardParam::GuardBeginCnt) == 4, "expected GuardBeginCnt to be size 4");
	static_assert(sizeof(FkBoss::GuardParam::GuardContinueCnt) == 4, "expected GuardContinueCnt to be size 4");
	static_assert(sizeof(struct FkBoss::GuardParam) == 8, "expected struct FkBoss::GuardParam to be size 8");

	// enum FkBoss::eReqAvoidDir
	enum eReqAvoidDir : uint32_t
	{
		// Enum values

		// <eReqAvoidDir_UNKNOWN = 0xffffffffffffffff>
		eReqAvoidDir_UNKNOWN = UINT32_MAX,

		// <eReqAvoidDir_Side = 0x0>
		eReqAvoidDir_Side = 0,

		// <eReqAvoidDir_Back = 0x1>
		eReqAvoidDir_Back = 1

	};


	/// Struct member variables

	// <class bsBasic field_0, offset 0x0>
	// class bsBasic Super;

	// <int32_t m_ContinueAvoidNum, offset 0xc84>
	int32_t m_ContinueAvoidNum;

	// <int32_t m_GeneralComboAttackArray[0x5][0xa], offset 0xc88>
	int32_t m_GeneralComboAttackArray[5][10];

	// <struct FkBoss::GuardParam m_GuardParam, offset 0xd50>
	struct FkBoss::GuardParam m_GuardParam;

	// <int32_t m_ThinkCnt, offset 0xd58>
	int32_t m_ThinkCnt;

	// <int32_t m_AttackCnt, offset 0xd5c>
	int32_t m_AttackCnt;

	// <enum FightSpirit m_FightSpirit, offset 0xd60>
	enum FightSpirit m_FightSpirit;

	// <int32_t m_ContinueDamageNum, offset 0xd64>
	int32_t m_ContinueDamageNum;

	// <int32_t m_ContinueGuardNum, offset 0xd68>
	int32_t m_ContinueGuardNum;

	// <enum FkBoss::eReqAvoidDir m_eReqAvoidDir, offset 0xd6c>
	enum FkBoss::eReqAvoidDir m_eReqAvoidDir;

	// <uint8_t m_boNoEfGuard, offset 0xd70>
	uint8_t m_boNoEfGuard;

	// <Filler, offset 0xd71>
	char _Filler11[3];

	// <struct Vec m_FrontDir, offset 0xd74>
	struct Vec m_FrontDir;

	// <class FkStlVector<Vec> m_RunAwayPointArr, offset 0xd80>
	class FkStlVector<Vec> m_RunAwayPointArr;

	// <int32_t m_ComboAttackNo, offset 0xd94>
	int32_t m_ComboAttackNo;

	// <int32_t m_SafetyStateChangeTick, offset 0xd98>
	int32_t m_SafetyStateChangeTick;

	// <float m_fEventAccumDamage, offset 0xd9c>
	float m_fEventAccumDamage;

	// <struct tagGHMR_TEX* m_apTex[0x1], offset 0xda0>
	struct tagGHMR_TEX* m_apTex[1];

	// <class EffectSlashTrack* m_pEfSamasoTrack[0x2], offset 0xda4>
	class EffectSlashTrack* m_pEfSamasoTrack[2];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<FkBoss>("FkBoss")
			.addProperty("m_ContinueAvoidNum", &FkBoss::m_ContinueAvoidNum)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_GeneralComboAttackArray", &FkBoss::m_GeneralComboAttackArray)
			.addProperty("m_GuardParam", &FkBoss::m_GuardParam)
			.addProperty("m_ThinkCnt", &FkBoss::m_ThinkCnt)
			.addProperty("m_AttackCnt", &FkBoss::m_AttackCnt)
			.addProperty("m_FightSpirit", &FkBoss::m_FightSpirit)
			.addProperty("m_ContinueDamageNum", &FkBoss::m_ContinueDamageNum)
			.addProperty("m_ContinueGuardNum", &FkBoss::m_ContinueGuardNum)
			.addProperty("m_eReqAvoidDir", &FkBoss::m_eReqAvoidDir)
			.addProperty("m_boNoEfGuard", &FkBoss::m_boNoEfGuard)
			.addProperty("m_FrontDir", &FkBoss::m_FrontDir)
			.addProperty("m_RunAwayPointArr", &FkBoss::m_RunAwayPointArr)
			.addProperty("m_ComboAttackNo", &FkBoss::m_ComboAttackNo)
			.addProperty("m_SafetyStateChangeTick", &FkBoss::m_SafetyStateChangeTick)
			.addProperty("m_fEventAccumDamage", &FkBoss::m_fEventAccumDamage)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_apTex", &FkBoss::m_apTex)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_pEfSamasoTrack", &FkBoss::m_pEfSamasoTrack)
		.endClass();
	}
#endif
};
static_assert(sizeof(FkBoss::m_ContinueAvoidNum) == 4, "expected m_ContinueAvoidNum to be size 4");
static_assert(sizeof(FkBoss::m_GeneralComboAttackArray) == 200, "expected m_GeneralComboAttackArray to be size 200");
static_assert(sizeof(FkBoss::m_GuardParam) == 8, "expected m_GuardParam to be size 8");
static_assert(sizeof(FkBoss::m_ThinkCnt) == 4, "expected m_ThinkCnt to be size 4");
static_assert(sizeof(FkBoss::m_AttackCnt) == 4, "expected m_AttackCnt to be size 4");
static_assert(sizeof(FkBoss::m_FightSpirit) == 4, "expected m_FightSpirit to be size 4");
static_assert(sizeof(FkBoss::m_ContinueDamageNum) == 4, "expected m_ContinueDamageNum to be size 4");
static_assert(sizeof(FkBoss::m_ContinueGuardNum) == 4, "expected m_ContinueGuardNum to be size 4");
static_assert(sizeof(FkBoss::m_eReqAvoidDir) == 4, "expected m_eReqAvoidDir to be size 4");
static_assert(sizeof(FkBoss::m_boNoEfGuard) == 1, "expected m_boNoEfGuard to be size 1");
static_assert(sizeof(FkBoss::m_FrontDir) == 12, "expected m_FrontDir to be size 12");
static_assert(sizeof(FkBoss::m_RunAwayPointArr) == 20, "expected m_RunAwayPointArr to be size 20");
static_assert(sizeof(FkBoss::m_ComboAttackNo) == 4, "expected m_ComboAttackNo to be size 4");
static_assert(sizeof(FkBoss::m_SafetyStateChangeTick) == 4, "expected m_SafetyStateChangeTick to be size 4");
static_assert(sizeof(FkBoss::m_fEventAccumDamage) == 4, "expected m_fEventAccumDamage to be size 4");
static_assert(sizeof(FkBoss::m_apTex) == 4, "expected m_apTex to be size 4");
static_assert(sizeof(FkBoss::m_pEfSamasoTrack) == 8, "expected m_pEfSamasoTrack to be size 8");
static_assert(sizeof(class FkBoss) == 3500, "expected class FkBoss to be size 3500");

// class EffectSlashTrack
// no dependencies
class EffectSlashTrack
{
public:
	/// No namespace types
	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[944];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectSlashTrack>("EffectSlashTrack")
		.endClass();
	}
#endif
};
static_assert(sizeof(class EffectSlashTrack) == 944, "expected class EffectSlashTrack to be size 944");

// class EffectBeamDragon
// no dependencies
class EffectBeamDragon
{
public:
	/// 2 namespace types: void __convention("thiscall") EffectBeamDragon::Set(class EffectBeamDragon* const this, struct Vec* arg2, class mHRChara* arg3), class EffectBeamDragon* EffectBeamDragon::Create(struct Vec* arg1, class mHRChara* arg2)

	// TODO: Function 'void __convention("thiscall") EffectBeamDragon::Set(class EffectBeamDragon* const this, struct Vec* arg2, class mHRChara* arg3)'
	// TODO: Function 'class EffectBeamDragon* EffectBeamDragon::Create(struct Vec* arg1, class mHRChara* arg2)'

	/// Struct member variables

	// <Filler, offset 0x0>
	char _Filler[520];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectBeamDragon>("EffectBeamDragon")
		.endClass();
	}
#endif
};
static_assert(sizeof(class EffectBeamDragon) == 520, "expected class EffectBeamDragon to be size 520");

// class EffectGYNMissile
// 2 dependencies: class HrTask, struct Vec
class EffectGYNMissile : HrTask
{
public:
	/// 2 namespace types: void __convention("thiscall") EffectGYNMissile::Set(class EffectGYNMissile* const this, struct Vec& arg2, float const arg3, class mHRChara* arg4), class EffectGYNMissile* EffectGYNMissile::Create(struct Vec& arg1, float const arg2, class mHRChara* arg3)

	// TODO: Function 'void __convention("thiscall") EffectGYNMissile::Set(class EffectGYNMissile* const this, struct Vec& arg2, float const arg3, class mHRChara* arg4)'
	// TODO: Function 'class EffectGYNMissile* EffectGYNMissile::Create(struct Vec& arg1, float const arg2, class mHRChara* arg3)'

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pTgtChar, offset 0x50>
	class mHRChara* m_pTgtChar;

	// <class TGmf* m_pMissileGmf, offset 0x54>
	class TGmf* m_pMissileGmf;

	// <struct Vec m_Pos, offset 0x58>
	struct Vec m_Pos;

	// <struct Vec m_BeforePos, offset 0x64>
	struct Vec m_BeforePos;

	// <struct Vec m_Rot, offset 0x70>
	struct Vec m_Rot;

	// <struct Vec m_MoveVec, offset 0x7c>
	struct Vec m_MoveVec;

	// <struct Vec m_LaunchVec, offset 0x88>
	struct Vec m_LaunchVec;

	// <float m_fRotYSpd, offset 0x94>
	float m_fRotYSpd;

	// <float m_fMoveSpd, offset 0x98>
	float m_fMoveSpd;

	// <int32_t m_Cnt, offset 0x9c>
	int32_t m_Cnt;

	// <int32_t m_SeHnd, offset 0xa0>
	int32_t m_SeHnd;

	// <uint8_t m_boHoming, offset 0xa4>
	uint8_t m_boHoming;

	// <Filler, offset 0xa5>
	char _Filler[3];

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectGYNMissile>("EffectGYNMissile")
			.addProperty("m_pTgtChar", &EffectGYNMissile::m_pTgtChar)
			.addProperty("m_pMissileGmf", &EffectGYNMissile::m_pMissileGmf)
			.addProperty("m_Pos", &EffectGYNMissile::m_Pos)
			.addProperty("m_BeforePos", &EffectGYNMissile::m_BeforePos)
			.addProperty("m_Rot", &EffectGYNMissile::m_Rot)
			.addProperty("m_MoveVec", &EffectGYNMissile::m_MoveVec)
			.addProperty("m_LaunchVec", &EffectGYNMissile::m_LaunchVec)
			.addProperty("m_fRotYSpd", &EffectGYNMissile::m_fRotYSpd)
			.addProperty("m_fMoveSpd", &EffectGYNMissile::m_fMoveSpd)
			.addProperty("m_Cnt", &EffectGYNMissile::m_Cnt)
			.addProperty("m_SeHnd", &EffectGYNMissile::m_SeHnd)
			.addProperty("m_boHoming", &EffectGYNMissile::m_boHoming)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectGYNMissile::m_pTgtChar) == 4, "expected m_pTgtChar to be size 4");
static_assert(sizeof(EffectGYNMissile::m_pMissileGmf) == 4, "expected m_pMissileGmf to be size 4");
static_assert(sizeof(EffectGYNMissile::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectGYNMissile::m_BeforePos) == 12, "expected m_BeforePos to be size 12");
static_assert(sizeof(EffectGYNMissile::m_Rot) == 12, "expected m_Rot to be size 12");
static_assert(sizeof(EffectGYNMissile::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(EffectGYNMissile::m_LaunchVec) == 12, "expected m_LaunchVec to be size 12");
static_assert(sizeof(EffectGYNMissile::m_fRotYSpd) == 4, "expected m_fRotYSpd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_fMoveSpd) == 4, "expected m_fMoveSpd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_Cnt) == 4, "expected m_Cnt to be size 4");
static_assert(sizeof(EffectGYNMissile::m_SeHnd) == 4, "expected m_SeHnd to be size 4");
static_assert(sizeof(EffectGYNMissile::m_boHoming) == 1, "expected m_boHoming to be size 1");
static_assert(sizeof(class EffectGYNMissile) == 168, "expected class EffectGYNMissile to be size 168");

// class EffectMoeMissile
// 2 dependencies: class HrTask, struct Vec
class EffectMoeMissile : HrTask
{
public:
	/// 2 namespace types: void __convention("thiscall") EffectMoeMissile::Set(class EffectMoeMissile* const this, struct Vec& arg2, float const arg3, class mHRChara* arg4), class EffectMoeMissile* EffectMoeMissile::Create(struct Vec& arg1, float const arg2, class mHRChara* arg3)

	// TODO: Function 'void __convention("thiscall") EffectMoeMissile::Set(class EffectMoeMissile* const this, struct Vec& arg2, float const arg3, class mHRChara* arg4)'
	// TODO: Function 'class EffectMoeMissile* EffectMoeMissile::Create(struct Vec& arg1, float const arg2, class mHRChara* arg3)'

	/// Struct member variables

	// <class HrTask field_0, offset 0x0>
	// class HrTask Super;

	// <class mHRChara* m_pTgtChar, offset 0x50>
	class mHRChara* m_pTgtChar;

	// <struct Vec m_Pos, offset 0x54>
	struct Vec m_Pos;

	// <struct Vec m_BeforePos, offset 0x60>
	struct Vec m_BeforePos;

	// <struct Vec m_Rot, offset 0x6c>
	struct Vec m_Rot;

	// <struct Vec m_MoveDir, offset 0x78>
	struct Vec m_MoveDir;

	// <struct Vec m_MoveVec, offset 0x84>
	struct Vec m_MoveVec;

	// <uint8_t m_boHoming, offset 0x90>
	uint8_t m_boHoming;

	// <Filler, offset 0x91>
	char _Filler8[3];

	// <class EffectFixFire* m_pFire, offset 0x94>
	class EffectFixFire* m_pFire;

	// <float m_MatRot[0x3][0x4], offset 0x98>
	float m_MatRot[3][4];

	// <float m_fSpd, offset 0xc8>
	float m_fSpd;

	// <class TGmf* m_pMissileGmf, offset 0xcc>
	class TGmf* m_pMissileGmf;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<EffectMoeMissile>("EffectMoeMissile")
			.addProperty("m_pTgtChar", &EffectMoeMissile::m_pTgtChar)
			.addProperty("m_Pos", &EffectMoeMissile::m_Pos)
			.addProperty("m_BeforePos", &EffectMoeMissile::m_BeforePos)
			.addProperty("m_Rot", &EffectMoeMissile::m_Rot)
			.addProperty("m_MoveDir", &EffectMoeMissile::m_MoveDir)
			.addProperty("m_MoveVec", &EffectMoeMissile::m_MoveVec)
			.addProperty("m_boHoming", &EffectMoeMissile::m_boHoming)
			.addProperty("m_pFire", &EffectMoeMissile::m_pFire)
			// static arrays are not supported in LuaBridge (only std::vector)
			//.addProperty("m_MatRot", &EffectMoeMissile::m_MatRot)
			.addProperty("m_fSpd", &EffectMoeMissile::m_fSpd)
			.addProperty("m_pMissileGmf", &EffectMoeMissile::m_pMissileGmf)
		.endClass();
	}
#endif
};
static_assert(sizeof(EffectMoeMissile::m_pTgtChar) == 4, "expected m_pTgtChar to be size 4");
static_assert(sizeof(EffectMoeMissile::m_Pos) == 12, "expected m_Pos to be size 12");
static_assert(sizeof(EffectMoeMissile::m_BeforePos) == 12, "expected m_BeforePos to be size 12");
static_assert(sizeof(EffectMoeMissile::m_Rot) == 12, "expected m_Rot to be size 12");
static_assert(sizeof(EffectMoeMissile::m_MoveDir) == 12, "expected m_MoveDir to be size 12");
static_assert(sizeof(EffectMoeMissile::m_MoveVec) == 12, "expected m_MoveVec to be size 12");
static_assert(sizeof(EffectMoeMissile::m_boHoming) == 1, "expected m_boHoming to be size 1");
static_assert(sizeof(EffectMoeMissile::m_pFire) == 4, "expected m_pFire to be size 4");
static_assert(sizeof(EffectMoeMissile::m_MatRot) == 48, "expected m_MatRot to be size 48");
static_assert(sizeof(EffectMoeMissile::m_fSpd) == 4, "expected m_fSpd to be size 4");
static_assert(sizeof(EffectMoeMissile::m_pMissileGmf) == 4, "expected m_pMissileGmf to be size 4");
static_assert(sizeof(class EffectMoeMissile) == 208, "expected class EffectMoeMissile to be size 208");

// class CMotionPlayer
// no dependencies
class CMotionPlayer
{
public:
	/// 2 namespace types: void __convention("thiscall") CMotionPlayer::begin(class CMotionPlayer* const this, class mHRChara* arg2), class CMotionPlayer::CElement

	// TODO: Function 'void __convention("thiscall") CMotionPlayer::begin(class CMotionPlayer* const this, class mHRChara* arg2)'
	// class CMotionPlayer::CElement
	// 1 dependencies: enum HRCAMERA_MODE
	class CElement
	{
	public:
		/// No namespace types
		/// Struct member variables

		// <int32_t m_nMotIndex, offset 0x0>
		int32_t m_nMotIndex;

		// <enum HRCAMERA_MODE m_eCamMode, offset 0x4>
		enum HRCAMERA_MODE m_eCamMode;

#ifdef WITH_LUA
		static void BindLua(luabridge::Namespace& NS)
		{
			NS = NS.beginClass<CMotionPlayer::CElement>("CMotionPlayer::CElement")
				.addProperty("m_nMotIndex", &CMotionPlayer::CElement::m_nMotIndex)
				.addProperty("m_eCamMode", &CMotionPlayer::CElement::m_eCamMode)
			.endClass();
		}
#endif
	};
	static_assert(sizeof(CMotionPlayer::CElement::m_nMotIndex) == 4, "expected m_nMotIndex to be size 4");
	static_assert(sizeof(CMotionPlayer::CElement::m_eCamMode) == 4, "expected m_eCamMode to be size 4");
	static_assert(sizeof(class CMotionPlayer::CElement) == 8, "expected class CMotionPlayer::CElement to be size 8");


	/// Struct member variables

	// <class CStlVector<CMotionPlayer::CElement> m_ainElement, offset 0x0>
	class std::vector<CMotionPlayer::CElement> m_ainElement;

	// <class mHRChara* m_pChara, offset 0xc>
	class mHRChara* m_pChara;

	// <int32_t m_nPlayIndex, offset 0x10>
	int32_t m_nPlayIndex;

#ifdef WITH_LUA
	static void BindLua(luabridge::Namespace& NS)
	{
		NS = NS.beginClass<CMotionPlayer>("CMotionPlayer")
			.addProperty("m_ainElement", &CMotionPlayer::m_ainElement)
			.addProperty("m_pChara", &CMotionPlayer::m_pChara)
			.addProperty("m_nPlayIndex", &CMotionPlayer::m_nPlayIndex)
		.endClass();
	}
#endif
};
static_assert(sizeof(CMotionPlayer::m_ainElement) == 12, "expected m_ainElement to be size 12");
static_assert(sizeof(CMotionPlayer::m_pChara) == 4, "expected m_pChara to be size 4");
static_assert(sizeof(CMotionPlayer::m_nPlayIndex) == 4, "expected m_nPlayIndex to be size 4");
static_assert(sizeof(class CMotionPlayer) == 20, "expected class CMotionPlayer to be size 20");

// TODO: Function 'void `dynamic atexit destructor for 'mHRChara::mCharaAnchor''()'

#ifdef WITH_LUA
/// Lua binding

void BindLua_Exported(luabridge::Namespace& NS)
{
	CSpringInterpolate::BindLua(NS);
	CDoubleSpringInterpolate::BindLua(NS);
	CAmbientShadow::BindLua(NS);
	stCharaEffect::BindLua(NS);
	stCharaFileData::BindLua(NS);
	Vec::BindLua(NS);
	ghmSegment::BindLua(NS);
	ghmCapsule::BindLua(NS);
	ghmGcOctTreeNodeObj::BindLua(NS);
	ghmGcCollObj::BindLua(NS);
	ghmGcCollObjCapsule::BindLua(NS);
	WAnim::BindLua(NS);
	WAnimF::BindLua(NS);
	stDamageInfo::BindLua(NS);
	ghmTriangle::BindLua(NS);
	ghmPlane::BindLua(NS);
	ghmGcCollObjHitResultObj::BindLua(NS);
	stVec::BindLua(NS);
	Quaternion::BindLua(NS);
	stCharaStatus::BindLua(NS);
	ghmListObj::BindLua(NS);
	mHRChara::BindLua(NS);
	ghmAABB::BindLua(NS);
	ghmGcOctTreeNode::BindLua(NS);
	ghmGcOctTree::BindLua(NS);
	ghmGcCollObjHitResult::BindLua(NS);
	WGclMaterialSpec::BindLua(NS);
	EE::SmartPtr<EE::IFile>::BindLua(NS);
	DVDCommandBlock::BindLua(NS);
	DVDFileInfo::BindLua(NS);
	ghmGcFile::ghmGcFileInfo::BindLua(NS);
	ghmGcFile::BindLua(NS);
	DVDDiskID::BindLua(NS);
	EE::RefObject::BindLua(NS);
	EE::IFile::BindLua(NS);
	ghmResGroup::BindLua(NS);
	ghmResStrTable::BindLua(NS);
	__m128::BindLua(NS);
	vector4f::BindLua(NS);
	vector4x::BindLua(NS);
	tiVector::BindLua(NS);
	mot::IBoneEffectModel::BindLua(NS);
	mot::IBoneEffectModelPJ::BindLua(NS);
	TGmf::tagMAIN::BindLua(NS);
	TGmf::BindLua(NS);
	TGanPlay::MAIN::BindLua(NS);
	TGanPlay::BindLua(NS);
	TGan::tagMAIN::BindLua(NS);
	TGan::BindLua(NS);
	WGanSpec::BindLua(NS);
	WGanMaterialSpec::BindLua(NS);
	WGanFAnmSpec::BindLua(NS);
	_WFAnmObjHeader::BindLua(NS);
	_WFAnmObjKeyListHeader::BindLua(NS);
	WGanMaterialLayerSpec::BindLua(NS);
	WGanNodeSpec::BindLua(NS);
	TGanPlayNode::MAIN::BindLua(NS);
	TGanPlayNode::BindLua(NS);
	TFAnm::tagMAIN::BindLua(NS);
	TFAnm::BindLua(NS);
	TGmfNode::tagMAIN::BindLua(NS);
	TGmfNode::BindLua(NS);
	CViewClipObjSphere::BindLua(NS);
	CViewClipObjBox::BindLua(NS);
	rPrimUnific::BindLua(NS);
	EfBase::BindLua(NS);
	HrTask::BindLua(NS);
	EfDestortion::BindLua(NS);
	TGMFMESH::BindLua(NS);
	GXTexObj::BindLua(NS);
	tagGHMR_TEX::BindLua(NS);
	GXSamplerStuff::BindLua(NS);
	GXTexture::GXSpecs::BindLua(NS);
	GXTexture::BindLua(NS);
	rAlphaAnime::BindLua(NS);
	rAnimeCounter::BindLua(NS);
	rST::BindLua(NS);
	rColor::BindLua(NS);
	rPrimBase::BindLua(NS);
	rTriangleList::BindLua(NS);
	CVertexAnimation::CVertex::BindLua(NS);
	CVertexAnimation::BindLua(NS);
	TFAnmObjF32_3::tagMAIN::BindLua(NS);
	TFAnmObjF32_3::BindLua(NS);
	_WFAnmVal::BindLua(NS);
	TFAnmObj::tagGETA::BindLua(NS);
	TFAnmObj::tagMAIN::BindLua(NS);
	TFAnmObj::BindLua(NS);
	mot::IBoneEffectPJ::BindLua(NS);
	CCameraVibTiming::BindLua(NS);
	HRCHARAVOICE::BindLua(NS);
	gameUtil::CPlane::BindLua(NS);
	CStickShadow::BindLua(NS);
	CharControlMotID::BindLua(NS);
	CharController::BindLua(NS);
	CTimeRatioInterpolate::BindLua(NS);
	uniSMflag::BindLua(NS);
	stFade::BindLua(NS);
	HROBJDummy::BindLua(NS);
	stTiger::BindLua(NS);
	stHugWalk::BindLua(NS);
	stPcEffect::BindLua(NS);
	stPcSndData::BindLua(NS);
	stDarkSideInfo::BindLua(NS);
	stPcSaveData::BindLua(NS);
	stMiniDemo::BindLua(NS);
	stPcStatus::BindLua(NS);
	mHRPc::BindLua(NS);
	CObjectShadow::BindLua(NS);
	stBikeEffect::BindLua(NS);
	stBike::BindLua(NS);
	mHRBike::BindLua(NS);
	EventAreaCircle::BindLua(NS);
	ghmScriptVariables::BindLua(NS);
	ghmScript::BindLua(NS);
	ghmScriptFunc::BindLua(NS);
	HrScriptFunc::BindLua(NS);
	ghmScriptBase::BindLua(NS);
	CCameraCollision::BindLua(NS);
	FkPjLib::BindLua(NS);
	ghmScriptFuncArgBase::BindLua(NS);
	ghmScriptObjectType::BindLua(NS);
	ghmScriptObject::BindLua(NS);
	ghmString::BindLua(NS);
	ghmScrHeader::BindLua(NS);
	ghmScrFuncHeader::BindLua(NS);
	ghmScriptProgFunc::BindLua(NS);
	ghmScriptStackData::BindLua(NS);
	ghmScriptStack::BindLua(NS);
	ghmScriptContext::BindLua(NS);
	EveCorn::BindLua(NS);
	EventAreaCamera::BindLua(NS);
	EVENTAREACAMERA_DATA::BindLua(NS);
	EffectDriftMark::BindLua(NS);
	EffectKeepSmoke::BindLua(NS);
	rQuad::BindLua(NS);
	GXColor::BindLua(NS);
	EffectFixFire::Object::BindLua(NS);
	EffectFixFire::BindLua(NS);
	HrOverLap::BindLua(NS);
	WGcl::BindLua(NS);
	commonObj::BindLua(NS);
	CustomColliderObj::BindLua(NS);
	WGclSpec::BindLua(NS);
	WGclNodeSpec::BindLua(NS);
	WGclNodeShapeMeshSpec::BindLua(NS);
	WGclNodeShapeMeshBspNodeSpec::BindLua(NS);
	WGclNodeShapeTriangleSpec::BindLua(NS);
	ghmGcColl::BindLua(NS);
	WGclNode::BindLua(NS);
	mot::CBoneEffectDamageData::BindLua(NS);
	mHRLockOnList::BindLua(NS);
	NYPhase::BindLua(NS);
	NYApproachToTargetVal::BindLua(NS);
	HrBattleIcon::CHrHpGauge::BindLua(NS);
	HrBattleIcon::BindLua(NS);
	HrMap::BindLua(NS);
	ACameraModeBase::BindLua(NS);
	CCameraModeLockOn::BindLua(NS);
	CCameraVibManager::BindLua(NS);
	CCameraBank::BindLua(NS);
	CCameraModeSubjective::BindLua(NS);
	CSpringInterpolate3D::BindLua(NS);
	CDoubleSpringInterpolate3D::BindLua(NS);
	CCameraModePetitMovie::BindLua(NS);
	CCameraModeCircle::BindLua(NS);
	CCameraModeDefaultAngle::BindLua(NS);
	CCameraModeFree::BindLua(NS);
	CCameraModeNormal::BindLua(NS);
	CCameraModeReset::BindLua(NS);
	CCameraDistToLookAt::BindLua(NS);
	CCameraFollowRot::BindLua(NS);
	CCameraLookAtOffset::BindLua(NS);
	CCameraLookAtBase::BindLua(NS);
	CCameraDefaultAngle::BindLua(NS);
	CCameraLockOnModeData::BindLua(NS);
	CCameraNormalModeData::BindLua(NS);
	CCameraModeCommonData::BindLua(NS);
	CGameDataLink::BindLua(NS);
	CCameraDataManager::BindLua(NS);
	CCameraAreaManager::BindLua(NS);
	gameUtil::CPositionControl::BindLua(NS);
	CCameraTarget::BindLua(NS);
	ti::CCamera::BindLua(NS);
	CGameCamera::BindLua(NS);
	CCameraman::BindLua(NS);
	CGameData::BindLua(NS);
	CPackFileDataElement::BindLua(NS);
	CFileData::BindLua(NS);
	CPackFileData::BindLua(NS);
	CGameDataManager::BindLua(NS);
	mHRBattle::BindLua(NS);
	HrMiniDemoObj::BindLua(NS);
	HrMiniDemoModel::BindLua(NS);
	STG0202::BindLua(NS);
	PJTateshi::BindLua(NS);
	PJState::BindLua(NS);
	ZkState_DownAttack::BindLua(NS);
	State_AwayAfterAttack::BindLua(NS);
	State_CloseBeforeAttack::BindLua(NS);
	State_StepInAttack::BindLua(NS);
	State_DownDamage::BindLua(NS);
	State_TojoBaseState::BindLua(NS);
	State_LeadPcWayPointMove::BindLua(NS);
	State_FixTurret::BindLua(NS);
	State_WayPointMoveAfterPop::BindLua(NS);
	State_Tojo_RoomRunner::BindLua(NS);
	State_Tojo_AeroBike::BindLua(NS);
	State_Tojo_BreakCmnObj::BindLua(NS);
	State_Tojo_JumpOff::BindLua(NS);
	State_Tojo_Car::BindLua(NS);
	State_Tojo_RunAndTurnPc::BindLua(NS);
	State_Idle::BindLua(NS);
	State_Tojo_AgainstWall::BindLua(NS);
	State_Tojo_LookAround::BindLua(NS);
	State_Tojo_Stand::BindLua(NS);
	State_Tojo_Bench::BindLua(NS);
	State_Tojo_Sit::BindLua(NS);
	State_Tojo_SuddenAttack::BindLua(NS);
	State_ReleaseWaitIdle::BindLua(NS);
	State_Scare_Base::BindLua(NS);
	State_Scare_Kosinukasi::BindLua(NS);
	State_Scare_Run::BindLua(NS);
	State_WayPointMove::BindLua(NS);
	State_Pressure::BindLua(NS);
	State_ThroughDamage::BindLua(NS);
	State_Defence::BindLua(NS);
	State_Evacuate::BindLua(NS);
	State_ComboAttack::BindLua(NS);
	State_Damage::BindLua(NS);
	CollInfo::BindLua(NS);
	tagHRTASKCHECK::BindLua(NS);
	ZkGuardParam::BindLua(NS);
	ZkEvacuateParam::BindLua(NS);
	FkCounter::BindLua(NS);
	ZkSetDamageInfo::BindLua(NS);
	State_Scare_Yotunbai::BindLua(NS);
	State_Scare_Stand::BindLua(NS);
	State_RandomMove::BindLua(NS);
	State_PerformIll::BindLua(NS);
	PJZAKO::ZakoInfo::BindLua(NS);
	PJZAKO::MotionInfo::BindLua(NS);
	PJZAKO::TojoInfo::BindLua(NS);
	PJZAKO::PcInfo::BindLua(NS);
	PJZAKO::DmgInfo::BindLua(NS);
	PJZAKO::AiInfo::BindLua(NS);
	PJZAKO::EfDanmen::BindLua(NS);
	PJZAKO::BindLua(NS);
	PJStateMachine::BindLua(NS);
	EffectDanmenFlash::BindLua(NS);
	EffectCutMark::BindLua(NS);
	EffectQuestion::BindLua(NS);
	PJZakoMotMng::BindLua(NS);
	PathPlanner::BindLua(NS);
	FkDynamicParam::DynamicParam::BindLua(NS);
	FkDynamicParam::BindLua(NS);
	FkObstacleSensor::BindLua(NS);
	FkBulletManager::stEfBullet::BindLua(NS);
	FkBulletManager::DmgInfo::BindLua(NS);
	FkBulletManager::BindLua(NS);
	EffectFkTobiDoguBase::strHitCheck::BindLua(NS);
	EffectFkTobiDoguBase::HitObjInfo::BindLua(NS);
	EffectFkTobiDoguBase::BindLua(NS);
	rQuadEx::BindLua(NS);
	EffectGunTrack::BindLua(NS);
	pcSNB::BindLua(NS);
	State_Tojo_Knife_SuddenAttack::BindLua(NS);
	ZkKnifeState_ThroughKnife::BindLua(NS);
	PJZAKOBoneB::BindLua(NS);
	PJZakoKnife::BindLua(NS);
	bsSKE::BindLua(NS);
	bsLEZ::BindLua(NS);
	bsCEW::BindLua(NS);
	bsAST::BindLua(NS);
	bsRKT::BindLua(NS);
	KrBaseState<bsBasic>::BindLua(NS);
	GLBDeathState::BindLua(NS);
	GLBWalkState::BindLua(NS);
	GLBComboState::BindLua(NS);
	GLBIdleState::BindLua(NS);
	GLBJampState::BindLua(NS);
	KrStateMachine<pcGLB,32>::BindLua(NS);
	rSideScrollCamera::BindLua(NS);
	GLBDamageState::BindLua(NS);
	GLBGuardState::BindLua(NS);
	GLBAirKickState::BindLua(NS);
	pcGLB::DmgInfo::BindLua(NS);
	pcGLB::TickCnt::BindLua(NS);
	pcGLB::BindLua(NS);
	EfRoboInterface::BindLua(NS);
	EffectSpeedBlur::BindLua(NS);
	CmDeathState::BindLua(NS);
	SDPDeathState::BindLua(NS);
	SDPComboState::BindLua(NS);
	CmDamageState::BindLua(NS);
	SDPDamageState::BindLua(NS);
	SDPBeamState::BindLua(NS);
	CmIdleState::BindLua(NS);
	SDPIdleState::BindLua(NS);
	bsBasic::PcInfo::BindLua(NS);
	bsBasic::SurroundInfo::BindLua(NS);
	bsBasic::DistSense::BindLua(NS);
	bsBasic::TickCnt::BindLua(NS);
	bsBasic::BattleParam::BindLua(NS);
	bsBasic::DmgInfo::BindLua(NS);
	bsBasic::BindLua(NS);
	SDPMoveState::BindLua(NS);
	SDPGuardState::BindLua(NS);
	bsSDP::BindLua(NS);
	FkTriangleList::BindLua(NS);
	EffectModelBeam::BindLua(NS);
	FkVtx::BindLua(NS);
	EfGeneralBeam::BindLua(NS);
	PJOBJ0029::BindLua(NS);
	PJOBJ0033::BindLua(NS);
	EFFECTSIMPLEOBJ3PARAM::BindLua(NS);
	EFFECTMODELFIREPARAM::BindLua(NS);
	EffectModelFire::MAIN::BindLua(NS);
	EffectModelFire::BindLua(NS);
	EffectSimpleObj3::MAIN::BindLua(NS);
	EffectSimpleObj3::OBJECT::BindLua(NS);
	EffectSimpleObj3::BindLua(NS);
	tagTLIST::BindLua(NS);
	PJOBJ0036::BindLua(NS);
	PJOBJ0037::BindLua(NS);
	PJOBJ0104::BindLua(NS);
	PJOBJ0155::BindLua(NS);
	PJOBJ0190::BindLua(NS);
	PJPTR::BindLua(NS);
	EffectEnemyDamage::BindLua(NS);
	FkDbgInfo_EventArea::BindLua(NS);
	FkGlobalDBG::CommonObjSetInf::BindLua(NS);
	FkGlobalDBG::BindLua(NS);
	EffectBloodSplash::MAIN::BindLua(NS);
	EffectBloodSplash::BindLua(NS);
	EffectSimpleObj2::MAIN::BindLua(NS);
	EffectSimpleObj2::BindLua(NS);
	EffectSlashHit::BindLua(NS);
	FkBoss::GuardParam::BindLua(NS);
	FkBoss::BindLua(NS);
	EffectSlashTrack::BindLua(NS);
	EffectBeamDragon::BindLua(NS);
	EffectGYNMissile::BindLua(NS);
	EffectMoeMissile::BindLua(NS);
	CMotionPlayer::CElement::BindLua(NS);
	CMotionPlayer::BindLua(NS);
}
#endif
